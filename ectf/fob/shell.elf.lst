
shell.elf:     file format elf32-littlearm


Disassembly of section .data:

20000000 <__echo>:
20000000:	00000001 	andeq	r0, r0, r1

20000004 <AES_key_b64>:
#include "shell_config.h"
#include "string.h"

// AES control struct and default key set here
struct AES_ctx ctx;
uint8_t AES_key_b64[44] = "3q2+796tvu/erb7v3q2+796tvu/erb7v3q2+796tvu8=";
20000004:	2b327133 	blcs	20c9c4d8 <_STACK_TOP_+0xc944dc>
20000008:	74363937 	ldrtvc	r3, [r6], #-2359	@ 0xfffff6c9
2000000c:	652f7576 	strvs	r7, [pc, #-1398]!	@ 1ffffa9e <__ROM_SIZE__+0x1ffbfa9e>
20000010:	76376272 			@ <UNDEFINED> instruction: 0x76376272
20000014:	2b327133 	blcs	20c9c4e8 <_STACK_TOP_+0xc944ec>
20000018:	74363937 	ldrtvc	r3, [r6], #-2359	@ 0xfffff6c9
2000001c:	652f7576 	strvs	r7, [pc, #-1398]!	@ 1ffffaae <__ROM_SIZE__+0x1ffbfaae>
20000020:	76376272 			@ <UNDEFINED> instruction: 0x76376272
20000024:	2b327133 	blcs	20c9c4f8 <_STACK_TOP_+0xc944fc>
20000028:	74363937 	ldrtvc	r3, [r6], #-2359	@ 0xfffff6c9
2000002c:	3d387576 	cfldr32cc	mvfx7, [r8, #-472]!	@ 0xfffffe28

20000030 <ECDH_privkey_b64>:
uint8_t AES_key[AES_KEYLEN];

uint8_t ECDH_privkey_b64[32] = "DeyvDeyvDeyvDeyvDeyvDeyvDeyvDeyv";
20000030:	76796544 	ldrbtvc	r6, [r9], -r4, asr #10
20000034:	76796544 	ldrbtvc	r6, [r9], -r4, asr #10
20000038:	76796544 	ldrbtvc	r6, [r9], -r4, asr #10
2000003c:	76796544 	ldrbtvc	r6, [r9], -r4, asr #10
20000040:	76796544 	ldrbtvc	r6, [r9], -r4, asr #10
20000044:	76796544 	ldrbtvc	r6, [r9], -r4, asr #10
20000048:	76796544 	ldrbtvc	r6, [r9], -r4, asr #10
2000004c:	76796544 	ldrbtvc	r6, [r9], -r4, asr #10

Disassembly of section .bss:

20000050 <__write_char__>:
20000050:	00000000 	andeq	r0, r0, r0

20000054 <total_num_commands>:
 * To reduce the shell size the history feature
 * is made optional. Skip history feature if
 * SHELL_NO_HISTORY is defined.
 */
#ifndef SHELL_NO_HISTORY
static volatile int total_num_commands = 0;
20000054:	00000000 	andeq	r0, r0, r0

20000058 <cmd_history>:
	...

20000158 <__cmd_exec_status>:
static volatile int __cmd_exec_status;
20000158:	00000000 	andeq	r0, r0, r0

2000015c <curr_command_ptr>:
static volatile int curr_command_ptr = 0;
2000015c:	00000000 	andeq	r0, r0, r0

20000160 <__read_char__>:
int (*__read_char__)(void);
20000160:	00000000 	andeq	r0, r0, r0

20000164 <__read_char2__>:
int (*__read_char2__)(void);
20000164:	00000000 	andeq	r0, r0, r0

20000168 <__write_char2__>:
void (*__write_char2__)(char c);
20000168:	00000000 	andeq	r0, r0, r0

2000016c <AES_key>:
	...

2000018c <ctx>:
	...

2000028c <ECDH_AESkey>:
	...

200002ac <ECDH_shared>:
	...

200002dc <ECDH_pubkey>:
	...

2000030c <ECDH_privkey>:
	...

20000324 <selected_mode>:

#include "memlog.h"
#include "string.h"

static rgn_info_t inp_buf_rgn, out_buf_rgn;
static mode_t selected_mode = NONE;
20000324:	00000000 	andeq	r0, r0, r0

20000328 <out_buf_rgn>:
	...

20000334 <inp_buf_rgn>:
	...

Disassembly of section .text:

00000000 <vector_table>:
       0:	20007ffc 	strdcs	r7, [r0], -ip
       4:	000027e5 	andeq	r2, r0, r5, ror #15
       8:	000004d5 	ldrdeq	r0, [r0], -r5
       c:	000004d5 	ldrdeq	r0, [r0], -r5
      10:	000004d5 	ldrdeq	r0, [r0], -r5
      14:	000004d5 	ldrdeq	r0, [r0], -r5
      18:	000004d5 	ldrdeq	r0, [r0], -r5
	...
      2c:	000004d5 	ldrdeq	r0, [r0], -r5
      30:	000004d5 	ldrdeq	r0, [r0], -r5
      34:	000004d5 	ldrdeq	r0, [r0], -r5
	...
      40:	000004d5 	ldrdeq	r0, [r0], -r5
      44:	000004d5 	ldrdeq	r0, [r0], -r5
      48:	000004d5 	ldrdeq	r0, [r0], -r5
      4c:	000004d5 	ldrdeq	r0, [r0], -r5
      50:	000004d5 	ldrdeq	r0, [r0], -r5
      54:	000004d5 	ldrdeq	r0, [r0], -r5
      58:	000004d5 	ldrdeq	r0, [r0], -r5
      5c:	000004d5 	ldrdeq	r0, [r0], -r5
      60:	000004d5 	ldrdeq	r0, [r0], -r5
      64:	000004d5 	ldrdeq	r0, [r0], -r5
      68:	000004d5 	ldrdeq	r0, [r0], -r5
      6c:	000004d5 	ldrdeq	r0, [r0], -r5
      70:	000004d5 	ldrdeq	r0, [r0], -r5
      74:	000004d5 	ldrdeq	r0, [r0], -r5
      78:	000004d5 	ldrdeq	r0, [r0], -r5
      7c:	000004d5 	ldrdeq	r0, [r0], -r5
      80:	000004d5 	ldrdeq	r0, [r0], -r5
      84:	000004d5 	ldrdeq	r0, [r0], -r5
      88:	000004d5 	ldrdeq	r0, [r0], -r5
      8c:	000004d5 	ldrdeq	r0, [r0], -r5
      90:	000004d5 	ldrdeq	r0, [r0], -r5
      94:	000004d5 	ldrdeq	r0, [r0], -r5
      98:	000004d5 	ldrdeq	r0, [r0], -r5
      9c:	000004d5 	ldrdeq	r0, [r0], -r5
      a0:	000004d5 	ldrdeq	r0, [r0], -r5
      a4:	000004d5 	ldrdeq	r0, [r0], -r5
      a8:	000004d5 	ldrdeq	r0, [r0], -r5
      ac:	000004d5 	ldrdeq	r0, [r0], -r5
      b0:	000004d5 	ldrdeq	r0, [r0], -r5
      b4:	000004d5 	ldrdeq	r0, [r0], -r5
      b8:	000004d5 	ldrdeq	r0, [r0], -r5
      bc:	000004d5 	ldrdeq	r0, [r0], -r5
      c0:	000004d5 	ldrdeq	r0, [r0], -r5
      c4:	000004d5 	ldrdeq	r0, [r0], -r5
      c8:	000004d5 	ldrdeq	r0, [r0], -r5
      cc:	000004d5 	ldrdeq	r0, [r0], -r5
      d0:	000004d5 	ldrdeq	r0, [r0], -r5
      d4:	000004d5 	ldrdeq	r0, [r0], -r5
      d8:	000004d5 	ldrdeq	r0, [r0], -r5
      dc:	000004d5 	ldrdeq	r0, [r0], -r5
      e0:	000004d5 	ldrdeq	r0, [r0], -r5
      e4:	000004d5 	ldrdeq	r0, [r0], -r5
      e8:	000004d5 	ldrdeq	r0, [r0], -r5
      ec:	000004d5 	ldrdeq	r0, [r0], -r5
      f0:	000004d5 	ldrdeq	r0, [r0], -r5
      f4:	000004d5 	ldrdeq	r0, [r0], -r5
      f8:	000004d5 	ldrdeq	r0, [r0], -r5
      fc:	000004d5 	ldrdeq	r0, [r0], -r5
     100:	000004d5 	ldrdeq	r0, [r0], -r5
     104:	000004d5 	ldrdeq	r0, [r0], -r5
     108:	000004d5 	ldrdeq	r0, [r0], -r5
     10c:	000004d5 	ldrdeq	r0, [r0], -r5
     110:	000004d5 	ldrdeq	r0, [r0], -r5
     114:	000004d5 	ldrdeq	r0, [r0], -r5
     118:	000004d5 	ldrdeq	r0, [r0], -r5
     11c:	000004d5 	ldrdeq	r0, [r0], -r5
     120:	000004d5 	ldrdeq	r0, [r0], -r5
     124:	000004d5 	ldrdeq	r0, [r0], -r5
     128:	000004d5 	ldrdeq	r0, [r0], -r5
     12c:	000004d5 	ldrdeq	r0, [r0], -r5
     130:	000004d5 	ldrdeq	r0, [r0], -r5
     134:	000004d5 	ldrdeq	r0, [r0], -r5
     138:	000004d5 	ldrdeq	r0, [r0], -r5
     13c:	000004d5 	ldrdeq	r0, [r0], -r5
     140:	000004d5 	ldrdeq	r0, [r0], -r5
     144:	000004d5 	ldrdeq	r0, [r0], -r5
     148:	000004d5 	ldrdeq	r0, [r0], -r5
     14c:	000004d5 	ldrdeq	r0, [r0], -r5
     150:	000004d5 	ldrdeq	r0, [r0], -r5
     154:	000004d5 	ldrdeq	r0, [r0], -r5
     158:	000004d5 	ldrdeq	r0, [r0], -r5
     15c:	000004d5 	ldrdeq	r0, [r0], -r5
     160:	000004d5 	ldrdeq	r0, [r0], -r5
     164:	000004d5 	ldrdeq	r0, [r0], -r5
     168:	000004d5 	ldrdeq	r0, [r0], -r5
     16c:	000004d5 	ldrdeq	r0, [r0], -r5
     170:	000004d5 	ldrdeq	r0, [r0], -r5
     174:	000004d5 	ldrdeq	r0, [r0], -r5
     178:	000004d5 	ldrdeq	r0, [r0], -r5
     17c:	000004d5 	ldrdeq	r0, [r0], -r5
     180:	000004d5 	ldrdeq	r0, [r0], -r5
     184:	000004d5 	ldrdeq	r0, [r0], -r5
     188:	000004d5 	ldrdeq	r0, [r0], -r5
     18c:	000004d5 	ldrdeq	r0, [r0], -r5
     190:	000004d5 	ldrdeq	r0, [r0], -r5
     194:	000004d5 	ldrdeq	r0, [r0], -r5
     198:	000004d5 	ldrdeq	r0, [r0], -r5
     19c:	000004d5 	ldrdeq	r0, [r0], -r5
     1a0:	000004d5 	ldrdeq	r0, [r0], -r5
     1a4:	000004d5 	ldrdeq	r0, [r0], -r5
     1a8:	000004d5 	ldrdeq	r0, [r0], -r5
     1ac:	000004d5 	ldrdeq	r0, [r0], -r5
     1b0:	000004d5 	ldrdeq	r0, [r0], -r5
     1b4:	000004d5 	ldrdeq	r0, [r0], -r5
     1b8:	000004d5 	ldrdeq	r0, [r0], -r5
     1bc:	000004d5 	ldrdeq	r0, [r0], -r5
     1c0:	000004d5 	ldrdeq	r0, [r0], -r5
     1c4:	000004d5 	ldrdeq	r0, [r0], -r5
     1c8:	000004d5 	ldrdeq	r0, [r0], -r5
     1cc:	000004d5 	ldrdeq	r0, [r0], -r5
     1d0:	000004d5 	ldrdeq	r0, [r0], -r5
     1d4:	000004d5 	ldrdeq	r0, [r0], -r5
     1d8:	000004d5 	ldrdeq	r0, [r0], -r5
     1dc:	000004d5 	ldrdeq	r0, [r0], -r5
     1e0:	000004d5 	ldrdeq	r0, [r0], -r5
     1e4:	000004d5 	ldrdeq	r0, [r0], -r5
     1e8:	000004d5 	ldrdeq	r0, [r0], -r5
     1ec:	000004d5 	ldrdeq	r0, [r0], -r5
     1f0:	000004d5 	ldrdeq	r0, [r0], -r5
     1f4:	000004d5 	ldrdeq	r0, [r0], -r5
     1f8:	000004d5 	ldrdeq	r0, [r0], -r5
     1fc:	000004d5 	ldrdeq	r0, [r0], -r5
     200:	000004d5 	ldrdeq	r0, [r0], -r5
     204:	000004d5 	ldrdeq	r0, [r0], -r5
     208:	000004d5 	ldrdeq	r0, [r0], -r5
     20c:	000004d5 	ldrdeq	r0, [r0], -r5
     210:	000004d5 	ldrdeq	r0, [r0], -r5
     214:	000004d5 	ldrdeq	r0, [r0], -r5
     218:	000004d5 	ldrdeq	r0, [r0], -r5
     21c:	000004d5 	ldrdeq	r0, [r0], -r5
     220:	000004d5 	ldrdeq	r0, [r0], -r5
     224:	000004d5 	ldrdeq	r0, [r0], -r5
     228:	000004d5 	ldrdeq	r0, [r0], -r5
     22c:	000004d5 	ldrdeq	r0, [r0], -r5
     230:	000004d5 	ldrdeq	r0, [r0], -r5
     234:	000004d5 	ldrdeq	r0, [r0], -r5
     238:	000004d5 	ldrdeq	r0, [r0], -r5
     23c:	000004d5 	ldrdeq	r0, [r0], -r5
     240:	000004d5 	ldrdeq	r0, [r0], -r5
     244:	000004d5 	ldrdeq	r0, [r0], -r5
     248:	000004d5 	ldrdeq	r0, [r0], -r5
     24c:	000004d5 	ldrdeq	r0, [r0], -r5
	...

000003c0 <car_mesg>:

#include "shell.h"

extern struct AES_ctx ctx;

int car_mesg(int argc, char** argv) {
     3c0:	b570      	push	{r4, r5, r6, lr}
     3c2:	b09a      	sub	sp, #104	@ 0x68
     3c4:	4605      	mov	r5, r0
     3c6:	460e      	mov	r6, r1
    int ctr;
    printf("Received a message from the car:");
     3c8:	4834      	ldr	r0, [pc, #208]	@ (49c <car_mesg+0xdc>)
     3ca:	f001 f95f 	bl	168c <printf>
    for (ctr = 1; ctr < argc; ctr++) {
     3ce:	2401      	movs	r4, #1
     3d0:	e005      	b.n	3de <car_mesg+0x1e>
        printf(" %s", argv[ctr]);
     3d2:	f856 1024 	ldr.w	r1, [r6, r4, lsl #2]
     3d6:	4832      	ldr	r0, [pc, #200]	@ (4a0 <car_mesg+0xe0>)
     3d8:	f001 f958 	bl	168c <printf>
    for (ctr = 1; ctr < argc; ctr++) {
     3dc:	3401      	adds	r4, #1
     3de:	42ac      	cmp	r4, r5
     3e0:	dbf7      	blt.n	3d2 <car_mesg+0x12>
    }
    printf("\n");
     3e2:	4830      	ldr	r0, [pc, #192]	@ (4a4 <car_mesg+0xe4>)
     3e4:	f001 f952 	bl	168c <printf>

    if (argc > 1) {
     3e8:	2d01      	cmp	r5, #1
     3ea:	dc02      	bgt.n	3f2 <car_mesg+0x32>
            printf("Didn't know how to handle %s\n", argv[1]);
        }

    }
    return 0;
}
     3ec:	2000      	movs	r0, #0
     3ee:	b01a      	add	sp, #104	@ 0x68
     3f0:	bd70      	pop	{r4, r5, r6, pc}
        if (strcmp(argv[1], "PING_REPLY") == 0) {
     3f2:	492d      	ldr	r1, [pc, #180]	@ (4a8 <car_mesg+0xe8>)
     3f4:	6870      	ldr	r0, [r6, #4]
     3f6:	f002 f9cd 	bl	2794 <strcmp>
     3fa:	b918      	cbnz	r0, 404 <car_mesg+0x44>
            printf("Got a ping reply.\n");
     3fc:	482b      	ldr	r0, [pc, #172]	@ (4ac <car_mesg+0xec>)
     3fe:	f001 f945 	bl	168c <printf>
     402:	e7f3      	b.n	3ec <car_mesg+0x2c>
        else if (strcmp(argv[1], "AESB64") == 0) {
     404:	492a      	ldr	r1, [pc, #168]	@ (4b0 <car_mesg+0xf0>)
     406:	6870      	ldr	r0, [r6, #4]
     408:	f002 f9c4 	bl	2794 <strcmp>
     40c:	b9f8      	cbnz	r0, 44e <car_mesg+0x8e>
            if (argc == 3) { 
     40e:	2d03      	cmp	r5, #3
     410:	d003      	beq.n	41a <car_mesg+0x5a>
                printf("Missing AESB64 encoded message\n");
     412:	4828      	ldr	r0, [pc, #160]	@ (4b4 <car_mesg+0xf4>)
     414:	f001 f93a 	bl	168c <printf>
     418:	e7e8      	b.n	3ec <car_mesg+0x2c>
                len = decode_base64((uint8_t *) argv[2], strlen(argv[2]), decoded);
     41a:	68b4      	ldr	r4, [r6, #8]
     41c:	4620      	mov	r0, r4
     41e:	f002 f9b1 	bl	2784 <strlen>
     422:	4601      	mov	r1, r0
     424:	aa01      	add	r2, sp, #4
     426:	4620      	mov	r0, r4
     428:	f000 feac 	bl	1184 <decode_base64>
     42c:	4604      	mov	r4, r0
                AES_ECB_decrypt(&ctx, decoded);
     42e:	a901      	add	r1, sp, #4
     430:	4821      	ldr	r0, [pc, #132]	@ (4b8 <car_mesg+0xf8>)
     432:	f001 fde3 	bl	1ffc <AES_ECB_decrypt>
                decoded[len] = '\0';
     436:	f104 0368 	add.w	r3, r4, #104	@ 0x68
     43a:	eb0d 0403 	add.w	r4, sp, r3
     43e:	2300      	movs	r3, #0
     440:	f804 3c64 	strb.w	r3, [r4, #-100]
                printf("Decoded/decrypted as %s\n", decoded);
     444:	a901      	add	r1, sp, #4
     446:	481d      	ldr	r0, [pc, #116]	@ (4bc <car_mesg+0xfc>)
     448:	f001 f920 	bl	168c <printf>
     44c:	e7ce      	b.n	3ec <car_mesg+0x2c>
        else if (strcmp(argv[1], "B64") == 0) {
     44e:	491c      	ldr	r1, [pc, #112]	@ (4c0 <car_mesg+0x100>)
     450:	6870      	ldr	r0, [r6, #4]
     452:	f002 f99f 	bl	2794 <strcmp>
     456:	b9e0      	cbnz	r0, 492 <car_mesg+0xd2>
            if (argc == 3) { 
     458:	2d03      	cmp	r5, #3
     45a:	d003      	beq.n	464 <car_mesg+0xa4>
                printf("Missing Base64 encoded message\n");
     45c:	4819      	ldr	r0, [pc, #100]	@ (4c4 <car_mesg+0x104>)
     45e:	f001 f915 	bl	168c <printf>
     462:	e7c3      	b.n	3ec <car_mesg+0x2c>
                printf("Decoding Base64\n");
     464:	4818      	ldr	r0, [pc, #96]	@ (4c8 <car_mesg+0x108>)
     466:	f001 f911 	bl	168c <printf>
                len = decode_base64((uint8_t *) argv[2], strlen(argv[2]), decoded);
     46a:	68b4      	ldr	r4, [r6, #8]
     46c:	4620      	mov	r0, r4
     46e:	f002 f989 	bl	2784 <strlen>
     472:	4601      	mov	r1, r0
     474:	aa01      	add	r2, sp, #4
     476:	4620      	mov	r0, r4
     478:	f000 fe84 	bl	1184 <decode_base64>
                decoded[len] = '\0';
     47c:	f100 0368 	add.w	r3, r0, #104	@ 0x68
     480:	446b      	add	r3, sp
     482:	2200      	movs	r2, #0
     484:	f803 2c64 	strb.w	r2, [r3, #-100]
                printf("Decoded as %s", decoded);
     488:	a901      	add	r1, sp, #4
     48a:	4810      	ldr	r0, [pc, #64]	@ (4cc <car_mesg+0x10c>)
     48c:	f001 f8fe 	bl	168c <printf>
     490:	e7ac      	b.n	3ec <car_mesg+0x2c>
            printf("Didn't know how to handle %s\n", argv[1]);
     492:	6871      	ldr	r1, [r6, #4]
     494:	480e      	ldr	r0, [pc, #56]	@ (4d0 <car_mesg+0x110>)
     496:	f001 f8f9 	bl	168c <printf>
     49a:	e7a7      	b.n	3ec <car_mesg+0x2c>
     49c:	00002918 	andeq	r2, r0, r8, lsl r9
     4a0:	0000293c 	andeq	r2, r0, ip, lsr r9
     4a4:	00003160 	andeq	r3, r0, r0, ror #2
     4a8:	00002940 	andeq	r2, r0, r0, asr #18
     4ac:	0000294c 	andeq	r2, r0, ip, asr #18
     4b0:	00002960 	andeq	r2, r0, r0, ror #18
     4b4:	00002984 	andeq	r2, r0, r4, lsl #19
     4b8:	2000018c 	andcs	r0, r0, ip, lsl #3
     4bc:	00002968 	andeq	r2, r0, r8, ror #18
     4c0:	000029a4 	andeq	r2, r0, r4, lsr #19
     4c4:	000029cc 	andeq	r2, r0, ip, asr #19
     4c8:	000029a8 	andeq	r2, r0, r8, lsr #19
     4cc:	000029bc 			@ <UNDEFINED> instruction: 0x000029bc
     4d0:	000029ec 	andeq	r2, r0, ip, ror #19

000004d4 <default_handler>:

extern int _STACK_TOP_;
extern void reset_handler(void);

void default_handler(void) {
  while (1)
     4d4:	e7fe      	b.n	4d4 <default_handler>
	...

000004d8 <uputc>:
 * limitations under the License.
 **/

#include "uart.h"

void uputc(char c) {
     4d8:	b508      	push	{r3, lr}
  while ((UARTFR >> 5) & 1)
     4da:	4b07      	ldr	r3, [pc, #28]	@ (4f8 <uputc+0x20>)
     4dc:	699b      	ldr	r3, [r3, #24]
     4de:	f013 0f20 	tst.w	r3, #32
     4e2:	d1fa      	bne.n	4da <uputc+0x2>
    ;

  UART_DR = c;
     4e4:	4b04      	ldr	r3, [pc, #16]	@ (4f8 <uputc+0x20>)
     4e6:	6018      	str	r0, [r3, #0]
  if (c == '\n')
     4e8:	280a      	cmp	r0, #10
     4ea:	d000      	beq.n	4ee <uputc+0x16>
    uputc('\r');
}
     4ec:	bd08      	pop	{r3, pc}
    uputc('\r');
     4ee:	200d      	movs	r0, #13
     4f0:	f7ff fff2 	bl	4d8 <uputc>
}
     4f4:	e7fa      	b.n	4ec <uputc+0x14>
     4f6:	bf00      	nop
     4f8:	4000c000 	andmi	ip, r0, r0

000004fc <ugetc>:

int ugetc(void) {
  if (!((UARTFR >> 4) & 1)) return UART_DR;
     4fc:	4b05      	ldr	r3, [pc, #20]	@ (514 <ugetc+0x18>)
     4fe:	699b      	ldr	r3, [r3, #24]
     500:	f013 0f10 	tst.w	r3, #16
     504:	d102      	bne.n	50c <ugetc+0x10>
     506:	4b03      	ldr	r3, [pc, #12]	@ (514 <ugetc+0x18>)
     508:	6818      	ldr	r0, [r3, #0]
     50a:	4770      	bx	lr

  return -1;
     50c:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
}
     510:	4770      	bx	lr
     512:	bf00      	nop
     514:	4000c000 	andmi	ip, r0, r0

00000518 <uart_init>:

void uart_init(void) {
  /* Disable UART0 */
  UARTCTL = 0;
     518:	4b07      	ldr	r3, [pc, #28]	@ (538 <uart_init+0x20>)
     51a:	2200      	movs	r2, #0
     51c:	631a      	str	r2, [r3, #48]	@ 0x30

  /* Set the Baud to 115200 */
  UARTIBRD = 8;
     51e:	2108      	movs	r1, #8
     520:	6259      	str	r1, [r3, #36]	@ 0x24
  UARTFBRD = 44;
     522:	212c      	movs	r1, #44	@ 0x2c
     524:	6299      	str	r1, [r3, #40]	@ 0x28

  /* Use system clock for Uart */
  UARTCC = 0;
     526:	f8c3 2fc8 	str.w	r2, [r3, #4040]	@ 0xfc8

  /* 8n1 and no fifo */
  UARTLCRH = 0x60;
     52a:	2260      	movs	r2, #96	@ 0x60
     52c:	62da      	str	r2, [r3, #44]	@ 0x2c

  /* Enable UART0, TXE and RXE */
  UARTCTL = 0x301;
     52e:	f240 3201 	movw	r2, #769	@ 0x301
     532:	631a      	str	r2, [r3, #48]	@ 0x30
}
     534:	4770      	bx	lr
     536:	bf00      	nop
     538:	4000c000 	andmi	ip, r0, r0

0000053c <u2putc>:
 * limitations under the License.
 **/

#include "uart2.h"

void u2putc(char c) {
     53c:	b508      	push	{r3, lr}
  while ((UART2FR >> 5) & 1)
     53e:	4b07      	ldr	r3, [pc, #28]	@ (55c <u2putc+0x20>)
     540:	699b      	ldr	r3, [r3, #24]
     542:	f013 0f20 	tst.w	r3, #32
     546:	d1fa      	bne.n	53e <u2putc+0x2>
    ;

  UART2_DR = c;
     548:	4b04      	ldr	r3, [pc, #16]	@ (55c <u2putc+0x20>)
     54a:	6018      	str	r0, [r3, #0]
  if (c == '\n')
     54c:	280a      	cmp	r0, #10
     54e:	d000      	beq.n	552 <u2putc+0x16>
    u2putc('\r');
}
     550:	bd08      	pop	{r3, pc}
    u2putc('\r');
     552:	200d      	movs	r0, #13
     554:	f7ff fff2 	bl	53c <u2putc>
}
     558:	e7fa      	b.n	550 <u2putc+0x14>
     55a:	bf00      	nop
     55c:	4000d000 	andmi	sp, r0, r0

00000560 <u2getc>:

int u2getc(void) {
  if (!((UART2FR >> 4) & 1)) return UART2_DR;
     560:	4b05      	ldr	r3, [pc, #20]	@ (578 <u2getc+0x18>)
     562:	699b      	ldr	r3, [r3, #24]
     564:	f013 0f10 	tst.w	r3, #16
     568:	d102      	bne.n	570 <u2getc+0x10>
     56a:	4b03      	ldr	r3, [pc, #12]	@ (578 <u2getc+0x18>)
     56c:	6818      	ldr	r0, [r3, #0]
     56e:	4770      	bx	lr

  return -1;
     570:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
}
     574:	4770      	bx	lr
     576:	bf00      	nop
     578:	4000d000 	andmi	sp, r0, r0

0000057c <uart2_init>:

void uart2_init(void) {
  /* Disable the UART */
  UART2CTL = 0;
     57c:	4b07      	ldr	r3, [pc, #28]	@ (59c <uart2_init+0x20>)
     57e:	2200      	movs	r2, #0
     580:	631a      	str	r2, [r3, #48]	@ 0x30

  /* Set the Baud to 115200 */
  UART2IBRD = 8;
     582:	2108      	movs	r1, #8
     584:	6259      	str	r1, [r3, #36]	@ 0x24
  UART2FBRD = 44;
     586:	212c      	movs	r1, #44	@ 0x2c
     588:	6299      	str	r1, [r3, #40]	@ 0x28

  /* Use system clock for Uart */
  UART2CC = 0;
     58a:	f8c3 2fc8 	str.w	r2, [r3, #4040]	@ 0xfc8

  /* 8n1 and no fifo */
  UART2LCRH = 0x60;
     58e:	2260      	movs	r2, #96	@ 0x60
     590:	62da      	str	r2, [r3, #44]	@ 0x2c

  /* Enable UART with TXE and RXE */
  UART2CTL = 0x301;
     592:	f240 3201 	movw	r2, #769	@ 0x301
     596:	631a      	str	r2, [r3, #48]	@ 0x30
}
     598:	4770      	bx	lr
     59a:	bf00      	nop
     59c:	4000d000 	andmi	sp, r0, r0

000005a0 <pin_setup>:


void pin_setup() {
  /* Enable clock for UART0 and GPIO */
  // RCGCUART |= 1;
  RCGCUART |= 3;
     5a0:	4b13      	ldr	r3, [pc, #76]	@ (5f0 <pin_setup+0x50>)
     5a2:	f8d3 2618 	ldr.w	r2, [r3, #1560]	@ 0x618
     5a6:	f042 0203 	orr.w	r2, r2, #3
     5aa:	f8c3 2618 	str.w	r2, [r3, #1560]	@ 0x618
   // RCGCGPIO |= 1;
  RCGCGPIO |= 3;
     5ae:	f8d3 2608 	ldr.w	r2, [r3, #1544]	@ 0x608
     5b2:	f042 0203 	orr.w	r2, r2, #3
     5b6:	f8c3 2608 	str.w	r2, [r3, #1544]	@ 0x608

  /* Set PIN PA0 and PA1 as uart */
  GPIODEN = 0x03;
     5ba:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
     5be:	2203      	movs	r2, #3
     5c0:	f8c3 251c 	str.w	r2, [r3, #1308]	@ 0x51c
  GPIOAFSEL = 0x03;
     5c4:	f8c3 2420 	str.w	r2, [r3, #1056]	@ 0x420
  GPIOPCTL |= 0x00000011;
     5c8:	f8d3 152c 	ldr.w	r1, [r3, #1324]	@ 0x52c
     5cc:	f041 0111 	orr.w	r1, r1, #17
     5d0:	f8c3 152c 	str.w	r1, [r3, #1324]	@ 0x52c

    /* Set PIN PA0 and PA1 as uart */
  GPIODEN2 = 0x03;
     5d4:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
     5d8:	f8c3 251c 	str.w	r2, [r3, #1308]	@ 0x51c
  GPIOAFSEL2 = 0x03;
     5dc:	f8c3 2420 	str.w	r2, [r3, #1056]	@ 0x420
  GPIOPCTL2 |= 0x00000011;
     5e0:	f8d3 252c 	ldr.w	r2, [r3, #1324]	@ 0x52c
     5e4:	f042 0211 	orr.w	r2, r2, #17
     5e8:	f8c3 252c 	str.w	r2, [r3, #1324]	@ 0x52c
}
     5ec:	4770      	bx	lr
     5ee:	bf00      	nop
     5f0:	400fe000 	andmi	lr, pc, r0

000005f4 <platform_init>:

/**
 * @brief Inilialize the platform
 *
 */
void platform_init() {
     5f4:	b508      	push	{r3, lr}
    pin_setup();
     5f6:	f7ff ffd3 	bl	5a0 <pin_setup>
    uart_init();
     5fa:	f7ff ff8d 	bl	518 <uart_init>
    uart2_init();
     5fe:	f7ff ffbd 	bl	57c <uart2_init>
    set_read_char(ugetc);
     602:	4806      	ldr	r0, [pc, #24]	@ (61c <platform_init+0x28>)
     604:	f000 fb7a 	bl	cfc <set_read_char>
    set_read_char2(u2getc);
     608:	4805      	ldr	r0, [pc, #20]	@ (620 <platform_init+0x2c>)
     60a:	f000 fb7d 	bl	d08 <set_read_char2>
    set_write_char(uputc);
     60e:	4805      	ldr	r0, [pc, #20]	@ (624 <platform_init+0x30>)
     610:	f000 fb80 	bl	d14 <set_write_char>
    set_write_char2(u2putc);
     614:	4804      	ldr	r0, [pc, #16]	@ (628 <platform_init+0x34>)
     616:	f000 fb83 	bl	d20 <set_write_char2>
}
     61a:	bd08      	pop	{r3, pc}
     61c:	000004fd 	strdeq	r0, [r0], -sp
     620:	00000561 	andeq	r0, r0, r1, ror #10
     624:	000004d9 	ldrdeq	r0, [r0], -r9
     628:	0000053d 	andeq	r0, r0, sp, lsr r5

0000062c <aes_test>:

// AES variables set globally in shell.c
extern struct AES_ctx ctx;
extern uint8_t AES_key[];

int aes_test(int argc, char** argv) {
     62c:	b570      	push	{r4, r5, r6, lr}
     62e:	b092      	sub	sp, #72	@ 0x48
    
    uint8_t text[17] = "0123456789abcdef";
     630:	f10d 0c34 	add.w	ip, sp, #52	@ 0x34
     634:	4c1f      	ldr	r4, [pc, #124]	@ (6b4 <aes_test+0x88>)
     636:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
     638:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
     63c:	6823      	ldr	r3, [r4, #0]
     63e:	f88c 3000 	strb.w	r3, [ip]
    text[16] = '\0';
    unsigned int len;

    printf("Plaintext is %s\n", text);
     642:	a90d      	add	r1, sp, #52	@ 0x34
     644:	481c      	ldr	r0, [pc, #112]	@ (6b8 <aes_test+0x8c>)
     646:	f001 f821 	bl	168c <printf>
    AES_ECB_encrypt(&ctx, text);
     64a:	4e1c      	ldr	r6, [pc, #112]	@ (6bc <aes_test+0x90>)
     64c:	a90d      	add	r1, sp, #52	@ 0x34
     64e:	4630      	mov	r0, r6
     650:	f001 fccd 	bl	1fee <AES_ECB_encrypt>

    //Let's encode it in base64 so we can send it character-by-character over UART
    uint8_t b64text[25];
    len = encode_base64(text, 16, b64text);
     654:	aa06      	add	r2, sp, #24
     656:	2110      	movs	r1, #16
     658:	a80d      	add	r0, sp, #52	@ 0x34
     65a:	f000 fd1f 	bl	109c <encode_base64>
     65e:	4604      	mov	r4, r0
    b64text[len] = '\0';
     660:	f100 0348 	add.w	r3, r0, #72	@ 0x48
     664:	446b      	add	r3, sp
     666:	2500      	movs	r5, #0
     668:	f803 5c30 	strb.w	r5, [r3, #-48]
    printf("Encrypted/encoded is %s\n", b64text);
     66c:	a906      	add	r1, sp, #24
     66e:	4814      	ldr	r0, [pc, #80]	@ (6c0 <aes_test+0x94>)
     670:	f001 f80c 	bl	168c <printf>
    printf2("FOB_MESG AESB64 %s\n", b64text);
     674:	a906      	add	r1, sp, #24
     676:	4813      	ldr	r0, [pc, #76]	@ (6c4 <aes_test+0x98>)
     678:	f001 f924 	bl	18c4 <printf2>
    printf("Test the mesg handler with CAR_MESG AESB64 %s\n", b64text);
     67c:	a906      	add	r1, sp, #24
     67e:	4812      	ldr	r0, [pc, #72]	@ (6c8 <aes_test+0x9c>)
     680:	f001 f804 	bl	168c <printf>

    uint8_t decoded[17];
    len = decode_base64(b64text, len, decoded);
     684:	aa01      	add	r2, sp, #4
     686:	4621      	mov	r1, r4
     688:	a806      	add	r0, sp, #24
     68a:	f000 fd7b 	bl	1184 <decode_base64>
     68e:	4604      	mov	r4, r0
    AES_ECB_decrypt(&ctx, decoded);
     690:	a901      	add	r1, sp, #4
     692:	4630      	mov	r0, r6
     694:	f001 fcb2 	bl	1ffc <AES_ECB_decrypt>
    decoded[len] = '\0';
     698:	f104 0348 	add.w	r3, r4, #72	@ 0x48
     69c:	eb0d 0403 	add.w	r4, sp, r3
     6a0:	f804 5c44 	strb.w	r5, [r4, #-68]

    printf("After encrypting->encoding->decoding->decrypting we recover %s\n", decoded);
     6a4:	a901      	add	r1, sp, #4
     6a6:	4809      	ldr	r0, [pc, #36]	@ (6cc <aes_test+0xa0>)
     6a8:	f000 fff0 	bl	168c <printf>
    return 0;
}
     6ac:	4628      	mov	r0, r5
     6ae:	b012      	add	sp, #72	@ 0x48
     6b0:	bd70      	pop	{r4, r5, r6, pc}
     6b2:	bf00      	nop
     6b4:	00002aec 	andeq	r2, r0, ip, ror #21
     6b8:	00002a38 	andeq	r2, r0, r8, lsr sl
     6bc:	2000018c 	andcs	r0, r0, ip, lsl #3
     6c0:	00002a4c 	andeq	r2, r0, ip, asr #20
     6c4:	00002a68 	andeq	r2, r0, r8, ror #20
     6c8:	00002a7c 	andeq	r2, r0, ip, ror sl
     6cc:	00002aac 	andeq	r2, r0, ip, lsr #21

000006d0 <pair>:

#include "shell.h"


int pair(int argc, char** argv) {
     6d0:	b508      	push	{r3, lr}
    printf("Sending a pair request.\n");
     6d2:	4804      	ldr	r0, [pc, #16]	@ (6e4 <pair+0x14>)
     6d4:	f000 ffda 	bl	168c <printf>
    printf2("FOB_MESG PAIR\n");
     6d8:	4803      	ldr	r0, [pc, #12]	@ (6e8 <pair+0x18>)
     6da:	f001 f8f3 	bl	18c4 <printf2>
    return 0;
}
     6de:	2000      	movs	r0, #0
     6e0:	bd08      	pop	{r3, pc}
     6e2:	bf00      	nop
     6e4:	00002b2c 	andeq	r2, r0, ip, lsr #22
     6e8:	00002b48 	andeq	r2, r0, r8, asr #22

000006ec <encode64>:
// Your max length should be 4*ceil(n/3) where n is the length of
// the array to be encoded. e.g. 100 bytes are encoded in 128 characters
#define MAXARRAYLEN 100 
#define MAXBASE64LEN 128

int encode64(int argc, char** argv) {
     6ec:	b510      	push	{r4, lr}
     6ee:	b0a0      	sub	sp, #128	@ 0x80

    if (argc > 1) {
     6f0:	2801      	cmp	r0, #1
     6f2:	dd16      	ble.n	722 <encode64+0x36>
     6f4:	460c      	mov	r4, r1

        uint8_t encoded[MAXBASE64LEN];
        int len;

        len = strlen(argv[1]);
     6f6:	6848      	ldr	r0, [r1, #4]
     6f8:	f002 f844 	bl	2784 <strlen>
     6fc:	4601      	mov	r1, r0
        if (len < MAXARRAYLEN) {
     6fe:	2863      	cmp	r0, #99	@ 0x63
     700:	dc0a      	bgt.n	718 <encode64+0x2c>
            len = encode_base64((uint8_t *) argv[1], len, encoded);
     702:	466a      	mov	r2, sp
     704:	6860      	ldr	r0, [r4, #4]
     706:	f000 fcc9 	bl	109c <encode_base64>
     70a:	4603      	mov	r3, r0
            printf("Encoded %s as %s with %d characters\n", argv[1], encoded, len);
     70c:	466a      	mov	r2, sp
     70e:	6861      	ldr	r1, [r4, #4]
     710:	4807      	ldr	r0, [pc, #28]	@ (730 <encode64+0x44>)
     712:	f000 ffbb 	bl	168c <printf>
     716:	e007      	b.n	728 <encode64+0x3c>
        }
        else {
            printf("String exceeds max length of %d characters", MAXARRAYLEN);
     718:	2164      	movs	r1, #100	@ 0x64
     71a:	4806      	ldr	r0, [pc, #24]	@ (734 <encode64+0x48>)
     71c:	f000 ffb6 	bl	168c <printf>
     720:	e002      	b.n	728 <encode64+0x3c>
        }
    }
    else {
        printf("Usage is 'encode64 string'\n");
     722:	4805      	ldr	r0, [pc, #20]	@ (738 <encode64+0x4c>)
     724:	f000 ffb2 	bl	168c <printf>
    }
        
    return 0;
}
     728:	2000      	movs	r0, #0
     72a:	b020      	add	sp, #128	@ 0x80
     72c:	bd10      	pop	{r4, pc}
     72e:	bf00      	nop
     730:	00002b88 	andeq	r2, r0, r8, lsl #23
     734:	00002bb0 			@ <UNDEFINED> instruction: 0x00002bb0
     738:	00002bdc 	ldrdeq	r2, [r0], -ip

0000073c <decode64>:

int decode64(int argc, char** argv) {
     73c:	b510      	push	{r4, lr}
     73e:	b09a      	sub	sp, #104	@ 0x68

    if (argc > 1) {
     740:	2801      	cmp	r0, #1
     742:	dd1c      	ble.n	77e <decode64+0x42>
     744:	460c      	mov	r4, r1

        int len = strlen(argv[1]);
     746:	6848      	ldr	r0, [r1, #4]
     748:	f002 f81c 	bl	2784 <strlen>
     74c:	4601      	mov	r1, r0

        if (len < MAXBASE64LEN) {
     74e:	287f      	cmp	r0, #127	@ 0x7f
     750:	dc10      	bgt.n	774 <decode64+0x38>
                
                uint8_t plaintext[MAXARRAYLEN + 1];
                len = decode_base64((uint8_t *) argv[1], len, plaintext);
     752:	466a      	mov	r2, sp
     754:	6860      	ldr	r0, [r4, #4]
     756:	f000 fd15 	bl	1184 <decode_base64>
                plaintext[len] = '\0';
     75a:	f100 0368 	add.w	r3, r0, #104	@ 0x68
     75e:	eb0d 0003 	add.w	r0, sp, r3
     762:	2300      	movs	r3, #0
     764:	f800 3c68 	strb.w	r3, [r0, #-104]
                printf("Decoded %s as: %s\n", argv[1], plaintext);
     768:	466a      	mov	r2, sp
     76a:	6861      	ldr	r1, [r4, #4]
     76c:	4807      	ldr	r0, [pc, #28]	@ (78c <decode64+0x50>)
     76e:	f000 ff8d 	bl	168c <printf>
     772:	e007      	b.n	784 <decode64+0x48>
        }
        else {
            printf("String exceeds max base64 string length of %d characters", MAXBASE64LEN);
     774:	2180      	movs	r1, #128	@ 0x80
     776:	4806      	ldr	r0, [pc, #24]	@ (790 <decode64+0x54>)
     778:	f000 ff88 	bl	168c <printf>
     77c:	e002      	b.n	784 <decode64+0x48>
        }   
    }
    else {
        printf("Usage is 'decode64 string'\n");
     77e:	4805      	ldr	r0, [pc, #20]	@ (794 <decode64+0x58>)
     780:	f000 ff84 	bl	168c <printf>
    }
        
    return 0;
}
     784:	2000      	movs	r0, #0
     786:	b01a      	add	sp, #104	@ 0x68
     788:	bd10      	pop	{r4, pc}
     78a:	bf00      	nop
     78c:	00002bf8 	strdeq	r2, [r0], -r8
     790:	00002c0c 	andeq	r2, r0, ip, lsl #24
     794:	00002c48 	andeq	r2, r0, r8, asr #24

00000798 <ecdh_test>:
extern uint8_t ECDH_AESkey[];
extern uint8_t AES_key[];
extern struct AES_ctx ctx;


int ecdh_test(int argc, char** argv) {
     798:	b570      	push	{r4, r5, r6, lr}
     79a:	b0d0      	sub	sp, #320	@ 0x140

    uint8_t b64privkey2[32] = "wP/uwP/uwP/uwP/uwP/uwP/uwP/uwP/u";
     79c:	f50d 7c90 	add.w	ip, sp, #288	@ 0x120
     7a0:	4c35      	ldr	r4, [pc, #212]	@ (878 <ecdh_test+0xe0>)
     7a2:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
     7a4:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
     7a8:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
     7ac:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
    uint8_t sharedsecret2[ECC_PRV_KEY_SIZE];
    uint8_t keytest[AES_KEYLEN];
    uint8_t b64test[45];
    int len = 0;

    printf("Testing the ecdh key exchange\n");
     7b0:	4832      	ldr	r0, [pc, #200]	@ (87c <ecdh_test+0xe4>)
     7b2:	f000 ff6b 	bl	168c <printf>

    decode_base64(ECDH_privkey_b64, 32, ECDH_privkey);
     7b6:	4c32      	ldr	r4, [pc, #200]	@ (880 <ecdh_test+0xe8>)
     7b8:	4622      	mov	r2, r4
     7ba:	2120      	movs	r1, #32
     7bc:	4831      	ldr	r0, [pc, #196]	@ (884 <ecdh_test+0xec>)
     7be:	f000 fce1 	bl	1184 <decode_base64>
    decode_base64(b64privkey2, 32, privkey2);
     7c2:	aa42      	add	r2, sp, #264	@ 0x108
     7c4:	2120      	movs	r1, #32
     7c6:	a848      	add	r0, sp, #288	@ 0x120
     7c8:	f000 fcdc 	bl	1184 <decode_base64>

    ecdh_generate_keys(ECDH_pubkey, ECDH_privkey);
     7cc:	4e2e      	ldr	r6, [pc, #184]	@ (888 <ecdh_test+0xf0>)
     7ce:	4621      	mov	r1, r4
     7d0:	4630      	mov	r0, r6
     7d2:	f001 ff05 	bl	25e0 <ecdh_generate_keys>
    ecdh_generate_keys(pubkey2, privkey2);
     7d6:	a942      	add	r1, sp, #264	@ 0x108
     7d8:	a836      	add	r0, sp, #216	@ 0xd8
     7da:	f001 ff01 	bl	25e0 <ecdh_generate_keys>

    ecdh_shared_secret(ECDH_privkey, pubkey2, ECDH_shared);
     7de:	4d2b      	ldr	r5, [pc, #172]	@ (88c <ecdh_test+0xf4>)
     7e0:	462a      	mov	r2, r5
     7e2:	a936      	add	r1, sp, #216	@ 0xd8
     7e4:	4620      	mov	r0, r4
     7e6:	f001 ff25 	bl	2634 <ecdh_shared_secret>
    ecdh_shared_secret(privkey2, ECDH_pubkey, sharedsecret2);
     7ea:	aa30      	add	r2, sp, #192	@ 0xc0
     7ec:	4631      	mov	r1, r6
     7ee:	a842      	add	r0, sp, #264	@ 0x108
     7f0:	f001 ff20 	bl	2634 <ecdh_shared_secret>

    SHA256_CTX shactx;
    sha256_init(&shactx);
     7f4:	4668      	mov	r0, sp
     7f6:	f000 fddd 	bl	13b4 <sha256_init>
	sha256_update(&shactx, ECDH_shared, ECC_PUB_KEY_SIZE);
     7fa:	2230      	movs	r2, #48	@ 0x30
     7fc:	4629      	mov	r1, r5
     7fe:	4668      	mov	r0, sp
     800:	f000 fe02 	bl	1408 <sha256_update>
	sha256_final(&shactx, ECDH_AESkey);
     804:	4d22      	ldr	r5, [pc, #136]	@ (890 <ecdh_test+0xf8>)
     806:	4629      	mov	r1, r5
     808:	4668      	mov	r0, sp
     80a:	f000 fe1d 	bl	1448 <sha256_final>

    len = encode_base64(ECDH_AESkey, AES_KEYLEN, b64test);
     80e:	aa1c      	add	r2, sp, #112	@ 0x70
     810:	2120      	movs	r1, #32
     812:	4628      	mov	r0, r5
     814:	f000 fc42 	bl	109c <encode_base64>
    b64test[len] = '\0';
     818:	f500 73a0 	add.w	r3, r0, #320	@ 0x140
     81c:	eb0d 0003 	add.w	r0, sp, r3
     820:	2400      	movs	r4, #0
     822:	f800 4cd0 	strb.w	r4, [r0, #-208]

    printf("First shared key is %s\n", b64test);
     826:	a91c      	add	r1, sp, #112	@ 0x70
     828:	481a      	ldr	r0, [pc, #104]	@ (894 <ecdh_test+0xfc>)
     82a:	f000 ff2f 	bl	168c <printf>

    sha256_init(&shactx);
     82e:	4668      	mov	r0, sp
     830:	f000 fdc0 	bl	13b4 <sha256_init>
    sha256_update(&shactx, sharedsecret2, ECC_PUB_KEY_SIZE);
     834:	2230      	movs	r2, #48	@ 0x30
     836:	a930      	add	r1, sp, #192	@ 0xc0
     838:	4668      	mov	r0, sp
     83a:	f000 fde5 	bl	1408 <sha256_update>
	sha256_final(&shactx, keytest);
     83e:	a928      	add	r1, sp, #160	@ 0xa0
     840:	4668      	mov	r0, sp
     842:	f000 fe01 	bl	1448 <sha256_final>

    len = encode_base64(keytest, AES_KEYLEN, b64test);
     846:	aa1c      	add	r2, sp, #112	@ 0x70
     848:	2120      	movs	r1, #32
     84a:	a828      	add	r0, sp, #160	@ 0xa0
     84c:	f000 fc26 	bl	109c <encode_base64>
    b64test[len] = '\0';
     850:	f500 73a0 	add.w	r3, r0, #320	@ 0x140
     854:	eb0d 0003 	add.w	r0, sp, r3
     858:	f800 4cd0 	strb.w	r4, [r0, #-208]
    printf("Should be same as %s\n", b64test);
     85c:	a91c      	add	r1, sp, #112	@ 0x70
     85e:	480e      	ldr	r0, [pc, #56]	@ (898 <ecdh_test+0x100>)
     860:	f000 ff14 	bl	168c <printf>

    printf("Switching fob AES key to new value. Try AES tests now.\n");
     864:	480d      	ldr	r0, [pc, #52]	@ (89c <ecdh_test+0x104>)
     866:	f000 ff11 	bl	168c <printf>

    AES_init_ctx(&ctx, ECDH_AESkey);
     86a:	4629      	mov	r1, r5
     86c:	480c      	ldr	r0, [pc, #48]	@ (8a0 <ecdh_test+0x108>)
     86e:	f001 fba8 	bl	1fc2 <AES_init_ctx>

    return 0;
}
     872:	4620      	mov	r0, r4
     874:	b050      	add	sp, #320	@ 0x140
     876:	bd70      	pop	{r4, r5, r6, pc}
     878:	00002d34 	andeq	r2, r0, r4, lsr sp
     87c:	00002cac 	andeq	r2, r0, ip, lsr #25
     880:	2000030c 	andcs	r0, r0, ip, lsl #6
     884:	20000030 	andcs	r0, r0, r0, lsr r0
     888:	200002dc 	ldrdcs	r0, [r0], -ip
     88c:	200002ac 	andcs	r0, r0, ip, lsr #5
     890:	2000028c 	andcs	r0, r0, ip, lsl #5
     894:	00002ccc 	andeq	r2, r0, ip, asr #25
     898:	00002ce4 	andeq	r2, r0, r4, ror #25
     89c:	00002cfc 	strdeq	r2, [r0], -ip
     8a0:	2000018c 	andcs	r0, r0, ip, lsl #3

000008a4 <send_ping>:

#include "shell.h"


int send_ping(int argc, char** argv) {
     8a4:	b508      	push	{r3, lr}
    printf("Pinging the car.\n");
     8a6:	4804      	ldr	r0, [pc, #16]	@ (8b8 <send_ping+0x14>)
     8a8:	f000 fef0 	bl	168c <printf>
    printf2("FOB_MESG PING\n");
     8ac:	4803      	ldr	r0, [pc, #12]	@ (8bc <send_ping+0x18>)
     8ae:	f001 f809 	bl	18c4 <printf2>
    return 0;
}
     8b2:	2000      	movs	r0, #0
     8b4:	bd08      	pop	{r3, pc}
     8b6:	bf00      	nop
     8b8:	00002d7c 	andeq	r2, r0, ip, ror sp
     8bc:	00002d90 	muleq	r0, r0, sp

000008c0 <sha256_test>:
#include "shell.h"


int sha256_test(int argc, char** argv) {
     8c0:	b570      	push	{r4, r5, r6, lr}
     8c2:	b0d4      	sub	sp, #336	@ 0x150
    printf("Starting sha256 test\n");
     8c4:	4822      	ldr	r0, [pc, #136]	@ (950 <sha256_test+0x90>)
     8c6:	f000 fee1 	bl	168c <printf>

    SHA256_CTX shactx;
    BYTE text1[] = {"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"};
     8ca:	f10d 0ca4 	add.w	ip, sp, #164	@ 0xa4
     8ce:	4c21      	ldr	r4, [pc, #132]	@ (954 <sha256_test+0x94>)
     8d0:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
     8d2:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
     8d6:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
     8d8:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
     8dc:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
     8de:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
     8e2:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
     8e6:	e8ac 0003 	stmia.w	ip!, {r0, r1}
     8ea:	f88c 2000 	strb.w	r2, [ip]
    BYTE hash1[SHA256_BLOCK_SIZE] = {0x24,0x8d,0x6a,0x61,0xd2,0x06,0x38,0xb8,0xe5,0xc0,0x26,0x93,0x0c,0x3e,0x60,0x39,
     8ee:	ac21      	add	r4, sp, #132	@ 0x84
     8f0:	4d19      	ldr	r5, [pc, #100]	@ (958 <sha256_test+0x98>)
     8f2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
     8f4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
     8f6:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
     8fa:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}

    uint8_t b64_hash1[45];
    uint8_t b64_buf[45];
    int len;

    sha256_init(&shactx);
     8fe:	a838      	add	r0, sp, #224	@ 0xe0
     900:	f000 fd58 	bl	13b4 <sha256_init>
	sha256_update(&shactx, text1, strlen((char *)text1));
     904:	a829      	add	r0, sp, #164	@ 0xa4
     906:	f001 ff3d 	bl	2784 <strlen>
     90a:	4602      	mov	r2, r0
     90c:	a929      	add	r1, sp, #164	@ 0xa4
     90e:	a838      	add	r0, sp, #224	@ 0xe0
     910:	f000 fd7a 	bl	1408 <sha256_update>
	sha256_final(&shactx, buf);
     914:	a919      	add	r1, sp, #100	@ 0x64
     916:	a838      	add	r0, sp, #224	@ 0xe0
     918:	f000 fd96 	bl	1448 <sha256_final>

    len = encode_base64(hash1, SHA256_BLOCK_SIZE, b64_hash1);
     91c:	ad0d      	add	r5, sp, #52	@ 0x34
     91e:	462a      	mov	r2, r5
     920:	2120      	movs	r1, #32
     922:	a821      	add	r0, sp, #132	@ 0x84
     924:	f000 fbba 	bl	109c <encode_base64>
    b64_hash1[len] = '\0';
     928:	2400      	movs	r4, #0
     92a:	542c      	strb	r4, [r5, r0]

    len = encode_base64(buf, SHA256_BLOCK_SIZE, b64_buf);
     92c:	ae01      	add	r6, sp, #4
     92e:	4632      	mov	r2, r6
     930:	2120      	movs	r1, #32
     932:	a819      	add	r0, sp, #100	@ 0x64
     934:	f000 fbb2 	bl	109c <encode_base64>
    b64_buf[len] = '\0';
     938:	5434      	strb	r4, [r6, r0]

    printf("Base64 of SHA-256 test is %s\n", b64_buf);
     93a:	4631      	mov	r1, r6
     93c:	4807      	ldr	r0, [pc, #28]	@ (95c <sha256_test+0x9c>)
     93e:	f000 fea5 	bl	168c <printf>
    printf("Should be %s\n", b64_hash1);
     942:	4629      	mov	r1, r5
     944:	4806      	ldr	r0, [pc, #24]	@ (960 <sha256_test+0xa0>)
     946:	f000 fea1 	bl	168c <printf>

    return 0;
}
     94a:	4620      	mov	r0, r4
     94c:	b054      	add	sp, #336	@ 0x150
     94e:	bd70      	pop	{r4, r5, r6, pc}
     950:	00002dc0 	andeq	r2, r0, r0, asr #27
     954:	00002e08 	andeq	r2, r0, r8, lsl #28
     958:	00002e44 	andeq	r2, r0, r4, asr #28
     95c:	00002dd8 	ldrdeq	r2, [r0], -r8
     960:	00002df8 	strdeq	r2, [r0], -r8

00000964 <initial_setup>:
         "@" BUILD_HOST "] - " __DATE__ " - " __TIME__ "\n");
  return 0;
}


void __attribute__((optimize("O0"), weak)) initial_setup(void) {
     964:	b580      	push	{r7, lr}
     966:	b082      	sub	sp, #8
     968:	af00      	add	r7, sp, #0
   * and zero the .bss section. This helps keep the user/custom
   * linker script and makefiles free from special variables to be declared.
   * Less burden on the user.
   */
  extern char _etext, _data, _edata, _bss, _ebss;
  char *src = &_etext, *dst = &_data;
     96a:	4b14      	ldr	r3, [pc, #80]	@ (9bc <initial_setup+0x58>)
     96c:	607b      	str	r3, [r7, #4]
     96e:	4b14      	ldr	r3, [pc, #80]	@ (9c0 <initial_setup+0x5c>)
     970:	603b      	str	r3, [r7, #0]
  /**
   * Copy over the data section from ROM to RAM.
   * In case of RAM based target, we skip this since
   * src and dst would point to same location in RAM
   */
  if (dst != src)
     972:	683a      	ldr	r2, [r7, #0]
     974:	687b      	ldr	r3, [r7, #4]
     976:	429a      	cmp	r2, r3
     978:	d00c      	beq.n	994 <initial_setup+0x30>
    while (dst < &_edata) *(dst++) = *(src++);
     97a:	e007      	b.n	98c <initial_setup+0x28>
     97c:	687a      	ldr	r2, [r7, #4]
     97e:	1c53      	adds	r3, r2, #1
     980:	607b      	str	r3, [r7, #4]
     982:	683b      	ldr	r3, [r7, #0]
     984:	1c59      	adds	r1, r3, #1
     986:	6039      	str	r1, [r7, #0]
     988:	7812      	ldrb	r2, [r2, #0]
     98a:	701a      	strb	r2, [r3, #0]
     98c:	683b      	ldr	r3, [r7, #0]
     98e:	4a0d      	ldr	r2, [pc, #52]	@ (9c4 <initial_setup+0x60>)
     990:	4293      	cmp	r3, r2
     992:	d3f3      	bcc.n	97c <initial_setup+0x18>

  /* Clear .bss*/
  for (dst = &_bss; dst < &_ebss; dst++) *dst = 0;
     994:	4b0c      	ldr	r3, [pc, #48]	@ (9c8 <initial_setup+0x64>)
     996:	603b      	str	r3, [r7, #0]
     998:	e005      	b.n	9a6 <initial_setup+0x42>
     99a:	683b      	ldr	r3, [r7, #0]
     99c:	2200      	movs	r2, #0
     99e:	701a      	strb	r2, [r3, #0]
     9a0:	683b      	ldr	r3, [r7, #0]
     9a2:	3301      	adds	r3, #1
     9a4:	603b      	str	r3, [r7, #0]
     9a6:	683b      	ldr	r3, [r7, #0]
     9a8:	4a08      	ldr	r2, [pc, #32]	@ (9cc <initial_setup+0x68>)
     9aa:	4293      	cmp	r3, r2
     9ac:	d3f5      	bcc.n	99a <initial_setup+0x36>
   *   uart_init();
   *   set_read_char(uart_getchar);
   *   set_write_char(uart_putchar);
   * }
   */
  platform_init();
     9ae:	f7ff fe21 	bl	5f4 <platform_init>
}
     9b2:	bf00      	nop
     9b4:	3708      	adds	r7, #8
     9b6:	46bd      	mov	sp, r7
     9b8:	bd80      	pop	{r7, pc}
     9ba:	bf00      	nop
     9bc:	000027ec 	andeq	r2, r0, ip, ror #15
     9c0:	20000000 	andcs	r0, r0, r0
     9c4:	20000050 	andcs	r0, r0, r0, asr r0
     9c8:	20000050 	andcs	r0, r0, r0, asr r0
     9cc:	20000340 	andcs	r0, r0, r0, asr #6

000009d0 <delete>:
static void delete(void) {
     9d0:	b510      	push	{r4, lr}
  __write_char__(BACK_SPACE);
     9d2:	4c05      	ldr	r4, [pc, #20]	@ (9e8 <delete+0x18>)
     9d4:	6823      	ldr	r3, [r4, #0]
     9d6:	2008      	movs	r0, #8
     9d8:	4798      	blx	r3
  __write_char__(SPACE);
     9da:	6823      	ldr	r3, [r4, #0]
     9dc:	2020      	movs	r0, #32
     9de:	4798      	blx	r3
  __write_char__(BACK_SPACE);
     9e0:	6823      	ldr	r3, [r4, #0]
     9e2:	2008      	movs	r0, #8
     9e4:	4798      	blx	r3
}
     9e6:	bd10      	pop	{r4, pc}
     9e8:	20000050 	andcs	r0, r0, r0, asr r0

000009ec <clear_prompt>:
static void clear_prompt(int char_count) {
     9ec:	b510      	push	{r4, lr}
     9ee:	4604      	mov	r4, r0
  while (char_count) {
     9f0:	e002      	b.n	9f8 <clear_prompt+0xc>
    delete ();
     9f2:	f7ff ffed 	bl	9d0 <delete>
    char_count--;
     9f6:	3c01      	subs	r4, #1
  while (char_count) {
     9f8:	2c00      	cmp	r4, #0
     9fa:	d1fa      	bne.n	9f2 <clear_prompt+0x6>
}
     9fc:	bd10      	pop	{r4, pc}

000009fe <exec_auto_cmds>:
static void exec_auto_cmds(void) {
     9fe:	b510      	push	{r4, lr}
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
     a00:	2400      	movs	r4, #0
     a02:	e004      	b.n	a0e <exec_auto_cmds+0x10>
    auto_load[i].command(0, NULL);
     a04:	688b      	ldr	r3, [r1, #8]
     a06:	2100      	movs	r1, #0
     a08:	4608      	mov	r0, r1
     a0a:	4798      	blx	r3
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
     a0c:	3401      	adds	r4, #1
     a0e:	eb04 0244 	add.w	r2, r4, r4, lsl #1
     a12:	0093      	lsls	r3, r2, #2
     a14:	4a02      	ldr	r2, [pc, #8]	@ (a20 <exec_auto_cmds+0x22>)
     a16:	1899      	adds	r1, r3, r2
     a18:	58d3      	ldr	r3, [r2, r3]
     a1a:	2b00      	cmp	r3, #0
     a1c:	d1f2      	bne.n	a04 <exec_auto_cmds+0x6>
}
     a1e:	bd10      	pop	{r4, pc}
     a20:	00002900 	andeq	r2, r0, r0, lsl #18

00000a24 <show_history>:
static int show_history(int argc, char **argv) {
     a24:	b538      	push	{r3, r4, r5, lr}
  uint32_t end_index = total_num_commands-1;
     a26:	4b0c      	ldr	r3, [pc, #48]	@ (a58 <show_history+0x34>)
     a28:	685d      	ldr	r5, [r3, #4]
     a2a:	3d01      	subs	r5, #1
  if (total_num_commands > NUM_HISTORY_ENTRIES) {
     a2c:	685b      	ldr	r3, [r3, #4]
     a2e:	2b02      	cmp	r3, #2
     a30:	dd03      	ble.n	a3a <show_history+0x16>
    beg_index = total_num_commands - NUM_HISTORY_ENTRIES;
     a32:	4b09      	ldr	r3, [pc, #36]	@ (a58 <show_history+0x34>)
     a34:	685c      	ldr	r4, [r3, #4]
     a36:	3c02      	subs	r4, #2
     a38:	e00a      	b.n	a50 <show_history+0x2c>
  uint32_t beg_index = 0;
     a3a:	2400      	movs	r4, #0
     a3c:	e008      	b.n	a50 <show_history+0x2c>
    printf("%s\n", cmd_history[index % NUM_HISTORY_ENTRIES]);
     a3e:	f004 0101 	and.w	r1, r4, #1
     a42:	4b06      	ldr	r3, [pc, #24]	@ (a5c <show_history+0x38>)
     a44:	eb03 11c1 	add.w	r1, r3, r1, lsl #7
     a48:	4805      	ldr	r0, [pc, #20]	@ (a60 <show_history+0x3c>)
     a4a:	f000 fe1f 	bl	168c <printf>
  for (uint32_t index = beg_index; index <= end_index; ++index) {
     a4e:	3401      	adds	r4, #1
     a50:	42ac      	cmp	r4, r5
     a52:	d9f4      	bls.n	a3e <show_history+0x1a>
}
     a54:	2000      	movs	r0, #0
     a56:	bd38      	pop	{r3, r4, r5, pc}
     a58:	20000050 	andcs	r0, r0, r0, asr r0
     a5c:	20000058 	andcs	r0, r0, r8, asr r0
     a60:	00002e94 	muleq	r0, r4, lr

00000a64 <cmd_exec_status>:
  }

  return 0;
}

int cmd_exec_status(int argc, char **argv) {
     a64:	b508      	push	{r3, lr}
  printf("%d\n", __cmd_exec_status);
     a66:	4b04      	ldr	r3, [pc, #16]	@ (a78 <cmd_exec_status+0x14>)
     a68:	f8d3 1108 	ldr.w	r1, [r3, #264]	@ 0x108
     a6c:	4803      	ldr	r0, [pc, #12]	@ (a7c <cmd_exec_status+0x18>)
     a6e:	f000 fe0d 	bl	168c <printf>
  return 0;
}
     a72:	2000      	movs	r0, #0
     a74:	bd08      	pop	{r3, pc}
     a76:	bf00      	nop
     a78:	20000050 	andcs	r0, r0, r0, asr r0
     a7c:	00002e98 	muleq	r0, r8, lr

00000a80 <build_info>:
static int build_info(int argc, char **argv) {
     a80:	b508      	push	{r3, lr}
  printf("Build: [" SHELL_VERSION ":" USER_REPO_VERSION "] - [" BUILD_USER
     a82:	4802      	ldr	r0, [pc, #8]	@ (a8c <build_info+0xc>)
     a84:	f000 fe02 	bl	168c <printf>
}
     a88:	2000      	movs	r0, #0
     a8a:	bd08      	pop	{r3, pc}
     a8c:	00002e9c 	muleq	r0, ip, lr

00000a90 <execute>:
static void execute(int argc, char **argv) {
     a90:	e92d 4178 	stmdb	sp!, {r3, r4, r5, r6, r8, lr}
     a94:	4680      	mov	r8, r0
     a96:	460e      	mov	r6, r1
  for (int i = 0; table[i].command_name != NULL; i++) {
     a98:	2500      	movs	r5, #0
     a9a:	e000      	b.n	a9e <execute+0xe>
     a9c:	3501      	adds	r5, #1
     a9e:	eb05 0445 	add.w	r4, r5, r5, lsl #1
     aa2:	00a4      	lsls	r4, r4, #2
     aa4:	4b0e      	ldr	r3, [pc, #56]	@ (ae0 <execute+0x50>)
     aa6:	5919      	ldr	r1, [r3, r4]
     aa8:	b171      	cbz	r1, ac8 <execute+0x38>
    if (strcmp(argv[0], table[i].command_name) == 0) {
     aaa:	6830      	ldr	r0, [r6, #0]
     aac:	f001 fe72 	bl	2794 <strcmp>
     ab0:	2800      	cmp	r0, #0
     ab2:	d1f3      	bne.n	a9c <execute+0xc>
      __cmd_exec_status = table[i].command(argc, &argv[0]);
     ab4:	4b0a      	ldr	r3, [pc, #40]	@ (ae0 <execute+0x50>)
     ab6:	4423      	add	r3, r4
     ab8:	689b      	ldr	r3, [r3, #8]
     aba:	4631      	mov	r1, r6
     abc:	4640      	mov	r0, r8
     abe:	4798      	blx	r3
     ac0:	4b08      	ldr	r3, [pc, #32]	@ (ae4 <execute+0x54>)
     ac2:	f8c3 0108 	str.w	r0, [r3, #264]	@ 0x108
  if (match_found == FALSE) {
     ac6:	e008      	b.n	ada <execute+0x4a>
    printf("\"%s\": command not found. Use \"help\" to list all command.\n",
     ac8:	6831      	ldr	r1, [r6, #0]
     aca:	4807      	ldr	r0, [pc, #28]	@ (ae8 <execute+0x58>)
     acc:	f000 fdde 	bl	168c <printf>
    __cmd_exec_status = -1;
     ad0:	4b04      	ldr	r3, [pc, #16]	@ (ae4 <execute+0x54>)
     ad2:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
     ad6:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
}
     ada:	e8bd 8178 	ldmia.w	sp!, {r3, r4, r5, r6, r8, pc}
     ade:	bf00      	nop
     ae0:	00002840 	andeq	r2, r0, r0, asr #16
     ae4:	20000050 	andcs	r0, r0, r0, asr r0
     ae8:	00002ee8 	andeq	r2, r0, r8, ror #29

00000aec <help>:
int help(int argc, char **argv) {
     aec:	b570      	push	{r4, r5, r6, lr}
  if (argc > 1 && (strcmp(argv[1], "-l")==0)) {
     aee:	2801      	cmp	r0, #1
     af0:	dd05      	ble.n	afe <help+0x12>
     af2:	460b      	mov	r3, r1
     af4:	4912      	ldr	r1, [pc, #72]	@ (b40 <help+0x54>)
     af6:	6858      	ldr	r0, [r3, #4]
     af8:	f001 fe4c 	bl	2794 <strcmp>
     afc:	b1e0      	cbz	r0, b38 <help+0x4c>
    printf("use: help -l for list only.\n\n");
     afe:	4811      	ldr	r0, [pc, #68]	@ (b44 <help+0x58>)
     b00:	f000 fdc4 	bl	168c <printf>
  bool verbose = true;
     b04:	2601      	movs	r6, #1
    verbose = false;
     b06:	2500      	movs	r5, #0
     b08:	e003      	b.n	b12 <help+0x26>
    printf("\n");
     b0a:	480f      	ldr	r0, [pc, #60]	@ (b48 <help+0x5c>)
     b0c:	f000 fdbe 	bl	168c <printf>
    i++;
     b10:	3501      	adds	r5, #1
  while (table[i].command_name != NULL) {
     b12:	eb05 0445 	add.w	r4, r5, r5, lsl #1
     b16:	00a4      	lsls	r4, r4, #2
     b18:	4b0c      	ldr	r3, [pc, #48]	@ (b4c <help+0x60>)
     b1a:	5918      	ldr	r0, [r3, r4]
     b1c:	b170      	cbz	r0, b3c <help+0x50>
    printf(table[i].command_name);
     b1e:	f000 fdb5 	bl	168c <printf>
    if (verbose) {
     b22:	2e00      	cmp	r6, #0
     b24:	d0f1      	beq.n	b0a <help+0x1e>
      printf("\n\t");
     b26:	480a      	ldr	r0, [pc, #40]	@ (b50 <help+0x64>)
     b28:	f000 fdb0 	bl	168c <printf>
      printf(table[i].command_help);
     b2c:	4b07      	ldr	r3, [pc, #28]	@ (b4c <help+0x60>)
     b2e:	4423      	add	r3, r4
     b30:	6858      	ldr	r0, [r3, #4]
     b32:	f000 fdab 	bl	168c <printf>
     b36:	e7e8      	b.n	b0a <help+0x1e>
    verbose = false;
     b38:	2600      	movs	r6, #0
     b3a:	e7e4      	b.n	b06 <help+0x1a>
}
     b3c:	bd70      	pop	{r4, r5, r6, pc}
     b3e:	bf00      	nop
     b40:	00002f24 	andeq	r2, r0, r4, lsr #30
     b44:	00002f28 	andeq	r2, r0, r8, lsr #30
     b48:	00002f4c 	andeq	r2, r0, ip, asr #30
     b4c:	00002840 	andeq	r2, r0, r0, asr #16
     b50:	00002f48 	andeq	r2, r0, r8, asr #30

00000b54 <add_command_to_history>:
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
     b54:	b1e0      	cbz	r0, b90 <add_command_to_history+0x3c>
static void add_command_to_history(const char *cmd_str) {
     b56:	b538      	push	{r3, r4, r5, lr}
     b58:	4605      	mov	r5, r0
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
     b5a:	490e      	ldr	r1, [pc, #56]	@ (b94 <add_command_to_history+0x40>)
     b5c:	f001 fe1a 	bl	2794 <strcmp>
     b60:	b900      	cbnz	r0, b64 <add_command_to_history+0x10>
}
     b62:	bd38      	pop	{r3, r4, r5, pc}
  int index = total_num_commands % NUM_HISTORY_ENTRIES;
     b64:	4c0c      	ldr	r4, [pc, #48]	@ (b98 <add_command_to_history+0x44>)
     b66:	6860      	ldr	r0, [r4, #4]
     b68:	2800      	cmp	r0, #0
     b6a:	f000 0001 	and.w	r0, r0, #1
     b6e:	bfb8      	it	lt
     b70:	4240      	neglt	r0, r0
  memcpy(&cmd_history[index], cmd_str, LINE_BUFF_SIZE);
     b72:	f104 0308 	add.w	r3, r4, #8
     b76:	2280      	movs	r2, #128	@ 0x80
     b78:	4629      	mov	r1, r5
     b7a:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
     b7e:	f001 fe1e 	bl	27be <memcpy>
  total_num_commands++;
     b82:	6863      	ldr	r3, [r4, #4]
     b84:	3301      	adds	r3, #1
     b86:	6063      	str	r3, [r4, #4]
  curr_command_ptr = total_num_commands;
     b88:	6863      	ldr	r3, [r4, #4]
     b8a:	f8c4 310c 	str.w	r3, [r4, #268]	@ 0x10c
     b8e:	e7e8      	b.n	b62 <add_command_to_history+0xe>
     b90:	4770      	bx	lr
     b92:	bf00      	nop
     b94:	00002f50 	andeq	r2, r0, r0, asr pc
     b98:	20000050 	andcs	r0, r0, r0, asr r0

00000b9c <parse_line>:
static int parse_line(char **argv, char *line_buff, int argument_size) {
     b9c:	b538      	push	{r3, r4, r5, lr}
     b9e:	4605      	mov	r5, r0
     ba0:	460c      	mov	r4, r1
  int length = strlen(line_buff);
     ba2:	4608      	mov	r0, r1
     ba4:	f001 fdee 	bl	2784 <strlen>
     ba8:	4684      	mov	ip, r0
  int pos = 0;
     baa:	2300      	movs	r3, #0
  int argc = 0;
     bac:	4618      	mov	r0, r3
  while (pos <= length) {
     bae:	e00f      	b.n	bd0 <parse_line+0x34>
         pos++)
     bb0:	3301      	adds	r3, #1
    for (; line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
     bb2:	18e1      	adds	r1, r4, r3
     bb4:	5ce2      	ldrb	r2, [r4, r3]
     bb6:	2a09      	cmp	r2, #9
     bb8:	d003      	beq.n	bc2 <parse_line+0x26>
     bba:	2a20      	cmp	r2, #32
     bbc:	d001      	beq.n	bc2 <parse_line+0x26>
     bbe:	2a00      	cmp	r2, #0
     bc0:	d1f6      	bne.n	bb0 <parse_line+0x14>
    if (line_buff[pos] == '\t' || line_buff[pos] == SPACE)
     bc2:	2a09      	cmp	r2, #9
     bc4:	d001      	beq.n	bca <parse_line+0x2e>
     bc6:	2a20      	cmp	r2, #32
     bc8:	d101      	bne.n	bce <parse_line+0x32>
      line_buff[pos] = END_OF_LINE;
     bca:	2200      	movs	r2, #0
     bcc:	700a      	strb	r2, [r1, #0]
    pos++;
     bce:	3301      	adds	r3, #1
  while (pos <= length) {
     bd0:	4563      	cmp	r3, ip
     bd2:	dc0b      	bgt.n	bec <parse_line+0x50>
    if (line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
     bd4:	18e1      	adds	r1, r4, r3
     bd6:	5ce2      	ldrb	r2, [r4, r3]
     bd8:	2a09      	cmp	r2, #9
     bda:	d0ea      	beq.n	bb2 <parse_line+0x16>
     bdc:	2a20      	cmp	r2, #32
     bde:	d0e8      	beq.n	bb2 <parse_line+0x16>
     be0:	2a00      	cmp	r2, #0
     be2:	d0e6      	beq.n	bb2 <parse_line+0x16>
      argv[argc++] = &line_buff[pos];
     be4:	f845 1020 	str.w	r1, [r5, r0, lsl #2]
     be8:	3001      	adds	r0, #1
     bea:	e7e2      	b.n	bb2 <parse_line+0x16>
}
     bec:	bd38      	pop	{r3, r4, r5, pc}

00000bee <prefix_match>:
  if (sub == NULL || str == NULL || len <= 0 || len > strlen(str)) {
     bee:	b1d0      	cbz	r0, c26 <prefix_match+0x38>
static int prefix_match(char *sub, int len, const char *str) {
     bf0:	b570      	push	{r4, r5, r6, lr}
     bf2:	460d      	mov	r5, r1
     bf4:	4614      	mov	r4, r2
     bf6:	4606      	mov	r6, r0
  if (sub == NULL || str == NULL || len <= 0 || len > strlen(str)) {
     bf8:	b17a      	cbz	r2, c1a <prefix_match+0x2c>
     bfa:	2900      	cmp	r1, #0
     bfc:	dd0d      	ble.n	c1a <prefix_match+0x2c>
     bfe:	4610      	mov	r0, r2
     c00:	f001 fdc0 	bl	2784 <strlen>
     c04:	42a8      	cmp	r0, r5
     c06:	d308      	bcc.n	c1a <prefix_match+0x2c>
  for (int i = 0; i<len; ++i) {
     c08:	2300      	movs	r3, #0
     c0a:	42ab      	cmp	r3, r5
     c0c:	da07      	bge.n	c1e <prefix_match+0x30>
    if (sub[i] != str[i]) {
     c0e:	5cf1      	ldrb	r1, [r6, r3]
     c10:	5ce2      	ldrb	r2, [r4, r3]
     c12:	4291      	cmp	r1, r2
     c14:	d105      	bne.n	c22 <prefix_match+0x34>
  for (int i = 0; i<len; ++i) {
     c16:	3301      	adds	r3, #1
     c18:	e7f7      	b.n	c0a <prefix_match+0x1c>
    return FALSE;
     c1a:	2000      	movs	r0, #0
}
     c1c:	bd70      	pop	{r4, r5, r6, pc}
  return TRUE;
     c1e:	2001      	movs	r0, #1
     c20:	e7fc      	b.n	c1c <prefix_match+0x2e>
      return FALSE;
     c22:	2000      	movs	r0, #0
     c24:	e7fa      	b.n	c1c <prefix_match+0x2e>
    return FALSE;
     c26:	2000      	movs	r0, #0
}
     c28:	4770      	bx	lr

00000c2a <handle_up_arrow>:
static void handle_up_arrow(char *cmd_buff, int *char_count) {
     c2a:	b538      	push	{r3, r4, r5, lr}
     c2c:	4604      	mov	r4, r0
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
     c2e:	4a19      	ldr	r2, [pc, #100]	@ (c94 <handle_up_arrow+0x6a>)
     c30:	6853      	ldr	r3, [r2, #4]
     c32:	3b02      	subs	r3, #2
     c34:	f8d2 210c 	ldr.w	r2, [r2, #268]	@ 0x10c
     c38:	4293      	cmp	r3, r2
     c3a:	dc04      	bgt.n	c46 <handle_up_arrow+0x1c>
     c3c:	460d      	mov	r5, r1
      curr_command_ptr == 0) {
     c3e:	4b15      	ldr	r3, [pc, #84]	@ (c94 <handle_up_arrow+0x6a>)
     c40:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
     c44:	b923      	cbnz	r3, c50 <handle_up_arrow+0x26>
    printf("%s", cmd_buff);
     c46:	4621      	mov	r1, r4
     c48:	4813      	ldr	r0, [pc, #76]	@ (c98 <handle_up_arrow+0x6e>)
     c4a:	f000 fd1f 	bl	168c <printf>
}
     c4e:	bd38      	pop	{r3, r4, r5, pc}
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
     c50:	2280      	movs	r2, #128	@ 0x80
     c52:	2100      	movs	r1, #0
     c54:	f001 fdbe 	bl	27d4 <memset>
  curr_command_ptr--;
     c58:	4b0e      	ldr	r3, [pc, #56]	@ (c94 <handle_up_arrow+0x6a>)
     c5a:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
     c5e:	3a01      	subs	r2, #1
     c60:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
     c64:	f8d3 110c 	ldr.w	r1, [r3, #268]	@ 0x10c
     c68:	2900      	cmp	r1, #0
     c6a:	f001 0101 	and.w	r1, r1, #1
     c6e:	bfb8      	it	lt
     c70:	4249      	neglt	r1, r1
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
     c72:	3308      	adds	r3, #8
     c74:	2280      	movs	r2, #128	@ 0x80
     c76:	eb03 11c1 	add.w	r1, r3, r1, lsl #7
     c7a:	4620      	mov	r0, r4
     c7c:	f001 fd9f 	bl	27be <memcpy>
  *char_count = strlen(cmd_buff);
     c80:	4620      	mov	r0, r4
     c82:	f001 fd7f 	bl	2784 <strlen>
     c86:	6028      	str	r0, [r5, #0]
  printf("%s", cmd_buff);
     c88:	4621      	mov	r1, r4
     c8a:	4803      	ldr	r0, [pc, #12]	@ (c98 <handle_up_arrow+0x6e>)
     c8c:	f000 fcfe 	bl	168c <printf>
     c90:	e7dd      	b.n	c4e <handle_up_arrow+0x24>
     c92:	bf00      	nop
     c94:	20000050 	andcs	r0, r0, r0, asr r0
     c98:	00002f54 	andeq	r2, r0, r4, asr pc

00000c9c <handle_down_arrow>:
static void handle_down_arrow(char *cmd_buff, int *char_count) {
     c9c:	b538      	push	{r3, r4, r5, lr}
     c9e:	4604      	mov	r4, r0
     ca0:	460d      	mov	r5, r1
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
     ca2:	2280      	movs	r2, #128	@ 0x80
     ca4:	2100      	movs	r1, #0
     ca6:	f001 fd95 	bl	27d4 <memset>
  *char_count = 0;
     caa:	2300      	movs	r3, #0
     cac:	602b      	str	r3, [r5, #0]
  if (curr_command_ptr == total_num_commands) return;
     cae:	4b11      	ldr	r3, [pc, #68]	@ (cf4 <handle_down_arrow+0x58>)
     cb0:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
     cb4:	685b      	ldr	r3, [r3, #4]
     cb6:	429a      	cmp	r2, r3
     cb8:	d01b      	beq.n	cf2 <handle_down_arrow+0x56>
  curr_command_ptr++;
     cba:	490e      	ldr	r1, [pc, #56]	@ (cf4 <handle_down_arrow+0x58>)
     cbc:	f8d1 310c 	ldr.w	r3, [r1, #268]	@ 0x10c
     cc0:	3301      	adds	r3, #1
     cc2:	f8c1 310c 	str.w	r3, [r1, #268]	@ 0x10c
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
     cc6:	f8d1 310c 	ldr.w	r3, [r1, #268]	@ 0x10c
     cca:	2b00      	cmp	r3, #0
     ccc:	f003 0301 	and.w	r3, r3, #1
     cd0:	bfb8      	it	lt
     cd2:	425b      	neglt	r3, r3
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
     cd4:	3108      	adds	r1, #8
     cd6:	2280      	movs	r2, #128	@ 0x80
     cd8:	eb01 11c3 	add.w	r1, r1, r3, lsl #7
     cdc:	4620      	mov	r0, r4
     cde:	f001 fd6e 	bl	27be <memcpy>
  *char_count = strlen(cmd_buff);
     ce2:	4620      	mov	r0, r4
     ce4:	f001 fd4e 	bl	2784 <strlen>
     ce8:	6028      	str	r0, [r5, #0]
  printf("%s", cmd_buff);
     cea:	4621      	mov	r1, r4
     cec:	4802      	ldr	r0, [pc, #8]	@ (cf8 <handle_down_arrow+0x5c>)
     cee:	f000 fccd 	bl	168c <printf>
}
     cf2:	bd38      	pop	{r3, r4, r5, pc}
     cf4:	20000050 	andcs	r0, r0, r0, asr r0
     cf8:	00002f54 	andeq	r2, r0, r4, asr pc

00000cfc <set_read_char>:
void set_read_char(int (*func)(void)) { __read_char__ = func; }
     cfc:	4b01      	ldr	r3, [pc, #4]	@ (d04 <set_read_char+0x8>)
     cfe:	f8c3 0110 	str.w	r0, [r3, #272]	@ 0x110
     d02:	4770      	bx	lr
     d04:	20000050 	andcs	r0, r0, r0, asr r0

00000d08 <set_read_char2>:
void set_read_char2(int (*func)(void)) { __read_char2__ = func; }
     d08:	4b01      	ldr	r3, [pc, #4]	@ (d10 <set_read_char2+0x8>)
     d0a:	f8c3 0114 	str.w	r0, [r3, #276]	@ 0x114
     d0e:	4770      	bx	lr
     d10:	20000050 	andcs	r0, r0, r0, asr r0

00000d14 <set_write_char>:
void set_write_char(void (*func)(char)) { __write_char__ = func; }
     d14:	4b01      	ldr	r3, [pc, #4]	@ (d1c <set_write_char+0x8>)
     d16:	6018      	str	r0, [r3, #0]
     d18:	4770      	bx	lr
     d1a:	bf00      	nop
     d1c:	20000050 	andcs	r0, r0, r0, asr r0

00000d20 <set_write_char2>:
void set_write_char2(void (*func)(char)) { __write_char2__ = func; }
     d20:	4b01      	ldr	r3, [pc, #4]	@ (d28 <set_write_char2+0x8>)
     d22:	f8c3 0118 	str.w	r0, [r3, #280]	@ 0x118
     d26:	4770      	bx	lr
     d28:	20000050 	andcs	r0, r0, r0, asr r0

00000d2c <setup>:
}
     d2c:	4770      	bx	lr

00000d2e <loop>:
}
     d2e:	4770      	bx	lr

00000d30 <prepend_prompt>:
}
     d30:	4770      	bx	lr

00000d32 <handle_tab>:
  if (cmd_buff == NULL || char_count <= 0) {
     d32:	2800      	cmp	r0, #0
     d34:	d046      	beq.n	dc4 <handle_tab+0x92>
static void handle_tab(char *cmd_buff, int *char_count) {
     d36:	e92d 4778 	stmdb	sp!, {r3, r4, r5, r6, r8, r9, sl, lr}
     d3a:	460e      	mov	r6, r1
     d3c:	4680      	mov	r8, r0
  if (cmd_buff == NULL || char_count <= 0) {
     d3e:	b309      	cbz	r1, d84 <handle_tab+0x52>
  int last_match = -1;
     d40:	f04f 3aff 	mov.w	sl, #4294967295	@ 0xffffffff
  int match_count = 0;
     d44:	f04f 0900 	mov.w	r9, #0
  int i = 0;
     d48:	464d      	mov	r5, r9
     d4a:	e000      	b.n	d4e <handle_tab+0x1c>
    i++;
     d4c:	3501      	adds	r5, #1
  while (table[i].command_name != NULL) { //loop over all commands
     d4e:	eb05 0445 	add.w	r4, r5, r5, lsl #1
     d52:	00a4      	lsls	r4, r4, #2
     d54:	4b1c      	ldr	r3, [pc, #112]	@ (dc8 <handle_tab+0x96>)
     d56:	591a      	ldr	r2, [r3, r4]
     d58:	b172      	cbz	r2, d78 <handle_tab+0x46>
    if (prefix_match(cmd_buff, *char_count, table[i].command_name)) {
     d5a:	6831      	ldr	r1, [r6, #0]
     d5c:	4640      	mov	r0, r8
     d5e:	f7ff ff46 	bl	bee <prefix_match>
     d62:	2800      	cmp	r0, #0
     d64:	d0f2      	beq.n	d4c <handle_tab+0x1a>
      match_count++;
     d66:	f109 0901 	add.w	r9, r9, #1
      printf("\n%s", table[i].command_name);
     d6a:	4b17      	ldr	r3, [pc, #92]	@ (dc8 <handle_tab+0x96>)
     d6c:	5919      	ldr	r1, [r3, r4]
     d6e:	4817      	ldr	r0, [pc, #92]	@ (dcc <handle_tab+0x9a>)
     d70:	f000 fc8c 	bl	168c <printf>
      last_match = i;
     d74:	46aa      	mov	sl, r5
     d76:	e7e9      	b.n	d4c <handle_tab+0x1a>
  if (match_count == 1) {
     d78:	f1b9 0f01 	cmp.w	r9, #1
     d7c:	d004      	beq.n	d88 <handle_tab+0x56>
  if (match_count) {
     d7e:	f1b9 0f00 	cmp.w	r9, #0
     d82:	d10e      	bne.n	da2 <handle_tab+0x70>
}
     d84:	e8bd 8778 	ldmia.w	sp!, {r3, r4, r5, r6, r8, r9, sl, pc}
    memcpy(cmd_buff, table[last_match].command_name, LINE_BUFF_SIZE);
     d88:	eb0a 0a4a 	add.w	sl, sl, sl, lsl #1
     d8c:	2280      	movs	r2, #128	@ 0x80
     d8e:	f853 102a 	ldr.w	r1, [r3, sl, lsl #2]
     d92:	4640      	mov	r0, r8
     d94:	f001 fd13 	bl	27be <memcpy>
    *char_count = strlen(cmd_buff);
     d98:	4640      	mov	r0, r8
     d9a:	f001 fcf3 	bl	2784 <strlen>
     d9e:	6030      	str	r0, [r6, #0]
     da0:	e7ed      	b.n	d7e <handle_tab+0x4c>
    printf("\n");
     da2:	4c0b      	ldr	r4, [pc, #44]	@ (dd0 <handle_tab+0x9e>)
     da4:	f104 00b8 	add.w	r0, r4, #184	@ 0xb8
     da8:	f000 fc70 	bl	168c <printf>
    prepend_prompt();
     dac:	f7ff ffc0 	bl	d30 <prepend_prompt>
    printf(PROMPT);
     db0:	f104 00c8 	add.w	r0, r4, #200	@ 0xc8
     db4:	f000 fc6a 	bl	168c <printf>
    printf("%s", cmd_buff);
     db8:	4641      	mov	r1, r8
     dba:	f104 00c0 	add.w	r0, r4, #192	@ 0xc0
     dbe:	f000 fc65 	bl	168c <printf>
     dc2:	e7df      	b.n	d84 <handle_tab+0x52>
     dc4:	4770      	bx	lr
     dc6:	bf00      	nop
     dc8:	00002840 	andeq	r2, r0, r0, asr #16
     dcc:	00002f58 	andeq	r2, r0, r8, asr pc
     dd0:	00002e94 	muleq	r0, r4, lr

00000dd4 <active_prompt>:
__attribute__((weak)) int active_prompt() { return TRUE; }
     dd4:	2001      	movs	r0, #1
     dd6:	4770      	bx	lr

00000dd8 <shell>:
static void shell(void) {
     dd8:	b530      	push	{r4, r5, lr}
     dda:	b0e3      	sub	sp, #396	@ 0x18c
  int count = 0;
     ddc:	2300      	movs	r3, #0
     dde:	9361      	str	r3, [sp, #388]	@ 0x184
  for (int i = 0; i < LINE_BUFF_SIZE; i++) line_buff[i] = 0;
     de0:	e006      	b.n	df0 <shell+0x18>
     de2:	f503 72c4 	add.w	r2, r3, #392	@ 0x188
     de6:	446a      	add	r2, sp
     de8:	2100      	movs	r1, #0
     dea:	f802 1c84 	strb.w	r1, [r2, #-132]
     dee:	3301      	adds	r3, #1
     df0:	2b7f      	cmp	r3, #127	@ 0x7f
     df2:	ddf6      	ble.n	de2 <shell+0xa>
  for (int i = 0; i < MAX_ARG_COUNT; i++) argv[i] = NULL;
     df4:	2300      	movs	r3, #0
     df6:	e004      	b.n	e02 <shell+0x2a>
     df8:	aa01      	add	r2, sp, #4
     dfa:	2100      	movs	r1, #0
     dfc:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
     e00:	3301      	adds	r3, #1
     e02:	2b3f      	cmp	r3, #63	@ 0x3f
     e04:	ddf8      	ble.n	df8 <shell+0x20>
  prepend_prompt();
     e06:	f7ff ff93 	bl	d30 <prepend_prompt>
  printf(PROMPT);
     e0a:	484e      	ldr	r0, [pc, #312]	@ (f44 <shell+0x16c>)
     e0c:	f000 fc3e 	bl	168c <printf>
  int special_key = 0;
     e10:	2500      	movs	r5, #0
     e12:	e039      	b.n	e88 <shell+0xb0>
        special_key = 1;
     e14:	2501      	movs	r5, #1
     e16:	e037      	b.n	e88 <shell+0xb0>
    if (s == -1) { s = __read_char2__();}
     e18:	4b4b      	ldr	r3, [pc, #300]	@ (f48 <shell+0x170>)
     e1a:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
     e1e:	4798      	blx	r3
    if (s != -1) {
     e20:	f1b0 3fff 	cmp.w	r0, #4294967295	@ 0xffffffff
     e24:	d13b      	bne.n	e9e <shell+0xc6>
      loop();
     e26:	f7ff ff82 	bl	d2e <loop>
     e2a:	e02d      	b.n	e88 <shell+0xb0>
        line_buff[count] = END_OF_LINE;
     e2c:	9b61      	ldr	r3, [sp, #388]	@ 0x184
     e2e:	f503 73c4 	add.w	r3, r3, #392	@ 0x188
     e32:	446b      	add	r3, sp
     e34:	2200      	movs	r2, #0
     e36:	f803 2c84 	strb.w	r2, [r3, #-132]
        __write_char__(NEW_LINE);
     e3a:	4b43      	ldr	r3, [pc, #268]	@ (f48 <shell+0x170>)
     e3c:	681b      	ldr	r3, [r3, #0]
     e3e:	200a      	movs	r0, #10
     e40:	4798      	blx	r3
  add_command_to_history(line_buff);
     e42:	a841      	add	r0, sp, #260	@ 0x104
     e44:	f7ff fe86 	bl	b54 <add_command_to_history>
  argc = parse_line(argv, line_buff, MAX_ARG_COUNT);
     e48:	2240      	movs	r2, #64	@ 0x40
     e4a:	a941      	add	r1, sp, #260	@ 0x104
     e4c:	a801      	add	r0, sp, #4
     e4e:	f7ff fea5 	bl	b9c <parse_line>
  if (argc > 0) execute(argc, argv);
     e52:	2800      	cmp	r0, #0
     e54:	dc71      	bgt.n	f3a <shell+0x162>
}
     e56:	b063      	add	sp, #396	@ 0x18c
     e58:	bd30      	pop	{r4, r5, pc}
        if (!__echo) {
     e5a:	4b3c      	ldr	r3, [pc, #240]	@ (f4c <shell+0x174>)
     e5c:	781b      	ldrb	r3, [r3, #0]
     e5e:	2b00      	cmp	r3, #0
     e60:	d03f      	beq.n	ee2 <shell+0x10a>
        if (count == 0) continue;
     e62:	9b61      	ldr	r3, [sp, #388]	@ 0x184
     e64:	b183      	cbz	r3, e88 <shell+0xb0>
        count--;
     e66:	3b01      	subs	r3, #1
     e68:	9361      	str	r3, [sp, #388]	@ 0x184
        line_buff[count] = END_OF_LINE;
     e6a:	f503 73c4 	add.w	r3, r3, #392	@ 0x188
     e6e:	446b      	add	r3, sp
     e70:	2200      	movs	r2, #0
     e72:	f803 2c84 	strb.w	r2, [r3, #-132]
        delete ();
     e76:	f7ff fdab 	bl	9d0 <delete>
      if (__echo) {
     e7a:	4b34      	ldr	r3, [pc, #208]	@ (f4c <shell+0x174>)
     e7c:	781b      	ldrb	r3, [r3, #0]
     e7e:	b11b      	cbz	r3, e88 <shell+0xb0>
        __write_char__(c);
     e80:	4b31      	ldr	r3, [pc, #196]	@ (f48 <shell+0x170>)
     e82:	681b      	ldr	r3, [r3, #0]
     e84:	4620      	mov	r0, r4
     e86:	4798      	blx	r3
    if (!active_prompt()) {
     e88:	f7ff ffa4 	bl	dd4 <active_prompt>
     e8c:	2800      	cmp	r0, #0
     e8e:	d0fb      	beq.n	e88 <shell+0xb0>
    s = __read_char__();
     e90:	4b2d      	ldr	r3, [pc, #180]	@ (f48 <shell+0x170>)
     e92:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
     e96:	4798      	blx	r3
    if (s == -1) { s = __read_char2__();}
     e98:	f1b0 3fff 	cmp.w	r0, #4294967295	@ 0xffffffff
     e9c:	d0bc      	beq.n	e18 <shell+0x40>
      c = (char)s;
     e9e:	b2c4      	uxtb	r4, r0
      if (c == CARRIAGE_RETURN || c == NEW_LINE) {
     ea0:	2c0d      	cmp	r4, #13
     ea2:	d0c3      	beq.n	e2c <shell+0x54>
     ea4:	2c0a      	cmp	r4, #10
     ea6:	d0c1      	beq.n	e2c <shell+0x54>
      if (c == DELETE || c == BACK_SPACE) {
     ea8:	2c7f      	cmp	r4, #127	@ 0x7f
     eaa:	d0d6      	beq.n	e5a <shell+0x82>
     eac:	2c08      	cmp	r4, #8
     eae:	d0d4      	beq.n	e5a <shell+0x82>
      } else if (c == ESCAPE) {
     eb0:	2c1b      	cmp	r4, #27
     eb2:	d0af      	beq.n	e14 <shell+0x3c>
      } else if (c == SQUARE_BRACKET_OPEN && special_key == 1) {
     eb4:	2c5b      	cmp	r4, #91	@ 0x5b
     eb6:	d019      	beq.n	eec <shell+0x114>
      } else if ((c == 'C' || c == 'D') && special_key != 0) {
     eb8:	f1a4 0343 	sub.w	r3, r4, #67	@ 0x43
     ebc:	b2db      	uxtb	r3, r3
     ebe:	2b01      	cmp	r3, #1
     ec0:	d918      	bls.n	ef4 <shell+0x11c>
      } else if ((c == 'A' || c == 'B') && special_key == 2) {
     ec2:	f1a4 0341 	sub.w	r3, r4, #65	@ 0x41
     ec6:	b2db      	uxtb	r3, r3
     ec8:	2b01      	cmp	r3, #1
     eca:	d917      	bls.n	efc <shell+0x124>
      else if (c == TAB) {
     ecc:	2c09      	cmp	r4, #9
     ece:	d02f      	beq.n	f30 <shell+0x158>
        line_buff[count] = c;
     ed0:	9b61      	ldr	r3, [sp, #388]	@ 0x184
     ed2:	f503 72c4 	add.w	r2, r3, #392	@ 0x188
     ed6:	446a      	add	r2, sp
     ed8:	f802 4c84 	strb.w	r4, [r2, #-132]
        count++;
     edc:	3301      	adds	r3, #1
     ede:	9361      	str	r3, [sp, #388]	@ 0x184
     ee0:	e7cb      	b.n	e7a <shell+0xa2>
          delete ();
     ee2:	f7ff fd75 	bl	9d0 <delete>
          delete ();
     ee6:	f7ff fd73 	bl	9d0 <delete>
     eea:	e7ba      	b.n	e62 <shell+0x8a>
      } else if (c == SQUARE_BRACKET_OPEN && special_key == 1) {
     eec:	2d01      	cmp	r5, #1
     eee:	d1e3      	bne.n	eb8 <shell+0xe0>
        special_key = 2;
     ef0:	2502      	movs	r5, #2
     ef2:	e7c9      	b.n	e88 <shell+0xb0>
      } else if ((c == 'C' || c == 'D') && special_key != 0) {
     ef4:	2d00      	cmp	r5, #0
     ef6:	d0e4      	beq.n	ec2 <shell+0xea>
        special_key = 0;
     ef8:	2500      	movs	r5, #0
     efa:	e7c5      	b.n	e88 <shell+0xb0>
      } else if ((c == 'A' || c == 'B') && special_key == 2) {
     efc:	2d02      	cmp	r5, #2
     efe:	d1e5      	bne.n	ecc <shell+0xf4>
        if (!__echo) {
     f00:	4b12      	ldr	r3, [pc, #72]	@ (f4c <shell+0x174>)
     f02:	781b      	ldrb	r3, [r3, #0]
     f04:	b95b      	cbnz	r3, f1e <shell+0x146>
          clear_prompt(count + 4);
     f06:	9861      	ldr	r0, [sp, #388]	@ 0x184
     f08:	3004      	adds	r0, #4
     f0a:	f7ff fd6f 	bl	9ec <clear_prompt>
        if (c == 'A') {
     f0e:	2c41      	cmp	r4, #65	@ 0x41
     f10:	d009      	beq.n	f26 <shell+0x14e>
          handle_down_arrow(line_buff, &count);
     f12:	a961      	add	r1, sp, #388	@ 0x184
     f14:	a841      	add	r0, sp, #260	@ 0x104
     f16:	f7ff fec1 	bl	c9c <handle_down_arrow>
        special_key = 0;
     f1a:	2500      	movs	r5, #0
        continue;
     f1c:	e7b4      	b.n	e88 <shell+0xb0>
          clear_prompt(count);
     f1e:	9861      	ldr	r0, [sp, #388]	@ 0x184
     f20:	f7ff fd64 	bl	9ec <clear_prompt>
     f24:	e7f3      	b.n	f0e <shell+0x136>
          handle_up_arrow(line_buff, &count);
     f26:	a961      	add	r1, sp, #388	@ 0x184
     f28:	a841      	add	r0, sp, #260	@ 0x104
     f2a:	f7ff fe7e 	bl	c2a <handle_up_arrow>
     f2e:	e7f4      	b.n	f1a <shell+0x142>
        handle_tab(line_buff, &count);
     f30:	a961      	add	r1, sp, #388	@ 0x184
     f32:	a841      	add	r0, sp, #260	@ 0x104
     f34:	f7ff fefd 	bl	d32 <handle_tab>
        continue;
     f38:	e7a6      	b.n	e88 <shell+0xb0>
  if (argc > 0) execute(argc, argv);
     f3a:	a901      	add	r1, sp, #4
     f3c:	f7ff fda8 	bl	a90 <execute>
}
     f40:	e789      	b.n	e56 <shell+0x7e>
     f42:	bf00      	nop
     f44:	00002f5c 	andeq	r2, r0, ip, asr pc
     f48:	20000050 	andcs	r0, r0, r0, asr r0
     f4c:	20000000 	andcs	r0, r0, r0

00000f50 <prompt>:
void prompt() {
     f50:	b508      	push	{r3, lr}
  initial_setup();
     f52:	f7ff fd07 	bl	964 <initial_setup>
  exec_auto_cmds();
     f56:	f7ff fd52 	bl	9fe <exec_auto_cmds>
  setup();
     f5a:	f7ff fee7 	bl	d2c <setup>
  decode_base64(AES_key_b64, 44, AES_key);
     f5e:	4c08      	ldr	r4, [pc, #32]	@ (f80 <prompt+0x30>)
     f60:	f504 758e 	add.w	r5, r4, #284	@ 0x11c
     f64:	462a      	mov	r2, r5
     f66:	212c      	movs	r1, #44	@ 0x2c
     f68:	4806      	ldr	r0, [pc, #24]	@ (f84 <prompt+0x34>)
     f6a:	f000 f90b 	bl	1184 <decode_base64>
  AES_init_ctx(&ctx, AES_key);
     f6e:	4629      	mov	r1, r5
     f70:	f504 709e 	add.w	r0, r4, #316	@ 0x13c
     f74:	f001 f825 	bl	1fc2 <AES_init_ctx>
    shell();
     f78:	f7ff ff2e 	bl	dd8 <shell>
  while (TRUE) {
     f7c:	e7fc      	b.n	f78 <prompt+0x28>
     f7e:	bf00      	nop
     f80:	20000050 	andcs	r0, r0, r0, asr r0
     f84:	20000004 	andcs	r0, r0, r4

00000f88 <exec>:
int exec(char *cmd_str) {
     f88:	b500      	push	{lr}
     f8a:	b0c1      	sub	sp, #260	@ 0x104
     f8c:	4601      	mov	r1, r0
  argc = parse_line(argv, cmd_str, MAX_ARG_COUNT);
     f8e:	2240      	movs	r2, #64	@ 0x40
     f90:	4668      	mov	r0, sp
     f92:	f7ff fe03 	bl	b9c <parse_line>
  if (argc > 0) execute(argc, argv);
     f96:	2800      	cmp	r0, #0
     f98:	dc05      	bgt.n	fa6 <exec+0x1e>
  return __cmd_exec_status;
     f9a:	4b05      	ldr	r3, [pc, #20]	@ (fb0 <exec+0x28>)
     f9c:	f8d3 0108 	ldr.w	r0, [r3, #264]	@ 0x108
}
     fa0:	b041      	add	sp, #260	@ 0x104
     fa2:	f85d fb04 	ldr.w	pc, [sp], #4
  if (argc > 0) execute(argc, argv);
     fa6:	4669      	mov	r1, sp
     fa8:	f7ff fd72 	bl	a90 <execute>
     fac:	e7f5      	b.n	f9a <exec+0x12>
     fae:	bf00      	nop
     fb0:	20000050 	andcs	r0, r0, r0, asr r0

00000fb4 <get_function_addr>:
cmd get_function_addr(char *cmd_str) {
     fb4:	b570      	push	{r4, r5, r6, lr}
     fb6:	4606      	mov	r6, r0
  for (int i = 0; table[i].command_name != NULL; i++) {
     fb8:	2500      	movs	r5, #0
     fba:	e000      	b.n	fbe <get_function_addr+0xa>
     fbc:	3501      	adds	r5, #1
     fbe:	eb05 0445 	add.w	r4, r5, r5, lsl #1
     fc2:	00a4      	lsls	r4, r4, #2
     fc4:	4b06      	ldr	r3, [pc, #24]	@ (fe0 <get_function_addr+0x2c>)
     fc6:	5919      	ldr	r1, [r3, r4]
     fc8:	b141      	cbz	r1, fdc <get_function_addr+0x28>
    if (strcmp(cmd_str, table[i].command_name) == 0) {
     fca:	4630      	mov	r0, r6
     fcc:	f001 fbe2 	bl	2794 <strcmp>
     fd0:	2800      	cmp	r0, #0
     fd2:	d1f3      	bne.n	fbc <get_function_addr+0x8>
      return table[i].command;
     fd4:	4b02      	ldr	r3, [pc, #8]	@ (fe0 <get_function_addr+0x2c>)
     fd6:	4423      	add	r3, r4
     fd8:	6898      	ldr	r0, [r3, #8]
     fda:	e000      	b.n	fde <get_function_addr+0x2a>
  return NULL;
     fdc:	2000      	movs	r0, #0
}
     fde:	bd70      	pop	{r4, r5, r6, pc}
     fe0:	00002840 	andeq	r2, r0, r0, asr #16

00000fe4 <binary_to_base64>:
#include "base64.h"

unsigned char binary_to_base64(unsigned char v) {
  // Capital letters - 'A' is ascii 65 and base64 0
  if(v < 26) return v + 'A';
     fe4:	2819      	cmp	r0, #25
     fe6:	d909      	bls.n	ffc <binary_to_base64+0x18>
  
  // Lowercase letters - 'a' is ascii 97 and base64 26
  if(v < 52) return v + 71;
     fe8:	2833      	cmp	r0, #51	@ 0x33
     fea:	d90a      	bls.n	1002 <binary_to_base64+0x1e>
  
  // Digits - '0' is ascii 48 and base64 52
  if(v < 62) return v - 4;
     fec:	283d      	cmp	r0, #61	@ 0x3d
     fee:	d90b      	bls.n	1008 <binary_to_base64+0x24>
  
  // '+' is ascii 43 and base64 62
  if(v == 62) return '+';
     ff0:	283e      	cmp	r0, #62	@ 0x3e
     ff2:	d00c      	beq.n	100e <binary_to_base64+0x2a>
  
  // '/' is ascii 47 and base64 63
  if(v == 63) return '/';
     ff4:	283f      	cmp	r0, #63	@ 0x3f
     ff6:	d00c      	beq.n	1012 <binary_to_base64+0x2e>
  
  return 64;
     ff8:	2040      	movs	r0, #64	@ 0x40
     ffa:	4770      	bx	lr
  if(v < 26) return v + 'A';
     ffc:	3041      	adds	r0, #65	@ 0x41
     ffe:	b2c0      	uxtb	r0, r0
    1000:	4770      	bx	lr
  if(v < 52) return v + 71;
    1002:	3047      	adds	r0, #71	@ 0x47
    1004:	b2c0      	uxtb	r0, r0
    1006:	4770      	bx	lr
  if(v < 62) return v - 4;
    1008:	3804      	subs	r0, #4
    100a:	b2c0      	uxtb	r0, r0
    100c:	4770      	bx	lr
  if(v == 62) return '+';
    100e:	202b      	movs	r0, #43	@ 0x2b
    1010:	4770      	bx	lr
  if(v == 63) return '/';
    1012:	202f      	movs	r0, #47	@ 0x2f
}
    1014:	4770      	bx	lr

00001016 <base64_to_binary>:

unsigned char base64_to_binary(unsigned char c) {
    1016:	4603      	mov	r3, r0
  // Capital letters - 'A' is ascii 65 and base64 0
  if('A' <= c && c <= 'Z') return c - 'A';
    1018:	3841      	subs	r0, #65	@ 0x41
    101a:	b2c0      	uxtb	r0, r0
    101c:	2819      	cmp	r0, #25
    101e:	d918      	bls.n	1052 <base64_to_binary+0x3c>
  
  // Lowercase letters - 'a' is ascii 97 and base64 26
  if('a' <= c && c <= 'z') return c - 71;
    1020:	f1a3 0261 	sub.w	r2, r3, #97	@ 0x61
    1024:	b2d2      	uxtb	r2, r2
    1026:	2a19      	cmp	r2, #25
    1028:	d90a      	bls.n	1040 <base64_to_binary+0x2a>
  
  // Digits - '0' is ascii 48 and base64 52
  if('0' <= c && c <= '9') return c + 4;
    102a:	f1a3 0230 	sub.w	r2, r3, #48	@ 0x30
    102e:	b2d2      	uxtb	r2, r2
    1030:	2a09      	cmp	r2, #9
    1032:	d908      	bls.n	1046 <base64_to_binary+0x30>
  
  // '+' is ascii 43 and base64 62
  if(c == '+') return 62;
    1034:	2b2b      	cmp	r3, #43	@ 0x2b
    1036:	d009      	beq.n	104c <base64_to_binary+0x36>
  
  // '/' is ascii 47 and base64 63
  if(c == '/') return 63;
    1038:	2b2f      	cmp	r3, #47	@ 0x2f
    103a:	d009      	beq.n	1050 <base64_to_binary+0x3a>
  
  return 255;
    103c:	20ff      	movs	r0, #255	@ 0xff
    103e:	4770      	bx	lr
  if('a' <= c && c <= 'z') return c - 71;
    1040:	3b47      	subs	r3, #71	@ 0x47
    1042:	b2d8      	uxtb	r0, r3
    1044:	4770      	bx	lr
  if('0' <= c && c <= '9') return c + 4;
    1046:	3304      	adds	r3, #4
    1048:	b2d8      	uxtb	r0, r3
    104a:	4770      	bx	lr
  if(c == '+') return 62;
    104c:	203e      	movs	r0, #62	@ 0x3e
    104e:	4770      	bx	lr
  if(c == '/') return 63;
    1050:	203f      	movs	r0, #63	@ 0x3f
}
    1052:	4770      	bx	lr

00001054 <encode_base64_length>:

unsigned int encode_base64_length(unsigned int input_length) {
  return (input_length + 2)/3*4;
    1054:	3002      	adds	r0, #2
    1056:	4b03      	ldr	r3, [pc, #12]	@ (1064 <encode_base64_length+0x10>)
    1058:	fba3 3000 	umull	r3, r0, r3, r0
    105c:	0840      	lsrs	r0, r0, #1
}
    105e:	0080      	lsls	r0, r0, #2
    1060:	4770      	bx	lr
    1062:	bf00      	nop
    1064:	aaaaaaab 	bge	feaabb18 <_STACK_TOP_+0xdeaa3b1c>

00001068 <decode_base64_length>:

unsigned int decode_base64_length(unsigned char input[], unsigned int input_length) {
    1068:	b570      	push	{r4, r5, r6, lr}
    106a:	4605      	mov	r5, r0
    106c:	460e      	mov	r6, r1
  unsigned char *start = input;
  
  while(base64_to_binary(input[0]) < 64 && (unsigned int) (input - start) < input_length) {
    106e:	4604      	mov	r4, r0
    1070:	e000      	b.n	1074 <decode_base64_length+0xc>
    ++input;
    1072:	3401      	adds	r4, #1
  while(base64_to_binary(input[0]) < 64 && (unsigned int) (input - start) < input_length) {
    1074:	7820      	ldrb	r0, [r4, #0]
    1076:	f7ff ffce 	bl	1016 <base64_to_binary>
    107a:	283f      	cmp	r0, #63	@ 0x3f
    107c:	d802      	bhi.n	1084 <decode_base64_length+0x1c>
    107e:	1b63      	subs	r3, r4, r5
    1080:	42b3      	cmp	r3, r6
    1082:	d3f6      	bcc.n	1072 <decode_base64_length+0xa>
  }
  
  input_length = input - start;
    1084:	1b64      	subs	r4, r4, r5
  return input_length/4*3 + (input_length % 4 ? input_length % 4 - 1 : 0);
    1086:	08a0      	lsrs	r0, r4, #2
    1088:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    108c:	f014 0403 	ands.w	r4, r4, #3
    1090:	d002      	beq.n	1098 <decode_base64_length+0x30>
    1092:	3c01      	subs	r4, #1
}
    1094:	4420      	add	r0, r4
    1096:	bd70      	pop	{r4, r5, r6, pc}
  return input_length/4*3 + (input_length % 4 ? input_length % 4 - 1 : 0);
    1098:	2400      	movs	r4, #0
    109a:	e7fb      	b.n	1094 <decode_base64_length+0x2c>

0000109c <encode_base64>:

unsigned int encode_base64(unsigned char input[], unsigned int input_length, unsigned char output[]) {
    109c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    10a0:	4604      	mov	r4, r0
    10a2:	4688      	mov	r8, r1
    10a4:	4615      	mov	r5, r2
  unsigned int full_sets = input_length/3;
    10a6:	4f36      	ldr	r7, [pc, #216]	@ (1180 <encode_base64+0xe4>)
    10a8:	fba7 3701 	umull	r3, r7, r7, r1
    10ac:	087f      	lsrs	r7, r7, #1
  
  // While there are still full sets of 24 bits...
  for(unsigned int i = 0; i < full_sets; ++i) {
    10ae:	2600      	movs	r6, #0
    10b0:	e021      	b.n	10f6 <encode_base64+0x5a>
    output[0] = binary_to_base64(                         input[0] >> 2);
    10b2:	7820      	ldrb	r0, [r4, #0]
    10b4:	0880      	lsrs	r0, r0, #2
    10b6:	f7ff ff95 	bl	fe4 <binary_to_base64>
    10ba:	7028      	strb	r0, [r5, #0]
    output[1] = binary_to_base64((input[0] & 0x03) << 4 | input[1] >> 4);
    10bc:	7823      	ldrb	r3, [r4, #0]
    10be:	011b      	lsls	r3, r3, #4
    10c0:	f003 0330 	and.w	r3, r3, #48	@ 0x30
    10c4:	7860      	ldrb	r0, [r4, #1]
    10c6:	ea43 1010 	orr.w	r0, r3, r0, lsr #4
    10ca:	f7ff ff8b 	bl	fe4 <binary_to_base64>
    10ce:	7068      	strb	r0, [r5, #1]
    output[2] = binary_to_base64((input[1] & 0x0F) << 2 | input[2] >> 6);
    10d0:	7863      	ldrb	r3, [r4, #1]
    10d2:	009b      	lsls	r3, r3, #2
    10d4:	f003 033c 	and.w	r3, r3, #60	@ 0x3c
    10d8:	78a0      	ldrb	r0, [r4, #2]
    10da:	ea43 1090 	orr.w	r0, r3, r0, lsr #6
    10de:	f7ff ff81 	bl	fe4 <binary_to_base64>
    10e2:	70a8      	strb	r0, [r5, #2]
    output[3] = binary_to_base64( input[2] & 0x3F);
    10e4:	78a0      	ldrb	r0, [r4, #2]
    10e6:	f000 003f 	and.w	r0, r0, #63	@ 0x3f
    10ea:	f7ff ff7b 	bl	fe4 <binary_to_base64>
    10ee:	70e8      	strb	r0, [r5, #3]
    
    input += 3;
    10f0:	3403      	adds	r4, #3
    output += 4;
    10f2:	3504      	adds	r5, #4
  for(unsigned int i = 0; i < full_sets; ++i) {
    10f4:	3601      	adds	r6, #1
    10f6:	42be      	cmp	r6, r7
    10f8:	d3db      	bcc.n	10b2 <encode_base64+0x16>
  }
  
  switch(input_length % 3) {
    10fa:	4a21      	ldr	r2, [pc, #132]	@ (1180 <encode_base64+0xe4>)
    10fc:	fba2 3208 	umull	r3, r2, r2, r8
    1100:	f022 0301 	bic.w	r3, r2, #1
    1104:	eb03 0352 	add.w	r3, r3, r2, lsr #1
    1108:	eba8 0303 	sub.w	r3, r8, r3
    110c:	2b01      	cmp	r3, #1
    110e:	d009      	beq.n	1124 <encode_base64+0x88>
    1110:	2b02      	cmp	r3, #2
    1112:	d019      	beq.n	1148 <encode_base64+0xac>
    1114:	b123      	cbz	r3, 1120 <encode_base64+0x84>
      output[3] = '=';
      output[4] = '\0';
      break;
  }
  
  return encode_base64_length(input_length);
    1116:	4640      	mov	r0, r8
    1118:	f7ff ff9c 	bl	1054 <encode_base64_length>
}
    111c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      output[0] = '\0';
    1120:	702b      	strb	r3, [r5, #0]
      break;
    1122:	e7f8      	b.n	1116 <encode_base64+0x7a>
      output[0] = binary_to_base64(                         input[0] >> 2);
    1124:	7820      	ldrb	r0, [r4, #0]
    1126:	0880      	lsrs	r0, r0, #2
    1128:	f7ff ff5c 	bl	fe4 <binary_to_base64>
    112c:	7028      	strb	r0, [r5, #0]
      output[1] = binary_to_base64((input[0] & 0x03) << 4);
    112e:	7820      	ldrb	r0, [r4, #0]
    1130:	0100      	lsls	r0, r0, #4
    1132:	f000 0030 	and.w	r0, r0, #48	@ 0x30
    1136:	f7ff ff55 	bl	fe4 <binary_to_base64>
    113a:	7068      	strb	r0, [r5, #1]
      output[2] = '=';
    113c:	233d      	movs	r3, #61	@ 0x3d
    113e:	70ab      	strb	r3, [r5, #2]
      output[3] = '=';
    1140:	70eb      	strb	r3, [r5, #3]
      output[4] = '\0';
    1142:	2300      	movs	r3, #0
    1144:	712b      	strb	r3, [r5, #4]
      break;
    1146:	e7e6      	b.n	1116 <encode_base64+0x7a>
      output[0] = binary_to_base64(                         input[0] >> 2);
    1148:	7820      	ldrb	r0, [r4, #0]
    114a:	0880      	lsrs	r0, r0, #2
    114c:	f7ff ff4a 	bl	fe4 <binary_to_base64>
    1150:	7028      	strb	r0, [r5, #0]
      output[1] = binary_to_base64((input[0] & 0x03) << 4 | input[1] >> 4);
    1152:	7823      	ldrb	r3, [r4, #0]
    1154:	011b      	lsls	r3, r3, #4
    1156:	f003 0330 	and.w	r3, r3, #48	@ 0x30
    115a:	7860      	ldrb	r0, [r4, #1]
    115c:	ea43 1010 	orr.w	r0, r3, r0, lsr #4
    1160:	f7ff ff40 	bl	fe4 <binary_to_base64>
    1164:	7068      	strb	r0, [r5, #1]
      output[2] = binary_to_base64((input[1] & 0x0F) << 2);
    1166:	7860      	ldrb	r0, [r4, #1]
    1168:	0080      	lsls	r0, r0, #2
    116a:	f000 003c 	and.w	r0, r0, #60	@ 0x3c
    116e:	f7ff ff39 	bl	fe4 <binary_to_base64>
    1172:	70a8      	strb	r0, [r5, #2]
      output[3] = '=';
    1174:	233d      	movs	r3, #61	@ 0x3d
    1176:	70eb      	strb	r3, [r5, #3]
      output[4] = '\0';
    1178:	2300      	movs	r3, #0
    117a:	712b      	strb	r3, [r5, #4]
      break;
    117c:	e7cb      	b.n	1116 <encode_base64+0x7a>
    117e:	bf00      	nop
    1180:	aaaaaaab 	bge	feaabc34 <_STACK_TOP_+0xdeaa3c38>

00001184 <decode_base64>:


unsigned int decode_base64(unsigned char input[], unsigned int input_length, unsigned char output[]) {
    1184:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1188:	4604      	mov	r4, r0
    118a:	4616      	mov	r6, r2
  unsigned int output_length = decode_base64_length(input, input_length);
    118c:	f7ff ff6c 	bl	1068 <decode_base64_length>
    1190:	4680      	mov	r8, r0
  
  // While there are still full sets of 24 bits...
  for(unsigned int i = 2; i < output_length; i += 3) {
    1192:	2702      	movs	r7, #2
    1194:	e01f      	b.n	11d6 <decode_base64+0x52>
    output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
    1196:	7820      	ldrb	r0, [r4, #0]
    1198:	f7ff ff3d 	bl	1016 <base64_to_binary>
    119c:	0085      	lsls	r5, r0, #2
    119e:	7860      	ldrb	r0, [r4, #1]
    11a0:	f7ff ff39 	bl	1016 <base64_to_binary>
    11a4:	ea45 1510 	orr.w	r5, r5, r0, lsr #4
    11a8:	7035      	strb	r5, [r6, #0]
    output[1] = base64_to_binary(input[1]) << 4 | base64_to_binary(input[2]) >> 2;
    11aa:	7860      	ldrb	r0, [r4, #1]
    11ac:	f7ff ff33 	bl	1016 <base64_to_binary>
    11b0:	0105      	lsls	r5, r0, #4
    11b2:	78a0      	ldrb	r0, [r4, #2]
    11b4:	f7ff ff2f 	bl	1016 <base64_to_binary>
    11b8:	ea45 0590 	orr.w	r5, r5, r0, lsr #2
    11bc:	7075      	strb	r5, [r6, #1]
    output[2] = base64_to_binary(input[2]) << 6 | base64_to_binary(input[3]);
    11be:	78a0      	ldrb	r0, [r4, #2]
    11c0:	f7ff ff29 	bl	1016 <base64_to_binary>
    11c4:	0185      	lsls	r5, r0, #6
    11c6:	78e0      	ldrb	r0, [r4, #3]
    11c8:	f7ff ff25 	bl	1016 <base64_to_binary>
    11cc:	4328      	orrs	r0, r5
    11ce:	70b0      	strb	r0, [r6, #2]
    
    input += 4;
    11d0:	3404      	adds	r4, #4
    output += 3;
    11d2:	3603      	adds	r6, #3
  for(unsigned int i = 2; i < output_length; i += 3) {
    11d4:	3703      	adds	r7, #3
    11d6:	4547      	cmp	r7, r8
    11d8:	d3dd      	bcc.n	1196 <decode_base64+0x12>
  }
  
  switch(output_length % 3) {
    11da:	4a18      	ldr	r2, [pc, #96]	@ (123c <decode_base64+0xb8>)
    11dc:	fba2 3208 	umull	r3, r2, r2, r8
    11e0:	f022 0301 	bic.w	r3, r2, #1
    11e4:	eb03 0352 	add.w	r3, r3, r2, lsr #1
    11e8:	eba8 0303 	sub.w	r3, r8, r3
    11ec:	2b01      	cmp	r3, #1
    11ee:	d004      	beq.n	11fa <decode_base64+0x76>
    11f0:	2b02      	cmp	r3, #2
    11f2:	d00d      	beq.n	1210 <decode_base64+0x8c>
      output[1] = base64_to_binary(input[1]) << 4 | base64_to_binary(input[2]) >> 2;
      break;
  }
  
  return output_length;
    11f4:	4640      	mov	r0, r8
    11f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
    11fa:	7820      	ldrb	r0, [r4, #0]
    11fc:	f7ff ff0b 	bl	1016 <base64_to_binary>
    1200:	0085      	lsls	r5, r0, #2
    1202:	7860      	ldrb	r0, [r4, #1]
    1204:	f7ff ff07 	bl	1016 <base64_to_binary>
    1208:	ea45 1510 	orr.w	r5, r5, r0, lsr #4
    120c:	7035      	strb	r5, [r6, #0]
      break;
    120e:	e7f1      	b.n	11f4 <decode_base64+0x70>
      output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
    1210:	7820      	ldrb	r0, [r4, #0]
    1212:	f7ff ff00 	bl	1016 <base64_to_binary>
    1216:	0085      	lsls	r5, r0, #2
    1218:	7860      	ldrb	r0, [r4, #1]
    121a:	f7ff fefc 	bl	1016 <base64_to_binary>
    121e:	ea45 1510 	orr.w	r5, r5, r0, lsr #4
    1222:	7035      	strb	r5, [r6, #0]
      output[1] = base64_to_binary(input[1]) << 4 | base64_to_binary(input[2]) >> 2;
    1224:	7860      	ldrb	r0, [r4, #1]
    1226:	f7ff fef6 	bl	1016 <base64_to_binary>
    122a:	0105      	lsls	r5, r0, #4
    122c:	78a0      	ldrb	r0, [r4, #2]
    122e:	f7ff fef2 	bl	1016 <base64_to_binary>
    1232:	ea45 0590 	orr.w	r5, r5, r0, lsr #2
    1236:	7075      	strb	r5, [r6, #1]
  return output_length;
    1238:	e7dc      	b.n	11f4 <decode_base64+0x70>
    123a:	bf00      	nop
    123c:	aaaaaaab 	bge	feaabcf0 <_STACK_TOP_+0xdeaa3cf4>

00001240 <sha256_transform>:
	0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2
};

/*********************** FUNCTION DEFINITIONS ***********************/
void sha256_transform(SHA256_CTX *ctx, const BYTE data[])
{
    1240:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1244:	b0c9      	sub	sp, #292	@ 0x124
    1246:	4681      	mov	r9, r0
	WORD a, b, c, d, e, f, g, h, i, j, t1, t2, m[64];

	for (i = 0, j = 0; i < 16; ++i, j += 4)
    1248:	2000      	movs	r0, #0
    124a:	4602      	mov	r2, r0
    124c:	e00f      	b.n	126e <sha256_transform+0x2e>
		m[i] = (data[j] << 24) | (data[j + 1] << 16) | (data[j + 2] << 8) | (data[j + 3]);
    124e:	5c0d      	ldrb	r5, [r1, r0]
    1250:	180c      	adds	r4, r1, r0
    1252:	7863      	ldrb	r3, [r4, #1]
    1254:	041b      	lsls	r3, r3, #16
    1256:	ea43 6305 	orr.w	r3, r3, r5, lsl #24
    125a:	78a5      	ldrb	r5, [r4, #2]
    125c:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
    1260:	78e4      	ldrb	r4, [r4, #3]
    1262:	4323      	orrs	r3, r4
    1264:	ac08      	add	r4, sp, #32
    1266:	f844 3022 	str.w	r3, [r4, r2, lsl #2]
	for (i = 0, j = 0; i < 16; ++i, j += 4)
    126a:	3201      	adds	r2, #1
    126c:	3004      	adds	r0, #4
    126e:	2a0f      	cmp	r2, #15
    1270:	d9ed      	bls.n	124e <sha256_transform+0xe>
    1272:	e022      	b.n	12ba <sha256_transform+0x7a>
	for ( ; i < 64; ++i)
		m[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16];
    1274:	1e93      	subs	r3, r2, #2
    1276:	a908      	add	r1, sp, #32
    1278:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
    127c:	ea4f 43f1 	mov.w	r3, r1, ror #19
    1280:	ea83 4371 	eor.w	r3, r3, r1, ror #17
    1284:	ea83 2391 	eor.w	r3, r3, r1, lsr #10
    1288:	1fd1      	subs	r1, r2, #7
    128a:	a808      	add	r0, sp, #32
    128c:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
    1290:	440b      	add	r3, r1
    1292:	f1a2 010f 	sub.w	r1, r2, #15
    1296:	f850 0021 	ldr.w	r0, [r0, r1, lsl #2]
    129a:	ea4f 41b0 	mov.w	r1, r0, ror #18
    129e:	ea81 11f0 	eor.w	r1, r1, r0, ror #7
    12a2:	ea81 01d0 	eor.w	r1, r1, r0, lsr #3
    12a6:	440b      	add	r3, r1
    12a8:	f1a2 0110 	sub.w	r1, r2, #16
    12ac:	a808      	add	r0, sp, #32
    12ae:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
    12b2:	440b      	add	r3, r1
    12b4:	f840 3022 	str.w	r3, [r0, r2, lsl #2]
	for ( ; i < 64; ++i)
    12b8:	3201      	adds	r2, #1
    12ba:	2a3f      	cmp	r2, #63	@ 0x3f
    12bc:	d9da      	bls.n	1274 <sha256_transform+0x34>

	a = ctx->state[0];
    12be:	f8d9 a050 	ldr.w	sl, [r9, #80]	@ 0x50
	b = ctx->state[1];
    12c2:	f8d9 b054 	ldr.w	fp, [r9, #84]	@ 0x54
	c = ctx->state[2];
    12c6:	f8d9 1058 	ldr.w	r1, [r9, #88]	@ 0x58
	d = ctx->state[3];
    12ca:	f8d9 305c 	ldr.w	r3, [r9, #92]	@ 0x5c
	e = ctx->state[4];
    12ce:	f8d9 2060 	ldr.w	r2, [r9, #96]	@ 0x60
    12d2:	9201      	str	r2, [sp, #4]
	f = ctx->state[5];
    12d4:	f8d9 7064 	ldr.w	r7, [r9, #100]	@ 0x64
    12d8:	9702      	str	r7, [sp, #8]
	g = ctx->state[6];
    12da:	f8d9 6068 	ldr.w	r6, [r9, #104]	@ 0x68
    12de:	9603      	str	r6, [sp, #12]
	h = ctx->state[7];
    12e0:	f8d9 006c 	ldr.w	r0, [r9, #108]	@ 0x6c
    12e4:	9004      	str	r0, [sp, #16]
    12e6:	4686      	mov	lr, r0
	d = ctx->state[3];
    12e8:	4698      	mov	r8, r3
	c = ctx->state[2];
    12ea:	460c      	mov	r4, r1
	b = ctx->state[1];
    12ec:	465d      	mov	r5, fp
	a = ctx->state[0];
    12ee:	46d4      	mov	ip, sl

	for (i = 0; i < 64; ++i) {
    12f0:	2000      	movs	r0, #0
    12f2:	f8cd a014 	str.w	sl, [sp, #20]
    12f6:	f8cd b018 	str.w	fp, [sp, #24]
    12fa:	9107      	str	r1, [sp, #28]
    12fc:	e030      	b.n	1360 <sha256_transform+0x120>
		t1 = h + EP1(e) + CH(e,f,g) + k[i] + m[i];
    12fe:	ea4f 21f2 	mov.w	r1, r2, ror #11
    1302:	ea81 11b2 	eor.w	r1, r1, r2, ror #6
    1306:	ea81 6172 	eor.w	r1, r1, r2, ror #25
    130a:	4471      	add	r1, lr
    130c:	ea02 0e07 	and.w	lr, r2, r7
    1310:	ea26 0a02 	bic.w	sl, r6, r2
    1314:	ea8e 0e0a 	eor.w	lr, lr, sl
    1318:	448e      	add	lr, r1
    131a:	4925      	ldr	r1, [pc, #148]	@ (13b0 <sha256_transform+0x170>)
    131c:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
    1320:	eb0e 0a01 	add.w	sl, lr, r1
    1324:	a908      	add	r1, sp, #32
    1326:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
    132a:	448a      	add	sl, r1
		t2 = EP0(a) + MAJ(a,b,c);
    132c:	ea4f 3e7c 	mov.w	lr, ip, ror #13
    1330:	ea8e 0ebc 	eor.w	lr, lr, ip, ror #2
    1334:	ea8e 5ebc 	eor.w	lr, lr, ip, ror #22
    1338:	ea85 0104 	eor.w	r1, r5, r4
    133c:	ea01 010c 	and.w	r1, r1, ip
    1340:	ea05 0b04 	and.w	fp, r5, r4
    1344:	ea81 010b 	eor.w	r1, r1, fp
    1348:	4471      	add	r1, lr
	for (i = 0; i < 64; ++i) {
    134a:	3001      	adds	r0, #1
		h = g;
    134c:	46b6      	mov	lr, r6
		g = f;
    134e:	463e      	mov	r6, r7
		f = e;
    1350:	4617      	mov	r7, r2
		e = d + t1;
    1352:	eb08 020a 	add.w	r2, r8, sl
		d = c;
    1356:	46a0      	mov	r8, r4
		c = b;
    1358:	462c      	mov	r4, r5
		b = a;
    135a:	4665      	mov	r5, ip
		a = t1 + t2;
    135c:	eb0a 0c01 	add.w	ip, sl, r1
	for (i = 0; i < 64; ++i) {
    1360:	283f      	cmp	r0, #63	@ 0x3f
    1362:	d9cc      	bls.n	12fe <sha256_transform+0xbe>
	}

	ctx->state[0] += a;
    1364:	f8dd a014 	ldr.w	sl, [sp, #20]
    1368:	f8dd b018 	ldr.w	fp, [sp, #24]
    136c:	9907      	ldr	r1, [sp, #28]
    136e:	eb0c 000a 	add.w	r0, ip, sl
    1372:	f8c9 0050 	str.w	r0, [r9, #80]	@ 0x50
	ctx->state[1] += b;
    1376:	445d      	add	r5, fp
    1378:	f8c9 5054 	str.w	r5, [r9, #84]	@ 0x54
	ctx->state[2] += c;
    137c:	440c      	add	r4, r1
    137e:	f8c9 4058 	str.w	r4, [r9, #88]	@ 0x58
	ctx->state[3] += d;
    1382:	4443      	add	r3, r8
    1384:	f8c9 305c 	str.w	r3, [r9, #92]	@ 0x5c
	ctx->state[4] += e;
    1388:	9b01      	ldr	r3, [sp, #4]
    138a:	441a      	add	r2, r3
    138c:	f8c9 2060 	str.w	r2, [r9, #96]	@ 0x60
	ctx->state[5] += f;
    1390:	9b02      	ldr	r3, [sp, #8]
    1392:	441f      	add	r7, r3
    1394:	f8c9 7064 	str.w	r7, [r9, #100]	@ 0x64
	ctx->state[6] += g;
    1398:	9b03      	ldr	r3, [sp, #12]
    139a:	441e      	add	r6, r3
    139c:	f8c9 6068 	str.w	r6, [r9, #104]	@ 0x68
	ctx->state[7] += h;
    13a0:	9b04      	ldr	r3, [sp, #16]
    13a2:	4473      	add	r3, lr
    13a4:	f8c9 306c 	str.w	r3, [r9, #108]	@ 0x6c
}
    13a8:	b049      	add	sp, #292	@ 0x124
    13aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    13ae:	bf00      	nop
    13b0:	00003004 	andeq	r3, r0, r4

000013b4 <sha256_init>:

void sha256_init(SHA256_CTX *ctx)
{
	ctx->datalen = 0;
    13b4:	2300      	movs	r3, #0
    13b6:	6403      	str	r3, [r0, #64]	@ 0x40
	ctx->bitlen = 0;
    13b8:	2200      	movs	r2, #0
    13ba:	2300      	movs	r3, #0
    13bc:	e9c0 2312 	strd	r2, r3, [r0, #72]	@ 0x48
	ctx->state[0] = 0x6a09e667;
    13c0:	4b0a      	ldr	r3, [pc, #40]	@ (13ec <sha256_init+0x38>)
    13c2:	6503      	str	r3, [r0, #80]	@ 0x50
	ctx->state[1] = 0xbb67ae85;
    13c4:	4b0a      	ldr	r3, [pc, #40]	@ (13f0 <sha256_init+0x3c>)
    13c6:	6543      	str	r3, [r0, #84]	@ 0x54
	ctx->state[2] = 0x3c6ef372;
    13c8:	4b0a      	ldr	r3, [pc, #40]	@ (13f4 <sha256_init+0x40>)
    13ca:	6583      	str	r3, [r0, #88]	@ 0x58
	ctx->state[3] = 0xa54ff53a;
    13cc:	4b0a      	ldr	r3, [pc, #40]	@ (13f8 <sha256_init+0x44>)
    13ce:	65c3      	str	r3, [r0, #92]	@ 0x5c
	ctx->state[4] = 0x510e527f;
    13d0:	4b0a      	ldr	r3, [pc, #40]	@ (13fc <sha256_init+0x48>)
    13d2:	6603      	str	r3, [r0, #96]	@ 0x60
	ctx->state[5] = 0x9b05688c;
    13d4:	4b0a      	ldr	r3, [pc, #40]	@ (1400 <sha256_init+0x4c>)
    13d6:	6643      	str	r3, [r0, #100]	@ 0x64
	ctx->state[6] = 0x1f83d9ab;
    13d8:	4b0a      	ldr	r3, [pc, #40]	@ (1404 <sha256_init+0x50>)
    13da:	6683      	str	r3, [r0, #104]	@ 0x68
	ctx->state[7] = 0x5be0cd19;
    13dc:	f103 5374 	add.w	r3, r3, #1023410176	@ 0x3d000000
    13e0:	f5a3 0323 	sub.w	r3, r3, #10682368	@ 0xa30000
    13e4:	f6a3 4392 	subw	r3, r3, #3218	@ 0xc92
    13e8:	66c3      	str	r3, [r0, #108]	@ 0x6c
}
    13ea:	4770      	bx	lr
    13ec:	6a09e667 	bvs	27ad90 <__ROM_SIZE__+0x23ad90>
    13f0:	bb67ae85 	bllt	19ece0c <__ROM_SIZE__+0x19ace0c>
    13f4:	3c6ef372 	stclcc	3, cr15, [lr], #-456	@ 0xfffffe38
    13f8:	a54ff53a 	strbge	pc, [pc, #-1338]	@ ec6 <shell+0xee>	@ <UNPREDICTABLE>
    13fc:	510e527f 	tstpl	lr, pc, ror r2
    1400:	9b05688c 	blls	15b638 <__ROM_SIZE__+0x11b638>
    1404:	1f83d9ab 	svcne	0x0083d9ab

00001408 <sha256_update>:

void sha256_update(SHA256_CTX *ctx, const BYTE data[], size_t len)
{
    1408:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    140a:	4604      	mov	r4, r0
    140c:	460f      	mov	r7, r1
    140e:	4616      	mov	r6, r2
	WORD i;

	for (i = 0; i < len; ++i) {
    1410:	2500      	movs	r5, #0
    1412:	e000      	b.n	1416 <sha256_update+0xe>
    1414:	3501      	adds	r5, #1
    1416:	42b5      	cmp	r5, r6
    1418:	d215      	bcs.n	1446 <sha256_update+0x3e>
		ctx->data[ctx->datalen] = data[i];
    141a:	6c23      	ldr	r3, [r4, #64]	@ 0x40
    141c:	5d78      	ldrb	r0, [r7, r5]
    141e:	54e0      	strb	r0, [r4, r3]
		ctx->datalen++;
    1420:	3301      	adds	r3, #1
    1422:	6423      	str	r3, [r4, #64]	@ 0x40
		if (ctx->datalen == 64) {
    1424:	2b40      	cmp	r3, #64	@ 0x40
    1426:	d1f5      	bne.n	1414 <sha256_update+0xc>
			sha256_transform(ctx, ctx->data);
    1428:	4621      	mov	r1, r4
    142a:	4620      	mov	r0, r4
    142c:	f7ff ff08 	bl	1240 <sha256_transform>
			ctx->bitlen += 512;
    1430:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
    1432:	6ce2      	ldr	r2, [r4, #76]	@ 0x4c
    1434:	f513 7300 	adds.w	r3, r3, #512	@ 0x200
    1438:	f142 0200 	adc.w	r2, r2, #0
    143c:	64a3      	str	r3, [r4, #72]	@ 0x48
    143e:	64e2      	str	r2, [r4, #76]	@ 0x4c
			ctx->datalen = 0;
    1440:	2300      	movs	r3, #0
    1442:	6423      	str	r3, [r4, #64]	@ 0x40
    1444:	e7e6      	b.n	1414 <sha256_update+0xc>
		}
	}
}
    1446:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00001448 <sha256_final>:

void sha256_final(SHA256_CTX *ctx, BYTE hash[])
{
    1448:	b538      	push	{r3, r4, r5, lr}
    144a:	4604      	mov	r4, r0
    144c:	460d      	mov	r5, r1
	WORD i;

	i = ctx->datalen;
    144e:	6c02      	ldr	r2, [r0, #64]	@ 0x40

	// Pad whatever data is left in the buffer.
	if (ctx->datalen < 56) {
    1450:	2a37      	cmp	r2, #55	@ 0x37
    1452:	d82d      	bhi.n	14b0 <sha256_final+0x68>
		ctx->data[i++] = 0x80;
    1454:	1c53      	adds	r3, r2, #1
    1456:	2180      	movs	r1, #128	@ 0x80
    1458:	5481      	strb	r1, [r0, r2]
		while (i < 56)
    145a:	e002      	b.n	1462 <sha256_final+0x1a>
			ctx->data[i++] = 0x00;
    145c:	2200      	movs	r2, #0
    145e:	54e2      	strb	r2, [r4, r3]
    1460:	3301      	adds	r3, #1
		while (i < 56)
    1462:	2b37      	cmp	r3, #55	@ 0x37
    1464:	d9fa      	bls.n	145c <sha256_final+0x14>
		sha256_transform(ctx, ctx->data);
		memset(ctx->data, 0, 56);
	}

	// Append to the padding the total message's length in bits and transform.
	ctx->bitlen += ctx->datalen * 8;
    1466:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
    1468:	6ce2      	ldr	r2, [r4, #76]	@ 0x4c
    146a:	6c21      	ldr	r1, [r4, #64]	@ 0x40
    146c:	00c9      	lsls	r1, r1, #3
    146e:	185b      	adds	r3, r3, r1
    1470:	f142 0200 	adc.w	r2, r2, #0
    1474:	64a3      	str	r3, [r4, #72]	@ 0x48
    1476:	64e2      	str	r2, [r4, #76]	@ 0x4c
	ctx->data[63] = ctx->bitlen;
    1478:	f884 303f 	strb.w	r3, [r4, #63]	@ 0x3f
	ctx->data[62] = ctx->bitlen >> 8;
    147c:	0a19      	lsrs	r1, r3, #8
    147e:	f884 103e 	strb.w	r1, [r4, #62]	@ 0x3e
	ctx->data[61] = ctx->bitlen >> 16;
    1482:	0c19      	lsrs	r1, r3, #16
    1484:	f884 103d 	strb.w	r1, [r4, #61]	@ 0x3d
	ctx->data[60] = ctx->bitlen >> 24;
    1488:	0e1b      	lsrs	r3, r3, #24
    148a:	f884 303c 	strb.w	r3, [r4, #60]	@ 0x3c
	ctx->data[59] = ctx->bitlen >> 32;
    148e:	f884 203b 	strb.w	r2, [r4, #59]	@ 0x3b
	ctx->data[58] = ctx->bitlen >> 40;
    1492:	0a13      	lsrs	r3, r2, #8
    1494:	f884 303a 	strb.w	r3, [r4, #58]	@ 0x3a
	ctx->data[57] = ctx->bitlen >> 48;
    1498:	0c13      	lsrs	r3, r2, #16
    149a:	f884 3039 	strb.w	r3, [r4, #57]	@ 0x39
	ctx->data[56] = ctx->bitlen >> 56;
    149e:	0e12      	lsrs	r2, r2, #24
    14a0:	f884 2038 	strb.w	r2, [r4, #56]	@ 0x38
	sha256_transform(ctx, ctx->data);
    14a4:	4621      	mov	r1, r4
    14a6:	4620      	mov	r0, r4
    14a8:	f7ff feca 	bl	1240 <sha256_transform>

	// Since this implementation uses little endian byte ordering and SHA uses big endian,
	// reverse all the bytes when copying the final state to the output hash.
	for (i = 0; i < 4; ++i) {
    14ac:	2300      	movs	r3, #0
    14ae:	e03b      	b.n	1528 <sha256_final+0xe0>
		ctx->data[i++] = 0x80;
    14b0:	1c53      	adds	r3, r2, #1
    14b2:	2180      	movs	r1, #128	@ 0x80
    14b4:	5481      	strb	r1, [r0, r2]
		while (i < 64)
    14b6:	e002      	b.n	14be <sha256_final+0x76>
			ctx->data[i++] = 0x00;
    14b8:	2200      	movs	r2, #0
    14ba:	54e2      	strb	r2, [r4, r3]
    14bc:	3301      	adds	r3, #1
		while (i < 64)
    14be:	2b3f      	cmp	r3, #63	@ 0x3f
    14c0:	d9fa      	bls.n	14b8 <sha256_final+0x70>
		sha256_transform(ctx, ctx->data);
    14c2:	4621      	mov	r1, r4
    14c4:	4620      	mov	r0, r4
    14c6:	f7ff febb 	bl	1240 <sha256_transform>
		memset(ctx->data, 0, 56);
    14ca:	2238      	movs	r2, #56	@ 0x38
    14cc:	2100      	movs	r1, #0
    14ce:	4620      	mov	r0, r4
    14d0:	f001 f980 	bl	27d4 <memset>
    14d4:	e7c7      	b.n	1466 <sha256_final+0x1e>
		hash[i]      = (ctx->state[0] >> (24 - i * 8)) & 0x000000ff;
    14d6:	6d21      	ldr	r1, [r4, #80]	@ 0x50
    14d8:	f1c3 0203 	rsb	r2, r3, #3
    14dc:	00d2      	lsls	r2, r2, #3
    14de:	40d1      	lsrs	r1, r2
    14e0:	54e9      	strb	r1, [r5, r3]
		hash[i + 4]  = (ctx->state[1] >> (24 - i * 8)) & 0x000000ff;
    14e2:	6d61      	ldr	r1, [r4, #84]	@ 0x54
    14e4:	40d1      	lsrs	r1, r2
    14e6:	1d18      	adds	r0, r3, #4
    14e8:	5429      	strb	r1, [r5, r0]
		hash[i + 8]  = (ctx->state[2] >> (24 - i * 8)) & 0x000000ff;
    14ea:	6da1      	ldr	r1, [r4, #88]	@ 0x58
    14ec:	40d1      	lsrs	r1, r2
    14ee:	f103 0008 	add.w	r0, r3, #8
    14f2:	5429      	strb	r1, [r5, r0]
		hash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0x000000ff;
    14f4:	6de1      	ldr	r1, [r4, #92]	@ 0x5c
    14f6:	40d1      	lsrs	r1, r2
    14f8:	f103 000c 	add.w	r0, r3, #12
    14fc:	5429      	strb	r1, [r5, r0]
		hash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0x000000ff;
    14fe:	6e21      	ldr	r1, [r4, #96]	@ 0x60
    1500:	40d1      	lsrs	r1, r2
    1502:	f103 0010 	add.w	r0, r3, #16
    1506:	5429      	strb	r1, [r5, r0]
		hash[i + 20] = (ctx->state[5] >> (24 - i * 8)) & 0x000000ff;
    1508:	6e61      	ldr	r1, [r4, #100]	@ 0x64
    150a:	40d1      	lsrs	r1, r2
    150c:	f103 0014 	add.w	r0, r3, #20
    1510:	5429      	strb	r1, [r5, r0]
		hash[i + 24] = (ctx->state[6] >> (24 - i * 8)) & 0x000000ff;
    1512:	6ea1      	ldr	r1, [r4, #104]	@ 0x68
    1514:	40d1      	lsrs	r1, r2
    1516:	f103 0018 	add.w	r0, r3, #24
    151a:	5429      	strb	r1, [r5, r0]
		hash[i + 28] = (ctx->state[7] >> (24 - i * 8)) & 0x000000ff;
    151c:	6ee1      	ldr	r1, [r4, #108]	@ 0x6c
    151e:	40d1      	lsrs	r1, r2
    1520:	f103 021c 	add.w	r2, r3, #28
    1524:	54a9      	strb	r1, [r5, r2]
	for (i = 0; i < 4; ++i) {
    1526:	3301      	adds	r3, #1
    1528:	2b03      	cmp	r3, #3
    152a:	d9d4      	bls.n	14d6 <sha256_final+0x8e>
	}
}
    152c:	bd38      	pop	{r3, r4, r5, pc}
    152e:	bf00      	nop

00001530 <outstr>:
} printf_state;

static char hextable[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                          '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

static void outstr(const char *str) {
    1530:	b510      	push	{r4, lr}
    1532:	4604      	mov	r4, r0
  while (*str != '\0') {
    1534:	e003      	b.n	153e <outstr+0xe>
    __write_char__(*str);
    1536:	4b04      	ldr	r3, [pc, #16]	@ (1548 <outstr+0x18>)
    1538:	681b      	ldr	r3, [r3, #0]
    153a:	4798      	blx	r3
    str++;
    153c:	3401      	adds	r4, #1
  while (*str != '\0') {
    153e:	7820      	ldrb	r0, [r4, #0]
    1540:	2800      	cmp	r0, #0
    1542:	d1f8      	bne.n	1536 <outstr+0x6>
  }
}
    1544:	bd10      	pop	{r4, pc}
    1546:	bf00      	nop
    1548:	20000050 	andcs	r0, r0, r0, asr r0

0000154c <printf_numbers>:

static bool printf_numbers(const char fmt, va_list *args, int l_count) {
    154c:	b530      	push	{r4, r5, lr}
    154e:	b085      	sub	sp, #20
    1550:	4614      	mov	r4, r2
  char num[MAX_DIGITS];
  int num_len = 0;

  switch (fmt) {
    1552:	2864      	cmp	r0, #100	@ 0x64
    1554:	d01d      	beq.n	1592 <printf_numbers+0x46>
    1556:	d914      	bls.n	1582 <printf_numbers+0x36>
    1558:	2875      	cmp	r0, #117	@ 0x75
    155a:	d001      	beq.n	1560 <printf_numbers+0x14>
    155c:	2878      	cmp	r0, #120	@ 0x78
    155e:	d112      	bne.n	1586 <printf_numbers+0x3a>
#ifndef SHELL_NO_PRINTF_LL
      long long unsigned int value = 0;
#else
      unsigned int value = 0;
#endif  // SHELL_NO_PRINTF_LL
      if (l_count == 0) {
    1560:	2c00      	cmp	r4, #0
    1562:	f040 8086 	bne.w	1672 <printf_numbers+0x126>
        value = va_arg(*args, unsigned int);
    1566:	680b      	ldr	r3, [r1, #0]
    1568:	1d1a      	adds	r2, r3, #4
    156a:	600a      	str	r2, [r1, #0]
    156c:	681d      	ldr	r5, [r3, #0]
#endif  // SHELL_NO_PRINTF_LL
      } else {
        return false;
      }

      if (fmt == 'u') {
    156e:	2875      	cmp	r0, #117	@ 0x75
    1570:	d043      	beq.n	15fa <printf_numbers+0xae>

        while (num_len > 0) {
          __write_char__(num[--num_len]);
        };
      } else {
        if (value == 0) {
    1572:	2d00      	cmp	r5, #0
    1574:	d176      	bne.n	1664 <printf_numbers+0x118>
          __write_char__(hextable[0]);
    1576:	4b40      	ldr	r3, [pc, #256]	@ (1678 <printf_numbers+0x12c>)
    1578:	681b      	ldr	r3, [r3, #0]
    157a:	2030      	movs	r0, #48	@ 0x30
    157c:	4798      	blx	r3
    }
    default:
      outstr("\nprintf-error\n");
      return false;
  }
  return true;
    157e:	2001      	movs	r0, #1
    1580:	e005      	b.n	158e <printf_numbers+0x42>
  switch (fmt) {
    1582:	2858      	cmp	r0, #88	@ 0x58
    1584:	d0ec      	beq.n	1560 <printf_numbers+0x14>
      outstr("\nprintf-error\n");
    1586:	483d      	ldr	r0, [pc, #244]	@ (167c <printf_numbers+0x130>)
    1588:	f7ff ffd2 	bl	1530 <outstr>
      return false;
    158c:	2000      	movs	r0, #0
}
    158e:	b005      	add	sp, #20
    1590:	bd30      	pop	{r4, r5, pc}
      if (l_count == 0) {
    1592:	2a00      	cmp	r2, #0
    1594:	d16b      	bne.n	166e <printf_numbers+0x122>
        value = va_arg(*args, int);
    1596:	680b      	ldr	r3, [r1, #0]
    1598:	1d1a      	adds	r2, r3, #4
    159a:	600a      	str	r2, [r1, #0]
    159c:	681d      	ldr	r5, [r3, #0]
      if (value < 0) {
    159e:	2d00      	cmp	r5, #0
    15a0:	db17      	blt.n	15d2 <printf_numbers+0x86>
        num[num_len++] = hextable[value % 10];
    15a2:	4a37      	ldr	r2, [pc, #220]	@ (1680 <printf_numbers+0x134>)
    15a4:	fb82 3205 	smull	r3, r2, r2, r5
    15a8:	17eb      	asrs	r3, r5, #31
    15aa:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
    15ae:	4619      	mov	r1, r3
    15b0:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    15b4:	eba5 0343 	sub.w	r3, r5, r3, lsl #1
    15b8:	4832      	ldr	r0, [pc, #200]	@ (1684 <printf_numbers+0x138>)
    15ba:	5cc0      	ldrb	r0, [r0, r3]
    15bc:	4623      	mov	r3, r4
    15be:	3310      	adds	r3, #16
    15c0:	446b      	add	r3, sp
    15c2:	3401      	adds	r4, #1
    15c4:	f803 0c0c 	strb.w	r0, [r3, #-12]
        value = value / 10;
    15c8:	462b      	mov	r3, r5
    15ca:	460d      	mov	r5, r1
      } while (value > 0);
    15cc:	2b09      	cmp	r3, #9
    15ce:	dce8      	bgt.n	15a2 <printf_numbers+0x56>
    15d0:	e00f      	b.n	15f2 <printf_numbers+0xa6>
        __write_char__('-');
    15d2:	4b29      	ldr	r3, [pc, #164]	@ (1678 <printf_numbers+0x12c>)
    15d4:	681b      	ldr	r3, [r3, #0]
    15d6:	202d      	movs	r0, #45	@ 0x2d
    15d8:	4798      	blx	r3
        value = -value;
    15da:	426d      	negs	r5, r5
    15dc:	e7e1      	b.n	15a2 <printf_numbers+0x56>
        __write_char__(num[--num_len]);
    15de:	3c01      	subs	r4, #1
    15e0:	f104 0310 	add.w	r3, r4, #16
    15e4:	eb0d 0203 	add.w	r2, sp, r3
    15e8:	4b23      	ldr	r3, [pc, #140]	@ (1678 <printf_numbers+0x12c>)
    15ea:	681b      	ldr	r3, [r3, #0]
    15ec:	f812 0c0c 	ldrb.w	r0, [r2, #-12]
    15f0:	4798      	blx	r3
      while (num_len > 0) {
    15f2:	2c00      	cmp	r4, #0
    15f4:	dcf3      	bgt.n	15de <printf_numbers+0x92>
  return true;
    15f6:	2001      	movs	r0, #1
    15f8:	e7c9      	b.n	158e <printf_numbers+0x42>
          num[num_len++] = hextable[value % 10];
    15fa:	4b23      	ldr	r3, [pc, #140]	@ (1688 <printf_numbers+0x13c>)
    15fc:	fba3 2305 	umull	r2, r3, r3, r5
    1600:	08db      	lsrs	r3, r3, #3
    1602:	4619      	mov	r1, r3
    1604:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    1608:	eba5 0343 	sub.w	r3, r5, r3, lsl #1
    160c:	481d      	ldr	r0, [pc, #116]	@ (1684 <printf_numbers+0x138>)
    160e:	5cc0      	ldrb	r0, [r0, r3]
    1610:	4623      	mov	r3, r4
    1612:	3310      	adds	r3, #16
    1614:	446b      	add	r3, sp
    1616:	3401      	adds	r4, #1
    1618:	f803 0c0c 	strb.w	r0, [r3, #-12]
          value = value / 10;
    161c:	462b      	mov	r3, r5
    161e:	460d      	mov	r5, r1
        } while (value > 0);
    1620:	2b09      	cmp	r3, #9
    1622:	d8ea      	bhi.n	15fa <printf_numbers+0xae>
        while (num_len > 0) {
    1624:	2c00      	cmp	r4, #0
    1626:	dd0a      	ble.n	163e <printf_numbers+0xf2>
          __write_char__(num[--num_len]);
    1628:	3c01      	subs	r4, #1
    162a:	f104 0310 	add.w	r3, r4, #16
    162e:	eb0d 0203 	add.w	r2, sp, r3
    1632:	4b11      	ldr	r3, [pc, #68]	@ (1678 <printf_numbers+0x12c>)
    1634:	681b      	ldr	r3, [r3, #0]
    1636:	f812 0c0c 	ldrb.w	r0, [r2, #-12]
    163a:	4798      	blx	r3
    163c:	e7f2      	b.n	1624 <printf_numbers+0xd8>
  return true;
    163e:	2001      	movs	r0, #1
    1640:	e7a5      	b.n	158e <printf_numbers+0x42>
              __write_char__(hextable[val]);
    1642:	4a0d      	ldr	r2, [pc, #52]	@ (1678 <printf_numbers+0x12c>)
    1644:	6812      	ldr	r2, [r2, #0]
    1646:	490f      	ldr	r1, [pc, #60]	@ (1684 <printf_numbers+0x138>)
    1648:	5cc8      	ldrb	r0, [r1, r3]
    164a:	4790      	blx	r2
              leading_zero_ignored = true;
    164c:	2201      	movs	r2, #1
            start_bit -= 4;
    164e:	3c04      	subs	r4, #4
          while (start_bit >= 0) {
    1650:	2c00      	cmp	r4, #0
    1652:	db0a      	blt.n	166a <printf_numbers+0x11e>
            int val = (value >> start_bit) & 0xF;
    1654:	fa25 f304 	lsr.w	r3, r5, r4
            if (val || leading_zero_ignored) {
    1658:	f013 030f 	ands.w	r3, r3, #15
    165c:	d1f1      	bne.n	1642 <printf_numbers+0xf6>
    165e:	2a00      	cmp	r2, #0
    1660:	d0f5      	beq.n	164e <printf_numbers+0x102>
    1662:	e7ee      	b.n	1642 <printf_numbers+0xf6>
          bool leading_zero_ignored = false;
    1664:	2200      	movs	r2, #0
          int start_bit = LAST_NIBBLE_FIRST_BIT;
    1666:	241c      	movs	r4, #28
    1668:	e7f2      	b.n	1650 <printf_numbers+0x104>
  return true;
    166a:	2001      	movs	r0, #1
    166c:	e78f      	b.n	158e <printf_numbers+0x42>
        return false;
    166e:	2000      	movs	r0, #0
    1670:	e78d      	b.n	158e <printf_numbers+0x42>
        return false;
    1672:	2000      	movs	r0, #0
    1674:	e78b      	b.n	158e <printf_numbers+0x42>
    1676:	bf00      	nop
    1678:	20000050 	andcs	r0, r0, r0, asr r0
    167c:	00003104 	andeq	r3, r0, r4, lsl #2
    1680:	66666667 	strbtvs	r6, [r6], -r7, ror #12
    1684:	00003114 	andeq	r3, r0, r4, lsl r1
    1688:	cccccccd 	stclgt	12, cr12, [ip], {205}	@ 0xcd

0000168c <printf>:

int printf(const char *fmt, ...) {
    168c:	b40f      	push	{r0, r1, r2, r3}
    168e:	b530      	push	{r4, r5, lr}
    1690:	b083      	sub	sp, #12
    1692:	ab06      	add	r3, sp, #24
    1694:	f853 4b04 	ldr.w	r4, [r3], #4
  printf_state state = CHECK_CH;
  va_list args;

  va_start(args, fmt);
    1698:	9301      	str	r3, [sp, #4]
  printf_state state = CHECK_CH;
    169a:	2500      	movs	r5, #0

  while (*fmt) {
    169c:	e005      	b.n	16aa <printf+0x1e>
    switch (state) {
      case CHECK_CH: {
        if (*fmt == '%') {
    169e:	2825      	cmp	r0, #37	@ 0x25
    16a0:	d00a      	beq.n	16b8 <printf+0x2c>
          state = PARSE_FMT_STR;
          fmt++;
          continue;
        }
        __write_char__(*fmt);
    16a2:	4b30      	ldr	r3, [pc, #192]	@ (1764 <printf+0xd8>)
    16a4:	681b      	ldr	r3, [r3, #0]
    16a6:	4798      	blx	r3
        fmt++;
    16a8:	3401      	adds	r4, #1
  while (*fmt) {
    16aa:	7820      	ldrb	r0, [r4, #0]
    16ac:	2800      	cmp	r0, #0
    16ae:	d050      	beq.n	1752 <printf+0xc6>
    switch (state) {
    16b0:	2d00      	cmp	r5, #0
    16b2:	d0f4      	beq.n	169e <printf+0x12>
    16b4:	b925      	cbnz	r5, 16c0 <printf+0x34>
    16b6:	e7f8      	b.n	16aa <printf+0x1e>
          fmt++;
    16b8:	3401      	adds	r4, #1
          state = PARSE_FMT_STR;
    16ba:	2501      	movs	r5, #1
          continue;
    16bc:	e7f5      	b.n	16aa <printf+0x1e>
        break;
      }
      case PARSE_FMT_STR: {
        // Support only basic format specifiers
        while (*fmt && ((*fmt >= '0' && *fmt <= '9') || *fmt == '-')) {
          fmt++;
    16be:	3401      	adds	r4, #1
        while (*fmt && ((*fmt >= '0' && *fmt <= '9') || *fmt == '-')) {
    16c0:	7820      	ldrb	r0, [r4, #0]
    16c2:	b130      	cbz	r0, 16d2 <printf+0x46>
    16c4:	f1a0 0330 	sub.w	r3, r0, #48	@ 0x30
    16c8:	b2db      	uxtb	r3, r3
    16ca:	2b09      	cmp	r3, #9
    16cc:	d9f7      	bls.n	16be <printf+0x32>
    16ce:	282d      	cmp	r0, #45	@ 0x2d
    16d0:	d0f5      	beq.n	16be <printf+0x32>
        }

        switch (*fmt) {
    16d2:	2863      	cmp	r0, #99	@ 0x63
    16d4:	d019      	beq.n	170a <printf+0x7e>
    16d6:	d80b      	bhi.n	16f0 <printf+0x64>
    16d8:	2843      	cmp	r0, #67	@ 0x43
    16da:	d016      	beq.n	170a <printf+0x7e>
    16dc:	2853      	cmp	r0, #83	@ 0x53
    16de:	d00b      	beq.n	16f8 <printf+0x6c>
    16e0:	2825      	cmp	r0, #37	@ 0x25
    16e2:	d12c      	bne.n	173e <printf+0xb2>
          case '%':
            __write_char__(*fmt);
    16e4:	4b1f      	ldr	r3, [pc, #124]	@ (1764 <printf+0xd8>)
    16e6:	681b      	ldr	r3, [r3, #0]
    16e8:	4798      	blx	r3
            fmt++;
    16ea:	3401      	adds	r4, #1
            state = CHECK_CH;
    16ec:	2500      	movs	r5, #0
            break;
    16ee:	e7dc      	b.n	16aa <printf+0x1e>
    16f0:	286c      	cmp	r0, #108	@ 0x6c
    16f2:	d014      	beq.n	171e <printf+0x92>
    16f4:	2873      	cmp	r0, #115	@ 0x73
    16f6:	d122      	bne.n	173e <printf+0xb2>
            fmt++;
            state = CHECK_CH;
            break;
          case 's':
          case 'S':
            outstr(va_arg(args, const char *));
    16f8:	9b01      	ldr	r3, [sp, #4]
    16fa:	1d1a      	adds	r2, r3, #4
    16fc:	9201      	str	r2, [sp, #4]
    16fe:	6818      	ldr	r0, [r3, #0]
    1700:	f7ff ff16 	bl	1530 <outstr>
            fmt++;
    1704:	3401      	adds	r4, #1
            state = CHECK_CH;
    1706:	2500      	movs	r5, #0
            break;
    1708:	e7cf      	b.n	16aa <printf+0x1e>
            __write_char__(va_arg(args, int));
    170a:	4b16      	ldr	r3, [pc, #88]	@ (1764 <printf+0xd8>)
    170c:	681a      	ldr	r2, [r3, #0]
    170e:	9b01      	ldr	r3, [sp, #4]
    1710:	1d19      	adds	r1, r3, #4
    1712:	9101      	str	r1, [sp, #4]
    1714:	7818      	ldrb	r0, [r3, #0]
    1716:	4790      	blx	r2
            fmt++;
    1718:	3401      	adds	r4, #1
            state = CHECK_CH;
    171a:	2500      	movs	r5, #0
            break;
    171c:	e7c5      	b.n	16aa <printf+0x1e>
          case 'l': {
            int l_count = 1;
            fmt++;
    171e:	1c65      	adds	r5, r4, #1
            if (*fmt == 'l') {
    1720:	7863      	ldrb	r3, [r4, #1]
    1722:	2b6c      	cmp	r3, #108	@ 0x6c
    1724:	d008      	beq.n	1738 <printf+0xac>
            int l_count = 1;
    1726:	2201      	movs	r2, #1
              l_count++;
              fmt++;
            }
            if (printf_numbers(*fmt, &args, l_count)) {
    1728:	a901      	add	r1, sp, #4
    172a:	7828      	ldrb	r0, [r5, #0]
    172c:	f7ff ff0e 	bl	154c <printf_numbers>
    1730:	b168      	cbz	r0, 174e <printf+0xc2>
              state = CHECK_CH;
              fmt++;
    1732:	1c6c      	adds	r4, r5, #1
              state = CHECK_CH;
    1734:	2500      	movs	r5, #0
              break;
    1736:	e7b8      	b.n	16aa <printf+0x1e>
              fmt++;
    1738:	1ca5      	adds	r5, r4, #2
              l_count++;
    173a:	2202      	movs	r2, #2
    173c:	e7f4      	b.n	1728 <printf+0x9c>
            }
            return -1;
          }
          default: {
            if (printf_numbers(*fmt, &args, 0)) {
    173e:	2200      	movs	r2, #0
    1740:	a901      	add	r1, sp, #4
    1742:	f7ff ff03 	bl	154c <printf_numbers>
    1746:	b148      	cbz	r0, 175c <printf+0xd0>
              state = CHECK_CH;
              fmt++;
    1748:	3401      	adds	r4, #1
              state = CHECK_CH;
    174a:	2500      	movs	r5, #0
              break;
    174c:	e7ad      	b.n	16aa <printf+0x1e>
            return -1;
    174e:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    }
  }

  va_end(args);
  return 0;
}
    1752:	b003      	add	sp, #12
    1754:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    1758:	b004      	add	sp, #16
    175a:	4770      	bx	lr
            return -1;
    175c:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    1760:	e7f7      	b.n	1752 <printf+0xc6>
    1762:	bf00      	nop
    1764:	20000050 	andcs	r0, r0, r0, asr r0

00001768 <outstr2>:
} printf2_state;

static char hextable2[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                          '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

static void outstr2(const char *str) {
    1768:	b510      	push	{r4, lr}
    176a:	4604      	mov	r4, r0
  while (*str != '\0') {
    176c:	e003      	b.n	1776 <outstr2+0xe>
    __write_char2__(*str);
    176e:	4b04      	ldr	r3, [pc, #16]	@ (1780 <outstr2+0x18>)
    1770:	681b      	ldr	r3, [r3, #0]
    1772:	4798      	blx	r3
    str++;
    1774:	3401      	adds	r4, #1
  while (*str != '\0') {
    1776:	7820      	ldrb	r0, [r4, #0]
    1778:	2800      	cmp	r0, #0
    177a:	d1f8      	bne.n	176e <outstr2+0x6>
  }
}
    177c:	bd10      	pop	{r4, pc}
    177e:	bf00      	nop
    1780:	20000168 	andcs	r0, r0, r8, ror #2

00001784 <printf2_numbers>:

static bool printf2_numbers(const char fmt, va_list *args, int l_count) {
    1784:	b530      	push	{r4, r5, lr}
    1786:	b085      	sub	sp, #20
    1788:	4614      	mov	r4, r2
  char num[MAX_DIGITS];
  int num_len = 0;

  switch (fmt) {
    178a:	2864      	cmp	r0, #100	@ 0x64
    178c:	d01d      	beq.n	17ca <printf2_numbers+0x46>
    178e:	d914      	bls.n	17ba <printf2_numbers+0x36>
    1790:	2875      	cmp	r0, #117	@ 0x75
    1792:	d001      	beq.n	1798 <printf2_numbers+0x14>
    1794:	2878      	cmp	r0, #120	@ 0x78
    1796:	d112      	bne.n	17be <printf2_numbers+0x3a>
#ifndef SHELL_NO_PRINTF_LL
      long long unsigned int value = 0;
#else
      unsigned int value = 0;
#endif  // SHELL_NO_PRINTF_LL
      if (l_count == 0) {
    1798:	2c00      	cmp	r4, #0
    179a:	f040 8086 	bne.w	18aa <printf2_numbers+0x126>
        value = va_arg(*args, unsigned int);
    179e:	680b      	ldr	r3, [r1, #0]
    17a0:	1d1a      	adds	r2, r3, #4
    17a2:	600a      	str	r2, [r1, #0]
    17a4:	681d      	ldr	r5, [r3, #0]
#endif  // SHELL_NO_PRINTF_LL
      } else {
        return false;
      }

      if (fmt == 'u') {
    17a6:	2875      	cmp	r0, #117	@ 0x75
    17a8:	d043      	beq.n	1832 <printf2_numbers+0xae>

        while (num_len > 0) {
          __write_char2__(num[--num_len]);
        };
      } else {
        if (value == 0) {
    17aa:	2d00      	cmp	r5, #0
    17ac:	d176      	bne.n	189c <printf2_numbers+0x118>
          __write_char2__(hextable2[0]);
    17ae:	4b40      	ldr	r3, [pc, #256]	@ (18b0 <printf2_numbers+0x12c>)
    17b0:	681b      	ldr	r3, [r3, #0]
    17b2:	2030      	movs	r0, #48	@ 0x30
    17b4:	4798      	blx	r3
    }
    default:
      outstr2("\nprintf2-error\n");
      return false;
  }
  return true;
    17b6:	2001      	movs	r0, #1
    17b8:	e005      	b.n	17c6 <printf2_numbers+0x42>
  switch (fmt) {
    17ba:	2858      	cmp	r0, #88	@ 0x58
    17bc:	d0ec      	beq.n	1798 <printf2_numbers+0x14>
      outstr2("\nprintf2-error\n");
    17be:	483d      	ldr	r0, [pc, #244]	@ (18b4 <printf2_numbers+0x130>)
    17c0:	f7ff ffd2 	bl	1768 <outstr2>
      return false;
    17c4:	2000      	movs	r0, #0
}
    17c6:	b005      	add	sp, #20
    17c8:	bd30      	pop	{r4, r5, pc}
      if (l_count == 0) {
    17ca:	2a00      	cmp	r2, #0
    17cc:	d16b      	bne.n	18a6 <printf2_numbers+0x122>
        value = va_arg(*args, int);
    17ce:	680b      	ldr	r3, [r1, #0]
    17d0:	1d1a      	adds	r2, r3, #4
    17d2:	600a      	str	r2, [r1, #0]
    17d4:	681d      	ldr	r5, [r3, #0]
      if (value < 0) {
    17d6:	2d00      	cmp	r5, #0
    17d8:	db17      	blt.n	180a <printf2_numbers+0x86>
        num[num_len++] = hextable2[value % 10];
    17da:	4a37      	ldr	r2, [pc, #220]	@ (18b8 <printf2_numbers+0x134>)
    17dc:	fb82 3205 	smull	r3, r2, r2, r5
    17e0:	17eb      	asrs	r3, r5, #31
    17e2:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
    17e6:	4619      	mov	r1, r3
    17e8:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    17ec:	eba5 0343 	sub.w	r3, r5, r3, lsl #1
    17f0:	4832      	ldr	r0, [pc, #200]	@ (18bc <printf2_numbers+0x138>)
    17f2:	5cc0      	ldrb	r0, [r0, r3]
    17f4:	4623      	mov	r3, r4
    17f6:	3310      	adds	r3, #16
    17f8:	446b      	add	r3, sp
    17fa:	3401      	adds	r4, #1
    17fc:	f803 0c0c 	strb.w	r0, [r3, #-12]
        value = value / 10;
    1800:	462b      	mov	r3, r5
    1802:	460d      	mov	r5, r1
      } while (value > 0);
    1804:	2b09      	cmp	r3, #9
    1806:	dce8      	bgt.n	17da <printf2_numbers+0x56>
    1808:	e00f      	b.n	182a <printf2_numbers+0xa6>
        __write_char2__('-');
    180a:	4b29      	ldr	r3, [pc, #164]	@ (18b0 <printf2_numbers+0x12c>)
    180c:	681b      	ldr	r3, [r3, #0]
    180e:	202d      	movs	r0, #45	@ 0x2d
    1810:	4798      	blx	r3
        value = -value;
    1812:	426d      	negs	r5, r5
    1814:	e7e1      	b.n	17da <printf2_numbers+0x56>
        __write_char2__(num[--num_len]);
    1816:	3c01      	subs	r4, #1
    1818:	f104 0310 	add.w	r3, r4, #16
    181c:	eb0d 0203 	add.w	r2, sp, r3
    1820:	4b23      	ldr	r3, [pc, #140]	@ (18b0 <printf2_numbers+0x12c>)
    1822:	681b      	ldr	r3, [r3, #0]
    1824:	f812 0c0c 	ldrb.w	r0, [r2, #-12]
    1828:	4798      	blx	r3
      while (num_len > 0) {
    182a:	2c00      	cmp	r4, #0
    182c:	dcf3      	bgt.n	1816 <printf2_numbers+0x92>
  return true;
    182e:	2001      	movs	r0, #1
    1830:	e7c9      	b.n	17c6 <printf2_numbers+0x42>
          num[num_len++] = hextable2[value % 10];
    1832:	4b23      	ldr	r3, [pc, #140]	@ (18c0 <printf2_numbers+0x13c>)
    1834:	fba3 2305 	umull	r2, r3, r3, r5
    1838:	08db      	lsrs	r3, r3, #3
    183a:	4619      	mov	r1, r3
    183c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    1840:	eba5 0343 	sub.w	r3, r5, r3, lsl #1
    1844:	481d      	ldr	r0, [pc, #116]	@ (18bc <printf2_numbers+0x138>)
    1846:	5cc0      	ldrb	r0, [r0, r3]
    1848:	4623      	mov	r3, r4
    184a:	3310      	adds	r3, #16
    184c:	446b      	add	r3, sp
    184e:	3401      	adds	r4, #1
    1850:	f803 0c0c 	strb.w	r0, [r3, #-12]
          value = value / 10;
    1854:	462b      	mov	r3, r5
    1856:	460d      	mov	r5, r1
        } while (value > 0);
    1858:	2b09      	cmp	r3, #9
    185a:	d8ea      	bhi.n	1832 <printf2_numbers+0xae>
        while (num_len > 0) {
    185c:	2c00      	cmp	r4, #0
    185e:	dd0a      	ble.n	1876 <printf2_numbers+0xf2>
          __write_char2__(num[--num_len]);
    1860:	3c01      	subs	r4, #1
    1862:	f104 0310 	add.w	r3, r4, #16
    1866:	eb0d 0203 	add.w	r2, sp, r3
    186a:	4b11      	ldr	r3, [pc, #68]	@ (18b0 <printf2_numbers+0x12c>)
    186c:	681b      	ldr	r3, [r3, #0]
    186e:	f812 0c0c 	ldrb.w	r0, [r2, #-12]
    1872:	4798      	blx	r3
    1874:	e7f2      	b.n	185c <printf2_numbers+0xd8>
  return true;
    1876:	2001      	movs	r0, #1
    1878:	e7a5      	b.n	17c6 <printf2_numbers+0x42>
              __write_char2__(hextable2[val]);
    187a:	4a0d      	ldr	r2, [pc, #52]	@ (18b0 <printf2_numbers+0x12c>)
    187c:	6812      	ldr	r2, [r2, #0]
    187e:	490f      	ldr	r1, [pc, #60]	@ (18bc <printf2_numbers+0x138>)
    1880:	5cc8      	ldrb	r0, [r1, r3]
    1882:	4790      	blx	r2
              leading_zero_ignored = true;
    1884:	2201      	movs	r2, #1
            start_bit -= 4;
    1886:	3c04      	subs	r4, #4
          while (start_bit >= 0) {
    1888:	2c00      	cmp	r4, #0
    188a:	db0a      	blt.n	18a2 <printf2_numbers+0x11e>
            int val = (value >> start_bit) & 0xF;
    188c:	fa25 f304 	lsr.w	r3, r5, r4
            if (val || leading_zero_ignored) {
    1890:	f013 030f 	ands.w	r3, r3, #15
    1894:	d1f1      	bne.n	187a <printf2_numbers+0xf6>
    1896:	2a00      	cmp	r2, #0
    1898:	d0f5      	beq.n	1886 <printf2_numbers+0x102>
    189a:	e7ee      	b.n	187a <printf2_numbers+0xf6>
          bool leading_zero_ignored = false;
    189c:	2200      	movs	r2, #0
          int start_bit = LAST_NIBBLE_FIRST_BIT;
    189e:	241c      	movs	r4, #28
    18a0:	e7f2      	b.n	1888 <printf2_numbers+0x104>
  return true;
    18a2:	2001      	movs	r0, #1
    18a4:	e78f      	b.n	17c6 <printf2_numbers+0x42>
        return false;
    18a6:	2000      	movs	r0, #0
    18a8:	e78d      	b.n	17c6 <printf2_numbers+0x42>
        return false;
    18aa:	2000      	movs	r0, #0
    18ac:	e78b      	b.n	17c6 <printf2_numbers+0x42>
    18ae:	bf00      	nop
    18b0:	20000168 	andcs	r0, r0, r8, ror #2
    18b4:	00003124 	andeq	r3, r0, r4, lsr #2
    18b8:	66666667 	strbtvs	r6, [r6], -r7, ror #12
    18bc:	00003134 	andeq	r3, r0, r4, lsr r1
    18c0:	cccccccd 	stclgt	12, cr12, [ip], {205}	@ 0xcd

000018c4 <printf2>:

int printf2(const char *fmt, ...) {
    18c4:	b40f      	push	{r0, r1, r2, r3}
    18c6:	b530      	push	{r4, r5, lr}
    18c8:	b083      	sub	sp, #12
    18ca:	ab06      	add	r3, sp, #24
    18cc:	f853 4b04 	ldr.w	r4, [r3], #4
  printf2_state state = CHECK_CH;
  va_list args;

  va_start(args, fmt);
    18d0:	9301      	str	r3, [sp, #4]
  printf2_state state = CHECK_CH;
    18d2:	2500      	movs	r5, #0

  while (*fmt) {
    18d4:	e005      	b.n	18e2 <printf2+0x1e>
    switch (state) {
      case CHECK_CH: {
        if (*fmt == '%') {
    18d6:	2825      	cmp	r0, #37	@ 0x25
    18d8:	d00a      	beq.n	18f0 <printf2+0x2c>
          state = PARSE_FMT_STR;
          fmt++;
          continue;
        }
        __write_char2__(*fmt);
    18da:	4b30      	ldr	r3, [pc, #192]	@ (199c <printf2+0xd8>)
    18dc:	681b      	ldr	r3, [r3, #0]
    18de:	4798      	blx	r3
        fmt++;
    18e0:	3401      	adds	r4, #1
  while (*fmt) {
    18e2:	7820      	ldrb	r0, [r4, #0]
    18e4:	2800      	cmp	r0, #0
    18e6:	d050      	beq.n	198a <printf2+0xc6>
    switch (state) {
    18e8:	2d00      	cmp	r5, #0
    18ea:	d0f4      	beq.n	18d6 <printf2+0x12>
    18ec:	b925      	cbnz	r5, 18f8 <printf2+0x34>
    18ee:	e7f8      	b.n	18e2 <printf2+0x1e>
          fmt++;
    18f0:	3401      	adds	r4, #1
          state = PARSE_FMT_STR;
    18f2:	2501      	movs	r5, #1
          continue;
    18f4:	e7f5      	b.n	18e2 <printf2+0x1e>
        break;
      }
      case PARSE_FMT_STR: {
        // Support only basic format specifiers
        while (*fmt && ((*fmt >= '0' && *fmt <= '9') || *fmt == '-')) {
          fmt++;
    18f6:	3401      	adds	r4, #1
        while (*fmt && ((*fmt >= '0' && *fmt <= '9') || *fmt == '-')) {
    18f8:	7820      	ldrb	r0, [r4, #0]
    18fa:	b130      	cbz	r0, 190a <printf2+0x46>
    18fc:	f1a0 0330 	sub.w	r3, r0, #48	@ 0x30
    1900:	b2db      	uxtb	r3, r3
    1902:	2b09      	cmp	r3, #9
    1904:	d9f7      	bls.n	18f6 <printf2+0x32>
    1906:	282d      	cmp	r0, #45	@ 0x2d
    1908:	d0f5      	beq.n	18f6 <printf2+0x32>
        }

        switch (*fmt) {
    190a:	2863      	cmp	r0, #99	@ 0x63
    190c:	d019      	beq.n	1942 <printf2+0x7e>
    190e:	d80b      	bhi.n	1928 <printf2+0x64>
    1910:	2843      	cmp	r0, #67	@ 0x43
    1912:	d016      	beq.n	1942 <printf2+0x7e>
    1914:	2853      	cmp	r0, #83	@ 0x53
    1916:	d00b      	beq.n	1930 <printf2+0x6c>
    1918:	2825      	cmp	r0, #37	@ 0x25
    191a:	d12c      	bne.n	1976 <printf2+0xb2>
          case '%':
            __write_char2__(*fmt);
    191c:	4b1f      	ldr	r3, [pc, #124]	@ (199c <printf2+0xd8>)
    191e:	681b      	ldr	r3, [r3, #0]
    1920:	4798      	blx	r3
            fmt++;
    1922:	3401      	adds	r4, #1
            state = CHECK_CH;
    1924:	2500      	movs	r5, #0
            break;
    1926:	e7dc      	b.n	18e2 <printf2+0x1e>
    1928:	286c      	cmp	r0, #108	@ 0x6c
    192a:	d014      	beq.n	1956 <printf2+0x92>
    192c:	2873      	cmp	r0, #115	@ 0x73
    192e:	d122      	bne.n	1976 <printf2+0xb2>
            fmt++;
            state = CHECK_CH;
            break;
          case 's':
          case 'S':
            outstr2(va_arg(args, const char *));
    1930:	9b01      	ldr	r3, [sp, #4]
    1932:	1d1a      	adds	r2, r3, #4
    1934:	9201      	str	r2, [sp, #4]
    1936:	6818      	ldr	r0, [r3, #0]
    1938:	f7ff ff16 	bl	1768 <outstr2>
            fmt++;
    193c:	3401      	adds	r4, #1
            state = CHECK_CH;
    193e:	2500      	movs	r5, #0
            break;
    1940:	e7cf      	b.n	18e2 <printf2+0x1e>
            __write_char2__(va_arg(args, int));
    1942:	4b16      	ldr	r3, [pc, #88]	@ (199c <printf2+0xd8>)
    1944:	681a      	ldr	r2, [r3, #0]
    1946:	9b01      	ldr	r3, [sp, #4]
    1948:	1d19      	adds	r1, r3, #4
    194a:	9101      	str	r1, [sp, #4]
    194c:	7818      	ldrb	r0, [r3, #0]
    194e:	4790      	blx	r2
            fmt++;
    1950:	3401      	adds	r4, #1
            state = CHECK_CH;
    1952:	2500      	movs	r5, #0
            break;
    1954:	e7c5      	b.n	18e2 <printf2+0x1e>
          case 'l': {
            int l_count = 1;
            fmt++;
    1956:	1c65      	adds	r5, r4, #1
            if (*fmt == 'l') {
    1958:	7863      	ldrb	r3, [r4, #1]
    195a:	2b6c      	cmp	r3, #108	@ 0x6c
    195c:	d008      	beq.n	1970 <printf2+0xac>
            int l_count = 1;
    195e:	2201      	movs	r2, #1
              l_count++;
              fmt++;
            }
            if (printf2_numbers(*fmt, &args, l_count)) {
    1960:	a901      	add	r1, sp, #4
    1962:	7828      	ldrb	r0, [r5, #0]
    1964:	f7ff ff0e 	bl	1784 <printf2_numbers>
    1968:	b168      	cbz	r0, 1986 <printf2+0xc2>
              state = CHECK_CH;
              fmt++;
    196a:	1c6c      	adds	r4, r5, #1
              state = CHECK_CH;
    196c:	2500      	movs	r5, #0
              break;
    196e:	e7b8      	b.n	18e2 <printf2+0x1e>
              fmt++;
    1970:	1ca5      	adds	r5, r4, #2
              l_count++;
    1972:	2202      	movs	r2, #2
    1974:	e7f4      	b.n	1960 <printf2+0x9c>
            }
            return -1;
          }
          default: {
            if (printf2_numbers(*fmt, &args, 0)) {
    1976:	2200      	movs	r2, #0
    1978:	a901      	add	r1, sp, #4
    197a:	f7ff ff03 	bl	1784 <printf2_numbers>
    197e:	b148      	cbz	r0, 1994 <printf2+0xd0>
              state = CHECK_CH;
              fmt++;
    1980:	3401      	adds	r4, #1
              state = CHECK_CH;
    1982:	2500      	movs	r5, #0
              break;
    1984:	e7ad      	b.n	18e2 <printf2+0x1e>
            return -1;
    1986:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    }
  }

  va_end(args);
  return 0;
}
    198a:	b003      	add	sp, #12
    198c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    1990:	b004      	add	sp, #16
    1992:	4770      	bx	lr
            return -1;
    1994:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    1998:	e7f7      	b.n	198a <printf2+0xc6>
    199a:	bf00      	nop
    199c:	20000168 	andcs	r0, r0, r8, ror #2

000019a0 <r32>:
/*
 * Memory manipulation utilities can be skipped to reduce
 * final binary size. Skip if SHELL_NO_UTILS is defined.
 */
#ifndef SHELL_NO_UTILS
int r32(int argc, char *argv[]) {
    19a0:	b508      	push	{r3, lr}
  if (argc < 2) {
    19a2:	2801      	cmp	r0, #1
    19a4:	dd09      	ble.n	19ba <r32+0x1a>
    printf("Usage: %s <address> (in hex)\n", argv[0]);
    return -1;
  }

  uint32_t addr = atoh(argv[1]);
    19a6:	6848      	ldr	r0, [r1, #4]
    19a8:	f000 fe77 	bl	269a <atoh>
    19ac:	4601      	mov	r1, r0
  uint32_t data;

  data = reg32(addr);
    19ae:	6802      	ldr	r2, [r0, #0]

  printf("0x%x: 0x%x\n", addr, data);
    19b0:	4805      	ldr	r0, [pc, #20]	@ (19c8 <r32+0x28>)
    19b2:	f7ff fe6b 	bl	168c <printf>
  return 0;
    19b6:	2000      	movs	r0, #0
}
    19b8:	bd08      	pop	{r3, pc}
    printf("Usage: %s <address> (in hex)\n", argv[0]);
    19ba:	6809      	ldr	r1, [r1, #0]
    19bc:	4803      	ldr	r0, [pc, #12]	@ (19cc <r32+0x2c>)
    19be:	f7ff fe65 	bl	168c <printf>
    return -1;
    19c2:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    19c6:	e7f7      	b.n	19b8 <r32+0x18>
    19c8:	00003164 	andeq	r3, r0, r4, ror #2
    19cc:	00003144 	andeq	r3, r0, r4, asr #2

000019d0 <w32>:

int w32(int argc, char *argv[]) {
    19d0:	b538      	push	{r3, r4, r5, lr}
    19d2:	460c      	mov	r4, r1
  if (argc < 3) {
    19d4:	2802      	cmp	r0, #2
    19d6:	dd09      	ble.n	19ec <w32+0x1c>
    printf("Usage: %s <address> (in hex) <value> (in hex)\n", argv[0]);
    return -1;
  }
  uint32_t addr = atoh(argv[1]);
    19d8:	6848      	ldr	r0, [r1, #4]
    19da:	f000 fe5e 	bl	269a <atoh>
    19de:	4605      	mov	r5, r0
  uint32_t data = atoh(argv[2]);
    19e0:	68a0      	ldr	r0, [r4, #8]
    19e2:	f000 fe5a 	bl	269a <atoh>
  reg32(addr) = data;
    19e6:	6028      	str	r0, [r5, #0]

  return 0;
    19e8:	2000      	movs	r0, #0
}
    19ea:	bd38      	pop	{r3, r4, r5, pc}
    printf("Usage: %s <address> (in hex) <value> (in hex)\n", argv[0]);
    19ec:	6809      	ldr	r1, [r1, #0]
    19ee:	4803      	ldr	r0, [pc, #12]	@ (19fc <w32+0x2c>)
    19f0:	f7ff fe4c 	bl	168c <printf>
    return -1;
    19f4:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    19f8:	e7f7      	b.n	19ea <w32+0x1a>
    19fa:	bf00      	nop
    19fc:	00003170 	andeq	r3, r0, r0, ror r1

00001a00 <read_mem>:

int read_mem(int argc, char *argv[]) {
    1a00:	b570      	push	{r4, r5, r6, lr}
    1a02:	460d      	mov	r5, r1
  if (argc < 3) {
    1a04:	2802      	cmp	r0, #2
    1a06:	dd09      	ble.n	1a1c <read_mem+0x1c>
    printf("Usage: %s <address> (in hex) <num_words> (in decimal)\n", argv[0]);
    return -1;
  }

  uint32_t addr = atoh(argv[1]);
    1a08:	6848      	ldr	r0, [r1, #4]
    1a0a:	f000 fe46 	bl	269a <atoh>
    1a0e:	4604      	mov	r4, r0
  uint32_t length = atoi(argv[2]);
    1a10:	68a8      	ldr	r0, [r5, #8]
    1a12:	f000 fe33 	bl	267c <atoi>
    1a16:	4606      	mov	r6, r0

  for (uint32_t i = 0, data = 0; i < length; i++) {
    1a18:	2500      	movs	r5, #0
    1a1a:	e00d      	b.n	1a38 <read_mem+0x38>
    printf("Usage: %s <address> (in hex) <num_words> (in decimal)\n", argv[0]);
    1a1c:	6809      	ldr	r1, [r1, #0]
    1a1e:	4808      	ldr	r0, [pc, #32]	@ (1a40 <read_mem+0x40>)
    1a20:	f7ff fe34 	bl	168c <printf>
    return -1;
    1a24:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    1a28:	e009      	b.n	1a3e <read_mem+0x3e>
    data = reg32(addr);
    1a2a:	6822      	ldr	r2, [r4, #0]
    printf("0x%x: 0x%x\n", addr, data);
    1a2c:	4621      	mov	r1, r4
    1a2e:	4805      	ldr	r0, [pc, #20]	@ (1a44 <read_mem+0x44>)
    1a30:	f7ff fe2c 	bl	168c <printf>

    addr += 4;
    1a34:	3404      	adds	r4, #4
  for (uint32_t i = 0, data = 0; i < length; i++) {
    1a36:	3501      	adds	r5, #1
    1a38:	42b5      	cmp	r5, r6
    1a3a:	d3f6      	bcc.n	1a2a <read_mem+0x2a>
  }

  return 0;
    1a3c:	2000      	movs	r0, #0
}
    1a3e:	bd70      	pop	{r4, r5, r6, pc}
    1a40:	000031a0 	andeq	r3, r0, r0, lsr #3
    1a44:	00003164 	andeq	r3, r0, r4, ror #2

00001a48 <w32_bit>:

#ifndef SHELL_NO_BIT_UTILS
int w32_bit(int argc, char *argv[])
{
    1a48:	b570      	push	{r4, r5, r6, lr}
    1a4a:	460c      	mov	r4, r1
  if (argc < 4) {
    1a4c:	2803      	cmp	r0, #3
    1a4e:	dd22      	ble.n	1a96 <w32_bit+0x4e>
    goto usage;
  }

  uint32_t addr = atoh(argv[1]);
    1a50:	6848      	ldr	r0, [r1, #4]
    1a52:	f000 fe22 	bl	269a <atoh>
    1a56:	4606      	mov	r6, r0
  uint32_t bit_loc = atoi(argv[2]);
    1a58:	68a0      	ldr	r0, [r4, #8]
    1a5a:	f000 fe0f 	bl	267c <atoi>
    1a5e:	4605      	mov	r5, r0
  uint32_t bit_val = atoi(argv[3]);
    1a60:	68e0      	ldr	r0, [r4, #12]
    1a62:	f000 fe0b 	bl	267c <atoi>

  if (bit_loc > 31) {
    1a66:	2d1f      	cmp	r5, #31
    1a68:	d80e      	bhi.n	1a88 <w32_bit+0x40>
    printf("Error: Invalid bit location argument\n");
    goto usage;
  }

  if (bit_val != 0 && bit_val != 1) {
    1a6a:	2801      	cmp	r0, #1
    1a6c:	d810      	bhi.n	1a90 <w32_bit+0x48>
    printf("Error: Invalid bit value argument\n");
    goto usage;
  }

  uint32_t data = reg32(addr);
    1a6e:	6832      	ldr	r2, [r6, #0]
  data = data | (bit_val << bit_loc);
    1a70:	fa00 f305 	lsl.w	r3, r0, r5
    1a74:	431a      	orrs	r2, r3
  data = data & ~(!bit_val << bit_loc);
    1a76:	fab0 f380 	clz	r3, r0
    1a7a:	095b      	lsrs	r3, r3, #5
    1a7c:	40ab      	lsls	r3, r5
    1a7e:	ea22 0303 	bic.w	r3, r2, r3
  reg32(addr) = data;
    1a82:	6033      	str	r3, [r6, #0]

  return 0;
    1a84:	2000      	movs	r0, #0
usage:
  printf("Usage: %s <address_in_hex(32-bits)> <bit_location_in_decimal(0 to 31)> <bit_value(0 or 1)>\n", argv[0]);
  return -1;
}
    1a86:	bd70      	pop	{r4, r5, r6, pc}
    printf("Error: Invalid bit location argument\n");
    1a88:	4806      	ldr	r0, [pc, #24]	@ (1aa4 <w32_bit+0x5c>)
    1a8a:	f7ff fdff 	bl	168c <printf>
    goto usage;
    1a8e:	e002      	b.n	1a96 <w32_bit+0x4e>
    printf("Error: Invalid bit value argument\n");
    1a90:	4805      	ldr	r0, [pc, #20]	@ (1aa8 <w32_bit+0x60>)
    1a92:	f7ff fdfb 	bl	168c <printf>
  printf("Usage: %s <address_in_hex(32-bits)> <bit_location_in_decimal(0 to 31)> <bit_value(0 or 1)>\n", argv[0]);
    1a96:	6821      	ldr	r1, [r4, #0]
    1a98:	4804      	ldr	r0, [pc, #16]	@ (1aac <w32_bit+0x64>)
    1a9a:	f7ff fdf7 	bl	168c <printf>
  return -1;
    1a9e:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    1aa2:	e7f0      	b.n	1a86 <w32_bit+0x3e>
    1aa4:	000031d8 	ldrdeq	r3, [r0], -r8
    1aa8:	00003200 	andeq	r3, r0, r0, lsl #4
    1aac:	00003224 	andeq	r3, r0, r4, lsr #4

00001ab0 <r32_bit>:

int r32_bit(int argc, char *argv[])
{
    1ab0:	b538      	push	{r3, r4, r5, lr}
    1ab2:	460c      	mov	r4, r1
  if (argc < 3) {
    1ab4:	2802      	cmp	r0, #2
    1ab6:	dd16      	ble.n	1ae6 <r32_bit+0x36>
    goto usage;
  }

  uint32_t addr = atoh(argv[1]);
    1ab8:	6848      	ldr	r0, [r1, #4]
    1aba:	f000 fdee 	bl	269a <atoh>
    1abe:	4605      	mov	r5, r0
  uint32_t bit_loc = atoi(argv[2]);
    1ac0:	68a0      	ldr	r0, [r4, #8]
    1ac2:	f000 fddb 	bl	267c <atoi>
    1ac6:	4601      	mov	r1, r0

  if (bit_loc > 31) {
    1ac8:	281f      	cmp	r0, #31
    1aca:	d809      	bhi.n	1ae0 <r32_bit+0x30>
    printf("Error: Invalid bit location argument\n");
    goto usage;
  }

  uint32_t data = reg32(addr);
    1acc:	682b      	ldr	r3, [r5, #0]
  uint32_t bit_val = (data >> bit_loc) & 0x1;
    1ace:	40c3      	lsrs	r3, r0
  printf("Bit %u @ 0x%08x: %u\n", bit_loc, addr, bit_val);
    1ad0:	f003 0301 	and.w	r3, r3, #1
    1ad4:	462a      	mov	r2, r5
    1ad6:	4807      	ldr	r0, [pc, #28]	@ (1af4 <r32_bit+0x44>)
    1ad8:	f7ff fdd8 	bl	168c <printf>
  return 0;
    1adc:	2000      	movs	r0, #0

usage:
  printf("Usage: %s <address_in_hex(32-bits)> <bit_location_in_decimal(0 to 31)\n", argv[0]);
  return -1;
}
    1ade:	bd38      	pop	{r3, r4, r5, pc}
    printf("Error: Invalid bit location argument\n");
    1ae0:	4805      	ldr	r0, [pc, #20]	@ (1af8 <r32_bit+0x48>)
    1ae2:	f7ff fdd3 	bl	168c <printf>
  printf("Usage: %s <address_in_hex(32-bits)> <bit_location_in_decimal(0 to 31)\n", argv[0]);
    1ae6:	6821      	ldr	r1, [r4, #0]
    1ae8:	4804      	ldr	r0, [pc, #16]	@ (1afc <r32_bit+0x4c>)
    1aea:	f7ff fdcf 	bl	168c <printf>
  return -1;
    1aee:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    1af2:	e7f4      	b.n	1ade <r32_bit+0x2e>
    1af4:	00003280 	andeq	r3, r0, r0, lsl #5
    1af8:	000031d8 	ldrdeq	r3, [r0], -r8
    1afc:	00003298 	muleq	r0, r8, r2

00001b00 <KeyExpansion>:
*/
#define getSBoxValue(num) (sbox[(num)])

// This function produces Nb(Nr+1) round keys. The round keys are used in each round to decrypt the states. 
static void KeyExpansion(uint8_t* RoundKey, const uint8_t* Key)
{
    1b00:	b530      	push	{r4, r5, lr}
    1b02:	b083      	sub	sp, #12
  unsigned i, j, k;
  uint8_t tempa[4]; // Used for the column/row operations
  
  // The first round key is the key itself.
  for (i = 0; i < Nk; ++i)
    1b04:	2200      	movs	r2, #0
    1b06:	e00e      	b.n	1b26 <KeyExpansion+0x26>
  {
    RoundKey[(i * 4) + 0] = Key[(i * 4) + 0];
    1b08:	0093      	lsls	r3, r2, #2
    1b0a:	f811 4022 	ldrb.w	r4, [r1, r2, lsl #2]
    1b0e:	f800 4022 	strb.w	r4, [r0, r2, lsl #2]
    RoundKey[(i * 4) + 1] = Key[(i * 4) + 1];
    1b12:	1c5c      	adds	r4, r3, #1
    1b14:	5d0d      	ldrb	r5, [r1, r4]
    1b16:	5505      	strb	r5, [r0, r4]
    RoundKey[(i * 4) + 2] = Key[(i * 4) + 2];
    1b18:	1c9c      	adds	r4, r3, #2
    1b1a:	5d0d      	ldrb	r5, [r1, r4]
    1b1c:	5505      	strb	r5, [r0, r4]
    RoundKey[(i * 4) + 3] = Key[(i * 4) + 3];
    1b1e:	3303      	adds	r3, #3
    1b20:	5ccc      	ldrb	r4, [r1, r3]
    1b22:	54c4      	strb	r4, [r0, r3]
  for (i = 0; i < Nk; ++i)
    1b24:	3201      	adds	r2, #1
    1b26:	2a07      	cmp	r2, #7
    1b28:	d9ee      	bls.n	1b08 <KeyExpansion+0x8>
  }

  // All other round keys are found from the previous round keys.
  for (i = Nk; i < Nb * (Nr + 1); ++i)
    1b2a:	2308      	movs	r3, #8
    1b2c:	e027      	b.n	1b7e <KeyExpansion+0x7e>
      }

      tempa[0] = tempa[0] ^ Rcon[i/Nk];
    }
#if defined(AES256) && (AES256 == 1)
    if (i % Nk == 4)
    1b2e:	2d04      	cmp	r5, #4
    1b30:	d05b      	beq.n	1bea <KeyExpansion+0xea>
        tempa[2] = getSBoxValue(tempa[2]);
        tempa[3] = getSBoxValue(tempa[3]);
      }
    }
#endif
    j = i * 4; k=(i - Nk) * 4;
    1b32:	0099      	lsls	r1, r3, #2
    1b34:	f1a3 0208 	sub.w	r2, r3, #8
    RoundKey[j + 0] = RoundKey[k + 0] ^ tempa[0];
    1b38:	f810 c022 	ldrb.w	ip, [r0, r2, lsl #2]
    1b3c:	f89d 4004 	ldrb.w	r4, [sp, #4]
    1b40:	ea8c 0c04 	eor.w	ip, ip, r4
    1b44:	f800 c023 	strb.w	ip, [r0, r3, lsl #2]
    RoundKey[j + 1] = RoundKey[k + 1] ^ tempa[1];
    1b48:	eb00 0282 	add.w	r2, r0, r2, lsl #2
    1b4c:	f892 c001 	ldrb.w	ip, [r2, #1]
    1b50:	f89d e005 	ldrb.w	lr, [sp, #5]
    1b54:	1c4c      	adds	r4, r1, #1
    1b56:	ea8c 0c0e 	eor.w	ip, ip, lr
    1b5a:	f800 c004 	strb.w	ip, [r0, r4]
    RoundKey[j + 2] = RoundKey[k + 2] ^ tempa[2];
    1b5e:	f892 c002 	ldrb.w	ip, [r2, #2]
    1b62:	f89d e006 	ldrb.w	lr, [sp, #6]
    1b66:	1c8c      	adds	r4, r1, #2
    1b68:	ea8c 0c0e 	eor.w	ip, ip, lr
    1b6c:	f800 c004 	strb.w	ip, [r0, r4]
    RoundKey[j + 3] = RoundKey[k + 3] ^ tempa[3];
    1b70:	78d2      	ldrb	r2, [r2, #3]
    1b72:	f89d 4007 	ldrb.w	r4, [sp, #7]
    1b76:	3103      	adds	r1, #3
    1b78:	4062      	eors	r2, r4
    1b7a:	5442      	strb	r2, [r0, r1]
  for (i = Nk; i < Nb * (Nr + 1); ++i)
    1b7c:	3301      	adds	r3, #1
    1b7e:	2b3b      	cmp	r3, #59	@ 0x3b
    1b80:	d849      	bhi.n	1c16 <KeyExpansion+0x116>
      k = (i - 1) * 4;
    1b82:	1e5a      	subs	r2, r3, #1
      tempa[0]=RoundKey[k + 0];
    1b84:	f810 1022 	ldrb.w	r1, [r0, r2, lsl #2]
    1b88:	f88d 1004 	strb.w	r1, [sp, #4]
      tempa[1]=RoundKey[k + 1];
    1b8c:	eb00 0282 	add.w	r2, r0, r2, lsl #2
    1b90:	7854      	ldrb	r4, [r2, #1]
    1b92:	f88d 4005 	strb.w	r4, [sp, #5]
      tempa[2]=RoundKey[k + 2];
    1b96:	f892 e002 	ldrb.w	lr, [r2, #2]
    1b9a:	f88d e006 	strb.w	lr, [sp, #6]
      tempa[3]=RoundKey[k + 3];
    1b9e:	f892 c003 	ldrb.w	ip, [r2, #3]
    1ba2:	f88d c007 	strb.w	ip, [sp, #7]
    if (i % Nk == 0)
    1ba6:	f013 0507 	ands.w	r5, r3, #7
    1baa:	d1c0      	bne.n	1b2e <KeyExpansion+0x2e>
        tempa[0] = tempa[1];
    1bac:	f88d 4004 	strb.w	r4, [sp, #4]
        tempa[1] = tempa[2];
    1bb0:	f88d e005 	strb.w	lr, [sp, #5]
        tempa[2] = tempa[3];
    1bb4:	f88d c006 	strb.w	ip, [sp, #6]
        tempa[3] = u8tmp;
    1bb8:	f88d 1007 	strb.w	r1, [sp, #7]
        tempa[0] = getSBoxValue(tempa[0]);
    1bbc:	4a17      	ldr	r2, [pc, #92]	@ (1c1c <KeyExpansion+0x11c>)
    1bbe:	5d14      	ldrb	r4, [r2, r4]
    1bc0:	f88d 4004 	strb.w	r4, [sp, #4]
        tempa[1] = getSBoxValue(tempa[1]);
    1bc4:	f812 e00e 	ldrb.w	lr, [r2, lr]
    1bc8:	f88d e005 	strb.w	lr, [sp, #5]
        tempa[2] = getSBoxValue(tempa[2]);
    1bcc:	f812 c00c 	ldrb.w	ip, [r2, ip]
    1bd0:	f88d c006 	strb.w	ip, [sp, #6]
        tempa[3] = getSBoxValue(tempa[3]);
    1bd4:	5c51      	ldrb	r1, [r2, r1]
    1bd6:	f88d 1007 	strb.w	r1, [sp, #7]
      tempa[0] = tempa[0] ^ Rcon[i/Nk];
    1bda:	eb02 02d3 	add.w	r2, r2, r3, lsr #3
    1bde:	f892 2100 	ldrb.w	r2, [r2, #256]	@ 0x100
    1be2:	4054      	eors	r4, r2
    1be4:	f88d 4004 	strb.w	r4, [sp, #4]
    1be8:	e7a1      	b.n	1b2e <KeyExpansion+0x2e>
        tempa[0] = getSBoxValue(tempa[0]);
    1bea:	f89d 1004 	ldrb.w	r1, [sp, #4]
    1bee:	4a0b      	ldr	r2, [pc, #44]	@ (1c1c <KeyExpansion+0x11c>)
    1bf0:	5c51      	ldrb	r1, [r2, r1]
    1bf2:	f88d 1004 	strb.w	r1, [sp, #4]
        tempa[1] = getSBoxValue(tempa[1]);
    1bf6:	f89d 1005 	ldrb.w	r1, [sp, #5]
    1bfa:	5c51      	ldrb	r1, [r2, r1]
    1bfc:	f88d 1005 	strb.w	r1, [sp, #5]
        tempa[2] = getSBoxValue(tempa[2]);
    1c00:	f89d 1006 	ldrb.w	r1, [sp, #6]
    1c04:	5c51      	ldrb	r1, [r2, r1]
    1c06:	f88d 1006 	strb.w	r1, [sp, #6]
        tempa[3] = getSBoxValue(tempa[3]);
    1c0a:	f89d 1007 	ldrb.w	r1, [sp, #7]
    1c0e:	5c52      	ldrb	r2, [r2, r1]
    1c10:	f88d 2007 	strb.w	r2, [sp, #7]
    1c14:	e78d      	b.n	1b32 <KeyExpansion+0x32>
  }
}
    1c16:	b003      	add	sp, #12
    1c18:	bd30      	pop	{r4, r5, pc}
    1c1a:	bf00      	nop
    1c1c:	000033ac 	andeq	r3, r0, ip, lsr #7

00001c20 <AddRoundKey>:
#endif

// This function adds the round key to state.
// The round key is added to the state by an XOR function.
static void AddRoundKey(uint8_t round, state_t* state, const uint8_t* RoundKey)
{
    1c20:	b530      	push	{r4, r5, lr}
  uint8_t i,j;
  for (i = 0; i < 4; ++i)
    1c22:	2400      	movs	r4, #0
    1c24:	e013      	b.n	1c4e <AddRoundKey+0x2e>
  {
    for (j = 0; j < 4; ++j)
    {
      (*state)[i][j] ^= RoundKey[(round * Nb * 4) + (i * Nb) + j];
    1c26:	eb01 0584 	add.w	r5, r1, r4, lsl #2
    1c2a:	f815 c003 	ldrb.w	ip, [r5, r3]
    1c2e:	eb04 0e80 	add.w	lr, r4, r0, lsl #2
    1c32:	eb03 0e8e 	add.w	lr, r3, lr, lsl #2
    1c36:	f812 e00e 	ldrb.w	lr, [r2, lr]
    1c3a:	ea8c 0c0e 	eor.w	ip, ip, lr
    1c3e:	f805 c003 	strb.w	ip, [r5, r3]
    for (j = 0; j < 4; ++j)
    1c42:	3301      	adds	r3, #1
    1c44:	b2db      	uxtb	r3, r3
    1c46:	2b03      	cmp	r3, #3
    1c48:	d9ed      	bls.n	1c26 <AddRoundKey+0x6>
  for (i = 0; i < 4; ++i)
    1c4a:	3401      	adds	r4, #1
    1c4c:	b2e4      	uxtb	r4, r4
    1c4e:	2c03      	cmp	r4, #3
    1c50:	d801      	bhi.n	1c56 <AddRoundKey+0x36>
    for (j = 0; j < 4; ++j)
    1c52:	2300      	movs	r3, #0
    1c54:	e7f7      	b.n	1c46 <AddRoundKey+0x26>
    }
  }
}
    1c56:	bd30      	pop	{r4, r5, pc}

00001c58 <SubBytes>:
// The SubBytes Function Substitutes the values in the
// state matrix with values in an S-box.
static void SubBytes(state_t* state)
{
  uint8_t i, j;
  for (i = 0; i < 4; ++i)
    1c58:	2200      	movs	r2, #0
    1c5a:	2a03      	cmp	r2, #3
    1c5c:	d81b      	bhi.n	1c96 <SubBytes+0x3e>
  {
    for (j = 0; j < 4; ++j)
    1c5e:	2300      	movs	r3, #0
    1c60:	2b03      	cmp	r3, #3
    1c62:	d815      	bhi.n	1c90 <SubBytes+0x38>
{
    1c64:	b410      	push	{r4}
    {
      (*state)[j][i] = getSBoxValue((*state)[j][i]);
    1c66:	eb00 0183 	add.w	r1, r0, r3, lsl #2
    1c6a:	f811 c002 	ldrb.w	ip, [r1, r2]
    1c6e:	4c0a      	ldr	r4, [pc, #40]	@ (1c98 <SubBytes+0x40>)
    1c70:	f814 c00c 	ldrb.w	ip, [r4, ip]
    1c74:	f801 c002 	strb.w	ip, [r1, r2]
    for (j = 0; j < 4; ++j)
    1c78:	3301      	adds	r3, #1
    1c7a:	b2db      	uxtb	r3, r3
    1c7c:	2b03      	cmp	r3, #3
    1c7e:	d9f2      	bls.n	1c66 <SubBytes+0xe>
  for (i = 0; i < 4; ++i)
    1c80:	3201      	adds	r2, #1
    1c82:	b2d2      	uxtb	r2, r2
    1c84:	2a03      	cmp	r2, #3
    1c86:	d801      	bhi.n	1c8c <SubBytes+0x34>
    for (j = 0; j < 4; ++j)
    1c88:	2300      	movs	r3, #0
    1c8a:	e7f7      	b.n	1c7c <SubBytes+0x24>
    }
  }
}
    1c8c:	bc10      	pop	{r4}
    1c8e:	4770      	bx	lr
  for (i = 0; i < 4; ++i)
    1c90:	3201      	adds	r2, #1
    1c92:	b2d2      	uxtb	r2, r2
    1c94:	e7e1      	b.n	1c5a <SubBytes+0x2>
    1c96:	4770      	bx	lr
    1c98:	000033ac 	andeq	r3, r0, ip, lsr #7

00001c9c <ShiftRows>:
static void ShiftRows(state_t* state)
{
  uint8_t temp;

  // Rotate first row 1 columns to left  
  temp           = (*state)[0][1];
    1c9c:	7843      	ldrb	r3, [r0, #1]
  (*state)[0][1] = (*state)[1][1];
    1c9e:	7942      	ldrb	r2, [r0, #5]
    1ca0:	7042      	strb	r2, [r0, #1]
  (*state)[1][1] = (*state)[2][1];
    1ca2:	7a42      	ldrb	r2, [r0, #9]
    1ca4:	7142      	strb	r2, [r0, #5]
  (*state)[2][1] = (*state)[3][1];
    1ca6:	7b42      	ldrb	r2, [r0, #13]
    1ca8:	7242      	strb	r2, [r0, #9]
  (*state)[3][1] = temp;
    1caa:	7343      	strb	r3, [r0, #13]

  // Rotate second row 2 columns to left  
  temp           = (*state)[0][2];
    1cac:	7883      	ldrb	r3, [r0, #2]
  (*state)[0][2] = (*state)[2][2];
    1cae:	7a82      	ldrb	r2, [r0, #10]
    1cb0:	7082      	strb	r2, [r0, #2]
  (*state)[2][2] = temp;
    1cb2:	7283      	strb	r3, [r0, #10]

  temp           = (*state)[1][2];
    1cb4:	7983      	ldrb	r3, [r0, #6]
  (*state)[1][2] = (*state)[3][2];
    1cb6:	7b82      	ldrb	r2, [r0, #14]
    1cb8:	7182      	strb	r2, [r0, #6]
  (*state)[3][2] = temp;
    1cba:	7383      	strb	r3, [r0, #14]

  // Rotate third row 3 columns to left
  temp           = (*state)[0][3];
    1cbc:	78c3      	ldrb	r3, [r0, #3]
  (*state)[0][3] = (*state)[3][3];
    1cbe:	7bc2      	ldrb	r2, [r0, #15]
    1cc0:	70c2      	strb	r2, [r0, #3]
  (*state)[3][3] = (*state)[2][3];
    1cc2:	7ac2      	ldrb	r2, [r0, #11]
    1cc4:	73c2      	strb	r2, [r0, #15]
  (*state)[2][3] = (*state)[1][3];
    1cc6:	79c2      	ldrb	r2, [r0, #7]
    1cc8:	72c2      	strb	r2, [r0, #11]
  (*state)[1][3] = temp;
    1cca:	71c3      	strb	r3, [r0, #7]
}
    1ccc:	4770      	bx	lr

00001cce <xtime>:

static uint8_t xtime(uint8_t x)
{
  return ((x<<1) ^ (((x>>7) & 1) * 0x1b));
    1cce:	09c3      	lsrs	r3, r0, #7
    1cd0:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    1cd4:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
    1cd8:	ea83 0040 	eor.w	r0, r3, r0, lsl #1
}
    1cdc:	b2c0      	uxtb	r0, r0
    1cde:	4770      	bx	lr

00001ce0 <MixColumns>:

// MixColumns function mixes the columns of the state matrix
static void MixColumns(state_t* state)
{
    1ce0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1ce4:	4681      	mov	r9, r0
  uint8_t i;
  uint8_t Tmp, Tm, t;
  for (i = 0; i < 4; ++i)
    1ce6:	2500      	movs	r5, #0
    1ce8:	e031      	b.n	1d4e <MixColumns+0x6e>
  {  
    t   = (*state)[i][0];
    1cea:	f819 a025 	ldrb.w	sl, [r9, r5, lsl #2]
    Tmp = (*state)[i][0] ^ (*state)[i][1] ^ (*state)[i][2] ^ (*state)[i][3] ;
    1cee:	eb09 0685 	add.w	r6, r9, r5, lsl #2
    1cf2:	f896 b001 	ldrb.w	fp, [r6, #1]
    1cf6:	ea8b 000a 	eor.w	r0, fp, sl
    1cfa:	f896 8002 	ldrb.w	r8, [r6, #2]
    1cfe:	78f7      	ldrb	r7, [r6, #3]
    1d00:	ea80 0408 	eor.w	r4, r0, r8
    1d04:	407c      	eors	r4, r7
    Tm  = (*state)[i][0] ^ (*state)[i][1] ; Tm = xtime(Tm);  (*state)[i][0] ^= Tm ^ Tmp ;
    1d06:	f7ff ffe2 	bl	1cce <xtime>
    1d0a:	4060      	eors	r0, r4
    1d0c:	ea8a 0000 	eor.w	r0, sl, r0
    1d10:	f809 0025 	strb.w	r0, [r9, r5, lsl #2]
    Tm  = (*state)[i][1] ^ (*state)[i][2] ; Tm = xtime(Tm);  (*state)[i][1] ^= Tm ^ Tmp ;
    1d14:	ea8b 0008 	eor.w	r0, fp, r8
    1d18:	f7ff ffd9 	bl	1cce <xtime>
    1d1c:	4060      	eors	r0, r4
    1d1e:	ea8b 0b00 	eor.w	fp, fp, r0
    1d22:	f886 b001 	strb.w	fp, [r6, #1]
    Tm  = (*state)[i][2] ^ (*state)[i][3] ; Tm = xtime(Tm);  (*state)[i][2] ^= Tm ^ Tmp ;
    1d26:	ea88 0007 	eor.w	r0, r8, r7
    1d2a:	f7ff ffd0 	bl	1cce <xtime>
    1d2e:	4060      	eors	r0, r4
    1d30:	ea88 0800 	eor.w	r8, r8, r0
    1d34:	f886 8002 	strb.w	r8, [r6, #2]
    Tm  = (*state)[i][3] ^ t ;              Tm = xtime(Tm);  (*state)[i][3] ^= Tm ^ Tmp ;
    1d38:	ea87 000a 	eor.w	r0, r7, sl
    1d3c:	f7ff ffc7 	bl	1cce <xtime>
    1d40:	ea84 0300 	eor.w	r3, r4, r0
    1d44:	ea87 0403 	eor.w	r4, r7, r3
    1d48:	70f4      	strb	r4, [r6, #3]
  for (i = 0; i < 4; ++i)
    1d4a:	3501      	adds	r5, #1
    1d4c:	b2ed      	uxtb	r5, r5
    1d4e:	2d03      	cmp	r5, #3
    1d50:	d9cb      	bls.n	1cea <MixColumns+0xa>
  }
}
    1d52:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

00001d56 <InvMixColumns>:

// MixColumns function mixes the columns of the state matrix.
// The method used to multiply may be difficult to understand for the inexperienced.
// Please use the references to gain more information.
static void InvMixColumns(state_t* state)
{
    1d56:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1d5a:	b08b      	sub	sp, #44	@ 0x2c
    1d5c:	9000      	str	r0, [sp, #0]
  int i;
  uint8_t a, b, c, d;
  for (i = 0; i < 4; ++i)
    1d5e:	2400      	movs	r4, #0
    1d60:	e0a0      	b.n	1ea4 <InvMixColumns+0x14e>
  { 
    a = (*state)[i][0];
    1d62:	9b00      	ldr	r3, [sp, #0]
    1d64:	f813 b024 	ldrb.w	fp, [r3, r4, lsl #2]
    b = (*state)[i][1];
    1d68:	eb03 0884 	add.w	r8, r3, r4, lsl #2
    1d6c:	f898 a001 	ldrb.w	sl, [r8, #1]
    c = (*state)[i][2];
    1d70:	f898 9002 	ldrb.w	r9, [r8, #2]
    d = (*state)[i][3];
    1d74:	f898 5003 	ldrb.w	r5, [r8, #3]

    (*state)[i][0] = Multiply(a, 0x0e) ^ Multiply(b, 0x0b) ^ Multiply(c, 0x0d) ^ Multiply(d, 0x09);
    1d78:	4658      	mov	r0, fp
    1d7a:	f7ff ffa8 	bl	1cce <xtime>
    1d7e:	9007      	str	r0, [sp, #28]
    1d80:	f7ff ffa5 	bl	1cce <xtime>
    1d84:	9001      	str	r0, [sp, #4]
    1d86:	f7ff ffa2 	bl	1cce <xtime>
    1d8a:	9008      	str	r0, [sp, #32]
    1d8c:	4650      	mov	r0, sl
    1d8e:	f7ff ff9e 	bl	1cce <xtime>
    1d92:	9002      	str	r0, [sp, #8]
    1d94:	f7ff ff9b 	bl	1cce <xtime>
    1d98:	9003      	str	r0, [sp, #12]
    1d9a:	f7ff ff98 	bl	1cce <xtime>
    1d9e:	4607      	mov	r7, r0
    1da0:	4648      	mov	r0, r9
    1da2:	f7ff ff94 	bl	1cce <xtime>
    1da6:	9009      	str	r0, [sp, #36]	@ 0x24
    1da8:	f7ff ff91 	bl	1cce <xtime>
    1dac:	9004      	str	r0, [sp, #16]
    1dae:	f7ff ff8e 	bl	1cce <xtime>
    1db2:	4606      	mov	r6, r0
    1db4:	4628      	mov	r0, r5
    1db6:	f7ff ff8a 	bl	1cce <xtime>
    1dba:	9005      	str	r0, [sp, #20]
    1dbc:	f7ff ff87 	bl	1cce <xtime>
    1dc0:	9006      	str	r0, [sp, #24]
    1dc2:	f7ff ff84 	bl	1cce <xtime>
    1dc6:	f8dd e01c 	ldr.w	lr, [sp, #28]
    1dca:	9a01      	ldr	r2, [sp, #4]
    1dcc:	ea8e 0302 	eor.w	r3, lr, r2
    1dd0:	b2db      	uxtb	r3, r3
    1dd2:	9908      	ldr	r1, [sp, #32]
    1dd4:	404b      	eors	r3, r1
    1dd6:	b2db      	uxtb	r3, r3
    1dd8:	f8dd c008 	ldr.w	ip, [sp, #8]
    1ddc:	ea8c 020a 	eor.w	r2, ip, sl
    1de0:	b2d2      	uxtb	r2, r2
    1de2:	407a      	eors	r2, r7
    1de4:	b2d2      	uxtb	r2, r2
    1de6:	4053      	eors	r3, r2
    1de8:	9a04      	ldr	r2, [sp, #16]
    1dea:	ea82 0209 	eor.w	r2, r2, r9
    1dee:	b2d2      	uxtb	r2, r2
    1df0:	4072      	eors	r2, r6
    1df2:	b2d2      	uxtb	r2, r2
    1df4:	4053      	eors	r3, r2
    1df6:	ea80 0205 	eor.w	r2, r0, r5
    1dfa:	b2d2      	uxtb	r2, r2
    1dfc:	4053      	eors	r3, r2
    1dfe:	f8dd c000 	ldr.w	ip, [sp]
    1e02:	f80c 3024 	strb.w	r3, [ip, r4, lsl #2]
    (*state)[i][1] = Multiply(a, 0x09) ^ Multiply(b, 0x0e) ^ Multiply(c, 0x0b) ^ Multiply(d, 0x0d);
    1e06:	ea81 030b 	eor.w	r3, r1, fp
    1e0a:	b2da      	uxtb	r2, r3
    1e0c:	f8dd c008 	ldr.w	ip, [sp, #8]
    1e10:	9b03      	ldr	r3, [sp, #12]
    1e12:	ea8c 0303 	eor.w	r3, ip, r3
    1e16:	b2db      	uxtb	r3, r3
    1e18:	407b      	eors	r3, r7
    1e1a:	b2db      	uxtb	r3, r3
    1e1c:	4053      	eors	r3, r2
    1e1e:	f8dd c024 	ldr.w	ip, [sp, #36]	@ 0x24
    1e22:	ea8c 0209 	eor.w	r2, ip, r9
    1e26:	b2d2      	uxtb	r2, r2
    1e28:	4072      	eors	r2, r6
    1e2a:	b2d2      	uxtb	r2, r2
    1e2c:	4053      	eors	r3, r2
    1e2e:	9a06      	ldr	r2, [sp, #24]
    1e30:	406a      	eors	r2, r5
    1e32:	b2d2      	uxtb	r2, r2
    1e34:	4042      	eors	r2, r0
    1e36:	b2d2      	uxtb	r2, r2
    1e38:	4053      	eors	r3, r2
    1e3a:	f888 3001 	strb.w	r3, [r8, #1]
    (*state)[i][2] = Multiply(a, 0x0d) ^ Multiply(b, 0x09) ^ Multiply(c, 0x0e) ^ Multiply(d, 0x0b);
    1e3e:	9b01      	ldr	r3, [sp, #4]
    1e40:	ea83 030b 	eor.w	r3, r3, fp
    1e44:	b2db      	uxtb	r3, r3
    1e46:	404b      	eors	r3, r1
    1e48:	b2db      	uxtb	r3, r3
    1e4a:	ea87 020a 	eor.w	r2, r7, sl
    1e4e:	b2d2      	uxtb	r2, r2
    1e50:	4053      	eors	r3, r2
    1e52:	9a04      	ldr	r2, [sp, #16]
    1e54:	ea8c 0202 	eor.w	r2, ip, r2
    1e58:	b2d2      	uxtb	r2, r2
    1e5a:	4072      	eors	r2, r6
    1e5c:	b2d2      	uxtb	r2, r2
    1e5e:	4053      	eors	r3, r2
    1e60:	9a05      	ldr	r2, [sp, #20]
    1e62:	4055      	eors	r5, r2
    1e64:	b2ed      	uxtb	r5, r5
    1e66:	4045      	eors	r5, r0
    1e68:	b2ed      	uxtb	r5, r5
    1e6a:	406b      	eors	r3, r5
    1e6c:	f888 3002 	strb.w	r3, [r8, #2]
    (*state)[i][3] = Multiply(a, 0x0b) ^ Multiply(b, 0x0d) ^ Multiply(c, 0x09) ^ Multiply(d, 0x0e);
    1e70:	ea8e 030b 	eor.w	r3, lr, fp
    1e74:	b2db      	uxtb	r3, r3
    1e76:	404b      	eors	r3, r1
    1e78:	b2db      	uxtb	r3, r3
    1e7a:	9903      	ldr	r1, [sp, #12]
    1e7c:	ea81 020a 	eor.w	r2, r1, sl
    1e80:	b2d2      	uxtb	r2, r2
    1e82:	4057      	eors	r7, r2
    1e84:	b2ff      	uxtb	r7, r7
    1e86:	407b      	eors	r3, r7
    1e88:	ea86 0609 	eor.w	r6, r6, r9
    1e8c:	b2f6      	uxtb	r6, r6
    1e8e:	4073      	eors	r3, r6
    1e90:	9905      	ldr	r1, [sp, #20]
    1e92:	9a06      	ldr	r2, [sp, #24]
    1e94:	404a      	eors	r2, r1
    1e96:	b2d2      	uxtb	r2, r2
    1e98:	4050      	eors	r0, r2
    1e9a:	b2c0      	uxtb	r0, r0
    1e9c:	4043      	eors	r3, r0
    1e9e:	f888 3003 	strb.w	r3, [r8, #3]
  for (i = 0; i < 4; ++i)
    1ea2:	3401      	adds	r4, #1
    1ea4:	2c03      	cmp	r4, #3
    1ea6:	f77f af5c 	ble.w	1d62 <InvMixColumns+0xc>
  }
}
    1eaa:	b00b      	add	sp, #44	@ 0x2c
    1eac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00001eb0 <InvSubBytes>:
// The SubBytes Function Substitutes the values in the
// state matrix with values in an S-box.
static void InvSubBytes(state_t* state)
{
  uint8_t i, j;
  for (i = 0; i < 4; ++i)
    1eb0:	2100      	movs	r1, #0
    1eb2:	2903      	cmp	r1, #3
    1eb4:	d81c      	bhi.n	1ef0 <InvSubBytes+0x40>
  {
    for (j = 0; j < 4; ++j)
    1eb6:	2300      	movs	r3, #0
    1eb8:	2b03      	cmp	r3, #3
    1eba:	d816      	bhi.n	1eea <InvSubBytes+0x3a>
{
    1ebc:	b500      	push	{lr}
    {
      (*state)[j][i] = getSBoxInvert((*state)[j][i]);
    1ebe:	eb00 0c83 	add.w	ip, r0, r3, lsl #2
    1ec2:	f81c e001 	ldrb.w	lr, [ip, r1]
    1ec6:	4a0b      	ldr	r2, [pc, #44]	@ (1ef4 <InvSubBytes+0x44>)
    1ec8:	4472      	add	r2, lr
    1eca:	f892 210c 	ldrb.w	r2, [r2, #268]	@ 0x10c
    1ece:	f80c 2001 	strb.w	r2, [ip, r1]
    for (j = 0; j < 4; ++j)
    1ed2:	3301      	adds	r3, #1
    1ed4:	b2db      	uxtb	r3, r3
    1ed6:	2b03      	cmp	r3, #3
    1ed8:	d9f1      	bls.n	1ebe <InvSubBytes+0xe>
  for (i = 0; i < 4; ++i)
    1eda:	3101      	adds	r1, #1
    1edc:	b2c9      	uxtb	r1, r1
    1ede:	2903      	cmp	r1, #3
    1ee0:	d801      	bhi.n	1ee6 <InvSubBytes+0x36>
    for (j = 0; j < 4; ++j)
    1ee2:	2300      	movs	r3, #0
    1ee4:	e7f7      	b.n	1ed6 <InvSubBytes+0x26>
    }
  }
}
    1ee6:	f85d fb04 	ldr.w	pc, [sp], #4
  for (i = 0; i < 4; ++i)
    1eea:	3101      	adds	r1, #1
    1eec:	b2c9      	uxtb	r1, r1
    1eee:	e7e0      	b.n	1eb2 <InvSubBytes+0x2>
    1ef0:	4770      	bx	lr
    1ef2:	bf00      	nop
    1ef4:	000033ac 	andeq	r3, r0, ip, lsr #7

00001ef8 <InvShiftRows>:
static void InvShiftRows(state_t* state)
{
  uint8_t temp;

  // Rotate first row 1 columns to right  
  temp = (*state)[3][1];
    1ef8:	7b43      	ldrb	r3, [r0, #13]
  (*state)[3][1] = (*state)[2][1];
    1efa:	7a42      	ldrb	r2, [r0, #9]
    1efc:	7342      	strb	r2, [r0, #13]
  (*state)[2][1] = (*state)[1][1];
    1efe:	7942      	ldrb	r2, [r0, #5]
    1f00:	7242      	strb	r2, [r0, #9]
  (*state)[1][1] = (*state)[0][1];
    1f02:	7842      	ldrb	r2, [r0, #1]
    1f04:	7142      	strb	r2, [r0, #5]
  (*state)[0][1] = temp;
    1f06:	7043      	strb	r3, [r0, #1]

  // Rotate second row 2 columns to right 
  temp = (*state)[0][2];
    1f08:	7883      	ldrb	r3, [r0, #2]
  (*state)[0][2] = (*state)[2][2];
    1f0a:	7a82      	ldrb	r2, [r0, #10]
    1f0c:	7082      	strb	r2, [r0, #2]
  (*state)[2][2] = temp;
    1f0e:	7283      	strb	r3, [r0, #10]

  temp = (*state)[1][2];
    1f10:	7983      	ldrb	r3, [r0, #6]
  (*state)[1][2] = (*state)[3][2];
    1f12:	7b82      	ldrb	r2, [r0, #14]
    1f14:	7182      	strb	r2, [r0, #6]
  (*state)[3][2] = temp;
    1f16:	7383      	strb	r3, [r0, #14]

  // Rotate third row 3 columns to right
  temp = (*state)[0][3];
    1f18:	78c3      	ldrb	r3, [r0, #3]
  (*state)[0][3] = (*state)[1][3];
    1f1a:	79c2      	ldrb	r2, [r0, #7]
    1f1c:	70c2      	strb	r2, [r0, #3]
  (*state)[1][3] = (*state)[2][3];
    1f1e:	7ac2      	ldrb	r2, [r0, #11]
    1f20:	71c2      	strb	r2, [r0, #7]
  (*state)[2][3] = (*state)[3][3];
    1f22:	7bc2      	ldrb	r2, [r0, #15]
    1f24:	72c2      	strb	r2, [r0, #11]
  (*state)[3][3] = temp;
    1f26:	73c3      	strb	r3, [r0, #15]
}
    1f28:	4770      	bx	lr

00001f2a <Cipher>:
#endif // #if (defined(CBC) && CBC == 1) || (defined(ECB) && ECB == 1)

// Cipher is the main function that encrypts the PlainText.
static void Cipher(state_t* state, const uint8_t* RoundKey)
{
    1f2a:	b570      	push	{r4, r5, r6, lr}
    1f2c:	4605      	mov	r5, r0
    1f2e:	460e      	mov	r6, r1
  uint8_t round = 0;

  // Add the First round key to the state before starting the rounds.
  AddRoundKey(0, state, RoundKey);
    1f30:	460a      	mov	r2, r1
    1f32:	4601      	mov	r1, r0
    1f34:	2000      	movs	r0, #0
    1f36:	f7ff fe73 	bl	1c20 <AddRoundKey>

  // There will be Nr rounds.
  // The first Nr-1 rounds are identical.
  // These Nr rounds are executed in the loop below.
  // Last one without MixColumns()
  for (round = 1; ; ++round)
    1f3a:	2401      	movs	r4, #1
    1f3c:	e009      	b.n	1f52 <Cipher+0x28>
    SubBytes(state);
    ShiftRows(state);
    if (round == Nr) {
      break;
    }
    MixColumns(state);
    1f3e:	4628      	mov	r0, r5
    1f40:	f7ff fece 	bl	1ce0 <MixColumns>
    AddRoundKey(round, state, RoundKey);
    1f44:	4632      	mov	r2, r6
    1f46:	4629      	mov	r1, r5
    1f48:	4620      	mov	r0, r4
    1f4a:	f7ff fe69 	bl	1c20 <AddRoundKey>
  for (round = 1; ; ++round)
    1f4e:	3401      	adds	r4, #1
    1f50:	b2e4      	uxtb	r4, r4
    SubBytes(state);
    1f52:	4628      	mov	r0, r5
    1f54:	f7ff fe80 	bl	1c58 <SubBytes>
    ShiftRows(state);
    1f58:	4628      	mov	r0, r5
    1f5a:	f7ff fe9f 	bl	1c9c <ShiftRows>
    if (round == Nr) {
    1f5e:	2c0e      	cmp	r4, #14
    1f60:	d1ed      	bne.n	1f3e <Cipher+0x14>
  }
  // Add round key to last round
  AddRoundKey(Nr, state, RoundKey);
    1f62:	4632      	mov	r2, r6
    1f64:	4629      	mov	r1, r5
    1f66:	200e      	movs	r0, #14
    1f68:	f7ff fe5a 	bl	1c20 <AddRoundKey>
}
    1f6c:	bd70      	pop	{r4, r5, r6, pc}

00001f6e <InvCipher>:

#if (defined(CBC) && CBC == 1) || (defined(ECB) && ECB == 1)
static void InvCipher(state_t* state, const uint8_t* RoundKey)
{
    1f6e:	b570      	push	{r4, r5, r6, lr}
    1f70:	4605      	mov	r5, r0
    1f72:	460e      	mov	r6, r1
  uint8_t round = 0;

  // Add the First round key to the state before starting the rounds.
  AddRoundKey(Nr, state, RoundKey);
    1f74:	460a      	mov	r2, r1
    1f76:	4601      	mov	r1, r0
    1f78:	200e      	movs	r0, #14
    1f7a:	f7ff fe51 	bl	1c20 <AddRoundKey>

  // There will be Nr rounds.
  // The first Nr-1 rounds are identical.
  // These Nr rounds are executed in the loop below.
  // Last one without InvMixColumn()
  for (round = (Nr - 1); ; --round)
    1f7e:	240d      	movs	r4, #13
    1f80:	e004      	b.n	1f8c <InvCipher+0x1e>
    InvSubBytes(state);
    AddRoundKey(round, state, RoundKey);
    if (round == 0) {
      break;
    }
    InvMixColumns(state);
    1f82:	4628      	mov	r0, r5
    1f84:	f7ff fee7 	bl	1d56 <InvMixColumns>
  for (round = (Nr - 1); ; --round)
    1f88:	3c01      	subs	r4, #1
    1f8a:	b2e4      	uxtb	r4, r4
    InvShiftRows(state);
    1f8c:	4628      	mov	r0, r5
    1f8e:	f7ff ffb3 	bl	1ef8 <InvShiftRows>
    InvSubBytes(state);
    1f92:	4628      	mov	r0, r5
    1f94:	f7ff ff8c 	bl	1eb0 <InvSubBytes>
    AddRoundKey(round, state, RoundKey);
    1f98:	4632      	mov	r2, r6
    1f9a:	4629      	mov	r1, r5
    1f9c:	4620      	mov	r0, r4
    1f9e:	f7ff fe3f 	bl	1c20 <AddRoundKey>
    if (round == 0) {
    1fa2:	2c00      	cmp	r4, #0
    1fa4:	d1ed      	bne.n	1f82 <InvCipher+0x14>
  }

}
    1fa6:	bd70      	pop	{r4, r5, r6, pc}

00001fa8 <XorWithIv>:


static void XorWithIv(uint8_t* buf, const uint8_t* Iv)
{
  uint8_t i;
  for (i = 0; i < AES_BLOCKLEN; ++i) // The block in AES is always 128bit no matter the key size
    1fa8:	2300      	movs	r3, #0
    1faa:	e007      	b.n	1fbc <XorWithIv+0x14>
  {
    buf[i] ^= Iv[i];
    1fac:	5cc2      	ldrb	r2, [r0, r3]
    1fae:	f811 c003 	ldrb.w	ip, [r1, r3]
    1fb2:	ea82 020c 	eor.w	r2, r2, ip
    1fb6:	54c2      	strb	r2, [r0, r3]
  for (i = 0; i < AES_BLOCKLEN; ++i) // The block in AES is always 128bit no matter the key size
    1fb8:	3301      	adds	r3, #1
    1fba:	b2db      	uxtb	r3, r3
    1fbc:	2b0f      	cmp	r3, #15
    1fbe:	d9f5      	bls.n	1fac <XorWithIv+0x4>
  }
}
    1fc0:	4770      	bx	lr

00001fc2 <AES_init_ctx>:
{
    1fc2:	b508      	push	{r3, lr}
  KeyExpansion(ctx->RoundKey, key);
    1fc4:	f7ff fd9c 	bl	1b00 <KeyExpansion>
}
    1fc8:	bd08      	pop	{r3, pc}

00001fca <AES_init_ctx_iv>:
{
    1fca:	b538      	push	{r3, r4, r5, lr}
    1fcc:	4604      	mov	r4, r0
    1fce:	4615      	mov	r5, r2
  KeyExpansion(ctx->RoundKey, key);
    1fd0:	f7ff fd96 	bl	1b00 <KeyExpansion>
  memcpy (ctx->Iv, iv, AES_BLOCKLEN);
    1fd4:	2210      	movs	r2, #16
    1fd6:	4629      	mov	r1, r5
    1fd8:	f104 00f0 	add.w	r0, r4, #240	@ 0xf0
    1fdc:	f000 fbef 	bl	27be <memcpy>
}
    1fe0:	bd38      	pop	{r3, r4, r5, pc}

00001fe2 <AES_ctx_set_iv>:
{
    1fe2:	b508      	push	{r3, lr}
  memcpy (ctx->Iv, iv, AES_BLOCKLEN);
    1fe4:	2210      	movs	r2, #16
    1fe6:	30f0      	adds	r0, #240	@ 0xf0
    1fe8:	f000 fbe9 	bl	27be <memcpy>
}
    1fec:	bd08      	pop	{r3, pc}

00001fee <AES_ECB_encrypt>:
{
    1fee:	b508      	push	{r3, lr}
    1ff0:	460b      	mov	r3, r1
  Cipher((state_t*)buf, ctx->RoundKey);
    1ff2:	4601      	mov	r1, r0
    1ff4:	4618      	mov	r0, r3
    1ff6:	f7ff ff98 	bl	1f2a <Cipher>
}
    1ffa:	bd08      	pop	{r3, pc}

00001ffc <AES_ECB_decrypt>:
{
    1ffc:	b508      	push	{r3, lr}
    1ffe:	460b      	mov	r3, r1
  InvCipher((state_t*)buf, ctx->RoundKey);
    2000:	4601      	mov	r1, r0
    2002:	4618      	mov	r0, r3
    2004:	f7ff ffb3 	bl	1f6e <InvCipher>
}
    2008:	bd08      	pop	{r3, pc}

0000200a <AES_CBC_encrypt_buffer>:

void AES_CBC_encrypt_buffer(struct AES_ctx *ctx, uint8_t* buf, size_t length)
{
    200a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    200e:	4606      	mov	r6, r0
    2010:	460c      	mov	r4, r1
    2012:	4617      	mov	r7, r2
  size_t i;
  uint8_t *Iv = ctx->Iv;
    2014:	f100 08f0 	add.w	r8, r0, #240	@ 0xf0
    2018:	4641      	mov	r1, r8
  for (i = 0; i < length; i += AES_BLOCKLEN)
    201a:	2500      	movs	r5, #0
    201c:	e009      	b.n	2032 <AES_CBC_encrypt_buffer+0x28>
  {
    XorWithIv(buf, Iv);
    201e:	4620      	mov	r0, r4
    2020:	f7ff ffc2 	bl	1fa8 <XorWithIv>
    Cipher((state_t*)buf, ctx->RoundKey);
    2024:	4631      	mov	r1, r6
    2026:	4620      	mov	r0, r4
    2028:	f7ff ff7f 	bl	1f2a <Cipher>
  for (i = 0; i < length; i += AES_BLOCKLEN)
    202c:	3510      	adds	r5, #16
    Iv = buf;
    202e:	4621      	mov	r1, r4
    buf += AES_BLOCKLEN;
    2030:	3410      	adds	r4, #16
  for (i = 0; i < length; i += AES_BLOCKLEN)
    2032:	42bd      	cmp	r5, r7
    2034:	d3f3      	bcc.n	201e <AES_CBC_encrypt_buffer+0x14>
  }
  /* store Iv in ctx for next call */
  memcpy(ctx->Iv, Iv, AES_BLOCKLEN);
    2036:	2210      	movs	r2, #16
    2038:	4640      	mov	r0, r8
    203a:	f000 fbc0 	bl	27be <memcpy>
}
    203e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00002042 <AES_CBC_decrypt_buffer>:

void AES_CBC_decrypt_buffer(struct AES_ctx* ctx, uint8_t* buf, size_t length)
{
    2042:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    2046:	b084      	sub	sp, #16
    2048:	4607      	mov	r7, r0
    204a:	460c      	mov	r4, r1
    204c:	4690      	mov	r8, r2
  size_t i;
  uint8_t storeNextIv[AES_BLOCKLEN];
  for (i = 0; i < length; i += AES_BLOCKLEN)
    204e:	2500      	movs	r5, #0
    2050:	e015      	b.n	207e <AES_CBC_decrypt_buffer+0x3c>
  {
    memcpy(storeNextIv, buf, AES_BLOCKLEN);
    2052:	2210      	movs	r2, #16
    2054:	4621      	mov	r1, r4
    2056:	4668      	mov	r0, sp
    2058:	f000 fbb1 	bl	27be <memcpy>
    InvCipher((state_t*)buf, ctx->RoundKey);
    205c:	4639      	mov	r1, r7
    205e:	4620      	mov	r0, r4
    2060:	f7ff ff85 	bl	1f6e <InvCipher>
    XorWithIv(buf, ctx->Iv);
    2064:	f107 06f0 	add.w	r6, r7, #240	@ 0xf0
    2068:	4631      	mov	r1, r6
    206a:	4620      	mov	r0, r4
    206c:	f7ff ff9c 	bl	1fa8 <XorWithIv>
    memcpy(ctx->Iv, storeNextIv, AES_BLOCKLEN);
    2070:	2210      	movs	r2, #16
    2072:	4669      	mov	r1, sp
    2074:	4630      	mov	r0, r6
    2076:	f000 fba2 	bl	27be <memcpy>
    buf += AES_BLOCKLEN;
    207a:	3410      	adds	r4, #16
  for (i = 0; i < length; i += AES_BLOCKLEN)
    207c:	3510      	adds	r5, #16
    207e:	4545      	cmp	r5, r8
    2080:	d3e7      	bcc.n	2052 <AES_CBC_decrypt_buffer+0x10>
  }

}
    2082:	b004      	add	sp, #16
    2084:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00002088 <AES_CTR_xcrypt_buffer>:

#if defined(CTR) && (CTR == 1)

/* Symmetrical operation: same function for encrypting as for decrypting. Note any IV/nonce should never be reused with the same key */
void AES_CTR_xcrypt_buffer(struct AES_ctx* ctx, uint8_t* buf, size_t length)
{
    2088:	b5f0      	push	{r4, r5, r6, r7, lr}
    208a:	b085      	sub	sp, #20
    208c:	4607      	mov	r7, r0
    208e:	460d      	mov	r5, r1
    2090:	4616      	mov	r6, r2
  uint8_t buffer[AES_BLOCKLEN];
  
  size_t i;
  int bi;
  for (i = 0, bi = AES_BLOCKLEN; i < length; ++i, ++bi)
    2092:	2310      	movs	r3, #16
    2094:	2400      	movs	r4, #0
    2096:	e013      	b.n	20c0 <AES_CTR_xcrypt_buffer+0x38>
      for (bi = (AES_BLOCKLEN - 1); bi >= 0; --bi)
      {
	/* inc will overflow */
        if (ctx->Iv[bi] == 255)
	{
          ctx->Iv[bi] = 0;
    2098:	18fa      	adds	r2, r7, r3
    209a:	2100      	movs	r1, #0
    209c:	f882 10f0 	strb.w	r1, [r2, #240]	@ 0xf0
      for (bi = (AES_BLOCKLEN - 1); bi >= 0; --bi)
    20a0:	3b01      	subs	r3, #1
    20a2:	e01c      	b.n	20de <AES_CTR_xcrypt_buffer+0x56>
          continue;
        } 
        ctx->Iv[bi] += 1;
        break;   
      }
      bi = 0;
    20a4:	2300      	movs	r3, #0
    }

    buf[i] = (buf[i] ^ buffer[bi]);
    20a6:	f815 c004 	ldrb.w	ip, [r5, r4]
    20aa:	f103 0210 	add.w	r2, r3, #16
    20ae:	446a      	add	r2, sp
    20b0:	f812 ec10 	ldrb.w	lr, [r2, #-16]
    20b4:	ea8c 0c0e 	eor.w	ip, ip, lr
    20b8:	f805 c004 	strb.w	ip, [r5, r4]
  for (i = 0, bi = AES_BLOCKLEN; i < length; ++i, ++bi)
    20bc:	3401      	adds	r4, #1
    20be:	3301      	adds	r3, #1
    20c0:	42b4      	cmp	r4, r6
    20c2:	d219      	bcs.n	20f8 <AES_CTR_xcrypt_buffer+0x70>
    if (bi == AES_BLOCKLEN) /* we need to regen xor compliment in buffer */
    20c4:	2b10      	cmp	r3, #16
    20c6:	d1ee      	bne.n	20a6 <AES_CTR_xcrypt_buffer+0x1e>
      memcpy(buffer, ctx->Iv, AES_BLOCKLEN);
    20c8:	2210      	movs	r2, #16
    20ca:	f107 01f0 	add.w	r1, r7, #240	@ 0xf0
    20ce:	4668      	mov	r0, sp
    20d0:	f000 fb75 	bl	27be <memcpy>
      Cipher((state_t*)buffer,ctx->RoundKey);
    20d4:	4639      	mov	r1, r7
    20d6:	4668      	mov	r0, sp
    20d8:	f7ff ff27 	bl	1f2a <Cipher>
      for (bi = (AES_BLOCKLEN - 1); bi >= 0; --bi)
    20dc:	230f      	movs	r3, #15
    20de:	2b00      	cmp	r3, #0
    20e0:	dbe0      	blt.n	20a4 <AES_CTR_xcrypt_buffer+0x1c>
        if (ctx->Iv[bi] == 255)
    20e2:	18fa      	adds	r2, r7, r3
    20e4:	f892 20f0 	ldrb.w	r2, [r2, #240]	@ 0xf0
    20e8:	2aff      	cmp	r2, #255	@ 0xff
    20ea:	d0d5      	beq.n	2098 <AES_CTR_xcrypt_buffer+0x10>
        ctx->Iv[bi] += 1;
    20ec:	443b      	add	r3, r7
    20ee:	3201      	adds	r2, #1
    20f0:	f883 20f0 	strb.w	r2, [r3, #240]	@ 0xf0
      bi = 0;
    20f4:	2300      	movs	r3, #0
        break;   
    20f6:	e7d6      	b.n	20a6 <AES_CTR_xcrypt_buffer+0x1e>
  }
}
    20f8:	b005      	add	sp, #20
    20fa:	bdf0      	pop	{r4, r5, r6, r7, pc}

000020fc <bitvec_get_bit>:


/* some basic bit-manipulation routines that act on bit-vectors follow */
static int bitvec_get_bit(const bitvec_t x, const uint32_t idx)
{
  return ((x[idx / 32U] >> (idx & 31U) & 1U));
    20fc:	094b      	lsrs	r3, r1, #5
    20fe:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
    2102:	f001 011f 	and.w	r1, r1, #31
    2106:	40c8      	lsrs	r0, r1
}
    2108:	f000 0001 	and.w	r0, r0, #1
    210c:	4770      	bx	lr

0000210e <bitvec_clr_bit>:

static void bitvec_clr_bit(bitvec_t x, const uint32_t idx)
{
  x[idx / 32U] &= ~(1U << (idx & 31U));
    210e:	ea4f 1c51 	mov.w	ip, r1, lsr #5
    2112:	f850 302c 	ldr.w	r3, [r0, ip, lsl #2]
    2116:	f001 011f 	and.w	r1, r1, #31
    211a:	2201      	movs	r2, #1
    211c:	408a      	lsls	r2, r1
    211e:	ea23 0302 	bic.w	r3, r3, r2
    2122:	f840 302c 	str.w	r3, [r0, ip, lsl #2]
}
    2126:	4770      	bx	lr

00002128 <bitvec_copy>:

static void bitvec_copy(bitvec_t x, const bitvec_t y)
{
  int i;
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2128:	2300      	movs	r3, #0
    212a:	e004      	b.n	2136 <bitvec_copy+0xe>
  {
    x[i] = y[i];
    212c:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
    2130:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2134:	3301      	adds	r3, #1
    2136:	2b05      	cmp	r3, #5
    2138:	ddf8      	ble.n	212c <bitvec_copy+0x4>
  }
}
    213a:	4770      	bx	lr

0000213c <bitvec_swap>:

static void bitvec_swap(bitvec_t x, bitvec_t y)
{
    213c:	b530      	push	{r4, r5, lr}
    213e:	b087      	sub	sp, #28
    2140:	4605      	mov	r5, r0
    2142:	460c      	mov	r4, r1
  bitvec_t tmp;
  bitvec_copy(tmp, x);
    2144:	4601      	mov	r1, r0
    2146:	4668      	mov	r0, sp
    2148:	f7ff ffee 	bl	2128 <bitvec_copy>
  bitvec_copy(x, y);
    214c:	4621      	mov	r1, r4
    214e:	4628      	mov	r0, r5
    2150:	f7ff ffea 	bl	2128 <bitvec_copy>
  bitvec_copy(y, tmp);
    2154:	4669      	mov	r1, sp
    2156:	4620      	mov	r0, r4
    2158:	f7ff ffe6 	bl	2128 <bitvec_copy>
}
    215c:	b007      	add	sp, #28
    215e:	bd30      	pop	{r4, r5, pc}

00002160 <bitvec_equal>:
#if defined(CONST_TIME) && (CONST_TIME == 0)
/* fast version of equality test */
static int bitvec_equal(const bitvec_t x, const bitvec_t y)
{
  int i;
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2160:	2300      	movs	r3, #0
    2162:	2b05      	cmp	r3, #5
    2164:	dc07      	bgt.n	2176 <bitvec_equal+0x16>
  {
    if (x[i] != y[i])
    2166:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
    216a:	f850 c023 	ldr.w	ip, [r0, r3, lsl #2]
    216e:	4594      	cmp	ip, r2
    2170:	d103      	bne.n	217a <bitvec_equal+0x1a>
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2172:	3301      	adds	r3, #1
    2174:	e7f5      	b.n	2162 <bitvec_equal+0x2>
    {
      return 0;
    }
  }
  return 1;
    2176:	2001      	movs	r0, #1
    2178:	4770      	bx	lr
      return 0;
    217a:	2000      	movs	r0, #0
}
    217c:	4770      	bx	lr

0000217e <bitvec_set_zero>:
#endif

static void bitvec_set_zero(bitvec_t x)
{
  int i;
  for (i = 0; i < BITVEC_NWORDS; ++i)
    217e:	2300      	movs	r3, #0
    2180:	e003      	b.n	218a <bitvec_set_zero+0xc>
  {
    x[i] = 0;
    2182:	2200      	movs	r2, #0
    2184:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2188:	3301      	adds	r3, #1
    218a:	2b05      	cmp	r3, #5
    218c:	ddf9      	ble.n	2182 <bitvec_set_zero+0x4>
  }
}
    218e:	4770      	bx	lr

00002190 <bitvec_is_zero>:

#if defined(CONST_TIME) && (CONST_TIME == 0)
/* fast implementation */
static int bitvec_is_zero(const bitvec_t x)
{
  uint32_t i = 0;
    2190:	2300      	movs	r3, #0
  while (i < BITVEC_NWORDS)
    2192:	2b05      	cmp	r3, #5
    2194:	d804      	bhi.n	21a0 <bitvec_is_zero+0x10>
  {
    if (x[i] != 0)
    2196:	f850 2023 	ldr.w	r2, [r0, r3, lsl #2]
    219a:	b90a      	cbnz	r2, 21a0 <bitvec_is_zero+0x10>
    {
      break;
    }
    i += 1;
    219c:	3301      	adds	r3, #1
    219e:	e7f8      	b.n	2192 <bitvec_is_zero+0x2>
  }
  return (i == BITVEC_NWORDS);
}
    21a0:	2b06      	cmp	r3, #6
    21a2:	bf14      	ite	ne
    21a4:	2000      	movne	r0, #0
    21a6:	2001      	moveq	r0, #1
    21a8:	4770      	bx	lr

000021aa <bitvec_degree>:
static int bitvec_degree(const bitvec_t x)
{
  int i = BITVEC_NWORDS * 32;

  /* Start at the back of the vector (MSB) */
  x += BITVEC_NWORDS;
    21aa:	f100 0318 	add.w	r3, r0, #24
  int i = BITVEC_NWORDS * 32;
    21ae:	20c0      	movs	r0, #192	@ 0xc0

  /* Skip empty / zero words */
  while (    (i > 0)
          && (*(--x)) == 0)
    21b0:	2800      	cmp	r0, #0
    21b2:	dd04      	ble.n	21be <bitvec_degree+0x14>
    21b4:	f853 2d04 	ldr.w	r2, [r3, #-4]!
    21b8:	b90a      	cbnz	r2, 21be <bitvec_degree+0x14>
  {
    i -= 32;
    21ba:	3820      	subs	r0, #32
    21bc:	e7f8      	b.n	21b0 <bitvec_degree+0x6>
  }
  /* Run through rest if count is not multiple of bitsize of DTYPE */
  if (i != 0)
    21be:	b930      	cbnz	r0, 21ce <bitvec_degree+0x24>
    21c0:	4770      	bx	lr
  {
    uint32_t u32mask = ((uint32_t)1 << 31);
    while (((*x) & u32mask) == 0)
    {
      u32mask >>= 1;
    21c2:	0852      	lsrs	r2, r2, #1
      i -= 1;
    21c4:	3801      	subs	r0, #1
    while (((*x) & u32mask) == 0)
    21c6:	6819      	ldr	r1, [r3, #0]
    21c8:	4211      	tst	r1, r2
    21ca:	d0fa      	beq.n	21c2 <bitvec_degree+0x18>
    }
  }
  return i;
}
    21cc:	4770      	bx	lr
    uint32_t u32mask = ((uint32_t)1 << 31);
    21ce:	f04f 4200 	mov.w	r2, #2147483648	@ 0x80000000
    21d2:	e7f8      	b.n	21c6 <bitvec_degree+0x1c>

000021d4 <bitvec_lshift>:

/* left-shift by 'count' digits */
static void bitvec_lshift(bitvec_t x, const bitvec_t y, int nbits)
{
    21d4:	b410      	push	{r4}
  int nwords = (nbits / 32);
    21d6:	4694      	mov	ip, r2
    21d8:	2a00      	cmp	r2, #0
    21da:	db03      	blt.n	21e4 <bitvec_lshift+0x10>
    21dc:	ea4f 1c6c 	mov.w	ip, ip, asr #5

  /* Shift whole words first if nwords > 0 */
  int i,j;
  for (i = 0; i < nwords; ++i)
    21e0:	2300      	movs	r3, #0
    21e2:	e006      	b.n	21f2 <bitvec_lshift+0x1e>
  int nwords = (nbits / 32);
    21e4:	f102 0c1f 	add.w	ip, r2, #31
    21e8:	e7f8      	b.n	21dc <bitvec_lshift+0x8>
  {
    /* Zero-initialize from least-significant word until offset reached */
    x[i] = 0;
    21ea:	2400      	movs	r4, #0
    21ec:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
  for (i = 0; i < nwords; ++i)
    21f0:	3301      	adds	r3, #1
    21f2:	4563      	cmp	r3, ip
    21f4:	dbf9      	blt.n	21ea <bitvec_lshift+0x16>
  }
  j = 0;
    21f6:	f04f 0c00 	mov.w	ip, #0
    21fa:	e006      	b.n	220a <bitvec_lshift+0x36>
  /* Copy to x output */
  while (i < BITVEC_NWORDS)
  {
    x[i] = y[j];
    21fc:	f851 402c 	ldr.w	r4, [r1, ip, lsl #2]
    2200:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
    i += 1;
    2204:	3301      	adds	r3, #1
    j += 1;
    2206:	f10c 0c01 	add.w	ip, ip, #1
  while (i < BITVEC_NWORDS)
    220a:	2b05      	cmp	r3, #5
    220c:	ddf6      	ble.n	21fc <bitvec_lshift+0x28>
  }

  /* Shift the rest if count was not multiple of bitsize of DTYPE */
  nbits &= 31;
  if (nbits != 0)
    220e:	f012 021f 	ands.w	r2, r2, #31
    2212:	d117      	bne.n	2244 <bitvec_lshift+0x70>
    {
      x[i]  = (x[i] << nbits) | (x[i - 1] >> (32 - nbits));
    }
    x[0] <<= nbits;
  }
}
    2214:	bc10      	pop	{r4}
    2216:	4770      	bx	lr
      x[i]  = (x[i] << nbits) | (x[i - 1] >> (32 - nbits));
    2218:	f850 1023 	ldr.w	r1, [r0, r3, lsl #2]
    221c:	4091      	lsls	r1, r2
    221e:	f103 4480 	add.w	r4, r3, #1073741824	@ 0x40000000
    2222:	3c01      	subs	r4, #1
    2224:	f850 4024 	ldr.w	r4, [r0, r4, lsl #2]
    2228:	f1c2 0c20 	rsb	ip, r2, #32
    222c:	fa24 f40c 	lsr.w	r4, r4, ip
    2230:	4321      	orrs	r1, r4
    2232:	f840 1023 	str.w	r1, [r0, r3, lsl #2]
    for (i = (BITVEC_NWORDS - 1); i > 0; --i)
    2236:	3b01      	subs	r3, #1
    2238:	2b00      	cmp	r3, #0
    223a:	dced      	bgt.n	2218 <bitvec_lshift+0x44>
    x[0] <<= nbits;
    223c:	6803      	ldr	r3, [r0, #0]
    223e:	4093      	lsls	r3, r2
    2240:	6003      	str	r3, [r0, #0]
}
    2242:	e7e7      	b.n	2214 <bitvec_lshift+0x40>
    for (i = (BITVEC_NWORDS - 1); i > 0; --i)
    2244:	2305      	movs	r3, #5
    2246:	e7f7      	b.n	2238 <bitvec_lshift+0x64>

00002248 <gf2field_set_one>:


static void gf2field_set_one(gf2elem_t x)
{
  /* Set first word to one */
  x[0] = 1;
    2248:	2301      	movs	r3, #1
    224a:	6003      	str	r3, [r0, #0]
  /* .. and the rest to zero */
  int i;
  for (i = 1; i < BITVEC_NWORDS; ++i)
    224c:	e003      	b.n	2256 <gf2field_set_one+0xe>
  {
    x[i] = 0;
    224e:	2200      	movs	r2, #0
    2250:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
  for (i = 1; i < BITVEC_NWORDS; ++i)
    2254:	3301      	adds	r3, #1
    2256:	2b05      	cmp	r3, #5
    2258:	ddf9      	ble.n	224e <gf2field_set_one+0x6>
  }
}
    225a:	4770      	bx	lr

0000225c <gf2field_is_one>:
#if defined(CONST_TIME) && (CONST_TIME == 0)
/* fastest check if x == 1 */
static int gf2field_is_one(const gf2elem_t x) 
{
  /* Check if first word == 1 */
  if (x[0] != 1)
    225c:	6803      	ldr	r3, [r0, #0]
    225e:	2b01      	cmp	r3, #1
    2260:	d10b      	bne.n	227a <gf2field_is_one+0x1e>
  {
    return 0;
  }
  /* ...and if rest of words == 0 */
  int i;
  for (i = 1; i < BITVEC_NWORDS; ++i)
    2262:	2b05      	cmp	r3, #5
    2264:	dc04      	bgt.n	2270 <gf2field_is_one+0x14>
  {
    if (x[i] != 0)
    2266:	f850 2023 	ldr.w	r2, [r0, r3, lsl #2]
    226a:	b90a      	cbnz	r2, 2270 <gf2field_is_one+0x14>
  for (i = 1; i < BITVEC_NWORDS; ++i)
    226c:	3301      	adds	r3, #1
    226e:	e7f8      	b.n	2262 <gf2field_is_one+0x6>
    {
      break;
    }
  }
  return (i == BITVEC_NWORDS);
    2270:	2b06      	cmp	r3, #6
    2272:	bf14      	ite	ne
    2274:	2000      	movne	r0, #0
    2276:	2001      	moveq	r0, #1
    2278:	4770      	bx	lr
    return 0;
    227a:	2000      	movs	r0, #0
}
    227c:	4770      	bx	lr

0000227e <gf2field_add>:

/* galois field(2^m) addition is modulo 2, so XOR is used instead - 'z := a + b' */
static void gf2field_add(gf2elem_t z, const gf2elem_t x, const gf2elem_t y)
{
  int i;
  for (i = 0; i < BITVEC_NWORDS; ++i)
    227e:	2300      	movs	r3, #0
    2280:	2b05      	cmp	r3, #5
    2282:	dc0c      	bgt.n	229e <gf2field_add+0x20>
{
    2284:	b430      	push	{r4, r5}
  {
    z[i] = (x[i] ^ y[i]);
    2286:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
    228a:	f851 5023 	ldr.w	r5, [r1, r3, lsl #2]
    228e:	406c      	eors	r4, r5
    2290:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2294:	3301      	adds	r3, #1
    2296:	2b05      	cmp	r3, #5
    2298:	ddf5      	ble.n	2286 <gf2field_add+0x8>
  }
}
    229a:	bc30      	pop	{r4, r5}
    229c:	4770      	bx	lr
    229e:	4770      	bx	lr

000022a0 <gf2field_inc>:

/* increment element */
static void gf2field_inc(gf2elem_t x)
{
  x[0] ^= 1;
    22a0:	6803      	ldr	r3, [r0, #0]
    22a2:	f083 0301 	eor.w	r3, r3, #1
    22a6:	6003      	str	r3, [r0, #0]
}
    22a8:	4770      	bx	lr

000022aa <gf2field_mul>:


/* field multiplication 'z := (x * y)' */
static void gf2field_mul(gf2elem_t z, const gf2elem_t x, const gf2elem_t y)
{
    22aa:	b570      	push	{r4, r5, r6, lr}
    22ac:	b086      	sub	sp, #24
    22ae:	4606      	mov	r6, r0
    22b0:	460c      	mov	r4, r1
    22b2:	4615      	mov	r5, r2
#if defined(CONST_TIME) && (CONST_TIME == 1)
  gf2elem_t blind;
  bitvec_set_zero(blind);
#endif

  bitvec_copy(tmp, x);
    22b4:	4668      	mov	r0, sp
    22b6:	f7ff ff37 	bl	2128 <bitvec_copy>

  /* LSB set? Then start with x */
  if (bitvec_get_bit(y, 0) != 0)
    22ba:	2100      	movs	r1, #0
    22bc:	4628      	mov	r0, r5
    22be:	f7ff ff1d 	bl	20fc <bitvec_get_bit>
    22c2:	b128      	cbz	r0, 22d0 <gf2field_mul+0x26>
  {
    bitvec_copy(z, x);
    22c4:	4621      	mov	r1, r4
    22c6:	4630      	mov	r0, r6
    22c8:	f7ff ff2e 	bl	2128 <bitvec_copy>
{
    22cc:	2401      	movs	r4, #1
    22ce:	e00a      	b.n	22e6 <gf2field_mul+0x3c>
  }
  else /* .. or else start with zero */
  {
    bitvec_set_zero(z);
    22d0:	4630      	mov	r0, r6
    22d2:	f7ff ff54 	bl	217e <bitvec_set_zero>
    22d6:	e7f9      	b.n	22cc <gf2field_mul+0x22>
    bitvec_lshift(tmp, tmp, 1);

    /* Modulo reduction polynomial if degree(tmp) > CURVE_DEGREE */
    if (bitvec_get_bit(tmp, CURVE_DEGREE))
    {
      gf2field_add(tmp, tmp, polynomial);
    22d8:	4a10      	ldr	r2, [pc, #64]	@ (231c <gf2field_mul+0x72>)
    22da:	4669      	mov	r1, sp
    22dc:	4668      	mov	r0, sp
    22de:	f7ff ffce 	bl	227e <gf2field_add>
    22e2:	e00d      	b.n	2300 <gf2field_mul+0x56>
  for (i = 1; i < CURVE_DEGREE; ++i)
    22e4:	3401      	adds	r4, #1
    22e6:	2ca2      	cmp	r4, #162	@ 0xa2
    22e8:	dc16      	bgt.n	2318 <gf2field_mul+0x6e>
    bitvec_lshift(tmp, tmp, 1);
    22ea:	2201      	movs	r2, #1
    22ec:	4669      	mov	r1, sp
    22ee:	4668      	mov	r0, sp
    22f0:	f7ff ff70 	bl	21d4 <bitvec_lshift>
    if (bitvec_get_bit(tmp, CURVE_DEGREE))
    22f4:	21a3      	movs	r1, #163	@ 0xa3
    22f6:	4668      	mov	r0, sp
    22f8:	f7ff ff00 	bl	20fc <bitvec_get_bit>
    22fc:	2800      	cmp	r0, #0
    22fe:	d1eb      	bne.n	22d8 <gf2field_mul+0x2e>
      gf2field_add(tmp, tmp, blind);
    }
#endif

    /* Add 2^i * tmp if this factor in y is non-zero */
    if (bitvec_get_bit(y, i))
    2300:	4621      	mov	r1, r4
    2302:	4628      	mov	r0, r5
    2304:	f7ff fefa 	bl	20fc <bitvec_get_bit>
    2308:	2800      	cmp	r0, #0
    230a:	d0eb      	beq.n	22e4 <gf2field_mul+0x3a>
    {
      gf2field_add(z, z, tmp);
    230c:	466a      	mov	r2, sp
    230e:	4631      	mov	r1, r6
    2310:	4630      	mov	r0, r6
    2312:	f7ff ffb4 	bl	227e <gf2field_add>
    2316:	e7e5      	b.n	22e4 <gf2field_mul+0x3a>
    {
      gf2field_add(z, z, blind);
    }
#endif
  }
}
    2318:	b006      	add	sp, #24
    231a:	bd70      	pop	{r4, r5, r6, pc}
    231c:	000035b8 			@ <UNDEFINED> instruction: 0x000035b8

00002320 <gf2field_inv>:

/* field inversion 'z := 1/x' */
static void gf2field_inv(gf2elem_t z, const gf2elem_t x)
{
    2320:	b5f0      	push	{r4, r5, r6, r7, lr}
    2322:	b099      	sub	sp, #100	@ 0x64
    2324:	4607      	mov	r7, r0
  gf2elem_t u, v, g, h;
  int i;

  bitvec_copy(u, x);
    2326:	a812      	add	r0, sp, #72	@ 0x48
    2328:	f7ff fefe 	bl	2128 <bitvec_copy>
  bitvec_copy(v, polynomial);
    232c:	491c      	ldr	r1, [pc, #112]	@ (23a0 <gf2field_inv+0x80>)
    232e:	a80c      	add	r0, sp, #48	@ 0x30
    2330:	f7ff fefa 	bl	2128 <bitvec_copy>
  bitvec_set_zero(g);
    2334:	a806      	add	r0, sp, #24
    2336:	f7ff ff22 	bl	217e <bitvec_set_zero>
  gf2field_set_one(z);
    233a:	4638      	mov	r0, r7
    233c:	f7ff ff84 	bl	2248 <gf2field_set_one>
  
  while (!gf2field_is_one(u))
    2340:	e013      	b.n	236a <gf2field_inv+0x4a>
    {
      bitvec_swap(u, v);
      bitvec_swap(v, u);
    }
#endif
    bitvec_lshift(h, v, i);
    2342:	4632      	mov	r2, r6
    2344:	a90c      	add	r1, sp, #48	@ 0x30
    2346:	4668      	mov	r0, sp
    2348:	f7ff ff44 	bl	21d4 <bitvec_lshift>
    gf2field_add(u, u, h);
    234c:	466a      	mov	r2, sp
    234e:	a912      	add	r1, sp, #72	@ 0x48
    2350:	4608      	mov	r0, r1
    2352:	f7ff ff94 	bl	227e <gf2field_add>
    bitvec_lshift(h, g, i);
    2356:	4632      	mov	r2, r6
    2358:	a906      	add	r1, sp, #24
    235a:	4668      	mov	r0, sp
    235c:	f7ff ff3a 	bl	21d4 <bitvec_lshift>
    gf2field_add(z, z, h);
    2360:	466a      	mov	r2, sp
    2362:	4639      	mov	r1, r7
    2364:	4638      	mov	r0, r7
    2366:	f7ff ff8a 	bl	227e <gf2field_add>
  while (!gf2field_is_one(u))
    236a:	a812      	add	r0, sp, #72	@ 0x48
    236c:	f7ff ff76 	bl	225c <gf2field_is_one>
    2370:	b998      	cbnz	r0, 239a <gf2field_inv+0x7a>
    i = (bitvec_degree(u) - bitvec_degree(v));
    2372:	a812      	add	r0, sp, #72	@ 0x48
    2374:	f7ff ff19 	bl	21aa <bitvec_degree>
    2378:	4604      	mov	r4, r0
    237a:	a80c      	add	r0, sp, #48	@ 0x30
    237c:	f7ff ff15 	bl	21aa <bitvec_degree>
    2380:	4605      	mov	r5, r0
    if (i < 0)
    2382:	1a26      	subs	r6, r4, r0
    2384:	d5dd      	bpl.n	2342 <gf2field_inv+0x22>
      bitvec_swap(u, v);
    2386:	a90c      	add	r1, sp, #48	@ 0x30
    2388:	a812      	add	r0, sp, #72	@ 0x48
    238a:	f7ff fed7 	bl	213c <bitvec_swap>
      bitvec_swap(g, z);
    238e:	4639      	mov	r1, r7
    2390:	a806      	add	r0, sp, #24
    2392:	f7ff fed3 	bl	213c <bitvec_swap>
      i = -i;
    2396:	1b2e      	subs	r6, r5, r4
    2398:	e7d3      	b.n	2342 <gf2field_inv+0x22>
  }
}
    239a:	b019      	add	sp, #100	@ 0x64
    239c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    239e:	bf00      	nop
    23a0:	000035b8 			@ <UNDEFINED> instruction: 0x000035b8

000023a4 <gf2point_copy>:
*/
/*************************************************************************************************/


static void gf2point_copy(gf2elem_t x1, gf2elem_t y1, const gf2elem_t x2, const gf2elem_t y2)
{
    23a4:	b538      	push	{r3, r4, r5, lr}
    23a6:	460c      	mov	r4, r1
    23a8:	461d      	mov	r5, r3
  bitvec_copy(x1, x2);
    23aa:	4611      	mov	r1, r2
    23ac:	f7ff febc 	bl	2128 <bitvec_copy>
  bitvec_copy(y1, y2);
    23b0:	4629      	mov	r1, r5
    23b2:	4620      	mov	r0, r4
    23b4:	f7ff feb8 	bl	2128 <bitvec_copy>
}
    23b8:	bd38      	pop	{r3, r4, r5, pc}

000023ba <gf2point_set_zero>:

static void gf2point_set_zero(gf2elem_t x, gf2elem_t y)
{
    23ba:	b510      	push	{r4, lr}
    23bc:	460c      	mov	r4, r1
  bitvec_set_zero(x);
    23be:	f7ff fede 	bl	217e <bitvec_set_zero>
  bitvec_set_zero(y);
    23c2:	4620      	mov	r0, r4
    23c4:	f7ff fedb 	bl	217e <bitvec_set_zero>
}
    23c8:	bd10      	pop	{r4, pc}

000023ca <gf2point_is_zero>:

static int gf2point_is_zero(const gf2elem_t x, const gf2elem_t y)
{
    23ca:	b510      	push	{r4, lr}
    23cc:	460c      	mov	r4, r1
  return (    bitvec_is_zero(x)
    23ce:	f7ff fedf 	bl	2190 <bitvec_is_zero>
           && bitvec_is_zero(y));
    23d2:	b120      	cbz	r0, 23de <gf2point_is_zero+0x14>
    23d4:	4620      	mov	r0, r4
    23d6:	f7ff fedb 	bl	2190 <bitvec_is_zero>
    23da:	b100      	cbz	r0, 23de <gf2point_is_zero+0x14>
    23dc:	2001      	movs	r0, #1
}
    23de:	bd10      	pop	{r4, pc}

000023e0 <gf2point_double>:

/* double the point (x,y) */
static void gf2point_double(gf2elem_t x, gf2elem_t y)
{
    23e0:	b530      	push	{r4, r5, lr}
    23e2:	b087      	sub	sp, #28
    23e4:	4604      	mov	r4, r0
    23e6:	460d      	mov	r5, r1
  /* iff P = O (zero or infinity): 2 * P = P */
  if (bitvec_is_zero(x))
    23e8:	f7ff fed2 	bl	2190 <bitvec_is_zero>
    23ec:	b120      	cbz	r0, 23f8 <gf2point_double+0x18>
  {
    bitvec_set_zero(y);
    23ee:	4628      	mov	r0, r5
    23f0:	f7ff fec5 	bl	217e <bitvec_set_zero>
#endif
    gf2field_add(x, x, l);
    gf2field_mul(l, l, x);
    gf2field_add(y, y, l);
  }
}
    23f4:	b007      	add	sp, #28
    23f6:	bd30      	pop	{r4, r5, pc}
    gf2field_inv(l, x);
    23f8:	4621      	mov	r1, r4
    23fa:	4668      	mov	r0, sp
    23fc:	f7ff ff90 	bl	2320 <gf2field_inv>
    gf2field_mul(l, l, y);
    2400:	462a      	mov	r2, r5
    2402:	4669      	mov	r1, sp
    2404:	4668      	mov	r0, sp
    2406:	f7ff ff50 	bl	22aa <gf2field_mul>
    gf2field_add(l, l, x);
    240a:	4622      	mov	r2, r4
    240c:	4669      	mov	r1, sp
    240e:	4668      	mov	r0, sp
    2410:	f7ff ff35 	bl	227e <gf2field_add>
    gf2field_mul(y, x, x);
    2414:	4622      	mov	r2, r4
    2416:	4621      	mov	r1, r4
    2418:	4628      	mov	r0, r5
    241a:	f7ff ff46 	bl	22aa <gf2field_mul>
    gf2field_mul(x, l, l);
    241e:	466a      	mov	r2, sp
    2420:	4669      	mov	r1, sp
    2422:	4620      	mov	r0, r4
    2424:	f7ff ff41 	bl	22aa <gf2field_mul>
    gf2field_inc(l);
    2428:	4668      	mov	r0, sp
    242a:	f7ff ff39 	bl	22a0 <gf2field_inc>
    gf2field_add(x, x, l);
    242e:	466a      	mov	r2, sp
    2430:	4621      	mov	r1, r4
    2432:	4620      	mov	r0, r4
    2434:	f7ff ff23 	bl	227e <gf2field_add>
    gf2field_mul(l, l, x);
    2438:	4622      	mov	r2, r4
    243a:	4669      	mov	r1, sp
    243c:	4668      	mov	r0, sp
    243e:	f7ff ff34 	bl	22aa <gf2field_mul>
    gf2field_add(y, y, l);
    2442:	466a      	mov	r2, sp
    2444:	4629      	mov	r1, r5
    2446:	4628      	mov	r0, r5
    2448:	f7ff ff19 	bl	227e <gf2field_add>
}
    244c:	e7d2      	b.n	23f4 <gf2point_double+0x14>

0000244e <gf2point_add>:


/* add two points together (x1, y1) := (x1, y1) + (x2, y2) */
static void gf2point_add(gf2elem_t x1, gf2elem_t y1, const gf2elem_t x2, const gf2elem_t y2)
{
    244e:	b5f0      	push	{r4, r5, r6, r7, lr}
    2450:	b099      	sub	sp, #100	@ 0x64
    2452:	4604      	mov	r4, r0
    2454:	460f      	mov	r7, r1
    2456:	4615      	mov	r5, r2
    2458:	461e      	mov	r6, r3
  if (!gf2point_is_zero(x2, y2))
    245a:	4619      	mov	r1, r3
    245c:	4610      	mov	r0, r2
    245e:	f7ff ffb4 	bl	23ca <gf2point_is_zero>
    2462:	b9c8      	cbnz	r0, 2498 <gf2point_add+0x4a>
  {
    if (gf2point_is_zero(x1, y1))
    2464:	4639      	mov	r1, r7
    2466:	4620      	mov	r0, r4
    2468:	f7ff ffaf 	bl	23ca <gf2point_is_zero>
    246c:	b970      	cbnz	r0, 248c <gf2point_add+0x3e>
    {
      gf2point_copy(x1, y1, x2, y2);
    }
    else
    {
      if (bitvec_equal(x1, x2))
    246e:	4629      	mov	r1, r5
    2470:	4620      	mov	r0, r4
    2472:	f7ff fe75 	bl	2160 <bitvec_equal>
    2476:	b1b0      	cbz	r0, 24a6 <gf2point_add+0x58>
      {
        if (bitvec_equal(y1, y2))
    2478:	4631      	mov	r1, r6
    247a:	4638      	mov	r0, r7
    247c:	f7ff fe70 	bl	2160 <bitvec_equal>
    2480:	b160      	cbz	r0, 249c <gf2point_add+0x4e>
        {
          gf2point_double(x1, y1);
    2482:	4639      	mov	r1, r7
    2484:	4620      	mov	r0, r4
    2486:	f7ff ffab 	bl	23e0 <gf2point_double>
    248a:	e005      	b.n	2498 <gf2point_add+0x4a>
      gf2point_copy(x1, y1, x2, y2);
    248c:	4633      	mov	r3, r6
    248e:	462a      	mov	r2, r5
    2490:	4639      	mov	r1, r7
    2492:	4620      	mov	r0, r4
    2494:	f7ff ff86 	bl	23a4 <gf2point_copy>
        gf2field_add(y1, y1, a);
        bitvec_copy(x1, d);
      }
    }
  }
}
    2498:	b019      	add	sp, #100	@ 0x64
    249a:	bdf0      	pop	{r4, r5, r6, r7, pc}
          gf2point_set_zero(x1, y1);
    249c:	4639      	mov	r1, r7
    249e:	4620      	mov	r0, r4
    24a0:	f7ff ff8b 	bl	23ba <gf2point_set_zero>
    24a4:	e7f8      	b.n	2498 <gf2point_add+0x4a>
        gf2field_add(a, y1, y2);
    24a6:	4632      	mov	r2, r6
    24a8:	4639      	mov	r1, r7
    24aa:	4668      	mov	r0, sp
    24ac:	f7ff fee7 	bl	227e <gf2field_add>
        gf2field_add(b, x1, x2);
    24b0:	462a      	mov	r2, r5
    24b2:	4621      	mov	r1, r4
    24b4:	a806      	add	r0, sp, #24
    24b6:	f7ff fee2 	bl	227e <gf2field_add>
        gf2field_inv(c, b);
    24ba:	a906      	add	r1, sp, #24
    24bc:	a80c      	add	r0, sp, #48	@ 0x30
    24be:	f7ff ff2f 	bl	2320 <gf2field_inv>
        gf2field_mul(c, c, a);
    24c2:	466a      	mov	r2, sp
    24c4:	a90c      	add	r1, sp, #48	@ 0x30
    24c6:	4608      	mov	r0, r1
    24c8:	f7ff feef 	bl	22aa <gf2field_mul>
        gf2field_mul(d, c, c);
    24cc:	aa0c      	add	r2, sp, #48	@ 0x30
    24ce:	4611      	mov	r1, r2
    24d0:	a812      	add	r0, sp, #72	@ 0x48
    24d2:	f7ff feea 	bl	22aa <gf2field_mul>
        gf2field_add(d, d, c);
    24d6:	aa0c      	add	r2, sp, #48	@ 0x30
    24d8:	a912      	add	r1, sp, #72	@ 0x48
    24da:	4608      	mov	r0, r1
    24dc:	f7ff fecf 	bl	227e <gf2field_add>
        gf2field_add(d, d, b);
    24e0:	aa06      	add	r2, sp, #24
    24e2:	a912      	add	r1, sp, #72	@ 0x48
    24e4:	4608      	mov	r0, r1
    24e6:	f7ff feca 	bl	227e <gf2field_add>
        gf2field_inc(d);
    24ea:	a812      	add	r0, sp, #72	@ 0x48
    24ec:	f7ff fed8 	bl	22a0 <gf2field_inc>
        gf2field_add(x1, x1, d);
    24f0:	aa12      	add	r2, sp, #72	@ 0x48
    24f2:	4621      	mov	r1, r4
    24f4:	4620      	mov	r0, r4
    24f6:	f7ff fec2 	bl	227e <gf2field_add>
        gf2field_mul(a, x1, c);
    24fa:	aa0c      	add	r2, sp, #48	@ 0x30
    24fc:	4621      	mov	r1, r4
    24fe:	4668      	mov	r0, sp
    2500:	f7ff fed3 	bl	22aa <gf2field_mul>
        gf2field_add(a, a, d);
    2504:	aa12      	add	r2, sp, #72	@ 0x48
    2506:	4669      	mov	r1, sp
    2508:	4668      	mov	r0, sp
    250a:	f7ff feb8 	bl	227e <gf2field_add>
        gf2field_add(y1, y1, a);
    250e:	466a      	mov	r2, sp
    2510:	4639      	mov	r1, r7
    2512:	4638      	mov	r0, r7
    2514:	f7ff feb3 	bl	227e <gf2field_add>
        bitvec_copy(x1, d);
    2518:	a912      	add	r1, sp, #72	@ 0x48
    251a:	4620      	mov	r0, r4
    251c:	f7ff fe04 	bl	2128 <bitvec_copy>
}
    2520:	e7ba      	b.n	2498 <gf2point_add+0x4a>

00002522 <gf2point_mul>:


#if defined(CONST_TIME) && (CONST_TIME == 0)
/* point multiplication via double-and-add algorithm */
static void gf2point_mul(gf2elem_t x, gf2elem_t y, const scalar_t exp)
{
    2522:	b5f0      	push	{r4, r5, r6, r7, lr}
    2524:	b08d      	sub	sp, #52	@ 0x34
    2526:	4606      	mov	r6, r0
    2528:	460f      	mov	r7, r1
    252a:	4615      	mov	r5, r2
  gf2elem_t tmpx, tmpy;
  int i;
  int nbits = bitvec_degree(exp);
    252c:	4610      	mov	r0, r2
    252e:	f7ff fe3c 	bl	21aa <bitvec_degree>
    2532:	4604      	mov	r4, r0

  gf2point_set_zero(tmpx, tmpy);
    2534:	4669      	mov	r1, sp
    2536:	a806      	add	r0, sp, #24
    2538:	f7ff ff3f 	bl	23ba <gf2point_set_zero>

  for (i = (nbits - 1); i >= 0; --i)
    253c:	3c01      	subs	r4, #1
    253e:	e000      	b.n	2542 <gf2point_mul+0x20>
    2540:	3c01      	subs	r4, #1
    2542:	2c00      	cmp	r4, #0
    2544:	db10      	blt.n	2568 <gf2point_mul+0x46>
  {
    gf2point_double(tmpx, tmpy);
    2546:	4669      	mov	r1, sp
    2548:	a806      	add	r0, sp, #24
    254a:	f7ff ff49 	bl	23e0 <gf2point_double>
    if (bitvec_get_bit(exp, i))
    254e:	4621      	mov	r1, r4
    2550:	4628      	mov	r0, r5
    2552:	f7ff fdd3 	bl	20fc <bitvec_get_bit>
    2556:	2800      	cmp	r0, #0
    2558:	d0f2      	beq.n	2540 <gf2point_mul+0x1e>
    {
      gf2point_add(tmpx, tmpy, x, y);
    255a:	463b      	mov	r3, r7
    255c:	4632      	mov	r2, r6
    255e:	4669      	mov	r1, sp
    2560:	a806      	add	r0, sp, #24
    2562:	f7ff ff74 	bl	244e <gf2point_add>
    2566:	e7eb      	b.n	2540 <gf2point_mul+0x1e>
    }
  }
  gf2point_copy(x, y, tmpx, tmpy);
    2568:	466b      	mov	r3, sp
    256a:	aa06      	add	r2, sp, #24
    256c:	4639      	mov	r1, r7
    256e:	4630      	mov	r0, r6
    2570:	f7ff ff18 	bl	23a4 <gf2point_copy>
}
    2574:	b00d      	add	sp, #52	@ 0x34
    2576:	bdf0      	pop	{r4, r5, r6, r7, pc}

00002578 <gf2point_on_curve>:



/* check if y^2 + x*y = x^3 + a*x^2 + coeff_b holds */
static int gf2point_on_curve(const gf2elem_t x, const gf2elem_t y)
{
    2578:	b530      	push	{r4, r5, lr}
    257a:	b08d      	sub	sp, #52	@ 0x34
    257c:	4604      	mov	r4, r0
    257e:	460d      	mov	r5, r1
  gf2elem_t a, b;

  if (gf2point_is_zero(x, y))
    2580:	f7ff ff23 	bl	23ca <gf2point_is_zero>
    2584:	b110      	cbz	r0, 258c <gf2point_on_curve+0x14>
  {
    return 1;
    2586:	2001      	movs	r0, #1
    gf2field_add(a, a, b);
    gf2field_mul(b, x, y);

    return bitvec_equal(a, b);
  }
}
    2588:	b00d      	add	sp, #52	@ 0x34
    258a:	bd30      	pop	{r4, r5, pc}
    gf2field_mul(a, x, x);
    258c:	4622      	mov	r2, r4
    258e:	4621      	mov	r1, r4
    2590:	a806      	add	r0, sp, #24
    2592:	f7ff fe8a 	bl	22aa <gf2field_mul>
    gf2field_mul(b, a, x);
    2596:	4622      	mov	r2, r4
    2598:	a906      	add	r1, sp, #24
    259a:	4668      	mov	r0, sp
    259c:	f7ff fe85 	bl	22aa <gf2field_mul>
    gf2field_add(a, a, b);
    25a0:	466a      	mov	r2, sp
    25a2:	a906      	add	r1, sp, #24
    25a4:	4608      	mov	r0, r1
    25a6:	f7ff fe6a 	bl	227e <gf2field_add>
    gf2field_add(a, a, coeff_b);
    25aa:	4a0c      	ldr	r2, [pc, #48]	@ (25dc <gf2point_on_curve+0x64>)
    25ac:	a906      	add	r1, sp, #24
    25ae:	4608      	mov	r0, r1
    25b0:	f7ff fe65 	bl	227e <gf2field_add>
    gf2field_mul(b, y, y);
    25b4:	462a      	mov	r2, r5
    25b6:	4629      	mov	r1, r5
    25b8:	4668      	mov	r0, sp
    25ba:	f7ff fe76 	bl	22aa <gf2field_mul>
    gf2field_add(a, a, b);
    25be:	466a      	mov	r2, sp
    25c0:	a906      	add	r1, sp, #24
    25c2:	4608      	mov	r0, r1
    25c4:	f7ff fe5b 	bl	227e <gf2field_add>
    gf2field_mul(b, x, y);
    25c8:	462a      	mov	r2, r5
    25ca:	4621      	mov	r1, r4
    25cc:	4668      	mov	r0, sp
    25ce:	f7ff fe6c 	bl	22aa <gf2field_mul>
    return bitvec_equal(a, b);
    25d2:	4669      	mov	r1, sp
    25d4:	a806      	add	r0, sp, #24
    25d6:	f7ff fdc3 	bl	2160 <bitvec_equal>
    25da:	e7d5      	b.n	2588 <gf2point_on_curve+0x10>
    25dc:	000035d0 	ldrdeq	r3, [r0], -r0

000025e0 <ecdh_generate_keys>:



/* NOTE: private should contain random data a-priori! */
int ecdh_generate_keys(uint8_t* public_key, uint8_t* private_key)
{
    25e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    25e2:	4606      	mov	r6, r0
    25e4:	460d      	mov	r5, r1
  /* Get copy of "base" point 'G' */
  gf2point_copy((uint32_t*)public_key, (uint32_t*)(public_key + BITVEC_NBYTES), base_x, base_y);
    25e6:	f100 0718 	add.w	r7, r0, #24
    25ea:	4a10      	ldr	r2, [pc, #64]	@ (262c <ecdh_generate_keys+0x4c>)
    25ec:	f102 0330 	add.w	r3, r2, #48	@ 0x30
    25f0:	3248      	adds	r2, #72	@ 0x48
    25f2:	4639      	mov	r1, r7
    25f4:	f7ff fed6 	bl	23a4 <gf2point_copy>

  /* Abort key generation if random number is too small */
  if (bitvec_degree((uint32_t*)private_key) < (CURVE_DEGREE / 2))
    25f8:	4628      	mov	r0, r5
    25fa:	f7ff fdd6 	bl	21aa <bitvec_degree>
    25fe:	2850      	cmp	r0, #80	@ 0x50
    2600:	dd12      	ble.n	2628 <ecdh_generate_keys+0x48>
    return 0;
  }
  else
  {
    /* Clear bits > CURVE_DEGREE in highest word to satisfy constraint 1 <= exp < n. */
    int nbits = bitvec_degree(base_order);
    2602:	480b      	ldr	r0, [pc, #44]	@ (2630 <ecdh_generate_keys+0x50>)
    2604:	f7ff fdd1 	bl	21aa <bitvec_degree>
    int i;

    for (i = (nbits - 1); i < (BITVEC_NWORDS * 32); ++i)
    2608:	1e44      	subs	r4, r0, #1
    260a:	e004      	b.n	2616 <ecdh_generate_keys+0x36>
    {
      bitvec_clr_bit((uint32_t*)private_key, i);
    260c:	4621      	mov	r1, r4
    260e:	4628      	mov	r0, r5
    2610:	f7ff fd7d 	bl	210e <bitvec_clr_bit>
    for (i = (nbits - 1); i < (BITVEC_NWORDS * 32); ++i)
    2614:	3401      	adds	r4, #1
    2616:	2cbf      	cmp	r4, #191	@ 0xbf
    2618:	ddf8      	ble.n	260c <ecdh_generate_keys+0x2c>
    }

    /* Multiply base-point with scalar (private-key) */
    gf2point_mul((uint32_t*)public_key, (uint32_t*)(public_key + BITVEC_NBYTES), (uint32_t*)private_key);
    261a:	462a      	mov	r2, r5
    261c:	4639      	mov	r1, r7
    261e:	4630      	mov	r0, r6
    2620:	f7ff ff7f 	bl	2522 <gf2point_mul>

    return 1;
    2624:	2001      	movs	r0, #1
  }
}
    2626:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return 0;
    2628:	2000      	movs	r0, #0
    262a:	e7fc      	b.n	2626 <ecdh_generate_keys+0x46>
    262c:	000035b8 			@ <UNDEFINED> instruction: 0x000035b8
    2630:	00003618 	andeq	r3, r0, r8, lsl r6

00002634 <ecdh_shared_secret>:



int ecdh_shared_secret(const uint8_t* private_key, const uint8_t* others_pub, uint8_t* output)
{
    2634:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2636:	4606      	mov	r6, r0
    2638:	460c      	mov	r4, r1
    263a:	4615      	mov	r5, r2
  /* Do some basic validation of other party's public key */
  if (    !gf2point_is_zero ((uint32_t*)others_pub, (uint32_t*)(others_pub + BITVEC_NBYTES))
    263c:	f101 0718 	add.w	r7, r1, #24
    2640:	4639      	mov	r1, r7
    2642:	4620      	mov	r0, r4
    2644:	f7ff fec1 	bl	23ca <gf2point_is_zero>
    2648:	b108      	cbz	r0, 264e <ecdh_shared_secret+0x1a>
    
    return 1;
  }
  else
  {
    return 0;
    264a:	2000      	movs	r0, #0
  }
}
    264c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
       &&  gf2point_on_curve((uint32_t*)others_pub, (uint32_t*)(others_pub + BITVEC_NBYTES)) )
    264e:	4639      	mov	r1, r7
    2650:	4620      	mov	r0, r4
    2652:	f7ff ff91 	bl	2578 <gf2point_on_curve>
    2656:	2800      	cmp	r0, #0
    2658:	d0f7      	beq.n	264a <ecdh_shared_secret+0x16>
    for (i = 0; i < (BITVEC_NBYTES * 2); ++i)
    265a:	2300      	movs	r3, #0
    265c:	e004      	b.n	2668 <ecdh_shared_secret+0x34>
      output[i] = others_pub[i];
    265e:	f814 c003 	ldrb.w	ip, [r4, r3]
    2662:	f805 c003 	strb.w	ip, [r5, r3]
    for (i = 0; i < (BITVEC_NBYTES * 2); ++i)
    2666:	3301      	adds	r3, #1
    2668:	2b2f      	cmp	r3, #47	@ 0x2f
    266a:	d9f8      	bls.n	265e <ecdh_shared_secret+0x2a>
    gf2point_mul((uint32_t*)output,(uint32_t*)(output + BITVEC_NBYTES), (const uint32_t*)private_key);
    266c:	4632      	mov	r2, r6
    266e:	f105 0118 	add.w	r1, r5, #24
    2672:	4628      	mov	r0, r5
    2674:	f7ff ff55 	bl	2522 <gf2point_mul>
    return 1;
    2678:	2001      	movs	r0, #1
    267a:	e7e7      	b.n	264c <ecdh_shared_secret+0x18>

0000267c <atoi>:
 * limitations under the License.
 **/

#include "a2i.h"

int atoi(const char* str) {
    267c:	4601      	mov	r1, r0
  int res = 0;
  for (int i = 0; str[i] != '\0'; ++i) {
    267e:	2200      	movs	r2, #0
  int res = 0;
    2680:	4610      	mov	r0, r2
  for (int i = 0; str[i] != '\0'; ++i) {
    2682:	e006      	b.n	2692 <atoi+0x16>
    res = res * 10 + str[i] - '0';
    2684:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    2688:	eb03 0340 	add.w	r3, r3, r0, lsl #1
    268c:	f1a3 0030 	sub.w	r0, r3, #48	@ 0x30
  for (int i = 0; str[i] != '\0'; ++i) {
    2690:	3201      	adds	r2, #1
    2692:	5c8b      	ldrb	r3, [r1, r2]
    2694:	2b00      	cmp	r3, #0
    2696:	d1f5      	bne.n	2684 <atoi+0x8>
  }
  return res;
}
    2698:	4770      	bx	lr

0000269a <atoh>:

uint32_t atoh(const char* str) {
    269a:	4684      	mov	ip, r0
  uint32_t hex = 0;
  uint32_t value = 0;

  for (uint32_t i = 0; str[i] != '\0'; i++) {
    269c:	2100      	movs	r1, #0
  uint32_t hex = 0;
    269e:	4608      	mov	r0, r1
  for (uint32_t i = 0; str[i] != '\0'; i++) {
    26a0:	e008      	b.n	26b4 <atoh+0x1a>
    if (str[i] >= '0' && str[i] <= '9') {
      value = str[i] - '0';
    } else if (str[i] >= 'a' && str[i] <= 'f') {
    26a2:	f1a3 0261 	sub.w	r2, r3, #97	@ 0x61
    26a6:	b2d2      	uxtb	r2, r2
    26a8:	2a05      	cmp	r2, #5
    26aa:	d80d      	bhi.n	26c8 <atoh+0x2e>
      value = str[i] - 'a' + 10;
    26ac:	3b57      	subs	r3, #87	@ 0x57
      continue;
    }

    // make space for the new nibble on the right
    hex = hex << 4;
    hex |= value;
    26ae:	ea43 1000 	orr.w	r0, r3, r0, lsl #4
  for (uint32_t i = 0; str[i] != '\0'; i++) {
    26b2:	3101      	adds	r1, #1
    26b4:	f81c 3001 	ldrb.w	r3, [ip, r1]
    26b8:	b16b      	cbz	r3, 26d6 <atoh+0x3c>
    if (str[i] >= '0' && str[i] <= '9') {
    26ba:	f1a3 0230 	sub.w	r2, r3, #48	@ 0x30
    26be:	b2d2      	uxtb	r2, r2
    26c0:	2a09      	cmp	r2, #9
    26c2:	d8ee      	bhi.n	26a2 <atoh+0x8>
      value = str[i] - '0';
    26c4:	3b30      	subs	r3, #48	@ 0x30
    26c6:	e7f2      	b.n	26ae <atoh+0x14>
    } else if (str[i] >= 'A' && str[i] <= 'F') {
    26c8:	f1a3 0241 	sub.w	r2, r3, #65	@ 0x41
    26cc:	b2d2      	uxtb	r2, r2
    26ce:	2a05      	cmp	r2, #5
    26d0:	d8ef      	bhi.n	26b2 <atoh+0x18>
      value = str[i] - 'A' + 10;
    26d2:	3b37      	subs	r3, #55	@ 0x37
    26d4:	e7eb      	b.n	26ae <atoh+0x14>
  }

  return hex;
}
    26d6:	4770      	bx	lr

000026d8 <memlog_init>:

void memlog_init(uint8_t *addr, uint32_t size, mode_t mode) {
  selected_mode = mode;
    26d8:	4b0e      	ldr	r3, [pc, #56]	@ (2714 <memlog_init+0x3c>)
    26da:	701a      	strb	r2, [r3, #0]

  if (selected_mode == NONE) {
    26dc:	b1ca      	cbz	r2, 2712 <memlog_init+0x3a>
void memlog_init(uint8_t *addr, uint32_t size, mode_t mode) {
    26de:	b570      	push	{r4, r5, r6, lr}
    return;
  }

  out_buf_rgn.addr = addr;
    26e0:	6058      	str	r0, [r3, #4]
  out_buf_rgn.size = size / 2;
    26e2:	084c      	lsrs	r4, r1, #1
    26e4:	609c      	str	r4, [r3, #8]
  out_buf_rgn.curr_index = 0;
    26e6:	2500      	movs	r5, #0
    26e8:	60dd      	str	r5, [r3, #12]

  inp_buf_rgn.addr = addr + size / 2;
    26ea:	1906      	adds	r6, r0, r4
    26ec:	611e      	str	r6, [r3, #16]
  inp_buf_rgn.size = size / 2;
    26ee:	615c      	str	r4, [r3, #20]
  inp_buf_rgn.curr_index = 0;
    26f0:	619d      	str	r5, [r3, #24]

  if (!(selected_mode & INP)) {
    26f2:	f012 0f01 	tst.w	r2, #1
    26f6:	d105      	bne.n	2704 <memlog_init+0x2c>
    // No input, use the extra memory for output.

    out_buf_rgn.size = size;
    26f8:	6099      	str	r1, [r3, #8]

    inp_buf_rgn.addr = addr;
    inp_buf_rgn.size = size;
  }

  memset(addr, 0, size);
    26fa:	460a      	mov	r2, r1
    26fc:	2100      	movs	r1, #0
    26fe:	f000 f869 	bl	27d4 <memset>
}
    2702:	bd70      	pop	{r4, r5, r6, pc}
  } else if (!(selected_mode & OUT)) {
    2704:	f012 0f02 	tst.w	r2, #2
    2708:	d1f7      	bne.n	26fa <memlog_init+0x22>
    inp_buf_rgn.addr = addr;
    270a:	4b02      	ldr	r3, [pc, #8]	@ (2714 <memlog_init+0x3c>)
    270c:	6118      	str	r0, [r3, #16]
    inp_buf_rgn.size = size;
    270e:	6159      	str	r1, [r3, #20]
    2710:	e7f3      	b.n	26fa <memlog_init+0x22>
    2712:	4770      	bx	lr
    2714:	20000324 	andcs	r0, r0, r4, lsr #6

00002718 <memlog_getc>:

int memlog_getc() {
  if (!(selected_mode & INP)) {
    2718:	4b0e      	ldr	r3, [pc, #56]	@ (2754 <memlog_getc+0x3c>)
    271a:	781b      	ldrb	r3, [r3, #0]
    271c:	f013 0f01 	tst.w	r3, #1
    2720:	d012      	beq.n	2748 <memlog_getc+0x30>
    return -1;
  }

  if (inp_buf_rgn.addr[inp_buf_rgn.curr_index] == 0) {
    2722:	4b0c      	ldr	r3, [pc, #48]	@ (2754 <memlog_getc+0x3c>)
    2724:	691a      	ldr	r2, [r3, #16]
    2726:	699b      	ldr	r3, [r3, #24]
    2728:	5cd1      	ldrb	r1, [r2, r3]
    272a:	b181      	cbz	r1, 274e <memlog_getc+0x36>
    return -1;
  }

  int val = inp_buf_rgn.addr[inp_buf_rgn.curr_index];
    272c:	5cd0      	ldrb	r0, [r2, r3]
    272e:	b2c0      	uxtb	r0, r0
  inp_buf_rgn.addr[inp_buf_rgn.curr_index] = 0;
    2730:	2100      	movs	r1, #0
    2732:	54d1      	strb	r1, [r2, r3]
  inp_buf_rgn.curr_index++;
    2734:	3301      	adds	r3, #1
    2736:	4a07      	ldr	r2, [pc, #28]	@ (2754 <memlog_getc+0x3c>)
    2738:	6193      	str	r3, [r2, #24]

  if (inp_buf_rgn.curr_index == inp_buf_rgn.size) {
    273a:	6952      	ldr	r2, [r2, #20]
    273c:	4293      	cmp	r3, r2
    273e:	d000      	beq.n	2742 <memlog_getc+0x2a>
    inp_buf_rgn.curr_index = 0;
  }

  return val;
}
    2740:	4770      	bx	lr
    inp_buf_rgn.curr_index = 0;
    2742:	4b04      	ldr	r3, [pc, #16]	@ (2754 <memlog_getc+0x3c>)
    2744:	6199      	str	r1, [r3, #24]
    2746:	4770      	bx	lr
    return -1;
    2748:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    274c:	4770      	bx	lr
    return -1;
    274e:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    2752:	e7f5      	b.n	2740 <memlog_getc+0x28>
    2754:	20000324 	andcs	r0, r0, r4, lsr #6

00002758 <memlog_putc>:

void memlog_putc(char c) {
  if (!(selected_mode & OUT) || c == 0) {
    2758:	4b09      	ldr	r3, [pc, #36]	@ (2780 <memlog_putc+0x28>)
    275a:	781b      	ldrb	r3, [r3, #0]
    275c:	f013 0f02 	tst.w	r3, #2
    2760:	d009      	beq.n	2776 <memlog_putc+0x1e>
    2762:	b140      	cbz	r0, 2776 <memlog_putc+0x1e>
    return;
  }

  out_buf_rgn.addr[out_buf_rgn.curr_index] = (uint8_t) c;
    2764:	4a06      	ldr	r2, [pc, #24]	@ (2780 <memlog_putc+0x28>)
    2766:	6851      	ldr	r1, [r2, #4]
    2768:	68d3      	ldr	r3, [r2, #12]
    276a:	54c8      	strb	r0, [r1, r3]
  out_buf_rgn.curr_index++;
    276c:	3301      	adds	r3, #1
    276e:	60d3      	str	r3, [r2, #12]

  if (out_buf_rgn.curr_index == out_buf_rgn.size) {
    2770:	6892      	ldr	r2, [r2, #8]
    2772:	4293      	cmp	r3, r2
    2774:	d000      	beq.n	2778 <memlog_putc+0x20>
    out_buf_rgn.curr_index = 0;
  }
}
    2776:	4770      	bx	lr
    out_buf_rgn.curr_index = 0;
    2778:	4b01      	ldr	r3, [pc, #4]	@ (2780 <memlog_putc+0x28>)
    277a:	2200      	movs	r2, #0
    277c:	60da      	str	r2, [r3, #12]
    277e:	e7fa      	b.n	2776 <memlog_putc+0x1e>
    2780:	20000324 	andcs	r0, r0, r4, lsr #6

00002784 <strlen>:
 * limitations under the License.
 **/

#include "string.h"

size_t strlen(const char *str) {
    2784:	4602      	mov	r2, r0
  size_t len = 0;
    2786:	2000      	movs	r0, #0
  while (str[len]) {
    2788:	e000      	b.n	278c <strlen+0x8>
    len++;
    278a:	3001      	adds	r0, #1
  while (str[len]) {
    278c:	5c13      	ldrb	r3, [r2, r0]
    278e:	2b00      	cmp	r3, #0
    2790:	d1fb      	bne.n	278a <strlen+0x6>
  }
  return len;
}
    2792:	4770      	bx	lr

00002794 <strcmp>:

int strcmp(const char *str1, const char *str2) {
  while (*str1 && (*str1 == *str2)) {
    2794:	e001      	b.n	279a <strcmp+0x6>
    str1++;
    2796:	3001      	adds	r0, #1
    str2++;
    2798:	3101      	adds	r1, #1
  while (*str1 && (*str1 == *str2)) {
    279a:	7803      	ldrb	r3, [r0, #0]
    279c:	b113      	cbz	r3, 27a4 <strcmp+0x10>
    279e:	780a      	ldrb	r2, [r1, #0]
    27a0:	4293      	cmp	r3, r2
    27a2:	d0f8      	beq.n	2796 <strcmp+0x2>
  }
  return *str1 - *str2;
    27a4:	7808      	ldrb	r0, [r1, #0]
}
    27a6:	1a18      	subs	r0, r3, r0
    27a8:	4770      	bx	lr

000027aa <strcpy>:

char *strcpy(char *str1, const char *str2) {
  while (*str2) {
    27aa:	e002      	b.n	27b2 <strcpy+0x8>
    *(str1++) = *(str2++);
    27ac:	3101      	adds	r1, #1
    27ae:	f800 3b01 	strb.w	r3, [r0], #1
  while (*str2) {
    27b2:	780b      	ldrb	r3, [r1, #0]
    27b4:	2b00      	cmp	r3, #0
    27b6:	d1f9      	bne.n	27ac <strcpy+0x2>
  }
  *str1 = '\0';
    27b8:	7003      	strb	r3, [r0, #0]
  return 0;
}
    27ba:	4618      	mov	r0, r3
    27bc:	4770      	bx	lr

000027be <memcpy>:

void *memcpy(void *dest, const void *src, size_t size) {
  size_t i;
  char *src_char = (char *)src;
  char *dest_char = (char *)dest;
  for (i = 0; i < size; i++) {
    27be:	2300      	movs	r3, #0
    27c0:	e004      	b.n	27cc <memcpy+0xe>
    dest_char[i] = src_char[i];
    27c2:	f811 c003 	ldrb.w	ip, [r1, r3]
    27c6:	f800 c003 	strb.w	ip, [r0, r3]
  for (i = 0; i < size; i++) {
    27ca:	3301      	adds	r3, #1
    27cc:	4293      	cmp	r3, r2
    27ce:	d3f8      	bcc.n	27c2 <memcpy+0x4>
  }
  return 0;
}
    27d0:	2000      	movs	r0, #0
    27d2:	4770      	bx	lr

000027d4 <memset>:

void *memset(void *dest, int val, size_t size) {
  size_t i;
  char *dest_char = (char *)dest;
  for (i = 0; i < size; i++) {
    27d4:	2300      	movs	r3, #0
    27d6:	e001      	b.n	27dc <memset+0x8>
    dest_char[i] = val;
    27d8:	54c1      	strb	r1, [r0, r3]
  for (i = 0; i < size; i++) {
    27da:	3301      	adds	r3, #1
    27dc:	4293      	cmp	r3, r2
    27de:	d3fb      	bcc.n	27d8 <memset+0x4>
  }

  return 0;
}
    27e0:	2000      	movs	r0, #0
    27e2:	4770      	bx	lr

000027e4 <reset_handler>:
    27e4:	f7fe fbb4 	bl	f50 <prompt>
    27e8:	f7ff fffe 	bl	27e8 <reset_handler+0x4>

Disassembly of section .rodata:

0000283c <_varcar_mesg-0x4>:
    283c:	00000000 	andeq	r0, r0, r0

00002840 <_varcar_mesg>:
    2840:	00002a0c 	andeq	r2, r0, ip, lsl #20
    2844:	00002a18 	andeq	r2, r0, r8, lsl sl
    2848:	000003c1 	andeq	r0, r0, r1, asr #7

0000284c <_varaes_test>:

// ADD_CMD(command, description, function name);
    284c:	00002b00 	andeq	r2, r0, r0, lsl #22
    2850:	00002b0c 	andeq	r2, r0, ip, lsl #22
    2854:	0000062d 	andeq	r0, r0, sp, lsr #12

00002858 <_varpair>:

// ADD_CMD(keyword, description, function name);
ADD_CMD(pair, "Starts the pairing process with a car.", pair);
    2858:	00002b58 	andeq	r2, r0, r8, asr fp
    285c:	00002b60 	andeq	r2, r0, r0, ror #22
    2860:	000006d1 	ldrdeq	r0, [r0], -r1

00002864 <_vardecode64>:

// ADD_CMD(command, description, function name);
ADD_CMD(encode64, "Base64 encodes a string", encode64);
    2864:	00002c64 	andeq	r2, r0, r4, ror #24
    2868:	00002c70 	andeq	r2, r0, r0, ror ip
    286c:	0000073d 	andeq	r0, r0, sp, lsr r7

00002870 <_varencode64>:
ADD_CMD(encode64, "Base64 encodes a string", encode64);
    2870:	00002c88 	andeq	r2, r0, r8, lsl #25
    2874:	00002c94 	muleq	r0, r4, ip
    2878:	000006ed 	andeq	r0, r0, sp, ror #13

0000287c <_varecdh_test>:

// ADD_CMD(command, description, function name);
ADD_CMD(ecdh_test, "Tests ECDH functions", ecdh_test);
    287c:	00002d58 	andeq	r2, r0, r8, asr sp
    2880:	00002d64 	andeq	r2, r0, r4, ror #26
    2884:	00000799 	muleq	r0, r9, r7

00002888 <_varsend_ping>:

// ADD_CMD(command, description, function name);
ADD_CMD(ping, "Pings the other board", send_ping);
    2888:	00002da0 	andeq	r2, r0, r0, lsr #27
    288c:	00002da8 	andeq	r2, r0, r8, lsr #27
    2890:	000008a5 	andeq	r0, r0, r5, lsr #17

00002894 <_varsha256_test>:

// ADD_CMD(keyword, description, function name);
    2894:	00002e68 	andeq	r2, r0, r8, ror #28
    2898:	00002e74 	andeq	r2, r0, r4, ror lr
    289c:	000008c1 	andeq	r0, r0, r1, asr #17

000028a0 <_varcmd_exec_status>:

// DO NOT REMOVE THESE
AUTO_CMD(version, "Prints details of the build", build_info);
ADD_CMD(help, "Prints all available commands", help);
ADD_CMD(status, "Returns exit status of last executed command",
    28a0:	00002f60 	andeq	r2, r0, r0, ror #30
    28a4:	00002f68 	andeq	r2, r0, r8, ror #30
    28a8:	00000a65 	andeq	r0, r0, r5, ror #20

000028ac <_varhelp>:
ADD_CMD(help, "Prints all available commands", help);
    28ac:	00002f98 	muleq	r0, r8, pc	@ <UNPREDICTABLE>
    28b0:	00002fa0 	andeq	r2, r0, r0, lsr #31
    28b4:	00000aed 	andeq	r0, r0, sp, ror #21

000028b8 <_varshow_history>:
ADD_CMD(history, "Show command history", show_history);
    28b8:	00002fe4 	andeq	r2, r0, r4, ror #31
    28bc:	00002fec 	andeq	r2, r0, ip, ror #31
    28c0:	00000a25 	andeq	r0, r0, r5, lsr #20

000028c4 <_varread_mem>:
ADD_CMD(rb, "reads a bit from memory location", r32_bit);
#endif //SHELL_NO_BIT_UTILS

ADD_CMD(r32, "reads a 32 bit memory location", r32);
ADD_CMD(w32, "writes a 32 bit value to a memory location", w32);
ADD_CMD(read, "Reads number of bytes from memory", read_mem);
    28c4:	000032e0 	andeq	r3, r0, r0, ror #5
    28c8:	000032e8 	andeq	r3, r0, r8, ror #5
    28cc:	00001a01 	andeq	r1, r0, r1, lsl #20

000028d0 <_varw32>:
ADD_CMD(w32, "writes a 32 bit value to a memory location", w32);
    28d0:	0000330c 	andeq	r3, r0, ip, lsl #6
    28d4:	00003310 	andeq	r3, r0, r0, lsl r3
    28d8:	000019d1 	ldrdeq	r1, [r0], -r1	@ <UNPREDICTABLE>

000028dc <_varr32>:
ADD_CMD(r32, "reads a 32 bit memory location", r32);
    28dc:	0000333c 	andeq	r3, r0, ip, lsr r3
    28e0:	00003340 	andeq	r3, r0, r0, asr #6
    28e4:	000019a1 	andeq	r1, r0, r1, lsr #19

000028e8 <_varr32_bit>:
ADD_CMD(rb, "reads a bit from memory location", r32_bit);
    28e8:	00003360 	andeq	r3, r0, r0, ror #6
    28ec:	00003364 	andeq	r3, r0, r4, ror #6
    28f0:	00001ab1 			@ <UNDEFINED> instruction: 0x00001ab1

000028f4 <_varw32_bit>:
ADD_CMD(wb, "write a bit to memory location", w32_bit);
    28f4:	00003388 	andeq	r3, r0, r8, lsl #7
    28f8:	0000338c 	andeq	r3, r0, ip, lsl #7
    28fc:	00001a49 	andeq	r1, r0, r9, asr #20

00002900 <_varbuild_info>:
AUTO_CMD(version, "Prints details of the build", build_info);
    2900:	00002fc0 	andeq	r2, r0, r0, asr #31
    2904:	00002fc8 	andeq	r2, r0, r8, asr #31
    2908:	00000a81 	andeq	r0, r0, r1, lsl #21

0000290c <cmd_end_>:
	...
    2918:	65636552 	strbvs	r6, [r3, #-1362]!	@ 0xfffffaae
    291c:	64657669 	strbtvs	r7, [r5], #-1641	@ 0xfffff997
    2920:	6d206120 	stfvss	f6, [r0, #-128]!	@ 0xffffff80
    2924:	61737365 	cmnvs	r3, r5, ror #6
    2928:	66206567 	strtvs	r6, [r0], -r7, ror #10
    292c:	206d6f72 	rsbcs	r6, sp, r2, ror pc
    2930:	20656874 	rsbcs	r6, r5, r4, ror r8
    2934:	3a726163 	bcc	1c9aec8 <__ROM_SIZE__+0x1c5aec8>
    2938:	00000000 	andeq	r0, r0, r0
    293c:	00732520 	rsbseq	r2, r3, r0, lsr #10
    2940:	474e4950 	smlsldmi	r4, lr, r0, r9
    2944:	5045525f 	subpl	r5, r5, pc, asr r2
    2948:	0000594c 	andeq	r5, r0, ip, asr #18
    294c:	20746f47 	rsbscs	r6, r4, r7, asr #30
    2950:	69702061 	ldmdbvs	r0!, {r0, r5, r6, sp}^
    2954:	7220676e 	eorvc	r6, r0, #28835840	@ 0x1b80000
    2958:	796c7065 	stmdbvc	ip!, {r0, r2, r5, r6, ip, sp, lr}^
    295c:	00000a2e 	andeq	r0, r0, lr, lsr #20
    2960:	42534541 	subsmi	r4, r3, #272629760	@ 0x10400000
    2964:	00003436 	andeq	r3, r0, r6, lsr r4
    2968:	6f636544 	svcvs	0x00636544
    296c:	2f646564 	svccs	0x00646564
    2970:	72636564 	rsbvc	r6, r3, #100, 10	@ 0x19000000
    2974:	65747079 	ldrbvs	r7, [r4, #-121]!	@ 0xffffff87
    2978:	73612064 	cmnvc	r1, #100	@ 0x64
    297c:	0a732520 	beq	1ccbe04 <__ROM_SIZE__+0x1c8be04>
    2980:	00000000 	andeq	r0, r0, r0
    2984:	7373694d 	cmnvc	r3, #1261568	@ 0x134000
    2988:	20676e69 	rsbcs	r6, r7, r9, ror #28
    298c:	42534541 	subsmi	r4, r3, #272629760	@ 0x10400000
    2990:	65203436 	strvs	r3, [r0, #-1078]!	@ 0xfffffbca
    2994:	646f636e 	strbtvs	r6, [pc], #-878	@ 299c <cmd_end_+0x90>
    2998:	6d206465 	cfstrsvs	mvf6, [r0, #-404]!	@ 0xfffffe6c
    299c:	61737365 	cmnvs	r3, r5, ror #6
    29a0:	000a6567 	andeq	r6, sl, r7, ror #10
    29a4:	00343642 	eorseq	r3, r4, r2, asr #12
    29a8:	6f636544 	svcvs	0x00636544
    29ac:	676e6964 	strbvs	r6, [lr, -r4, ror #18]!
    29b0:	73614220 	cmnvc	r1, #32, 4
    29b4:	0a343665 	beq	d10350 <__ROM_SIZE__+0xcd0350>
    29b8:	00000000 	andeq	r0, r0, r0
    29bc:	6f636544 	svcvs	0x00636544
    29c0:	20646564 	rsbcs	r6, r4, r4, ror #10
    29c4:	25207361 	strcs	r7, [r0, #-865]!	@ 0xfffffc9f
    29c8:	00000073 	andeq	r0, r0, r3, ror r0
    29cc:	7373694d 	cmnvc	r3, #1261568	@ 0x134000
    29d0:	20676e69 	rsbcs	r6, r7, r9, ror #28
    29d4:	65736142 	ldrbvs	r6, [r3, #-322]!	@ 0xfffffebe
    29d8:	65203436 	strvs	r3, [r0, #-1078]!	@ 0xfffffbca
    29dc:	646f636e 	strbtvs	r6, [pc], #-878	@ 29e4 <cmd_end_+0xd8>
    29e0:	6d206465 	cfstrsvs	mvf6, [r0, #-404]!	@ 0xfffffe6c
    29e4:	61737365 	cmnvs	r3, r5, ror #6
    29e8:	000a6567 	andeq	r6, sl, r7, ror #10
    29ec:	6e646944 	vnmulvs.f16	s13, s8, s8	@ <UNPREDICTABLE>
    29f0:	6b207427 	blvs	81fa94 <__ROM_SIZE__+0x7dfa94>
    29f4:	20776f6e 	rsbscs	r6, r7, lr, ror #30
    29f8:	20776f68 	rsbscs	r6, r7, r8, ror #30
    29fc:	68206f74 	stmdavs	r0!, {r2, r4, r5, r6, r8, r9, sl, fp, sp, lr}
    2a00:	6c646e61 	stclvs	14, cr6, [r4], #-388	@ 0xfffffe7c
    2a04:	73252065 			@ <UNDEFINED> instruction: 0x73252065
    2a08:	0000000a 	andeq	r0, r0, sl
    2a0c:	5f524143 	svcpl	0x00524143
    2a10:	4753454d 	ldrbmi	r4, [r3, -sp, asr #10]
    2a14:	00000000 	andeq	r0, r0, r0
    2a18:	636f7250 	cmnvs	pc, #80, 4
    2a1c:	65737365 	ldrbvs	r7, [r3, #-869]!	@ 0xfffffc9b
    2a20:	656d2073 	strbvs	r2, [sp, #-115]!	@ 0xffffff8d
    2a24:	67617373 			@ <UNDEFINED> instruction: 0x67617373
    2a28:	66207365 	strtvs	r7, [r0], -r5, ror #6
    2a2c:	206d6f72 	rsbcs	r6, sp, r2, ror pc
    2a30:	20656874 	rsbcs	r6, r5, r4, ror r8
    2a34:	00726163 	rsbseq	r6, r2, r3, ror #2
    2a38:	69616c50 	stmdbvs	r1!, {r4, r6, sl, fp, sp, lr}^
    2a3c:	7865746e 	stmdavc	r5!, {r1, r2, r3, r5, r6, sl, ip, sp, lr}^
    2a40:	73692074 	cmnvc	r9, #116	@ 0x74
    2a44:	0a732520 	beq	1ccbecc <__ROM_SIZE__+0x1c8becc>
    2a48:	00000000 	andeq	r0, r0, r0
    2a4c:	72636e45 	rsbvc	r6, r3, #1104	@ 0x450
    2a50:	65747079 	ldrbvs	r7, [r4, #-121]!	@ 0xffffff87
    2a54:	6e652f64 	cdpvs	15, 6, cr2, cr5, cr4, {3}
    2a58:	65646f63 	strbvs	r6, [r4, #-3939]!	@ 0xfffff09d
    2a5c:	73692064 	cmnvc	r9, #100	@ 0x64
    2a60:	0a732520 	beq	1ccbee8 <__ROM_SIZE__+0x1c8bee8>
    2a64:	00000000 	andeq	r0, r0, r0
    2a68:	5f424f46 	svcpl	0x00424f46
    2a6c:	4753454d 	ldrbmi	r4, [r3, -sp, asr #10]
    2a70:	53454120 	movtpl	r4, #20768	@ 0x5120
    2a74:	20343642 	eorscs	r3, r4, r2, asr #12
    2a78:	000a7325 	andeq	r7, sl, r5, lsr #6
    2a7c:	74736554 	ldrbtvc	r6, [r3], #-1364	@ 0xfffffaac
    2a80:	65687420 	strbvs	r7, [r8, #-1056]!	@ 0xfffffbe0
    2a84:	73656d20 	cmnvc	r5, #32, 26	@ 0x800
    2a88:	61682067 	cmnvs	r8, r7, rrx
    2a8c:	656c646e 	strbvs	r6, [ip, #-1134]!	@ 0xfffffb92
    2a90:	69772072 	ldmdbvs	r7!, {r1, r4, r5, r6, sp}^
    2a94:	43206874 			@ <UNDEFINED> instruction: 0x43206874
    2a98:	4d5f5241 	lfmmi	f5, 2, [pc, #-260]	@ 299c <cmd_end_+0x90>
    2a9c:	20475345 	subcs	r5, r7, r5, asr #6
    2aa0:	42534541 	subsmi	r4, r3, #272629760	@ 0x10400000
    2aa4:	25203436 	strcs	r3, [r0, #-1078]!	@ 0xfffffbca
    2aa8:	00000a73 	andeq	r0, r0, r3, ror sl
    2aac:	65746641 	ldrbvs	r6, [r4, #-1601]!	@ 0xfffff9bf
    2ab0:	6e652072 	mcrvs	0, 3, r2, cr5, cr2, {3}
    2ab4:	70797263 	rsbsvc	r7, r9, r3, ror #4
    2ab8:	676e6974 			@ <UNDEFINED> instruction: 0x676e6974
    2abc:	6e653e2d 	cdpvs	14, 6, cr3, cr5, cr13, {1}
    2ac0:	69646f63 	stmdbvs	r4!, {r0, r1, r5, r6, r8, r9, sl, fp, sp, lr}^
    2ac4:	3e2d676e 	cdpcc	7, 2, cr6, cr13, cr14, {3}
    2ac8:	6f636564 	svcvs	0x00636564
    2acc:	676e6964 	strbvs	r6, [lr, -r4, ror #18]!
    2ad0:	65643e2d 	strbvs	r3, [r4, #-3629]!	@ 0xfffff1d3
    2ad4:	70797263 	rsbsvc	r7, r9, r3, ror #4
    2ad8:	676e6974 			@ <UNDEFINED> instruction: 0x676e6974
    2adc:	20657720 	rsbcs	r7, r5, r0, lsr #14
    2ae0:	6f636572 	svcvs	0x00636572
    2ae4:	20726576 	rsbscs	r6, r2, r6, ror r5
    2ae8:	000a7325 	andeq	r7, sl, r5, lsr #6
    2aec:	33323130 	teqcc	r2, #48, 2
    2af0:	37363534 			@ <UNDEFINED> instruction: 0x37363534
    2af4:	62613938 	rsbvs	r3, r1, #56, 18	@ 0xe0000
    2af8:	66656463 	strbtvs	r6, [r5], -r3, ror #8
    2afc:	00000000 	andeq	r0, r0, r0
    2b00:	5f736561 	svcpl	0x00736561
    2b04:	74736574 	ldrbtvc	r6, [r3], #-1396	@ 0xfffffa8c
    2b08:	00000000 	andeq	r0, r0, r0
    2b0c:	74736554 	ldrbtvc	r6, [r3], #-1364	@ 0xfffffaac
    2b10:	45412073 	strbmi	r2, [r1, #-115]	@ 0xffffff8d
    2b14:	61422f53 	cmpvs	r2, r3, asr pc
    2b18:	34366573 	ldrtcc	r6, [r6], #-1395	@ 0xfffffa8d
    2b1c:	706d6920 	rsbvc	r6, sp, r0, lsr #18
    2b20:	656d656c 	strbvs	r6, [sp, #-1388]!	@ 0xfffffa94
    2b24:	7461746e 	strbtvc	r7, [r1], #-1134	@ 0xfffffb92
    2b28:	006e6f69 	rsbeq	r6, lr, r9, ror #30
    2b2c:	646e6553 	strbtvs	r6, [lr], #-1363	@ 0xfffffaad
    2b30:	20676e69 	rsbcs	r6, r7, r9, ror #28
    2b34:	61702061 	cmnvs	r0, r1, rrx
    2b38:	72207269 	eorvc	r7, r0, #-1879048186	@ 0x90000006
    2b3c:	65757165 	ldrbvs	r7, [r5, #-357]!	@ 0xfffffe9b
    2b40:	0a2e7473 	beq	b9fd14 <__ROM_SIZE__+0xb5fd14>
    2b44:	00000000 	andeq	r0, r0, r0
    2b48:	5f424f46 	svcpl	0x00424f46
    2b4c:	4753454d 	ldrbmi	r4, [r3, -sp, asr #10]
    2b50:	49415020 	stmdbmi	r1, {r5, ip, lr}^
    2b54:	00000a52 	andeq	r0, r0, r2, asr sl
    2b58:	72696170 	rsbvc	r6, r9, #112, 2
    2b5c:	00000000 	andeq	r0, r0, r0
    2b60:	72617453 	rsbvc	r7, r1, #1392508928	@ 0x53000000
    2b64:	74207374 	strtvc	r7, [r0], #-884	@ 0xfffffc8c
    2b68:	70206568 	eorvc	r6, r0, r8, ror #10
    2b6c:	69726961 	ldmdbvs	r2!, {r0, r5, r6, r8, fp, sp, lr}^
    2b70:	7020676e 	eorvc	r6, r0, lr, ror #14
    2b74:	65636f72 	strbvs	r6, [r3, #-3954]!	@ 0xfffff08e
    2b78:	77207373 			@ <UNDEFINED> instruction: 0x77207373
    2b7c:	20687469 	rsbcs	r7, r8, r9, ror #8
    2b80:	61632061 	cmnvs	r3, r1, rrx
    2b84:	00002e72 	andeq	r2, r0, r2, ror lr
    2b88:	6f636e45 	svcvs	0x00636e45
    2b8c:	20646564 	rsbcs	r6, r4, r4, ror #10
    2b90:	61207325 			@ <UNDEFINED> instruction: 0x61207325
    2b94:	73252073 			@ <UNDEFINED> instruction: 0x73252073
    2b98:	74697720 	strbtvc	r7, [r9], #-1824	@ 0xfffff8e0
    2b9c:	64252068 	strtvs	r2, [r5], #-104	@ 0xffffff98
    2ba0:	61686320 	cmnvs	r8, r0, lsr #6
    2ba4:	74636172 	strbtvc	r6, [r3], #-370	@ 0xfffffe8e
    2ba8:	0a737265 	beq	1cdf544 <__ROM_SIZE__+0x1c9f544>
    2bac:	00000000 	andeq	r0, r0, r0
    2bb0:	69727453 	ldmdbvs	r2!, {r0, r1, r4, r6, sl, ip, sp, lr}^
    2bb4:	6520676e 	strvs	r6, [r0, #-1902]!	@ 0xfffff892
    2bb8:	65656378 	strbvs	r6, [r5, #-888]!	@ 0xfffffc88
    2bbc:	6d207364 	stcvs	3, cr7, [r0, #-400]!	@ 0xfffffe70
    2bc0:	6c207861 	stcvs	8, cr7, [r0], #-388	@ 0xfffffe7c
    2bc4:	74676e65 	strbtvc	r6, [r7], #-3685	@ 0xfffff19b
    2bc8:	666f2068 	strbtvs	r2, [pc], -r8, rrx
    2bcc:	20642520 	rsbcs	r2, r4, r0, lsr #10
    2bd0:	72616863 	rsbvc	r6, r1, #6488064	@ 0x630000
    2bd4:	65746361 	ldrbvs	r6, [r4, #-865]!	@ 0xfffffc9f
    2bd8:	00007372 	andeq	r7, r0, r2, ror r3
    2bdc:	67617355 			@ <UNDEFINED> instruction: 0x67617355
    2be0:	73692065 	cmnvc	r9, #101	@ 0x65
    2be4:	6e652720 	cdpvs	7, 6, cr2, cr5, cr0, {1}
    2be8:	65646f63 	strbvs	r6, [r4, #-3939]!	@ 0xfffff09d
    2bec:	73203436 			@ <UNDEFINED> instruction: 0x73203436
    2bf0:	6e697274 	mcrvs	2, 3, r7, cr9, cr4, {3}
    2bf4:	000a2767 	andeq	r2, sl, r7, ror #14
    2bf8:	6f636544 	svcvs	0x00636544
    2bfc:	20646564 	rsbcs	r6, r4, r4, ror #10
    2c00:	61207325 			@ <UNDEFINED> instruction: 0x61207325
    2c04:	25203a73 	strcs	r3, [r0, #-2675]!	@ 0xfffff58d
    2c08:	00000a73 	andeq	r0, r0, r3, ror sl
    2c0c:	69727453 	ldmdbvs	r2!, {r0, r1, r4, r6, sl, ip, sp, lr}^
    2c10:	6520676e 	strvs	r6, [r0, #-1902]!	@ 0xfffff892
    2c14:	65656378 	strbvs	r6, [r5, #-888]!	@ 0xfffffc88
    2c18:	6d207364 	stcvs	3, cr7, [r0, #-400]!	@ 0xfffffe70
    2c1c:	62207861 	eorvs	r7, r0, #6356992	@ 0x610000
    2c20:	36657361 	strbtcc	r7, [r5], -r1, ror #6
    2c24:	74732034 	ldrbtvc	r2, [r3], #-52	@ 0xffffffcc
    2c28:	676e6972 			@ <UNDEFINED> instruction: 0x676e6972
    2c2c:	6e656c20 	cdpvs	12, 6, cr6, cr5, cr0, {1}
    2c30:	20687467 	rsbcs	r7, r8, r7, ror #8
    2c34:	2520666f 	strcs	r6, [r0, #-1647]!	@ 0xfffff991
    2c38:	68632064 	stmdavs	r3!, {r2, r5, r6, sp}^
    2c3c:	63617261 	cmnvs	r1, #268435462	@ 0x10000006
    2c40:	73726574 	cmnvc	r2, #116, 10	@ 0x1d000000
    2c44:	00000000 	andeq	r0, r0, r0
    2c48:	67617355 			@ <UNDEFINED> instruction: 0x67617355
    2c4c:	73692065 	cmnvc	r9, #101	@ 0x65
    2c50:	65642720 	strbvs	r2, [r4, #-1824]!	@ 0xfffff8e0
    2c54:	65646f63 	strbvs	r6, [r4, #-3939]!	@ 0xfffff09d
    2c58:	73203436 			@ <UNDEFINED> instruction: 0x73203436
    2c5c:	6e697274 	mcrvs	2, 3, r7, cr9, cr4, {3}
    2c60:	000a2767 	andeq	r2, sl, r7, ror #14
    2c64:	6f636564 	svcvs	0x00636564
    2c68:	34366564 	ldrtcc	r6, [r6], #-1380	@ 0xfffffa9c
    2c6c:	00000000 	andeq	r0, r0, r0
    2c70:	65736142 	ldrbvs	r6, [r3, #-322]!	@ 0xfffffebe
    2c74:	64203436 	strtvs	r3, [r0], #-1078	@ 0xfffffbca
    2c78:	646f6365 	strbtvs	r6, [pc], #-869	@ 2c80 <cmd_end_+0x374>
    2c7c:	61207365 			@ <UNDEFINED> instruction: 0x61207365
    2c80:	72747320 	rsbsvc	r7, r4, #32, 6	@ 0x80000000
    2c84:	00676e69 	rsbeq	r6, r7, r9, ror #28
    2c88:	6f636e65 	svcvs	0x00636e65
    2c8c:	34366564 	ldrtcc	r6, [r6], #-1380	@ 0xfffffa9c
    2c90:	00000000 	andeq	r0, r0, r0
    2c94:	65736142 	ldrbvs	r6, [r3, #-322]!	@ 0xfffffebe
    2c98:	65203436 	strvs	r3, [r0, #-1078]!	@ 0xfffffbca
    2c9c:	646f636e 	strbtvs	r6, [pc], #-878	@ 2ca4 <cmd_end_+0x398>
    2ca0:	61207365 			@ <UNDEFINED> instruction: 0x61207365
    2ca4:	72747320 	rsbsvc	r7, r4, #32, 6	@ 0x80000000
    2ca8:	00676e69 	rsbeq	r6, r7, r9, ror #28
    2cac:	74736554 	ldrbtvc	r6, [r3], #-1364	@ 0xfffffaac
    2cb0:	20676e69 	rsbcs	r6, r7, r9, ror #28
    2cb4:	20656874 	rsbcs	r6, r5, r4, ror r8
    2cb8:	68646365 	stmdavs	r4!, {r0, r2, r5, r6, r8, r9, sp, lr}^
    2cbc:	79656b20 	stmdbvc	r5!, {r5, r8, r9, fp, sp, lr}^
    2cc0:	63786520 	cmnvs	r8, #32, 10	@ 0x8000000
    2cc4:	676e6168 	strbvs	r6, [lr, -r8, ror #2]!
    2cc8:	00000a65 	andeq	r0, r0, r5, ror #20
    2ccc:	73726946 	cmnvc	r2, #1146880	@ 0x118000
    2cd0:	68732074 	ldmdavs	r3!, {r2, r4, r5, r6, sp}^
    2cd4:	64657261 	strbtvs	r7, [r5], #-609	@ 0xfffffd9f
    2cd8:	79656b20 	stmdbvc	r5!, {r5, r8, r9, fp, sp, lr}^
    2cdc:	20736920 	rsbscs	r6, r3, r0, lsr #18
    2ce0:	000a7325 	andeq	r7, sl, r5, lsr #6
    2ce4:	756f6853 	strbvc	r6, [pc, #-2131]!	@ 2499 <gf2point_add+0x4b>
    2ce8:	6220646c 	eorvs	r6, r0, #108, 8	@ 0x6c000000
    2cec:	61732065 	cmnvs	r3, r5, rrx
    2cf0:	6120656d 			@ <UNDEFINED> instruction: 0x6120656d
    2cf4:	73252073 			@ <UNDEFINED> instruction: 0x73252073
    2cf8:	0000000a 	andeq	r0, r0, sl
    2cfc:	74697753 	strbtvc	r7, [r9], #-1875	@ 0xfffff8ad
    2d00:	6e696863 	cdpvs	8, 6, cr6, cr9, cr3, {3}
    2d04:	6f662067 	svcvs	0x00662067
    2d08:	45412062 	strbmi	r2, [r1, #-98]	@ 0xffffff9e
    2d0c:	656b2053 	strbvs	r2, [fp, #-83]!	@ 0xffffffad
    2d10:	6f742079 	svcvs	0x00742079
    2d14:	77656e20 	strbvc	r6, [r5, -r0, lsr #28]!
    2d18:	6c617620 	stclvs	6, cr7, [r1], #-128	@ 0xffffff80
    2d1c:	202e6575 	eorcs	r6, lr, r5, ror r5
    2d20:	20797254 	rsbscs	r7, r9, r4, asr r2
    2d24:	20534541 	subscs	r4, r3, r1, asr #10
    2d28:	74736574 	ldrbtvc	r6, [r3], #-1396	@ 0xfffffa8c
    2d2c:	6f6e2073 	svcvs	0x006e2073
    2d30:	000a2e77 	andeq	r2, sl, r7, ror lr
    2d34:	752f5077 	strvc	r5, [pc, #-119]!	@ 2cc5 <cmd_end_+0x3b9>
    2d38:	752f5077 	strvc	r5, [pc, #-119]!	@ 2cc9 <cmd_end_+0x3bd>
    2d3c:	752f5077 	strvc	r5, [pc, #-119]!	@ 2ccd <cmd_end_+0x3c1>
    2d40:	752f5077 	strvc	r5, [pc, #-119]!	@ 2cd1 <cmd_end_+0x3c5>
    2d44:	752f5077 	strvc	r5, [pc, #-119]!	@ 2cd5 <cmd_end_+0x3c9>
    2d48:	752f5077 	strvc	r5, [pc, #-119]!	@ 2cd9 <cmd_end_+0x3cd>
    2d4c:	752f5077 	strvc	r5, [pc, #-119]!	@ 2cdd <cmd_end_+0x3d1>
    2d50:	752f5077 	strvc	r5, [pc, #-119]!	@ 2ce1 <cmd_end_+0x3d5>
    2d54:	00000000 	andeq	r0, r0, r0
    2d58:	68646365 	stmdavs	r4!, {r0, r2, r5, r6, r8, r9, sp, lr}^
    2d5c:	7365745f 	cmnvc	r5, #1593835520	@ 0x5f000000
    2d60:	00000074 	andeq	r0, r0, r4, ror r0
    2d64:	74736554 	ldrbtvc	r6, [r3], #-1364	@ 0xfffffaac
    2d68:	43452073 	movtmi	r2, #20595	@ 0x5073
    2d6c:	66204844 	strtvs	r4, [r0], -r4, asr #16
    2d70:	74636e75 	strbtvc	r6, [r3], #-3701	@ 0xfffff18b
    2d74:	736e6f69 	cmnvc	lr, #420	@ 0x1a4
    2d78:	00000000 	andeq	r0, r0, r0
    2d7c:	676e6950 			@ <UNDEFINED> instruction: 0x676e6950
    2d80:	20676e69 	rsbcs	r6, r7, r9, ror #28
    2d84:	20656874 	rsbcs	r6, r5, r4, ror r8
    2d88:	2e726163 	rpwcssz	f6, f2, f3
    2d8c:	0000000a 	andeq	r0, r0, sl
    2d90:	5f424f46 	svcpl	0x00424f46
    2d94:	4753454d 	ldrbmi	r4, [r3, -sp, asr #10]
    2d98:	4e495020 	cdpmi	0, 4, cr5, cr9, cr0, {1}
    2d9c:	00000a47 	andeq	r0, r0, r7, asr #20
    2da0:	676e6970 			@ <UNDEFINED> instruction: 0x676e6970
    2da4:	00000000 	andeq	r0, r0, r0
    2da8:	676e6950 			@ <UNDEFINED> instruction: 0x676e6950
    2dac:	68742073 	ldmdavs	r4!, {r0, r1, r4, r5, r6, sp}^
    2db0:	746f2065 	strbtvc	r2, [pc], #-101	@ 2db8 <cmd_end_+0x4ac>
    2db4:	20726568 	rsbscs	r6, r2, r8, ror #10
    2db8:	72616f62 	rsbvc	r6, r1, #392	@ 0x188
    2dbc:	00000064 	andeq	r0, r0, r4, rrx
    2dc0:	72617453 	rsbvc	r7, r1, #1392508928	@ 0x53000000
    2dc4:	676e6974 			@ <UNDEFINED> instruction: 0x676e6974
    2dc8:	61687320 	cmnvs	r8, r0, lsr #6
    2dcc:	20363532 	eorscs	r3, r6, r2, lsr r5
    2dd0:	74736574 	ldrbtvc	r6, [r3], #-1396	@ 0xfffffa8c
    2dd4:	0000000a 	andeq	r0, r0, sl
    2dd8:	65736142 	ldrbvs	r6, [r3, #-322]!	@ 0xfffffebe
    2ddc:	6f203436 	svcvs	0x00203436
    2de0:	48532066 	ldmdami	r3, {r1, r2, r5, r6, sp}^
    2de4:	35322d41 	ldrcc	r2, [r2, #-3393]!	@ 0xfffff2bf
    2de8:	65742036 	ldrbvs	r2, [r4, #-54]!	@ 0xffffffca
    2dec:	69207473 	stmdbvs	r0!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}
    2df0:	73252073 			@ <UNDEFINED> instruction: 0x73252073
    2df4:	0000000a 	andeq	r0, r0, sl
    2df8:	756f6853 	strbvc	r6, [pc, #-2131]!	@ 25ad <gf2point_on_curve+0x35>
    2dfc:	6220646c 	eorvs	r6, r0, #108, 8	@ 0x6c000000
    2e00:	73252065 			@ <UNDEFINED> instruction: 0x73252065
    2e04:	0000000a 	andeq	r0, r0, sl
    2e08:	64636261 	strbtvs	r6, [r3], #-609	@ 0xfffffd9f
    2e0c:	65646362 	strbvs	r6, [r4, #-866]!	@ 0xfffffc9e
    2e10:	66656463 	strbtvs	r6, [r5], -r3, ror #8
    2e14:	67666564 	strbvs	r6, [r6, -r4, ror #10]!
    2e18:	68676665 	stmdavs	r7!, {r0, r2, r5, r6, r9, sl, sp, lr}^
    2e1c:	69686766 	stmdbvs	r8!, {r1, r2, r5, r6, r8, r9, sl, sp, lr}^
    2e20:	6a696867 	bvs	1a5cfc4 <__ROM_SIZE__+0x1a1cfc4>
    2e24:	6b6a6968 	blvs	1a9d3cc <__ROM_SIZE__+0x1a5d3cc>
    2e28:	6c6b6a69 			@ <UNDEFINED> instruction: 0x6c6b6a69
    2e2c:	6d6c6b6a 	vstmdbvs	ip!, {d22-<overflow reg d74>}
    2e30:	6e6d6c6b 	cdpvs	12, 6, cr6, cr13, cr11, {3}
    2e34:	6f6e6d6c 	svcvs	0x006e6d6c
    2e38:	706f6e6d 	rsbvc	r6, pc, sp, ror #28
    2e3c:	71706f6e 	cmnvc	r0, lr, ror #30
    2e40:	00000000 	andeq	r0, r0, r0
    2e44:	616a8d24 	cmnvs	sl, r4, lsr #26
    2e48:	b83806d2 	ldmdalt	r8!, {r1, r4, r6, r7, r9, sl}
    2e4c:	9326c0e5 			@ <UNDEFINED> instruction: 0x9326c0e5
    2e50:	39603e0c 	stmdbcc	r0!, {r2, r3, r9, sl, fp, ip, sp}^
    2e54:	59e43ca3 	stmibpl	r4!, {r0, r1, r5, r7, sl, fp, ip, sp}^
    2e58:	6721ff64 	strvs	pc, [r1, -r4, ror #30]!
    2e5c:	d4edecf6 	strbtle	lr, [sp], #3318	@ 0xcf6
    2e60:	c106db19 	tstgt	r6, r9, lsl fp
    2e64:	00000000 	andeq	r0, r0, r0
    2e68:	32616873 	rsbcc	r6, r1, #7536640	@ 0x730000
    2e6c:	745f3635 	ldrbvc	r3, [pc], #-1589	@ 2e74 <cmd_end_+0x568>
    2e70:	00747365 	rsbseq	r7, r4, r5, ror #6
    2e74:	74736554 	ldrbtvc	r6, [r3], #-1364	@ 0xfffffaac
    2e78:	68742073 	ldmdavs	r4!, {r0, r1, r4, r5, r6, sp}^
    2e7c:	68732065 	ldmdavs	r3!, {r0, r2, r5, r6, sp}^
    2e80:	36353261 	ldrtcc	r3, [r5], -r1, ror #4
    2e84:	706d6920 	rsbvc	r6, sp, r0, lsr #18
    2e88:	656d656c 	strbvs	r6, [sp, #-1388]!	@ 0xfffffa94
    2e8c:	7461746e 	strbtvc	r7, [r1], #-1134	@ 0xfffffb92
    2e90:	006e6f69 	rsbeq	r6, lr, r9, ror #30
    2e94:	000a7325 	andeq	r7, sl, r5, lsr #6
    2e98:	000a6425 	andeq	r6, sl, r5, lsr #8
    2e9c:	6c697542 	cfstr64vs	mvdx7, [r9], #-264	@ 0xfffffef8
    2ea0:	5b203a64 	blpl	811838 <__ROM_SIZE__+0x7d1838>
    2ea4:	62343939 	eorsvs	r3, r4, #933888	@ 0xe4000
    2ea8:	3a306136 	bcc	c1b388 <__ROM_SIZE__+0xbdb388>
    2eac:	62343939 	eorsvs	r3, r4, #933888	@ 0xe4000
    2eb0:	5d306136 	ldfpls	f6, [r0, #-216]!	@ 0xffffff28
    2eb4:	5b202d20 	blpl	80e33c <__ROM_SIZE__+0x7ce33c>
    2eb8:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    2ebc:	49485240 	stmdbmi	r8, {r6, r9, ip, lr}^
    2ec0:	39522d54 	ldmdbcc	r2, {r2, r4, r6, r8, sl, fp, sp}^
    2ec4:	325a5830 	subscc	r5, sl, #48, 16	@ 0x300000
    2ec8:	205d4450 	subscs	r4, sp, r0, asr r4
    2ecc:	7041202d 	subvc	r2, r1, sp, lsr #32
    2ed0:	33322072 	teqcc	r2, #114	@ 0x72
    2ed4:	32303220 	eorscc	r3, r0, #32, 4
    2ed8:	202d2033 	eorcs	r2, sp, r3, lsr r0
    2edc:	343a3231 	ldrtcc	r3, [sl], #-561	@ 0xfffffdcf
    2ee0:	32313a30 	eorscc	r3, r1, #48, 20	@ 0x30000
    2ee4:	0000000a 	andeq	r0, r0, sl
    2ee8:	22732522 	rsbscs	r2, r3, #142606336	@ 0x8800000
    2eec:	6f63203a 	svcvs	0x0063203a
    2ef0:	6e616d6d 	cdpvs	13, 6, cr6, cr1, cr13, {3}
    2ef4:	6f6e2064 	svcvs	0x006e2064
    2ef8:	6f662074 	svcvs	0x00662074
    2efc:	2e646e75 	mcrcs	14, 3, r6, cr4, cr5, {3}
    2f00:	65735520 	ldrbvs	r5, [r3, #-1312]!	@ 0xfffffae0
    2f04:	65682220 	strbvs	r2, [r8, #-544]!	@ 0xfffffde0
    2f08:	2022706c 	eorcs	r7, r2, ip, rrx
    2f0c:	6c206f74 	stcvs	15, cr6, [r0], #-464	@ 0xfffffe30
    2f10:	20747369 	rsbscs	r7, r4, r9, ror #6
    2f14:	206c6c61 	rsbcs	r6, ip, r1, ror #24
    2f18:	6d6d6f63 	stclvs	15, cr6, [sp, #-396]!	@ 0xfffffe74
    2f1c:	2e646e61 	cdpcs	14, 6, cr6, cr4, cr1, {3}
    2f20:	0000000a 	andeq	r0, r0, sl
    2f24:	00006c2d 	andeq	r6, r0, sp, lsr #24
    2f28:	3a657375 	bcc	195fd04 <__ROM_SIZE__+0x191fd04>
    2f2c:	6c656820 	stclvs	8, cr6, [r5], #-128	@ 0xffffff80
    2f30:	6c2d2070 	stcvs	0, cr2, [sp], #-448	@ 0xfffffe40
    2f34:	726f6620 	rsbvc	r6, pc, #32, 12	@ 0x2000000
    2f38:	73696c20 	cmnvc	r9, #32, 24	@ 0x2000
    2f3c:	6e6f2074 	mcrvs	0, 3, r2, cr15, cr4, {3}
    2f40:	0a2e796c 	beq	ba14f8 <__ROM_SIZE__+0xb614f8>
    2f44:	0000000a 	andeq	r0, r0, sl
    2f48:	0000090a 	andeq	r0, r0, sl, lsl #18
    2f4c:	0000000a 	andeq	r0, r0, sl
    2f50:	00000000 	andeq	r0, r0, r0
    2f54:	00007325 	andeq	r7, r0, r5, lsr #6
    2f58:	0073250a 	rsbseq	r2, r3, sl, lsl #10
    2f5c:	00002023 	andeq	r2, r0, r3, lsr #32
    2f60:	74617473 	strbtvc	r7, [r1], #-1139	@ 0xfffffb8d
    2f64:	00007375 	andeq	r7, r0, r5, ror r3
    2f68:	75746552 	ldrbvc	r6, [r4, #-1362]!	@ 0xfffffaae
    2f6c:	20736e72 	rsbscs	r6, r3, r2, ror lr
    2f70:	74697865 	strbtvc	r7, [r9], #-2149	@ 0xfffff79b
    2f74:	61747320 	cmnvs	r4, r0, lsr #6
    2f78:	20737574 	rsbscs	r7, r3, r4, ror r5
    2f7c:	6c20666f 	stcvs	6, cr6, [r0], #-444	@ 0xfffffe44
    2f80:	20747361 	rsbscs	r7, r4, r1, ror #6
    2f84:	63657865 	cmnvs	r5, #6619136	@ 0x650000
    2f88:	64657475 	strbtvs	r7, [r5], #-1141	@ 0xfffffb8b
    2f8c:	6d6f6320 	stclvs	3, cr6, [pc, #-128]!	@ 2f14 <cmd_end_+0x608>
    2f90:	646e616d 	strbtvs	r6, [lr], #-365	@ 0xfffffe93
    2f94:	00000000 	andeq	r0, r0, r0
    2f98:	706c6568 	rsbvc	r6, ip, r8, ror #10
    2f9c:	00000000 	andeq	r0, r0, r0
    2fa0:	6e697250 	mcrvs	2, 3, r7, cr9, cr0, {2}
    2fa4:	61207374 			@ <UNDEFINED> instruction: 0x61207374
    2fa8:	61206c6c 			@ <UNDEFINED> instruction: 0x61206c6c
    2fac:	6c696176 	stfvse	f6, [r9], #-472	@ 0xfffffe28
    2fb0:	656c6261 	strbvs	r6, [ip, #-609]!	@ 0xfffffd9f
    2fb4:	6d6f6320 	stclvs	3, cr6, [pc, #-128]!	@ 2f3c <cmd_end_+0x630>
    2fb8:	646e616d 	strbtvs	r6, [lr], #-365	@ 0xfffffe93
    2fbc:	00000073 	andeq	r0, r0, r3, ror r0
    2fc0:	73726576 	cmnvc	r2, #494927872	@ 0x1d800000
    2fc4:	006e6f69 	rsbeq	r6, lr, r9, ror #30
    2fc8:	6e697250 	mcrvs	2, 3, r7, cr9, cr0, {2}
    2fcc:	64207374 	strtvs	r7, [r0], #-884	@ 0xfffffc8c
    2fd0:	69617465 	stmdbvs	r1!, {r0, r2, r5, r6, sl, ip, sp, lr}^
    2fd4:	6f20736c 	svcvs	0x0020736c
    2fd8:	68742066 	ldmdavs	r4!, {r1, r2, r5, r6, sp}^
    2fdc:	75622065 	strbvc	r2, [r2, #-101]!	@ 0xffffff9b
    2fe0:	00646c69 	rsbeq	r6, r4, r9, ror #24
    2fe4:	74736968 	ldrbtvc	r6, [r3], #-2408	@ 0xfffff698
    2fe8:	0079726f 	rsbseq	r7, r9, pc, ror #4
    2fec:	776f6853 			@ <UNDEFINED> instruction: 0x776f6853
    2ff0:	6d6f6320 	stclvs	3, cr6, [pc, #-128]!	@ 2f78 <cmd_end_+0x66c>
    2ff4:	646e616d 	strbtvs	r6, [lr], #-365	@ 0xfffffe93
    2ff8:	73696820 	cmnvc	r9, #32, 16	@ 0x200000
    2ffc:	79726f74 	ldmdbvc	r2!, {r2, r4, r5, r6, r8, r9, sl, fp, sp, lr}^
    3000:	00000000 	andeq	r0, r0, r0

00003004 <k>:
static const WORD k[64] = {
    3004:	428a2f98 	addmi	r2, sl, #152, 30	@ 0x260
    3008:	71374491 	teqvc	r7, r1	@ <illegal shifter operand>
    300c:	b5c0fbcf 	strblt	pc, [r0, #3023]	@ 0xbcf	@ <UNPREDICTABLE>
    3010:	e9b5dba5 	ldmib	r5!, {r0, r2, r5, r7, r8, r9, fp, ip, lr, pc}
    3014:	3956c25b 	ldmdbcc	r6, {r0, r1, r3, r4, r6, r9, lr, pc}^
    3018:	59f111f1 	ldmibpl	r1!, {r0, r4, r5, r6, r7, r8, ip}^
    301c:	923f82a4 	eorsls	r8, pc, #164, 4	@ 0x4000000a
    3020:	ab1c5ed5 	blge	71ab7c <__ROM_SIZE__+0x6dab7c>
    3024:	d807aa98 	stmdale	r7, {r3, r4, r7, r9, fp, sp, pc}
    3028:	12835b01 	addne	r5, r3, #1024	@ 0x400
    302c:	243185be 	ldrtcs	r8, [r1], #-1470	@ 0xfffffa42
    3030:	550c7dc3 	strpl	r7, [ip, #-3523]	@ 0xfffff23d
    3034:	72be5d74 	adcsvc	r5, lr, #116, 26	@ 0x1d00
    3038:	80deb1fe 	ldrshhi	fp, [lr], #30
    303c:	9bdc06a7 	blls	ff704ae0 <_STACK_TOP_+0xdf6fcae4>
    3040:	c19bf174 	orrsgt	pc, fp, r4, ror r1	@ <UNPREDICTABLE>
    3044:	e49b69c1 	ldr	r6, [fp], #2497	@ 0x9c1
    3048:	efbe4786 	svc	0x00be4786
    304c:	0fc19dc6 	svceq	0x00c19dc6
    3050:	240ca1cc 	strcs	sl, [ip], #-460	@ 0xfffffe34
    3054:	2de92c6f 	stclcs	12, cr2, [r9, #444]!	@ 0x1bc
    3058:	4a7484aa 	bmi	1d24308 <__ROM_SIZE__+0x1ce4308>
    305c:	5cb0a9dc 			@ <UNDEFINED> instruction: 0x5cb0a9dc
    3060:	76f988da 	usatvc	r8, #25, sl, asr #17
    3064:	983e5152 	ldmdals	lr!, {r1, r4, r6, r8, ip, lr}
    3068:	a831c66d 	ldmdage	r1!, {r0, r2, r3, r5, r6, r9, sl, lr, pc}
    306c:	b00327c8 	andlt	r2, r3, r8, asr #15
    3070:	bf597fc7 	svclt	0x00597fc7
    3074:	c6e00bf3 			@ <UNDEFINED> instruction: 0xc6e00bf3
    3078:	d5a79147 	strle	r9, [r7, #327]!	@ 0x147
    307c:	06ca6351 			@ <UNDEFINED> instruction: 0x06ca6351
    3080:	14292967 	strtne	r2, [r9], #-2407	@ 0xfffff699
    3084:	27b70a85 	ldrcs	r0, [r7, r5, lsl #21]!
    3088:	2e1b2138 	mrccs	1, 0, r2, cr11, cr8, {1}
    308c:	4d2c6dfc 	stcmi	13, cr6, [ip, #-1008]!	@ 0xfffffc10
    3090:	53380d13 	teqpl	r8, #1216	@ 0x4c0
    3094:	650a7354 	strvs	r7, [sl, #-852]	@ 0xfffffcac
    3098:	766a0abb 			@ <UNDEFINED> instruction: 0x766a0abb
    309c:	81c2c92e 	bichi	ip, r2, lr, lsr #18
    30a0:	92722c85 	rsbsls	r2, r2, #34048	@ 0x8500
    30a4:	a2bfe8a1 	adcsge	lr, pc, #10551296	@ 0xa10000
    30a8:	a81a664b 	ldmdage	sl, {r0, r1, r3, r6, r9, sl, sp, lr}
    30ac:	c24b8b70 	subgt	r8, fp, #112, 22	@ 0x1c000
    30b0:	c76c51a3 	strbgt	r5, [ip, -r3, lsr #3]!
    30b4:	d192e819 	orrsle	lr, r2, r9, lsl r8
    30b8:	d6990624 	ldrle	r0, [r9], r4, lsr #12
    30bc:	f40e3585 	vst3.32	{d3,d5,d7}, [lr], r5
    30c0:	106aa070 	rsbne	sl, sl, r0, ror r0
    30c4:	19a4c116 	stmibne	r4!, {r1, r2, r4, r8, lr, pc}
    30c8:	1e376c08 	cdpne	12, 3, cr6, cr7, cr8, {0}
    30cc:	2748774c 	strbcs	r7, [r8, -ip, asr #14]
    30d0:	34b0bcb5 	ldrtcc	fp, [r0], #3253	@ 0xcb5
    30d4:	391c0cb3 	ldmdbcc	ip, {r0, r1, r4, r5, r7, sl, fp}
    30d8:	4ed8aa4a 	vfnmami.f32	s21, s16, s20
    30dc:	5b9cca4f 	blpl	fe735a20 <_STACK_TOP_+0xde72da24>
    30e0:	682e6ff3 	stmdavs	lr!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, fp, sp, lr}
    30e4:	748f82ee 	strvc	r8, [pc], #750	@ 30ec <k+0xe8>
    30e8:	78a5636f 	stmiavc	r5!, {r0, r1, r2, r3, r5, r6, r8, r9, sp, lr}
    30ec:	84c87814 	strbhi	r7, [r8], #2068	@ 0x814
    30f0:	8cc70208 	sfmhi	f0, 2, [r7], {8}
    30f4:	90befffa 	ldrshtls	pc, [lr], sl	@ <UNPREDICTABLE>
    30f8:	a4506ceb 	ldrbge	r6, [r0], #-3307	@ 0xfffff315
    30fc:	bef9a3f7 	mrclt	3, 7, sl, cr9, cr7, {7}
    3100:	c67178f2 			@ <UNDEFINED> instruction: 0xc67178f2
    3104:	6972700a 	ldmdbvs	r2!, {r1, r3, ip, sp, lr}^
    3108:	2d66746e 	cfstrdcs	mvd7, [r6, #-440]!	@ 0xfffffe48
    310c:	6f727265 	svcvs	0x00727265
    3110:	00000a72 	andeq	r0, r0, r2, ror sl

00003114 <hextable>:
static char hextable[] = {'0', '1', '2', '3', '4', '5', '6', '7',
    3114:	33323130 	teqcc	r2, #48, 2
    3118:	37363534 			@ <UNDEFINED> instruction: 0x37363534
    311c:	42413938 	submi	r3, r1, #56, 18	@ 0xe0000
    3120:	46454443 	strbmi	r4, [r5], -r3, asr #8
    3124:	6972700a 	ldmdbvs	r2!, {r1, r3, ip, sp, lr}^
    3128:	3266746e 	rsbcc	r7, r6, #1845493760	@ 0x6e000000
    312c:	7272652d 	rsbsvc	r6, r2, #188743680	@ 0xb400000
    3130:	000a726f 	andeq	r7, sl, pc, ror #4

00003134 <hextable2>:
static char hextable2[] = {'0', '1', '2', '3', '4', '5', '6', '7',
    3134:	33323130 	teqcc	r2, #48, 2
    3138:	37363534 			@ <UNDEFINED> instruction: 0x37363534
    313c:	42413938 	submi	r3, r1, #56, 18	@ 0xe0000
    3140:	46454443 	strbmi	r4, [r5], -r3, asr #8
    3144:	67617355 			@ <UNDEFINED> instruction: 0x67617355
    3148:	25203a65 	strcs	r3, [r0, #-2661]!	@ 0xfffff59b
    314c:	613c2073 	teqvs	ip, r3, ror r0
    3150:	65726464 	ldrbvs	r6, [r2, #-1124]!	@ 0xfffffb9c
    3154:	203e7373 	eorscs	r7, lr, r3, ror r3
    3158:	206e6928 	rsbcs	r6, lr, r8, lsr #18
    315c:	29786568 	ldmdbcs	r8!, {r3, r5, r6, r8, sl, sp, lr}^
    3160:	0000000a 	andeq	r0, r0, sl
    3164:	78257830 	stmdavc	r5!, {r4, r5, fp, ip, sp, lr}
    3168:	7830203a 	ldmdavc	r0!, {r1, r3, r4, r5, sp}
    316c:	000a7825 	andeq	r7, sl, r5, lsr #16
    3170:	67617355 			@ <UNDEFINED> instruction: 0x67617355
    3174:	25203a65 	strcs	r3, [r0, #-2661]!	@ 0xfffff59b
    3178:	613c2073 	teqvs	ip, r3, ror r0
    317c:	65726464 	ldrbvs	r6, [r2, #-1124]!	@ 0xfffffb9c
    3180:	203e7373 	eorscs	r7, lr, r3, ror r3
    3184:	206e6928 	rsbcs	r6, lr, r8, lsr #18
    3188:	29786568 	ldmdbcs	r8!, {r3, r5, r6, r8, sl, sp, lr}^
    318c:	61763c20 	cmnvs	r6, r0, lsr #24
    3190:	3e65756c 	cdpcc	5, 6, cr7, cr5, cr12, {3}
    3194:	6e692820 	cdpvs	8, 6, cr2, cr9, cr0, {1}
    3198:	78656820 	stmdavc	r5!, {r5, fp, sp, lr}^
    319c:	00000a29 	andeq	r0, r0, r9, lsr #20
    31a0:	67617355 			@ <UNDEFINED> instruction: 0x67617355
    31a4:	25203a65 	strcs	r3, [r0, #-2661]!	@ 0xfffff59b
    31a8:	613c2073 	teqvs	ip, r3, ror r0
    31ac:	65726464 	ldrbvs	r6, [r2, #-1124]!	@ 0xfffffb9c
    31b0:	203e7373 	eorscs	r7, lr, r3, ror r3
    31b4:	206e6928 	rsbcs	r6, lr, r8, lsr #18
    31b8:	29786568 	ldmdbcs	r8!, {r3, r5, r6, r8, sl, sp, lr}^
    31bc:	756e3c20 	strbvc	r3, [lr, #-3104]!	@ 0xfffff3e0
    31c0:	6f775f6d 	svcvs	0x00775f6d
    31c4:	3e736472 	mrccc	4, 3, r6, cr3, cr2, {3}
    31c8:	6e692820 	cdpvs	8, 6, cr2, cr9, cr0, {1}
    31cc:	63656420 	cmnvs	r5, #32, 8	@ 0x20000000
    31d0:	6c616d69 	stclvs	13, cr6, [r1], #-420	@ 0xfffffe5c
    31d4:	00000a29 	andeq	r0, r0, r9, lsr #20
    31d8:	6f727245 	svcvs	0x00727245
    31dc:	49203a72 	stmdbmi	r0!, {r1, r4, r5, r6, r9, fp, ip, sp}
    31e0:	6c61766e 	stclvs	6, cr7, [r1], #-440	@ 0xfffffe48
    31e4:	62206469 	eorvs	r6, r0, #1761607680	@ 0x69000000
    31e8:	6c207469 	cfstrsvs	mvf7, [r0], #-420	@ 0xfffffe5c
    31ec:	7461636f 	strbtvc	r6, [r1], #-879	@ 0xfffffc91
    31f0:	206e6f69 	rsbcs	r6, lr, r9, ror #30
    31f4:	75677261 	strbvc	r7, [r7, #-609]!	@ 0xfffffd9f
    31f8:	746e656d 	strbtvc	r6, [lr], #-1389	@ 0xfffffa93
    31fc:	0000000a 	andeq	r0, r0, sl
    3200:	6f727245 	svcvs	0x00727245
    3204:	49203a72 	stmdbmi	r0!, {r1, r4, r5, r6, r9, fp, ip, sp}
    3208:	6c61766e 	stclvs	6, cr7, [r1], #-440	@ 0xfffffe48
    320c:	62206469 	eorvs	r6, r0, #1761607680	@ 0x69000000
    3210:	76207469 	strtvc	r7, [r0], -r9, ror #8
    3214:	65756c61 	ldrbvs	r6, [r5, #-3169]!	@ 0xfffff39f
    3218:	67726120 	ldrbvs	r6, [r2, -r0, lsr #2]!
    321c:	6e656d75 	mcrvs	13, 3, r6, cr5, cr5, {3}
    3220:	00000a74 	andeq	r0, r0, r4, ror sl
    3224:	67617355 			@ <UNDEFINED> instruction: 0x67617355
    3228:	25203a65 	strcs	r3, [r0, #-2661]!	@ 0xfffff59b
    322c:	613c2073 	teqvs	ip, r3, ror r0
    3230:	65726464 	ldrbvs	r6, [r2, #-1124]!	@ 0xfffffb9c
    3234:	695f7373 	ldmdbvs	pc, {r0, r1, r4, r5, r6, r8, r9, ip, sp, lr}^	@ <UNPREDICTABLE>
    3238:	65685f6e 	strbvs	r5, [r8, #-3950]!	@ 0xfffff092
    323c:	32332878 	eorscc	r2, r3, #120, 16	@ 0x780000
    3240:	7469622d 	strbtvc	r6, [r9], #-557	@ 0xfffffdd3
    3244:	203e2973 	eorscs	r2, lr, r3, ror r9
    3248:	7469623c 	strbtvc	r6, [r9], #-572	@ 0xfffffdc4
    324c:	636f6c5f 	cmnvs	pc, #24320	@ 0x5f00
    3250:	6f697461 	svcvs	0x00697461
    3254:	6e695f6e 	cdpvs	15, 6, cr5, cr9, cr14, {3}
    3258:	6365645f 	cmnvs	r5, #1593835520	@ 0x5f000000
    325c:	6c616d69 	stclvs	13, cr6, [r1], #-420	@ 0xfffffe5c
    3260:	74203028 	strtvc	r3, [r0], #-40	@ 0xffffffd8
    3264:	3133206f 	teqcc	r3, pc, rrx
    3268:	3c203e29 	stccc	14, cr3, [r0], #-164	@ 0xffffff5c
    326c:	5f746962 	svcpl	0x00746962
    3270:	756c6176 	strbvc	r6, [ip, #-374]!	@ 0xfffffe8a
    3274:	20302865 	eorscs	r2, r0, r5, ror #16
    3278:	3120726f 			@ <UNDEFINED> instruction: 0x3120726f
    327c:	000a3e29 	andeq	r3, sl, r9, lsr #28
    3280:	20746942 	rsbscs	r6, r4, r2, asr #18
    3284:	40207525 	eormi	r7, r0, r5, lsr #10
    3288:	25783020 	ldrbcs	r3, [r8, #-32]!	@ 0xffffffe0
    328c:	3a783830 	bcc	1e11354 <__ROM_SIZE__+0x1dd1354>
    3290:	0a752520 	beq	1d4c718 <__ROM_SIZE__+0x1d0c718>
    3294:	00000000 	andeq	r0, r0, r0
    3298:	67617355 			@ <UNDEFINED> instruction: 0x67617355
    329c:	25203a65 	strcs	r3, [r0, #-2661]!	@ 0xfffff59b
    32a0:	613c2073 	teqvs	ip, r3, ror r0
    32a4:	65726464 	ldrbvs	r6, [r2, #-1124]!	@ 0xfffffb9c
    32a8:	695f7373 	ldmdbvs	pc, {r0, r1, r4, r5, r6, r8, r9, ip, sp, lr}^	@ <UNPREDICTABLE>
    32ac:	65685f6e 	strbvs	r5, [r8, #-3950]!	@ 0xfffff092
    32b0:	32332878 	eorscc	r2, r3, #120, 16	@ 0x780000
    32b4:	7469622d 	strbtvc	r6, [r9], #-557	@ 0xfffffdd3
    32b8:	203e2973 	eorscs	r2, lr, r3, ror r9
    32bc:	7469623c 	strbtvc	r6, [r9], #-572	@ 0xfffffdc4
    32c0:	636f6c5f 	cmnvs	pc, #24320	@ 0x5f00
    32c4:	6f697461 	svcvs	0x00697461
    32c8:	6e695f6e 	cdpvs	15, 6, cr5, cr9, cr14, {3}
    32cc:	6365645f 	cmnvs	r5, #1593835520	@ 0x5f000000
    32d0:	6c616d69 	stclvs	13, cr6, [r1], #-420	@ 0xfffffe5c
    32d4:	74203028 	strtvc	r3, [r0], #-40	@ 0xffffffd8
    32d8:	3133206f 	teqcc	r3, pc, rrx
    32dc:	00000a29 	andeq	r0, r0, r9, lsr #20
    32e0:	64616572 	strbtvs	r6, [r1], #-1394	@ 0xfffffa8e
    32e4:	00000000 	andeq	r0, r0, r0
    32e8:	64616552 	strbtvs	r6, [r1], #-1362	@ 0xfffffaae
    32ec:	756e2073 	strbvc	r2, [lr, #-115]!	@ 0xffffff8d
    32f0:	7265626d 	rsbvc	r6, r5, #-805306362	@ 0xd0000006
    32f4:	20666f20 	rsbcs	r6, r6, r0, lsr #30
    32f8:	65747962 	ldrbvs	r7, [r4, #-2402]!	@ 0xfffff69e
    32fc:	72662073 	rsbvc	r2, r6, #115	@ 0x73
    3300:	6d206d6f 	stcvs	13, cr6, [r0, #-444]!	@ 0xfffffe44
    3304:	726f6d65 	rsbvc	r6, pc, #6464	@ 0x1940
    3308:	00000079 	andeq	r0, r0, r9, ror r0
    330c:	00323377 	eorseq	r3, r2, r7, ror r3
    3310:	74697277 	strbtvc	r7, [r9], #-631	@ 0xfffffd89
    3314:	61207365 			@ <UNDEFINED> instruction: 0x61207365
    3318:	20323320 	eorscs	r3, r2, r0, lsr #6
    331c:	20746962 	rsbscs	r6, r4, r2, ror #18
    3320:	756c6176 	strbvc	r6, [ip, #-374]!	@ 0xfffffe8a
    3324:	6f742065 	svcvs	0x00742065
    3328:	6d206120 	stfvss	f6, [r0, #-128]!	@ 0xffffff80
    332c:	726f6d65 	rsbvc	r6, pc, #6464	@ 0x1940
    3330:	6f6c2079 	svcvs	0x006c2079
    3334:	69746163 	ldmdbvs	r4!, {r0, r1, r5, r6, r8, sp, lr}^
    3338:	00006e6f 	andeq	r6, r0, pc, ror #28
    333c:	00323372 	eorseq	r3, r2, r2, ror r3
    3340:	64616572 	strbtvs	r6, [r1], #-1394	@ 0xfffffa8e
    3344:	20612073 	rsbcs	r2, r1, r3, ror r0
    3348:	62203233 	eorvs	r3, r0, #805306371	@ 0x30000003
    334c:	6d207469 	cfstrsvs	mvf7, [r0, #-420]!	@ 0xfffffe5c
    3350:	726f6d65 	rsbvc	r6, pc, #6464	@ 0x1940
    3354:	6f6c2079 	svcvs	0x006c2079
    3358:	69746163 	ldmdbvs	r4!, {r0, r1, r5, r6, r8, sp, lr}^
    335c:	00006e6f 	andeq	r6, r0, pc, ror #28
    3360:	00006272 	andeq	r6, r0, r2, ror r2
    3364:	64616572 	strbtvs	r6, [r1], #-1394	@ 0xfffffa8e
    3368:	20612073 	rsbcs	r2, r1, r3, ror r0
    336c:	20746962 	rsbscs	r6, r4, r2, ror #18
    3370:	6d6f7266 	sfmvs	f7, 2, [pc, #-408]!	@ 31e0 <hextable2+0xac>
    3374:	6d656d20 	stclvs	13, cr6, [r5, #-128]!	@ 0xffffff80
    3378:	2079726f 	rsbscs	r7, r9, pc, ror #4
    337c:	61636f6c 	cmnvs	r3, ip, ror #30
    3380:	6e6f6974 			@ <UNDEFINED> instruction: 0x6e6f6974
    3384:	00000000 	andeq	r0, r0, r0
    3388:	00006277 	andeq	r6, r0, r7, ror r2
    338c:	74697277 	strbtvc	r7, [r9], #-631	@ 0xfffffd89
    3390:	20612065 	rsbcs	r2, r1, r5, rrx
    3394:	20746962 	rsbscs	r6, r4, r2, ror #18
    3398:	6d206f74 	stcvs	15, cr6, [r0, #-464]!	@ 0xfffffe30
    339c:	726f6d65 	rsbvc	r6, pc, #6464	@ 0x1940
    33a0:	6f6c2079 	svcvs	0x006c2079
    33a4:	69746163 	ldmdbvs	r4!, {r0, r1, r5, r6, r8, sp, lr}^
    33a8:	00006e6f 	andeq	r6, r0, pc, ror #28

000033ac <sbox>:
static const uint8_t sbox[256] = {
    33ac:	7b777c63 	blvc	1de2540 <__ROM_SIZE__+0x1da2540>
    33b0:	c56f6bf2 	strbgt	r6, [pc, #-3058]!	@ 27c6 <memcpy+0x8>
    33b4:	2b670130 	blcs	19c387c <__ROM_SIZE__+0x198387c>
    33b8:	76abd7fe 			@ <UNDEFINED> instruction: 0x76abd7fe
    33bc:	7dc982ca 	sfmvc	f0, 3, [r9, #808]	@ 0x328
    33c0:	f04759fa 			@ <UNDEFINED> instruction: 0xf04759fa
    33c4:	afa2d4ad 	svcge	0x00a2d4ad
    33c8:	c072a49c 			@ <UNDEFINED> instruction: 0xc072a49c
    33cc:	2693fdb7 			@ <UNDEFINED> instruction: 0x2693fdb7
    33d0:	ccf73f36 	ldclgt	15, cr3, [r7], #216	@ 0xd8
    33d4:	f1e5a534 			@ <UNDEFINED> instruction: 0xf1e5a534
    33d8:	1531d871 	ldrne	sp, [r1, #-2161]!	@ 0xfffff78f
    33dc:	c323c704 			@ <UNDEFINED> instruction: 0xc323c704
    33e0:	9a059618 	bls	168c48 <__ROM_SIZE__+0x128c48>
    33e4:	e2801207 	add	r1, r0, #1879048192	@ 0x70000000
    33e8:	75b227eb 	ldrvc	r2, [r2, #2027]!	@ 0x7eb
    33ec:	1a2c8309 	bne	b24018 <__ROM_SIZE__+0xae4018>
    33f0:	a05a6e1b 	subsge	r6, sl, fp, lsl lr
    33f4:	b3d63b52 	bicslt	r3, r6, #83968	@ 0x14800
    33f8:	842fe329 	strthi	lr, [pc], #-809	@ 3400 <sbox+0x54>
    33fc:	ed00d153 	stfd	f5, [r0, #-332]	@ 0xfffffeb4
    3400:	5bb1fc20 	blpl	fec82488 <_STACK_TOP_+0xdec7a48c>
    3404:	39becb6a 	ldmibcc	lr!, {r1, r3, r5, r6, r8, r9, fp, lr, pc}
    3408:	cf584c4a 	svcgt	0x00584c4a
    340c:	fbaaefd0 	blx	feabf356 <_STACK_TOP_+0xdeab735a>
    3410:	85334d43 	ldrhi	r4, [r3, #-3395]!	@ 0xfffff2bd
    3414:	7f02f945 	svcvc	0x0002f945
    3418:	a89f3c50 	ldmge	pc, {r4, r6, sl, fp, ip, sp}	@ <UNPREDICTABLE>
    341c:	8f40a351 	svchi	0x0040a351
    3420:	f5389d92 			@ <UNDEFINED> instruction: 0xf5389d92
    3424:	21dab6bc 	ldrhcs	fp, [sl, #108]	@ 0x6c
    3428:	d2f3ff10 	rscsle	pc, r3, #16, 30	@ 0x40
    342c:	ec130ccd 	ldc	12, cr0, [r3], {205}	@ 0xcd
    3430:	1744975f 	smlsldne	r9, r4, pc, r7	@ <UNPREDICTABLE>
    3434:	3d7ea7c4 	ldclcc	7, cr10, [lr, #-784]!	@ 0xfffffcf0
    3438:	73195d64 	tstvc	r9, #100, 26	@ 0x1900
    343c:	dc4f8160 	stflep	f0, [pc], {96}	@ 0x60
    3440:	88902a22 	ldmhi	r0, {r1, r5, r9, fp, sp}
    3444:	14b8ee46 	ldrtne	lr, [r8], #3654	@ 0xe46
    3448:	db0b5ede 	blle	2dafc8 <__ROM_SIZE__+0x29afc8>
    344c:	0a3a32e0 	beq	e8ffd4 <__ROM_SIZE__+0xe4ffd4>
    3450:	5c240649 	stcpl	6, cr0, [r4], #-292	@ 0xfffffedc
    3454:	62acd3c2 	adcvs	sp, ip, #134217731	@ 0x8000003
    3458:	79e49591 	stmibvc	r4!, {r0, r4, r7, r8, sl, ip, pc}^
    345c:	6d37c8e7 	ldcvs	8, cr12, [r7, #-924]!	@ 0xfffffc64
    3460:	a94ed58d 	stmdbge	lr, {r0, r2, r3, r7, r8, sl, ip, lr, pc}^
    3464:	eaf4566c 	b	ffd18e1c <_STACK_TOP_+0xdfd10e20>
    3468:	08ae7a65 	stmiaeq	lr!, {r0, r2, r5, r6, r9, fp, ip, sp, lr}
    346c:	2e2578ba 	mcrcs	8, 1, r7, cr5, cr10, {5}
    3470:	c6b4a61c 	ssatgt	sl, #21, ip, lsl #12
    3474:	1f74dde8 	svcne	0x0074dde8
    3478:	8a8bbd4b 	bhi	fe2f29ac <_STACK_TOP_+0xde2ea9b0>
    347c:	66b53e70 			@ <UNDEFINED> instruction: 0x66b53e70
    3480:	0ef60348 	cdpeq	3, 15, cr0, cr6, cr8, {2}
    3484:	b9573561 	ldmdblt	r7, {r0, r5, r6, r8, sl, ip, sp}^
    3488:	9e1dc186 	mnfls<illegal precision>	f4, f6
    348c:	1198f8e1 	orrsne	pc, r8, r1, ror #17
    3490:	948ed969 	strls	sp, [lr], #2409	@ 0x969
    3494:	e9871e9b 	stmib	r7, {r0, r1, r3, r4, r7, r9, sl, fp, ip}
    3498:	df2855ce 	svcle	0x002855ce
    349c:	0d89a18c 	stfeqd	f2, [r9, #560]	@ 0x230
    34a0:	6842e6bf 	stmdavs	r2, {r0, r1, r2, r3, r4, r5, r7, r9, sl, sp, lr, pc}^
    34a4:	0f2d9941 	svceq	0x002d9941
    34a8:	16bb54b0 			@ <UNDEFINED> instruction: 0x16bb54b0

000034ac <Rcon>:
static const uint8_t Rcon[11] = {
    34ac:	0402018d 	streq	r0, [r2], #-397	@ 0xfffffe73
    34b0:	40201008 	eormi	r1, r0, r8
    34b4:	00361b80 	eorseq	r1, r6, r0, lsl #23

000034b8 <rsbox>:
static const uint8_t rsbox[256] = {
    34b8:	d56a0952 	strble	r0, [sl, #-2386]!	@ 0xfffff6ae
    34bc:	38a53630 	stmiacc	r5!, {r4, r5, r9, sl, ip, sp}
    34c0:	9ea340bf 	mcrls	0, 5, r4, cr3, cr15, {5}
    34c4:	fbd7f381 	blx	ff6002d2 <_STACK_TOP_+0xdf5f82d6>
    34c8:	8239e37c 	eorshi	lr, r9, #124, 6	@ 0xf0000001
    34cc:	87ff2f9b 			@ <UNDEFINED> instruction: 0x87ff2f9b
    34d0:	44438e34 	strbmi	r8, [r3], #-3636	@ 0xfffff1cc
    34d4:	cbe9dec4 	blgt	ffa7afec <_STACK_TOP_+0xdfa72ff0>
    34d8:	32947b54 	addscc	r7, r4, #84, 22	@ 0x15000
    34dc:	3d23c2a6 	sfmcc	f4, 1, [r3, #-664]!	@ 0xfffffd68
    34e0:	0b954cee 	bleq	fe5568a0 <_STACK_TOP_+0xde54e8a4>
    34e4:	4ec3fa42 			@ <UNDEFINED> instruction: 0x4ec3fa42
    34e8:	66a12e08 	strtvs	r2, [r1], r8, lsl #28
    34ec:	b224d928 	eorlt	sp, r4, #40, 18	@ 0xa0000
    34f0:	49a25b76 	stmibmi	r2!, {r1, r2, r4, r5, r6, r8, r9, fp, ip, lr}
    34f4:	25d18b6d 	ldrbcs	r8, [r1, #2925]	@ 0xb6d
    34f8:	64f6f872 	ldrbtvs	pc, [r6], #2162	@ 0x872	@ <UNPREDICTABLE>
    34fc:	16986886 	ldrne	r6, [r8], r6, lsl #17
    3500:	cc5ca4d4 	cfldrdgt	mvd10, [ip], {212}	@ 0xd4
    3504:	92b6655d 	adcsls	r6, r6, #390070272	@ 0x17400000
    3508:	5048706c 	subpl	r7, r8, ip, rrx
    350c:	dab9edfd 	ble	fee7ed08 <_STACK_TOP_+0xdee76d0c>
    3510:	5746155e 	smlsldpl	r1, r6, lr, r5
    3514:	849d8da7 	ldrhi	r8, [sp], #3495	@ 0xda7
    3518:	00abd890 	umlaleq	sp, fp, r0, r8
    351c:	0ad3bc8c 	beq	ff4f2754 <_STACK_TOP_+0xdf4ea758>
    3520:	0558e4f7 	ldrbeq	lr, [r8, #-1271]	@ 0xfffffb09
    3524:	0645b3b8 			@ <UNDEFINED> instruction: 0x0645b3b8
    3528:	8f1e2cd0 	svchi	0x001e2cd0
    352c:	020f3fca 	andeq	r3, pc, #808	@ 0x328
    3530:	03bdafc1 			@ <UNDEFINED> instruction: 0x03bdafc1
    3534:	6b8a1301 	blvs	fe288140 <_STACK_TOP_+0xde280144>
    3538:	4111913a 	tstmi	r1, sl, lsr r1
    353c:	eadc674f 	b	ff71d280 <_STACK_TOP_+0xdf715284>
    3540:	cecff297 	mcrgt	2, 6, pc, cr15, cr7, {4}	@ <UNPREDICTABLE>
    3544:	73e6b4f0 	mvnvc	fp, #240, 8	@ 0xf0000000
    3548:	2274ac96 	rsbscs	sl, r4, #38400	@ 0x9600
    354c:	8535ade7 	ldrhi	sl, [r5, #-3559]!	@ 0xfffff219
    3550:	e837f9e2 	ldmda	r7!, {r1, r5, r6, r7, r8, fp, ip, sp, lr, pc}
    3554:	6edf751c 	mrcvs	5, 6, r7, cr15, cr12, {0}
    3558:	711af147 	tstvc	sl, r7, asr #2	@ <UNPREDICTABLE>
    355c:	89c5291d 	stmibhi	r5, {r0, r2, r3, r4, r8, fp, sp}^
    3560:	0e62b76f 	cdpeq	7, 6, cr11, cr2, cr15, {3}
    3564:	1bbe18aa 	blne	fef89814 <_STACK_TOP_+0xdef81818>
    3568:	4b3e56fc 	blmi	f99160 <__ROM_SIZE__+0xf59160>
    356c:	2079d2c6 	rsbscs	sp, r9, r6, asr #5
    3570:	fec0db9a 	mcr2	11, 6, sp, cr0, cr10, {4}	@ <UNPREDICTABLE>
    3574:	f45acd78 			@ <UNDEFINED> instruction: 0xf45acd78
    3578:	33a8dd1f 			@ <UNDEFINED> instruction: 0x33a8dd1f
    357c:	31c70788 	biccc	r0, r7, r8, lsl #15
    3580:	591012b1 	ldmdbpl	r0, {r0, r4, r5, r7, r9, ip}
    3584:	5fec8027 	svcpl	0x00ec8027
    3588:	a97f5160 	ldmdbge	pc!, {r5, r6, r8, ip, lr}^	@ <UNPREDICTABLE>
    358c:	0d4ab519 	cfstr64eq	mvdx11, [sl, #-100]	@ 0xffffff9c
    3590:	9f7ae52d 	svcls	0x007ae52d
    3594:	ef9cc993 	svc	0x009cc993
    3598:	4d3be0a0 	ldcmi	0, cr14, [fp, #-640]!	@ 0xfffffd80
    359c:	b0f52aae 	rscslt	r2, r5, lr, lsr #21
    35a0:	3cbbebc8 	vldmiacc	fp!, {d14-<overflow reg d49>}
    35a4:	61995383 	orrsvs	r5, r9, r3, lsl #7
    35a8:	7e042b17 	vmovvc.32	d4[0], r2
    35ac:	26d677ba 			@ <UNDEFINED> instruction: 0x26d677ba
    35b0:	631469e1 	tstvs	r4, #3686400	@ 0x384000
    35b4:	7d0c2155 	stfvcs	f2, [ip, #-340]	@ 0xfffffeac

000035b8 <polynomial>:
const gf2elem_t polynomial = { 0x000000c9, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000008 }; 
    35b8:	000000c9 	andeq	r0, r0, r9, asr #1
	...
    35cc:	00000008 	andeq	r0, r0, r8

000035d0 <coeff_b>:
const gf2elem_t coeff_b    = { 0x4a3205fd, 0x512f7874, 0x1481eb10, 0xb8c953ca, 0x0a601907, 0x00000002 }; 
    35d0:	4a3205fd 	bmi	c84dcc <__ROM_SIZE__+0xc44dcc>
    35d4:	512f7874 			@ <UNDEFINED> instruction: 0x512f7874
    35d8:	1481eb10 	strne	lr, [r1], #2832	@ 0xb10
    35dc:	b8c953ca 	stmialt	r9, {r1, r3, r6, r7, r8, r9, ip, lr}^
    35e0:	0a601907 	beq	1809a04 <__ROM_SIZE__+0x17c9a04>
    35e4:	00000002 	andeq	r0, r0, r2

000035e8 <base_y>:
const gf2elem_t base_y     = { 0x797324f1, 0xb11c5c0c, 0xa2cdd545, 0x71a0094f, 0xd51fbc6c, 0x00000000 }; 
    35e8:	797324f1 	ldmdbvc	r3!, {r0, r4, r5, r6, r7, sl, sp}^
    35ec:	b11c5c0c 	tstlt	ip, ip, lsl #24
    35f0:	a2cdd545 	sbcge	sp, sp, #289406976	@ 0x11400000
    35f4:	71a0094f 	asrvc	r0, pc, #18
    35f8:	d51fbc6c 	ldrle	fp, [pc, #-3180]	@ 2994 <cmd_end_+0x88>
    35fc:	00000000 	andeq	r0, r0, r0

00003600 <base_x>:
const gf2elem_t base_x     = { 0xe8343e36, 0xd4994637, 0xa0991168, 0x86a2d57e, 0xf0eba162, 0x00000003 }; 
    3600:	e8343e36 	ldmda	r4!, {r1, r2, r4, r5, r9, sl, fp, ip, sp}
    3604:	d4994637 	ldrle	r4, [r9], #1591	@ 0x637
    3608:	a0991168 	addsge	r1, r9, r8, ror #2
    360c:	86a2d57e 			@ <UNDEFINED> instruction: 0x86a2d57e
    3610:	f0eba162 			@ <UNDEFINED> instruction: 0xf0eba162
    3614:	00000003 	andeq	r0, r0, r3

00003618 <base_order>:
const scalar_t  base_order = { 0xa4234c33, 0x77e70c12, 0x000292fe, 0x00000000, 0x00000000, 0x00000004 }; 
    3618:	a4234c33 	strtge	r4, [r3], #-3123	@ 0xfffff3cd
    361c:	77e70c12 			@ <UNDEFINED> instruction: 0x77e70c12
    3620:	000292fe 	strdeq	r9, [r2], -lr
	...
    362c:	00000004 	andeq	r0, r0, r4

Disassembly of section .debug_info:

00000000 <.debug_info>:
       0:	0000045a 	andeq	r0, r0, sl, asr r4
       4:	04010005 	streq	r0, [r1], #-5
       8:	00000000 	andeq	r0, r0, r0
       c:	00001411 	andeq	r1, r0, r1, lsl r4
      10:	008f1d00 	addeq	r1, pc, r0, lsl #26
      14:	01770000 	cmneq	r7, r0
      18:	03c00000 	biceq	r0, r0, #0
      1c:	01140000 	tsteq	r4, r0
      20:	00000000 	andeq	r0, r0, r0
      24:	01030000 	mrseq	r0, (UNDEF: 3)
      28:	0000fe06 	andeq	pc, r0, r6, lsl #28
      2c:	05020300 	streq	r0, [r2, #-768]	@ 0xfffffd00
      30:	00000168 	andeq	r0, r0, r8, ror #2
      34:	58050403 	stmdapl	r5, {r0, r1, sl}
      38:	03000001 	movweq	r0, #1
      3c:	01530508 	cmpeq	r3, r8, lsl #10
      40:	34080000 	strcc	r0, [r8], #-0
      44:	02000001 	andeq	r0, r0, #1
      48:	004e182e 	subeq	r1, lr, lr, lsr #16
      4c:	01030000 	mrseq	r0, (UNDEF: 3)
      50:	0000fc08 	andeq	pc, r0, r8, lsl #24
      54:	07020300 	streq	r0, [r2, -r0, lsl #6]
      58:	0000010a 	andeq	r0, r0, sl, lsl #2
      5c:	22070403 	andcs	r0, r7, #50331648	@ 0x3000000
      60:	03000001 	movweq	r0, #1
      64:	011d0708 	tsteq	sp, r8, lsl #14
      68:	04120000 	ldreq	r0, [r2], #-0
      6c:	746e6905 	strbtvc	r6, [lr], #-2309	@ 0xfffff6fb
      70:	07040300 	streq	r0, [r4, -r0, lsl #6]
      74:	00000127 	andeq	r0, r0, r7, lsr #2
      78:	00000d08 	andeq	r0, r0, r8, lsl #26
      7c:	17d60300 	ldrbne	r0, [r6, r0, lsl #6]
      80:	00000071 	andeq	r0, r0, r1, ror r0
      84:	9e040803 	cdpls	8, 0, cr0, cr4, cr3, {0}
      88:	13000001 	movwne	r0, #1
      8c:	0000013c 	andeq	r0, r0, ip, lsr r1
      90:	2c040100 	stfcss	f0, [r4], {-0}
      94:	0000b308 	andeq	fp, r0, r8, lsl #6
      98:	0c3f0600 	ldceq	6, cr0, [pc], #-0	@ a0 <vector_table+0xa0>
      9c:	2e040000 	cdpcs	0, 0, cr0, cr4, cr0, {0}
      a0:	0000b80b 	andeq	fp, r0, fp, lsl #16
      a4:	49140000 	ldmdbmi	r4, {}	@ <UNPREDICTABLE>
      a8:	30040076 	andcc	r0, r4, r6, ror r0
      ac:	0000c80b 	andeq	ip, r0, fp, lsl #16
      b0:	0c00f000 	stceq	0, cr15, [r0], {-0}
      b4:	0000008b 	andeq	r0, r0, fp, lsl #1
      b8:	0000420d 	andeq	r4, r0, sp, lsl #4
      bc:	0000c800 	andeq	ip, r0, r0, lsl #16
      c0:	00710900 	rsbseq	r0, r1, r0, lsl #18
      c4:	00ef0000 	rsceq	r0, pc, r0
      c8:	0000420d 	andeq	r4, r0, sp, lsl #4
      cc:	0000d800 	andeq	sp, r0, r0, lsl #16
      d0:	00710900 	rsbseq	r0, r1, r0, lsl #18
      d4:	000f0000 	andeq	r0, pc, r0
      d8:	646d6315 	strbtvs	r6, [sp], #-789	@ 0xfffffceb
      dc:	0f2f0500 	svceq	0x002f0500
      e0:	000000e4 	andeq	r0, r0, r4, ror #1
      e4:	0000e905 	andeq	lr, r0, r5, lsl #18
      e8:	006a1600 	rsbeq	r1, sl, r0, lsl #12
      ec:	00fd0000 	rscseq	r0, sp, r0
      f0:	6a040000 	bvs	1000f8 <__ROM_SIZE__+0xc00f8>
      f4:	04000000 	streq	r0, [r0], #-0
      f8:	000000fd 	strdeq	r0, [r0], -sp
      fc:	01020500 	tsteq	r2, r0, lsl #10
     100:	07050000 	streq	r0, [r5, -r0]
     104:	03000001 	movweq	r0, #1
     108:	01050801 	tsteq	r5, r1, lsl #16
     10c:	070c0000 	streq	r0, [ip, -r0]
     110:	17000001 	strne	r0, [r0, -r1]
     114:	0938050c 	ldmdbeq	r8!, {r2, r3, r8, sl}
     118:	00000144 	andeq	r0, r0, r4, asr #2
     11c:	0000c406 	andeq	ip, r0, r6, lsl #8
     120:	0f390500 	svceq	0x00390500
     124:	00000144 	andeq	r0, r0, r4, asr #2
     128:	00000600 	andeq	r0, r0, r0, lsl #12
     12c:	3a050000 	bcc	140134 <__ROM_SIZE__+0x100134>
     130:	0001440f 	andeq	r4, r1, pc, lsl #8
     134:	bc060400 	cfstrslt	mvf0, [r6], {-0}
     138:	05000000 	streq	r0, [r0, #-0]
     13c:	00d8073b 	sbcseq	r0, r8, fp, lsr r7
     140:	00080000 	andeq	r0, r8, r0
     144:	00010e05 	andeq	r0, r1, r5, lsl #28
     148:	01980800 	orrseq	r0, r8, r0, lsl #16
     14c:	3c050000 	stccc	0, cr0, [r5], {-0}
     150:	00011303 	andeq	r1, r1, r3, lsl #6
     154:	74631800 	strbtvc	r1, [r3], #-2048	@ 0xfffff800
     158:	04010078 	streq	r0, [r1], #-120	@ 0xffffff88
     15c:	00008b17 	andeq	r8, r0, r7, lsl fp
     160:	00ef1900 	rsceq	r1, pc, r0, lsl #18
     164:	36010000 	strcc	r0, [r1], -r0
     168:	00014901 	andeq	r4, r1, r1, lsl #18
     16c:	40030500 	andmi	r0, r3, r0, lsl #10
     170:	1a000028 	bne	218 <vector_table+0x218>
     174:	000000df 	ldrdeq	r0, [r0], -pc	@ <UNPREDICTABLE>
     178:	8a063f04 	bhi	18fd90 <__ROM_SIZE__+0x14fd90>
     17c:	04000001 	streq	r0, [r0], #-1
     180:	0000018a 	andeq	r0, r0, sl, lsl #3
     184:	00018f04 	andeq	r8, r1, r4, lsl #30
     188:	b3050000 	movwlt	r0, #20480	@ 0x5000
     18c:	05000000 	streq	r0, [r0, #-0]
     190:	00000042 	andeq	r0, r0, r2, asr #32
     194:	0000d107 	andeq	sp, r0, r7, lsl #2
     198:	0e4a0600 	cdpeq	6, 4, cr0, cr10, cr0, {0}
     19c:	00000071 	andeq	r0, r0, r1, ror r0
     1a0:	000001b4 			@ <UNDEFINED> instruction: 0x000001b4
     1a4:	0001b404 	andeq	fp, r1, r4, lsl #8
     1a8:	00710400 	rsbseq	r0, r1, r0, lsl #8
     1ac:	b4040000 	strlt	r0, [r4], #-0
     1b0:	00000001 	andeq	r0, r0, r1
     1b4:	00004e05 	andeq	r4, r0, r5, lsl #28
     1b8:	01aa0700 			@ <UNDEFINED> instruction: 0x01aa0700
     1bc:	1f070000 	svcne	0x00070000
     1c0:	00007808 	andeq	r7, r0, r8, lsl #16
     1c4:	0001cf00 	andeq	ip, r1, r0, lsl #30
     1c8:	01440400 	cmpeq	r4, r0, lsl #8
     1cc:	07000000 	streq	r0, [r0, -r0]
     1d0:	0000014c 	andeq	r0, r0, ip, asr #2
     1d4:	6a052707 	bvs	149df8 <__ROM_SIZE__+0x109df8>
     1d8:	ea000000 	b	1e0 <vector_table+0x1e0>
     1dc:	04000001 	streq	r0, [r0], #-1
     1e0:	00000144 	andeq	r0, r0, r4, asr #2
     1e4:	00014404 	andeq	r4, r1, r4, lsl #8
     1e8:	61070000 	mrsvs	r0, (UNDEF: 7)
     1ec:	08000001 	stmdaeq	r0, {r0}
     1f0:	006a052c 	rsbeq	r0, sl, ip, lsr #10
     1f4:	02010000 	andeq	r0, r1, #0
     1f8:	44040000 	strmi	r0, [r4], #-0
     1fc:	1b000001 	blne	208 <vector_table+0x208>
     200:	00f31c00 	rscseq	r1, r3, r0, lsl #24
     204:	06010000 	streq	r0, [r1], -r0
     208:	00006a05 	andeq	r6, r0, r5, lsl #20
     20c:	0003c000 	andeq	ip, r3, r0
     210:	00011400 	andeq	r1, r1, r0, lsl #8
     214:	519c0100 	orrspl	r0, ip, r0, lsl #2
     218:	0e000004 	cdpeq	0, 0, cr0, cr0, cr4, {0}
     21c:	00000172 	andeq	r0, r0, r2, ror r1
     220:	00006a12 	andeq	r6, r0, r2, lsl sl
     224:	00001000 	andeq	r1, r0, r0
     228:	00000c00 	andeq	r0, r0, r0, lsl #24
     22c:	00b70e00 	adcseq	r0, r7, r0, lsl #28
     230:	fd1f0000 	ldc2	0, cr0, [pc, #-0]	@ 238 <vector_table+0x238>
     234:	20000000 	andcs	r0, r0, r0
     238:	1c000000 	stcne	0, cr0, [r0], {-0}
     23c:	0a000000 	beq	244 <vector_table+0x244>
     240:	00727463 	rsbseq	r7, r2, r3, ror #8
     244:	006a0907 	rsbeq	r0, sl, r7, lsl #18
     248:	00360000 	eorseq	r0, r6, r0
     24c:	002c0000 	eoreq	r0, ip, r0
     250:	1a0f0000 	bne	3c0258 <__ROM_SIZE__+0x380258>
     254:	32000004 	andcc	r0, r0, #4
     258:	df000000 	svcle	0x00000000
     25c:	10000002 	andne	r0, r0, r2
     260:	00000144 	andeq	r0, r0, r4, asr #2
     264:	00045115 	andeq	r5, r4, r5, lsl r1
     268:	8c910300 	ldchi	3, cr0, [r1], {0}
     26c:	656c0a7f 	strbvs	r0, [ip, #-2687]!	@ 0xfffff581
     270:	1516006e 	ldrne	r0, [r6, #-110]	@ 0xffffff92
     274:	0000006a 	andeq	r0, r0, sl, rrx
     278:	0000005b 	andeq	r0, r0, fp, asr r0
     27c:	00000055 	andeq	r0, r0, r5, asr r0
     280:	00042202 	andeq	r2, r4, r2, lsl #4
     284:	0001b900 	andeq	fp, r1, r0, lsl #18
     288:	00029400 	andeq	r9, r2, r0, lsl #8
     28c:	50010100 	andpl	r0, r1, r0, lsl #2
     290:	00007402 	andeq	r7, r0, r2, lsl #8
     294:	00042c02 	andeq	r2, r4, r2, lsl #24
     298:	00019400 	andeq	r9, r1, r0, lsl #8
     29c:	0002af00 	andeq	sl, r2, r0, lsl #30
     2a0:	50010100 	andpl	r0, r1, r0, lsl #2
     2a4:	01007402 	tsteq	r0, r2, lsl #8
     2a8:	91035201 	tstls	r3, r1, lsl #4
     2ac:	02007f8c 	andeq	r7, r0, #140, 30	@ 0x230
     2b0:	00000436 	andeq	r0, r0, r6, lsr r4
     2b4:	00000173 	andeq	r0, r0, r3, ror r1
     2b8:	000002c4 	andeq	r0, r0, r4, asr #5
     2bc:	03510101 	cmpeq	r1, #1073741824	@ 0x40000000
     2c0:	007f8c91 			@ <UNDEFINED> instruction: 0x007f8c91
     2c4:	00044c0b 	andeq	r4, r4, fp, lsl #24
     2c8:	0001ea00 	andeq	lr, r1, r0, lsl #20
     2cc:	50010100 	andpl	r0, r1, r0, lsl #2
     2d0:	29680305 	stmdbcs	r8!, {r0, r2, r8, r9}^
     2d4:	01010000 	mrseq	r0, (UNDEF: 1)
     2d8:	8c910351 	ldchi	3, cr0, [r1], {81}	@ 0x51
     2dc:	0f00007f 	svceq	0x0000007f
     2e0:	00000464 	andeq	r0, r0, r4, ror #8
     2e4:	0000002c 	andeq	r0, r0, ip, lsr #32
     2e8:	0000036e 	andeq	r0, r0, lr, ror #6
     2ec:	00014410 	andeq	r4, r1, r0, lsl r4
     2f0:	04512300 	ldrbeq	r2, [r1], #-768	@ 0xfffffd00
     2f4:	91030000 	mrsls	r0, (UNDEF: 3)
     2f8:	6c0a7f8c 	stcvs	15, cr7, [sl], {140}	@ 0x8c
     2fc:	24006e65 	strcs	r6, [r0], #-3685	@ 0xfffff19b
     300:	00006a15 	andeq	r6, r0, r5, lsl sl
     304:	00007100 	andeq	r7, r0, r0, lsl #2
     308:	00006f00 	andeq	r6, r0, r0, lsl #30
     30c:	046a0200 	strbteq	r0, [sl], #-512	@ 0xfffffe00
     310:	01ea0000 	mvneq	r0, r0
     314:	03240000 			@ <UNDEFINED> instruction: 0x03240000
     318:	01010000 	mrseq	r0, (UNDEF: 1)
     31c:	a8030550 	stmdage	r3, {r4, r6, r8, sl}
     320:	00000029 	andeq	r0, r0, r9, lsr #32
     324:	00047202 	andeq	r7, r4, r2, lsl #4
     328:	0001b900 	andeq	fp, r1, r0, lsl #18
     32c:	00033800 	andeq	r3, r3, r0, lsl #16
     330:	50010100 	andpl	r0, r1, r0, lsl #2
     334:	00007402 	andeq	r7, r0, r2, lsl #8
     338:	00047c02 	andeq	r7, r4, r2, lsl #24
     33c:	00019400 	andeq	r9, r1, r0, lsl #8
     340:	00035300 	andeq	r5, r3, r0, lsl #6
     344:	50010100 	andpl	r0, r1, r0, lsl #2
     348:	01007402 	tsteq	r0, r2, lsl #8
     34c:	91035201 	tstls	r3, r1, lsl #4
     350:	0b007f8c 	bleq	20188 <__RAM_SIZE__+0x18188>
     354:	00000490 	muleq	r0, r0, r4
     358:	000001ea 	andeq	r0, r0, sl, ror #3
     35c:	05500101 	ldrbeq	r0, [r0, #-257]	@ 0xfffffeff
     360:	0029bc03 	eoreq	fp, r9, r3, lsl #24
     364:	51010100 	mrspl	r0, (UNDEF: 17)
     368:	7f8c9103 	svcvc	0x008c9103
     36c:	ce020000 	cdpgt	0, 0, cr0, cr2, cr0, {0}
     370:	ea000003 	b	384 <vector_table+0x384>
     374:	85000001 	strhi	r0, [r0, #-1]
     378:	01000003 	tsteq	r0, r3
     37c:	03055001 	movweq	r5, #20481	@ 0x5001
     380:	00002918 	andeq	r2, r0, r8, lsl r9
     384:	03dc0200 	bicseq	r0, ip, #0, 4
     388:	01ea0000 	mvneq	r0, r0
     38c:	039c0000 	orrseq	r0, ip, #0
     390:	01010000 	mrseq	r0, (UNDEF: 1)
     394:	3c030550 	cfstr32cc	mvfx0, [r3], {80}	@ 0x50
     398:	00000029 	andeq	r0, r0, r9, lsr #32
     39c:	0003e802 	andeq	lr, r3, r2, lsl #16
     3a0:	0001ea00 	andeq	lr, r1, r0, lsl #20
     3a4:	0003b300 	andeq	fp, r3, r0, lsl #6
     3a8:	50010100 	andpl	r0, r1, r0, lsl #2
     3ac:	31600305 	cmncc	r0, r5, lsl #6
     3b0:	02000000 	andeq	r0, r0, #0
     3b4:	000003fa 	strdeq	r0, [r0], -sl
     3b8:	000001cf 	andeq	r0, r0, pc, asr #3
     3bc:	000003ca 	andeq	r0, r0, sl, asr #7
int car_mesg(int argc, char** argv) {
     3c0:	05510101 	ldrbeq	r0, [r1, #-257]	@ 0xfffffeff
     3c4:	00294003 	eoreq	r4, r9, r3
    printf("Received a message from the car:");
     3c8:	02020000 	andeq	r0, r2, #0
     3cc:	ea000004 	b	3e4 <car_mesg+0x24>
    for (ctr = 1; ctr < argc; ctr++) {
     3d0:	e1000001 	tst	r0, r1
        printf(" %s", argv[ctr]);
     3d4:	01000003 	tsteq	r0, r3
     3d8:	03055001 	movweq	r5, #20481	@ 0x5001
    for (ctr = 1; ctr < argc; ctr++) {
     3dc:	0000294c 	andeq	r2, r0, ip, asr #18
     3e0:	040c0200 	streq	r0, [ip], #-512	@ 0xfffffe00
    printf("\n");
     3e4:	01cf0000 	biceq	r0, pc, r0
    if (argc > 1) {
     3e8:	03f80000 	mvnseq	r0, #0
}
     3ec:	01010000 	mrseq	r0, (UNDEF: 1)
     3f0:	60030551 	andvs	r0, r3, r1, asr r5
        if (strcmp(argv[1], "PING_REPLY") == 0) {
     3f4:	00000029 	andeq	r0, r0, r9, lsr #32
     3f8:	00041802 	andeq	r1, r4, r2, lsl #16
            printf("Got a ping reply.\n");
     3fc:	0001ea00 	andeq	lr, r1, r0, lsl #20
     400:	00040f00 	andeq	r0, r4, r0, lsl #30
        else if (strcmp(argv[1], "AESB64") == 0) {
     404:	50010100 	andpl	r0, r1, r0, lsl #2
     408:	29840305 	stmibcs	r4, {r0, r2, r8, r9}
     40c:	02000000 	andeq	r0, r0, #0
            if (argc == 3) { 
     410:	00000456 	andeq	r0, r0, r6, asr r4
                printf("Missing AESB64 encoded message\n");
     414:	000001cf 	andeq	r0, r0, pc, asr #3
     418:	00000426 	andeq	r0, r0, r6, lsr #8
                len = decode_base64((uint8_t *) argv[2], strlen(argv[2]), decoded);
     41c:	05510101 	ldrbeq	r0, [r1, #-257]	@ 0xfffffeff
     420:	0029a403 	eoreq	sl, r9, r3, lsl #8
     424:	62020000 	andvs	r0, r2, #0
     428:	ea000004 	b	440 <car_mesg+0x80>
     42c:	3d000001 	stccc	0, cr0, [r0, #-4]
                AES_ECB_decrypt(&ctx, decoded);
     430:	01000004 	tsteq	r0, r4
     434:	03055001 	movweq	r5, #20481	@ 0x5001
                decoded[len] = '\0';
     438:	000029cc 	andeq	r2, r0, ip, asr #19
     43c:	049a0b00 	ldreq	r0, [sl], #2816	@ 0xb00
     440:	01ea0000 	mvneq	r0, r0
                printf("Decoded/decrypted as %s\n", decoded);
     444:	01010000 	mrseq	r0, (UNDEF: 1)
     448:	ec030550 	cfstr32	mvfx0, [r3], {80}	@ 0x50
     44c:	00000029 	andeq	r0, r0, r9, lsr #32
        else if (strcmp(argv[1], "B64") == 0) {
     450:	00421d00 	subeq	r1, r2, r0, lsl #26
     454:	71090000 	mrsvc	r0, (UNDEF: 9)
            if (argc == 3) { 
     458:	63000000 	movwvs	r0, #0
                printf("Missing Base64 encoded message\n");
     45c:	00bd0000 	adcseq	r0, sp, r0
     460:	00050000 	andeq	r0, r5, r0
                printf("Decoding Base64\n");
     464:	01a00401 	lsleq	r0, r1, #8
     468:	14020000 	strne	r0, [r2], #-0
                len = decode_base64((uint8_t *) argv[2], strlen(argv[2]), decoded);
     46c:	1d000000 	stcne	0, cr0, [r0, #-0]
     470:	000001e4 	andeq	r0, r0, r4, ror #3
     474:	00000177 	andeq	r0, r0, r7, ror r1
     478:	000004d4 	ldrdeq	r0, [r0], -r4
                decoded[len] = '\0';
     47c:	00000002 	andeq	r0, r0, r2
     480:	00000265 	andeq	r0, r0, r5, ror #4
     484:	fe060101 	cdp2	1, 0, cr0, cr6, cr1, {0}
                printf("Decoded as %s", decoded);
     488:	01000000 	mrseq	r0, (UNDEF: 0)
     48c:	01680502 	cmneq	r8, r2, lsl #10
     490:	04010000 	streq	r0, [r1], #-0
            printf("Didn't know how to handle %s\n", argv[1]);
     494:	00015805 	andeq	r5, r1, r5, lsl #16
     498:	05080100 	streq	r0, [r8, #-256]	@ 0xffffff00
     49c:	00000153 	andeq	r0, r0, r3, asr r1
     4a0:	fc080101 	stc2	1, cr0, [r8], {1}
     4a4:	01000000 	mrseq	r0, (UNDEF: 0)
     4a8:	010a0702 	tsteq	sl, r2, lsl #14
     4ac:	b1030000 	mrslt	r0, (UNDEF: 3)
     4b0:	02000001 	andeq	r0, r0, #1
     4b4:	005c1934 	subseq	r1, ip, r4, lsr r9
     4b8:	04010000 	streq	r0, [r1], #-0
     4bc:	00012207 	andeq	r2, r1, r7, lsl #4
     4c0:	07080100 	streq	r0, [r8, -r0, lsl #2]
     4c4:	0000011d 	andeq	r0, r0, sp, lsl r1
     4c8:	69050404 	stmdbvs	r5, {r2, sl}
     4cc:	0100746e 	tsteq	r0, lr, ror #8
     4d0:	01270704 			@ <UNDEFINED> instruction: 0x01270704
     4d4:	d8050000 	stmdale	r5, {}	@ <UNPREDICTABLE>
void uputc(char c) {
     4d8:	01000001 	tsteq	r0, r1
  while ((UARTFR >> 5) & 1)
     4dc:	006a0c14 	rsbeq	r0, sl, r4, lsl ip
     4e0:	50060000 	andpl	r0, r6, r0
  UART_DR = c;
     4e4:	94000000 	strls	r0, [r0], #-0
  if (c == '\n')
     4e8:	07000000 	streq	r0, [r0, -r0]
}
     4ec:	00000071 	andeq	r0, r0, r1, ror r0
    uputc('\r');
     4f0:	1d0800ef 	stcne	0, cr0, [r8, #-956]	@ 0xfffffc44
}
     4f4:	01000002 	tsteq	r0, r2
     4f8:	00840a1c 	addeq	r0, r4, ip, lsl sl
  if (!((UARTFR >> 4) & 1)) return UART_DR;
     4fc:	03050000 	movweq	r0, #20480	@ 0x5000
     500:	00000000 	andeq	r0, r0, r0
     504:	0001ba09 	andeq	fp, r1, r9, lsl #20
     508:	0d150100 	ldfeqs	f0, [r5, #-0]
  return -1;
     50c:	0001c80a 	andeq	ip, r1, sl, lsl #16
}
     510:	06170100 	ldreq	r0, [r7], -r0, lsl #2
     514:	000004d4 	ldrdeq	r0, [r0], -r4
  UARTCTL = 0;
     518:	00000002 	andeq	r0, r0, r2
     51c:	91009c01 	tstls	r0, r1, lsl #24
  UARTIBRD = 8;
     520:	05000000 	streq	r0, [r0, #-0]
  UARTFBRD = 44;
     524:	3d040100 	stfccs	f0, [r4, #-0]
  UARTCC = 0;
     528:	01000002 	tsteq	r0, r2
  UARTLCRH = 0x60;
     52c:	00000014 	andeq	r0, r0, r4, lsl r0
  UARTCTL = 0x301;
     530:	0002401d 	andeq	r4, r2, sp, lsl r0
}
     534:	00017700 	andeq	r7, r1, r0, lsl #14
     538:	0004d800 	andeq	sp, r4, r0, lsl #16
void u2putc(char c) {
     53c:	00006400 	andeq	r6, r0, r0, lsl #8
  while ((UART2FR >> 5) & 1)
     540:	00032900 	andeq	r2, r3, r0, lsl #18
     544:	022a0200 	eoreq	r0, sl, #0, 4
  UART2_DR = c;
     548:	22010000 	andcs	r0, r1, #0
  if (c == '\n')
     54c:	00051806 	andeq	r1, r5, r6, lsl #16
}
     550:	00002400 	andeq	r2, r0, r0, lsl #8
    u2putc('\r');
     554:	039c0100 	orrseq	r0, ip, #0, 2
}
     558:	00000234 	andeq	r0, r0, r4, lsr r2
     55c:	4e051c01 	cdpmi	12, 0, cr1, cr5, cr1, {0}
  if (!((UART2FR >> 4) & 1)) return UART2_DR;
     560:	fc000000 	stc2	0, cr0, [r0], {-0}
     564:	1c000004 	stcne	0, cr0, [r0], {4}
     568:	01000000 	mrseq	r0, (UNDEF: 0)
     56c:	0504049c 	streq	r0, [r4, #-1180]	@ 0xfffffb64
  return -1;
     570:	00746e69 	rsbseq	r6, r4, r9, ror #28
}
     574:	00023a05 	andeq	r3, r2, r5, lsl #20
     578:	06130100 	ldreq	r0, [r3], -r0, lsl #2
  UART2CTL = 0;
     57c:	000004d8 	ldrdeq	r0, [r0], -r8
     580:	00000024 	andeq	r0, r0, r4, lsr #32
  UART2IBRD = 8;
     584:	008d9c01 	addeq	r9, sp, r1, lsl #24
  UART2FBRD = 44;
     588:	63060000 	movwvs	r0, #24576	@ 0x6000
  UART2CC = 0;
     58c:	11130100 	tstne	r3, r0, lsl #2
  UART2LCRH = 0x60;
     590:	0000008d 	andeq	r0, r0, sp, lsl #1
  UART2CTL = 0x301;
     594:	0000008d 	andeq	r0, r0, sp, lsl #1
}
     598:	00000085 	andeq	r0, r0, r5, lsl #1
     59c:	0004f407 	andeq	pc, r4, r7, lsl #8
  RCGCUART |= 3;
     5a0:	00005500 	andeq	r5, r0, r0, lsl #10
     5a4:	50010800 	andpl	r0, r1, r0, lsl #16
     5a8:	00003d01 	andeq	r3, r0, r1, lsl #26
     5ac:	05080109 	streq	r0, [r8, #-265]	@ 0xfffffef7
  RCGCGPIO |= 3;
     5b0:	00000001 	andeq	r0, r0, r1
     5b4:	00000091 	muleq	r0, r1, r0
     5b8:	04010005 	streq	r0, [r1], #-5
  GPIODEN = 0x03;
     5bc:	000002dc 	ldrdeq	r0, [r0], -ip
     5c0:	00001401 	andeq	r1, r0, r1, lsl #8
  GPIOAFSEL = 0x03;
     5c4:	028f1d00 	addeq	r1, pc, #0, 26
  GPIOPCTL |= 0x00000011;
     5c8:	01770000 	cmneq	r7, r0
     5cc:	053c0000 	ldreq	r0, [ip, #-0]!
     5d0:	00640000 	rsbeq	r0, r4, r0
  GPIODEN2 = 0x03;
     5d4:	04260000 	strteq	r0, [r6], #-0
     5d8:	76020000 	strvc	r0, [r2], -r0
  GPIOAFSEL2 = 0x03;
     5dc:	01000002 	tsteq	r0, r2
  GPIOPCTL2 |= 0x00000011;
     5e0:	057c0622 	ldrbeq	r0, [ip, #-1570]!	@ 0xfffff9de
     5e4:	00240000 	eoreq	r0, r4, r0
     5e8:	9c010000 	stcls	0, cr0, [r1], {-0}
}
     5ec:	00028803 	andeq	r8, r2, r3, lsl #16
     5f0:	051c0100 	ldreq	r0, [ip, #-256]	@ 0xffffff00
void platform_init() {
     5f4:	0000004e 	andeq	r0, r0, lr, asr #32
    pin_setup();
     5f8:	00000560 	andeq	r0, r0, r0, ror #10
    uart_init();
     5fc:	0000001c 	andeq	r0, r0, ip, lsl r0
    uart2_init();
     600:	04049c01 	streq	r9, [r4], #-3073	@ 0xfffff3ff
    set_read_char(ugetc);
     604:	746e6905 	strbtvc	r6, [lr], #-2309	@ 0xfffff6fb
    set_read_char2(u2getc);
     608:	02810500 	addeq	r0, r1, #0, 10
     60c:	13010000 	movwne	r0, #4096	@ 0x1000
    set_write_char(uputc);
     610:	00053c06 	andeq	r3, r5, r6, lsl #24
    set_write_char2(u2putc);
     614:	00002400 	andeq	r2, r0, r0, lsl #8
     618:	8d9c0100 	ldfhis	f0, [ip]
}
     61c:	06000000 	streq	r0, [r0], -r0
     620:	13010063 	movwne	r0, #4195	@ 0x1063
     624:	00008d12 	andeq	r8, r0, r2, lsl sp
     628:	0000bc00 	andeq	fp, r0, r0, lsl #24
int aes_test(int argc, char** argv) {
     62c:	0000b400 	andeq	fp, r0, r0, lsl #8
    uint8_t text[17] = "0123456789abcdef";
     630:	05580700 	ldrbeq	r0, [r8, #-1792]	@ 0xfffff900
     634:	00550000 	subseq	r0, r5, r0
     638:	01080000 	mrseq	r0, (UNDEF: 8)
     63c:	003d0150 	eorseq	r0, sp, r0, asr r1
     640:	08010900 	stmdaeq	r1, {r8, fp}
    printf("Plaintext is %s\n", text);
     644:	00000105 	andeq	r0, r0, r5, lsl #2
     648:	00017f00 	andeq	r7, r1, r0, lsl #30
    AES_ECB_encrypt(&ctx, text);
     64c:	01000500 	tsteq	r0, r0, lsl #10
     650:	00037b04 	andeq	r7, r3, r4, lsl #22
    len = encode_base64(text, 16, b64text);
     654:	00140800 	andseq	r0, r4, r0, lsl #16
     658:	c61d0000 	ldrgt	r0, [sp], -r0
     65c:	77000002 	strvc	r0, [r0, -r2]
    b64text[len] = '\0';
     660:	a0000001 	andge	r0, r0, r1
     664:	8c000005 	stchi	0, cr0, [r0], {5}
     668:	24000000 	strcs	r0, [r0], #-0
    printf("Encrypted/encoded is %s\n", b64text);
     66c:	01000005 	tsteq	r0, r5
     670:	00fe0601 	rscseq	r0, lr, r1, lsl #12
    printf2("FOB_MESG AESB64 %s\n", b64text);
     674:	02010000 	andeq	r0, r1, #0
     678:	00016805 	andeq	r6, r1, r5, lsl #16
    printf("Test the mesg handler with CAR_MESG AESB64 %s\n", b64text);
     67c:	05040100 	streq	r0, [r4, #-256]	@ 0xffffff00
     680:	00000158 	andeq	r0, r0, r8, asr r1
    len = decode_base64(b64text, len, decoded);
     684:	53050801 	movwpl	r0, #22529	@ 0x5801
     688:	01000001 	tsteq	r0, r1
     68c:	00fc0801 	rscseq	r0, ip, r1, lsl #16
    AES_ECB_decrypt(&ctx, decoded);
     690:	02010000 	andeq	r0, r1, #0
     694:	00010a07 	andeq	r0, r1, r7, lsl #20
    decoded[len] = '\0';
     698:	07040100 	streq	r0, [r4, -r0, lsl #2]
     69c:	00000122 	andeq	r0, r0, r2, lsr #2
     6a0:	1d070801 	stcne	8, cr0, [r7, #-4]
    printf("After encrypting->encoding->decoding->decrypting we recover %s\n", decoded);
     6a4:	09000001 	stmdbeq	r0, {r0}
     6a8:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
}
     6ac:	04010074 	streq	r0, [r1], #-116	@ 0xffffff8c
     6b0:	00012707 	andeq	r2, r1, r7, lsl #14
     6b4:	04080100 	streq	r0, [r8], #-256	@ 0xffffff00
     6b8:	0000019e 	muleq	r0, lr, r1
     6bc:	05080101 	streq	r0, [r8, #-257]	@ 0xfffffeff
     6c0:	04000001 	streq	r0, [r0], #-1
     6c4:	00000281 	andeq	r0, r0, r1, lsl #5
     6c8:	008b2202 	addeq	r2, fp, r2, lsl #4
     6cc:	73020000 	movwvc	r0, #8192	@ 0x2000
int pair(int argc, char** argv) {
     6d0:	00000000 	andeq	r0, r0, r0
    printf("Sending a pair request.\n");
     6d4:	00032304 	andeq	r2, r3, r4, lsl #6
    printf2("FOB_MESG PAIR\n");
     6d8:	9c780300 	ldclls	3, cr0, [r8], #-0
     6dc:	02000000 	andeq	r0, r0, #0
}
     6e0:	0000009c 	muleq	r0, ip, r0
     6e4:	00a10500 	adceq	r0, r1, r0, lsl #10
     6e8:	ac0a0000 	stcge	0, cr0, [sl], {-0}
int encode64(int argc, char** argv) {
     6ec:	02000000 	andeq	r0, r0, #0
    if (argc > 1) {
     6f0:	00000073 	andeq	r0, r0, r3, ror r0
     6f4:	023a0400 	eorseq	r0, sl, #0, 8
        len = strlen(argv[1]);
     6f8:	22040000 	andcs	r0, r4, #0
     6fc:	000000bd 	strheq	r0, [r0], -sp
        if (len < MAXARRAYLEN) {
     700:	00007302 	andeq	r7, r0, r2, lsl #6
            len = encode_base64((uint8_t *) argv[1], len, encoded);
     704:	14040000 	strne	r0, [r4], #-0
     708:	03000003 	movweq	r0, #3
            printf("Encoded %s as %s with %d characters\n", argv[1], encoded, len);
     70c:	0000ce77 	andeq	ip, r0, r7, ror lr
     710:	009c0200 	addseq	r0, ip, r0, lsl #4
     714:	06000000 	streq	r0, [r0], -r0
            printf("String exceeds max length of %d characters", MAXARRAYLEN);
     718:	00000288 	andeq	r0, r0, r8, lsl #5
     71c:	00005e02 	andeq	r5, r0, r2, lsl #28
     720:	03050400 	movweq	r0, #21504	@ 0x5400
        printf("Usage is 'encode64 string'\n");
     724:	6b030000 	blvs	c072c <__ROM_SIZE__+0x8072c>
}
     728:	000000e9 	andeq	r0, r0, r9, ror #1
     72c:	0000e902 	andeq	lr, r0, r2, lsl #18
     730:	ee050000 	cdp	0, 0, cr0, cr5, cr0, {0}
     734:	0b000000 	bleq	73c <decode64>
     738:	0000005e 	andeq	r0, r0, lr, asr r0
int decode64(int argc, char** argv) {
     73c:	00023406 	andeq	r3, r2, r6, lsl #8
    if (argc > 1) {
     740:	005e0400 	subseq	r0, lr, r0, lsl #8
     744:	33040000 	movwcc	r0, #16384	@ 0x4000
        int len = strlen(argv[1]);
     748:	03000003 	movweq	r0, #3
     74c:	00010e6a 	andeq	r0, r1, sl, ror #28
        if (len < MAXBASE64LEN) {
     750:	00e90200 	rsceq	r0, r9, r0, lsl #4
                len = decode_base64((uint8_t *) argv[1], len, plaintext);
     754:	07000000 	streq	r0, [r0, -r0]
     758:	00000276 	andeq	r0, r0, r6, ror r2
                plaintext[len] = '\0';
     75c:	022a0702 	eoreq	r0, sl, #524288	@ 0x80000
     760:	0c040000 	stceq	0, cr0, [r4], {-0}
     764:	00000341 	andeq	r0, r0, r1, asr #6
                printf("Decoded %s as: %s\n", argv[1], plaintext);
     768:	f4063801 	vst2.8	{d3-d4}, [r6], r1
     76c:	38000005 	stmdacc	r0, {r0, r2}
     770:	01000000 	mrseq	r0, (UNDEF: 0)
            printf("String exceeds max base64 string length of %d characters", MAXBASE64LEN);
     774:	0001709c 	muleq	r1, ip, r0
     778:	05fa0300 	ldrbeq	r0, [sl, #768]!	@ 0x300
     77c:	01700000 	cmneq	r0, r0
        printf("Usage is 'decode64 string'\n");
     780:	fe030000 	cdp2	0, 0, cr0, cr3, cr0, {0}
}
     784:	14000005 	strne	r0, [r0], #-5
     788:	03000001 	movweq	r0, #1
     78c:	00000602 	andeq	r0, r0, r2, lsl #12
     790:	0000010e 	andeq	r0, r0, lr, lsl #2
     794:	00060803 	andeq	r0, r6, r3, lsl #16
int ecdh_test(int argc, char** argv) {
     798:	0000fd00 	andeq	pc, r0, r0, lsl #26
    uint8_t b64privkey2[32] = "wP/uwP/uwP/uwP/uwP/uwP/uwP/uwP/u";
     79c:	060e0300 	streq	r0, [lr], -r0, lsl #6
     7a0:	00d80000 	sbcseq	r0, r8, r0
     7a4:	14030000 	strne	r0, [r3], #-0
     7a8:	bd000006 	stclt	0, cr0, [r0, #-24]	@ 0xffffffe8
     7ac:	03000000 	movweq	r0, #0
    printf("Testing the ecdh key exchange\n");
     7b0:	0000061a 	andeq	r0, r0, sl, lsl r6
     7b4:	0000008b 	andeq	r0, r0, fp, lsl #1
    decode_base64(ECDH_privkey_b64, 32, ECDH_privkey);
     7b8:	02fb0d00 	rscseq	r0, fp, #0, 26
     7bc:	22010000 	andcs	r0, r1, #0
     7c0:	0005a006 	andeq	sl, r5, r6
    decode_base64(b64privkey2, 32, privkey2);
     7c4:	00005400 	andeq	r5, r0, r0, lsl #8
     7c8:	009c0100 	addseq	r0, ip, r0, lsl #2
    ecdh_generate_keys(ECDH_pubkey, ECDH_privkey);
     7cc:	000003a5 	andeq	r0, r0, r5, lsr #7
     7d0:	04010005 	streq	r0, [r1], #-5
     7d4:	00000445 	andeq	r0, r0, r5, asr #8
    ecdh_generate_keys(pubkey2, privkey2);
     7d8:	00001410 	andeq	r1, r0, r0, lsl r4
     7dc:	036f1d00 	cmneq	pc, #0, 26
    ecdh_shared_secret(ECDH_privkey, pubkey2, ECDH_shared);
     7e0:	01770000 	cmneq	r7, r0
     7e4:	062c0000 	strteq	r0, [ip], -r0
     7e8:	00a40000 	adceq	r0, r4, r0
    ecdh_shared_secret(privkey2, ECDH_pubkey, sharedsecret2);
     7ec:	06500000 	ldrbeq	r0, [r0], -r0
     7f0:	01030000 	mrseq	r0, (UNDEF: 3)
    sha256_init(&shactx);
     7f4:	0000fe06 	andeq	pc, r0, r6, lsl #28
     7f8:	05020300 	streq	r0, [r2, #-768]	@ 0xfffffd00
	sha256_update(&shactx, ECDH_shared, ECC_PUB_KEY_SIZE);
     7fc:	00000168 	andeq	r0, r0, r8, ror #2
     800:	58050403 	stmdapl	r5, {r0, r1, sl}
	sha256_final(&shactx, ECDH_AESkey);
     804:	03000001 	movweq	r0, #1
     808:	01530508 	cmpeq	r3, r8, lsl #10
     80c:	340b0000 	strcc	r0, [fp], #-0
    len = encode_base64(ECDH_AESkey, AES_KEYLEN, b64test);
     810:	04000001 	streq	r0, [r0], #-1
     814:	004e182e 	subeq	r1, lr, lr, lsr #16
    b64test[len] = '\0';
     818:	01030000 	mrseq	r0, (UNDEF: 3)
     81c:	0000fc08 	andeq	pc, r0, r8, lsl #24
     820:	07020300 	streq	r0, [r2, -r0, lsl #6]
     824:	0000010a 	andeq	r0, r0, sl, lsl #2
    printf("First shared key is %s\n", b64test);
     828:	22070403 	andcs	r0, r7, #50331648	@ 0x3000000
     82c:	03000001 	movweq	r0, #1
    sha256_init(&shactx);
     830:	011d0708 	tsteq	sp, r8, lsl #14
    sha256_update(&shactx, sharedsecret2, ECC_PUB_KEY_SIZE);
     834:	04110000 	ldreq	r0, [r1], #-0
     838:	746e6905 	strbtvc	r6, [lr], #-2309	@ 0xfffff6fb
     83c:	07040300 	streq	r0, [r4, -r0, lsl #6]
	sha256_final(&shactx, keytest);
     840:	00000127 	andeq	r0, r0, r7, lsr #2
     844:	9e040803 	cdpls	8, 0, cr0, cr4, cr3, {0}
    len = encode_base64(keytest, AES_KEYLEN, b64test);
     848:	12000001 	andne	r0, r0, #1
     84c:	0000013c 	andeq	r0, r0, ip, lsr r1
    b64test[len] = '\0';
     850:	2c020100 	stfcss	f0, [r2], {-0}
     854:	0000a708 	andeq	sl, r0, r8, lsl #14
     858:	0c3f0600 	ldceq	6, cr0, [pc], #-0	@ 860 <ecdh_test+0xc8>
    printf("Should be same as %s\n", b64test);
     85c:	2e020000 	cdpcs	0, 0, cr0, cr2, cr0, {0}
     860:	0000ac0b 	andeq	sl, r0, fp, lsl #24
    printf("Switching fob AES key to new value. Try AES tests now.\n");
     864:	49130000 	ldmdbmi	r3, {}	@ <UNPREDICTABLE>
     868:	30020076 	andcc	r0, r2, r6, ror r0
    AES_init_ctx(&ctx, ECDH_AESkey);
     86c:	0000bc0b 	andeq	fp, r0, fp, lsl #24
     870:	0c00f000 	stceq	0, cr15, [r0], {-0}
}
     874:	0000007f 	andeq	r0, r0, pc, ror r0
     878:	00004209 	andeq	r4, r0, r9, lsl #4
     87c:	0000bc00 	andeq	fp, r0, r0, lsl #24
     880:	00710700 	rsbseq	r0, r1, r0, lsl #14
     884:	00ef0000 	rsceq	r0, pc, r0
     888:	00004209 	andeq	r4, r0, r9, lsl #4
     88c:	0000cc00 	andeq	ip, r0, r0, lsl #24
     890:	00710700 	rsbseq	r0, r1, r0, lsl #14
     894:	000f0000 	andeq	r0, pc, r0
     898:	646d6314 	strbtvs	r6, [sp], #-788	@ 0xfffffcec
     89c:	0f2f0300 	svceq	0x002f0300
     8a0:	000000d8 	ldrdeq	r0, [r0], -r8
int send_ping(int argc, char** argv) {
     8a4:	0000dd05 	andeq	sp, r0, r5, lsl #26
    printf("Pinging the car.\n");
     8a8:	006a1500 	rsbeq	r1, sl, r0, lsl #10
    printf2("FOB_MESG PING\n");
     8ac:	00f10000 	rscseq	r0, r1, r0
     8b0:	6a020000 	bvs	808b8 <__ROM_SIZE__+0x408b8>
}
     8b4:	02000000 	andeq	r0, r0, #0
     8b8:	000000f1 	strdeq	r0, [r0], -r1
     8bc:	00f60500 	rscseq	r0, r6, r0, lsl #10
int sha256_test(int argc, char** argv) {
     8c0:	fb050000 	blx	1408ca <__ROM_SIZE__+0x1008ca>
    printf("Starting sha256 test\n");
     8c4:	03000000 	movweq	r0, #0
     8c8:	01050801 	tsteq	r5, r1, lsl #16
    BYTE text1[] = {"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"};
     8cc:	fb0c0000 	blx	3008d6 <__ROM_SIZE__+0x2c08d6>
     8d0:	16000000 	strne	r0, [r0], -r0
     8d4:	0938030c 	ldmdbeq	r8!, {r2, r3, r8, r9}
     8d8:	00000138 	andeq	r0, r0, r8, lsr r1
     8dc:	0000c406 	andeq	ip, r0, r6, lsl #8
     8e0:	0f390300 	svceq	0x00390300
     8e4:	00000138 	andeq	r0, r0, r8, lsr r1
     8e8:	00000600 	andeq	r0, r0, r0, lsl #12
     8ec:	3a030000 	bcc	c08f4 <__ROM_SIZE__+0x808f4>
    BYTE hash1[SHA256_BLOCK_SIZE] = {0x24,0x8d,0x6a,0x61,0xd2,0x06,0x38,0xb8,0xe5,0xc0,0x26,0x93,0x0c,0x3e,0x60,0x39,
     8f0:	0001380f 	andeq	r3, r1, pc, lsl #16
     8f4:	bc060400 	cfstrslt	mvf0, [r6], {-0}
     8f8:	03000000 	movweq	r0, #0
     8fc:	00cc073b 	sbceq	r0, ip, fp, lsr r7
    sha256_init(&shactx);
     900:	00080000 	andeq	r0, r8, r0
	sha256_update(&shactx, text1, strlen((char *)text1));
     904:	00010205 	andeq	r0, r1, r5, lsl #4
     908:	01980b00 	orrseq	r0, r8, r0, lsl #22
     90c:	3c030000 	stccc	0, cr0, [r3], {-0}
     910:	00010703 	andeq	r0, r1, r3, lsl #14
	sha256_final(&shactx, buf);
     914:	74631700 	strbtvc	r1, [r3], #-1792	@ 0xfffff900
     918:	04010078 	streq	r0, [r1], #-120	@ 0xffffff88
    len = encode_base64(hash1, SHA256_BLOCK_SIZE, b64_hash1);
     91c:	00007f17 	andeq	r7, r0, r7, lsl pc
     920:	03a91800 			@ <UNDEFINED> instruction: 0x03a91800
     924:	22010000 	andcs	r0, r1, #0
    b64_hash1[len] = '\0';
     928:	00013d01 	andeq	r3, r1, r1, lsl #26
    len = encode_base64(buf, SHA256_BLOCK_SIZE, b64_buf);
     92c:	4c030500 	cfstr32mi	mvfx0, [r3], {-0}
     930:	0d000028 	stceq	0, cr0, [r0, #-160]	@ 0xffffff60
     934:	000000df 	ldrdeq	r0, [r0], -pc	@ <UNPREDICTABLE>
    b64_buf[len] = '\0';
     938:	00017c3f 	andeq	r7, r1, pc, lsr ip
    printf("Base64 of SHA-256 test is %s\n", b64_buf);
     93c:	017c0200 	cmneq	ip, r0, lsl #4
     940:	81020000 	mrshi	r0, (UNDEF: 2)
    printf("Should be %s\n", b64_hash1);
     944:	00000001 	andeq	r0, r0, r1
     948:	0000a705 	andeq	sl, r0, r5, lsl #14
}
     94c:	00420500 	subeq	r0, r2, r0, lsl #10
     950:	d1080000 	mrsle	r0, (UNDEF: 8)
     954:	05000000 	streq	r0, [r0, #-0]
     958:	00710e4a 	rsbseq	r0, r1, sl, asr #28
     95c:	01a60000 			@ <UNDEFINED> instruction: 0x01a60000
     960:	a6020000 	strge	r0, [r2], -r0
void __attribute__((optimize("O0"), weak)) initial_setup(void) {
     964:	02000001 	andeq	r0, r0, #1
     968:	00000071 	andeq	r0, r0, r1, ror r0
  char *src = &_etext, *dst = &_data;
     96c:	0001a602 	andeq	sl, r1, r2, lsl #12
     970:	4e050000 	cdpmi	0, 0, cr0, cr5, cr0, {0}
  if (dst != src)
     974:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
     978:	0000034f 	andeq	r0, r0, pc, asr #6
    while (dst < &_edata) *(dst++) = *(src++);
     97c:	6a052d06 	bvs	14bd9c <__ROM_SIZE__+0x10bd9c>
     980:	c2000000 	andgt	r0, r0, #0
     984:	02000001 	andeq	r0, r0, #1
     988:	00000138 	andeq	r0, r0, r8, lsr r1
     98c:	9b08000e 	blls	2009cc <__ROM_SIZE__+0x1c09cc>
     990:	05000003 	streq	r0, [r0, #-3]
  for (dst = &_bss; dst < &_ebss; dst++) *dst = 0;
     994:	00710e3d 	rsbseq	r0, r1, sp, lsr lr
     998:	01e20000 	mvneq	r0, r0
     99c:	a6020000 	strge	r0, [r2], -r0
     9a0:	02000001 	andeq	r0, r0, #1
     9a4:	00000071 	andeq	r0, r0, r1, ror r0
     9a8:	0001a602 	andeq	sl, r1, r2, lsl #12
     9ac:	570d0000 	strpl	r0, [sp, -r0]
  platform_init();
     9b0:	3e000003 	cdpcc	0, 0, cr0, cr0, cr3, {0}
}
     9b4:	000001f7 	strdeq	r0, [r0], -r7
     9b8:	00017c02 	andeq	r7, r1, r2, lsl #24
     9bc:	01810200 	orreq	r0, r1, r0, lsl #4
     9c0:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
     9c4:	00000161 	andeq	r0, r0, r1, ror #2
     9c8:	6a052c06 	bvs	14b9e8 <__ROM_SIZE__+0x10b9e8>
     9cc:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
static void delete(void) {
     9d0:	02000002 	andeq	r0, r0, #2
  __write_char__(BACK_SPACE);
     9d4:	00000138 	andeq	r0, r0, r8, lsr r1
     9d8:	ad19000e 	ldcge	0, cr0, [r9, #-56]	@ 0xffffffc8
  __write_char__(SPACE);
     9dc:	01000003 	tsteq	r0, r3
  __write_char__(BACK_SPACE);
     9e0:	006a0507 	rsbeq	r0, sl, r7, lsl #10
     9e4:	062c0000 	strteq	r0, [ip], -r0
}
     9e8:	00a40000 	adceq	r0, r4, r0
static void clear_prompt(int char_count) {
     9ec:	9c010000 	stcls	0, cr0, [r1], {-0}
  while (char_count) {
     9f0:	0000038c 	andeq	r0, r0, ip, lsl #7
    delete ();
     9f4:	0001720f 	andeq	r7, r1, pc, lsl #4
  while (char_count) {
     9f8:	006a1200 	rsbeq	r1, sl, r0, lsl #4
}
     9fc:	00e70000 	rsceq	r0, r7, r0
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
     a00:	00e30000 	rsceq	r0, r3, r0
    auto_load[i].command(0, NULL);
     a04:	b70f0000 	strlt	r0, [pc, -r0]
     a08:	1f000000 	svcne	0x00000000
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
     a0c:	000000f1 	strdeq	r0, [r0], -r1
     a10:	000000fa 	strdeq	r0, [r0], -sl
     a14:	000000f6 	strdeq	r0, [r0], -r6
     a18:	00036a0a 	andeq	r6, r3, sl, lsl #20
     a1c:	038c0900 	orreq	r0, ip, #0, 18
}
     a20:	91020000 	mrsls	r0, (UNDEF: 2)
static int show_history(int argc, char **argv) {
     a24:	656c1a5c 	strbvs	r1, [ip, #-2652]!	@ 0xfffff5a4
  uint32_t end_index = total_num_commands-1;
     a28:	0b01006e 	bleq	40be8 <__ROM_SIZE__+0xbe8>
  if (total_num_commands > NUM_HISTORY_ENTRIES) {
     a2c:	00007112 	andeq	r7, r0, r2, lsl r1
     a30:	00011300 	andeq	r1, r1, r0, lsl #6
    beg_index = total_num_commands - NUM_HISTORY_ENTRIES;
     a34:	00010900 	andeq	r0, r1, r0, lsl #18
     a38:	03670a00 	cmneq	r7, #0, 20
  uint32_t beg_index = 0;
     a3c:	9c110000 	ldcls	0, cr0, [r1], {-0}
    printf("%s\n", cmd_history[index % NUM_HISTORY_ENTRIES]);
     a40:	02000003 	andeq	r0, r0, #3
     a44:	440a4091 	strmi	r4, [sl], #-145	@ 0xffffff6f
     a48:	18000001 	stmdane	r0, {r0}
     a4c:	0000038c 	andeq	r0, r0, ip, lsl #7
  for (uint32_t index = beg_index; index <= end_index; ++index) {
     a50:	7fac9103 	svcvc	0x00ac9103
}
     a54:	00064a04 	andeq	r4, r6, r4, lsl #20
     a58:	0001f700 	andeq	pc, r1, r0, lsl #14
     a5c:	0002a500 	andeq	sl, r2, r0, lsl #10
     a60:	50010100 	andpl	r0, r1, r0, lsl #2
int cmd_exec_status(int argc, char **argv) {
     a64:	2a380305 	bcs	e01680 <__ROM_SIZE__+0xdc1680>
  printf("%d\n", __cmd_exec_status);
     a68:	01010000 	mrseq	r0, (UNDEF: 1)
     a6c:	5c910251 	lfmpl	f0, 4, [r1], {81}	@ 0x51
     a70:	06540400 	ldrbeq	r0, [r4], -r0, lsl #8
}
     a74:	01e20000 	mvneq	r0, r0
     a78:	02bf0000 	adcseq	r0, pc, #0
     a7c:	01010000 	mrseq	r0, (UNDEF: 1)
static int build_info(int argc, char **argv) {
     a80:	00760250 	rsbseq	r0, r6, r0, asr r2
  printf("Build: [" SHELL_VERSION ":" USER_REPO_VERSION "] - [" BUILD_USER
     a84:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
}
     a88:	04005c91 	streq	r5, [r0], #-3217	@ 0xfffff36f
     a8c:	0000065e 	andeq	r0, r0, lr, asr r6
static void execute(int argc, char **argv) {
     a90:	000001c2 	andeq	r0, r0, r2, asr #3
     a94:	000002de 	ldrdeq	r0, [r0], -lr
  for (int i = 0; table[i].command_name != NULL; i++) {
     a98:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
     a9c:	01015c91 			@ <UNDEFINED> instruction: 0x01015c91
     aa0:	01400151 	cmpeq	r0, r1, asr r1
     aa4:	91025201 	tstls	r2, r1, lsl #4
     aa8:	74040040 	strvc	r0, [r4], #-64	@ 0xffffffc0
    if (strcmp(argv[0], table[i].command_name) == 0) {
     aac:	f7000006 			@ <UNDEFINED> instruction: 0xf7000006
     ab0:	fb000001 	blx	abe <execute+0x2e>
      __cmd_exec_status = table[i].command(argc, &argv[0]);
     ab4:	01000002 	tsteq	r0, r2
     ab8:	03055001 	movweq	r5, #20481	@ 0x5001
     abc:	00002a4c 	andeq	r2, r0, ip, asr #20
     ac0:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
     ac4:	04004091 	streq	r4, [r0], #-145	@ 0xffffff6f
    printf("\"%s\": command not found. Use \"help\" to list all command.\n",
     ac8:	0000067c 	andeq	r0, r0, ip, ror r6
     acc:	000001ab 	andeq	r0, r0, fp, lsr #3
    __cmd_exec_status = -1;
     ad0:	00000318 	andeq	r0, r0, r8, lsl r3
     ad4:	05500101 	ldrbeq	r0, [r0, #-257]	@ 0xfffffeff
     ad8:	002a6803 	eoreq	r6, sl, r3, lsl #16
}
     adc:	51010100 	mrspl	r0, (UNDEF: 17)
     ae0:	00409102 	subeq	r9, r0, r2, lsl #2
     ae4:	00068404 	andeq	r8, r6, r4, lsl #8
     ae8:	0001f700 	andeq	pc, r1, r0, lsl #14
int help(int argc, char **argv) {
     aec:	00033500 	andeq	r3, r3, r0, lsl #10
  if (argc > 1 && (strcmp(argv[1], "-l")==0)) {
     af0:	50010100 	andpl	r0, r1, r0, lsl #2
     af4:	2a7c0305 	bcs	1f01710 <__ROM_SIZE__+0x1ec1710>
     af8:	01010000 	mrseq	r0, (UNDEF: 1)
     afc:	40910251 	addsmi	r0, r1, r1, asr r2
    printf("use: help -l for list only.\n\n");
     b00:	068e0400 	streq	r0, [lr], r0, lsl #8
  bool verbose = true;
     b04:	01860000 	orreq	r0, r6, r0
    verbose = false;
     b08:	03560000 	cmpeq	r6, #0
    printf("\n");
     b0c:	01010000 	mrseq	r0, (UNDEF: 1)
    i++;
     b10:	40910250 	addsmi	r0, r1, r0, asr r2
  while (table[i].command_name != NULL) {
     b14:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
     b18:	01010074 	tsteq	r1, r4, ror r0
     b1c:	ac910352 	ldcge	3, cr0, [r1], {82}	@ 0x52
    printf(table[i].command_name);
     b20:	9804007f 	stmdals	r4, {r0, r1, r2, r3, r4, r5, r6}
    if (verbose) {
     b24:	67000006 	strvs	r0, [r0, -r6]
      printf("\n\t");
     b28:	71000001 	tstvc	r0, r1
      printf(table[i].command_help);
     b2c:	01000003 	tsteq	r0, r3
     b30:	76025001 	strvc	r5, [r2], -r1
     b34:	51010100 	mrspl	r0, (UNDEF: 17)
    verbose = false;
     b38:	7fac9103 	svcvc	0x00ac9103
}
     b3c:	06ac1b00 	strteq	r1, [ip], r0, lsl #22
     b40:	01f70000 	mvnseq	r0, r0
     b44:	01010000 	mrseq	r0, (UNDEF: 1)
     b48:	ac030550 	cfstr32ge	mvfx0, [r3], {80}	@ 0x50
     b4c:	0100002a 	tsteq	r0, sl, lsr #32
     b50:	91035101 	tstls	r3, r1, lsl #2
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
     b54:	00007fac 	andeq	r7, r0, ip, lsr #31
static void add_command_to_history(const char *cmd_str) {
     b58:	00004209 	andeq	r4, r0, r9, lsl #4
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
     b5c:	00039c00 	andeq	r9, r3, r0, lsl #24
     b60:	00710700 	rsbseq	r0, r1, r0, lsl #14
  int index = total_num_commands % NUM_HISTORY_ENTRIES;
     b64:	00100000 	andseq	r0, r0, r0
     b68:	0000421c 	andeq	r4, r0, ip, lsl r2
     b6c:	00710700 	rsbseq	r0, r1, r0, lsl #14
     b70:	00180000 	andseq	r0, r8, r0
  memcpy(&cmd_history[index], cmd_str, LINE_BUFF_SIZE);
     b74:	00018b00 	andeq	r8, r1, r0, lsl #22
     b78:	01000500 	tsteq	r0, r0, lsl #10
     b7c:	0005db04 	andeq	sp, r5, r4, lsl #22
     b80:	00140900 	andseq	r0, r4, r0, lsl #18
  total_num_commands++;
     b84:	bf1d0000 	svclt	0x001d0000
  curr_command_ptr = total_num_commands;
     b88:	77000003 	strvc	r0, [r0, -r3]
     b8c:	d0000001 	andle	r0, r0, r1
     b90:	1c000006 	stcne	0, cr0, [r0], {6}
     b94:	09000000 	stmdbeq	r0, {}	@ <UNPREDICTABLE>
     b98:	01000008 	tsteq	r0, r8
static int parse_line(char **argv, char *line_buff, int argument_size) {
     b9c:	00fe0601 	rscseq	r0, lr, r1, lsl #12
     ba0:	02010000 	andeq	r0, r1, #0
  int length = strlen(line_buff);
     ba4:	00016805 	andeq	r6, r1, r5, lsl #16
     ba8:	05040100 	streq	r0, [r4, #-256]	@ 0xffffff00
  int argc = 0;
     bac:	00000158 	andeq	r0, r0, r8, asr r1
         pos++)
     bb0:	53050801 	movwpl	r0, #22529	@ 0x5801
    for (; line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
     bb4:	01000001 	tsteq	r0, r1
     bb8:	00fc0801 	rscseq	r0, ip, r1, lsl #16
     bbc:	02010000 	andeq	r0, r1, #0
     bc0:	00010a07 	andeq	r0, r1, r7, lsl #20
    if (line_buff[pos] == '\t' || line_buff[pos] == SPACE)
     bc4:	07040100 	streq	r0, [r4, -r0, lsl #2]
     bc8:	00000122 	andeq	r0, r0, r2, lsr #2
      line_buff[pos] = END_OF_LINE;
     bcc:	1d070801 	stcne	8, cr0, [r7, #-4]
  while (pos <= length) {
     bd0:	0a000001 	beq	bdc <parse_line+0x40>
    if (line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
     bd4:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
     bd8:	04010074 	streq	r0, [r1], #-116	@ 0xffffff8c
     bdc:	00012707 	andeq	r2, r1, r7, lsl #14
     be0:	04080100 	streq	r0, [r8], #-256	@ 0xffffff00
      argv[argc++] = &line_buff[pos];
     be4:	0000019e 	muleq	r0, lr, r1
     be8:	646d630b 	strbtvs	r6, [sp], #-779	@ 0xfffffcf5
}
     bec:	0f2f0200 	svceq	0x002f0200
static int prefix_match(char *sub, int len, const char *str) {
     bf0:	0000007f 	andeq	r0, r0, pc, ror r0
     bf4:	00008402 	andeq	r8, r0, r2, lsl #8
  if (sub == NULL || str == NULL || len <= 0 || len > strlen(str)) {
     bf8:	005e0c00 	subseq	r0, lr, r0, lsl #24
     bfc:	00980000 	addseq	r0, r8, r0
     c00:	5e030000 	cdppl	0, 0, cr0, cr3, cr0, {0}
     c04:	03000000 	movweq	r0, #0
  for (int i = 0; i<len; ++i) {
     c08:	00000098 	muleq	r0, r8, r0
     c0c:	009d0200 	addseq	r0, sp, r0, lsl #4
    if (sub[i] != str[i]) {
     c10:	a2020000 	andge	r0, r2, #0
     c14:	01000000 	mrseq	r0, (UNDEF: 0)
  for (int i = 0; i<len; ++i) {
     c18:	01050801 	tsteq	r5, r1, lsl #16
}
     c1c:	a20d0000 	andge	r0, sp, #0
  return TRUE;
     c20:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
      return FALSE;
     c24:	0938020c 	ldmdbeq	r8!, {r2, r3, r9}
}
     c28:	000000dc 	ldrdeq	r0, [r0], -ip
static void handle_up_arrow(char *cmd_buff, int *char_count) {
     c2c:	0000c404 	andeq	ip, r0, r4, lsl #8
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
     c30:	dc0f3900 			@ <UNDEFINED> instruction: 0xdc0f3900
     c34:	00000000 	andeq	r0, r0, r0
     c38:	00000004 	andeq	r0, r0, r4
     c3c:	dc0f3a00 			@ <UNDEFINED> instruction: 0xdc0f3a00
      curr_command_ptr == 0) {
     c40:	04000000 	streq	r0, [r0], #-0
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
     c44:	0000bc04 	andeq	fp, r0, r4, lsl #24
    printf("%s", cmd_buff);
     c48:	73073b00 	movwvc	r3, #31488	@ 0x7b00
     c4c:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
     c50:	00a90200 	adceq	r0, r9, r0, lsl #4
     c54:	980f0000 	stmdals	pc, {}	@ <UNPREDICTABLE>
  curr_command_ptr--;
     c58:	02000001 	andeq	r0, r0, #1
     c5c:	00ae033c 	adceq	r0, lr, ip, lsr r3
     c60:	b6100000 	ldrlt	r0, [r0], -r0
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
     c64:	01000003 	tsteq	r0, r3
     c68:	00e1010c 	rsceq	r0, r1, ip, lsl #2
     c6c:	03050000 	movweq	r0, #20480	@ 0x5000
     c70:	00002858 	andeq	r2, r0, r8, asr r8
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
     c74:	00034f05 	andeq	r4, r3, r5, lsl #30
     c78:	005e2d00 	subseq	r2, lr, r0, lsl #26
     c7c:	01140000 	tsteq	r4, r0
  *char_count = strlen(cmd_buff);
     c80:	dc030000 	stcle	0, cr0, [r3], {-0}
     c84:	06000000 	streq	r0, [r0], -r0
  printf("%s", cmd_buff);
     c88:	01610500 	cmneq	r1, r0, lsl #10
     c8c:	5e2c0000 	cdppl	0, 2, cr0, cr12, cr0, {0}
     c90:	29000000 	stmdbcs	r0, {}	@ <UNPREDICTABLE>
     c94:	03000001 	movweq	r0, #1
     c98:	000000dc 	ldrdeq	r0, [r0], -ip
static void handle_down_arrow(char *cmd_buff, int *char_count) {
     c9c:	ba110006 	blt	440cbc <__ROM_SIZE__+0x400cbc>
     ca0:	01000003 	tsteq	r0, r3
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
     ca4:	005e0505 	subseq	r0, lr, r5, lsl #10
     ca8:	06d00000 	ldrbeq	r0, [r0], r0
  *char_count = 0;
     cac:	001c0000 	andseq	r0, ip, r0
  if (curr_command_ptr == total_num_commands) return;
     cb0:	9c010000 	stcls	0, cr0, [r1], {-0}
     cb4:	00017207 	andeq	r7, r1, r7, lsl #4
     cb8:	005e0e00 	subseq	r0, lr, r0, lsl #28
  curr_command_ptr++;
     cbc:	01400000 	mrseq	r0, (UNDEF: 64)
     cc0:	013c0000 	teqeq	ip, r0
     cc4:	b7070000 	strlt	r0, [r7, -r0]
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
     cc8:	1b000000 	blne	cd0 <handle_down_arrow+0x34>
     ccc:	00000098 	muleq	r0, r8, r0
     cd0:	00000152 	andeq	r0, r0, r2, asr r1
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
     cd4:	0000014e 	andeq	r0, r0, lr, asr #2
     cd8:	0006d812 	andeq	sp, r6, r2, lsl r8
     cdc:	00011400 	andeq	r1, r1, r0, lsl #8
     ce0:	00017a00 	andeq	r7, r1, r0, lsl #20
  *char_count = strlen(cmd_buff);
     ce4:	50010800 	andpl	r0, r1, r0, lsl #16
     ce8:	2b2c0305 	blcs	b01904 <__ROM_SIZE__+0xac1904>
  printf("%s", cmd_buff);
     cec:	13000000 	movwne	r0, #0
     cf0:	000006de 	ldrdeq	r0, [r0], -lr
}
     cf4:	000000ff 	strdeq	r0, [r0], -pc	@ <UNPREDICTABLE>
     cf8:	05500108 	ldrbeq	r0, [r0, #-264]	@ 0xfffffef8
void set_read_char(int (*func)(void)) { __read_char__ = func; }
     cfc:	002b4803 	eoreq	r4, fp, r3, lsl #16
     d00:	00000000 	andeq	r0, r0, r0
     d04:	00000362 	andeq	r0, r0, r2, ror #6
void set_read_char2(int (*func)(void)) { __read_char2__ = func; }
     d08:	04010005 	streq	r0, [r1], #-5
     d0c:	000006e6 	andeq	r0, r0, r6, ror #13
     d10:	00001412 	andeq	r1, r0, r2, lsl r4
void set_write_char(void (*func)(char)) { __write_char__ = func; }
     d14:	04061d00 	streq	r1, [r6], #-3328	@ 0xfffff300
     d18:	01770000 	cmneq	r7, r0
     d1c:	06ec0000 	strbteq	r0, [ip], r0
void set_write_char2(void (*func)(char)) { __write_char2__ = func; }
     d20:	00ac0000 	adceq	r0, ip, r0
     d24:	08d30000 	ldmeq	r3, {}^	@ <UNPREDICTABLE>
     d28:	01020000 	mrseq	r0, (UNDEF: 2)
}
     d2c:	0000fe06 	andeq	pc, r0, r6, lsl #28
}
     d30:	05020200 	streq	r0, [r2, #-512]	@ 0xfffffe00
  if (cmd_buff == NULL || char_count <= 0) {
     d34:	00000168 	andeq	r0, r0, r8, ror #2
static void handle_tab(char *cmd_buff, int *char_count) {
     d38:	58050402 	stmdapl	r5, {r1, sl}
     d3c:	02000001 	andeq	r0, r0, #1
  int last_match = -1;
     d40:	01530508 	cmpeq	r3, r8, lsl #10
  int match_count = 0;
     d44:	34080000 	strcc	r0, [r8], #-0
  int i = 0;
     d48:	02000001 	andeq	r0, r0, #1
    i++;
     d4c:	004e182e 	subeq	r1, lr, lr, lsr #16
  while (table[i].command_name != NULL) { //loop over all commands
     d50:	01020000 	mrseq	r0, (UNDEF: 2)
     d54:	0000fc08 	andeq	pc, r0, r8, lsl #24
     d58:	07020200 	streq	r0, [r2, -r0, lsl #4]
    if (prefix_match(cmd_buff, *char_count, table[i].command_name)) {
     d5c:	0000010a 	andeq	r0, r0, sl, lsl #2
     d60:	22070402 	andcs	r0, r7, #33554432	@ 0x2000000
     d64:	02000001 	andeq	r0, r0, #1
      match_count++;
     d68:	011d0708 	tsteq	sp, r8, lsl #14
      printf("\n%s", table[i].command_name);
     d6c:	04130000 	ldreq	r0, [r3], #-0
     d70:	746e6905 	strbtvc	r6, [lr], #-2309	@ 0xfffff6fb
      last_match = i;
     d74:	07040200 	streq	r0, [r4, -r0, lsl #4]
  if (match_count == 1) {
     d78:	00000127 	andeq	r0, r0, r7, lsr #2
     d7c:	00000d08 	andeq	r0, r0, r8, lsl #26
  if (match_count) {
     d80:	17d60300 	ldrbne	r0, [r6, r0, lsl #6]
}
     d84:	00000071 	andeq	r0, r0, r1, ror r0
    memcpy(cmd_buff, table[last_match].command_name, LINE_BUFF_SIZE);
     d88:	9e040802 	cdpls	8, 0, cr0, cr4, cr2, {0}
     d8c:	14000001 	strne	r0, [r0], #-1
     d90:	00646d63 	rsbeq	r6, r4, r3, ror #26
     d94:	970f2f04 	strls	r2, [pc, -r4, lsl #30]
    *char_count = strlen(cmd_buff);
     d98:	04000000 	streq	r0, [r0], #-0
     d9c:	0000009c 	muleq	r0, ip, r0
     da0:	00006a15 	andeq	r6, r0, r5, lsl sl
    printf("\n");
     da4:	0000b000 	andeq	fp, r0, r0
     da8:	006a0300 	rsbeq	r0, sl, r0, lsl #6
    prepend_prompt();
     dac:	b0030000 	andlt	r0, r3, r0
    printf(PROMPT);
     db0:	00000000 	andeq	r0, r0, r0
     db4:	0000b504 	andeq	fp, r0, r4, lsl #10
    printf("%s", cmd_buff);
     db8:	00ba0400 	adcseq	r0, sl, r0, lsl #8
     dbc:	01020000 	mrseq	r0, (UNDEF: 2)
     dc0:	00010508 	andeq	r0, r1, r8, lsl #10
     dc4:	00ba1600 	adcseq	r1, sl, r0, lsl #12
     dc8:	0c170000 	ldceq	0, cr0, [r7], {-0}
     dcc:	f4093804 	vst2.8	{d3-d4}, [r9], r4
     dd0:	09000000 	stmdbeq	r0, {}	@ <UNPREDICTABLE>
__attribute__((weak)) int active_prompt() { return TRUE; }
     dd4:	000000c4 	andeq	r0, r0, r4, asr #1
static void shell(void) {
     dd8:	00f40f39 	rscseq	r0, r4, r9, lsr pc
  int count = 0;
     ddc:	09000000 	stmdbeq	r0, {}	@ <UNPREDICTABLE>
  for (int i = 0; i < LINE_BUFF_SIZE; i++) line_buff[i] = 0;
     de0:	00000000 	andeq	r0, r0, r0
     de4:	00f40f3a 	rscseq	r0, r4, sl, lsr pc
     de8:	09040000 	stmdbeq	r4, {}	@ <UNPREDICTABLE>
     dec:	000000bc 	strheq	r0, [r0], -ip
     df0:	008b073b 	addeq	r0, fp, fp, lsr r7
  for (int i = 0; i < MAX_ARG_COUNT; i++) argv[i] = NULL;
     df4:	00080000 	andeq	r0, r8, r0
     df8:	0000c104 	andeq	ip, r0, r4, lsl #2
     dfc:	01980800 	orrseq	r0, r8, r0, lsl #16
     e00:	3c040000 	stccc	0, cr0, [r4], {-0}
     e04:	0000c603 	andeq	ip, r0, r3, lsl #12
  prepend_prompt();
     e08:	04300c00 	ldrteq	r0, [r0], #-3072	@ 0xfffff400
  printf(PROMPT);
     e0c:	f9390000 			@ <UNDEFINED> instruction: 0xf9390000
  int special_key = 0;
     e10:	05000000 	streq	r0, [r0, #-0]
        special_key = 1;
     e14:	00287003 	eoreq	r7, r8, r3
    if (s == -1) { s = __read_char2__();}
     e18:	03e70c00 	mvneq	r0, #0, 24
     e1c:	f93a0000 			@ <UNDEFINED> instruction: 0xf93a0000
    if (s != -1) {
     e20:	05000000 	streq	r0, [r0, #-0]
     e24:	00286403 	eoreq	r6, r8, r3, lsl #8
      loop();
     e28:	00d10600 	sbcseq	r0, r1, r0, lsl #12
        line_buff[count] = END_OF_LINE;
     e2c:	4a050000 	bmi	140e34 <__ROM_SIZE__+0x100e34>
     e30:	0000710e 	andeq	r7, r0, lr, lsl #2
     e34:	00014500 	andeq	r4, r1, r0, lsl #10
     e38:	01450300 	mrseq	r0, (UNDEF: 117)
        __write_char__(NEW_LINE);
     e3c:	71030000 	mrsvc	r0, (UNDEF: 3)
     e40:	03000000 	movweq	r0, #0
  add_command_to_history(line_buff);
     e44:	00000145 	andeq	r0, r0, r5, asr #2
  argc = parse_line(argv, line_buff, MAX_ARG_COUNT);
     e48:	004e0400 	subeq	r0, lr, r0, lsl #8
     e4c:	61060000 	mrsvs	r0, (UNDEF: 6)
     e50:	06000001 	streq	r0, [r0], -r1
  if (argc > 0) execute(argc, argv);
     e54:	006a052c 	rsbeq	r0, sl, ip, lsr #10
}
     e58:	01610000 	cmneq	r1, r0
        if (!__echo) {
     e5c:	f4030000 	vst4.8	{d0-d3}, [r3], r0
     e60:	18000000 	stmdane	r0, {}	@ <UNPREDICTABLE>
        if (count == 0) continue;
     e64:	039b0600 	orrseq	r0, fp, #0, 12
        count--;
     e68:	3d050000 	stccc	0, cr0, [r5, #-0]
        line_buff[count] = END_OF_LINE;
     e6c:	0000710e 	andeq	r7, r0, lr, lsl #2
     e70:	00018100 	andeq	r8, r1, r0, lsl #2
     e74:	01450300 	mrseq	r0, (UNDEF: 117)
        delete ();
     e78:	71030000 	mrsvc	r0, (UNDEF: 3)
      if (__echo) {
     e7c:	03000000 	movweq	r0, #0
        __write_char__(c);
     e80:	00000145 	andeq	r0, r0, r5, asr #2
     e84:	01aa0600 			@ <UNDEFINED> instruction: 0x01aa0600
    if (!active_prompt()) {
     e88:	1f070000 	svcne	0x00070000
     e8c:	00007808 	andeq	r7, r0, r8, lsl #16
    s = __read_char__();
     e90:	00019700 	andeq	r9, r1, r0, lsl #14
     e94:	00f40300 	rscseq	r0, r4, r0, lsl #6
    if (s == -1) { s = __read_char2__();}
     e98:	0d000000 	stceq	0, cr0, [r0, #-0]
     e9c:	000003eb 	andeq	r0, r0, fp, ror #7
      if (c == CARRIAGE_RETURN || c == NEW_LINE) {
     ea0:	00006a20 	andeq	r6, r0, r0, lsr #20
     ea4:	00073c00 	andeq	r3, r7, r0, lsl #24
      if (c == DELETE || c == BACK_SPACE) {
     ea8:	00005c00 	andeq	r5, r0, r0, lsl #24
     eac:	759c0100 	ldrvc	r0, [ip, #256]	@ 0x100
      } else if (c == ESCAPE) {
     eb0:	07000002 	streq	r0, [r0, -r2]
      } else if (c == SQUARE_BRACKET_OPEN && special_key == 1) {
     eb4:	00000172 	andeq	r0, r0, r2, ror r1
      } else if ((c == 'C' || c == 'D') && special_key != 0) {
     eb8:	006a1220 	rsbeq	r1, sl, r0, lsr #4
     ebc:	01740000 	cmneq	r4, r0
     ec0:	016c0000 	cmneq	ip, r0
      } else if ((c == 'A' || c == 'B') && special_key == 2) {
     ec4:	b7070000 	strlt	r0, [r7, -r0]
     ec8:	20000000 	andcs	r0, r0, r0
      else if (c == TAB) {
     ecc:	0000b01f 	andeq	fp, r0, pc, lsl r0
        line_buff[count] = c;
     ed0:	00019c00 	andeq	r9, r1, r0, lsl #24
     ed4:	00019400 	andeq	r9, r1, r0, lsl #8
     ed8:	07460a00 	strbeq	r0, [r6, -r0, lsl #20]
        count++;
     edc:	00380000 	eorseq	r0, r8, r0
     ee0:	02610000 	rsbeq	r0, r1, #0
          delete ();
     ee4:	6c0e0000 	stcvs	0, cr0, [lr], {-0}
          delete ();
     ee8:	24006e65 	strcs	r6, [r0], #-3685	@ 0xfffff19b
      } else if (c == SQUARE_BRACKET_OPEN && special_key == 1) {
     eec:	0000006a 	andeq	r0, r0, sl, rrx
        special_key = 2;
     ef0:	000001c3 	andeq	r0, r0, r3, asr #3
      } else if ((c == 'C' || c == 'D') && special_key != 0) {
     ef4:	000001b9 			@ <UNDEFINED> instruction: 0x000001b9
        special_key = 0;
     ef8:	0007520a 	andeq	r5, r7, sl, lsl #4
      } else if ((c == 'A' || c == 'B') && special_key == 2) {
     efc:	00002000 	andeq	r2, r0, r0
        if (!__echo) {
     f00:	00023e00 	andeq	r3, r2, r0, lsl #28
     f04:	03f40f00 	mvnseq	r0, #0, 30
          clear_prompt(count + 4);
     f08:	19280000 	stmdbne	r8!, {}	@ <UNPREDICTABLE>
     f0c:	00000275 	andeq	r0, r0, r5, ror r2
        if (c == 'A') {
     f10:	7f909103 	svcvc	0x00909103
          handle_down_arrow(line_buff, &count);
     f14:	00075a0b 	andeq	r5, r7, fp, lsl #20
     f18:	00012500 	andeq	r2, r1, r0, lsl #10
        continue;
     f1c:	00022400 	andeq	r2, r2, r0, lsl #8
          clear_prompt(count);
     f20:	52010100 	andpl	r0, r1, #0, 2
     f24:	00007d02 	andeq	r7, r0, r2, lsl #26
          handle_up_arrow(line_buff, &count);
     f28:	00077205 	andeq	r7, r7, r5, lsl #4
     f2c:	00014a00 	andeq	r4, r1, r0, lsl #20
        handle_tab(line_buff, &count);
     f30:	50010100 	andpl	r0, r1, r0, lsl #2
     f34:	2bf80305 	blcs	ffe01b50 <_STACK_TOP_+0xdfdf9b54>
        continue;
     f38:	01010000 	mrseq	r0, (UNDEF: 1)
  if (argc > 0) execute(argc, argv);
     f3c:	007d0252 	rsbseq	r0, sp, r2, asr r2
}
     f40:	4c100000 	ldcmi	0, cr0, [r0], {-0}
     f44:	81000007 	tsthi	r0, r7
     f48:	05000001 	streq	r0, [r0, #-1]
     f4c:	0000077c 	andeq	r0, r0, ip, ror r7
void prompt() {
     f50:	0000014a 	andeq	r0, r0, sl, asr #2
  initial_setup();
     f54:	05500101 	ldrbeq	r0, [r0, #-257]	@ 0xfffffeff
  exec_auto_cmds();
     f58:	002c0c03 	eoreq	r0, ip, r3, lsl #24
  setup();
     f5c:	51010100 	mrspl	r0, (UNDEF: 17)
  decode_base64(AES_key_b64, 44, AES_key);
     f60:	00800802 	addeq	r0, r0, r2, lsl #16
     f64:	07840500 	streq	r0, [r4, r0, lsl #10]
     f68:	014a0000 	mrseq	r0, (UNDEF: 74)
     f6c:	01010000 	mrseq	r0, (UNDEF: 1)
  AES_init_ctx(&ctx, AES_key);
     f70:	48030550 	stmdami	r3, {r4, r6, r8, sl}
     f74:	0000002c 	andeq	r0, r0, ip, lsr #32
    shell();
     f78:	00421900 	subeq	r1, r2, r0, lsl #18
  while (TRUE) {
     f7c:	02850000 	addeq	r0, r5, #0
     f80:	71110000 	tstvc	r1, r0
     f84:	64000000 	strvs	r0, [r0], #-0
int exec(char *cmd_str) {
     f88:	04340d00 	ldrteq	r0, [r4], #-3328	@ 0xfffff300
     f8c:	6a090000 	bvs	240f94 <__ROM_SIZE__+0x200f94>
  argc = parse_line(argv, cmd_str, MAX_ARG_COUNT);
     f90:	ec000000 	stc	0, cr0, [r0], {-0}
     f94:	50000006 	andpl	r0, r0, r6
  if (argc > 0) execute(argc, argv);
     f98:	01000000 	mrseq	r0, (UNDEF: 0)
  return __cmd_exec_status;
     f9c:	0003599c 	muleq	r3, ip, r9
}
     fa0:	01720700 	cmneq	r2, r0, lsl #14
     fa4:	12090000 	andne	r0, r9, #0
  if (argc > 0) execute(argc, argv);
     fa8:	0000006a 	andeq	r0, r0, sl, rrx
     fac:	000001ea 	andeq	r0, r0, sl, ror #3
     fb0:	000001e2 	andeq	r0, r0, r2, ror #3
cmd get_function_addr(char *cmd_str) {
     fb4:	0000b707 	andeq	fp, r0, r7, lsl #14
  for (int i = 0; table[i].command_name != NULL; i++) {
     fb8:	b01f0900 	andslt	r0, pc, r0, lsl #18
     fbc:	0d000000 	stceq	0, cr0, [r0, #-0]
     fc0:	05000002 	streq	r0, [r0, #-2]
     fc4:	0a000002 	beq	fd4 <get_function_addr+0x20>
     fc8:	000006f6 	strdeq	r0, [r0], -r6
    if (strcmp(cmd_str, table[i].command_name) == 0) {
     fcc:	0000002c 	andeq	r0, r0, ip, lsr #32
     fd0:	00000345 	andeq	r0, r0, r5, asr #6
      return table[i].command;
     fd4:	0003fe0f 	andeq	pc, r3, pc, lsl #28
     fd8:	59110d00 	ldmdbpl	r1, {r8, sl, fp}
  return NULL;
     fdc:	03000003 	movweq	r0, #3
}
     fe0:	0e7ef891 	mrceq	8, 3, APSR_nzcv, cr14, cr1, {4}
  if(v < 26) return v + 'A';
     fe4:	006e656c 	rsbeq	r6, lr, ip, ror #10
  if(v < 52) return v + 71;
     fe8:	00006a0e 	andeq	r6, r0, lr, lsl #20
  if(v < 62) return v - 4;
     fec:	00022f00 	andeq	r2, r2, r0, lsl #30
  if(v == 62) return '+';
     ff0:	00022500 	andeq	r2, r2, r0, lsl #10
  if(v == 63) return '/';
     ff4:	06fc1000 	ldrbteq	r1, [ip], r0
  return 64;
     ff8:	01810000 	orreq	r0, r1, r0
  if(v < 26) return v + 'A';
     ffc:	0a0b0000 	beq	2c1004 <__ROM_SIZE__+0x281004>
    1000:	61000007 	tstvs	r0, r7
  if(v < 52) return v + 71;
    1004:	0e000001 	cdpeq	0, 0, cr0, cr0, cr1, {0}
  if(v < 62) return v - 4;
    1008:	01000003 	tsteq	r0, r3
    100c:	7d025201 	sfmvc	f5, 4, [r2, #-4]
  if(v == 62) return '+';
    1010:	160b0000 	strne	r0, [fp], -r0
}
    1014:	4a000007 	bmi	1038 <base64_to_binary+0x22>
  if('A' <= c && c <= 'Z') return c - 'A';
    1018:	2b000001 	blcs	1024 <base64_to_binary+0xe>
    101c:	01000003 	tsteq	r0, r3
  if('a' <= c && c <= 'z') return c - 71;
    1020:	03055001 	movweq	r5, #20481	@ 0x5001
    1024:	00002b88 	andeq	r2, r0, r8, lsl #23
    1028:	02520101 	subseq	r0, r2, #1073741824	@ 0x40000000
  if('0' <= c && c <= '9') return c + 4;
    102c:	0500007d 	streq	r0, [r0, #-125]	@ 0xffffff83
    1030:	00000720 	andeq	r0, r0, r0, lsr #14
  if(c == '+') return 62;
    1034:	0000014a 	andeq	r0, r0, sl, asr #2
  if(c == '/') return 63;
    1038:	05500101 	ldrbeq	r0, [r0, #-257]	@ 0xfffffeff
  return 255;
    103c:	002bb003 	eoreq	fp, fp, r3
  if('a' <= c && c <= 'z') return c - 71;
    1040:	51010100 	mrspl	r0, (UNDEF: 17)
    1044:	00640802 	rsbeq	r0, r4, r2, lsl #16
  if('0' <= c && c <= '9') return c + 4;
    1048:	07280500 	streq	r0, [r8, -r0, lsl #10]!
  if(c == '+') return 62;
    104c:	014a0000 	mrseq	r0, (UNDEF: 74)
  if(c == '/') return 63;
    1050:	01010000 	mrseq	r0, (UNDEF: 1)
  return (input_length + 2)/3*4;
    1054:	dc030550 	cfstr32le	mvfx0, [r3], {80}	@ 0x50
    1058:	0000002b 	andeq	r0, r0, fp, lsr #32
    105c:	00421a00 	subeq	r1, r2, r0, lsl #20
}
    1060:	71110000 	tstvc	r1, r0
    1064:	7f000000 	svcvc	0x00000000
unsigned int decode_base64_length(unsigned char input[], unsigned int input_length) {
    1068:	06450000 	strbeq	r0, [r5], -r0
    106c:	00050000 	andeq	r0, r5, r0
  while(base64_to_binary(input[0]) < 64 && (unsigned int) (input - start) < input_length) {
    1070:	08490401 	stmdaeq	r9, {r0, sl}^
    1074:	14110000 	ldrne	r0, [r1], #-0
    1078:	1d000000 	stcne	0, cr0, [r0, #-0]
    107c:	000004cb 	andeq	r0, r0, fp, asr #9
    1080:	00000177 	andeq	r0, r0, r7, ror r1
  input_length = input - start;
    1084:	00000798 	muleq	r0, r8, r7
  return input_length/4*3 + (input_length % 4 ? input_length % 4 - 1 : 0);
    1088:	0000010c 	andeq	r0, r0, ip, lsl #2
    108c:	00000ae7 	andeq	r0, r0, r7, ror #21
    1090:	fe060104 	cdp2	1, 0, cr0, cr6, cr4, {0}
}
    1094:	04000000 	streq	r0, [r0], #-0
  return input_length/4*3 + (input_length % 4 ? input_length % 4 - 1 : 0);
    1098:	01680502 	cmneq	r8, r2, lsl #10
unsigned int encode_base64(unsigned char input[], unsigned int input_length, unsigned char output[]) {
    109c:	04040000 	streq	r0, [r4], #-0
    10a0:	00015805 	andeq	r5, r1, r5, lsl #16
    10a4:	05080400 	streq	r0, [r8, #-1024]	@ 0xfffffc00
  unsigned int full_sets = input_length/3;
    10a8:	00000153 	andeq	r0, r0, r3, asr r1
    10ac:	0001340a 	andeq	r3, r1, sl, lsl #8
  for(unsigned int i = 0; i < full_sets; ++i) {
    10b0:	182e0200 	stmdane	lr!, {r9}
    output[0] = binary_to_base64(                         input[0] >> 2);
    10b4:	00000053 	andeq	r0, r0, r3, asr r0
    10b8:	0000420e 	andeq	r4, r0, lr, lsl #4
    output[1] = binary_to_base64((input[0] & 0x03) << 4 | input[1] >> 4);
    10bc:	08010400 	stmdaeq	r1, {sl}
    10c0:	000000fc 	strdeq	r0, [r0], -ip
    10c4:	0a070204 	beq	1c18dc <__ROM_SIZE__+0x1818dc>
    10c8:	04000001 	streq	r0, [r0], #-1
    10cc:	01220704 			@ <UNDEFINED> instruction: 0x01220704
    output[2] = binary_to_base64((input[1] & 0x0F) << 2 | input[2] >> 6);
    10d0:	08040000 	stmdaeq	r4, {}	@ <UNPREDICTABLE>
    10d4:	00011d07 	andeq	r1, r1, r7, lsl #26
    10d8:	05041200 	streq	r1, [r4, #-512]	@ 0xfffffe00
    10dc:	00746e69 	rsbseq	r6, r4, r9, ror #28
    10e0:	27070404 	strcs	r0, [r7, -r4, lsl #8]
    output[3] = binary_to_base64( input[2] & 0x3F);
    10e4:	0a000001 	beq	10f0 <encode_base64+0x54>
    10e8:	0000000d 	andeq	r0, r0, sp
    10ec:	7617d603 	ldrvc	sp, [r7], -r3, lsl #12
    input += 3;
    10f0:	04000000 	streq	r0, [r0], #-0
  for(unsigned int i = 0; i < full_sets; ++i) {
    10f4:	019e0408 	orrseq	r0, lr, r8, lsl #8
    10f8:	3c130000 	ldccc	0, cr0, [r3], {-0}
  switch(input_length % 3) {
    10fc:	00000001 	andeq	r0, r0, r1
    1100:	082c0501 	stmdaeq	ip!, {r0, r8, sl}
    1104:	000000b8 	strheq	r0, [r0], -r8
    1108:	000c3f06 	andeq	r3, ip, r6, lsl #30
    110c:	0b2e0500 	bleq	b82514 <__ROM_SIZE__+0xb42514>
    1110:	000000b8 	strheq	r0, [r0], -r8
    1114:	76491400 	strbvc	r1, [r9], -r0, lsl #8
  return encode_base64_length(input_length);
    1118:	0b300500 	bleq	c02520 <__ROM_SIZE__+0xbc2520>
}
    111c:	000000c8 	andeq	r0, r0, r8, asr #1
      output[0] = '\0';
    1120:	420700f0 	andmi	r0, r7, #240	@ 0xf0
      output[0] = binary_to_base64(                         input[0] >> 2);
    1124:	c8000000 	stmdagt	r0, {}	@ <UNPREDICTABLE>
    1128:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
    112c:	00000076 	andeq	r0, r0, r6, ror r0
      output[1] = binary_to_base64((input[0] & 0x03) << 4);
    1130:	420700ef 	andmi	r0, r7, #239	@ 0xef
    1134:	d8000000 	stmdale	r0, {}	@ <UNPREDICTABLE>
    1138:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
      output[2] = '=';
    113c:	00000076 	andeq	r0, r0, r6, ror r0
      output[3] = '=';
    1140:	780a000f 	stmdavc	sl, {r0, r1, r2, r3}
      output[4] = '\0';
    1144:	04000004 	streq	r0, [r0], #-4
      output[0] = binary_to_base64(                         input[0] >> 2);
    1148:	00531713 	subseq	r1, r3, r3, lsl r7
    114c:	d80e0000 	stmdale	lr, {}	@ <UNPREDICTABLE>
    1150:	0a000000 	beq	1158 <encode_base64+0xbc>
      output[1] = binary_to_base64((input[0] & 0x03) << 4 | input[1] >> 4);
    1154:	00000459 	andeq	r0, r0, r9, asr r4
    1158:	76171404 	ldrvc	r1, [r7], -r4, lsl #8
    115c:	0f000000 	svceq	0x00000000
    1160:	32160470 	andscc	r0, r6, #112, 8	@ 0x70000000
    1164:	06000001 	streq	r0, [r0], -r1
      output[2] = binary_to_base64((input[1] & 0x0F) << 2);
    1168:	00000738 	andeq	r0, r0, r8, lsr r7
    116c:	32071704 	andcc	r1, r7, #4, 14	@ 0x100000
    1170:	00000001 	andeq	r0, r0, r1
      output[3] = '=';
    1174:	00045106 	andeq	r5, r4, r6, lsl #2
      output[4] = '\0';
    1178:	07180400 	ldreq	r0, [r8, -r0, lsl #8]
      break;
    117c:	000000e9 	andeq	r0, r0, r9, ror #1
    1180:	05090640 	streq	r0, [r9, #-1600]	@ 0xfffff9c0
unsigned int decode_base64(unsigned char input[], unsigned int input_length, unsigned char output[]) {
    1184:	19040000 	stmdbne	r4, {}	@ <UNPREDICTABLE>
    1188:	00006815 	andeq	r6, r0, r5, lsl r8
  unsigned int output_length = decode_base64_length(input, input_length);
    118c:	9a064800 	bls	193194 <__ROM_SIZE__+0x153194>
    1190:	0400000a 	streq	r0, [r0], #-10
  for(unsigned int i = 2; i < output_length; i += 3) {
    1194:	0142071a 	cmpeq	r2, sl, lsl r7
    output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
    1198:	00500000 	subseq	r0, r0, r0
    119c:	0000d807 	andeq	sp, r0, r7, lsl #16
    11a0:	00014200 	andeq	r4, r1, r0, lsl #4
    11a4:	00760800 	rsbseq	r0, r6, r0, lsl #16
    11a8:	003f0000 	eorseq	r0, pc, r0
    output[1] = base64_to_binary(input[1]) << 4 | base64_to_binary(input[2]) >> 2;
    11ac:	0000e907 	andeq	lr, r0, r7, lsl #18
    11b0:	00015200 	andeq	r5, r1, r0, lsl #4
    11b4:	00760800 	rsbseq	r0, r6, r0, lsl #16
    11b8:	00070000 	andeq	r0, r7, r0
    11bc:	0005100a 	andeq	r1, r5, sl
    output[2] = base64_to_binary(input[2]) << 6 | base64_to_binary(input[3]);
    11c0:	031b0400 	tsteq	fp, #0, 8
    11c4:	000000f5 	strdeq	r0, [r0], -r5
    11c8:	646d6315 	strbtvs	r6, [sp], #-789	@ 0xfffffceb
    11cc:	0f2f0600 	svceq	0x002f0600
    input += 4;
    11d0:	0000016a 	andeq	r0, r0, sl, ror #2
  for(unsigned int i = 2; i < output_length; i += 3) {
    11d4:	00016f05 	andeq	r6, r1, r5, lsl #30
    11d8:	006f1600 	rsbeq	r1, pc, r0, lsl #12
  switch(output_length % 3) {
    11dc:	01830000 	orreq	r0, r3, r0
    11e0:	6f020000 	svcvs	0x00020000
    11e4:	02000000 	andeq	r0, r0, #0
    11e8:	00000183 	andeq	r0, r0, r3, lsl #3
    11ec:	01880500 	orreq	r0, r8, r0, lsl #10
    11f0:	8d050000 	stchi	0, cr0, [r5, #-0]
    11f4:	04000001 	streq	r0, [r0], #-1
    11f8:	01050801 	tsteq	r5, r1, lsl #16
      output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
    11fc:	8d0e0000 	stchi	0, cr0, [lr, #-0]
    1200:	0f000001 	svceq	0x00000001
    1204:	c938060c 	ldmdbgt	r8!, {r2, r3, r9, sl}
    1208:	06000001 	streq	r0, [r0], -r1
    120c:	000000c4 	andeq	r0, r0, r4, asr #1
      output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
    1210:	c90f3906 	stmdbgt	pc, {r1, r2, r8, fp, ip, sp}	@ <UNPREDICTABLE>
    1214:	00000001 	andeq	r0, r0, r1
    1218:	00000006 	andeq	r0, r0, r6
    121c:	0f3a0600 	svceq	0x003a0600
    1220:	000001c9 	andeq	r0, r0, r9, asr #3
      output[1] = base64_to_binary(input[1]) << 4 | base64_to_binary(input[2]) >> 2;
    1224:	00bc0604 	adcseq	r0, ip, r4, lsl #12
    1228:	3b060000 	blcc	181230 <__ROM_SIZE__+0x141230>
    122c:	00015e07 	andeq	r5, r1, r7, lsl #28
    1230:	05000800 	streq	r0, [r0, #-2048]	@ 0xfffff800
    1234:	00000194 	muleq	r0, r4, r1
  return output_length;
    1238:	0001980a 	andeq	r9, r1, sl, lsl #16
    123c:	033c0600 	teqeq	ip, #0, 12
{
    1240:	00000199 	muleq	r0, r9, r1
    1244:	00004207 	andeq	r4, r0, r7, lsl #4
	for (i = 0, j = 0; i < 16; ++i, j += 4)
    1248:	0001e500 	andeq	lr, r1, r0, lsl #10
    124c:	0b001700 	bleq	6e54 <base_order+0x383c>
		m[i] = (data[j] << 24) | (data[j + 1] << 16) | (data[j + 2] << 8) | (data[j + 3]);
    1250:	000004f8 	strdeq	r0, [r0], -r8
    1254:	0001da03 	andeq	sp, r1, r3, lsl #20
    1258:	04440b00 	strbeq	r0, [r4], #-2816	@ 0xfffff500
    125c:	da040000 	ble	101264 <__ROM_SIZE__+0xc1264>
    1260:	0b000001 	bleq	126c <sha256_transform+0x2c>
    1264:	00000559 	andeq	r0, r0, r9, asr r5
    1268:	0001da05 	andeq	sp, r1, r5, lsl #20
	for (i = 0, j = 0; i < 16; ++i, j += 4)
    126c:	05650b00 	strbeq	r0, [r5, #-2816]!	@ 0xfffff500
    1270:	da060000 	ble	181278 <__ROM_SIZE__+0x141278>
		m[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16];
    1274:	0b000001 	bleq	1280 <sha256_transform+0x40>
    1278:	0000046c 	andeq	r0, r0, ip, ror #8
    127c:	0001da07 	andeq	sp, r1, r7, lsl #20
    1280:	74631800 	strbtvc	r1, [r3], #-2048	@ 0xfffff800
    1284:	09010078 	stmdbeq	r1, {r3, r4, r5, r6}
    1288:	00009017 	andeq	r9, r0, r7, lsl r0
    128c:	048a1900 	streq	r1, [sl], #2304	@ 0x900
    1290:	3b010000 	blcc	41298 <__ROM_SIZE__+0x1298>
    1294:	0001ce01 	andeq	ip, r1, r1, lsl #28
    1298:	7c030500 	cfstr32vc	mvfx0, [r3], {-0}
    129c:	0d000028 	stceq	0, cr0, [r0, #-160]	@ 0xffffff60
    12a0:	00000529 	andeq	r0, r0, r9, lsr #10
    12a4:	024b3405 	subeq	r3, fp, #83886080	@ 0x5000000
    12a8:	4b020000 	blmi	812b0 <__ROM_SIZE__+0x412b0>
    12ac:	02000002 	andeq	r0, r0, #2
    12b0:	00000250 	andeq	r0, r0, r0, asr r2
    12b4:	00900500 	addseq	r0, r0, r0, lsl #10
	for ( ; i < 64; ++i)
    12b8:	4e050000 	cdpmi	0, 0, cr0, cr5, cr0, {0}
    12bc:	0c000000 	stceq	0, cr0, [r0], {-0}
	a = ctx->state[0];
    12c0:	0000039b 	muleq	r0, fp, r3
	b = ctx->state[1];
    12c4:	760e3d07 	strvc	r3, [lr], -r7, lsl #26
	c = ctx->state[2];
    12c8:	75000000 	strvc	r0, [r0, #-0]
	d = ctx->state[3];
    12cc:	02000002 	andeq	r0, r0, #2
	e = ctx->state[4];
    12d0:	00000275 	andeq	r0, r0, r5, ror r2
	f = ctx->state[5];
    12d4:	00007602 	andeq	r7, r0, r2, lsl #12
    12d8:	02750200 	rsbseq	r0, r5, #0, 4
	g = ctx->state[6];
    12dc:	05000000 	streq	r0, [r0, #-0]
	h = ctx->state[7];
    12e0:	00000053 	andeq	r0, r0, r3, asr r0
    12e4:	00047d0d 	andeq	r7, r4, sp, lsl #26
	d = ctx->state[3];
    12e8:	90200400 	eorls	r0, r0, r0, lsl #8
	b = ctx->state[1];
    12ec:	02000002 	andeq	r0, r0, #2
	for (i = 0; i < 64; ++i) {
    12f0:	00000290 	muleq	r0, r0, r2
    12f4:	00029502 	andeq	r9, r2, r2, lsl #10
    12f8:	52050000 	andpl	r0, r5, #0
    12fc:	05000001 	streq	r0, [r0, #-1]
		t1 = h + EP1(e) + CH(e,f,g) + k[i] + m[i];
    1300:	000000d8 	ldrdeq	r0, [r0], -r8
    1304:	00051b0d 	andeq	r1, r5, sp, lsl #22
    1308:	b51f0400 	ldrlt	r0, [pc, #-1024]	@ f10 <shell+0x138>
    130c:	02000002 	andeq	r0, r0, #2
    1310:	00000290 	muleq	r0, r0, r2
    1314:	0002b502 	andeq	fp, r2, r2, lsl #10
    1318:	007d0200 	rsbseq	r0, sp, r0, lsl #4
    131c:	05000000 	streq	r0, [r0, #-0]
    1320:	000000e4 	andeq	r0, r0, r4, ror #1
    1324:	0004980d 	andeq	r9, r4, sp, lsl #16
    1328:	cb1e0400 	blgt	782330 <__ROM_SIZE__+0x742330>
		t2 = EP0(a) + MAJ(a,b,c);
    132c:	02000002 	andeq	r0, r0, #2
    1330:	00000290 	muleq	r0, r0, r2
    1334:	05460c00 	strbeq	r0, [r6, #-3072]	@ 0xfffff400
    1338:	61080000 	mrsvs	r0, (UNDEF: 8)
    133c:	00006f05 	andeq	r6, r0, r5, lsl #30
    1340:	0002eb00 	andeq	lr, r2, r0, lsl #22
    1344:	02500200 	subseq	r0, r0, #0, 4
    1348:	50020000 	andpl	r0, r2, r0
		h = g;
    134c:	02000002 	andeq	r0, r0, #2
		f = e;
    1350:	000002eb 	andeq	r0, r0, fp, ror #5
		e = d + t1;
    1354:	00420500 	subeq	r0, r2, r0, lsl #10
		c = b;
    1358:	a40c0000 	strge	r0, [ip], #-0
		a = t1 + t2;
    135c:	08000004 	stmdaeq	r0, {r2}
	for (i = 0; i < 64; ++i) {
    1360:	006f055e 	rsbeq	r0, pc, lr, asr r5	@ <UNPREDICTABLE>
	ctx->state[0] += a;
    1364:	030b0000 	movweq	r0, #45056	@ 0xb000
    1368:	eb020000 	bl	81370 <__ROM_SIZE__+0x41370>
    136c:	02000002 	andeq	r0, r0, #2
    1370:	000002eb 	andeq	r0, r0, fp, ror #5
    1374:	00d10c00 	sbcseq	r0, r1, r0, lsl #24
	ctx->state[1] += b;
    1378:	4a070000 	bmi	1c1380 <__ROM_SIZE__+0x181380>
	ctx->state[2] += c;
    137c:	0000760e 	andeq	r7, r0, lr, lsl #12
    1380:	00032b00 	andeq	r2, r3, r0, lsl #22
	ctx->state[3] += d;
    1384:	02750200 	rsbseq	r0, r5, #0, 4
	ctx->state[4] += e;
    1388:	76020000 	strvc	r0, [r2], -r0
    138c:	02000000 	andeq	r0, r0, #0
	ctx->state[5] += f;
    1390:	00000275 	andeq	r0, r0, r5, ror r2
    1394:	01610c00 	cmneq	r1, r0, lsl #24
	ctx->state[6] += g;
    1398:	2c090000 	stccs	0, cr0, [r9], {-0}
    139c:	00006f05 	andeq	r6, r0, r5, lsl #30
	ctx->state[7] += h;
    13a0:	00034200 	andeq	r4, r3, r0, lsl #4
    13a4:	01c90200 	biceq	r0, r9, r0, lsl #4
}
    13a8:	001a0000 	andseq	r0, sl, r0
    13ac:	00048e1b 	andeq	r8, r4, fp, lsl lr
    13b0:	050c0100 	streq	r0, [ip, #-256]	@ 0xffffff00
	ctx->datalen = 0;
    13b4:	0000006f 	andeq	r0, r0, pc, rrx
	ctx->bitlen = 0;
    13b8:	00000798 	muleq	r0, r8, r7
    13bc:	0000010c 	andeq	r0, r0, ip, lsl #2
	ctx->state[0] = 0x6a09e667;
    13c0:	060c9c01 	streq	r9, [ip], -r1, lsl #24
	ctx->state[1] = 0xbb67ae85;
    13c4:	72100000 	andsvc	r0, r0, #0
	ctx->state[2] = 0x3c6ef372;
    13c8:	13000001 	movwne	r0, #1
	ctx->state[3] = 0xa54ff53a;
    13cc:	0000006f 	andeq	r0, r0, pc, rrx
	ctx->state[4] = 0x510e527f;
    13d0:	00000259 	andeq	r0, r0, r9, asr r2
	ctx->state[5] = 0x9b05688c;
    13d4:	00000255 	andeq	r0, r0, r5, asr r2
	ctx->state[6] = 0x1f83d9ab;
    13d8:	0000b710 	andeq	fp, r0, r0, lsl r7
	ctx->state[7] = 0x5be0cd19;
    13dc:	01832000 	orreq	r2, r3, r0
    13e0:	026c0000 	rsbeq	r0, ip, #0
    13e4:	02680000 	rsbeq	r0, r8, #0
    13e8:	bf090000 	svclt	0x00090000
}
    13ec:	0e000004 	cdpeq	0, 0, cr0, cr0, cr4, {0}
    13f0:	00060c0d 	andeq	r0, r6, sp, lsl #24
    13f4:	50910200 	addspl	r0, r1, r0, lsl #4
    13f8:	0004c209 	andeq	ip, r4, r9, lsl #4
    13fc:	1c0d0f00 	stcne	15, cr0, [sp], {-0}
    1400:	03000006 	movweq	r0, #6
    1404:	097fb891 	ldmdbeq	pc!, {r0, r4, r7, fp, ip, sp, pc}^	@ <UNPREDICTABLE>
{
    1408:	00000536 	andeq	r0, r0, r6, lsr r5
    140c:	062c0d10 			@ <UNDEFINED> instruction: 0x062c0d10
	for (i = 0; i < len; ++i) {
    1410:	91030000 	mrsls	r0, (UNDEF: 3)
    1414:	5e097f88 	cdppl	15, 0, cr7, cr9, cr8, {4}
    1418:	11000004 	tstne	r0, r4
		ctx->data[ctx->datalen] = data[i];
    141c:	00061c0d 	andeq	r1, r6, sp, lsl #24
		ctx->datalen++;
    1420:	f0910300 			@ <UNDEFINED> instruction: 0xf0910300
		if (ctx->datalen == 64) {
    1424:	04b7097e 	ldrteq	r0, [r7], #2430	@ 0x97e
			sha256_transform(ctx, ctx->data);
    1428:	0d120000 	ldceq	0, cr0, [r2, #-0]
    142c:	0000060c 	andeq	r0, r0, ip, lsl #12
			ctx->bitlen += 512;
    1430:	7ed09103 	atnvcs	f1, f3
    1434:	00053e09 	andeq	r3, r5, r9, lsl #28
    1438:	3c0d1300 	stccc	3, cr1, [sp], {-0}
    143c:	03000006 	movweq	r0, #6
			ctx->datalen = 0;
    1440:	1c7ea091 	ldclne	0, cr10, [lr], #-580	@ 0xfffffdbc
    1444:	006e656c 	rsbeq	r6, lr, ip, ror #10
{
    1448:	6f091401 	svcvs	0x00091401
    144c:	85000000 	strhi	r0, [r0, #-0]
	if (ctx->datalen < 56) {
    1450:	7b000002 	blvc	1460 <sha256_final+0x18>
		ctx->data[i++] = 0x80;
    1454:	09000002 	stmdbeq	r0, {r1}
    1458:	0000043d 	andeq	r0, r0, sp, lsr r4
			ctx->data[i++] = 0x00;
    145c:	01521021 	cmpeq	r2, r1, lsr #32
    1460:	91030000 	mrsls	r0, (UNDEF: 3)
		while (i < 56)
    1464:	b6037db0 			@ <UNDEFINED> instruction: 0xb6037db0
	ctx->bitlen += ctx->datalen * 8;
    1468:	2b000007 	blcs	148c <sha256_final+0x44>
    146c:	13000003 	movwne	r0, #3
    1470:	01000004 	tsteq	r0, r4
    1474:	03055001 	movweq	r5, #20481	@ 0x5001
	ctx->data[63] = ctx->bitlen;
    1478:	00002cac 	andeq	r2, r0, ip, lsr #25
	ctx->data[62] = ctx->bitlen >> 8;
    147c:	07c20300 	strbeq	r0, [r2, r0, lsl #6]
    1480:	030b0000 	movweq	r0, #45056	@ 0xb000
	ctx->data[61] = ctx->bitlen >> 16;
    1484:	042d0000 	strteq	r0, [sp], #-0
	ctx->data[60] = ctx->bitlen >> 24;
    1488:	01010000 	mrseq	r0, (UNDEF: 1)
    148c:	20080251 	andcs	r0, r8, r1, asr r2
	ctx->data[59] = ctx->bitlen >> 32;
    1490:	02520101 	subseq	r0, r2, #1073741824	@ 0x40000000
	ctx->data[58] = ctx->bitlen >> 40;
    1494:	03000074 	movweq	r0, #116	@ 0x74
	ctx->data[57] = ctx->bitlen >> 48;
    1498:	000007cc 	andeq	r0, r0, ip, asr #15
    149c:	0000030b 	andeq	r0, r0, fp, lsl #6
	ctx->data[56] = ctx->bitlen >> 56;
    14a0:	0000044e 	andeq	r0, r0, lr, asr #8
	sha256_transform(ctx, ctx->data);
    14a4:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    14a8:	01015091 	swpeq	r5, r1, [r1]	@ <UNPREDICTABLE>
	for (i = 0; i < 4; ++i) {
    14ac:	20080251 	andcs	r0, r8, r1, asr r2
		ctx->data[i++] = 0x80;
    14b0:	03520101 	cmpeq	r2, #1073741824	@ 0x40000000
    14b4:	007fb891 			@ <UNDEFINED> instruction: 0x007fb891
			ctx->data[i++] = 0x00;
    14b8:	0007d603 	andeq	sp, r7, r3, lsl #12
    14bc:	0002f000 	andeq	pc, r2, r0
		while (i < 64)
    14c0:	00046800 	andeq	r6, r4, r0, lsl #16
		sha256_transform(ctx, ctx->data);
    14c4:	50010100 	andpl	r0, r1, r0, lsl #2
    14c8:	01007602 	tsteq	r0, r2, lsl #12
		memset(ctx->data, 0, 56);
    14cc:	74025101 	strvc	r5, [r2], #-257	@ 0xfffffeff
    14d0:	de030000 	cdple	0, 0, cr0, cr3, cr0, {0}
    14d4:	f0000007 			@ <UNDEFINED> instruction: 0xf0000007
		hash[i]      = (ctx->state[0] >> (24 - i * 8)) & 0x000000ff;
    14d8:	84000002 	strhi	r0, [r0], #-2
    14dc:	01000004 	tsteq	r0, r4
    14e0:	91035001 	tstls	r3, r1
		hash[i + 4]  = (ctx->state[1] >> (24 - i * 8)) & 0x000000ff;
    14e4:	01017f88 	smlabbeq	r1, r8, pc, r7	@ <UNPREDICTABLE>
    14e8:	b8910351 	ldmlt	r1, {r0, r4, r6, r8, r9}
		hash[i + 8]  = (ctx->state[2] >> (24 - i * 8)) & 0x000000ff;
    14ec:	ea03007f 	b	c16f0 <__ROM_SIZE__+0x816f0>
    14f0:	cb000007 	blgt	1514 <sha256_final+0xcc>
		hash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0x000000ff;
    14f4:	a5000002 	strge	r0, [r0, #-2]
    14f8:	01000004 	tsteq	r0, r4
    14fc:	74025001 	strvc	r5, [r2], #-1
		hash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0x000000ff;
    1500:	51010100 	mrspl	r0, (UNDEF: 17)
    1504:	7f889103 	svcvc	0x00889103
		hash[i + 20] = (ctx->state[5] >> (24 - i * 8)) & 0x000000ff;
    1508:	02520101 	subseq	r0, r2, #1073741824	@ 0x40000000
    150c:	03000075 	movweq	r0, #117	@ 0x75
    1510:	000007f4 	strdeq	r0, [r0], -r4
		hash[i + 24] = (ctx->state[6] >> (24 - i * 8)) & 0x000000ff;
    1514:	000002cb 	andeq	r0, r0, fp, asr #5
    1518:	000004c7 	andeq	r0, r0, r7, asr #9
		hash[i + 28] = (ctx->state[7] >> (24 - i * 8)) & 0x000000ff;
    151c:	03500101 	cmpeq	r0, #1073741824	@ 0x40000000
    1520:	017fb891 			@ <UNDEFINED> instruction: 0x017fb891
    1524:	76025101 	strvc	r5, [r2], -r1, lsl #2
	for (i = 0; i < 4; ++i) {
    1528:	52010100 	andpl	r0, r1, #0, 2
}
    152c:	7ef09103 	nrmvcs	f1, f3
static void outstr(const char *str) {
    1530:	07fa0300 	ldrbeq	r0, [sl, r0, lsl #6]!
  while (*str != '\0') {
    1534:	02ba0000 	adcseq	r0, sl, #0
    __write_char__(*str);
    1538:	04db0000 	ldrbeq	r0, [fp], #0
    str++;
    153c:	01010000 	mrseq	r0, (UNDEF: 1)
  while (*str != '\0') {
    1540:	007d0250 	rsbseq	r0, sp, r0, asr r2
}
    1544:	08040300 	stmdaeq	r4, {r8, r9}
    1548:	029a0000 	addseq	r0, sl, #0
static bool printf_numbers(const char fmt, va_list *args, int l_count) {
    154c:	04fb0000 	ldrbteq	r0, [fp], #0
    1550:	01010000 	mrseq	r0, (UNDEF: 1)
  switch (fmt) {
    1554:	007d0250 	rsbseq	r0, sp, r0, asr r2
    1558:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    155c:	01010075 	tsteq	r1, r5, ror r0
      if (l_count == 0) {
    1560:	30080252 	andcc	r0, r8, r2, asr r2
    1564:	080e0300 	stmdaeq	lr, {r8, r9}
        value = va_arg(*args, unsigned int);
    1568:	027a0000 	rsbseq	r0, sl, #0
    156c:	05150000 	ldreq	r0, [r5, #-0]
      if (fmt == 'u') {
    1570:	01010000 	mrseq	r0, (UNDEF: 1)
        if (value == 0) {
    1574:	007d0250 	rsbseq	r0, sp, r0, asr r2
          __write_char__(hextable[0]);
    1578:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    157c:	03000075 	movweq	r0, #117	@ 0x75
  return true;
    1580:	00000818 	andeq	r0, r0, r8, lsl r8
  switch (fmt) {
    1584:	00000255 	andeq	r0, r0, r5, asr r2
      outstr("\nprintf-error\n");
    1588:	00000536 	andeq	r0, r0, r6, lsr r5
      return false;
    158c:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
}
    1590:	01010075 	tsteq	r1, r5, ror r0
      if (l_count == 0) {
    1594:	20080251 	andcs	r0, r8, r1, asr r2
        value = va_arg(*args, int);
    1598:	03520101 	cmpeq	r2, #1073741824	@ 0x40000000
    159c:	007ea091 			@ <UNDEFINED> instruction: 0x007ea091
      if (value < 0) {
    15a0:	00082e03 	andeq	r2, r8, r3, lsl #28
        num[num_len++] = hextable[value % 10];
    15a4:	00032b00 	andeq	r2, r3, r0, lsl #22
    15a8:	00055400 	andeq	r5, r5, r0, lsl #8
    15ac:	50010100 	andpl	r0, r1, r0, lsl #2
    15b0:	2ccc0305 	stclcs	3, cr0, [ip], {5}
    15b4:	01010000 	mrseq	r0, (UNDEF: 1)
    15b8:	a0910351 	addsge	r0, r1, r1, asr r3
    15bc:	3403007e 	strcc	r0, [r3], #-126	@ 0xffffff82
    15c0:	ba000008 	blt	15e8 <printf_numbers+0x9c>
    15c4:	68000002 	stmdavs	r0, {r1}
        value = value / 10;
    15c8:	01000005 	tsteq	r0, r5
      } while (value > 0);
    15cc:	7d025001 	stcvc	0, cr5, [r2, #-4]
    15d0:	3e030000 	cdpcc	0, 0, cr0, cr3, cr0, {0}
        __write_char__('-');
    15d4:	9a000008 	bls	15fc <printf_numbers+0xb0>
    15d8:	89000002 	stmdbhi	r0, {r1}
        value = -value;
    15dc:	01000005 	tsteq	r0, r5
        __write_char__(num[--num_len]);
    15e0:	7d025001 	stcvc	0, cr5, [r2, #-4]
    15e4:	51010100 	mrspl	r0, (UNDEF: 17)
    15e8:	7ef09103 	nrmvcs	f1, f3
    15ec:	02520101 	subseq	r0, r2, #1073741824	@ 0x40000000
    15f0:	03003008 	movweq	r3, #8
      while (num_len > 0) {
    15f4:	00000846 	andeq	r0, r0, r6, asr #16
  return true;
    15f8:	0000027a 	andeq	r0, r0, sl, ror r2
          num[num_len++] = hextable[value % 10];
    15fc:	000005a4 	andeq	r0, r0, r4, lsr #11
    1600:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    1604:	0101007d 	tsteq	r1, sp, ror r0
    1608:	d0910351 	addsle	r0, r1, r1, asr r3
    160c:	5003007e 	andpl	r0, r3, lr, ror r0
    1610:	55000008 	strpl	r0, [r0, #-8]
    1614:	c6000002 	strgt	r0, [r0], -r2
    1618:	01000005 	tsteq	r0, r5
          value = value / 10;
    161c:	91035001 	tstls	r3, r1
        } while (value > 0);
    1620:	01017ed0 	ldrdeq	r7, [r1, -r0]
        while (num_len > 0) {
    1624:	20080251 	andcs	r0, r8, r1, asr r2
          __write_char__(num[--num_len]);
    1628:	03520101 	cmpeq	r2, #1073741824	@ 0x40000000
    162c:	007ea091 			@ <UNDEFINED> instruction: 0x007ea091
    1630:	00086403 	andeq	r6, r8, r3, lsl #8
    1634:	00032b00 	andeq	r2, r3, r0, lsl #22
    1638:	0005e400 	andeq	lr, r5, r0, lsl #8
    163c:	50010100 	andpl	r0, r1, r0, lsl #2
  return true;
    1640:	2ce40305 	stclcs	3, cr0, [r4], #20
              __write_char__(hextable[val]);
    1644:	01010000 	mrseq	r0, (UNDEF: 1)
    1648:	a0910351 	addsge	r0, r1, r1, asr r3
              leading_zero_ignored = true;
    164c:	6a03007e 	bvs	c184c <__ROM_SIZE__+0x8184c>
          while (start_bit >= 0) {
    1650:	2b000008 	blcs	1678 <printf_numbers+0x12c>
            int val = (value >> start_bit) & 0xF;
    1654:	fb000003 	blx	166a <printf_numbers+0x11e>
            if (val || leading_zero_ignored) {
    1658:	01000005 	tsteq	r0, r5
    165c:	03055001 	movweq	r5, #20481	@ 0x5001
    1660:	00002cfc 	strdeq	r2, [r0], -ip
          bool leading_zero_ignored = false;
    1664:	08721d00 	ldmdaeq	r2!, {r8, sl, fp, ip}^
          int start_bit = LAST_NIBBLE_FIRST_BIT;
    1668:	02350000 	eorseq	r0, r5, #0
  return true;
    166c:	01010000 	mrseq	r0, (UNDEF: 1)
        return false;
    1670:	00750251 	rsbseq	r0, r5, r1, asr r2
        return false;
    1674:	42070000 	andmi	r0, r7, #0
    1678:	1c000000 	stcne	0, cr0, [r0], {-0}
    167c:	08000006 	stmdaeq	r0, {r1, r2}
    1680:	00000076 	andeq	r0, r0, r6, ror r0
    1684:	4207001f 	andmi	r0, r7, #31
    1688:	2c000000 	stccs	0, cr0, [r0], {-0}
int printf(const char *fmt, ...) {
    168c:	08000006 	stmdaeq	r0, {r1, r2}
    1690:	00000076 	andeq	r0, r0, r6, ror r0
    1694:	42070017 	andmi	r0, r7, #23
  va_start(args, fmt);
    1698:	3c000000 	stccc	0, cr0, [r0], {-0}
  while (*fmt) {
    169c:	08000006 	stmdaeq	r0, {r1, r2}
        if (*fmt == '%') {
    16a0:	00000076 	andeq	r0, r0, r6, ror r0
        __write_char__(*fmt);
    16a4:	421e002f 	andsmi	r0, lr, #47	@ 0x2f
        fmt++;
    16a8:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
  while (*fmt) {
    16ac:	00000076 	andeq	r0, r0, r6, ror r0
    switch (state) {
    16b0:	8b00002c 	blhi	1768 <outstr2>
    16b4:	05000001 	streq	r0, [r0, #-1]
          fmt++;
    16b8:	f8040100 			@ <UNDEFINED> instruction: 0xf8040100
          continue;
    16bc:	09000009 	stmdbeq	r0, {r0, r3}
        while (*fmt && ((*fmt >= '0' && *fmt <= '9') || *fmt == '-')) {
    16c0:	00000014 	andeq	r0, r0, r4, lsl r0
    16c4:	00057f1d 	andeq	r7, r5, sp, lsl pc
    16c8:	00017700 	andeq	r7, r1, r0, lsl #14
    16cc:	0008a400 	andeq	sl, r8, r0, lsl #8
    16d0:	00001c00 	andeq	r1, r0, r0, lsl #24
        switch (*fmt) {
    16d4:	000d2a00 	andeq	r2, sp, r0, lsl #20
    16d8:	06010100 	streq	r0, [r1], -r0, lsl #2
    16dc:	000000fe 	strdeq	r0, [r0], -lr
    16e0:	68050201 	stmdavs	r5, {r0, r9}
            __write_char__(*fmt);
    16e4:	01000001 	tsteq	r0, r1
    16e8:	01580504 	cmpeq	r8, r4, lsl #10
            state = CHECK_CH;
    16ec:	08010000 	stmdaeq	r1, {}	@ <UNPREDICTABLE>
            break;
    16f0:	00015305 	andeq	r5, r1, r5, lsl #6
    16f4:	08010100 	stmdaeq	r1, {r8}
            outstr(va_arg(args, const char *));
    16f8:	000000fc 	strdeq	r0, [r0], -ip
    16fc:	0a070201 	beq	1c1f08 <__ROM_SIZE__+0x181f08>
    1700:	01000001 	tsteq	r0, r1
            fmt++;
    1704:	01220704 			@ <UNDEFINED> instruction: 0x01220704
            break;
    1708:	08010000 	stmdaeq	r1, {}	@ <UNPREDICTABLE>
            __write_char__(va_arg(args, int));
    170c:	00011d07 	andeq	r1, r1, r7, lsl #26
    1710:	05040a00 	streq	r0, [r4, #-2560]	@ 0xfffff600
    1714:	00746e69 	rsbseq	r6, r4, r9, ror #28
            fmt++;
    1718:	27070401 	strcs	r0, [r7, -r1, lsl #8]
            break;
    171c:	01000001 	tsteq	r0, r1
            if (*fmt == 'l') {
    1720:	019e0408 	orrseq	r0, lr, r8, lsl #8
    1724:	630b0000 	movwvs	r0, #45056	@ 0xb000
            if (printf_numbers(*fmt, &args, l_count)) {
    1728:	0200646d 	andeq	r6, r0, #1828716544	@ 0x6d000000
    172c:	007f0f2f 	rsbseq	r0, pc, pc, lsr #30
    1730:	84020000 	strhi	r0, [r2], #-0
              state = CHECK_CH;
    1734:	0c000000 	stceq	0, cr0, [r0], {-0}
              fmt++;
    1738:	0000005e 	andeq	r0, r0, lr, asr r0
              l_count++;
    173c:	00000098 	muleq	r0, r8, r0
            if (printf_numbers(*fmt, &args, 0)) {
    1740:	00005e03 	andeq	r5, r0, r3, lsl #28
    1744:	00980300 	addseq	r0, r8, r0, lsl #6
              fmt++;
    1748:	02000000 	andeq	r0, r0, #0
              break;
    174c:	0000009d 	muleq	r0, sp, r0
            return -1;
    1750:	0000a202 	andeq	sl, r0, r2, lsl #4
}
    1754:	08010100 	stmdaeq	r1, {r8}
    1758:	00000105 	andeq	r0, r0, r5, lsl #2
            return -1;
    175c:	0000a20d 	andeq	sl, r0, sp, lsl #4
    1760:	020c0e00 	andeq	r0, ip, #0, 28
    1764:	00dc0938 	sbcseq	r0, ip, r8, lsr r9
static void outstr2(const char *str) {
    1768:	c4040000 	strgt	r0, [r4], #-0
  while (*str != '\0') {
    176c:	39000000 	stmdbcc	r0, {}	@ <UNPREDICTABLE>
    __write_char2__(*str);
    1770:	0000dc0f 	andeq	sp, r0, pc, lsl #24
    str++;
    1774:	00040000 	andeq	r0, r4, r0
  while (*str != '\0') {
    1778:	3a000000 	bcc	1780 <outstr2+0x18>
}
    177c:	0000dc0f 	andeq	sp, r0, pc, lsl #24
    1780:	bc040400 	cfstrslt	mvf0, [r4], {-0}
static bool printf2_numbers(const char fmt, va_list *args, int l_count) {
    1784:	3b000000 	blcc	178c <printf2_numbers+0x8>
    1788:	00007307 	andeq	r7, r0, r7, lsl #6
  switch (fmt) {
    178c:	02000800 	andeq	r0, r0, #0, 16
    1790:	000000a9 	andeq	r0, r0, r9, lsr #1
    1794:	0001980f 	andeq	r9, r1, pc, lsl #16
      if (l_count == 0) {
    1798:	033c0200 	teqeq	ip, #0, 4
    179c:	000000ae 	andeq	r0, r0, lr, lsr #1
        value = va_arg(*args, unsigned int);
    17a0:	00057110 	andeq	r7, r5, r0, lsl r1
    17a4:	010c0100 	mrseq	r0, (UNDEF: 28)
      if (fmt == 'u') {
    17a8:	000000e1 	andeq	r0, r0, r1, ror #1
        if (value == 0) {
    17ac:	28880305 	stmcs	r8, {r0, r2, r8, r9}
          __write_char2__(hextable2[0]);
    17b0:	4f050000 	svcmi	0x00050000
    17b4:	2d000003 	stccs	0, cr0, [r0, #-12]
  return true;
    17b8:	0000005e 	andeq	r0, r0, lr, asr r0
  switch (fmt) {
    17bc:	00000114 	andeq	r0, r0, r4, lsl r1
      outstr2("\nprintf2-error\n");
    17c0:	0000dc03 	andeq	sp, r0, r3, lsl #24
      return false;
    17c4:	05000600 	streq	r0, [r0, #-1536]	@ 0xfffffa00
}
    17c8:	00000161 	andeq	r0, r0, r1, ror #2
      if (l_count == 0) {
    17cc:	00005e2c 	andeq	r5, r0, ip, lsr #28
        value = va_arg(*args, int);
    17d0:	00012900 	andeq	r2, r1, r0, lsl #18
    17d4:	00dc0300 	sbcseq	r0, ip, r0, lsl #6
      if (value < 0) {
    17d8:	00060000 	andeq	r0, r6, r0
        num[num_len++] = hextable2[value % 10];
    17dc:	00057511 	andeq	r7, r5, r1, lsl r5
    17e0:	05050100 	streq	r0, [r5, #-256]	@ 0xffffff00
    17e4:	0000005e 	andeq	r0, r0, lr, asr r0
    17e8:	000008a4 	andeq	r0, r0, r4, lsr #17
    17ec:	0000001c 	andeq	r0, r0, ip, lsl r0
    17f0:	72079c01 	andvc	r9, r7, #256	@ 0x100
    17f4:	13000001 	movwne	r0, #1
    17f8:	0000005e 	andeq	r0, r0, lr, asr r0
    17fc:	000002bf 			@ <UNDEFINED> instruction: 0x000002bf
        value = value / 10;
    1800:	000002bb 			@ <UNDEFINED> instruction: 0x000002bb
      } while (value > 0);
    1804:	0000b707 	andeq	fp, r0, r7, lsl #14
    1808:	00982000 	addseq	r2, r8, r0
        __write_char2__('-');
    180c:	02d10000 	sbcseq	r0, r1, #0
    1810:	02cd0000 	sbceq	r0, sp, #0
        value = -value;
    1814:	ac120000 	ldcge	0, cr0, [r2], {-0}
        __write_char2__(num[--num_len]);
    1818:	14000008 	strne	r0, [r0], #-8
    181c:	7a000001 	bvc	1828 <printf2_numbers+0xa4>
    1820:	08000001 	stmdaeq	r0, {r0}
    1824:	03055001 	movweq	r5, #20481	@ 0x5001
    1828:	00002d7c 	andeq	r2, r0, ip, ror sp
      while (num_len > 0) {
    182c:	08b21300 	ldmeq	r2!, {r8, r9, ip}
  return true;
    1830:	00ff0000 	rscseq	r0, pc, r0
          num[num_len++] = hextable2[value % 10];
    1834:	01080000 	mrseq	r0, (UNDEF: 8)
    1838:	90030550 	andls	r0, r3, r0, asr r5
    183c:	0000002d 	andeq	r0, r0, sp, lsr #32
    1840:	04060000 	streq	r0, [r6], #-0
    1844:	00050000 	andeq	r0, r5, r0
    1848:	0b030401 	bleq	c2854 <__ROM_SIZE__+0x82854>
    184c:	14100000 	ldrne	r0, [r0], #-0
    1850:	1d000000 	stcne	0, cr0, [r0, #-0]
          value = value / 10;
    1854:	000005a7 	andeq	r0, r0, r7, lsr #11
        } while (value > 0);
    1858:	00000177 	andeq	r0, r0, r7, ror r1
        while (num_len > 0) {
    185c:	000008c0 	andeq	r0, r0, r0, asr #17
          __write_char2__(num[--num_len]);
    1860:	000000a4 	andeq	r0, r0, r4, lsr #1
    1864:	00000df4 	strdeq	r0, [r0], -r4
    1868:	fe060103 	cdp2	1, 0, cr0, cr6, cr3, {0}
    186c:	03000000 	movweq	r0, #0
    1870:	01680502 	cmneq	r8, r2, lsl #10
    1874:	04030000 	streq	r0, [r3], #-0
  return true;
    1878:	00015805 	andeq	r5, r1, r5, lsl #16
              __write_char2__(hextable2[val]);
    187c:	05080300 	streq	r0, [r8, #-768]	@ 0xfffffd00
    1880:	00000153 	andeq	r0, r0, r3, asr r1
              leading_zero_ignored = true;
    1884:	00013407 	andeq	r3, r1, r7, lsl #8
          while (start_bit >= 0) {
    1888:	182e0200 	stmdane	lr!, {r9}
            int val = (value >> start_bit) & 0xF;
    188c:	0000004e 	andeq	r0, r0, lr, asr #32
            if (val || leading_zero_ignored) {
    1890:	fc080103 	stc2	1, cr0, [r8], {3}
    1894:	03000000 	movweq	r0, #0
    1898:	010a0702 	tsteq	sl, r2, lsl #14
          bool leading_zero_ignored = false;
    189c:	04030000 	streq	r0, [r3], #-0
          int start_bit = LAST_NIBBLE_FIRST_BIT;
    18a0:	00012207 	andeq	r2, r1, r7, lsl #4
  return true;
    18a4:	07080300 	streq	r0, [r8, -r0, lsl #6]
        return false;
    18a8:	0000011d 	andeq	r0, r0, sp, lsl r1
        return false;
    18ac:	69050411 	stmdbvs	r5, {r0, r4, sl}
    18b0:	0300746e 	movweq	r7, #1134	@ 0x46e
    18b4:	01270704 			@ <UNDEFINED> instruction: 0x01270704
    18b8:	0d070000 	stceq	0, cr0, [r7, #-0]
    18bc:	03000000 	movweq	r0, #0
    18c0:	007117d6 	ldrsbteq	r1, [r1], #-118	@ 0xffffff8a
int printf2(const char *fmt, ...) {
    18c4:	08030000 	stmdaeq	r3, {}	@ <UNPREDICTABLE>
    18c8:	00019e04 	andeq	r9, r1, r4, lsl #28
    18cc:	04780700 	ldrbteq	r0, [r8], #-1792	@ 0xfffff900
  va_start(args, fmt);
    18d0:	13040000 	movwne	r0, #16384	@ 0x4000
  while (*fmt) {
    18d4:	00004e17 	andeq	r4, r0, r7, lsl lr
        if (*fmt == '%') {
    18d8:	008b0d00 	addeq	r0, fp, r0, lsl #26
        __write_char2__(*fmt);
    18dc:	59070000 	stmdbpl	r7, {}	@ <UNPREDICTABLE>
        fmt++;
    18e0:	04000004 	streq	r0, [r0], #-4
  while (*fmt) {
    18e4:	00711714 	rsbseq	r1, r1, r4, lsl r7
    switch (state) {
    18e8:	700e0000 	andvc	r0, lr, r0
    18ec:	00e51604 	rsceq	r1, r5, r4, lsl #12
          fmt++;
    18f0:	38060000 	stmdacc	r6, {}	@ <UNPREDICTABLE>
          continue;
    18f4:	04000007 	streq	r0, [r0], #-7
        while (*fmt && ((*fmt >= '0' && *fmt <= '9') || *fmt == '-')) {
    18f8:	00e50717 	rsceq	r0, r5, r7, lsl r7
    18fc:	06000000 	streq	r0, [r0], -r0
    1900:	00000451 	andeq	r0, r0, r1, asr r4
    1904:	9c071804 	stcls	8, cr1, [r7], {4}
    1908:	40000000 	andmi	r0, r0, r0
        switch (*fmt) {
    190c:	00050906 	andeq	r0, r5, r6, lsl #18
    1910:	15190400 	ldrne	r0, [r9, #-1024]	@ 0xfffffc00
    1914:	00000063 	andeq	r0, r0, r3, rrx
    1918:	0a9a0648 	beq	fe683240 <_STACK_TOP_+0xde67b244>
            __write_char2__(*fmt);
    191c:	1a040000 	bne	101924 <__ROM_SIZE__+0xc1924>
    1920:	0000f507 	andeq	pc, r0, r7, lsl #10
            state = CHECK_CH;
    1924:	0a005000 	beq	1592c <__RAM_SIZE__+0xd92c>
            break;
    1928:	0000008b 	andeq	r0, r0, fp, lsl #1
    192c:	000000f5 	strdeq	r0, [r0], -r5
            outstr2(va_arg(args, const char *));
    1930:	00007108 	andeq	r7, r0, r8, lsl #2
    1934:	0a003f00 	beq	1153c <__RAM_SIZE__+0x953c>
    1938:	0000009c 	muleq	r0, ip, r0
            fmt++;
    193c:	00000105 	andeq	r0, r0, r5, lsl #2
            break;
    1940:	00007108 	andeq	r7, r0, r8, lsl #2
            __write_char2__(va_arg(args, int));
    1944:	07000700 	streq	r0, [r0, -r0, lsl #14]
    1948:	00000510 	andeq	r0, r0, r0, lsl r5
    194c:	a8031b04 	stmdage	r3, {r2, r8, r9, fp, ip}
            fmt++;
    1950:	12000000 	andne	r0, r0, #0
            break;
    1954:	00646d63 	rsbeq	r6, r4, r3, ror #26
            if (*fmt == 'l') {
    1958:	1d0f2f05 	stcne	15, cr2, [pc, #-20]	@ 194c <printf2+0x88>
    195c:	04000001 	streq	r0, [r0], #-1
            if (printf2_numbers(*fmt, &args, l_count)) {
    1960:	00000122 	andeq	r0, r0, r2, lsr #2
    1964:	00006a13 	andeq	r6, r0, r3, lsl sl
    1968:	00013600 	andeq	r3, r1, r0, lsl #12
              state = CHECK_CH;
    196c:	006a0200 	rsbeq	r0, sl, r0, lsl #4
              fmt++;
    1970:	36020000 	strcc	r0, [r2], -r0
              l_count++;
    1974:	00000001 	andeq	r0, r0, r1
            if (printf2_numbers(*fmt, &args, 0)) {
    1978:	00013b04 	andeq	r3, r1, r4, lsl #22
    197c:	01400400 	cmpeq	r0, r0, lsl #8
              fmt++;
    1980:	01030000 	mrseq	r0, (UNDEF: 3)
              break;
    1984:	00010508 	andeq	r0, r1, r8, lsl #10
            return -1;
    1988:	01400d00 	cmpeq	r0, r0, lsl #26
}
    198c:	0c0e0000 	stceq	0, cr0, [lr], {-0}
    1990:	017c3805 	cmneq	ip, r5, lsl #16
            return -1;
    1994:	c4060000 	strgt	r0, [r6], #-0
    1998:	05000000 	streq	r0, [r0, #-0]
    199c:	017c0f39 	cmneq	ip, r9, lsr pc
int r32(int argc, char *argv[]) {
    19a0:	06000000 	streq	r0, [r0], -r0
  if (argc < 2) {
    19a4:	00000000 	andeq	r0, r0, r0
  uint32_t addr = atoh(argv[1]);
    19a8:	7c0f3a05 			@ <UNDEFINED> instruction: 0x7c0f3a05
    19ac:	04000001 	streq	r0, [r0], #-1
  printf("0x%x: 0x%x\n", addr, data);
    19b0:	0000bc06 	andeq	fp, r0, r6, lsl #24
    19b4:	073b0500 	ldreq	r0, [fp, -r0, lsl #10]!
}
    19b8:	00000111 	andeq	r0, r0, r1, lsl r1
    printf("Usage: %s <address> (in hex)\n", argv[0]);
    19bc:	47040008 	strmi	r0, [r4, -r8]
    19c0:	07000001 	streq	r0, [r0, -r1]
    return -1;
    19c4:	00000198 	muleq	r0, r8, r1
    19c8:	4c033c05 	stcmi	12, cr3, [r3], {5}
    19cc:	14000001 	strne	r0, [r0], #-1
int w32(int argc, char *argv[]) {
    19d0:	000005ee 	andeq	r0, r0, lr, ror #11
  if (argc < 3) {
    19d4:	81012201 	tsthi	r1, r1, lsl #4
  uint32_t addr = atoh(argv[1]);
    19d8:	05000001 	streq	r0, [r0, #-1]
    19dc:	00289403 	eoreq	r9, r8, r3, lsl #8
  uint32_t data = atoh(argv[2]);
    19e0:	039b0b00 	orrseq	r0, fp, #0, 22
    19e4:	3d060000 	stccc	0, cr0, [r6, #-0]
  return 0;
    19e8:	0000710e 	andeq	r7, r0, lr, lsl #2
    printf("Usage: %s <address> (in hex) <value> (in hex)\n", argv[0]);
    19ec:	0001bf00 	andeq	fp, r1, r0, lsl #30
    19f0:	01bf0200 			@ <UNDEFINED> instruction: 0x01bf0200
    return -1;
    19f4:	71020000 	mrsvc	r0, (UNDEF: 2)
    19f8:	02000000 	andeq	r0, r0, #0
    19fc:	000001bf 			@ <UNDEFINED> instruction: 0x000001bf
int read_mem(int argc, char *argv[]) {
    1a00:	004e0400 	subeq	r0, lr, r0, lsl #8
  if (argc < 3) {
    1a04:	7d0c0000 	stcvc	0, cr0, [ip, #-0]
  uint32_t addr = atoh(argv[1]);
    1a08:	20000004 	andcs	r0, r0, r4
    1a0c:	000001d9 	ldrdeq	r0, [r0], -r9
  uint32_t length = atoi(argv[2]);
    1a10:	0001d902 	andeq	sp, r1, r2, lsl #18
    1a14:	01de0200 	bicseq	r0, lr, r0, lsl #4
  for (uint32_t i = 0, data = 0; i < length; i++) {
    1a18:	04000000 	streq	r0, [r0], #-0
    printf("Usage: %s <address> (in hex) <num_words> (in decimal)\n", argv[0]);
    1a1c:	00000105 	andeq	r0, r0, r5, lsl #2
    1a20:	00008b04 	andeq	r8, r0, r4, lsl #22
    return -1;
    1a24:	051b0c00 	ldreq	r0, [fp, #-3072]	@ 0xfffff400
    1a28:	fd1f0000 	ldc2	0, cr0, [pc, #-0]	@ 1a30 <read_mem+0x30>
    printf("0x%x: 0x%x\n", addr, data);
    1a2c:	02000001 	andeq	r0, r0, #1
    1a30:	000001d9 	ldrdeq	r0, [r0], -r9
    addr += 4;
    1a34:	0001fd02 	andeq	pc, r1, r2, lsl #26
  for (uint32_t i = 0, data = 0; i < length; i++) {
    1a38:	00780200 	rsbseq	r0, r8, r0, lsl #4
  return 0;
    1a3c:	04000000 	streq	r0, [r0], #-0
}
    1a40:	00000097 	muleq	r0, r7, r0
    1a44:	0001aa0b 	andeq	sl, r1, fp, lsl #20
{
    1a48:	081f0700 	ldmdaeq	pc, {r8, r9, sl}	@ <UNPREDICTABLE>
  if (argc < 4) {
    1a4c:	00000078 	andeq	r0, r0, r8, ror r0
  uint32_t addr = atoh(argv[1]);
    1a50:	00000218 	andeq	r0, r0, r8, lsl r2
    1a54:	00017c02 	andeq	r7, r1, r2, lsl #24
  uint32_t bit_loc = atoi(argv[2]);
    1a58:	980c0000 	stmdals	ip, {}	@ <UNPREDICTABLE>
    1a5c:	1e000004 	cdpne	0, 0, cr0, cr0, cr4, {0}
  uint32_t bit_val = atoi(argv[3]);
    1a60:	00000228 	andeq	r0, r0, r8, lsr #4
    1a64:	0001d902 	andeq	sp, r1, r2, lsl #18
  if (bit_loc > 31) {
    1a68:	610b0000 	mrsvs	r0, (UNDEF: 11)
  if (bit_val != 0 && bit_val != 1) {
    1a6c:	08000001 	stmdaeq	r0, {r0}
  data = data | (bit_val << bit_loc);
    1a70:	006a052c 	rsbeq	r0, sl, ip, lsr #10
    1a74:	023f0000 	eorseq	r0, pc, #0
  data = data & ~(!bit_val << bit_loc);
    1a78:	7c020000 	stcvc	0, cr0, [r2], {-0}
    1a7c:	15000001 	strne	r0, [r0, #-1]
    1a80:	05f21600 	ldrbeq	r1, [r2, #1536]!	@ 0x600
  return 0;
    1a84:	04010000 	streq	r0, [r1], #-0
    printf("Error: Invalid bit location argument\n");
    1a88:	00006a05 	andeq	r6, r0, r5, lsl #20
    1a8c:	0008c000 	andeq	ip, r8, r0
    printf("Error: Invalid bit value argument\n");
    1a90:	0000a400 	andeq	sl, r0, r0, lsl #8
    1a94:	dd9c0100 	ldfles	f0, [ip]
  printf("Usage: %s <address_in_hex(32-bits)> <bit_location_in_decimal(0 to 31)> <bit_value(0 or 1)>\n", argv[0]);
    1a98:	0f000003 	svceq	0x00000003
    1a9c:	00000172 	andeq	r0, r0, r2, ror r1
  return -1;
    1aa0:	00006a15 	andeq	r6, r0, r5, lsl sl
    1aa4:	0002ef00 	andeq	lr, r2, r0, lsl #30
    1aa8:	0002eb00 	andeq	lr, r2, r0, lsl #22
    1aac:	00b70f00 	adcseq	r0, r7, r0, lsl #30
{
    1ab0:	36220000 	strtcc	r0, [r2], -r0
  if (argc < 3) {
    1ab4:	02000001 	andeq	r0, r0, #1
  uint32_t addr = atoh(argv[1]);
    1ab8:	fe000003 	cdp2	0, 0, cr0, cr0, cr3, {0}
    1abc:	09000002 	stmdbeq	r0, {r1}
  uint32_t bit_loc = atoi(argv[2]);
    1ac0:	0000043d 	andeq	r0, r0, sp, lsr r4
    1ac4:	01051007 	tsteq	r5, r7
  if (bit_loc > 31) {
    1ac8:	91030000 	mrsls	r0, (UNDEF: 3)
  uint32_t data = reg32(addr);
    1acc:	e8097f80 	stmda	r9, {r7, r8, r9, sl, fp, ip, sp, lr}
  printf("Bit %u @ 0x%08x: %u\n", bit_loc, addr, bit_val);
    1ad0:	08000005 	stmdaeq	r0, {r0, r2}
    1ad4:	0003dd0a 	andeq	sp, r3, sl, lsl #26
    1ad8:	c4910300 	ldrgt	r0, [r1], #768	@ 0x300
  return 0;
    1adc:	05e2097e 	strbeq	r0, [r2, #2430]!	@ 0x97e
    printf("Error: Invalid bit location argument\n");
    1ae0:	0a090000 	beq	241ae8 <__ROM_SIZE__+0x201ae8>
    1ae4:	000003ed 	andeq	r0, r0, sp, ror #7
  printf("Usage: %s <address_in_hex(32-bits)> <bit_location_in_decimal(0 to 31)\n", argv[0]);
    1ae8:	7ea49103 	tanvcs	f1, f3
    1aec:	66756217 			@ <UNDEFINED> instruction: 0x66756217
  return -1;
    1af0:	0a0b0100 	beq	2c1ef8 <__ROM_SIZE__+0x281ef8>
    1af4:	000003ed 	andeq	r0, r0, sp, ror #7
    1af8:	7e849103 	sinvcs	f1, f3
    1afc:	0005de09 	andeq	sp, r5, r9, lsl #28
{
    1b00:	fd0d0d00 	stc2	13, cr0, [sp, #-0]
  for (i = 0; i < Nk; ++i)
    1b04:	03000003 	movweq	r0, #3
    RoundKey[(i * 4) + 0] = Key[(i * 4) + 0];
    1b08:	097dd491 	ldmdbeq	sp!, {r0, r4, r7, sl, ip, lr, pc}^
    1b0c:	000005d6 	ldrdeq	r0, [r0], -r6
    1b10:	03fd0d0e 	mvnseq	r0, #896	@ 0x380
    RoundKey[(i * 4) + 1] = Key[(i * 4) + 1];
    1b14:	91030000 	mrsls	r0, (UNDEF: 3)
    RoundKey[(i * 4) + 2] = Key[(i * 4) + 2];
    1b18:	6c187da4 	ldcvs	13, cr7, [r8], {164}	@ 0xa4
    1b1c:	01006e65 	tsteq	r0, r5, ror #28
    RoundKey[(i * 4) + 3] = Key[(i * 4) + 3];
    1b20:	006a090f 	rsbeq	r0, sl, pc, lsl #18
  for (i = 0; i < Nk; ++i)
    1b24:	03150000 	tsteq	r5, #0
    1b28:	03110000 	tsteq	r1, #0
  for (i = Nk; i < Nb * (Nr + 1); ++i)
    1b2c:	ca050000 	bgt	141b34 <__ROM_SIZE__+0x101b34>
    if (i % Nk == 4)
    1b30:	28000008 	stmdacs	r0, {r3}
    j = i * 4; k=(i - Nk) * 4;
    1b34:	03000002 	movweq	r0, #2
    RoundKey[j + 0] = RoundKey[k + 0] ^ tempa[0];
    1b38:	01000003 	tsteq	r0, r3
    1b3c:	03055001 	movweq	r5, #20481	@ 0x5001
    1b40:	00002dc0 	andeq	r2, r0, r0, asr #27
    1b44:	09040500 	stmdbeq	r4, {r8, sl}
    RoundKey[j + 1] = RoundKey[k + 1] ^ tempa[1];
    1b48:	02180000 	andseq	r0, r8, #0
    1b4c:	03180000 	tsteq	r8, #0
    1b50:	01010000 	mrseq	r0, (UNDEF: 1)
    1b54:	80910350 	addshi	r0, r1, r0, asr r3
    1b58:	0a05007f 	beq	141d5c <__ROM_SIZE__+0x101d5c>
    1b5c:	02000009 	andeq	r0, r0, #9
    RoundKey[j + 2] = RoundKey[k + 2] ^ tempa[2];
    1b60:	2d000002 	stccs	0, cr0, [r0, #-8]
    1b64:	01000003 	tsteq	r0, r3
    1b68:	91035001 	tstls	r3, r1
    1b6c:	05007ec4 	streq	r7, [r0, #-3780]	@ 0xfffff13c
    RoundKey[j + 3] = RoundKey[k + 3] ^ tempa[3];
    1b70:	00000914 	andeq	r0, r0, r4, lsl r9
    1b74:	000001e3 	andeq	r0, r0, r3, ror #3
    1b78:	00000349 	andeq	r0, r0, r9, asr #6
  for (i = Nk; i < Nb * (Nr + 1); ++i)
    1b7c:	03500101 	cmpeq	r0, #1073741824	@ 0x40000000
    1b80:	017f8091 			@ <UNDEFINED> instruction: 0x017f8091
      tempa[0]=RoundKey[k + 0];
    1b84:	91035101 	tstls	r3, r1, lsl #2
    1b88:	05007ec4 	streq	r7, [r0, #-3780]	@ 0xfffff13c
      tempa[1]=RoundKey[k + 1];
    1b8c:	0000091c 	andeq	r0, r0, ip, lsl r9
    1b90:	000001c4 	andeq	r0, r0, r4, asr #3
    1b94:	00000365 	andeq	r0, r0, r5, ror #6
      tempa[2]=RoundKey[k + 2];
    1b98:	03500101 	cmpeq	r0, #1073741824	@ 0x40000000
    1b9c:	017f8091 			@ <UNDEFINED> instruction: 0x017f8091
      tempa[3]=RoundKey[k + 3];
    1ba0:	91035101 	tstls	r3, r1, lsl #2
    1ba4:	05007e84 	streq	r7, [r0, #-3716]	@ 0xfffff17c
    if (i % Nk == 0)
    1ba8:	00000928 	andeq	r0, r0, r8, lsr #18
        tempa[0] = tempa[1];
    1bac:	0000019f 	muleq	r0, pc, r1	@ <UNPREDICTABLE>
        tempa[1] = tempa[2];
    1bb0:	00000385 	andeq	r0, r0, r5, lsl #7
        tempa[2] = tempa[3];
    1bb4:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
        tempa[3] = u8tmp;
    1bb8:	01017074 	tsteq	r1, r4, ror r0
        tempa[0] = getSBoxValue(tempa[0]);
    1bbc:	20080251 	andcs	r0, r8, r1, asr r2
    1bc0:	02520101 	subseq	r0, r2, #1073741824	@ 0x40000000
        tempa[1] = getSBoxValue(tempa[1]);
    1bc4:	05000075 	streq	r0, [r0, #-117]	@ 0xffffff8b
    1bc8:	00000938 	andeq	r0, r0, r8, lsr r9
        tempa[2] = getSBoxValue(tempa[2]);
    1bcc:	0000019f 	muleq	r0, pc, r1	@ <UNPREDICTABLE>
    1bd0:	000003a6 	andeq	r0, r0, r6, lsr #7
        tempa[3] = getSBoxValue(tempa[3]);
    1bd4:	03500101 	cmpeq	r0, #1073741824	@ 0x40000000
    1bd8:	017e8491 			@ <UNDEFINED> instruction: 0x017e8491
      tempa[0] = tempa[0] ^ Rcon[i/Nk];
    1bdc:	08025101 	stmdaeq	r2, {r0, r8, ip, lr}
    1be0:	52010120 	andpl	r0, r1, #32, 2
    1be4:	00007602 	andeq	r7, r0, r2, lsl #12
    1be8:	00094205 	andeq	r4, r9, r5, lsl #4
        tempa[0] = getSBoxValue(tempa[0]);
    1bec:	00022800 	andeq	r2, r2, r0, lsl #16
    1bf0:	0003c300 	andeq	ip, r3, r0, lsl #6
    1bf4:	50010100 	andpl	r0, r1, r0, lsl #2
        tempa[1] = getSBoxValue(tempa[1]);
    1bf8:	2dd80305 	ldclcs	3, cr0, [r8, #20]
    1bfc:	01010000 	mrseq	r0, (UNDEF: 1)
        tempa[2] = getSBoxValue(tempa[2]);
    1c00:	00760251 	rsbseq	r0, r6, r1, asr r2
    1c04:	094a1900 	stmdbeq	sl, {r8, fp, ip}^
    1c08:	02280000 	eoreq	r0, r8, #0
        tempa[3] = getSBoxValue(tempa[3]);
    1c0c:	01010000 	mrseq	r0, (UNDEF: 1)
    1c10:	f8030550 			@ <UNDEFINED> instruction: 0xf8030550
    1c14:	0100002d 	tsteq	r0, sp, lsr #32
}
    1c18:	75025101 	strvc	r5, [r2, #-257]	@ 0xfffffeff
    1c1c:	0a000000 	beq	1c24 <AddRoundKey+0x4>
{
    1c20:	0000008b 	andeq	r0, r0, fp, lsl #1
  for (i = 0; i < 4; ++i)
    1c24:	000003ed 	andeq	r0, r0, sp, ror #7
      (*state)[i][j] ^= RoundKey[(round * Nb * 4) + (i * Nb) + j];
    1c28:	00007108 	andeq	r7, r0, r8, lsl #2
    1c2c:	0a003800 	beq	fc34 <__RAM_SIZE__+0x7c34>
    1c30:	0000008b 	andeq	r0, r0, fp, lsl #1
    1c34:	000003fd 	strdeq	r0, [r0], -sp
    1c38:	00007108 	andeq	r7, r0, r8, lsl #2
    1c3c:	1a001f00 	bne	9844 <__RAM_SIZE__+0x1844>
    1c40:	00000042 	andeq	r0, r0, r2, asr #32
    for (j = 0; j < 4; ++j)
    1c44:	00007108 	andeq	r7, r0, r8, lsl #2
    1c48:	00002c00 	andeq	r2, r0, r0, lsl #24
  for (i = 0; i < 4; ++i)
    1c4c:	00001091 	muleq	r0, r1, r0
    1c50:	04010005 	streq	r0, [r1], #-5
    for (j = 0; j < 4; ++j)
    1c54:	00000c75 	andeq	r0, r0, r5, ror ip
  for (i = 0; i < 4; ++i)
    1c58:	00001428 	andeq	r1, r0, r8, lsr #8
    1c5c:	06be1d00 	ldrteq	r1, [lr], r0, lsl #26
    for (j = 0; j < 4; ++j)
    1c60:	01770000 	cmneq	r7, r0
{
    1c64:	09640000 	stmdbeq	r4!, {}^	@ <UNPREDICTABLE>
      (*state)[j][i] = getSBoxValue((*state)[j][i]);
    1c68:	06800000 	streq	r0, [r0], r0
    1c6c:	0ffe0000 	svceq	0x00fe0000
    1c70:	01070000 	mrseq	r0, (UNDEF: 7)
    1c74:	0000fe06 	andeq	pc, r0, r6, lsl #28
    for (j = 0; j < 4; ++j)
    1c78:	05020700 	streq	r0, [r2, #-1792]	@ 0xfffff900
    1c7c:	00000168 	andeq	r0, r0, r8, ror #2
  for (i = 0; i < 4; ++i)
    1c80:	58050407 	stmdapl	r5, {r0, r1, r2, sl}
    1c84:	07000001 	streq	r0, [r0, -r1]
    for (j = 0; j < 4; ++j)
    1c88:	01530508 	cmpeq	r3, r8, lsl #10
}
    1c8c:	34140000 	ldrcc	r0, [r4], #-0
  for (i = 0; i < 4; ++i)
    1c90:	02000001 	andeq	r0, r0, #1
    1c94:	0053182e 	subseq	r1, r3, lr, lsr #16
    1c98:	421b0000 	andsmi	r0, fp, #0
  temp           = (*state)[0][1];
    1c9c:	07000000 	streq	r0, [r0, -r0]
  (*state)[0][1] = (*state)[1][1];
    1ca0:	00fc0801 	rscseq	r0, ip, r1, lsl #16
  (*state)[1][1] = (*state)[2][1];
    1ca4:	02070000 	andeq	r0, r7, #0
  (*state)[2][1] = (*state)[3][1];
    1ca8:	00010a07 	andeq	r0, r1, r7, lsl #20
  temp           = (*state)[0][2];
    1cac:	01b11400 			@ <UNDEFINED> instruction: 0x01b11400
  (*state)[0][2] = (*state)[2][2];
    1cb0:	34020000 	strcc	r0, [r2], #-0
  temp           = (*state)[1][2];
    1cb4:	00006d19 	andeq	r6, r0, r9, lsl sp
  (*state)[1][2] = (*state)[3][2];
    1cb8:	07040700 	streq	r0, [r4, -r0, lsl #14]
  temp           = (*state)[0][3];
    1cbc:	00000122 	andeq	r0, r0, r2, lsr #2
  (*state)[0][3] = (*state)[3][3];
    1cc0:	1d070807 	stcne	8, cr0, [r7, #-28]	@ 0xffffffe4
  (*state)[3][3] = (*state)[2][3];
    1cc4:	29000001 	stmdbcs	r0, {r0}
  (*state)[2][3] = (*state)[1][3];
    1cc8:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
}
    1ccc:	7b1c0074 	blvc	701ea4 <__ROM_SIZE__+0x6c1ea4>
  return ((x<<1) ^ (((x>>7) & 1) * 0x1b));
    1cd0:	07000000 	streq	r0, [r0, -r0]
    1cd4:	01270704 			@ <UNDEFINED> instruction: 0x01270704
    1cd8:	0d140000 	ldceq	0, cr0, [r4, #-0]
}
    1cdc:	03000000 	movweq	r0, #0
{
    1ce0:	008717d6 	ldrdeq	r1, [r7], r6
    1ce4:	08070000 	stmdaeq	r7, {}	@ <UNPREDICTABLE>
  for (i = 0; i < 4; ++i)
    1ce8:	00019e04 	andeq	r9, r1, r4, lsl #28
    t   = (*state)[i][0];
    1cec:	013c2a00 	teqeq	ip, r0, lsl #20
    Tmp = (*state)[i][0] ^ (*state)[i][1] ^ (*state)[i][2] ^ (*state)[i][3] ;
    1cf0:	01000000 	mrseq	r0, (UNDEF: 0)
    1cf4:	c9082c04 	stmdbgt	r8, {r2, sl, fp, sp}
    1cf8:	15000000 	strne	r0, [r0, #-0]
    1cfc:	00000c3f 	andeq	r0, r0, pc, lsr ip
    1d00:	c90b2e04 	stmdbgt	fp, {r2, r9, sl, fp, sp}
    1d04:	00000000 	andeq	r0, r0, r0
    Tm  = (*state)[i][0] ^ (*state)[i][1] ; Tm = xtime(Tm);  (*state)[i][0] ^= Tm ^ Tmp ;
    1d08:	0076492b 	rsbseq	r4, r6, fp, lsr #18
    1d0c:	d90b3004 	stmdble	fp, {r2, ip, sp}
    1d10:	f0000000 			@ <UNDEFINED> instruction: 0xf0000000
    Tm  = (*state)[i][1] ^ (*state)[i][2] ; Tm = xtime(Tm);  (*state)[i][1] ^= Tm ^ Tmp ;
    1d14:	00420c00 	subeq	r0, r2, r0, lsl #24
    1d18:	00d90000 	sbcseq	r0, r9, r0
    1d1c:	870b0000 	strhi	r0, [fp, -r0]
    1d20:	ef000000 	svc	0x00000000
    1d24:	00420c00 	subeq	r0, r2, r0, lsl #24
    Tm  = (*state)[i][2] ^ (*state)[i][3] ; Tm = xtime(Tm);  (*state)[i][2] ^= Tm ^ Tmp ;
    1d28:	00e90000 	rsceq	r0, r9, r0
    1d2c:	870b0000 	strhi	r0, [fp, -r0]
    1d30:	0f000000 	svceq	0x00000000
    1d34:	6d632c00 	stclvs	12, cr2, [r3, #-0]
    Tm  = (*state)[i][3] ^ t ;              Tm = xtime(Tm);  (*state)[i][3] ^= Tm ^ Tmp ;
    1d38:	2f050064 	svccs	0x00050064
    1d3c:	0000f50f 	andeq	pc, r0, pc, lsl #10
    1d40:	00fa0800 	rscseq	r0, sl, r0, lsl #16
    1d44:	7b2d0000 	blvc	b41d4c <__ROM_SIZE__+0xb01d4c>
    1d48:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
  for (i = 0; i < 4; ++i)
    1d4c:	03000001 	movweq	r0, #1
    1d50:	0000007b 	andeq	r0, r0, fp, ror r0
}
    1d54:	00010e03 	andeq	r0, r1, r3, lsl #28
{
    1d58:	13080000 	movwne	r0, #32768	@ 0x8000
    1d5c:	08000001 	stmdaeq	r0, {r0}
  for (i = 0; i < 4; ++i)
    1d60:	00000118 	andeq	r0, r0, r8, lsl r1
    a = (*state)[i][0];
    1d64:	05080107 	streq	r0, [r8, #-263]	@ 0xfffffef9
    b = (*state)[i][1];
    1d68:	1b000001 	blne	1d74 <InvMixColumns+0x1e>
    1d6c:	00000118 	andeq	r0, r0, r8, lsl r1
    c = (*state)[i][2];
    1d70:	38050c2e 	stmdacc	r5, {r1, r2, r3, r5, sl, fp}
    d = (*state)[i][3];
    1d74:	00015509 	andeq	r5, r1, r9, lsl #10
    (*state)[i][0] = Multiply(a, 0x0e) ^ Multiply(b, 0x0b) ^ Multiply(c, 0x0d) ^ Multiply(d, 0x09);
    1d78:	00c41500 	sbceq	r1, r4, r0, lsl #10
    1d7c:	39050000 	stmdbcc	r5, {}	@ <UNPREDICTABLE>
    1d80:	0001550f 	andeq	r5, r1, pc, lsl #10
    1d84:	00150000 	andseq	r0, r5, r0
    1d88:	05000000 	streq	r0, [r0, #-0]
    1d8c:	01550f3a 	cmpeq	r5, sl, lsr pc
    1d90:	15040000 	strne	r0, [r4, #-0]
    1d94:	000000bc 	strheq	r0, [r0], -ip
    1d98:	e9073b05 	stmdb	r7, {r0, r2, r8, r9, fp, ip, sp}
    1d9c:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
    1da0:	011f0800 	tsteq	pc, r0, lsl #16
    1da4:	98140000 	ldmdals	r4, {}	@ <UNPREDICTABLE>
    1da8:	05000001 	streq	r0, [r0, #-1]
    1dac:	0124033c 			@ <UNDEFINED> instruction: 0x0124033c
    1db0:	5a1b0000 	bpl	6c1db8 <__ROM_SIZE__+0x681db8>
    1db4:	1c000001 	stcne	0, cr0, [r0], {1}
    1db8:	0000015a 	andeq	r0, r0, sl, asr r1
    1dbc:	7874632f 	ldmdavc	r4!, {r0, r1, r2, r3, r5, r8, r9, sp, lr}^
    1dc0:	10190100 	andsne	r0, r9, r0, lsl #2
    1dc4:	000000a1 	andeq	r0, r0, r1, lsr #1
    1dc8:	018c0305 	orreq	r0, ip, r5, lsl #6
    1dcc:	420c2000 	andmi	r2, ip, #0
    1dd0:	92000000 	andls	r0, r0, #0
    1dd4:	0b000001 	bleq	1de0 <InvMixColumns+0x8a>
    1dd8:	00000087 	andeq	r0, r0, r7, lsl #1
    1ddc:	4309002b 	movwmi	r0, #36907	@ 0x902b
    1de0:	1a000007 	bne	1e04 <InvMixColumns+0xae>
    1de4:	00018209 	andeq	r8, r1, r9, lsl #4
    1de8:	04030500 	streq	r0, [r3], #-1280	@ 0xfffffb00
    1dec:	0c200000 	stceq	0, cr0, [r0], #-0
    1df0:	00000042 	andeq	r0, r0, r2, asr #32
    1df4:	000001b3 			@ <UNDEFINED> instruction: 0x000001b3
    1df8:	0000870b 	andeq	r8, r0, fp, lsl #14
    1dfc:	09001f00 	stmdbeq	r0, {r8, r9, sl, fp, ip}
    1e00:	0000064a 	andeq	r0, r0, sl, asr #12
    1e04:	01a3091b 			@ <UNDEFINED> instruction: 0x01a3091b
    (*state)[i][1] = Multiply(a, 0x09) ^ Multiply(b, 0x0e) ^ Multiply(c, 0x0b) ^ Multiply(d, 0x0d);
    1e08:	03050000 	movweq	r0, #20480	@ 0x5000
    1e0c:	2000016c 	andcs	r0, r0, ip, ror #2
    1e10:	0004f809 	andeq	pc, r4, r9, lsl #16
    1e14:	a3091d00 	movwge	r1, #40192	@ 0x9d00
    1e18:	05000001 	streq	r0, [r0, #-1]
    1e1c:	00003003 	andeq	r3, r0, r3
    1e20:	00420c20 	subeq	r0, r2, r0, lsr #24
    1e24:	01e50000 	mvneq	r0, r0
    1e28:	870b0000 	strhi	r0, [fp, -r0]
    1e2c:	17000000 	strne	r0, [r0, -r0]
    1e30:	04440900 	strbeq	r0, [r4], #-2304	@ 0xfffff700
    1e34:	091e0000 	ldmdbeq	lr, {}	@ <UNPREDICTABLE>
    1e38:	000001d5 	ldrdeq	r0, [r0], -r5
    1e3c:	030c0305 	movweq	r0, #49925	@ 0xc305
    (*state)[i][2] = Multiply(a, 0x0d) ^ Multiply(b, 0x09) ^ Multiply(c, 0x0e) ^ Multiply(d, 0x0b);
    1e40:	420c2000 	andmi	r2, ip, #0
    1e44:	06000000 	streq	r0, [r0], -r0
    1e48:	0b000002 	bleq	1e58 <InvMixColumns+0x102>
    1e4c:	00000087 	andeq	r0, r0, r7, lsl #1
    1e50:	5909002f 	stmdbpl	r9, {r0, r1, r2, r3, r5}
    1e54:	1f000005 	svcne	0x00000005
    1e58:	0001f609 	andeq	pc, r1, r9, lsl #12
    1e5c:	dc030500 	cfstr32le	mvfx0, [r3], {-0}
    1e60:	09200002 	stmdbeq	r0!, {r1}
    1e64:	00000565 	andeq	r0, r0, r5, ror #10
    1e68:	01f60920 	mvnseq	r0, r0, lsr #18
    1e6c:	03050000 	movweq	r0, #20480	@ 0x5000
    (*state)[i][3] = Multiply(a, 0x0b) ^ Multiply(b, 0x0d) ^ Multiply(c, 0x09) ^ Multiply(d, 0x0e);
    1e70:	200002ac 	andcs	r0, r0, ip, lsr #5
    1e74:	00046c09 	andeq	r6, r4, r9, lsl #24
    1e78:	a3092100 	movwge	r2, #37120	@ 0x9100
    1e7c:	05000001 	streq	r0, [r0, #-1]
    1e80:	00028c03 	andeq	r8, r2, r3, lsl #24
    1e84:	007b3020 	rsbseq	r3, fp, r0, lsr #32
    1e88:	6e090000 	cdpvs	0, 0, cr0, cr9, cr0, {0}
    1e8c:	24000006 	strcs	r0, [r0], #-6
    1e90:	00024f07 	andeq	r4, r2, r7, lsl #30
    1e94:	60030500 	andvs	r0, r3, r0, lsl #10
    1e98:	08200001 	stmdaeq	r0!, {r0}
    1e9c:	00000239 	andeq	r0, r0, r9, lsr r2
    1ea0:	0008ac09 	andeq	sl, r8, r9, lsl #24
  for (i = 0; i < 4; ++i)
    1ea4:	4f072500 	svcmi	0x00072500
    1ea8:	05000002 	streq	r0, [r0, #-2]
}
    1eac:	00016403 	andeq	r6, r1, r3, lsl #8
  for (i = 0; i < 4; ++i)
    1eb0:	02703120 	rsbseq	r3, r0, #32, 2
    1eb4:	18030000 	stmdane	r3, {}	@ <UNPREDICTABLE>
    for (j = 0; j < 4; ++j)
    1eb8:	00000001 	andeq	r0, r0, r1
{
    1ebc:	00080009 	andeq	r0, r8, r9
      (*state)[j][i] = getSBoxInvert((*state)[j][i]);
    1ec0:	81082600 	tsthi	r8, r0, lsl #12
    1ec4:	05000002 	streq	r0, [r0, #-2]
    1ec8:	00005003 	andeq	r5, r0, r3
    1ecc:	02650820 	rsbeq	r0, r5, #32, 16	@ 0x200000
    1ed0:	14090000 	strne	r0, [r9], #-0
    for (j = 0; j < 4; ++j)
    1ed4:	27000006 	strcs	r0, [r0, -r6]
    1ed8:	00028108 	andeq	r8, r2, r8, lsl #2
  for (i = 0; i < 4; ++i)
    1edc:	68030500 	stmdavs	r3, {r8, sl}
    1ee0:	24200001 	strtcs	r0, [r0], #-1
    for (j = 0; j < 4; ++j)
    1ee4:	00000719 	andeq	r0, r0, r9, lsl r7
}
    1ee8:	00006d29 	andeq	r6, r0, r9, lsr #26
  for (i = 0; i < 4; ++i)
    1eec:	078e2400 	streq	r2, [lr, r0, lsl #8]
    1ef0:	6d2a0000 	stcvs	0, cr0, [sl, #-0]
    1ef4:	25000000 	strcs	r0, [r0, #-0]
  temp = (*state)[3][1];
    1ef8:	00000224 	andeq	r0, r0, r4, lsr #4
  (*state)[3][1] = (*state)[2][1];
    1efc:	0002b52c 	andeq	fp, r2, ip, lsr #10
  (*state)[2][1] = (*state)[1][1];
    1f00:	01660800 	cmneq	r6, r0, lsl #16
  (*state)[1][1] = (*state)[0][1];
    1f04:	a2250000 	eorge	r0, r5, #0
  temp = (*state)[0][2];
    1f08:	2d000008 	stccs	0, cr0, [r0, #-32]	@ 0xffffffe0
  (*state)[0][2] = (*state)[2][2];
    1f0c:	000002b5 			@ <UNDEFINED> instruction: 0x000002b5
  temp = (*state)[1][2];
    1f10:	00082111 	andeq	r2, r8, r1, lsl r1
  (*state)[1][2] = (*state)[3][2];
    1f14:	82152e00 	andshi	r2, r5, #0, 28
  temp = (*state)[0][3];
    1f18:	05000000 	streq	r0, [r0, #-0]
  (*state)[0][3] = (*state)[1][3];
    1f1c:	00015803 	andeq	r5, r1, r3, lsl #16
  (*state)[1][3] = (*state)[2][3];
    1f20:	077b1120 	ldrbeq	r1, [fp, -r0, lsr #2]!
  (*state)[2][3] = (*state)[3][3];
    1f24:	15360000 	ldrne	r0, [r6, #-0]!
}
    1f28:	00000082 	andeq	r0, r0, r2, lsl #1
{
    1f2c:	00540305 	subseq	r0, r4, r5, lsl #6
  AddRoundKey(0, state, RoundKey);
    1f30:	60112000 	andsvs	r2, r1, r0
    1f34:	37000008 	strcc	r0, [r0, -r8]
    1f38:	00008215 	andeq	r8, r0, r5, lsl r2
  for (round = 1; ; ++round)
    1f3c:	5c030500 	cfstr32pl	mvfx0, [r3], {-0}
    MixColumns(state);
    1f40:	0c200001 	stceq	0, cr0, [r0], #-4
    AddRoundKey(round, state, RoundKey);
    1f44:	00000118 	andeq	r0, r0, r8, lsl r1
    1f48:	0000030d 	andeq	r0, r0, sp, lsl #6
    1f4c:	0000870b 	andeq	r8, r0, fp, lsl #14
  for (round = 1; ; ++round)
    1f50:	870b0100 	strhi	r0, [fp, -r0, lsl #2]
    SubBytes(state);
    1f54:	7f000000 	svcvc	0x00000000
    ShiftRows(state);
    1f58:	06b21100 	ldrteq	r1, [r2], r0, lsl #2
    1f5c:	0d380000 	ldceq	0, cr0, [r8, #-0]
    if (round == Nr) {
    1f60:	000002f7 	strdeq	r0, [r0], -r7
  AddRoundKey(Nr, state, RoundKey);
    1f64:	00580305 	subseq	r0, r8, r5, lsl #6
    1f68:	91112000 	tstls	r1, r0
}
    1f6c:	3b000008 	blcc	1f94 <InvCipher+0x26>
{
    1f70:	00033616 	andeq	r3, r3, r6, lsl r6
  AddRoundKey(Nr, state, RoundKey);
    1f74:	00030500 	andeq	r0, r3, r0, lsl #10
    1f78:	07200000 	streq	r0, [r0, -r0]!
    1f7c:	07d90201 	ldrbeq	r0, [r9, r1, lsl #4]
  for (round = (Nr - 1); ; --round)
    1f80:	2f1c0000 	svccs	0x001c0000
    InvMixColumns(state);
    1f84:	09000003 	stmdbeq	r0, {r0, r1}
  for (round = (Nr - 1); ; --round)
    1f88:	0000062b 	andeq	r0, r0, fp, lsr #12
    InvShiftRows(state);
    1f8c:	015a019e 			@ <UNDEFINED> instruction: 0x015a019e
    1f90:	03050000 	movweq	r0, #20480	@ 0x5000
    InvSubBytes(state);
    1f94:	000028b8 			@ <UNDEFINED> instruction: 0x000028b8
    AddRoundKey(round, state, RoundKey);
    1f98:	0007bd1d 	andeq	fp, r7, sp, lsl sp
    1f9c:	5a01f400 	bpl	7efa4 <__ROM_SIZE__+0x3efa4>
    1fa0:	05000001 	streq	r0, [r0, #-1]
    if (round == 0) {
    1fa4:	00290003 	eoreq	r0, r9, r3
  for (i = 0; i < AES_BLOCKLEN; ++i) // The block in AES is always 128bit no matter the key size
    1fa8:	06911d00 	ldreq	r1, [r1], r0, lsl #26
    buf[i] ^= Iv[i];
    1fac:	01f50000 	mvnseq	r0, r0
    1fb0:	0000015a 	andeq	r0, r0, sl, asr r1
    1fb4:	28ac0305 	stmiacs	ip!, {r0, r2, r8, r9}
  for (i = 0; i < AES_BLOCKLEN; ++i) // The block in AES is always 128bit no matter the key size
    1fb8:	5a1d0000 	bpl	741fc0 <__ROM_SIZE__+0x701fc0>
    1fbc:	f6000006 			@ <UNDEFINED> instruction: 0xf6000006
}
    1fc0:	00015a01 	andeq	r5, r1, r1, lsl #20
  KeyExpansion(ctx->RoundKey, key);
    1fc4:	a0030500 	andge	r0, r3, r0, lsl #10
}
    1fc8:	12000028 	andne	r0, r0, #40	@ 0x28
{
    1fcc:	00000772 	andeq	r0, r0, r2, ror r7
  KeyExpansion(ctx->RoundKey, key);
    1fd0:	6b3c01fa 	blvs	f027c0 <__ROM_SIZE__+0xec27c0>
  memcpy (ctx->Iv, iv, AES_BLOCKLEN);
    1fd4:	05000001 	streq	r0, [r0, #-1]
    1fd8:	00290c03 	eoreq	r0, r9, r3, lsl #24
    1fdc:	07121000 	ldreq	r1, [r2, -r0]
}
    1fe0:	41060000 	mrsmi	r0, (UNDEF: 6)
  memcpy (ctx->Iv, iv, AES_BLOCKLEN);
    1fe4:	0003b107 	andeq	fp, r3, r7, lsl #2
    1fe8:	0003b100 	andeq	fp, r3, r0, lsl #2
}
    1fec:	03b10300 			@ <UNDEFINED> instruction: 0x03b10300
{
    1ff0:	7b030000 	blvc	c1ff8 <__ROM_SIZE__+0x81ff8>
  Cipher((state_t*)buf, ctx->RoundKey);
    1ff4:	03000000 	movweq	r0, #0
    1ff8:	0000008e 	andeq	r0, r0, lr, lsl #1
{
    1ffc:	10043200 	andne	r3, r4, r0, lsl #4
  InvCipher((state_t*)buf, ctx->RoundKey);
    2000:	000001aa 	andeq	r0, r0, sl, lsr #3
    2004:	8e081f06 	cdphi	15, 0, cr1, cr8, cr6, {0}
}
    2008:	c9000000 	stmdbgt	r0, {}	@ <UNPREDICTABLE>
{
    200c:	03000003 	movweq	r0, #3
    2010:	00000155 	andeq	r0, r0, r5, asr r1
  uint8_t *Iv = ctx->Iv;
    2014:	068a1000 	streq	r1, [sl], r0
    2018:	38060000 	stmdacc	r6, {}	@ <UNPREDICTABLE>
  for (i = 0; i < length; i += AES_BLOCKLEN)
    201c:	0003b107 	andeq	fp, r3, r7, lsl #2
    XorWithIv(buf, Iv);
    2020:	0003e900 	andeq	lr, r3, r0, lsl #18
    Cipher((state_t*)buf, ctx->RoundKey);
    2024:	03b10300 			@ <UNDEFINED> instruction: 0x03b10300
    2028:	e9030000 	stmdb	r3, {}	@ <UNPREDICTABLE>
  for (i = 0; i < length; i += AES_BLOCKLEN)
    202c:	03000003 	movweq	r0, #3
    buf += AES_BLOCKLEN;
    2030:	0000008e 	andeq	r0, r0, lr, lsl #1
  for (i = 0; i < length; i += AES_BLOCKLEN)
    2034:	03ee0800 	mvneq	r0, #0, 16
  memcpy(ctx->Iv, Iv, AES_BLOCKLEN);
    2038:	10330000 	eorsne	r0, r3, r0
    203c:	0000014c 	andeq	r0, r0, ip, asr #2
}
    2040:	7b052706 	blvc	14bc60 <__ROM_SIZE__+0x10bc60>
{
    2044:	0a000000 	beq	204c <AES_CBC_decrypt_buffer+0xa>
    2048:	03000004 	movweq	r0, #4
    204c:	00000155 	andeq	r0, r0, r5, asr r1
  for (i = 0; i < length; i += AES_BLOCKLEN)
    2050:	00015503 	andeq	r5, r1, r3, lsl #10
    memcpy(storeNextIv, buf, AES_BLOCKLEN);
    2054:	29340000 	ldmdbcs	r4!, {}	@ <UNPREDICTABLE>
    2058:	04000005 	streq	r0, [r0], #-5
    InvCipher((state_t*)buf, ctx->RoundKey);
    205c:	04210634 	strteq	r0, [r1], #-1588	@ 0xfffff9cc
    2060:	21030000 	mrscs	r0, (UNDEF: 3)
    XorWithIv(buf, ctx->Iv);
    2064:	03000004 	movweq	r0, #4
    2068:	00000426 	andeq	r0, r0, r6, lsr #8
    206c:	00a10800 	adceq	r0, r1, r0, lsl #16
    memcpy(ctx->Iv, storeNextIv, AES_BLOCKLEN);
    2070:	4e080000 	cdpmi	0, 0, cr0, cr8, cr0, {0}
    2074:	10000000 	andne	r0, r0, r0
    2078:	000000d1 	ldrdeq	r0, [r0], -r1
  for (i = 0; i < length; i += AES_BLOCKLEN)
    207c:	870e4a07 	strhi	r4, [lr, -r7, lsl #20]
    2080:	4b000000 	blmi	2088 <AES_CTR_xcrypt_buffer>
}
    2084:	03000004 	movweq	r0, #4
{
    2088:	0000044b 	andeq	r0, r0, fp, asr #8
    208c:	00008703 	andeq	r8, r0, r3, lsl #14
    2090:	044b0300 	strbeq	r0, [fp], #-768	@ 0xfffffd00
  for (i = 0, bi = AES_BLOCKLEN; i < length; ++i, ++bi)
    2094:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
          ctx->Iv[bi] = 0;
    2098:	00000053 	andeq	r0, r0, r3, asr r0
    209c:	00034135 	andeq	r4, r3, r5, lsr r1
      for (bi = (AES_BLOCKLEN - 1); bi >= 0; --bi)
    20a0:	068a0500 	streq	r0, [sl], r0, lsl #10
      bi = 0;
    20a4:	00016110 	andeq	r6, r1, r0, lsl r1
    buf[i] = (buf[i] ^ buffer[bi]);
    20a8:	052c0800 	streq	r0, [ip, #-2048]!	@ 0xfffff800
    20ac:	0000007b 	andeq	r0, r0, fp, ror r0
    20b0:	0000046f 	andeq	r0, r0, pc, ror #8
    20b4:	00015503 	andeq	r5, r1, r3, lsl #10
    20b8:	16003600 	strne	r3, [r0], -r0, lsl #12
  for (i = 0, bi = AES_BLOCKLEN; i < length; ++i, ++bi)
    20bc:	00000823 	andeq	r0, r0, r3, lsr #16
    20c0:	007b01ee 	rsbseq	r0, fp, lr, ror #3
    if (bi == AES_BLOCKLEN) /* we need to regen xor compliment in buffer */
    20c4:	0a640000 	beq	19020cc <__ROM_SIZE__+0x18c20cc>
      memcpy(buffer, ctx->Iv, AES_BLOCKLEN);
    20c8:	001c0000 	andseq	r0, ip, r0
    20cc:	9c010000 	stcls	0, cr0, [r1], {-0}
    20d0:	000004c4 	andeq	r0, r0, r4, asr #9
      Cipher((state_t*)buffer,ctx->RoundKey);
    20d4:	0001720d 	andeq	r7, r1, sp, lsl #4
    20d8:	1901ee00 	stmdbne	r1, {r9, sl, fp, sp, lr, pc}
      for (bi = (AES_BLOCKLEN - 1); bi >= 0; --bi)
    20dc:	0000007b 	andeq	r0, r0, fp, ror r0
    20e0:	00000330 	andeq	r0, r0, r0, lsr r3
        if (ctx->Iv[bi] == 255)
    20e4:	0000032c 	andeq	r0, r0, ip, lsr #6
    20e8:	0000b70d 	andeq	fp, r0, sp, lsl #14
        ctx->Iv[bi] += 1;
    20ec:	2601ee00 	strcs	lr, [r1], -r0, lsl #28
    20f0:	0000010e 	andeq	r0, r0, lr, lsl #2
      bi = 0;
    20f4:	00000346 	andeq	r0, r0, r6, asr #6
}
    20f8:	00000342 	andeq	r0, r0, r2, asr #6
  return ((x[idx / 32U] >> (idx & 31U) & 1U));
    20fc:	000a7206 	andeq	r7, sl, r6, lsl #4
    2100:	00045800 	andeq	r5, r4, r0, lsl #16
    2104:	50010100 	andpl	r0, r1, r0, lsl #2
}
    2108:	2e980305 	cdpcs	3, 9, cr0, cr8, cr5, {0}
    210c:	00000000 	andeq	r0, r0, r0
  x[idx / 32U] &= ~(1U << (idx & 31U));
    2110:	00000816 	andeq	r0, r0, r6, lsl r8
    2114:	7b01d400 	blvc	7711c <__ROM_SIZE__+0x3711c>
    2118:	ec000000 	stc	0, cr0, [r0], {-0}
    211c:	6800000a 	stmdavs	r0, {r1, r3}
    2120:	01000000 	mrseq	r0, (UNDEF: 0)
    2124:	00059a9c 	muleq	r5, ip, sl
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2128:	01720d00 	cmneq	r2, r0, lsl #26
    x[i] = y[i];
    212c:	01d40000 	bicseq	r0, r4, r0
    2130:	00007b0e 	andeq	r7, r0, lr, lsl #22
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2134:	00035c00 	andeq	r5, r3, r0, lsl #24
    2138:	00035800 	andeq	r5, r3, r0, lsl #16
{
    213c:	00b70d00 	adcseq	r0, r7, r0, lsl #26
    2140:	01d40000 	bicseq	r0, r4, r0
  bitvec_copy(tmp, x);
    2144:	00010e1b 	andeq	r0, r1, fp, lsl lr
    2148:	00037400 	andeq	r7, r3, r0, lsl #8
  bitvec_copy(x, y);
    214c:	00036e00 	andeq	r6, r3, r0, lsl #28
    2150:	00690e00 	rsbeq	r0, r9, r0, lsl #28
  bitvec_copy(y, tmp);
    2154:	7b0701d5 	blvc	1c28b0 <__ROM_SIZE__+0x1828b0>
    2158:	95000000 	strls	r0, [r0, #-0]
}
    215c:	8d000003 	stchi	0, cr0, [r0, #-12]
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2160:	17000003 	strne	r0, [r0, -r3]
    2164:	00000652 	andeq	r0, r0, r2, asr r6
    if (x[i] != y[i])
    2168:	2f0801d7 	svccs	0x000801d7
    216c:	bc000003 	stclt	0, cr0, [r0], {3}
    2170:	b4000003 	strlt	r0, [r0], #-3
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2174:	02000003 	andeq	r0, r0, #3
  return 1;
    2178:	00000afc 	strdeq	r0, [r0], -ip
}
    217c:	000003ef 	andeq	r0, r0, pc, ror #7
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2180:	00000542 	andeq	r0, r0, r2, asr #10
    x[i] = 0;
    2184:	05510101 	ldrbeq	r0, [r1, #-257]	@ 0xfffffeff
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2188:	002f2403 	eoreq	r2, pc, r3, lsl #8
    218c:	04020000 	streq	r0, [r2], #-0
  uint32_t i = 0;
    2190:	5800000b 	stmdapl	r0, {r0, r1, r3}
  while (i < BITVEC_NWORDS)
    2194:	59000004 	stmdbpl	r0, {r2}
    if (x[i] != 0)
    2198:	01000005 	tsteq	r0, r5
    i += 1;
    219c:	03055001 	movweq	r5, #20481	@ 0x5001
}
    21a0:	00002f28 	andeq	r2, r0, r8, lsr #30
    21a4:	0b100200 	bleq	4029ac <__ROM_SIZE__+0x3c29ac>
    21a8:	04580000 	ldrbeq	r0, [r8], #-0
  x += BITVEC_NWORDS;
    21ac:	05700000 	ldrbeq	r0, [r0, #-0]!
          && (*(--x)) == 0)
    21b0:	01010000 	mrseq	r0, (UNDEF: 1)
    21b4:	4c030550 	cfstr32mi	mvfx0, [r3], {80}	@ 0x50
    21b8:	0000002f 	andeq	r0, r0, pc, lsr #32
    i -= 32;
    21bc:	000b2204 	andeq	r2, fp, r4, lsl #4
  if (i != 0)
    21c0:	00045800 	andeq	r5, r4, r0, lsl #16
      i -= 1;
    21c4:	0b2c0200 	bleq	b029cc <__ROM_SIZE__+0xac29cc>
    while (((*x) & u32mask) == 0)
    21c8:	04580000 	ldrbeq	r0, [r8], #-0
}
    21cc:	05900000 	ldreq	r0, [r0]
    uint32_t u32mask = ((uint32_t)1 << 31);
    21d0:	01010000 	mrseq	r0, (UNDEF: 1)
{
    21d4:	48030550 	stmdami	r3, {r4, r6, r8, sl}
  int nwords = (nbits / 32);
    21d8:	0000002f 	andeq	r0, r0, pc, lsr #32
    21dc:	000b3604 	andeq	r3, fp, r4, lsl #12
  for (i = 0; i < nwords; ++i)
    21e0:	00045800 	andeq	r5, r4, r0, lsl #16
  int nwords = (nbits / 32);
    21e4:	33160000 	tstcc	r6, #0
    21e8:	cb000008 	blgt	2210 <bitvec_lshift+0x3c>
    x[i] = 0;
    21ec:	0000e901 	andeq	lr, r0, r1, lsl #18
  for (i = 0; i < nwords; ++i)
    21f0:	000fb400 	andeq	fp, pc, r0, lsl #8
    21f4:	00003000 	andeq	r3, r0, r0
  j = 0;
    21f8:	f49c0100 			@ <UNDEFINED> instruction: 0xf49c0100
    x[i] = y[j];
    21fc:	0d000005 	stceq	0, cr0, [r0, #-20]	@ 0xffffffec
    2200:	000006ea 	andeq	r0, r0, sl, ror #13
    i += 1;
    2204:	131d01cb 	tstne	sp, #-1073741774	@ 0xc0000032
    j += 1;
    2208:	e1000001 	tst	r0, r1
  while (i < BITVEC_NWORDS)
    220c:	db000003 	blle	2220 <bitvec_lshift+0x4c>
  if (nbits != 0)
    2210:	1e000003 	cdpne	0, 0, cr0, cr0, cr3, {0}
}
    2214:	00000fb8 			@ <UNDEFINED> instruction: 0x00000fb8
      x[i]  = (x[i] << nbits) | (x[i - 1] >> (32 - nbits));
    2218:	00000024 	andeq	r0, r0, r4, lsr #32
    221c:	cc00690e 			@ <UNDEFINED> instruction: 0xcc00690e
    2220:	007b0c01 	rsbseq	r0, fp, r1, lsl #24
    2224:	03fe0000 	mvnseq	r0, #0
    2228:	03fa0000 	mvnseq	r0, #0
    222c:	d0060000 	andle	r0, r6, r0
    2230:	ef00000f 	svc	0x0000000f
    2234:	01000003 	tsteq	r0, r3
    for (i = (BITVEC_NWORDS - 1); i > 0; --i)
    2238:	76025001 	strvc	r5, [r2], -r1
    x[0] <<= nbits;
    223c:	00000000 	andeq	r0, r0, r0
    2240:	00070216 	andeq	r0, r7, r6, lsl r2
    for (i = (BITVEC_NWORDS - 1); i > 0; --i)
    2244:	7b01bc00 	blvc	7124c <__ROM_SIZE__+0x3124c>
  x[0] = 1;
    2248:	88000000 	stmdahi	r0, {}	@ <UNPREDICTABLE>
  for (i = 1; i < BITVEC_NWORDS; ++i)
    224c:	2c00000f 	stccs	0, cr0, [r0], {15}
    x[i] = 0;
    2250:	01000000 	mrseq	r0, (UNDEF: 0)
  for (i = 1; i < BITVEC_NWORDS; ++i)
    2254:	0006779c 	muleq	r6, ip, r7
    2258:	06ea0d00 	strbteq	r0, [sl], r0, lsl #26
  if (x[0] != 1)
    225c:	01bc0000 			@ <UNDEFINED> instruction: 0x01bc0000
    2260:	00011310 	andeq	r1, r1, r0, lsl r3
  for (i = 1; i < BITVEC_NWORDS; ++i)
    2264:	00041400 	andeq	r1, r4, r0, lsl #8
    if (x[i] != 0)
    2268:	00040e00 	andeq	r0, r4, r0, lsl #28
  for (i = 1; i < BITVEC_NWORDS; ++i)
    226c:	01721700 	cmneq	r2, r0, lsl #14
  return (i == BITVEC_NWORDS);
    2270:	01bd0000 			@ <UNDEFINED> instruction: 0x01bd0000
    2274:	00007b07 	andeq	r7, r0, r7, lsl #22
    2278:	00043100 	andeq	r3, r4, r0, lsl #2
}
    227c:	00042d00 	andeq	r2, r4, r0, lsl #26
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2280:	00b71200 	adcseq	r1, r7, r0, lsl #4
{
    2284:	01c00000 	biceq	r0, r0, r0
    z[i] = (x[i] ^ y[i]);
    2288:	00067709 	andeq	r7, r6, r9, lsl #14
    228c:	f8910300 			@ <UNDEFINED> instruction: 0xf8910300
    2290:	0f96027d 	svceq	0x0096027d
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2294:	0a950000 	beq	fe54229c <_STACK_TOP_+0xde53a2a0>
    2298:	06660000 	strbteq	r0, [r6], -r0
}
    229c:	01010000 	mrseq	r0, (UNDEF: 1)
  x[0] ^= 1;
    22a0:	007d0250 	rsbseq	r0, sp, r0, asr r2
    22a4:	03510101 	cmpeq	r1, #1073741824	@ 0x40000000
}
    22a8:	015001a3 	cmpeq	r0, r3, lsr #3
{
    22ac:	08025201 	stmdaeq	r2, {r0, r9, ip, lr}
    22b0:	ac060040 	stcge	0, cr0, [r6], {64}	@ 0x40
  bitvec_copy(tmp, x);
    22b4:	fa00000f 	blx	22f8 <gf2field_mul+0x4e>
    22b8:	01000009 	tsteq	r0, r9
  if (bitvec_get_bit(y, 0) != 0)
    22bc:	7d025101 	stfvcs	f5, [r2, #-4]
    22c0:	0c000000 	stceq	0, cr0, [r0], {-0}
    bitvec_copy(z, x);
    22c4:	00000113 	andeq	r0, r0, r3, lsl r1
    22c8:	00000687 	andeq	r0, r0, r7, lsl #13
{
    22cc:	0000870b 	andeq	r8, r0, fp, lsl #14
    bitvec_set_zero(z);
    22d0:	37003f00 	strcc	r3, [r0, -r0, lsl #30]
    22d4:	000007f2 	strdeq	r0, [r0], -r2
      gf2field_add(tmp, tmp, polynomial);
    22d8:	0601af01 	streq	sl, [r1], -r1, lsl #30
    22dc:	00000f50 	andeq	r0, r0, r0, asr pc
    22e0:	00000038 	andeq	r0, r0, r8, lsr r0
  for (i = 1; i < CURVE_DEGREE; ++i)
    22e4:	07019c01 	streq	r9, [r1, -r1, lsl #24]
    22e8:	56040000 	strpl	r0, [r4], -r0
    bitvec_lshift(tmp, tmp, 1);
    22ec:	0100000f 	tsteq	r0, pc
    22f0:	04000007 	streq	r0, [r0], #-7
    if (bitvec_get_bit(tmp, CURVE_DEGREE))
    22f4:	00000f5a 	andeq	r0, r0, sl, asr pc
    22f8:	000007bc 			@ <UNDEFINED> instruction: 0x000007bc
    22fc:	000f5e04 	andeq	r5, pc, r4, lsl #28
    if (bitvec_get_bit(y, i))
    2300:	000ffe00 	andeq	pc, pc, r0, lsl #28
    2304:	0f6e0200 	svceq	0x006e0200
    2308:	042b0000 	strteq	r0, [fp], #-0
      gf2field_add(z, z, tmp);
    230c:	06dc0000 	ldrbeq	r0, [ip], r0
    2310:	01010000 	mrseq	r0, (UNDEF: 1)
    2314:	04030550 	streq	r0, [r3], #-1360	@ 0xfffffab0
}
    2318:	01200000 			@ <UNDEFINED> instruction: 0x01200000
    231c:	08025101 	stmdaeq	r2, {r0, r8, ip, lr}
{
    2320:	5201012c 	andpl	r0, r1, #44, 2
    2324:	00007502 	andeq	r7, r0, r2, lsl #10
  bitvec_copy(u, x);
    2328:	000f7802 	andeq	r7, pc, r2, lsl #16
  bitvec_copy(v, polynomial);
    232c:	00040a00 	andeq	r0, r4, r0, lsl #20
    2330:	0006f700 	andeq	pc, r6, r0, lsl #14
  bitvec_set_zero(g);
    2334:	50010100 	andpl	r0, r1, r0, lsl #2
    2338:	02bc7403 	adcseq	r7, ip, #50331648	@ 0x3000000
  gf2field_set_one(z);
    233c:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
  while (!gf2field_is_one(u))
    2340:	04000075 	streq	r0, [r0], #-117	@ 0xffffff8b
    bitvec_lshift(h, v, i);
    2344:	00000f7c 	andeq	r0, r0, ip, ror pc
    2348:	00000800 	andeq	r0, r0, r0, lsl #16
    gf2field_add(u, u, h);
    234c:	067c3800 	ldrbteq	r3, [ip], -r0, lsl #16
    2350:	81010000 	mrshi	r0, (UNDEF: 1)
    2354:	09642c01 	stmdbeq	r4!, {r0, sl, fp, sp}^
    bitvec_lshift(h, g, i);
    2358:	006c0000 	rsbeq	r0, ip, r0
    235c:	9c010000 	stcls	0, cr0, [r1], {-0}
    gf2field_add(z, z, h);
    2360:	00000765 	andeq	r0, r0, r5, ror #14
    2364:	0008bb13 	andeq	fp, r8, r3, lsl fp
    2368:	01180f00 	tsteq	r8, r0, lsl #30
  while (!gf2field_is_one(u))
    236c:	37130000 	ldrcc	r0, [r3, -r0]
    2370:	17000007 	strne	r0, [r0, -r7]
    i = (bitvec_degree(u) - bitvec_degree(v));
    2374:	00000118 	andeq	r0, r0, r8, lsl r1
    2378:	00062413 	andeq	r2, r6, r3, lsl r4
    237c:	01181e00 	tsteq	r8, r0, lsl #28
    2380:	c2130000 	andsgt	r0, r3, #0
    if (i < 0)
    2384:	26000008 	strcs	r0, [r0], -r8
      bitvec_swap(u, v);
    2388:	00000118 	andeq	r0, r0, r8, lsl r1
    238c:	00070c13 	andeq	r0, r7, r3, lsl ip
      bitvec_swap(g, z);
    2390:	01182c00 	tsteq	r8, r0, lsl #24
    2394:	73260000 			@ <UNDEFINED> instruction: 0x73260000
      i = -i;
    2398:	09006372 	stmdbeq	r0, {r1, r4, r5, r6, r8, r9, sp, lr}
}
    239c:	00000113 	andeq	r0, r0, r3, lsl r1
    23a0:	26749102 	ldrbtcs	r9, [r4], -r2, lsl #2
{
    23a4:	00747364 	rsbseq	r7, r4, r4, ror #6
    23a8:	00011319 	andeq	r1, r1, r9, lsl r3
  bitvec_copy(x1, x2);
    23ac:	70910200 	addsvc	r0, r1, r0, lsl #4
  bitvec_copy(y1, y2);
    23b0:	07c13900 	strbeq	r3, [r1, r0, lsl #18]
    23b4:	7a010000 	bvc	423bc <__ROM_SIZE__+0x23bc>
}
    23b8:	007b0c01 	rsbseq	r0, fp, r1, lsl #24
{
    23bc:	0a800000 	beq	fe0023c4 <_STACK_TOP_+0xddffa3c8>
  bitvec_set_zero(x);
    23c0:	00100000 	andseq	r0, r0, r0
  bitvec_set_zero(y);
    23c4:	9c010000 	stcls	0, cr0, [r1], {-0}
}
    23c8:	000007bc 			@ <UNDEFINED> instruction: 0x000007bc
{
    23cc:	0001720d 	andeq	r7, r1, sp, lsl #4
  return (    bitvec_is_zero(x)
    23d0:	1b017a00 	blne	60bd8 <__ROM_SIZE__+0x20bd8>
           && bitvec_is_zero(y));
    23d4:	0000007b 	andeq	r0, r0, fp, ror r0
    23d8:	00000444 	andeq	r0, r0, r4, asr #8
    23dc:	00000440 	andeq	r0, r0, r0, asr #8
{
    23e0:	0000b70d 	andeq	fp, r0, sp, lsl #14
    23e4:	28017a00 	stmdacs	r1, {r9, fp, ip, sp, lr}
  if (bitvec_is_zero(x))
    23e8:	0000010e 	andeq	r0, r0, lr, lsl #2
    23ec:	0000045a 	andeq	r0, r0, sl, asr r4
    bitvec_set_zero(y);
    23f0:	00000456 	andeq	r0, r0, r6, asr r4
}
    23f4:	000a8806 	andeq	r8, sl, r6, lsl #16
    gf2field_inv(l, x);
    23f8:	00045800 	andeq	r5, r4, r0, lsl #16
    23fc:	50010100 	andpl	r0, r1, r0, lsl #2
    gf2field_mul(l, l, y);
    2400:	2e9c0305 	cdpcs	3, 9, cr0, cr12, cr5, {0}
    2404:	00000000 	andeq	r0, r0, r0
    2408:	0008513a 	andeq	r5, r8, sl, lsr r1
    gf2field_add(l, l, x);
    240c:	01740100 	cmneq	r4, r0, lsl #2
    2410:	0009fe0d 	andeq	pc, r9, sp, lsl #28
    gf2field_mul(y, x, x);
    2414:	00002600 	andeq	r2, r0, r0, lsl #12
    2418:	009c0100 	addseq	r0, ip, r0, lsl #2
    241c:	1e000008 	cdpne	0, 0, cr0, cr0, cr8, {0}
    gf2field_mul(x, l, l);
    2420:	00000a00 	andeq	r0, r0, r0, lsl #20
    2424:	0000001e 	andeq	r0, r0, lr, lsl r0
    gf2field_inc(l);
    2428:	7500690e 	strvc	r6, [r0, #-2318]	@ 0xfffff6f2
    242c:	007b0c01 	rsbseq	r0, fp, r1, lsl #24
    gf2field_add(x, x, l);
    2430:	04700000 	ldrbteq	r0, [r0], #-0
    2434:	046c0000 	strbteq	r0, [ip], #-0
    gf2field_mul(l, l, x);
    2438:	0c1f0000 	ldceq	0, cr0, [pc], {-0}
    243c:	0100000a 	tsteq	r0, sl
    2440:	30015001 	andcc	r5, r1, r1
    gf2field_add(y, y, l);
    2444:	01510101 	cmpeq	r1, r1, lsl #2
    2448:	00000030 	andeq	r0, r0, r0, lsr r0
}
    244c:	00073d3b 	andeq	r3, r7, fp, lsr sp
{
    2450:	01010100 	mrseq	r0, (UNDEF: 17)
    2454:	000dd80d 	andeq	sp, sp, sp, lsl #16
    2458:	00017800 	andeq	r7, r1, r0, lsl #16
  if (!gf2point_is_zero(x2, y2))
    245c:	ea9c0100 	b	fe702864 <_STACK_TOP_+0xde6fa868>
    2460:	0e000009 	cdpeq	0, 0, cr0, cr0, cr9, {0}
    if (gf2point_is_zero(x1, y1))
    2464:	01020073 	tsteq	r2, r3, ror r0
    2468:	00007b07 	andeq	r7, r0, r7, lsl #22
    246c:	00048600 	andeq	r8, r4, r0, lsl #12
      if (bitvec_equal(x1, x2))
    2470:	00048000 	andeq	r8, r4, r0
    2474:	01721700 	cmneq	r2, r0, lsl #14
        if (bitvec_equal(y1, y2))
    2478:	01020000 	mrseq	r0, (UNDEF: 2)
    247c:	00007b0a 	andeq	r7, r0, sl, lsl #22
    2480:	0004a000 	andeq	sl, r4, r0
          gf2point_double(x1, y1);
    2484:	00049c00 	andeq	r9, r4, r0, lsl #24
    2488:	084b1200 	stmdaeq	fp, {r9, ip}^
      gf2point_copy(x1, y1, x2, y2);
    248c:	01030000 	mrseq	r0, (UNDEF: 3)
    2490:	00007b07 	andeq	r7, r0, r7, lsl #22
    2494:	6c910200 	lfmvs	f0, 4, [r1], {0}
}
    2498:	0007a817 	andeq	sl, r7, r7, lsl r8
          gf2point_set_zero(x1, y1);
    249c:	07010400 	streq	r0, [r1, -r0, lsl #8]
    24a0:	0000007b 	andeq	r0, r0, fp, ror r0
    24a4:	000004bf 			@ <UNDEFINED> instruction: 0x000004bf
        gf2field_add(a, y1, y2);
    24a8:	000004af 	andeq	r0, r0, pc, lsr #9
    24ac:	0500630e 	streq	r6, [r0, #-782]	@ 0xfffffcf2
        gf2field_add(b, x1, x2);
    24b0:	01180801 	tsteq	r8, r1, lsl #16
    24b4:	05000000 	streq	r0, [r0, #-0]
    24b8:	04fa0000 	ldrbteq	r0, [sl], #0
        gf2field_inv(c, b);
    24bc:	2d120000 	ldccs	0, cr0, [r2, #-0]
    24c0:	07000007 	streq	r0, [r0, -r7]
        gf2field_mul(c, c, a);
    24c4:	09ea0801 	stmibeq	sl!, {r0, fp}^
    24c8:	91030000 	mrsls	r0, (UNDEF: 3)
        gf2field_mul(d, c, c);
    24cc:	b7127eec 	ldrlt	r7, [r2, -ip, ror #29]
    24d0:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
    24d4:	06770901 	ldrbteq	r0, [r7], -r1, lsl #18
        gf2field_add(d, d, c);
    24d8:	91030000 	mrsls	r0, (UNDEF: 3)
    24dc:	e0207cec 	eor	r7, r0, ip, ror #25
        gf2field_add(d, d, b);
    24e0:	1400000d 	strne	r0, [r0], #-13
    24e4:	b2000000 	andlt	r0, r0, #0
    24e8:	0e000008 	cdpeq	0, 0, cr0, cr0, cr8, {0}
        gf2field_inc(d);
    24ec:	010a0069 	tsteq	sl, r9, rrx
        gf2field_add(x1, x1, d);
    24f0:	00007b0c 	andeq	r7, r0, ip, lsl #22
    24f4:	00051a00 	andeq	r1, r5, r0, lsl #20
    24f8:	00051600 	andeq	r1, r5, r0, lsl #12
        gf2field_mul(a, x1, c);
    24fc:	f4200000 	vld4.8	{d0-d3}, [r0], r0
    2500:	1200000d 	andne	r0, r0, #13
        gf2field_add(a, a, d);
    2504:	d2000000 	andle	r0, r0, #0
    2508:	0e000008 	cdpeq	0, 0, cr0, cr0, cr8, {0}
    250c:	010c0069 	tsteq	ip, r9, rrx
        gf2field_add(y1, y1, a);
    2510:	00007b0c 	andeq	r7, r0, ip, lsl #22
    2514:	00052c00 	andeq	r2, r5, r0, lsl #24
        bitvec_copy(x1, d);
    2518:	00052a00 	andeq	r2, r5, r0, lsl #20
    251c:	0a040000 	beq	102524 <__ROM_SIZE__+0xc2524>
}
    2520:	dc00000e 	stcle	0, cr0, [r0], {14}
{
    2524:	0200000f 	andeq	r0, r0, #15
    2528:	00000e10 	andeq	r0, r0, r0, lsl lr
  int nbits = bitvec_degree(exp);
    252c:	00000458 	andeq	r0, r0, r8, asr r4
    2530:	000008f2 	strdeq	r0, [r0], -r2
  gf2point_set_zero(tmpx, tmpy);
    2534:	05500101 	ldrbeq	r0, [r0, #-257]	@ 0xfffffeff
    2538:	002f5c03 	eoreq	r5, pc, r3, lsl #24
  for (i = (nbits - 1); i >= 0; --i)
    253c:	2a040000 	bcs	102544 <__ROM_SIZE__+0xc2544>
    2540:	ee00000e 	cdp	0, 0, cr0, cr0, cr14, {0}
    2544:	1800000f 	stmdane	r0, {r0, r1, r2, r3}
    gf2point_double(tmpx, tmpy);
    2548:	00000e42 	andeq	r0, r0, r2, asr #28
    254c:	0000090a 	andeq	r0, r0, sl, lsl #18
    if (bitvec_get_bit(exp, i))
    2550:	01500101 	cmpeq	r0, r1, lsl #2
    2554:	4802003a 	stmdami	r2, {r1, r3, r4, r5}
    2558:	6900000e 	stmdbvs	r0, {r1, r2, r3}
      gf2point_add(tmpx, tmpy, x, y);
    255c:	1f00000d 	svcne	0x0000000d
    2560:	01000009 	tsteq	r0, r9
    2564:	91035001 	tstls	r3, r1
  gf2point_copy(x, y, tmpx, tmpy);
    2568:	02007eec 	andeq	r7, r0, #236, 28	@ 0xec0
    256c:	00000e52 	andeq	r0, r0, r2, asr lr
    2570:	00000a95 	muleq	r0, r5, sl
}
    2574:	00000941 	andeq	r0, r0, r1, asr #18
{
    2578:	03500101 	cmpeq	r0, #1073741824	@ 0x40000000
    257c:	017cec91 			@ <UNDEFINED> instruction: 0x017cec91
  if (gf2point_is_zero(x, y))
    2580:	91035101 	tstls	r3, r1, lsl #2
    2584:	01017eec 	smlatteq	r1, ip, lr, r7
}
    2588:	40080252 	andmi	r0, r8, r2, asr r2
    gf2field_mul(a, x, x);
    258c:	0e7a0400 	cdpeq	4, 7, cr0, cr10, cr0, {0}
    2590:	0f870000 	svceq	0x00870000
    2594:	88180000 	ldmdahi	r8, {}	@ <UNPREDICTABLE>
    gf2field_mul(b, a, x);
    2598:	5a00000e 	bpl	25d8 <gf2point_on_curve+0x60>
    259c:	01000009 	tsteq	r0, r9
    gf2field_add(a, a, b);
    25a0:	74025001 	strvc	r5, [r2], #-1
    25a4:	8c040000 	stchi	0, cr0, [r4], {-0}
    25a8:	c600000e 	strgt	r0, [r0], -lr
    gf2field_add(a, a, coeff_b);
    25ac:	0400000f 	streq	r0, [r0], #-15
    25b0:	00000ee6 	andeq	r0, r0, r6, ror #29
    gf2field_mul(b, y, y);
    25b4:	00000f87 	andeq	r0, r0, r7, lsl #31
    25b8:	000eea04 	andeq	lr, lr, r4, lsl #20
    25bc:	000f8700 	andeq	r8, pc, r0, lsl #14
    gf2field_add(a, a, b);
    25c0:	0f0e0400 	svceq	0x000e0400
    25c4:	0f560000 	svceq	0x00560000
    gf2field_mul(b, x, y);
    25c8:	1a020000 	bne	825d0 <__ROM_SIZE__+0x425d0>
    25cc:	d700000f 	strle	r0, [r0, -pc]
    25d0:	9900000d 	stmdbls	r0, {r0, r2, r3}
    return bitvec_equal(a, b);
    25d4:	01000009 	tsteq	r0, r9
    25d8:	91035001 	tstls	r3, r1
    25dc:	01017eec 	smlatteq	r1, ip, lr, r7
{
    25e0:	6c910251 	lfmvs	f0, 4, [r1], {81}	@ 0x51
    25e4:	0f240400 	svceq	0x00240400
  gf2point_copy((uint32_t*)public_key, (uint32_t*)(public_key + BITVEC_NBYTES), base_x, base_y);
    25e8:	0f560000 	svceq	0x00560000
    25ec:	2e020000 	cdpcs	0, 0, cr0, cr2, cr0, {0}
    25f0:	8b00000f 	blhi	2634 <ecdh_shared_secret>
    25f4:	bd00000e 	stclt	0, cr0, [r0, #-56]	@ 0xffffffc8
  if (bitvec_degree((uint32_t*)private_key) < (CURVE_DEGREE / 2))
    25f8:	01000009 	tsteq	r0, r9
    25fc:	91035001 	tstls	r3, r1
    2600:	01017eec 	smlatteq	r1, ip, lr, r7
    int nbits = bitvec_degree(base_order);
    2604:	6c910251 	lfmvs	f0, 4, [r1], {81}	@ 0x51
    for (i = (nbits - 1); i < (BITVEC_NWORDS * 32); ++i)
    2608:	0f380200 	svceq	0x00380200
      bitvec_clr_bit((uint32_t*)private_key, i);
    260c:	0b300000 	bleq	c02614 <__ROM_SIZE__+0xbc2614>
    2610:	09d80000 	ldmibeq	r8, {}^	@ <UNPREDICTABLE>
    for (i = (nbits - 1); i < (BITVEC_NWORDS * 32); ++i)
    2614:	01010000 	mrseq	r0, (UNDEF: 1)
    2618:	ec910350 	ldc	3, cr0, [r1], {80}	@ 0x50
    gf2point_mul((uint32_t*)public_key, (uint32_t*)(public_key + BITVEC_NBYTES), (uint32_t*)private_key);
    261c:	5101017e 	tstpl	r1, lr, ror r1
    2620:	006c9102 	rsbeq	r9, ip, r2, lsl #2
    return 1;
    2624:	000f4006 	andeq	r4, pc, r6
    return 0;
    2628:	0009fa00 	andeq	pc, r9, r0, lsl #20
    262c:	51010100 	mrspl	r0, (UNDEF: 17)
    2630:	7cec9103 	stfvcp	f1, [ip], #12
{
    2634:	180c0000 	stmdane	ip, {}	@ <UNPREDICTABLE>
    2638:	fa000001 	blx	2644 <ecdh_shared_secret+0x10>
  if (    !gf2point_is_zero ((uint32_t*)others_pub, (uint32_t*)(others_pub + BITVEC_NBYTES))
    263c:	0b000009 	bleq	2668 <ecdh_shared_secret+0x34>
    2640:	00000087 	andeq	r0, r0, r7, lsl #1
    2644:	7b0f007f 	blvc	3c2848 <__ROM_SIZE__+0x382848>
    2648:	ef000008 	svc	0x00000008
}
    264c:	00000a90 	muleq	r0, r0, sl
       &&  gf2point_on_curve((uint32_t*)others_pub, (uint32_t*)(others_pub + BITVEC_NBYTES)) )
    2650:	0000005c 	andeq	r0, r0, ip, asr r0
    2654:	0a959c01 	beq	fe569660 <_STACK_TOP_+0xde561664>
    2658:	72050000 	andvc	r0, r5, #0
    for (i = 0; i < (BITVEC_NBYTES * 2); ++i)
    265c:	ef000001 	svc	0x00000001
      output[i] = others_pub[i];
    2660:	00007b19 	andeq	r7, r0, r9, lsl fp
    2664:	00053a00 	andeq	r3, r5, r0, lsl #20
    for (i = 0; i < (BITVEC_NBYTES * 2); ++i)
    2668:	00053400 	andeq	r3, r5, r0, lsl #8
    gf2point_mul((uint32_t*)output,(uint32_t*)(output + BITVEC_NBYTES), (const uint32_t*)private_key);
    266c:	00b70500 	adcseq	r0, r7, r0, lsl #10
    2670:	26ef0000 	strbtcs	r0, [pc], r0
    2674:	0000010e 	andeq	r0, r0, lr, lsl #2
    return 1;
    2678:	00000559 	andeq	r0, r0, r9, asr r5
int atoi(const char* str) {
    267c:	00000553 	andeq	r0, r0, r3, asr r5
  int res = 0;
    2680:	0007660a 	andeq	r6, r7, sl, lsl #12
    res = res * 10 + str[i] - '0';
    2684:	7b07f000 	blvc	1fe68c <__ROM_SIZE__+0x1be68c>
    2688:	78000000 	stmdavc	r0, {}	@ <UNPREDICTABLE>
    268c:	72000005 	andvc	r0, r0, #5
  for (int i = 0; str[i] != '\0'; ++i) {
    2690:	20000005 	andcs	r0, r0, r5
    2694:	00000a98 	muleq	r0, r8, sl
}
    2698:	0000002e 	andeq	r0, r0, lr, lsr #32
  for (uint32_t i = 0; str[i] != '\0'; i++) {
    269c:	00000a81 	andeq	r0, r0, r1, lsl #21
    26a0:	f2006919 	vmul.i8	d6, d0, d9
    } else if (str[i] >= 'a' && str[i] <= 'f') {
    26a4:	00007b0c 	andeq	r7, r0, ip, lsl #22
    26a8:	00059500 	andeq	r9, r5, r0, lsl #10
      value = str[i] - 'a' + 10;
    26ac:	00059100 	andeq	r9, r5, r0, lsl #2
    hex |= value;
    26b0:	0ab00400 	beq	fec036b8 <_STACK_TOP_+0xdebfb6bc>
  for (uint32_t i = 0; str[i] != '\0'; i++) {
    26b4:	03ef0000 	mvneq	r0, #0
    26b8:	c01f0000 	andsgt	r0, pc, r0
    if (str[i] >= '0' && str[i] <= '9') {
    26bc:	0100000a 	tsteq	r0, sl
    26c0:	78025001 	stmdavc	r2, {r0, ip, lr}
      value = str[i] - '0';
    26c4:	51010100 	mrspl	r0, (UNDEF: 17)
    } else if (str[i] >= 'A' && str[i] <= 'F') {
    26c8:	00007602 	andeq	r7, r0, r2, lsl #12
    26cc:	0ad00600 	beq	ff403ed4 <_STACK_TOP_+0xdf3fbed8>
    26d0:	04580000 	ldrbeq	r0, [r8], #-0
      value = str[i] - 'A' + 10;
    26d4:	01010000 	mrseq	r0, (UNDEF: 1)
  selected_mode = mode;
    26d8:	e8030550 	stmda	r3, {r4, r6, r8, sl}
  if (selected_mode == NONE) {
    26dc:	0000002e 	andeq	r0, r0, lr, lsr #32
  out_buf_rgn.addr = addr;
    26e0:	05fe2100 	ldrbeq	r2, [lr, #256]!	@ 0x100
  out_buf_rgn.size = size / 2;
    26e4:	7bd70000 	blvc	ff5c26ec <_STACK_TOP_+0xdf5ba6f0>
  out_buf_rgn.curr_index = 0;
    26e8:	9c000000 	stcls	0, cr0, [r0], {-0}
  inp_buf_rgn.addr = addr + size / 2;
    26ec:	5200000b 	andpl	r0, r0, #11
  inp_buf_rgn.curr_index = 0;
    26f0:	01000000 	mrseq	r0, (UNDEF: 0)
  if (!(selected_mode & INP)) {
    26f4:	000b309c 	muleq	fp, ip, r0
    out_buf_rgn.size = size;
    26f8:	00b70500 	adcseq	r0, r7, r0, lsl #10
  memset(addr, 0, size);
    26fc:	1ed70000 	cdpne	0, 13, cr0, cr7, cr0, {0}
    2700:	0000010e 	andeq	r0, r0, lr, lsl #2
  } else if (!(selected_mode & OUT)) {
    2704:	000005a9 	andeq	r0, r0, r9, lsr #11
    2708:	000005a5 	andeq	r0, r0, r5, lsr #11
    inp_buf_rgn.addr = addr;
    270c:	00072d05 	andeq	r2, r7, r5, lsl #26
    inp_buf_rgn.size = size;
    2710:	132ad700 			@ <UNDEFINED> instruction: 0x132ad700
    2714:	bc000001 	stclt	0, cr0, [r0], {1}
  if (!(selected_mode & INP)) {
    2718:	b8000005 	stmdalt	r0, {r0, r2}
    271c:	05000005 	streq	r0, [r0, #-5]
    2720:	00000883 	andeq	r0, r0, r3, lsl #17
  if (inp_buf_rgn.addr[inp_buf_rgn.curr_index] == 0) {
    2724:	007b39d7 	ldrsbteq	r3, [fp], #-151	@ 0xffffff69
    2728:	05cf0000 	strbeq	r0, [pc]	@ 2730 <memlog_getc+0x18>
  int val = inp_buf_rgn.addr[inp_buf_rgn.curr_index];
    272c:	05cb0000 	strbeq	r0, [fp]
  inp_buf_rgn.addr[inp_buf_rgn.curr_index] = 0;
    2730:	720a0000 	andvc	r0, sl, #0
  inp_buf_rgn.curr_index++;
    2734:	d8000001 	stmdale	r0, {r0}
    2738:	00007b07 	andeq	r7, r0, r7, lsl #22
  if (inp_buf_rgn.curr_index == inp_buf_rgn.size) {
    273c:	0005e900 	andeq	lr, r5, r0, lsl #18
}
    2740:	0005e100 	andeq	lr, r5, r0, lsl #2
    inp_buf_rgn.curr_index = 0;
    2744:	6f701900 	svcvs	0x00701900
    return -1;
    2748:	07d90073 			@ <UNDEFINED> instruction: 0x07d90073
    274c:	0000007b 	andeq	r0, r0, fp, ror r0
    return -1;
    2750:	0000060d 	andeq	r0, r0, sp, lsl #12
    2754:	00000609 	andeq	r0, r0, r9, lsl #12
  if (!(selected_mode & OUT) || c == 0) {
    2758:	0009760a 	andeq	r7, r9, sl, lsl #12
    275c:	7b07da00 	blvc	1f8f64 <__ROM_SIZE__+0x1b8f64>
    2760:	21000000 	mrscs	r0, (UNDEF: 0)
  out_buf_rgn.addr[out_buf_rgn.curr_index] = (uint8_t) c;
    2764:	1d000006 	stcne	0, cr0, [r0, #-24]	@ 0xffffffe8
    2768:	06000006 	streq	r0, [r0], -r6
  out_buf_rgn.curr_index++;
    276c:	00000ba8 	andeq	r0, r0, r8, lsr #23
  if (out_buf_rgn.curr_index == out_buf_rgn.size) {
    2770:	000003b3 			@ <UNDEFINED> instruction: 0x000003b3
    2774:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    out_buf_rgn.curr_index = 0;
    2778:	00000074 	andeq	r0, r0, r4, ror r0
    277c:	00069a0f 	andeq	r9, r6, pc, lsl #20
    2780:	0d32b200 	lfmeq	f3, 1, [r2, #-0]
size_t strlen(const char *str) {
    2784:	00a20000 	adceq	r0, r2, r0
  while (str[len]) {
    2788:	9c010000 	stcls	0, cr0, [r1], {-0}
    278c:	00000c45 	andeq	r0, r0, r5, asr #24
    2790:	0007b405 	andeq	fp, r7, r5, lsl #8
  while (*str1 && (*str1 == *str2)) {
    2794:	131eb200 	tstne	lr, #0, 4
    str2++;
    2798:	36000001 	strcc	r0, [r0], -r1
  while (*str1 && (*str1 == *str2)) {
    279c:	30000006 	andcc	r0, r0, r6
    27a0:	05000006 	streq	r0, [r0, #-6]
  return *str1 - *str2;
    27a4:	00000609 	andeq	r0, r0, r9, lsl #12
}
    27a8:	0c452db2 	mcrreq	13, 11, r2, r5, cr2
    *(str1++) = *(str2++);
    27ac:	06520000 	ldrbeq	r0, [r2], -r0
    27b0:	064c0000 	strbeq	r0, [ip], -r0
  while (*str2) {
    27b4:	69190000 	ldmdbvs	r9, {}	@ <UNPREDICTABLE>
  *str1 = '\0';
    27b8:	7b07b700 	blvc	1f03c0 <__ROM_SIZE__+0x1b03c0>
}
    27bc:	6c000000 	stcvs	0, cr0, [r0], {-0}
  for (i = 0; i < size; i++) {
    27c0:	68000006 	stmdavs	r0, {r1, r2}
    dest_char[i] = src_char[i];
    27c4:	0a000006 	beq	27e4 <reset_handler>
    27c8:	00000845 	andeq	r0, r0, r5, asr #16
  for (i = 0; i < size; i++) {
    27cc:	007b07b8 	ldrhteq	r0, [fp], #-120	@ 0xffffff88
}
    27d0:	067f0000 	ldrbteq	r0, [pc], -r0
  for (i = 0; i < size; i++) {
    27d4:	067b0000 	ldrbteq	r0, [fp], -r0
    dest_char[i] = val;
    27d8:	df0a0000 	svcle	0x000a0000
  for (i = 0; i < size; i++) {
    27dc:	b9000007 	stmdblt	r0, {r0, r1, r2}
}
    27e0:	00007b07 	andeq	r7, r0, r7, lsl #22
    27e4:	00069600 	andeq	r9, r6, r0, lsl #12
    27e8:	00068e00 	andeq	r8, r6, r0, lsl #28
    27ec:	0d620200 	sfmeq	f0, 2, [r2, #-0]
    27f0:	0c4a0000 	mareq	acc0, r0, sl
    27f4:	0bb50000 	bleq	fed427fc <_STACK_TOP_+0xded3a800>
    27f8:	01010000 	mrseq	r0, (UNDEF: 1)
    27fc:	00780250 	rsbseq	r0, r8, r0, asr r2
    2800:	0d740200 	lfmeq	f0, 2, [r4, #-0]
    2804:	04580000 	ldrbeq	r0, [r8], #-0
    2808:	0bcc0000 	bleq	ff302810 <_STACK_TOP_+0xdf2fa814>
    280c:	01010000 	mrseq	r0, (UNDEF: 1)
    2810:	58030550 	stmdapl	r3, {r4, r6, r8, sl}
    2814:	0000002f 	andeq	r0, r0, pc, lsr #32
    2818:	000d9802 	andeq	r9, sp, r2, lsl #16
    281c:	0003c900 	andeq	ip, r3, r0, lsl #18
    2820:	000be600 	andeq	lr, fp, r0, lsl #12
    2824:	50010100 	andpl	r0, r1, r0, lsl #2
    2828:	01007802 	tsteq	r0, r2, lsl #16
    282c:	08025201 	stmdaeq	r2, {r0, r9, ip, lr}
    2830:	9e020080 	cdpls	0, 0, cr0, cr2, cr0, {4}
    2834:	b300000d 	movwlt	r0, #13
    2838:	fa000003 	blx	284c <_varaes_test>
    283c:	0100000b 	tsteq	r0, fp
    2840:	78025001 	stmdavc	r2, {r0, ip, lr}
    2844:	ac020000 	stcge	0, cr0, [r2], {-0}
    2848:	5800000d 	stmdapl	r0, {r0, r2, r3}
    284c:	0f000004 	svceq	0x00000004
    2850:	0100000c 	tsteq	r0, ip
    2854:	74035001 	strvc	r5, [r3], #-1
    2858:	040001b8 	streq	r0, [r0], #-440	@ 0xfffffe48
    285c:	00000db0 			@ <UNDEFINED> instruction: 0x00000db0
    2860:	00000fdc 	ldrdeq	r0, [r0], -ip
    2864:	000db802 	andeq	fp, sp, r2, lsl #16
    2868:	00045800 	andeq	r5, r4, r0, lsl #16
    286c:	000c2d00 	andeq	r2, ip, r0, lsl #26
    2870:	50010100 	andpl	r0, r1, r0, lsl #2
    2874:	01c87403 	biceq	r7, r8, r3, lsl #8
    2878:	0dc20600 	stcleq	6, cr0, [r2]
    287c:	04580000 	ldrbeq	r0, [r8], #-0
    2880:	01010000 	mrseq	r0, (UNDEF: 1)
    2884:	c0740350 	rsbsgt	r0, r4, r0, asr r3
    2888:	51010101 	tstpl	r1, r1, lsl #2
    288c:	00007802 	andeq	r7, r0, r2, lsl #16
    2890:	007b0800 	rsbseq	r0, fp, r0, lsl #16
    2894:	cc210000 	stcgt	0, cr0, [r1], #-0
    2898:	a5000007 	strge	r0, [r0, #-7]
    289c:	0000007b 	andeq	r0, r0, fp, ror r0
    28a0:	00000bee 	andeq	r0, r0, lr, ror #23
    28a4:	0000003c 	andeq	r0, r0, ip, lsr r0
    28a8:	0cc49c01 	stcleq	12, cr9, [r4], {1}
    28ac:	73220000 			@ <UNDEFINED> instruction: 0x73220000
    28b0:	1f006275 	svcne	0x00006275
    28b4:	00000113 	andeq	r0, r0, r3, lsl r1
    28b8:	000006bb 			@ <UNDEFINED> instruction: 0x000006bb
    28bc:	000006b3 			@ <UNDEFINED> instruction: 0x000006b3
    28c0:	6e656c22 	cdpvs	12, 6, cr6, cr5, cr2, {1}
    28c4:	007b2800 	rsbseq	r2, fp, r0, lsl #16
    28c8:	06e10000 	strbteq	r0, [r1], r0
    28cc:	06db0000 	ldrbeq	r0, [fp], r0
    28d0:	73220000 			@ <UNDEFINED> instruction: 0x73220000
    28d4:	39007274 	stmdbcc	r0, {r2, r4, r5, r6, r9, ip, sp, lr}
    28d8:	00000155 	andeq	r0, r0, r5, asr r1
    28dc:	000006fd 	strdeq	r0, [r0], -sp
    28e0:	000006f7 	strdeq	r0, [r0], -r7
    28e4:	00000c3c 	andeq	r0, r0, ip, lsr ip
    28e8:	000cb300 	andeq	fp, ip, r0, lsl #6
    28ec:	00691900 	rsbeq	r1, r9, r0, lsl #18
    28f0:	007b0caa 	rsbseq	r0, fp, sl, lsr #25
    28f4:	07170000 	ldreq	r0, [r7, -r0]
    28f8:	07130000 	ldreq	r0, [r3, -r0]
    28fc:	06000000 	streq	r0, [r0], -r0
    2900:	00000c04 	andeq	r0, r0, r4, lsl #24
    2904:	000003b3 			@ <UNDEFINED> instruction: 0x000003b3
    2908:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    290c:	00000074 	andeq	r0, r0, r4, ror r0
    2910:	00062f21 	andeq	r2, r6, r1, lsr #30
    2914:	007b9100 	rsbseq	r9, fp, r0, lsl #2
    2918:	0a240000 	beq	902920 <__ROM_SIZE__+0x8c2920>
    291c:	00400000 	subeq	r0, r0, r0
    2920:	9c010000 	stcls	0, cr0, [r1], {-0}
    2924:	00000d69 	andeq	r0, r0, r9, ror #26
    2928:	00017205 	andeq	r7, r1, r5, lsl #4
    292c:	7b1d9100 	blvc	766d34 <__ROM_SIZE__+0x726d34>
    2930:	2a000000 	bcs	2938 <cmd_end_+0x2c>
    2934:	26000007 	strcs	r0, [r0], -r7
    2938:	05000007 	streq	r0, [r0, #-7]
    293c:	000000b7 	strheq	r0, [r0], -r7
    2940:	010e2a91 			@ <UNDEFINED> instruction: 0x010e2a91
    2944:	07400000 	strbeq	r0, [r0, -r0]
    2948:	073c0000 	ldreq	r0, [ip, -r0]!
    294c:	710a0000 	mrsvc	r0, (UNDEF: 10)
    2950:	92000008 	andls	r0, r0, #8
    2954:	0000610c 	andeq	r6, r0, ip, lsl #2
    2958:	00075400 	andeq	r5, r7, r0, lsl #8
    295c:	00075200 	andeq	r5, r7, r0, lsl #4
    2960:	08980a00 	ldmeq	r8, {r9, fp}
    2964:	0c930000 	ldceq	0, cr0, [r3], {0}
    2968:	00000061 	andeq	r0, r0, r1, rrx
    296c:	00000762 	andeq	r0, r0, r2, ror #14
    2970:	0000075c 	andeq	r0, r0, ip, asr r7
    2974:	000a3e1e 	andeq	r3, sl, lr, lsl lr
    2978:	00001600 	andeq	r1, r0, r0, lsl #12
    297c:	08750a00 	ldmdaeq	r5!, {r9, fp}^
    2980:	11970000 	orrsne	r0, r7, r0
    2984:	00000061 	andeq	r0, r0, r1, rrx
    2988:	0000077c 	andeq	r0, r0, ip, ror r7
    298c:	0000077a 	andeq	r0, r0, sl, ror r7
    2990:	000a4e06 	andeq	r4, sl, r6, lsl #28
    2994:	00045800 	andeq	r5, r4, r0, lsl #16
    2998:	50010100 	andpl	r0, r1, r0, lsl #2
    299c:	2e940305 	cdpcs	3, 9, cr0, cr4, cr5, {0}
    29a0:	01010000 	mrseq	r0, (UNDEF: 1)
    29a4:	00740c51 	rsbseq	r0, r4, r1, asr ip
    29a8:	24371a31 	ldrtcs	r1, [r7], #-2609	@ 0xfffff5cf
    29ac:	00005803 	andeq	r5, r0, r3, lsl #16
    29b0:	00002220 	andeq	r2, r0, r0, lsr #4
    29b4:	074f0f00 	strbeq	r0, [pc, -r0, lsl #30]
    29b8:	54850000 	strpl	r0, [r5], #0
    29bc:	4800000b 	stmdami	r0, {r0, r1, r3}
    29c0:	01000000 	mrseq	r0, (UNDEF: 0)
    29c4:	000dd79c 	muleq	sp, ip, r7
    29c8:	06ea0500 	strbteq	r0, [sl], r0, lsl #10
    29cc:	30850000 	addcc	r0, r5, r0
    29d0:	00000155 	andeq	r0, r0, r5, asr r1
    29d4:	0000078a 	andeq	r0, r0, sl, lsl #15
    29d8:	00000784 	andeq	r0, r0, r4, lsl #15
    29dc:	0008750a 	andeq	r7, r8, sl, lsl #10
    29e0:	7b078b00 	blvc	1e55e8 <__ROM_SIZE__+0x1a55e8>
    29e4:	a2000000 	andge	r0, r0, #0
    29e8:	a0000007 	andge	r0, r0, r7
    29ec:	02000007 	andeq	r0, r0, #7
    29f0:	00000b60 	andeq	r0, r0, r0, ror #22
    29f4:	000003ef 	andeq	r0, r0, pc, ror #7
    29f8:	00000dc0 	andeq	r0, r0, r0, asr #27
    29fc:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    2a00:	01010075 	tsteq	r1, r5, ror r0
    2a04:	50030551 	andpl	r0, r3, r1, asr r5
    2a08:	0000002f 	andeq	r0, r0, pc, lsr #32
    2a0c:	000b8206 	andeq	r8, fp, r6, lsl #4
    2a10:	0003c900 	andeq	ip, r3, r0, lsl #18
    2a14:	51010100 	mrspl	r0, (UNDEF: 17)
    2a18:	01007502 	tsteq	r0, r2, lsl #10
    2a1c:	08025201 	stmdaeq	r2, {r0, r9, ip, lr}
    2a20:	0f000080 	svceq	0x00000080
    2a24:	0000080f 	andeq	r0, r0, pc, lsl #16
    2a28:	000c9c78 	andeq	r9, ip, r8, ror ip
    2a2c:	00006000 	andeq	r6, r0, r0
    2a30:	8b9c0100 	blhi	fe702e38 <_STACK_TOP_+0xde6fae3c>
    2a34:	0500000e 	streq	r0, [r0, #-14]
    2a38:	000007b4 			@ <UNDEFINED> instruction: 0x000007b4
    2a3c:	01132578 	tsteq	r3, r8, ror r5
    2a40:	07b00000 	ldreq	r0, [r0, r0]!
    2a44:	07aa0000 	streq	r0, [sl, r0]!
    2a48:	09050000 	stmdbeq	r5, {}	@ <UNPREDICTABLE>
    2a4c:	78000006 	stmdavc	r0, {r1, r2}
    2a50:	000c4534 	andeq	r4, ip, r4, lsr r5
    2a54:	0007cf00 	andeq	ip, r7, r0, lsl #30
    2a58:	0007c900 	andeq	ip, r7, r0, lsl #18
    2a5c:	08750a00 	ldmdaeq	r5!, {r9, fp}^
    2a60:	077e0000 	ldrbeq	r0, [lr, -r0]!
    2a64:	0000007b 	andeq	r0, r0, fp, ror r0
    2a68:	000007ea 	andeq	r0, r0, sl, ror #15
    2a6c:	000007e8 	andeq	r0, r0, r8, ror #15
    2a70:	000caa02 	andeq	sl, ip, r2, lsl #20
    2a74:	00039100 	andeq	r9, r3, r0, lsl #2
    2a78:	000e4300 	andeq	r4, lr, r0, lsl #6
    2a7c:	50010100 	andpl	r0, r1, r0, lsl #2
    2a80:	01007402 	tsteq	r0, r2, lsl #8
    2a84:	30015101 	andcc	r5, r1, r1, lsl #2
    2a88:	02520101 	subseq	r0, r2, #1073741824	@ 0x40000000
    2a8c:	02008008 	andeq	r8, r0, #8
    2a90:	00000ce2 	andeq	r0, r0, r2, ror #25
    2a94:	000003c9 	andeq	r0, r0, r9, asr #7
    2a98:	00000e5d 	andeq	r0, r0, sp, asr lr
    2a9c:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    2aa0:	01010074 	tsteq	r1, r4, ror r0
    2aa4:	80080252 	andhi	r0, r8, r2, asr r2
    2aa8:	0ce80200 	sfmeq	f0, 2, [r8]
    2aac:	03b30000 			@ <UNDEFINED> instruction: 0x03b30000
    2ab0:	0e710000 	cdpeq	0, 7, cr0, cr1, cr0, {0}
    2ab4:	01010000 	mrseq	r0, (UNDEF: 1)
    2ab8:	00740250 	rsbseq	r0, r4, r0, asr r2
    2abc:	0cf20600 	ldcleq	6, cr0, [r2]
    2ac0:	04580000 	ldrbeq	r0, [r8], #-0
    2ac4:	01010000 	mrseq	r0, (UNDEF: 1)
    2ac8:	54030550 	strpl	r0, [r3], #-1360	@ 0xfffffab0
    2acc:	0100002f 	tsteq	r0, pc, lsr #32
    2ad0:	74025101 	strvc	r5, [r2], #-257	@ 0xfffffeff
    2ad4:	0f000000 	svceq	0x00000000
    2ad8:	000006f2 	strdeq	r0, [r0], -r2
    2adc:	000c2a67 	andeq	r2, ip, r7, ror #20
    2ae0:	00007200 	andeq	r7, r0, r0, lsl #4
    2ae4:	569c0100 	ldrpl	r0, [ip], r0, lsl #2
    2ae8:	0500000f 	streq	r0, [r0, #-15]
    2aec:	000007b4 			@ <UNDEFINED> instruction: 0x000007b4
    2af0:	01132367 	tsteq	r3, r7, ror #6
    2af4:	07fa0000 	ldrbeq	r0, [sl, r0]!
    2af8:	07f20000 	ldrbeq	r0, [r2, r0]!
    2afc:	09050000 	stmdbeq	r5, {}	@ <UNPREDICTABLE>
    2b00:	67000006 	strvs	r0, [r0, -r6]
    2b04:	000c4532 	andeq	r4, ip, r2, lsr r5
    2b08:	00081f00 	andeq	r1, r8, r0, lsl #30
    2b0c:	00081700 	andeq	r1, r8, r0, lsl #14
    2b10:	08750a00 	ldmdaeq	r5!, {r9, fp}^
    2b14:	07710000 	ldrbeq	r0, [r1, -r0]!
    2b18:	0000007b 	andeq	r0, r0, fp, ror r0
    2b1c:	00000841 	andeq	r0, r0, r1, asr #16
    2b20:	0000083f 	andeq	r0, r0, pc, lsr r8
    2b24:	000c4e02 	andeq	r4, ip, r2, lsl #28
    2b28:	00045800 	andeq	r5, r4, r0, lsl #16
    2b2c:	000ef500 	andeq	pc, lr, r0, lsl #10
    2b30:	50010100 	andpl	r0, r1, r0, lsl #2
    2b34:	2f540305 	svccs	0x00540305
    2b38:	01010000 	mrseq	r0, (UNDEF: 1)
    2b3c:	00740251 	rsbseq	r0, r4, r1, asr r2
    2b40:	0c580200 	lfmeq	f0, 2, [r8], {-0}
    2b44:	03910000 	orrseq	r0, r1, #0
    2b48:	0f0e0000 	svceq	0x000e0000
    2b4c:	01010000 	mrseq	r0, (UNDEF: 1)
    2b50:	01300151 	teqeq	r0, r1, asr r1
    2b54:	08025201 	stmdaeq	r2, {r0, r9, ip, lr}
    2b58:	80020080 	andhi	r0, r2, r0, lsl #1
    2b5c:	c900000c 	stmdbgt	r0, {r2, r3}
    2b60:	28000003 	stmdacs	r0, {r0, r1}
    2b64:	0100000f 	tsteq	r0, pc
    2b68:	74025001 	strvc	r5, [r2], #-1
    2b6c:	52010100 	andpl	r0, r1, #0, 2
    2b70:	00800802 	addeq	r0, r0, r2, lsl #16
    2b74:	000c8602 	andeq	r8, ip, r2, lsl #12
    2b78:	0003b300 	andeq	fp, r3, r0, lsl #6
    2b7c:	000f3c00 	andeq	r3, pc, r0, lsl #24
    2b80:	50010100 	andpl	r0, r1, r0, lsl #2
    2b84:	00007402 	andeq	r7, r0, r2, lsl #8
    2b88:	000c9006 	andeq	r9, ip, r6
    2b8c:	00045800 	andeq	r5, r4, r0, lsl #16
    2b90:	50010100 	andpl	r0, r1, r0, lsl #2
    2b94:	2f540305 	svccs	0x00540305
    2b98:	01010000 	mrseq	r0, (UNDEF: 1)
    2b9c:	00740251 	rsbseq	r0, r4, r1, asr r2
    2ba0:	a50f0000 	strge	r0, [pc, #-0]	@ 2ba8 <cmd_end_+0x29c>
    2ba4:	5a000006 	bpl	2bc4 <cmd_end_+0x2b8>
    2ba8:	000009ec 	andeq	r0, r0, ip, ror #19
    2bac:	00000012 	andeq	r0, r0, r2, lsl r0
    2bb0:	0f879c01 	svceq	0x00879c01
    2bb4:	09050000 	stmdbeq	r5, {}	@ <UNPREDICTABLE>
    2bb8:	5a000006 	bpl	2bd8 <cmd_end_+0x2cc>
    2bbc:	00007b1e 	andeq	r7, r0, lr, lsl fp
    2bc0:	00084d00 	andeq	r4, r8, r0, lsl #26
    2bc4:	00084900 	andeq	r4, r8, r0, lsl #18
    2bc8:	09f60400 	ldmibeq	r6!, {sl}^
    2bcc:	0f870000 	svceq	0x00870000
    2bd0:	0f000000 	svceq	0x00000000
    2bd4:	000007f9 	strdeq	r0, [r0], -r9
    2bd8:	0009d054 	andeq	sp, r9, r4, asr r0
    2bdc:	00001c00 	andeq	r1, r0, r0, lsl #24
    2be0:	c69c0100 	ldrgt	r0, [ip], r0, lsl #2
    2be4:	1800000f 	stmdane	r0, {r0, r1, r2, r3}
    2be8:	000009da 	ldrdeq	r0, [r0], -sl
    2bec:	00000faa 	andeq	r0, r0, sl, lsr #31
    2bf0:	01500101 	cmpeq	r0, r1, lsl #2
    2bf4:	e0180038 	ands	r0, r8, r8, lsr r0
    2bf8:	ba000009 	blt	2c24 <cmd_end_+0x318>
    2bfc:	0100000f 	tsteq	r0, pc
    2c00:	08025001 	stmdaeq	r2, {r0, ip, lr}
    2c04:	e61f0020 	ldr	r0, [pc], -r0, lsr #32
    2c08:	01000009 	tsteq	r0, r9
    2c0c:	38015001 	stmdacc	r1, {r0, ip, lr}
    2c10:	3c3d0000 	ldccc	0, cr0, [sp], #-0
    2c14:	01000006 	tsteq	r0, r6
    2c18:	007b1b52 	rsbseq	r1, fp, r2, asr fp
    2c1c:	0dd40000 	ldcleq	0, cr0, [r4]
    2c20:	00040000 	andeq	r0, r4, r0
    2c24:	9c010000 	stcls	0, cr0, [r1], {-0}
    2c28:	0007ea3e 	andeq	lr, r7, lr, lsr sl
    2c2c:	1c4c0100 	stfnee	f0, [ip], {-0}
    2c30:	00000d30 	andeq	r0, r0, r0, lsr sp
    2c34:	00000002 	andeq	r0, r0, r2
    2c38:	a3279c01 			@ <UNDEFINED> instruction: 0xa3279c01
    2c3c:	47000007 	strmi	r0, [r0, -r7]
    2c40:	00000d2e 	andeq	r0, r0, lr, lsr #26
    2c44:	00000002 	andeq	r0, r0, r2
    2c48:	84279c01 	strthi	r9, [r7], #-3073	@ 0xfffff3ff
    2c4c:	43000006 	movwmi	r0, #6
    2c50:	00000d2c 	andeq	r0, r0, ip, lsr #26
    2c54:	00000002 	andeq	r0, r0, r2
    2c58:	23239c01 			@ <UNDEFINED> instruction: 0x23239c01
    2c5c:	41000003 	tstmi	r0, r3
    2c60:	00000d20 	andeq	r0, r0, r0, lsr #26
    2c64:	0000000c 	andeq	r0, r0, ip
    2c68:	10309c01 	eorsne	r9, r0, r1, lsl #24
    2c6c:	071a0000 	ldreq	r0, [sl, -r0]
    2c70:	41000007 	tstmi	r0, r7
    2c74:	0002811d 	andeq	r8, r2, sp, lsl r1
    2c78:	00500100 	subseq	r0, r0, r0, lsl #2
    2c7c:	00031423 	andeq	r1, r3, r3, lsr #8
    2c80:	0d144000 	ldceq	0, cr4, [r4, #-0]
    2c84:	000c0000 	andeq	r0, ip, r0
    2c88:	9c010000 	stcls	0, cr0, [r1], {-0}
    2c8c:	00001052 	andeq	r1, r0, r2, asr r0
    2c90:	0007071a 	andeq	r0, r7, sl, lsl r7
    2c94:	811c4000 	tsthi	ip, r0
    2c98:	01000002 	tsteq	r0, r2
    2c9c:	05230050 	streq	r0, [r3, #-80]!	@ 0xffffffb0
    2ca0:	3e000003 	cdpcc	0, 0, cr0, cr0, cr3, {0}
    2ca4:	00000d08 	andeq	r0, r0, r8, lsl #26
    2ca8:	0000000c 	andeq	r0, r0, ip
    2cac:	10749c01 	rsbsne	r9, r4, r1, lsl #24
    2cb0:	071a0000 	ldreq	r0, [sl, -r0]
    2cb4:	3e000007 	cdpcc	0, 0, cr0, cr0, cr7, {0}
    2cb8:	00024f1b 	andeq	r4, r2, fp, lsl pc
    2cbc:	00500100 	subseq	r0, r0, r0, lsl #2
    2cc0:	0003333f 	andeq	r3, r3, pc, lsr r3
    2cc4:	063d0100 	ldrteq	r0, [sp], -r0, lsl #2
    2cc8:	00000cfc 	strdeq	r0, [r0], -ip
    2ccc:	0000000c 	andeq	r0, r0, ip
    2cd0:	071a9c01 	ldreq	r9, [sl, -r1, lsl #24]
    2cd4:	3d000007 	stccc	0, cr0, [r0, #-28]	@ 0xffffffe4
    2cd8:	00024f1a 	andeq	r4, r2, sl, lsl pc
    2cdc:	00500100 	subseq	r0, r0, r0, lsl #2
    2ce0:	00030500 	andeq	r0, r3, r0, lsl #10
    2ce4:	01000500 	tsteq	r0, r0, lsl #10
    2ce8:	0010a004 	andseq	sl, r0, r4
    2cec:	00140b00 	andseq	r0, r4, r0, lsl #22
    2cf0:	1f1d0000 	svcne	0x001d0000
    2cf4:	77000009 	strvc	r0, [r0, -r9]
    2cf8:	e4000001 	str	r0, [r0], #-1
    2cfc:	5c00000f 	stcpl	0, cr0, [r0], {15}
    2d00:	d3000002 	movwle	r0, #2
    2d04:	03000019 	movweq	r0, #25
    2d08:	000000d1 	ldrdeq	r0, [r0], -r1
    2d0c:	01310e5e 	teqeq	r1, lr, asr lr
    2d10:	11840000 	orrne	r0, r4, r0
    2d14:	00bc0000 	adcseq	r0, ip, r0
    2d18:	9c010000 	stcls	0, cr0, [r1], {-0}
    2d1c:	00000131 	andeq	r0, r0, r1, lsr r1
    2d20:	00091902 	andeq	r1, r9, r2, lsl #18
    2d24:	382a5e00 	stmdacc	sl!, {r9, sl, fp, ip, lr}
    2d28:	6c000001 	stcvs	0, cr0, [r0], {1}
    2d2c:	68000008 	stmdavs	r0, {r3}
    2d30:	02000008 	andeq	r0, r0, #8
    2d34:	000008e9 	andeq	r0, r0, r9, ror #17
    2d38:	0131405e 	teqeq	r1, lr, asr r0
    2d3c:	087f0000 	ldmdaeq	pc!, {}^	@ <UNPREDICTABLE>
    2d40:	087b0000 	ldmdaeq	fp!, {}^	@ <UNPREDICTABLE>
    2d44:	e2020000 	and	r0, r2, #0
    2d48:	5e000008 	cdppl	0, 0, cr0, cr0, cr8, {0}
    2d4c:	0001385c 	andeq	r3, r1, ip, asr r8
    2d50:	00089500 	andeq	r9, r8, r0, lsl #10
    2d54:	00089100 	andeq	r9, r8, r0, lsl #2
    2d58:	090b0400 	stmdbeq	fp, {sl}
    2d5c:	105f0000 	subsne	r0, pc, r0
    2d60:	00000131 	andeq	r0, r0, r1, lsr r1
    2d64:	000008a8 	andeq	r0, r0, r8, lsr #17
    2d68:	000008a4 	andeq	r0, r0, r4, lsr #17
    2d6c:	00119206 	andseq	r9, r1, r6, lsl #4
    2d70:	00004800 	andeq	r4, r0, r0, lsl #16
    2d74:	0000df00 	andeq	sp, r0, r0, lsl #30
    2d78:	00690700 	rsbeq	r0, r9, r0, lsl #14
    2d7c:	00013162 	andeq	r3, r1, r2, ror #2
    2d80:	0008bb00 	andeq	fp, r8, r0, lsl #22
    2d84:	0008b700 	andeq	fp, r8, r0, lsl #14
    2d88:	119c0100 	orrsne	r0, ip, r0, lsl #2
    2d8c:	02b70000 	adcseq	r0, r7, #0
    2d90:	a4010000 	strge	r0, [r1], #-0
    2d94:	b7000011 	smladlt	r0, r1, r0, r0
    2d98:	01000002 	tsteq	r0, r2
    2d9c:	000011b0 			@ <UNDEFINED> instruction: 0x000011b0
    2da0:	000002b7 			@ <UNDEFINED> instruction: 0x000002b7
    2da4:	0011b801 	andseq	fp, r1, r1, lsl #16
    2da8:	0002b700 	andeq	fp, r2, r0, lsl #14
    2dac:	11c40100 	bicne	r0, r4, r0, lsl #2
    2db0:	02b70000 	adcseq	r0, r7, #0
    2db4:	cc010000 	stcgt	0, cr0, [r1], {-0}
    2db8:	b7000011 	smladlt	r0, r1, r0, r0
    2dbc:	00000002 	andeq	r0, r0, r2
    2dc0:	00119008 	andseq	r9, r1, r8
    2dc4:	00022e00 	andeq	r2, r2, r0, lsl #28
    2dc8:	0000fa00 	andeq	pc, r0, r0, lsl #20
    2dcc:	50010500 	andpl	r0, r1, r0, lsl #10
    2dd0:	05007402 	streq	r7, [r0, #-1026]	@ 0xfffffbfe
    2dd4:	a3035101 	movwge	r5, #12545	@ 0x3101
    2dd8:	01005101 	tsteq	r0, r1, lsl #2
    2ddc:	00001200 	andeq	r1, r0, r0, lsl #4
    2de0:	000002b7 			@ <UNDEFINED> instruction: 0x000002b7
    2de4:	00120801 	andseq	r0, r2, r1, lsl #16
    2de8:	0002b700 	andeq	fp, r2, r0, lsl #14
    2dec:	12160100 	andsne	r0, r6, #0, 2
    2df0:	02b70000 	adcseq	r0, r7, #0
    2df4:	1e010000 	cdpne	0, 0, cr0, cr1, cr0, {0}
    2df8:	b7000012 	smladlt	r0, r2, r0, r0
    2dfc:	01000002 	tsteq	r0, r2
    2e00:	0000122a 	andeq	r1, r0, sl, lsr #4
    2e04:	000002b7 			@ <UNDEFINED> instruction: 0x000002b7
    2e08:	00123201 	andseq	r3, r2, r1, lsl #4
    2e0c:	0002b700 	andeq	fp, r2, r0, lsl #14
    2e10:	04090000 	streq	r0, [r9], #-0
    2e14:	00012707 	andeq	r2, r1, r7, lsl #14
    2e18:	3e040c00 	cdpcc	12, 0, cr0, cr4, cr0, {0}
    2e1c:	09000001 	stmdbeq	r0, {r0}
    2e20:	00fc0801 	rscseq	r0, ip, r1, lsl #16
    2e24:	9b030000 	blls	c2e2c <__ROM_SIZE__+0x82e2c>
    2e28:	38000003 	stmdacc	r0, {r0, r1}
    2e2c:	0001310e 	andeq	r3, r1, lr, lsl #2
    2e30:	00109c00 	andseq	r9, r0, r0, lsl #24
    2e34:	0000e800 	andeq	lr, r0, r0, lsl #16
    2e38:	2e9c0100 	fmlcse	f0, f4, f0
    2e3c:	02000002 	andeq	r0, r0, #2
    2e40:	00000919 	andeq	r0, r0, r9, lsl r9
    2e44:	01382a38 	teqeq	r8, r8, lsr sl
    2e48:	08cf0000 	stmiaeq	pc, {}^	@ <UNPREDICTABLE>
    2e4c:	08cb0000 	stmiaeq	fp, {}^	@ <UNPREDICTABLE>
    2e50:	e9020000 	stmdb	r2, {}	@ <UNPREDICTABLE>
    2e54:	38000008 	stmdacc	r0, {r3}
    2e58:	00013140 	andeq	r3, r1, r0, asr #2
    2e5c:	0008e200 	andeq	lr, r8, r0, lsl #4
    2e60:	0008de00 	andeq	sp, r8, r0, lsl #28
    2e64:	08e20200 	stmiaeq	r2!, {r9}^
    2e68:	5c380000 	ldcpl	0, cr0, [r8], #-0
    2e6c:	00000138 	andeq	r0, r0, r8, lsr r1
    2e70:	000008f5 	strdeq	r0, [r0], -r5
    2e74:	000008f1 	strdeq	r0, [r0], -r1
    2e78:	0008c704 	andeq	ip, r8, r4, lsl #14
    2e7c:	31103900 	tstcc	r0, r0, lsl #18
    2e80:	06000001 	streq	r0, [r0], -r1
    2e84:	04000009 	streq	r0, [r0], #-9
    2e88:	06000009 	streq	r0, [r0], -r9
    2e8c:	000010ae 	andeq	r1, r0, lr, lsr #1
    2e90:	0000004c 	andeq	r0, r0, ip, asr #32
    2e94:	000001ec 	andeq	r0, r0, ip, ror #3
    2e98:	3c006907 			@ <UNDEFINED> instruction: 0x3c006907
    2e9c:	00000131 	andeq	r0, r0, r1, lsr r1
    2ea0:	00000912 	andeq	r0, r0, r2, lsl r9
    2ea4:	0000090e 	andeq	r0, r0, lr, lsl #18
    2ea8:	0010ba01 	andseq	fp, r0, r1, lsl #20
    2eac:	0002e100 	andeq	lr, r2, r0, lsl #2
    2eb0:	10ce0100 	sbcne	r0, lr, r0, lsl #2
    2eb4:	02e10000 	rsceq	r0, r1, #0
    2eb8:	e2010000 	and	r0, r1, #0
    2ebc:	e1000010 	tst	r0, r0, lsl r0
    2ec0:	01000002 	tsteq	r0, r2
    2ec4:	000010ee 	andeq	r1, r0, lr, ror #1
    2ec8:	000002e1 	andeq	r0, r0, r1, ror #5
    2ecc:	111c0800 	tstne	ip, r0, lsl #16
    2ed0:	028a0000 	addeq	r0, sl, #0
    2ed4:	02000000 	andeq	r0, r0, #0
    2ed8:	01050000 	mrseq	r0, (UNDEF: 5)
    2edc:	00780250 	rsbseq	r0, r8, r0, asr r2
    2ee0:	112c0100 			@ <UNDEFINED> instruction: 0x112c0100
    2ee4:	02e10000 	rsceq	r0, r1, #0
    2ee8:	3a010000 	bcc	42ef0 <__ROM_SIZE__+0x2ef0>
    2eec:	e1000011 	tst	r0, r1, lsl r0
    2ef0:	01000002 	tsteq	r0, r2
    2ef4:	00001150 	andeq	r1, r0, r0, asr r1
    2ef8:	000002e1 	andeq	r0, r0, r1, ror #5
    2efc:	00116401 	andseq	r6, r1, r1, lsl #8
    2f00:	0002e100 	andeq	lr, r2, r0, lsl #2
    2f04:	11720100 	cmnne	r2, r0, lsl #2
    2f08:	02e10000 	rsceq	r0, r1, #0
    2f0c:	03000000 	movweq	r0, #0
    2f10:	00000968 	andeq	r0, r0, r8, ror #18
    2f14:	01310e2d 	teqeq	r1, sp, lsr #28
    2f18:	10680000 	rsbne	r0, r8, r0
    2f1c:	00340000 	eorseq	r0, r4, r0
    2f20:	9c010000 	stcls	0, cr0, [r1], {-0}
    2f24:	0000028a 	andeq	r0, r0, sl, lsl #5
    2f28:	00091902 	andeq	r1, r9, r2, lsl #18
    2f2c:	38312d00 	ldmdacc	r1!, {r8, sl, fp, sp}
    2f30:	26000001 	strcs	r0, [r0], -r1
    2f34:	22000009 	andcs	r0, r0, #9
    2f38:	02000009 	andeq	r0, r0, #9
    2f3c:	000008e9 	andeq	r0, r0, r9, ror #17
    2f40:	0131472d 	teqeq	r1, sp, lsr #14
    2f44:	093b0000 	ldmdbeq	fp!, {}	@ <UNPREDICTABLE>
    2f48:	09350000 	ldmdbeq	r5!, {}	@ <UNPREDICTABLE>
    2f4c:	62040000 	andvs	r0, r4, #0
    2f50:	2e000009 	cdpcs	0, 0, cr0, cr0, cr9, {0}
    2f54:	00013812 	andeq	r3, r1, r2, lsl r8
    2f58:	00095500 	andeq	r5, r9, r0, lsl #10
    2f5c:	00095100 	andeq	r5, r9, r0, lsl #2
    2f60:	107a0100 	rsbsne	r0, sl, r0, lsl #2
    2f64:	02b70000 	adcseq	r0, r7, #0
    2f68:	03000000 	movweq	r0, #0
    2f6c:	000008f6 	strdeq	r0, [r0], -r6
    2f70:	01310e29 	teqeq	r1, r9, lsr #28
    2f74:	10540000 	subsne	r0, r4, r0
    2f78:	00140000 	andseq	r0, r4, r0
    2f7c:	9c010000 	stcls	0, cr0, [r1], {-0}
    2f80:	000002b7 			@ <UNDEFINED> instruction: 0x000002b7
    2f84:	0008e902 	andeq	lr, r8, r2, lsl #18
    2f88:	31302900 	teqcc	r0, r0, lsl #18
    2f8c:	6a000001 	bvs	2f98 <cmd_end_+0x68c>
    2f90:	64000009 	strvs	r0, [r0], #-9
    2f94:	00000009 	andeq	r0, r0, r9
    2f98:	0008d103 	andeq	sp, r8, r3, lsl #2
    2f9c:	3e0f1600 	cfmadd32cc	mvax0, mvfx1, mvfx15, mvfx0
    2fa0:	16000001 	strne	r0, [r0], -r1
    2fa4:	3e000010 	mcrcc	0, 0, r0, cr0, cr0, {0}
    2fa8:	01000000 	mrseq	r0, (UNDEF: 0)
    2fac:	0002e19c 	muleq	r2, ip, r1
    2fb0:	00630a00 	rsbeq	r0, r3, r0, lsl #20
    2fb4:	00013e16 	andeq	r3, r1, r6, lsl lr
    2fb8:	00098400 	andeq	r8, r9, r0, lsl #8
    2fbc:	00098000 	andeq	r8, r9, r0
    2fc0:	510d0000 	mrspl	r0, (UNDEF: 13)
    2fc4:	01000009 	tsteq	r0, r9
    2fc8:	013e0f03 	teqeq	lr, r3, lsl #30
    2fcc:	0fe40000 	svceq	0x00e40000
    2fd0:	00320000 	eorseq	r0, r2, r0
    2fd4:	9c010000 	stcls	0, cr0, [r1], {-0}
    2fd8:	0300760a 	movweq	r7, #1546	@ 0x60a
    2fdc:	0000013e 	andeq	r0, r0, lr, lsr r1
    2fe0:	000009aa 	andeq	r0, r0, sl, lsr #19
    2fe4:	00000992 	muleq	r0, r2, r9
    2fe8:	03b50000 			@ <UNDEFINED> instruction: 0x03b50000
    2fec:	00050000 	andeq	r0, r5, r0
    2ff0:	117f0401 	cmnne	pc, r1, lsl #8
    2ff4:	14110000 	ldrne	r0, [r1], #-0
    2ff8:	1d000000 	stcne	0, cr0, [r0, #-0]
    2ffc:	00000993 	muleq	r0, r3, r9
    3000:	00000177 	andeq	r0, r0, r7, ror r1
    3004:	00001240 	andeq	r1, r0, r0, asr #4
    3008:	000002ee 	andeq	r0, r0, lr, ror #5
    300c:	00001e39 	andeq	r1, r0, r9, lsr lr
    3010:	00000d04 	andeq	r0, r0, r4, lsl #26
    3014:	17d60200 	ldrbne	r0, [r6, r0, lsl #4]
    3018:	00000032 	andeq	r0, r0, r2, lsr r0
    301c:	27070402 	strcs	r0, [r7, -r2, lsl #8]
    3020:	12000001 	andne	r0, r0, #1
    3024:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
    3028:	08020074 	stmdaeq	r2, {r2, r4, r5, r6}
    302c:	00015305 	andeq	r5, r1, r5, lsl #6
    3030:	04080200 	streq	r0, [r8], #-512	@ 0xfffffe00
    3034:	0000019e 	muleq	r0, lr, r1
    3038:	fe060102 	cdp2	1, 0, cr0, cr6, cr2, {0}
    303c:	02000000 	andeq	r0, r0, #0
    3040:	00fc0801 	rscseq	r0, ip, r1, lsl #16
    3044:	02020000 	andeq	r0, r2, #0
    3048:	00016805 	andeq	r6, r1, r5, lsl #16
    304c:	07020200 	streq	r0, [r2, -r0, lsl #4]
    3050:	0000010a 	andeq	r0, r0, sl, lsl #2
    3054:	58050402 	stmdapl	r5, {r1, sl}
    3058:	02000001 	andeq	r0, r0, #1
    305c:	01220704 			@ <UNDEFINED> instruction: 0x01220704
    3060:	08020000 	stmdaeq	r2, {}	@ <UNPREDICTABLE>
    3064:	00011d07 	andeq	r1, r1, r7, lsl #26
    3068:	02041300 	andeq	r1, r4, #0, 6
    306c:	01050801 	tsteq	r5, r1, lsl #16
    3070:	78040000 	stmdavc	r4, {}	@ <UNPREDICTABLE>
    3074:	03000004 	movweq	r0, #4
    3078:	00551713 	subseq	r1, r5, r3, lsl r7
    307c:	88090000 	stmdahi	r9, {}	@ <UNPREDICTABLE>
    3080:	04000000 	streq	r0, [r0], #-0
    3084:	00000459 	andeq	r0, r0, r9, asr r4
    3088:	32171403 	andscc	r1, r7, #50331648	@ 0x3000000
    308c:	09000000 	stmdbeq	r0, {}	@ <UNPREDICTABLE>
    3090:	00000099 	muleq	r0, r9, r0
    3094:	16037014 			@ <UNDEFINED> instruction: 0x16037014
    3098:	0000e409 	andeq	lr, r0, r9, lsl #8
    309c:	07380500 	ldreq	r0, [r8, -r0, lsl #10]!
    30a0:	07170000 	ldreq	r0, [r7, -r0]
    30a4:	000000e4 	andeq	r0, r0, r4, ror #1
    30a8:	04510500 	ldrbeq	r0, [r1], #-1280	@ 0xfffffb00
    30ac:	07180000 	ldreq	r0, [r8, -r0]
    30b0:	00000099 	muleq	r0, r9, r0
    30b4:	05090540 	streq	r0, [r9, #-1344]	@ 0xfffffac0
    30b8:	15190000 	ldrne	r0, [r9, #-0]
    30bc:	00000078 	andeq	r0, r0, r8, ror r0
    30c0:	0a9a0548 	beq	fe6845e8 <_STACK_TOP_+0xde67c5ec>
    30c4:	071a0000 	ldreq	r0, [sl, -r0]
    30c8:	000000f4 	strdeq	r0, [r0], -r4
    30cc:	880a0050 	stmdahi	sl, {r4, r6}
    30d0:	f4000000 	vst4.8	{d0-d3}, [r0], r0
    30d4:	06000000 	streq	r0, [r0], -r0
    30d8:	00000032 	andeq	r0, r0, r2, lsr r0
    30dc:	990a003f 	stmdbls	sl, {r0, r1, r2, r3, r4, r5}
    30e0:	04000000 	streq	r0, [r0], #-0
    30e4:	06000001 	streq	r0, [r0], -r1
    30e8:	00000032 	andeq	r0, r0, r2, lsr r0
    30ec:	10040007 	andne	r0, r4, r7
    30f0:	03000005 	movweq	r0, #5
    30f4:	00aa031b 	adceq	r0, sl, fp, lsl r3
    30f8:	a50a0000 	strge	r0, [sl, #-0]
    30fc:	20000000 	andcs	r0, r0, r0
    3100:	06000001 	streq	r0, [r0], -r1
    3104:	00000032 	andeq	r0, r0, r2, lsr r0
    3108:	1009003f 	andne	r0, r9, pc, lsr r0
    310c:	0e000001 	cdpeq	0, 0, cr0, cr0, cr1, {0}
    3110:	1320006b 			@ <UNDEFINED> instruction: 0x1320006b
    3114:	00000120 	andeq	r0, r0, r0, lsr #2
    3118:	30040305 	andcc	r0, r4, r5, lsl #6
    311c:	12150000 	andsne	r0, r5, #0
    3120:	04000007 	streq	r0, [r0], #-7
    3124:	007f0741 	rsbseq	r0, pc, r1, asr #14
    3128:	01540000 	cmpeq	r4, r0
    312c:	7f0b0000 	svcvc	0x000b0000
    3130:	0b000000 	bleq	3138 <hextable2+0x4>
    3134:	00000039 	andeq	r0, r0, r9, lsr r0
    3138:	0000260b 	andeq	r2, r0, fp, lsl #12
    313c:	7d070000 	stcvc	0, cr0, [r7, #-0]
    3140:	72000004 	andvc	r0, r0, #4
    3144:	00001448 	andeq	r1, r0, r8, asr #8
    3148:	000000e6 	andeq	r0, r0, r6, ror #1
    314c:	01ef9c01 	mvneq	r9, r1, lsl #24
    3150:	63080000 	movwvs	r0, #32768	@ 0x8000
    3154:	72007874 	andvc	r7, r0, #116, 16	@ 0x740000
    3158:	0001ef1f 	andeq	lr, r1, pc, lsl pc
    315c:	000a0d00 	andeq	r0, sl, r0, lsl #26
    3160:	000a0500 	andeq	r0, sl, r0, lsl #10
    3164:	097d0c00 	ldmdbeq	sp!, {sl, fp}^
    3168:	29720000 	ldmdbcs	r2!, {}^	@ <UNPREDICTABLE>
    316c:	000001f4 	strdeq	r0, [r0], -r4
    3170:	00000a32 	andeq	r0, r0, r2, lsr sl
    3174:	00000a2a 	andeq	r0, r0, sl, lsr #20
    3178:	74006901 	strvc	r6, [r0], #-2305	@ 0xfffff6ff
    317c:	00009907 	andeq	r9, r0, r7, lsl #18
    3180:	000a6300 	andeq	r6, sl, r0, lsl #6
    3184:	000a4f00 	andeq	r4, sl, r0, lsl #30
    3188:	14ac0f00 	strtne	r0, [ip], #3840	@ 0xf00
    318c:	02960000 	addseq	r0, r6, #0
    3190:	01b90000 			@ <UNDEFINED> instruction: 0x01b90000
    3194:	01030000 	mrseq	r0, (UNDEF: 3)
    3198:	00740250 	rsbseq	r0, r4, r0, asr r2
    319c:	02510103 	subseq	r0, r1, #-1073741824	@ 0xc0000000
    31a0:	0f000074 	svceq	0x00000074
    31a4:	000014ca 	andeq	r1, r0, sl, asr #9
    31a8:	00000296 	muleq	r0, r6, r2
    31ac:	000001d3 	ldrdeq	r0, [r0], -r3
    31b0:	02500103 	subseq	r0, r0, #-1073741824	@ 0xc0000000
    31b4:	01030074 	tsteq	r3, r4, ror r0
    31b8:	00740251 	rsbseq	r0, r4, r1, asr r2
    31bc:	14d41000 	ldrbne	r1, [r4], #0
    31c0:	01340000 	teqeq	r4, r0
    31c4:	01030000 	mrseq	r0, (UNDEF: 3)
    31c8:	00740250 	rsbseq	r0, r4, r0, asr r2
    31cc:	01510103 	cmpeq	r1, r3, lsl #2
    31d0:	52010330 	andpl	r0, r1, #48, 6	@ 0xc0000000
    31d4:	00380802 	eorseq	r0, r8, r2, lsl #16
    31d8:	01040d00 	tsteq	r4, r0, lsl #26
    31dc:	880d0000 	stmdahi	sp, {}	@ <UNPREDICTABLE>
    31e0:	07000000 	streq	r0, [r0, -r0]
    31e4:	0000051b 	andeq	r0, r0, fp, lsl r5
    31e8:	00140863 	andseq	r0, r4, r3, ror #16
    31ec:	00004000 	andeq	r4, r0, r0
    31f0:	6e9c0100 	fmlvse	f0, f4, f0
    31f4:	08000002 	stmdaeq	r0, {r1}
    31f8:	00787463 	rsbseq	r7, r8, r3, ror #8
    31fc:	01ef2063 	mvneq	r2, r3, rrx
    3200:	0ab30000 	beq	fecc3208 <_STACK_TOP_+0xdecbb20c>
    3204:	0aaf0000 	beq	febc320c <_STACK_TOP_+0xdebbb210>
    3208:	380c0000 	stmdacc	ip, {}	@ <UNPREDICTABLE>
    320c:	63000007 	movwvs	r0, #7
    3210:	00026e30 	andeq	r6, r2, r0, lsr lr
    3214:	000ac600 	andeq	ip, sl, r0, lsl #12
    3218:	000ac200 	andeq	ip, sl, r0, lsl #4
    321c:	656c0800 	strbvs	r0, [ip, #-2048]!	@ 0xfffff800
    3220:	3f63006e 	svccc	0x0063006e
    3224:	00000026 	andeq	r0, r0, r6, lsr #32
    3228:	00000ad9 	ldrdeq	r0, [r0], -r9
    322c:	00000ad5 	ldrdeq	r0, [r0], -r5
    3230:	65006901 	strvs	r6, [r0, #-2305]	@ 0xfffff6ff
    3234:	00009907 	andeq	r9, r0, r7, lsl #18
    3238:	000aec00 	andeq	lr, sl, r0, lsl #24
    323c:	000ae800 	andeq	lr, sl, r0, lsl #16
    3240:	14301000 	ldrtne	r1, [r0], #-0
    3244:	02960000 	addseq	r0, r6, #0
    3248:	01030000 	mrseq	r0, (UNDEF: 3)
    324c:	00740250 	rsbseq	r0, r4, r0, asr r2
    3250:	02510103 	subseq	r0, r1, #-1073741824	@ 0xc0000000
    3254:	00000074 	andeq	r0, r0, r4, ror r0
    3258:	0000940d 	andeq	r9, r0, sp, lsl #8
    325c:	04980700 	ldreq	r0, [r8], #1792	@ 0x700
    3260:	b4550000 	ldrblt	r0, [r5], #-0
    3264:	54000013 	strpl	r0, [r0], #-19	@ 0xffffffed
    3268:	01000000 	mrseq	r0, (UNDEF: 0)
    326c:	0002969c 	muleq	r2, ip, r6
    3270:	74631600 	strbtvc	r1, [r3], #-1536	@ 0xfffffa00
    3274:	55010078 	strpl	r0, [r1, #-120]	@ 0xffffff88
    3278:	0001ef1e 	andeq	lr, r1, lr, lsl pc
    327c:	00500100 	subseq	r0, r0, r0, lsl #2
    3280:	00098207 	andeq	r8, r9, r7, lsl #4
    3284:	12402c00 	subne	r2, r0, #0, 24
    3288:	01740000 	cmneq	r4, r0
    328c:	9c010000 	stcls	0, cr0, [r1], {-0}
    3290:	000003ac 	andeq	r0, r0, ip, lsr #7
    3294:	78746308 	ldmdavc	r4!, {r3, r8, r9, sp, lr}^
    3298:	ef232c00 	svc	0x00232c00
    329c:	02000001 	andeq	r0, r0, #1
    32a0:	fc00000b 	stc2	0, cr0, [r0], {11}
    32a4:	0c00000a 	stceq	0, cr0, [r0], {10}
    32a8:	00000738 	andeq	r0, r0, r8, lsr r7
    32ac:	026e332c 	rsbeq	r3, lr, #44, 6	@ 0xb0000000
    32b0:	0b1c0000 	bleq	7032b8 <__ROM_SIZE__+0x6c32b8>
    32b4:	0b180000 	bleq	6032bc <__ROM_SIZE__+0x5c32bc>
    32b8:	61010000 	mrsvs	r0, (UNDEF: 1)
    32bc:	99072e00 	stmdbls	r7, {r9, sl, fp, sp}
    32c0:	33000000 	movwcc	r0, #0
    32c4:	2b00000b 	blcs	32f8 <hextable2+0x1c4>
    32c8:	0100000b 	tsteq	r0, fp
    32cc:	0a2e0062 	beq	b8345c <__ROM_SIZE__+0xb4345c>
    32d0:	00000099 	muleq	r0, r9, r0
    32d4:	00000b5d 	andeq	r0, r0, sp, asr fp
    32d8:	00000b55 	andeq	r0, r0, r5, asr fp
    32dc:	2e006301 	cdpcs	3, 0, cr6, cr0, cr1, {0}
    32e0:	0000990d 	andeq	r9, r0, sp, lsl #18
    32e4:	000b8200 	andeq	r8, fp, r0, lsl #4
    32e8:	000b7a00 	andeq	r7, fp, r0, lsl #20
    32ec:	00640100 	rsbeq	r0, r4, r0, lsl #2
    32f0:	0099102e 	addseq	r1, r9, lr, lsr #32
    32f4:	0ba70000 	bleq	fe9c32fc <_STACK_TOP_+0xde9bb300>
    32f8:	0b9f0000 	bleq	fe7c3300 <_STACK_TOP_+0xde7bb304>
    32fc:	65010000 	strvs	r0, [r1, #-0]
    3300:	99132e00 	ldmdbls	r3, {r9, sl, fp, sp}
    3304:	ca000000 	bgt	330c <hextable2+0x1d8>
    3308:	c400000b 	strgt	r0, [r0], #-11
    330c:	0100000b 	tsteq	r0, fp
    3310:	162e0066 	strtne	r0, [lr], -r6, rrx
    3314:	00000099 	muleq	r0, r9, r0
    3318:	00000beb 	andeq	r0, r0, fp, ror #23
    331c:	00000be5 	andeq	r0, r0, r5, ror #23
    3320:	2e006701 	cdpcs	7, 0, cr6, cr0, cr1, {0}
    3324:	00009919 	andeq	r9, r0, r9, lsl r9
    3328:	000c0700 	andeq	r0, ip, r0, lsl #14
    332c:	000c0100 	andeq	r0, ip, r0, lsl #2
    3330:	00680100 	rsbeq	r0, r8, r0, lsl #2
    3334:	00991c2e 	addseq	r1, r9, lr, lsr #24
    3338:	0c250000 	stceq	0, cr0, [r5], #-0
    333c:	0c1d0000 	ldceq	0, cr0, [sp], {-0}
    3340:	69010000 	stmdbvs	r1, {}	@ <UNPREDICTABLE>
    3344:	991f2e00 	ldmdbls	pc, {r9, sl, fp, sp}	@ <UNPREDICTABLE>
    3348:	4a000000 	bmi	3350 <hextable2+0x21c>
    334c:	4200000c 	andmi	r0, r0, #12
    3350:	0100000c 	tsteq	r0, ip
    3354:	222e006a 	eorcs	r0, lr, #106	@ 0x6a
    3358:	00000099 	muleq	r0, r9, r0
    335c:	00000c6a 	andeq	r0, r0, sl, ror #24
    3360:	00000c66 	andeq	r0, r0, r6, ror #24
    3364:	00317401 	eorseq	r7, r1, r1, lsl #8
    3368:	0099252e 	addseq	r2, r9, lr, lsr #10
    336c:	0c780000 	ldcleq	0, cr0, [r8], #-0
    3370:	0c760000 	ldcleq	0, cr0, [r6], #-0
    3374:	74010000 	strvc	r0, [r1], #-0
    3378:	292e0032 	stmdbcs	lr!, {r1, r4, r5}
    337c:	00000099 	muleq	r0, r9, r0
    3380:	00000c82 	andeq	r0, r0, r2, lsl #25
    3384:	00000c80 	andeq	r0, r0, r0, lsl #25
    3388:	2e006d0e 	cdpcs	13, 0, cr6, cr0, cr14, {0}
    338c:	0003ac2d 	andeq	sl, r3, sp, lsr #24
    3390:	d8910300 	ldmle	r1, {r8, r9}
    3394:	9917007d 	ldmdbls	r7, {r0, r2, r3, r4, r5, r6}
    3398:	06000000 	streq	r0, [r0], -r0
    339c:	00000032 	andeq	r0, r0, r2, lsr r0
    33a0:	2b00003f 	blcs	34a4 <sbox+0xf8>
    33a4:	05000003 	streq	r0, [r0, #-3]
    33a8:	c4040100 	strgt	r0, [r4], #-256	@ 0xffffff00
    33ac:	10000012 	andne	r0, r0, r2, lsl r0
    33b0:	00000014 	andeq	r0, r0, r4, lsl r0
    33b4:	000a381d 	andeq	r3, sl, sp, lsl r8
    33b8:	00017700 	andeq	r7, r1, r0, lsl #14
    33bc:	00153000 	andseq	r3, r5, r0
    33c0:	00023800 	andeq	r3, r2, r0, lsl #16
    33c4:	00243100 	eoreq	r3, r4, r0, lsl #2
    33c8:	09c50400 	stmibeq	r5, {sl}^
    33cc:	28020000 	stmdacs	r2, {}	@ <UNPREDICTABLE>
    33d0:	0000321b 	andeq	r3, r0, fp, lsl r2
    33d4:	0a171100 	beq	5c77dc <__ROM_SIZE__+0x5877dc>
    33d8:	03040000 	movweq	r0, #16384	@ 0x4000
    33dc:	00004900 	andeq	r4, r0, r0, lsl #18
    33e0:	0a8d1200 	beq	fe347be8 <_STACK_TOP_+0xde33fbec>
    33e4:	00490000 	subeq	r0, r9, r0
    33e8:	00000000 	andeq	r0, r0, r0
    33ec:	19040413 	stmdbne	r4, {r0, r1, r4, sl}
    33f0:	0200000a 	andeq	r0, r0, #10
    33f4:	00261863 	eoreq	r1, r6, r3, ror #16
    33f8:	04140000 	ldreq	r0, [r4], #-0
    33fc:	746e6905 	strbtvc	r6, [lr], #-2309	@ 0xfffff6fb
    3400:	00691500 	rsbeq	r1, r9, r0, lsl #10
    3404:	69160000 	ldmdbvs	r6, {}	@ <UNPREDICTABLE>
    3408:	00000000 	andeq	r0, r0, r0
    340c:	05080103 	streq	r0, [r8, #-259]	@ 0xfffffefd
    3410:	17000001 	strne	r0, [r0, -r1]
    3414:	00000069 	andeq	r0, r0, r9, rrx
    3418:	00080018 	andeq	r0, r8, r8, lsl r0
    341c:	0f180100 	svceq	0x00180100
    3420:	00000081 	andeq	r0, r0, r1, lsl #1
    3424:	00005e05 	andeq	r5, r0, r5, lsl #28
    3428:	01071900 	tsteq	r7, r0, lsl #18
    342c:	000000a1 	andeq	r0, r0, r1, lsr #1
    3430:	a10e2301 	tstge	lr, r1, lsl #6
    3434:	0a000000 	beq	343c <sbox+0x90>
    3438:	00000a7f 	andeq	r0, r0, pc, ror sl
    343c:	09f00a00 	ldmibeq	r0!, {r9, fp}^
    3440:	00010000 	andeq	r0, r1, r0
    3444:	fc080103 	stc2	1, cr0, [r8], {3}
    3448:	04000000 	streq	r0, [r0], #-0
    344c:	00000a21 	andeq	r0, r0, r1, lsr #20
    3450:	86032601 	strhi	r2, [r3], -r1, lsl #12
    3454:	0b000000 	bleq	345c <sbox+0xb0>
    3458:	00000069 	andeq	r0, r0, r9, rrx
    345c:	000000c4 	andeq	r0, r0, r4, asr #1
    3460:	0000c40c 	andeq	ip, r0, ip, lsl #8
    3464:	03000f00 	movweq	r0, #3840	@ 0xf00
    3468:	01270704 			@ <UNDEFINED> instruction: 0x01270704
    346c:	fe0d0000 	cdp2	0, 0, cr0, cr13, cr0, {0}
    3470:	28000009 	stmdacs	r0, {r0, r3}
    3474:	0000b40d 	andeq	fp, r0, sp, lsl #8
    3478:	14030500 	strne	r0, [r3], #-1280	@ 0xfffffb00
    347c:	1a000031 	bne	3548 <rsbox+0x90>
    3480:	00000161 	andeq	r0, r0, r1, ror #2
    3484:	5705a901 	strpl	sl, [r5, -r1, lsl #18]
    3488:	8c000000 	stchi	0, cr0, [r0], {-0}
    348c:	dc000016 	stcle	0, cr0, [r0], {22}
    3490:	01000000 	mrseq	r0, (UNDEF: 0)
    3494:	0001799c 	muleq	r1, ip, r9
    3498:	6d660600 	stclvs	6, cr0, [r6, #-0]
    349c:	18a90074 	stmiane	r9!, {r2, r4, r5, r6}
    34a0:	00000179 	andeq	r0, r0, r9, ror r1
    34a4:	00000ca6 	andeq	r0, r0, r6, lsr #25
    34a8:	00000c96 	muleq	r0, r6, ip
    34ac:	0a9a021b 	beq	fe683d20 <_STACK_TOP_+0xde67bd24>
    34b0:	10aa0000 	adcne	r0, sl, r0
    34b4:	000000a8 	andeq	r0, r0, r8, lsr #1
    34b8:	00000cfc 	strdeq	r0, [r0], -ip
    34bc:	00000ce0 	andeq	r0, r0, r0, ror #25
    34c0:	000a880d 	andeq	r8, sl, sp, lsl #16
    34c4:	4b0bab00 	blmi	2ee0cc <__ROM_SIZE__+0x2ae0cc>
    34c8:	02000000 	andeq	r0, r0, #0
    34cc:	4e075c91 	mcrmi	12, 0, r5, cr7, cr1, {4}
    34d0:	59000000 	stmdbpl	r0, {}	@ <UNPREDICTABLE>
    34d4:	02000001 	andeq	r0, r0, #1
    34d8:	00000a0f 	andeq	r0, r0, pc, lsl #20
    34dc:	005711d4 	ldrsbeq	r1, [r7], #-20	@ 0xffffffec
    34e0:	0d6e0000 	stcleq	0, cr0, [lr, #-0]
    34e4:	0d660000 	stcleq	0, cr0, [r6, #-0]
    34e8:	30080000 	andcc	r0, r8, r0
    34ec:	7e000017 	mcrvc	0, 0, r0, cr0, cr7, {0}
    34f0:	01000001 	tsteq	r0, r1
    34f4:	91035101 	tstls	r3, r1, lsl #2
    34f8:	00007fbc 			@ <UNDEFINED> instruction: 0x00007fbc
    34fc:	0017041c 	andseq	r0, r7, ip, lsl r4
    3500:	00030800 	andeq	r0, r3, r0, lsl #16
    3504:	17460800 	strbne	r0, [r6, -r0, lsl #16]
    3508:	017e0000 	cmneq	lr, r0
    350c:	01010000 	mrseq	r0, (UNDEF: 1)
    3510:	bc910351 	ldclt	3, cr0, [r1], {81}	@ 0x51
    3514:	5201017f 	andpl	r0, r1, #-1073741793	@ 0xc000001f
    3518:	00003001 	andeq	r3, r0, r1
    351c:	00007005 	andeq	r7, r0, r5
    3520:	0a701d00 	beq	1c0a928 <__ROM_SIZE__+0x1bca928>
    3524:	32010000 	andcc	r0, r1, #0
    3528:	0002ec0d 	andeq	lr, r2, sp, lsl #24
    352c:	00154c00 	andseq	r4, r5, r0, lsl #24
    3530:	00014000 	andeq	r4, r1, r0
    3534:	ec9c0100 	ldfs	f0, [ip], {0}
    3538:	06000002 	streq	r0, [r0], -r2
    353c:	00746d66 	rsbseq	r6, r4, r6, ror #26
    3540:	00702732 	rsbseq	r2, r0, r2, lsr r7
    3544:	0daa0000 	stceq	0, cr0, [sl]
    3548:	0d8e0000 	stceq	0, cr0, [lr]
    354c:	880e0000 	stmdahi	lr, {}	@ <UNPREDICTABLE>
    3550:	3500000a 	strcc	r0, [r0, #-10]
    3554:	000002f3 	strdeq	r0, [r0], -r3
    3558:	00000e2d 	andeq	r0, r0, sp, lsr #28
    355c:	00000e17 	andeq	r0, r0, r7, lsl lr
    3560:	000a0f0e 	andeq	r0, sl, lr, lsl #30
    3564:	00573f00 	subseq	r3, r7, r0, lsl #30
    3568:	0e990000 	cdpeq	0, 9, cr0, cr9, cr0, {0}
    356c:	0e7f0000 	cdpeq	0, 7, cr0, cr15, cr0, {0}
    3570:	6e1e0000 	cdpvs	0, 1, cr0, cr14, cr0, {0}
    3574:	01006d75 	tsteq	r0, r5, ror sp
    3578:	02f80833 	rscseq	r0, r8, #3342336	@ 0x330000
    357c:	91020000 	mrsls	r0, (UNDEF: 2)
    3580:	0a070264 	beq	1c3f18 <__ROM_SIZE__+0x183f18>
    3584:	07340000 	ldreq	r0, [r4, -r0]!
    3588:	00000057 	andeq	r0, r0, r7, asr r0
    358c:	00000f04 	andeq	r0, r0, r4, lsl #30
    3590:	00000ef2 	strdeq	r0, [r0], -r2
    3594:	00004407 	andeq	r4, r0, r7, lsl #8
    3598:	00023100 	andeq	r3, r2, r0, lsl #2
    359c:	0a6a0200 	beq	1a83da4 <__ROM_SIZE__+0x1a43da4>
    35a0:	0b410000 	bleq	10435a8 <__ROM_SIZE__+0x10035a8>
    35a4:	00000057 	andeq	r0, r0, r7, asr r0
    35a8:	00000f51 	andeq	r0, r0, r1, asr pc
    35ac:	00000f47 	andeq	r0, r0, r7, asr #30
    35b0:	0015da0f 	andseq	sp, r5, pc, lsl #20
    35b4:	00021d00 	andeq	r1, r2, r0, lsl #26
    35b8:	50010100 	andpl	r0, r1, r0, lsl #2
    35bc:	002d0802 	eoreq	r0, sp, r2, lsl #16
    35c0:	0015f209 	andseq	pc, r5, r9, lsl #4
    35c4:	50010100 	andpl	r0, r1, r0, lsl #2
    35c8:	74009109 	strvc	r9, [r0], #-265	@ 0xfffffef7
    35cc:	1c4c2200 	sfmne	f2, 2, [ip], {-0}
    35d0:	00000194 	muleq	r0, r4, r1
    35d4:	00002307 	andeq	r2, r0, r7, lsl #6
    35d8:	0002d800 	andeq	sp, r2, r0, lsl #16
    35dc:	0a6a0200 	beq	1a83de4 <__ROM_SIZE__+0x1a43de4>
    35e0:	14710000 	ldrbtne	r0, [r1], #-0
    35e4:	000000c4 	andeq	r0, r0, r4, asr #1
    35e8:	00000f7e 	andeq	r0, r0, lr, ror pc
    35ec:	00000f74 	andeq	r0, r0, r4, ror pc
    35f0:	0016421f 	andseq	r4, r6, pc, lsl r2
    35f4:	00002800 	andeq	r2, r0, r0, lsl #16
    35f8:	0002b400 	andeq	fp, r2, r0, lsl #8
    35fc:	0a2e0200 	beq	b83e04 <__ROM_SIZE__+0xb43e04>
    3600:	0f930000 	svceq	0x00930000
    3604:	00000057 	andeq	r0, r0, r7, asr r0
    3608:	00000fa6 	andeq	r0, r0, r6, lsr #31
    360c:	00000fa2 	andeq	r0, r0, r2, lsr #31
    3610:	0009db02 	andeq	sp, r9, r2, lsl #22
    3614:	ec109400 	cfldrs	mvf9, [r0], {-0}
    3618:	bd000002 	stclt	0, cr0, [r0, #-8]
    361c:	b500000f 	strlt	r0, [r0, #-15]
    3620:	2000000f 	andcs	r0, r0, pc
    3624:	00000039 	andeq	r0, r0, r9, lsr r0
    3628:	6c617621 	stclvs	6, cr7, [r1], #-132	@ 0xffffff7c
    362c:	11970100 	orrsne	r0, r7, r0, lsl #2
    3630:	00000057 	andeq	r0, r0, r7, asr r0
    3634:	00000fe3 	andeq	r0, r0, r3, ror #31
    3638:	00000fdb 	ldrdeq	r0, [r0], -fp
    363c:	00164c09 	andseq	r4, r6, r9, lsl #24
    3640:	50010100 	andpl	r0, r1, r0, lsl #2
    3644:	7400750f 	strvc	r7, [r0], #-1295	@ 0xfffffaf1
    3648:	1a3f2500 	bne	fcca50 <__ROM_SIZE__+0xf8ca50>
    364c:	00311403 	eorseq	r1, r1, r3, lsl #8
    3650:	01942200 	orrseq	r2, r4, r0, lsl #4
    3654:	0f000000 	svceq	0x00000000
    3658:	0000157e 	andeq	r1, r0, lr, ror r5
    365c:	000002c4 	andeq	r0, r0, r4, asr #5
    3660:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    3664:	09003008 	stmdbeq	r0, {r3, ip, sp}
    3668:	0000163c 	andeq	r1, r0, ip, lsr r6
    366c:	09500101 	ldmdbeq	r0, {r0, r8}^
    3670:	00740091 			@ <UNDEFINED> instruction: 0x00740091
    3674:	941c4c22 	ldrls	r4, [ip], #-3106	@ 0xfffff3de
    3678:	08000001 	stmdaeq	r0, {r0}
    367c:	0000158c 	andeq	r1, r0, ip, lsl #11
    3680:	00000308 	andeq	r0, r0, r8, lsl #6
    3684:	05500101 	ldrbeq	r0, [r0, #-257]	@ 0xfffffeff
    3688:	00310403 	eorseq	r0, r1, r3, lsl #8
    368c:	03000000 	movweq	r0, #0
    3690:	07d90201 	ldrbeq	r0, [r9, r1, lsl #4]
    3694:	4b050000 	blmi	14369c <__ROM_SIZE__+0x10369c>
    3698:	0b000000 	bleq	36a0 <base_order+0x88>
    369c:	00000069 	andeq	r0, r0, r9, rrx
    36a0:	00000308 	andeq	r0, r0, r8, lsl #6
    36a4:	0000c40c 	andeq	ip, r0, ip, lsl #8
    36a8:	22000900 	andcs	r0, r0, #0, 18
    36ac:	000009d4 	ldrdeq	r0, [r0], -r4
    36b0:	300d2b01 	andcc	r2, sp, r1, lsl #22
    36b4:	1c000015 	stcne	0, cr0, [r0], {21}
    36b8:	01000000 	mrseq	r0, (UNDEF: 0)
    36bc:	7473069c 	ldrbtvc	r0, [r3], #-1692	@ 0xfffff964
    36c0:	202b0072 	eorcs	r0, fp, r2, ror r0
    36c4:	00000179 	andeq	r0, r0, r9, ror r1
    36c8:	0000100f 	andeq	r1, r0, pc
    36cc:	0000100b 	andeq	r1, r0, fp
    36d0:	032b0000 			@ <UNDEFINED> instruction: 0x032b0000
    36d4:	00050000 	andeq	r0, r5, r0
    36d8:	14930401 	ldrne	r0, [r3], #1025	@ 0x401
    36dc:	14100000 	ldrne	r0, [r0], #-0
    36e0:	1d000000 	stcne	0, cr0, [r0, #-0]
    36e4:	00000aa0 	andeq	r0, r0, r0, lsr #21
    36e8:	00000177 	andeq	r0, r0, r7, ror r1
    36ec:	00001768 	andeq	r1, r0, r8, ror #14
    36f0:	00000238 	andeq	r0, r0, r8, lsr r2
    36f4:	000027d4 	ldrdeq	r2, [r0], -r4
    36f8:	0009c504 	andeq	ip, r9, r4, lsl #10
    36fc:	1b280200 	blne	a03f04 <__ROM_SIZE__+0x9c3f04>
    3700:	00000032 	andeq	r0, r0, r2, lsr r0
    3704:	000a1711 	andeq	r1, sl, r1, lsl r7
    3708:	00030400 	andeq	r0, r3, r0, lsl #8
    370c:	00000049 	andeq	r0, r0, r9, asr #32
    3710:	000a8d12 	andeq	r8, sl, r2, lsl sp
    3714:	00004900 	andeq	r4, r0, r0, lsl #18
    3718:	13000000 	movwne	r0, #0
    371c:	0a190404 	beq	644734 <__ROM_SIZE__+0x604734>
    3720:	63020000 	movwvs	r0, #8192	@ 0x2000
    3724:	00002618 	andeq	r2, r0, r8, lsl r6
    3728:	05041400 	streq	r1, [r4, #-1024]	@ 0xfffffc00
    372c:	00746e69 	rsbseq	r6, r4, r9, ror #28
    3730:	00006915 	andeq	r6, r0, r5, lsl r9
    3734:	00691600 	rsbeq	r1, r9, r0, lsl #12
    3738:	03000000 	movweq	r0, #0
    373c:	01050801 	tsteq	r5, r1, lsl #16
    3740:	69170000 	ldmdbvs	r7, {}	@ <UNPREDICTABLE>
    3744:	18000000 	stmdane	r0, {}	@ <UNPREDICTABLE>
    3748:	00000614 	andeq	r0, r0, r4, lsl r6
    374c:	810f1701 	tsthi	pc, r1, lsl #14
    3750:	05000000 	streq	r0, [r0, #-0]
    3754:	0000005e 	andeq	r0, r0, lr, asr r0
    3758:	a1010719 	tstge	r1, r9, lsl r7
    375c:	01000000 	mrseq	r0, (UNDEF: 0)
    3760:	00a10e21 	adceq	r0, r1, r1, lsr #28
    3764:	7f0a0000 	svcvc	0x000a0000
    3768:	0000000a 	andeq	r0, r0, sl
    376c:	0009f00a 	andeq	pc, r9, sl
    3770:	03000100 	movweq	r0, #256	@ 0x100
    3774:	00fc0801 	rscseq	r0, ip, r1, lsl #16
    3778:	92040000 	andls	r0, r4, #0
    377c:	0100000a 	tsteq	r0, sl
    3780:	00860324 	addeq	r0, r6, r4, lsr #6
    3784:	690b0000 	stmdbvs	fp, {}	@ <UNPREDICTABLE>
    3788:	c4000000 	strgt	r0, [r0], #-0
    378c:	0c000000 	stceq	0, cr0, [r0], {-0}
    3790:	000000c4 	andeq	r0, r0, r4, asr #1
    3794:	0403000f 	streq	r0, [r3], #-15
    3798:	00012707 	andeq	r2, r1, r7, lsl #14
    379c:	0ae30d00 	beq	ff8c6ba4 <_STACK_TOP_+0xdf8beba8>
    37a0:	0d260000 	stceq	0, cr0, [r6, #-0]
    37a4:	000000b4 	strheq	r0, [r0], -r4
    37a8:	31340305 	teqcc	r4, r5, lsl #6
    37ac:	4f1a0000 	svcmi	0x001a0000
    37b0:	01000003 	tsteq	r0, r3
    37b4:	005705a7 	subseq	r0, r7, r7, lsr #11
    37b8:	18c40000 	stmiane	r4, {}^	@ <UNPREDICTABLE>
    37bc:	00dc0000 	sbcseq	r0, ip, r0
    37c0:	9c010000 	stcls	0, cr0, [r1], {-0}
    37c4:	00000179 	andeq	r0, r0, r9, ror r1
    37c8:	746d6606 	strbtvc	r6, [sp], #-1542	@ 0xfffff9fa
    37cc:	7919a700 	ldmdbvc	r9, {r8, r9, sl, sp, pc}
    37d0:	36000001 	strcc	r0, [r0], -r1
    37d4:	26000010 			@ <UNDEFINED> instruction: 0x26000010
    37d8:	1b000010 	blne	3820 <base_order+0x208>
    37dc:	000a9a02 	andeq	r9, sl, r2, lsl #20
    37e0:	a811a800 	ldmdage	r1, {fp, sp, pc}
    37e4:	8c000000 	stchi	0, cr0, [r0], {-0}
    37e8:	70000010 	andvc	r0, r0, r0, lsl r0
    37ec:	0d000010 	stceq	0, cr0, [r0, #-64]	@ 0xffffffc0
    37f0:	00000a88 	andeq	r0, r0, r8, lsl #21
    37f4:	004b0ba9 	subeq	r0, fp, r9, lsr #23
    37f8:	91020000 	mrsls	r0, (UNDEF: 2)
    37fc:	0090075c 	addseq	r0, r0, ip, asr r7
    3800:	01590000 	cmpeq	r9, r0
    3804:	0f020000 	svceq	0x00020000
    3808:	d200000a 	andle	r0, r0, #10
    380c:	00005711 	andeq	r5, r0, r1, lsl r7
    3810:	0010fe00 	andseq	pc, r0, r0, lsl #28
    3814:	0010f600 	andseq	pc, r0, r0, lsl #12
    3818:	19680800 	stmdbne	r8!, {fp}^
    381c:	017e0000 	cmneq	lr, r0
    3820:	01010000 	mrseq	r0, (UNDEF: 1)
    3824:	bc910351 	ldclt	3, cr0, [r1], {81}	@ 0x51
    3828:	1c00007f 	stcne	0, cr0, [r0], {127}	@ 0x7f
    382c:	0000193c 	andeq	r1, r0, ip, lsr r9
    3830:	00000308 	andeq	r0, r0, r8, lsl #6
    3834:	00197e08 	andseq	r7, r9, r8, lsl #28
    3838:	00017e00 	andeq	r7, r1, r0, lsl #28
    383c:	51010100 	mrspl	r0, (UNDEF: 17)
    3840:	7fbc9103 	svcvc	0x00bc9103
    3844:	01520101 	cmpeq	r2, r1, lsl #2
    3848:	05000030 	streq	r0, [r0, #-48]	@ 0xffffffd0
    384c:	00000070 	andeq	r0, r0, r0, ror r0
    3850:	000ad31d 	andeq	sp, sl, sp, lsl r3
    3854:	0d300100 	ldfeqs	f0, [r0, #-0]
    3858:	000002ec 	andeq	r0, r0, ip, ror #5
    385c:	00001784 	andeq	r1, r0, r4, lsl #15
    3860:	00000140 	andeq	r0, r0, r0, asr #2
    3864:	02ec9c01 	rsceq	r9, ip, #256	@ 0x100
    3868:	66060000 	strvs	r0, [r6], -r0
    386c:	3000746d 	andcc	r7, r0, sp, ror #8
    3870:	00007028 	andeq	r7, r0, r8, lsr #32
    3874:	00113a00 	andseq	r3, r1, r0, lsl #20
    3878:	00111e00 	andseq	r1, r1, r0, lsl #28
    387c:	0a880e00 	beq	fe207084 <_STACK_TOP_+0xde1ff088>
    3880:	f3360000 	vhadd.u<illegal width 64>	d0, d6, d0
    3884:	bd000002 	stclt	0, cr0, [r0, #-8]
    3888:	a7000011 	smladge	r0, r1, r0, r0
    388c:	0e000011 	mcreq	0, 0, r0, cr0, cr1, {0}
    3890:	00000a0f 	andeq	r0, r0, pc, lsl #20
    3894:	00005740 	andeq	r5, r0, r0, asr #14
    3898:	00122900 	andseq	r2, r2, r0, lsl #18
    389c:	00120f00 	andseq	r0, r2, r0, lsl #30
    38a0:	756e1e00 	strbvc	r1, [lr, #-3584]!	@ 0xfffff200
    38a4:	3101006d 	tstcc	r1, sp, rrx
    38a8:	0002f808 	andeq	pc, r2, r8, lsl #16
    38ac:	64910200 	ldrvs	r0, [r1], #512	@ 0x200
    38b0:	000a0702 	andeq	r0, sl, r2, lsl #14
    38b4:	57073200 	strpl	r3, [r7, -r0, lsl #4]
    38b8:	94000000 	strls	r0, [r0], #-0
    38bc:	82000012 	andhi	r0, r0, #18
    38c0:	07000012 	smladeq	r0, r2, r0, r0
    38c4:	00000086 	andeq	r0, r0, r6, lsl #1
    38c8:	00000231 	andeq	r0, r0, r1, lsr r2
    38cc:	000a6a02 	andeq	r6, sl, r2, lsl #20
    38d0:	570b3f00 	strpl	r3, [fp, -r0, lsl #30]
    38d4:	e1000000 	mrs	r0, (UNDEF: 0)
    38d8:	d7000012 	smladle	r0, r2, r0, r0
    38dc:	0f000012 	svceq	0x00000012
    38e0:	00001812 	andeq	r1, r0, r2, lsl r8
    38e4:	0000021d 	andeq	r0, r0, sp, lsl r2
    38e8:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    38ec:	09002d08 	stmdbeq	r0, {r3, r8, sl, fp, sp}
    38f0:	0000182a 	andeq	r1, r0, sl, lsr #16
    38f4:	09500101 	ldmdbeq	r0, {r0, r8}^
    38f8:	00740091 			@ <UNDEFINED> instruction: 0x00740091
    38fc:	941c4c22 	ldrls	r4, [ip], #-3106	@ 0xfffff3de
    3900:	07000001 	streq	r0, [r0, -r1]
    3904:	00000065 	andeq	r0, r0, r5, rrx
    3908:	000002d8 	ldrdeq	r0, [r0], -r8
    390c:	000a6a02 	andeq	r6, sl, r2, lsl #20
    3910:	c4146f00 	ldrgt	r6, [r4], #-3840	@ 0xfffff100
    3914:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
    3918:	04000013 	streq	r0, [r0], #-19	@ 0xffffffed
    391c:	1f000013 	svcne	0x00000013
    3920:	0000187a 	andeq	r1, r0, sl, ror r8
    3924:	00000028 	andeq	r0, r0, r8, lsr #32
    3928:	000002b4 			@ <UNDEFINED> instruction: 0x000002b4
    392c:	000a2e02 	andeq	r2, sl, r2, lsl #28
    3930:	570f9100 	strpl	r9, [pc, -r0, lsl #2]
    3934:	36000000 	strcc	r0, [r0], -r0
    3938:	32000013 	andcc	r0, r0, #19
    393c:	02000013 	andeq	r0, r0, #19
    3940:	000009db 	ldrdeq	r0, [r0], -fp
    3944:	02ec1092 	rsceq	r1, ip, #146	@ 0x92
    3948:	134d0000 	movtne	r0, #53248	@ 0xd000
    394c:	13450000 	movtne	r0, #20480	@ 0x5000
    3950:	7b200000 	blvc	803958 <__ROM_SIZE__+0x7c3958>
    3954:	21000000 	mrscs	r0, (UNDEF: 0)
    3958:	006c6176 	rsbeq	r6, ip, r6, ror r1
    395c:	57119501 	ldrpl	r9, [r1, -r1, lsl #10]
    3960:	73000000 	movwvc	r0, #0
    3964:	6b000013 	blvs	39b8 <base_order+0x3a0>
    3968:	09000013 	stmdbeq	r0, {r0, r1, r4}
    396c:	00001884 	andeq	r1, r0, r4, lsl #17
    3970:	0f500101 	svceq	0x00500101
    3974:	00740075 	rsbseq	r0, r4, r5, ror r0
    3978:	031a3f25 	tsteq	sl, #37, 30	@ 0x94
    397c:	00003134 	andeq	r3, r0, r4, lsr r1
    3980:	00019422 	andeq	r9, r1, r2, lsr #8
    3984:	b60f0000 	strlt	r0, [pc], -r0
    3988:	c4000017 	strgt	r0, [r0], #-23	@ 0xffffffe9
    398c:	01000002 	tsteq	r0, r2
    3990:	08025001 	stmdaeq	r2, {r0, ip, lr}
    3994:	74090030 	strvc	r0, [r9], #-48	@ 0xffffffd0
    3998:	01000018 	tsteq	r0, r8, lsl r0
    399c:	91095001 	tstls	r9, r1
    39a0:	22007400 	andcs	r7, r0, #0, 8
    39a4:	01941c4c 	orrseq	r1, r4, ip, asr #24
    39a8:	c4080000 	strgt	r0, [r8], #-0
    39ac:	08000017 	stmdaeq	r0, {r0, r1, r2, r4}
    39b0:	01000003 	tsteq	r0, r3
    39b4:	03055001 	movweq	r5, #20481	@ 0x5001
    39b8:	00003124 	andeq	r3, r0, r4, lsr #2
    39bc:	01030000 	mrseq	r0, (UNDEF: 3)
    39c0:	0007d902 	andeq	sp, r7, r2, lsl #18
    39c4:	004b0500 	subeq	r0, fp, r0, lsl #10
    39c8:	690b0000 	stmdbvs	fp, {}	@ <UNPREDICTABLE>
    39cc:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
    39d0:	0c000003 	stceq	0, cr0, [r0], {3}
    39d4:	000000c4 	andeq	r0, r0, r4, asr #1
    39d8:	ed220009 	stc	0, cr0, [r2, #-36]!	@ 0xffffffdc
    39dc:	0100000a 	tsteq	r0, sl
    39e0:	17680d29 	strbne	r0, [r8, -r9, lsr #26]!
    39e4:	001c0000 	andseq	r0, ip, r0
    39e8:	9c010000 	stcls	0, cr0, [r1], {-0}
    39ec:	72747306 	rsbsvc	r7, r4, #402653184	@ 0x18000000
    39f0:	79212900 	stmdbvc	r1!, {r8, fp, sp}
    39f4:	9f000001 	svcls	0x00000001
    39f8:	9b000013 	blls	3a4c <base_order+0x434>
    39fc:	00000013 	andeq	r0, r0, r3, lsl r0
    3a00:	00056800 	andeq	r6, r5, r0, lsl #16
    3a04:	01000500 	tsteq	r0, r0, lsl #10
    3a08:	00166204 	andseq	r6, r6, r4, lsl #4
    3a0c:	00141000 	andseq	r1, r4, r0
    3a10:	011d0000 	tsteq	sp, r0
    3a14:	7700000b 	strvc	r0, [r0, -fp]
    3a18:	a0000001 	andge	r0, r0, r1
    3a1c:	60000019 	andvs	r0, r0, r9, lsl r0
    3a20:	78000001 	stmdavc	r0, {r0}
    3a24:	0300002b 	movweq	r0, #43	@ 0x2b
    3a28:	00fe0601 	rscseq	r0, lr, r1, lsl #12
    3a2c:	02030000 	andeq	r0, r3, #0
    3a30:	00016805 	andeq	r6, r1, r5, lsl #16
    3a34:	05040300 	streq	r0, [r4, #-768]	@ 0xfffffd00
    3a38:	00000158 	andeq	r0, r0, r8, asr r1
    3a3c:	53050803 	movwpl	r0, #22531	@ 0x5803
    3a40:	03000001 	movweq	r0, #1
    3a44:	00fc0801 	rscseq	r0, ip, r1, lsl #16
    3a48:	02030000 	andeq	r0, r3, #0
    3a4c:	00010a07 	andeq	r0, r1, r7, lsl #20
    3a50:	01b10b00 			@ <UNDEFINED> instruction: 0x01b10b00
    3a54:	34020000 	strcc	r0, [r2], #-0
    3a58:	00005c19 	andeq	r5, r0, r9, lsl ip
    3a5c:	07040300 	streq	r0, [r4, -r0, lsl #6]
    3a60:	00000122 	andeq	r0, r0, r2, lsr #2
    3a64:	1d070803 	stcne	8, cr0, [r7, #-12]
    3a68:	11000001 	tstne	r0, r1
    3a6c:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
    3a70:	04030074 	streq	r0, [r3], #-116	@ 0xffffff8c
    3a74:	00012707 	andeq	r2, r1, r7, lsl #14
    3a78:	0b310b00 	bleq	c46680 <__ROM_SIZE__+0xc06680>
    3a7c:	56020000 	strpl	r0, [r2], -r0
    3a80:	0000711a 	andeq	r7, r0, sl, lsl r1
    3a84:	04080300 	streq	r0, [r8], #-768	@ 0xfffffd00
    3a88:	0000019e 	muleq	r0, lr, r1
    3a8c:	646d6312 	strbtvs	r6, [sp], #-786	@ 0xfffffcee
    3a90:	0f2f0300 	svceq	0x002f0300
    3a94:	00000097 	muleq	r0, r7, r0
    3a98:	00009c0a 	andeq	r9, r0, sl, lsl #24
    3a9c:	006a1300 	rsbeq	r1, sl, r0, lsl #6
    3aa0:	00b00000 	adcseq	r0, r0, r0
    3aa4:	6a070000 	bvs	1c3aac <__ROM_SIZE__+0x183aac>
    3aa8:	07000000 	streq	r0, [r0, -r0]
    3aac:	000000b0 	strheq	r0, [r0], -r0	@ <UNPREDICTABLE>
    3ab0:	00b50a00 	adcseq	r0, r5, r0, lsl #20
    3ab4:	ba0a0000 	blt	283abc <__ROM_SIZE__+0x243abc>
    3ab8:	03000000 	movweq	r0, #0
    3abc:	01050801 	tsteq	r5, r1, lsl #16
    3ac0:	ba140000 	blt	503ac8 <__ROM_SIZE__+0x4c3ac8>
    3ac4:	15000000 	strne	r0, [r0, #-0]
    3ac8:	0938030c 	ldmdbeq	r8!, {r2, r3, r8, r9}
    3acc:	000000f4 	strdeq	r0, [r0], -r4
    3ad0:	0000c40c 	andeq	ip, r0, ip, lsl #8
    3ad4:	f40f3900 	vst2.8	{d3,d5}, [pc], r0
    3ad8:	00000000 	andeq	r0, r0, r0
    3adc:	0000000c 	andeq	r0, r0, ip
    3ae0:	f40f3a00 	vst1.8	{d3-d4}, [pc], r0
    3ae4:	04000000 	streq	r0, [r0], #-0
    3ae8:	0000bc0c 	andeq	fp, r0, ip, lsl #24
    3aec:	8b073b00 	blhi	1d26f4 <__ROM_SIZE__+0x1926f4>
    3af0:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
    3af4:	00c10a00 	sbceq	r0, r1, r0, lsl #20
    3af8:	980b0000 	stmdals	fp, {}	@ <UNPREDICTABLE>
    3afc:	03000001 	movweq	r0, #1
    3b00:	00c6033c 	sbceq	r0, r6, ip, lsr r3
    3b04:	f5080000 			@ <UNDEFINED> instruction: 0xf5080000
    3b08:	7f00000a 	svcvc	0x0000000a
    3b0c:	000000f9 	strdeq	r0, [r0], -r9
    3b10:	28f40305 	ldmcs	r4!, {r0, r2, r8, r9}^
    3b14:	6e080000 	cdpvs	0, 0, cr0, cr8, cr0, {0}
    3b18:	8000000b 	andhi	r0, r0, fp
    3b1c:	000000f9 	strdeq	r0, [r0], -r9
    3b20:	28e80305 	stmiacs	r8!, {r0, r2, r8, r9}^
    3b24:	66080000 	strvs	r0, [r8], -r0
    3b28:	8300000b 	movwhi	r0, #11
    3b2c:	000000f9 	strdeq	r0, [r0], -r9
    3b30:	28dc0305 	ldmcs	ip, {r0, r2, r8, r9}^
    3b34:	48080000 	stmdami	r8, {}	@ <UNPREDICTABLE>
    3b38:	8400000b 	strhi	r0, [r0], #-11
    3b3c:	000000f9 	strdeq	r0, [r0], -r9
    3b40:	28d00305 	ldmcs	r0, {r0, r2, r8, r9}^
    3b44:	3b080000 	blcc	203b4c <__ROM_SIZE__+0x1c3b4c>
    3b48:	8500000b 	strhi	r0, [r0, #-11]
    3b4c:	000000f9 	strdeq	r0, [r0], -r9
    3b50:	28c40305 	stmiacs	r4, {r0, r2, r8, r9}^
    3b54:	7f0d0000 	svcvc	0x000d0000
    3b58:	0400000b 	streq	r0, [r0], #-11
    3b5c:	006a051f 	rsbeq	r0, sl, pc, lsl r5
    3b60:	016b0000 	cmneq	fp, r0
    3b64:	f4070000 	vst4.8	{d0-d3}, [r7], r0
    3b68:	00000000 	andeq	r0, r0, r0
    3b6c:	000b7a0d 	andeq	r7, fp, sp, lsl #20
    3b70:	0a260400 	beq	984b78 <__ROM_SIZE__+0x944b78>
    3b74:	00000050 	andeq	r0, r0, r0, asr r0
    3b78:	00000181 	andeq	r0, r0, r1, lsl #3
    3b7c:	0000f407 	andeq	pc, r0, r7, lsl #8
    3b80:	610d0000 	mrsvs	r0, (UNDEF: 13)
    3b84:	05000001 	streq	r0, [r0, #-1]
    3b88:	006a052c 	rsbeq	r0, sl, ip, lsr #10
    3b8c:	01980000 	orrseq	r0, r8, r0
    3b90:	f4070000 	vst4.8	{d0-d3}, [r7], r0
    3b94:	16000000 	strne	r0, [r0], -r0
    3b98:	0b720e00 	bleq	1c873a0 <__ROM_SIZE__+0x1c473a0>
    3b9c:	6a670000 	bvs	19c3ba4 <__ROM_SIZE__+0x1983ba4>
    3ba0:	b0000000 	andlt	r0, r0, r0
    3ba4:	5000001a 	andpl	r0, r0, sl, lsl r0
    3ba8:	01000000 	mrseq	r0, (UNDEF: 0)
    3bac:	0002869c 	muleq	r2, ip, r6
    3bb0:	01720400 	cmneq	r2, r0, lsl #8
    3bb4:	11670000 	cmnne	r7, r0
    3bb8:	0000006a 	andeq	r0, r0, sl, rrx
    3bbc:	000013ba 			@ <UNDEFINED> instruction: 0x000013ba
    3bc0:	000013b6 			@ <UNDEFINED> instruction: 0x000013b6
    3bc4:	0000b704 	andeq	fp, r0, r4, lsl #14
    3bc8:	b01d6700 	andslt	r6, sp, r0, lsl #14
    3bcc:	d0000000 	andle	r0, r0, r0
    3bd0:	cc000013 	stcgt	0, cr0, [r0], {19}
    3bd4:	0f000013 	svceq	0x00000013
    3bd8:	00000b60 	andeq	r0, r0, r0, ror #22
    3bdc:	001ae67a 	andseq	lr, sl, sl, ror r6
    3be0:	08400100 	stmdaeq	r0, {r8}^
    3be4:	0c6d0000 	stcleq	0, cr0, [sp], #-0
    3be8:	00000050 	andeq	r0, r0, r0, asr r0
    3bec:	000013e5 	andeq	r1, r0, r5, ror #7
    3bf0:	000013df 	ldrdeq	r1, [r0], -pc	@ <UNPREDICTABLE>
    3bf4:	000b5001 	andeq	r5, fp, r1
    3bf8:	500c6e00 	andpl	r6, ip, r0, lsl #28
    3bfc:	03000000 	movweq	r0, #0
    3c00:	fb000014 	blx	3c5a <base_order+0x642>
    3c04:	01000013 	tsteq	r0, r3, lsl r0
    3c08:	00000738 	andeq	r0, r0, r8, lsr r7
    3c0c:	00500c75 	subseq	r0, r0, r5, ror ip
    3c10:	14220000 	strtne	r0, [r2], #-0
    3c14:	14200000 	strtne	r0, [r0], #-0
    3c18:	58010000 	stmdapl	r1, {}	@ <UNPREDICTABLE>
    3c1c:	7600000b 	strvc	r0, [r0], -fp
    3c20:	0000500c 	andeq	r5, r0, ip
    3c24:	00142e00 	andseq	r2, r4, r0, lsl #28
    3c28:	00142a00 	andseq	r2, r4, r0, lsl #20
    3c2c:	1abe0500 	bne	fef85034 <_STACK_TOP_+0xdef7d038>
    3c30:	016b0000 	cmneq	fp, r0
    3c34:	c6050000 	strgt	r0, [r5], -r0
    3c38:	5500001a 	strpl	r0, [r0, #-26]	@ 0xffffffe6
    3c3c:	09000001 	stmdbeq	r0, {r0}
    3c40:	00001adc 	ldrdeq	r1, [r0], -ip
    3c44:	00000181 	andeq	r0, r0, r1, lsl #3
    3c48:	0000025b 	andeq	r0, r0, fp, asr r2
    3c4c:	05500102 	ldrbeq	r0, [r0, #-258]	@ 0xfffffefe
    3c50:	00328003 	eorseq	r8, r2, r3
    3c54:	52010200 	andpl	r0, r1, #0, 4
    3c58:	00007502 	andeq	r7, r0, r2, lsl #10
    3c5c:	001ae609 	andseq	lr, sl, r9, lsl #12
    3c60:	00018100 	andeq	r8, r1, r0, lsl #2
    3c64:	00027200 	andeq	r7, r2, r0, lsl #4
    3c68:	50010200 	andpl	r0, r1, r0, lsl #4
    3c6c:	31d80305 	bicscc	r0, r8, r5, lsl #6
    3c70:	06000000 	streq	r0, [r0], -r0
    3c74:	00001aee 	andeq	r1, r0, lr, ror #21
    3c78:	00000181 	andeq	r0, r0, r1, lsl #3
    3c7c:	05500102 	ldrbeq	r0, [r0, #-258]	@ 0xfffffefe
    3c80:	00329803 	eorseq	r9, r2, r3, lsl #16
    3c84:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
    3c88:	00000af9 	strdeq	r0, [r0], -r9
    3c8c:	00006a48 	andeq	r6, r0, r8, asr #20
    3c90:	001a4800 	andseq	r4, sl, r0, lsl #16
    3c94:	00006800 	andeq	r6, r0, r0, lsl #16
    3c98:	779c0100 	ldrvc	r0, [ip, r0, lsl #2]
    3c9c:	04000003 	streq	r0, [r0], #-3
    3ca0:	00000172 	andeq	r0, r0, r2, ror r1
    3ca4:	006a1148 	rsbeq	r1, sl, r8, asr #2
    3ca8:	14450000 	strbne	r0, [r5], #-0
    3cac:	14410000 	strbne	r0, [r1], #-0
    3cb0:	b7040000 	strlt	r0, [r4, -r0]
    3cb4:	48000000 	stmdami	r0, {}	@ <UNPREDICTABLE>
    3cb8:	0000b01d 	andeq	fp, r0, sp, lsl r0
    3cbc:	00145b00 	andseq	r5, r4, r0, lsl #22
    3cc0:	00145700 	andseq	r5, r4, r0, lsl #14
    3cc4:	0b600f00 	bleq	18078cc <__ROM_SIZE__+0x17c78cc>
    3cc8:	96620000 	strbtls	r0, [r2], -r0
    3ccc:	0100001a 	tsteq	r0, sl, lsl r0
    3cd0:	00000840 	andeq	r0, r0, r0, asr #16
    3cd4:	00500c4e 	subseq	r0, r0, lr, asr #24
    3cd8:	14700000 	ldrbtne	r0, [r0], #-0
    3cdc:	146a0000 	strbtne	r0, [sl], #-0
    3ce0:	50010000 	andpl	r0, r1, r0
    3ce4:	4f00000b 	svcmi	0x0000000b
    3ce8:	0000500c 	andeq	r5, r0, ip
    3cec:	00148c00 	andseq	r8, r4, r0, lsl #24
    3cf0:	00148600 	andseq	r8, r4, r0, lsl #12
    3cf4:	0b580100 	bleq	16040fc <__ROM_SIZE__+0x15c40fc>
    3cf8:	0c500000 	mraeq	r0, r0, acc0
    3cfc:	00000050 	andeq	r0, r0, r0, asr r0
    3d00:	000014a8 	andeq	r1, r0, r8, lsr #9
    3d04:	000014a2 	andeq	r1, r0, r2, lsr #9
    3d08:	00073801 	andeq	r3, r7, r1, lsl #16
    3d0c:	500c5c00 	andpl	r5, ip, r0, lsl #24
    3d10:	c2000000 	andgt	r0, r0, #0
    3d14:	be000014 	mcrlt	0, 0, r0, cr0, cr4, {0}
    3d18:	05000014 	streq	r0, [r0, #-20]	@ 0xffffffec
    3d1c:	00001a56 	andeq	r1, r0, r6, asr sl
    3d20:	0000016b 	andeq	r0, r0, fp, ror #2
    3d24:	001a5e05 	andseq	r5, sl, r5, lsl #28
    3d28:	00015500 	andeq	r5, r1, r0, lsl #10
    3d2c:	1a660500 	bne	1985134 <__ROM_SIZE__+0x1945134>
    3d30:	01550000 	cmpeq	r5, r0
    3d34:	8e090000 	cdphi	0, 0, cr0, cr9, cr0, {0}
    3d38:	8100001a 	tsthi	r0, sl, lsl r0
    3d3c:	4c000001 	stcmi	0, cr0, [r0], {1}
    3d40:	02000003 	andeq	r0, r0, #3
    3d44:	03055001 	movweq	r5, #20481	@ 0x5001
    3d48:	000031d8 	ldrdeq	r3, [r0], -r8
    3d4c:	1a960900 	bne	fe586154 <_STACK_TOP_+0xde57e158>
    3d50:	01810000 	orreq	r0, r1, r0
    3d54:	03630000 	cmneq	r3, #0
    3d58:	01020000 	mrseq	r0, (UNDEF: 2)
    3d5c:	00030550 	andeq	r0, r3, r0, asr r5
    3d60:	00000032 	andeq	r0, r0, r2, lsr r0
    3d64:	001a9e06 	andseq	r9, sl, r6, lsl #28
    3d68:	00018100 	andeq	r8, r1, r0, lsl #2
    3d6c:	50010200 	andpl	r0, r1, r0, lsl #4
    3d70:	32240305 	eorcc	r0, r4, #335544320	@ 0x14000000
    3d74:	00000000 	andeq	r0, r0, r0
    3d78:	000b3f0e 	andeq	r3, fp, lr, lsl #30
    3d7c:	006a3400 	rsbeq	r3, sl, r0, lsl #8
    3d80:	1a000000 	bne	3d88 <base_order+0x770>
    3d84:	00480000 	subeq	r0, r8, r0
    3d88:	9c010000 	stcls	0, cr0, [r1], {-0}
    3d8c:	00000449 	andeq	r0, r0, r9, asr #8
    3d90:	00017204 	andeq	r7, r1, r4, lsl #4
    3d94:	6a123400 	bvs	490d9c <__ROM_SIZE__+0x450d9c>
    3d98:	d9000000 	stmdble	r0, {}	@ <UNPREDICTABLE>
    3d9c:	d1000014 	tstle	r0, r4, lsl r0
    3da0:	04000014 	streq	r0, [r0], #-20	@ 0xffffffec
    3da4:	000000b7 	strheq	r0, [r0], -r7
    3da8:	00b01e34 	adcseq	r1, r0, r4, lsr lr
    3dac:	15030000 	strne	r0, [r3, #-0]
    3db0:	14f70000 	ldrbtne	r0, [r7], #0
    3db4:	40010000 	andmi	r0, r1, r0
    3db8:	3a000008 	bcc	3de0 <base_order+0x7c8>
    3dbc:	0000500c 	andeq	r5, r0, ip
    3dc0:	00153100 	andseq	r3, r5, r0, lsl #2
    3dc4:	00152b00 	andseq	r2, r5, r0, lsl #22
    3dc8:	09760100 	ldmdbeq	r6!, {r8}^
    3dcc:	0c3b0000 	ldceq	0, cr0, [fp], #-0
    3dd0:	00000050 	andeq	r0, r0, r0, asr r0
    3dd4:	00001547 	andeq	r1, r0, r7, asr #10
    3dd8:	00001543 	andeq	r1, r0, r3, asr #10
    3ddc:	0000a717 	andeq	sl, r0, r7, lsl r7
    3de0:	00042300 	andeq	r2, r4, r0, lsl #6
    3de4:	00691800 	rsbeq	r1, r9, r0, lsl #16
    3de8:	50113d01 	andspl	r3, r1, r1, lsl #26
    3dec:	58000000 	stmdapl	r0, {}	@ <UNPREDICTABLE>
    3df0:	54000015 	strpl	r0, [r0], #-21	@ 0xffffffeb
    3df4:	01000015 	tsteq	r0, r5, lsl r0
    3df8:	00000738 	andeq	r0, r0, r8, lsr r7
    3dfc:	0050183d 	subseq	r1, r0, sp, lsr r8
    3e00:	156a0000 	strbne	r0, [sl, #-0]!
    3e04:	15660000 	strbne	r0, [r6, #-0]!
    3e08:	34060000 	strcc	r0, [r6], #-0
    3e0c:	8100001a 	tsthi	r0, sl, lsl r0
    3e10:	02000001 	andeq	r0, r0, #1
    3e14:	03055001 	movweq	r5, #20481	@ 0x5001
    3e18:	00003164 	andeq	r3, r0, r4, ror #2
    3e1c:	02510102 	subseq	r0, r1, #-2147483648	@ 0x80000000
    3e20:	00000074 	andeq	r0, r0, r4, ror r0
    3e24:	001a0e05 	andseq	r0, sl, r5, lsl #28
    3e28:	00016b00 	andeq	r6, r1, r0, lsl #22
    3e2c:	1a160500 	bne	585234 <__ROM_SIZE__+0x545234>
    3e30:	01550000 	cmpeq	r5, r0
    3e34:	24060000 	strcs	r0, [r6], #-0
    3e38:	8100001a 	tsthi	r0, sl, lsl r0
    3e3c:	02000001 	andeq	r0, r0, #1
    3e40:	03055001 	movweq	r5, #20481	@ 0x5001
    3e44:	000031a0 	andeq	r3, r0, r0, lsr #3
    3e48:	77190000 	ldrvc	r0, [r9, -r0]
    3e4c:	01003233 	tsteq	r0, r3, lsr r2
    3e50:	006a0528 	rsbeq	r0, sl, r8, lsr #10
    3e54:	19d00000 	ldmibne	r0, {}^	@ <UNPREDICTABLE>
    3e58:	00300000 	eorseq	r0, r0, r0
    3e5c:	9c010000 	stcls	0, cr0, [r1], {-0}
    3e60:	000004d5 	ldrdeq	r0, [r0], -r5
    3e64:	00017204 	andeq	r7, r1, r4, lsl #4
    3e68:	6a0d2800 	bvs	34de70 <__ROM_SIZE__+0x30de70>
    3e6c:	80000000 	andhi	r0, r0, r0
    3e70:	78000015 	stmdavc	r0, {r0, r2, r4}
    3e74:	04000015 	streq	r0, [r0], #-21	@ 0xffffffeb
    3e78:	000000b7 	strheq	r0, [r0], -r7
    3e7c:	00b01928 	adcseq	r1, r0, r8, lsr #18
    3e80:	15a30000 	strne	r0, [r3, #0]!
    3e84:	159b0000 	ldrne	r0, [fp]
    3e88:	40010000 	andmi	r0, r1, r0
    3e8c:	2d000008 	stccs	0, cr0, [r0, #-32]	@ 0xffffffe0
    3e90:	0000500c 	andeq	r5, r0, ip
    3e94:	0015bc00 	andseq	fp, r5, r0, lsl #24
    3e98:	0015b800 	andseq	fp, r5, r0, lsl #16
    3e9c:	07380100 	ldreq	r0, [r8, -r0, lsl #2]!
    3ea0:	0c2e0000 	stceq	0, cr0, [lr], #-0
    3ea4:	00000050 	andeq	r0, r0, r0, asr r0
    3ea8:	000015c9 	andeq	r1, r0, r9, asr #11
    3eac:	000015c7 	andeq	r1, r0, r7, asr #11
    3eb0:	0019de05 	andseq	sp, r9, r5, lsl #28
    3eb4:	00016b00 	andeq	r6, r1, r0, lsl #22
    3eb8:	19e60500 	stmibne	r6!, {r8, sl}^
    3ebc:	016b0000 	cmneq	fp, r0
    3ec0:	f4060000 	vst4.8	{d0-d3}, [r6], r0
    3ec4:	81000019 	tsthi	r0, r9, lsl r0
    3ec8:	02000001 	andeq	r0, r0, #1
    3ecc:	03055001 	movweq	r5, #20481	@ 0x5001
    3ed0:	00003170 	andeq	r3, r0, r0, ror r1
    3ed4:	721a0000 	andsvc	r0, sl, #0
    3ed8:	01003233 	tsteq	r0, r3, lsr r2
    3edc:	006a0519 	rsbeq	r0, sl, r9, lsl r5
    3ee0:	19a00000 	stmibne	r0!, {}	@ <UNPREDICTABLE>
    3ee4:	00300000 	eorseq	r0, r0, r0
    3ee8:	9c010000 	stcls	0, cr0, [r1], {-0}
    3eec:	00017204 	andeq	r7, r1, r4, lsl #4
    3ef0:	6a0d1900 	bvs	34a2f8 <__ROM_SIZE__+0x30a2f8>
    3ef4:	d7000000 	strle	r0, [r0, -r0]
    3ef8:	cf000015 	svcgt	0x00000015
    3efc:	04000015 	streq	r0, [r0], #-21	@ 0xffffffeb
    3f00:	000000b7 	strheq	r0, [r0], -r7
    3f04:	00b01919 	adcseq	r1, r0, r9, lsl r9
    3f08:	15fa0000 	ldrbne	r0, [sl, #0]!
    3f0c:	15f20000 	ldrbne	r0, [r2, #0]!
    3f10:	40010000 	andmi	r0, r1, r0
    3f14:	1f000008 	svcne	0x00000008
    3f18:	0000500c 	andeq	r5, r0, ip
    3f1c:	00161900 	andseq	r1, r6, r0, lsl #18
    3f20:	00161500 	andseq	r1, r6, r0, lsl #10
    3f24:	07380100 	ldreq	r0, [r8, -r0, lsl #2]!
    3f28:	0c200000 	stceq	0, cr0, [r0], #-0
    3f2c:	00000050 	andeq	r0, r0, r0, asr r0
    3f30:	00001626 	andeq	r1, r0, r6, lsr #12
    3f34:	00001624 	andeq	r1, r0, r4, lsr #12
    3f38:	0019ac05 	andseq	sl, r9, r5, lsl #24
    3f3c:	00016b00 	andeq	r6, r1, r0, lsl #22
    3f40:	19b60900 	ldmibne	r6!, {r8, fp}
    3f44:	01810000 	orreq	r0, r1, r0
    3f48:	05570000 	ldrbeq	r0, [r7, #-0]
    3f4c:	01020000 	mrseq	r0, (UNDEF: 2)
    3f50:	64030550 	strvs	r0, [r3], #-1360	@ 0xfffffab0
    3f54:	00000031 	andeq	r0, r0, r1, lsr r0
    3f58:	0019c206 	andseq	ip, r9, r6, lsl #4
    3f5c:	00018100 	andeq	r8, r1, r0, lsl #2
    3f60:	50010200 	andpl	r0, r1, r0, lsl #4
    3f64:	31440305 	cmpcc	r4, r5, lsl #6
    3f68:	00000000 	andeq	r0, r0, r0
    3f6c:	000c3000 	andeq	r3, ip, r0
    3f70:	01000500 	tsteq	r0, r0, lsl #10
    3f74:	0017f404 	andseq	pc, r7, r4, lsl #8
    3f78:	00141a00 	andseq	r1, r4, r0, lsl #20
    3f7c:	ce1d0000 	cdpgt	0, 1, cr0, cr13, cr0, {0}
    3f80:	7700000b 	strvc	r0, [r0, -fp]
    3f84:	00000001 	andeq	r0, r0, r1
    3f88:	fc00001b 	stc2	0, cr0, [r0], {27}
    3f8c:	9b000005 	blls	3fa8 <base_order+0x990>
    3f90:	1b00002e 	blne	4050 <base_order+0xa38>
    3f94:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
    3f98:	0d130074 	ldceq	0, cr0, [r3, #-464]	@ 0xfffffe30
    3f9c:	02000000 	andeq	r0, r0, #0
    3fa0:	003917d6 	ldrsbteq	r1, [r9], -r6
    3fa4:	04060000 	streq	r0, [r6], #-0
    3fa8:	00012707 	andeq	r2, r1, r7, lsl #14
    3fac:	05080600 	streq	r0, [r8, #-1536]	@ 0xfffffa00
    3fb0:	00000153 	andeq	r0, r0, r3, asr r1
    3fb4:	9e040806 	cdpls	8, 0, cr0, cr4, cr6, {0}
    3fb8:	06000001 	streq	r0, [r0], -r1
    3fbc:	00fe0601 	rscseq	r0, lr, r1, lsl #12
    3fc0:	02060000 	andeq	r0, r6, #0
    3fc4:	00016805 	andeq	r6, r1, r5, lsl #16
    3fc8:	05040600 	streq	r0, [r4, #-1536]	@ 0xfffffa00
    3fcc:	00000158 	andeq	r0, r0, r8, asr r1
    3fd0:	00013413 	andeq	r3, r1, r3, lsl r4
    3fd4:	182e0300 	stmdane	lr!, {r8, r9}
    3fd8:	00000074 	andeq	r0, r0, r4, ror r0
    3fdc:	00006310 	andeq	r6, r0, r0, lsl r3
    3fe0:	08010600 	stmdaeq	r1, {r9, sl}
    3fe4:	000000fc 	strdeq	r0, [r0], -ip
    3fe8:	0a070206 	beq	1c4808 <__ROM_SIZE__+0x184808>
    3fec:	06000001 	streq	r0, [r0], -r1
    3ff0:	01220704 			@ <UNDEFINED> instruction: 0x01220704
    3ff4:	08060000 	stmdaeq	r6, {}	@ <UNPREDICTABLE>
    3ff8:	00011d07 	andeq	r1, r1, r7, lsl #26
    3ffc:	013c1c00 	teqeq	ip, r0, lsl #24
    4000:	01000000 	mrseq	r0, (UNDEF: 0)
    4004:	b8082c04 	stmdalt	r8, {r2, sl, fp, sp}
    4008:	1d000000 	stcne	0, cr0, [r0, #-0]
    400c:	00000c3f 	andeq	r0, r0, pc, lsr ip
    4010:	bd0b2e04 	stclt	14, cr2, [fp, #-16]
    4014:	00000000 	andeq	r0, r0, r0
    4018:	0076491e 	rsbseq	r4, r6, lr, lsl r9
    401c:	cd0b3004 	stcgt	0, cr3, [fp, #-16]
    4020:	f0000000 			@ <UNDEFINED> instruction: 0xf0000000
    4024:	00901000 	addseq	r1, r0, r0
    4028:	630d0000 	movwvs	r0, #53248	@ 0xd000
    402c:	cd000000 	stcgt	0, cr0, [r0, #-0]
    4030:	0a000000 	beq	4038 <base_order+0xa20>
    4034:	00000039 	andeq	r0, r0, r9, lsr r0
    4038:	630d00ef 	movwvs	r0, #53487	@ 0xd0ef
    403c:	dd000000 	stcle	0, cr0, [r0, #-0]
    4040:	0a000000 	beq	4048 <base_order+0xa30>
    4044:	00000039 	andeq	r0, r0, r9, lsr r0
    4048:	0f13000f 	svceq	0x0013000f
    404c:	0100000c 	tsteq	r0, ip
    4050:	00e91148 	rsceq	r1, r9, r8, asr #2
    4054:	630d0000 	movwvs	r0, #53248	@ 0xd000
    4058:	ff000000 			@ <UNDEFINED> instruction: 0xff000000
    405c:	0a000000 	beq	4064 <base_order+0xa4c>
    4060:	00000039 	andeq	r0, r0, r9, lsr r0
    4064:	00390a03 	eorseq	r0, r9, r3, lsl #20
    4068:	00030000 	andeq	r0, r3, r0
    406c:	00006f0d 	andeq	r6, r0, sp, lsl #30
    4070:	00010f00 	andeq	r0, r1, r0, lsl #30
    4074:	00390a00 	eorseq	r0, r9, r0, lsl #20
    4078:	00ff0000 	rscseq	r0, pc, r0
    407c:	0000ff10 	andeq	pc, r0, r0, lsl pc	@ <UNPREDICTABLE>
    4080:	0bb21100 	bleq	fec88488 <_STACK_TOP_+0xdec8048c>
    4084:	164f0000 	strbne	r0, [pc], -r0
    4088:	0000010f 	andeq	r0, r0, pc, lsl #2
    408c:	33ac0305 			@ <UNDEFINED> instruction: 0x33ac0305
    4090:	b1110000 	tstlt	r1, r0
    4094:	6300000b 	movwvs	r0, #11
    4098:	00010f16 	andeq	r0, r1, r6, lsl pc
    409c:	b8030500 	stmdalt	r3, {r8, sl}
    40a0:	0d000034 	stceq	0, cr0, [r0, #-208]	@ 0xffffff30
    40a4:	0000006f 	andeq	r0, r0, pc, rrx
    40a8:	00000146 	andeq	r0, r0, r6, asr #2
    40ac:	0000390a 	andeq	r3, r0, sl, lsl #18
    40b0:	10000a00 	andne	r0, r0, r0, lsl #20
    40b4:	00000136 	andeq	r0, r0, r6, lsr r1
    40b8:	000c6411 	andeq	r6, ip, r1, lsl r4
    40bc:	46167800 	ldrmi	r7, [r6], -r0, lsl #16
    40c0:	05000001 	streq	r0, [r0, #-1]
    40c4:	0034ac03 	eorseq	sl, r4, r3, lsl #24
    40c8:	068a1f00 	streq	r1, [sl], r0, lsl #30
    40cc:	38050000 	stmdacc	r5, {}	@ <UNPREDICTABLE>
    40d0:	00017c07 	andeq	r7, r1, r7, lsl #24
    40d4:	00017c00 	andeq	r7, r1, r0, lsl #24
    40d8:	017c1400 	cmneq	ip, r0, lsl #8
    40dc:	7e140000 	cdpvc	0, 1, cr0, cr4, cr0, {0}
    40e0:	14000001 	strne	r0, [r0], #-1
    40e4:	0000002d 	andeq	r0, r0, sp, lsr #32
    40e8:	0c042000 	stceq	0, cr2, [r4], {-0}
    40ec:	00000183 	andeq	r0, r0, r3, lsl #3
    40f0:	0c480e21 	mcrreq	14, 2, r0, r8, cr1
    40f4:	021a0000 	andseq	r0, sl, #0
    40f8:	00002088 	andeq	r2, r0, r8, lsl #1
    40fc:	00000074 	andeq	r0, r0, r4, ror r0
    4100:	023f9c01 	eorseq	r9, pc, #256	@ 0x100
    4104:	63050000 	movwvs	r0, #20480	@ 0x5000
    4108:	1a007874 	bne	222e0 <__RAM_SIZE__+0x1a2e0>
    410c:	023f2c02 	eorseq	r2, pc, #512	@ 0x200
    4110:	163c0000 	ldrtne	r0, [ip], -r0
    4114:	16380000 	ldrtne	r0, [r8], -r0
    4118:	62050000 	andvs	r0, r5, #0
    411c:	1a006675 	bne	1daf8 <__RAM_SIZE__+0x15af8>
    4120:	02443a02 	subeq	r3, r4, #8192	@ 0x2000
    4124:	164f0000 	strbne	r0, [pc], -r0
    4128:	164b0000 	strbne	r0, [fp], -r0
    412c:	76070000 	strvc	r0, [r7], -r0
    4130:	1a000009 	bne	415c <base_order+0xb44>
    4134:	002d4602 	eoreq	r4, sp, r2, lsl #12
    4138:	16620000 	strbtne	r0, [r2], -r0
    413c:	165e0000 	ldrbne	r0, [lr], -r0
    4140:	27180000 	ldrcs	r0, [r8, -r0]
    4144:	1c00000c 	stcne	0, cr0, [r0], {12}
    4148:	0000cd02 	andeq	ip, r0, r2, lsl #26
    414c:	58910200 	ldmpl	r1, {r9}
    4150:	1e006903 	vmlane.f16	s12, s0, s6	@ <UNPREDICTABLE>
    4154:	002d0a02 	eoreq	r0, sp, r2, lsl #20
    4158:	16750000 	ldrbtne	r0, [r5], -r0
    415c:	16710000 	ldrbtne	r0, [r1], -r0
    4160:	62030000 	andvs	r0, r3, #0
    4164:	021f0069 	andseq	r0, pc, #105	@ 0x69
    4168:	00002607 	andeq	r2, r0, r7, lsl #12
    416c:	00168f00 	andseq	r8, r6, r0, lsl #30
    4170:	00168500 	andseq	r8, r6, r0, lsl #10
    4174:	20d40200 	sbcscs	r0, r4, r0, lsl #4
    4178:	015c0000 	cmpeq	ip, r0
    417c:	02280000 	eoreq	r0, r8, #0
    4180:	01010000 	mrseq	r0, (UNDEF: 1)
    4184:	007d0250 	rsbseq	r0, sp, r0, asr r2
    4188:	03510101 	cmpeq	r1, #1073741824	@ 0x40000000
    418c:	0101f077 	tsteq	r1, r7, ror r0	@ <UNPREDICTABLE>
    4190:	40015201 	andmi	r5, r1, r1, lsl #4
    4194:	20dc0400 	sbcscs	r0, ip, r0, lsl #8
    4198:	05a50000 	streq	r0, [r5, #0]!
    419c:	01010000 	mrseq	r0, (UNDEF: 1)
    41a0:	007d0250 	rsbseq	r0, sp, r0, asr r2
    41a4:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    41a8:	00000077 	andeq	r0, r0, r7, ror r0
    41ac:	0000900c 	andeq	r9, r0, ip
    41b0:	00630c00 	rsbeq	r0, r3, r0, lsl #24
    41b4:	170e0000 	strne	r0, [lr, -r0]
    41b8:	0400000c 	streq	r0, [r0], #-12
    41bc:	00204202 	eoreq	r4, r0, r2, lsl #4
    41c0:	00004600 	andeq	r4, r0, r0, lsl #12
    41c4:	299c0100 	ldmibcs	ip, {r8}
    41c8:	05000003 	streq	r0, [r0, #-3]
    41cc:	00787463 	rsbseq	r7, r8, r3, ror #8
    41d0:	3f2d0204 	svccc	0x002d0204
    41d4:	b9000002 	stmdblt	r0, {r1}
    41d8:	b5000016 	strlt	r0, [r0, #-22]	@ 0xffffffea
    41dc:	05000016 	streq	r0, [r0, #-22]	@ 0xffffffea
    41e0:	00667562 	rsbeq	r7, r6, r2, ror #10
    41e4:	443b0204 	ldrtmi	r0, [fp], #-516	@ 0xfffffdfc
    41e8:	cc000002 	stcgt	0, cr0, [r0], {2}
    41ec:	c8000016 	stmdagt	r0, {r1, r2, r4}
    41f0:	07000016 	smladeq	r0, r6, r0, r0
    41f4:	00000976 	andeq	r0, r0, r6, ror r9
    41f8:	2d470204 	sfmcs	f0, 2, [r7, #-16]
    41fc:	df000000 	svcle	0x00000000
    4200:	db000016 	blle	4260 <base_order+0xc48>
    4204:	03000016 	movweq	r0, #22
    4208:	02060069 	andeq	r0, r6, #105	@ 0x69
    420c:	00002d0a 	andeq	r2, r0, sl, lsl #26
    4210:	0016f200 	andseq	pc, r6, r0, lsl #4
    4214:	0016ee00 	andseq	lr, r6, r0, lsl #28
    4218:	0ba51800 	bleq	fe94a220 <_STACK_TOP_+0xde942224>
    421c:	02070000 	andeq	r0, r7, #0
    4220:	000000cd 	andeq	r0, r0, sp, asr #1
    4224:	02589102 	subseq	r9, r8, #-2147483648	@ 0x80000000
    4228:	0000205c 	andeq	r2, r0, ip, asr r0
    422c:	0000015c 	andeq	r0, r0, ip, asr r1
    4230:	000002d9 	ldrdeq	r0, [r0], -r9
    4234:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    4238:	0101007d 	tsteq	r1, sp, ror r0
    423c:	00740251 	rsbseq	r0, r4, r1, asr r2
    4240:	01520101 	cmpeq	r2, r1, lsl #2
    4244:	64020040 	strvs	r0, [r2], #-64	@ 0xffffffc0
    4248:	d8000020 	stmdale	r0, {r5}
    424c:	f3000004 	vhadd.u8	d0, d0, d4
    4250:	01000002 	tsteq	r0, r2
    4254:	74025001 	strvc	r5, [r2], #-1
    4258:	51010100 	mrspl	r0, (UNDEF: 17)
    425c:	00007702 	andeq	r7, r0, r2, lsl #14
    4260:	00207002 	eoreq	r7, r0, r2
    4264:	0003e300 	andeq	lr, r3, r0, lsl #6
    4268:	00030d00 	andeq	r0, r3, r0, lsl #26
    426c:	50010100 	andpl	r0, r1, r0, lsl #2
    4270:	01007402 	tsteq	r0, r2, lsl #8
    4274:	76025101 	strvc	r5, [r2], -r1, lsl #2
    4278:	7a040000 	bvc	104280 <__ROM_SIZE__+0xc4280>
    427c:	5c000020 	stcpl	0, cr0, [r0], {32}
    4280:	01000001 	tsteq	r0, r1
    4284:	76025001 	strvc	r5, [r2], -r1
    4288:	51010100 	mrspl	r0, (UNDEF: 17)
    428c:	01007d02 	tsteq	r0, r2, lsl #26
    4290:	40015201 	andmi	r5, r1, r1, lsl #4
    4294:	b70e0000 	strlt	r0, [lr, -r0]
    4298:	f500000b 			@ <UNDEFINED> instruction: 0xf500000b
    429c:	00200a01 	eoreq	r0, r0, r1, lsl #20
    42a0:	00003800 	andeq	r3, r0, r0, lsl #16
    42a4:	e39c0100 	orrs	r0, ip, #0, 2
    42a8:	05000003 	streq	r0, [r0, #-3]
    42ac:	00787463 	rsbseq	r7, r8, r3, ror #8
    42b0:	3f2d01f5 	svccc	0x002d01f5
    42b4:	06000002 	streq	r0, [r0], -r2
    42b8:	02000017 	andeq	r0, r0, #23
    42bc:	05000017 	streq	r0, [r0, #-23]	@ 0xffffffe9
    42c0:	00667562 	rsbeq	r7, r6, r2, ror #10
    42c4:	443b01f5 	ldrtmi	r0, [fp], #-501	@ 0xfffffe0b
    42c8:	1d000002 	stcne	0, cr0, [r0, #-8]
    42cc:	15000017 	strne	r0, [r0, #-23]	@ 0xffffffe9
    42d0:	07000017 	smladeq	r0, r7, r0, r0
    42d4:	00000976 	andeq	r0, r0, r6, ror r9
    42d8:	2d4701f5 	stfcse	f0, [r7, #-980]	@ 0xfffffc2c
    42dc:	40000000 	andmi	r0, r0, r0
    42e0:	3c000017 	stccc	0, cr0, [r0], {23}
    42e4:	03000017 	movweq	r0, #23
    42e8:	01f70069 	mvnseq	r0, r9, rrx
    42ec:	00002d0a 	andeq	r2, r0, sl, lsl #26
    42f0:	00175300 	andseq	r5, r7, r0, lsl #6
    42f4:	00174f00 	andseq	r4, r7, r0, lsl #30
    42f8:	76490300 	strbvc	r0, [r9], -r0, lsl #6
    42fc:	0c01f800 	stceq	8, cr15, [r1], {-0}
    4300:	00000244 	andeq	r0, r0, r4, asr #4
    4304:	0000176b 	andeq	r1, r0, fp, ror #14
    4308:	00001763 	andeq	r1, r0, r3, ror #14
    430c:	00202402 	eoreq	r2, r0, r2, lsl #8
    4310:	0003e300 	andeq	lr, r3, r0, lsl #6
    4314:	0003b300 	andeq	fp, r3, r0, lsl #6
    4318:	50010100 	andpl	r0, r1, r0, lsl #2
    431c:	00007402 	andeq	r7, r0, r2, lsl #8
    4320:	00202c02 	eoreq	r2, r0, r2, lsl #24
    4324:	0005a500 	andeq	sl, r5, r0, lsl #10
    4328:	0003cd00 	andeq	ip, r3, r0, lsl #26
    432c:	50010100 	andpl	r0, r1, r0, lsl #2
    4330:	01007402 	tsteq	r0, r2, lsl #8
    4334:	76025101 	strvc	r5, [r2], -r1, lsl #2
    4338:	3e040000 	cdpcc	0, 0, cr0, cr4, cr0, {0}
    433c:	5c000020 	stcpl	0, cr0, [r0], {32}
    4340:	01000001 	tsteq	r0, r1
    4344:	78025001 	stmdavc	r2, {r0, ip, lr}
    4348:	52010100 	andpl	r0, r1, #0, 2
    434c:	00004001 	andeq	r4, r0, r1
    4350:	000c9e08 	andeq	r9, ip, r8, lsl #28
    4354:	a801ec00 	stmdage	r1, {sl, fp, sp, lr, pc}
    4358:	1a00001f 	bne	43dc <base_order+0xdc4>
    435c:	01000000 	mrseq	r0, (UNDEF: 0)
    4360:	0004229c 	muleq	r4, ip, r2
    4364:	75621900 	strbvc	r1, [r2, #-2304]!	@ 0xfffff700
    4368:	44200066 	strtmi	r0, [r0], #-102	@ 0xffffff9a
    436c:	01000002 	tsteq	r0, r2
    4370:	76491950 			@ <UNDEFINED> instruction: 0x76491950
    4374:	04223400 	strteq	r3, [r2], #-1024	@ 0xfffffc00
    4378:	51010000 	mrspl	r0, (UNDEF: 1)
    437c:	ee006903 	vmla.f16	s12, s0, s6
    4380:	00630b01 	rsbeq	r0, r3, r1, lsl #22
    4384:	178e0000 	strne	r0, [lr, r0]
    4388:	17880000 	strne	r0, [r8, r0]
    438c:	0c000000 	stceq	0, cr0, [r0], {-0}
    4390:	0000006f 	andeq	r0, r0, pc, rrx
    4394:	0000df0e 	andeq	sp, r0, lr, lsl #30
    4398:	fc01dc00 	stc2	12, cr13, [r1], {-0}
    439c:	0e00001f 	mcreq	0, 0, r0, cr0, cr15, {0}
    43a0:	01000000 	mrseq	r0, (UNDEF: 0)
    43a4:	00047d9c 	muleq	r4, ip, sp
    43a8:	74630500 	strbtvc	r0, [r3], #-1280	@ 0xfffffb00
    43ac:	01dc0078 	bicseq	r0, ip, r8, ror r0
    43b0:	00047d2c 	andeq	r7, r4, ip, lsr #26
    43b4:	0017ab00 	andseq	sl, r7, r0, lsl #22
    43b8:	0017a500 	andseq	sl, r7, r0, lsl #10
    43bc:	75620500 	strbvc	r0, [r2, #-1280]!	@ 0xfffffb00
    43c0:	01dc0066 	bicseq	r0, ip, r6, rrx
    43c4:	0002443a 	andeq	r4, r2, sl, lsr r4
    43c8:	0017ca00 	andseq	ip, r7, r0, lsl #20
    43cc:	0017c400 	andseq	ip, r7, r0, lsl #8
    43d0:	20080400 	andcs	r0, r8, r0, lsl #8
    43d4:	04d80000 	ldrbeq	r0, [r8], #0
    43d8:	01010000 	mrseq	r0, (UNDEF: 1)
    43dc:	01a30350 			@ <UNDEFINED> instruction: 0x01a30350
    43e0:	51010151 	tstpl	r1, r1, asr r1
    43e4:	5001a303 	andpl	sl, r1, r3, lsl #6
    43e8:	b80c0000 	stmdalt	ip, {}	@ <UNPREDICTABLE>
    43ec:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
    43f0:	00000357 	andeq	r0, r0, r7, asr r3
    43f4:	1fee01d6 	svcne	0x00ee01d6
    43f8:	000e0000 	andeq	r0, lr, r0
    43fc:	9c010000 	stcls	0, cr0, [r1], {-0}
    4400:	000004d8 	ldrdeq	r0, [r0], -r8
    4404:	78746305 	ldmdavc	r4!, {r0, r2, r8, r9, sp, lr}^
    4408:	2c01d600 	stccs	6, cr13, [r1], {-0}
    440c:	0000047d 	andeq	r0, r0, sp, ror r4
    4410:	000017e9 	andeq	r1, r0, r9, ror #15
    4414:	000017e3 	andeq	r1, r0, r3, ror #15
    4418:	66756205 	ldrbtvs	r6, [r5], -r5, lsl #4
    441c:	3a01d600 	bcc	79c24 <__ROM_SIZE__+0x39c24>
    4420:	00000244 	andeq	r0, r0, r4, asr #4
    4424:	00001808 	andeq	r1, r0, r8, lsl #16
    4428:	00001802 	andeq	r1, r0, r2, lsl #16
    442c:	001ffa04 	andseq	pc, pc, r4, lsl #20
    4430:	0005a500 	andeq	sl, r5, r0, lsl #10
    4434:	50010100 	andpl	r0, r1, r0, lsl #2
    4438:	5101a303 	tstpl	r1, r3, lsl #6
    443c:	03510101 	cmpeq	r1, #1073741824	@ 0x40000000
    4440:	005001a3 	subseq	r0, r0, r3, lsr #3
    4444:	0bff0800 	bleq	fffc644c <_STACK_TOP_+0xdffbe450>
    4448:	01b70000 			@ <UNDEFINED> instruction: 0x01b70000
    444c:	00001f6e 	andeq	r1, r0, lr, ror #30
    4450:	0000003a 	andeq	r0, r0, sl, lsr r0
    4454:	05a09c01 	streq	r9, [r0, #3073]!	@ 0xc01
    4458:	9a070000 	bls	1c4460 <__ROM_SIZE__+0x184460>
    445c:	b700000a 	strlt	r0, [r0, -sl]
    4460:	05a02001 	streq	r2, [r0, #1]!
    4464:	18270000 	stmdane	r7!, {}	@ <UNPREDICTABLE>
    4468:	18210000 	stmdane	r1!, {}	@ <UNPREDICTABLE>
    446c:	3f070000 	svccc	0x00070000
    4470:	b700000c 	strlt	r0, [r0, -ip]
    4474:	04223601 	strteq	r3, [r2], #-1537	@ 0xfffff9ff
    4478:	18430000 	stmdane	r3, {}^	@ <UNPREDICTABLE>
    447c:	183d0000 	ldmdane	sp!, {}	@ <UNPREDICTABLE>
    4480:	5e120000 	cdppl	0, 1, cr0, cr2, cr0, {0}
    4484:	b900000c 	stmdblt	r0, {r2, r3}
    4488:	00006301 	andeq	r6, r0, r1, lsl #6
    448c:	00186100 	andseq	r6, r8, r0, lsl #2
    4490:	00185900 	andseq	r5, r8, r0, lsl #18
    4494:	1f7e0200 	svcne	0x007e0200
    4498:	0a040000 	beq	1044a0 <__ROM_SIZE__+0xc44a0>
    449c:	05470000 	strbeq	r0, [r7, #-0]
    44a0:	01010000 	mrseq	r0, (UNDEF: 1)
    44a4:	013e0150 	teqeq	lr, r0, asr r1
    44a8:	75025101 	strvc	r5, [r2, #-257]	@ 0xfffffeff
    44ac:	52010100 	andpl	r0, r1, #0, 2
    44b0:	00007602 	andeq	r7, r0, r2, lsl #12
    44b4:	001f8802 	andseq	r8, pc, r2, lsl #16
    44b8:	00070b00 	andeq	r0, r7, r0, lsl #22
    44bc:	00055b00 	andeq	r5, r5, r0, lsl #22
    44c0:	50010100 	andpl	r0, r1, r0, lsl #2
    44c4:	00007502 	andeq	r7, r0, r2, lsl #10
    44c8:	001f9202 	andseq	r9, pc, r2, lsl #4
    44cc:	00068c00 	andeq	r8, r6, r0, lsl #24
    44d0:	00056f00 	andeq	r6, r5, r0, lsl #30
    44d4:	50010100 	andpl	r0, r1, r0, lsl #2
    44d8:	00007502 	andeq	r7, r0, r2, lsl #10
    44dc:	001f9802 	andseq	r9, pc, r2, lsl #16
    44e0:	0006c300 	andeq	ip, r6, r0, lsl #6
    44e4:	00058300 	andeq	r8, r5, r0, lsl #6
    44e8:	50010100 	andpl	r0, r1, r0, lsl #2
    44ec:	00007502 	andeq	r7, r0, r2, lsl #10
    44f0:	001fa204 	andseq	sl, pc, r4, lsl #4
    44f4:	000a0400 	andeq	r0, sl, r0, lsl #8
    44f8:	50010100 	andpl	r0, r1, r0, lsl #2
    44fc:	01007402 	tsteq	r0, r2, lsl #8
    4500:	75025101 	strvc	r5, [r2, #-257]	@ 0xfffffeff
    4504:	52010100 	andpl	r0, r1, #0, 2
    4508:	00007602 	andeq	r7, r0, r2, lsl #12
    450c:	00dd0c00 	sbcseq	r0, sp, r0, lsl #24
    4510:	02080000 	andeq	r0, r8, #0
    4514:	9d00000c 	stcls	0, cr0, [r0, #-48]	@ 0xffffffd0
    4518:	001f2a01 	andseq	r2, pc, r1, lsl #20
    451c:	00004400 	andeq	r4, r0, r0, lsl #8
    4520:	8c9c0100 	ldfhis	f0, [ip], {0}
    4524:	07000006 	streq	r0, [r0, -r6]
    4528:	00000a9a 	muleq	r0, sl, sl
    452c:	a01d019d 	mulsge	sp, sp, r1
    4530:	86000005 	strhi	r0, [r0], -r5
    4534:	80000018 	andhi	r0, r0, r8, lsl r0
    4538:	07000018 	smladeq	r0, r8, r0, r0
    453c:	00000c3f 	andeq	r0, r0, pc, lsr ip
    4540:	2233019d 	eorscs	r0, r3, #1073741863	@ 0x40000027
    4544:	a2000004 	andge	r0, r0, #4
    4548:	9c000018 	stcls	0, cr0, [r0], {24}
    454c:	12000018 	andne	r0, r0, #24
    4550:	00000c5e 	andeq	r0, r0, lr, asr ip
    4554:	0063019f 	mlseq	r3, pc, r1, r0	@ <UNPREDICTABLE>
    4558:	18c00000 	stmiane	r0, {}^	@ <UNPREDICTABLE>
    455c:	18b80000 	ldmne	r8!, {}	@ <UNPREDICTABLE>
    4560:	3a020000 	bcc	84568 <__ROM_SIZE__+0x44568>
    4564:	0400001f 	streq	r0, [r0], #-31	@ 0xffffffe1
    4568:	1400000a 	strne	r0, [r0], #-10
    456c:	01000006 	tsteq	r0, r6
    4570:	30015001 	andcc	r5, r1, r1
    4574:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    4578:	01010075 	tsteq	r1, r5, ror r0
    457c:	00760252 	rsbseq	r0, r6, r2, asr r2
    4580:	1f440200 	svcne	0x00440200
    4584:	088e0000 	stmeq	lr, {}	@ <UNPREDICTABLE>
    4588:	06280000 	strteq	r0, [r8], -r0
    458c:	01010000 	mrseq	r0, (UNDEF: 1)
    4590:	00750250 	rsbseq	r0, r5, r0, asr r2
    4594:	1f4e0200 	svcne	0x004e0200
    4598:	0a040000 	beq	1045a0 <__ROM_SIZE__+0xc45a0>
    459c:	06480000 	strbeq	r0, [r8], -r0
    45a0:	01010000 	mrseq	r0, (UNDEF: 1)
    45a4:	00740250 	rsbseq	r0, r4, r0, asr r2
    45a8:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    45ac:	01010075 	tsteq	r1, r5, ror r0
    45b0:	00760252 	rsbseq	r0, r6, r2, asr r2
    45b4:	1f580200 	svcne	0x00580200
    45b8:	09c00000 	stmibeq	r0, {}^	@ <UNPREDICTABLE>
    45bc:	065c0000 	ldrbeq	r0, [ip], -r0
    45c0:	01010000 	mrseq	r0, (UNDEF: 1)
    45c4:	00750250 	rsbseq	r0, r5, r0, asr r2
    45c8:	1f5e0200 	svcne	0x005e0200
    45cc:	09890000 	stmibeq	r9, {}	@ <UNPREDICTABLE>
    45d0:	06700000 	ldrbteq	r0, [r0], -r0
    45d4:	01010000 	mrseq	r0, (UNDEF: 1)
    45d8:	00750250 	rsbseq	r0, r5, r0, asr r2
    45dc:	1f6c0400 	svcne	0x006c0400
    45e0:	0a040000 	beq	1045e8 <__ROM_SIZE__+0xc45e8>
    45e4:	01010000 	mrseq	r0, (UNDEF: 1)
    45e8:	013e0150 	teqeq	lr, r0, asr r1
    45ec:	75025101 	strvc	r5, [r2, #-257]	@ 0xfffffeff
    45f0:	52010100 	andpl	r0, r1, #0, 2
    45f4:	00007602 	andeq	r7, r0, r2, lsl #12
    45f8:	0c780800 	ldcleq	8, cr0, [r8], #-0
    45fc:	017f0000 	cmneq	pc, r0
    4600:	00001ef8 	strdeq	r1, [r0], -r8
    4604:	00000032 	andeq	r0, r0, r2, lsr r0
    4608:	06c39c01 	strbeq	r9, [r3], r1, lsl #24
    460c:	9a150000 	bls	544614 <__ROM_SIZE__+0x504614>
    4610:	7f00000a 	svcvc	0x0000000a
    4614:	05a02301 	streq	r2, [r0, #769]!	@ 0x301
    4618:	50010000 	andpl	r0, r1, r0
    461c:	000ba012 	andeq	sl, fp, r2, lsl r0
    4620:	63018100 	movwvs	r8, #4352	@ 0x1100
    4624:	e1000000 	mrs	r0, (UNDEF: 0)
    4628:	df000018 	svcle	0x00000018
    462c:	00000018 	andeq	r0, r0, r8, lsl r0
    4630:	000c9208 	andeq	r9, ip, r8, lsl #4
    4634:	b0017300 	andlt	r7, r1, r0, lsl #6
    4638:	4800001e 	stmdami	r0, {r1, r2, r3, r4}
    463c:	01000000 	mrseq	r0, (UNDEF: 0)
    4640:	00070b9c 	muleq	r7, ip, fp
    4644:	0a9a1500 	beq	fe689a4c <_STACK_TOP_+0xde681a50>
    4648:	01730000 	cmneq	r3, r0
    464c:	0005a022 	andeq	sl, r5, r2, lsr #32
    4650:	03500100 	cmpeq	r0, #0, 2
    4654:	01750069 	cmneq	r5, r9, rrx
    4658:	0000630b 	andeq	r6, r0, fp, lsl #6
    465c:	0018f100 	andseq	pc, r8, r0, lsl #2
    4660:	0018e900 	andseq	lr, r8, r0, lsl #18
    4664:	006a0300 	rsbeq	r0, sl, r0, lsl #6
    4668:	630e0175 	movwvs	r0, #57717	@ 0xe175
    466c:	15000000 	strne	r0, [r0, #-0]
    4670:	0f000019 	svceq	0x00000019
    4674:	00000019 	andeq	r0, r0, r9, lsl r0
    4678:	000c2e08 	andeq	r2, ip, r8, lsl #28
    467c:	56015e00 	strpl	r5, [r1], -r0, lsl #28
    4680:	5a00001d 	bpl	46fc <base_order+0x10e4>
    4684:	01000001 	tsteq	r0, r1
    4688:	00088e9c 	muleq	r8, ip, lr
    468c:	0a9a0700 	beq	fe686294 <_STACK_TOP_+0xde67e298>
    4690:	015e0000 	cmpeq	lr, r0
    4694:	0005a024 	andeq	sl, r5, r4, lsr #32
    4698:	00193100 	andseq	r3, r9, r0, lsl #2
    469c:	00192b00 	andseq	r2, r9, r0, lsl #22
    46a0:	00690300 	rsbeq	r0, r9, r0, lsl #6
    46a4:	26070160 	strcs	r0, [r7], -r0, ror #2
    46a8:	4e000000 	cdpmi	0, 0, cr0, cr0, cr0, {0}
    46ac:	4a000019 	bmi	4718 <base_order+0x1100>
    46b0:	03000019 	movweq	r0, #25
    46b4:	01610061 	cmneq	r1, r1, rrx
    46b8:	0000630b 	andeq	r6, r0, fp, lsl #6
    46bc:	00196000 	andseq	r6, r9, r0
    46c0:	00195e00 	andseq	r5, r9, r0, lsl #28
    46c4:	00620300 	rsbeq	r0, r2, r0, lsl #6
    46c8:	630e0161 	movwvs	r0, #57697	@ 0xe161
    46cc:	6a000000 	bvs	46d4 <base_order+0x10bc>
    46d0:	68000019 	stmdavs	r0, {r0, r3, r4}
    46d4:	03000019 	movweq	r0, #25
    46d8:	01610063 	cmneq	r1, r3, rrx
    46dc:	00006311 	andeq	r6, r0, r1, lsl r3
    46e0:	00197400 	andseq	r7, r9, r0, lsl #8
    46e4:	00197200 	andseq	r7, r9, r0, lsl #4
    46e8:	00640300 	rsbeq	r0, r4, r0, lsl #6
    46ec:	63140161 	tstvs	r4, #1073741848	@ 0x40000018
    46f0:	7e000000 	cdpvc	0, 0, cr0, cr0, cr0, {0}
    46f4:	7c000019 	stcvc	0, cr0, [r0], {25}
    46f8:	02000019 	andeq	r0, r0, #25
    46fc:	00001d7e 	andeq	r1, r0, lr, ror sp
    4700:	0000095b 	andeq	r0, r0, fp, asr r9
    4704:	000007a2 	andeq	r0, r0, r2, lsr #15
    4708:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    470c:	0200007b 	andeq	r0, r0, #123	@ 0x7b
    4710:	00001d84 	andeq	r1, r0, r4, lsl #27
    4714:	0000095b 	andeq	r0, r0, fp, asr r9
    4718:	000007b8 			@ <UNDEFINED> instruction: 0x000007b8
    471c:	04500101 	ldrbeq	r0, [r0], #-257	@ 0xfffffeff
    4720:	01944c91 			@ <UNDEFINED> instruction: 0x01944c91
    4724:	1d8a0200 	sfmne	f0, 4, [sl]
    4728:	095b0000 	ldmdbeq	fp, {}^	@ <UNPREDICTABLE>
    472c:	07cf0000 	strbeq	r0, [pc, r0]
    4730:	01010000 	mrseq	r0, (UNDEF: 1)
    4734:	b4910550 	ldrlt	r0, [r1], #1360	@ 0x550
    4738:	0001947f 	andeq	r9, r1, pc, ror r4
    473c:	001d9202 	andseq	r9, sp, r2, lsl #4
    4740:	00095b00 	andeq	r5, r9, r0, lsl #22
    4744:	0007e300 	andeq	lr, r7, r0, lsl #6
    4748:	50010100 	andpl	r0, r1, r0, lsl #2
    474c:	00007a02 	andeq	r7, r0, r2, lsl #20
    4750:	001d9802 	andseq	r9, sp, r2, lsl #16
    4754:	00095b00 	andeq	r5, r9, r0, lsl #22
    4758:	0007fa00 	andeq	pc, r7, r0, lsl #20
    475c:	50010100 	andpl	r0, r1, r0, lsl #2
    4760:	7fb89105 	svcvc	0x00b89105
    4764:	02000194 	andeq	r0, r0, #148, 2	@ 0x25
    4768:	00001d9e 	muleq	r0, lr, sp
    476c:	0000095b 	andeq	r0, r0, fp, asr r9
    4770:	00000811 	andeq	r0, r0, r1, lsl r8
    4774:	05500101 	ldrbeq	r0, [r0, #-257]	@ 0xfffffeff
    4778:	947fbc91 	ldrbtls	fp, [pc], #-3217	@ 4780 <base_order+0x1168>
    477c:	a6020001 	strge	r0, [r2], -r1
    4780:	5b00001d 	blpl	47fc <base_order+0x11e4>
    4784:	25000009 	strcs	r0, [r0, #-9]
    4788:	01000008 	tsteq	r0, r8
    478c:	79025001 	stmdbvc	r2, {r0, ip, lr}
    4790:	ac020000 	stcge	0, cr0, [r2], {-0}
    4794:	5b00001d 	blpl	4810 <base_order+0x11f8>
    4798:	3b000009 	blcc	47c4 <base_order+0x11ac>
    479c:	01000008 	tsteq	r0, r8
    47a0:	91045001 	tstls	r4, r1
    47a4:	00019454 	andeq	r9, r1, r4, asr r4
    47a8:	001db202 	andseq	fp, sp, r2, lsl #4
    47ac:	00095b00 	andeq	r5, r9, r0, lsl #22
    47b0:	00085100 	andeq	r5, r8, r0, lsl #2
    47b4:	50010100 	andpl	r0, r1, r0, lsl #2
    47b8:	94409104 	strbls	r9, [r0], #-260	@ 0xfffffefc
    47bc:	ba020001 	blt	847c8 <__ROM_SIZE__+0x447c8>
    47c0:	5b00001d 	blpl	483c <base_order+0x1224>
    47c4:	65000009 	strvs	r0, [r0, #-9]
    47c8:	01000008 	tsteq	r0, r8
    47cc:	75025001 	strvc	r5, [r2, #-1]
    47d0:	c0020000 	andgt	r0, r2, r0
    47d4:	5b00001d 	blpl	4850 <base_order+0x1238>
    47d8:	7b000009 	blvc	4804 <base_order+0x11ec>
    47dc:	01000008 	tsteq	r0, r8
    47e0:	91045001 	tstls	r4, r1
    47e4:	00019444 	andeq	r9, r1, r4, asr #8
    47e8:	001dc604 	andseq	ip, sp, r4, lsl #12
    47ec:	00095b00 	andeq	r5, r9, r0, lsl #22
    47f0:	50010100 	andpl	r0, r1, r0, lsl #2
    47f4:	94489104 	strbls	r9, [r8], #-260	@ 0xfffffefc
    47f8:	08000001 	stmdaeq	r0, {r0}
    47fc:	00000c31 	andeq	r0, r0, r1, lsr ip
    4800:	1ce0012c 	stfnee	f0, [r0], #176	@ 0xb0
    4804:	00760000 	rsbseq	r0, r6, r0
    4808:	9c010000 	stcls	0, cr0, [r1], {-0}
    480c:	0000095b 	andeq	r0, r0, fp, asr r9
    4810:	000a9a07 	andeq	r9, sl, r7, lsl #20
    4814:	21012c00 	tstcs	r1, r0, lsl #24
    4818:	000005a0 	andeq	r0, r0, r0, lsr #11
    481c:	0000198a 	andeq	r1, r0, sl, lsl #19
    4820:	00001986 	andeq	r1, r0, r6, lsl #19
    4824:	2e006903 	vmlacs.f16	s12, s0, s6	@ <UNPREDICTABLE>
    4828:	00630b01 	rsbeq	r0, r3, r1, lsl #22
    482c:	199f0000 	ldmibne	pc, {}	@ <UNPREDICTABLE>
    4830:	19990000 	ldmibne	r9, {}	@ <UNPREDICTABLE>
    4834:	54030000 	strpl	r0, [r3], #-0
    4838:	2f00706d 	svccs	0x0000706d
    483c:	00630b01 	rsbeq	r0, r3, r1, lsl #22
    4840:	19b80000 	ldmibne	r8!, {}	@ <UNPREDICTABLE>
    4844:	19b60000 	ldmibne	r6!, {}	@ <UNPREDICTABLE>
    4848:	54030000 	strpl	r0, [r3], #-0
    484c:	012f006d 			@ <UNDEFINED> instruction: 0x012f006d
    4850:	00006310 	andeq	r6, r0, r0, lsl r3
    4854:	0019de00 	andseq	sp, r9, r0, lsl #28
    4858:	0019c000 	andseq	ip, r9, r0
    485c:	00740300 	rsbseq	r0, r4, r0, lsl #6
    4860:	6314012f 	tstvs	r4, #-1073741813	@ 0xc000000b
    4864:	6d000000 	stcvs	0, cr0, [r0, #-0]
    4868:	6b00001a 	blvs	48d8 <base_order+0x12c0>
    486c:	0200001a 	andeq	r0, r0, #26
    4870:	00001d0a 	andeq	r1, r0, sl, lsl #26
    4874:	0000095b 	andeq	r0, r0, fp, asr r9
    4878:	00000919 	andeq	r0, r0, r9, lsl r9
    487c:	05500101 	ldrbeq	r0, [r0, #-257]	@ 0xfffffeff
    4880:	007a007b 	rsbseq	r0, sl, fp, ror r0
    4884:	1c020027 	stcne	0, cr0, [r2], {39}	@ 0x27
    4888:	5b00001d 	blpl	4904 <base_order+0x12ec>
    488c:	30000009 	andcc	r0, r0, r9
    4890:	01000009 	tsteq	r0, r9
    4894:	7b055001 	blvc	1588a0 <__ROM_SIZE__+0x1188a0>
    4898:	27007800 	strcs	r7, [r0, -r0, lsl #16]
    489c:	1d2e0200 	sfmne	f0, 4, [lr, #-0]
    48a0:	095b0000 	ldmdbeq	fp, {}^	@ <UNPREDICTABLE>
    48a4:	09470000 	stmdbeq	r7, {}^	@ <UNPREDICTABLE>
    48a8:	01010000 	mrseq	r0, (UNDEF: 1)
    48ac:	00780550 	rsbseq	r0, r8, r0, asr r5
    48b0:	00270077 	eoreq	r0, r7, r7, ror r0
    48b4:	001d4004 	andseq	r4, sp, r4
    48b8:	00095b00 	andeq	r5, r9, r0, lsl #22
    48bc:	50010100 	andpl	r0, r1, r0, lsl #2
    48c0:	7a007705 	bvc	224dc <__RAM_SIZE__+0x1a4dc>
    48c4:	00002700 	andeq	r2, r0, r0, lsl #14
    48c8:	000b9422 	andeq	r9, fp, r2, lsr #8
    48cc:	01260100 			@ <UNDEFINED> instruction: 0x01260100
    48d0:	00006310 	andeq	r6, r0, r0, lsl r3
    48d4:	001cce00 	andseq	ip, ip, r0, lsl #28
    48d8:	00001200 	andeq	r1, r0, r0, lsl #4
    48dc:	899c0100 	ldmibhi	ip, {r8}
    48e0:	05000009 	streq	r0, [r0, #-9]
    48e4:	01260078 			@ <UNDEFINED> instruction: 0x01260078
    48e8:	0000631e 	andeq	r6, r0, lr, lsl r3
    48ec:	001a7900 	andseq	r7, sl, r0, lsl #18
    48f0:	001a7500 	andseq	r7, sl, r0, lsl #10
    48f4:	7b080000 	blvc	2048fc <__ROM_SIZE__+0x1c48fc>
    48f8:	0a00000c 	beq	4930 <base_order+0x1318>
    48fc:	001c9c01 	andseq	r9, ip, r1, lsl #24
    4900:	00003200 	andeq	r3, r0, r0, lsl #4
    4904:	c09c0100 	addsgt	r0, ip, r0, lsl #2
    4908:	15000009 	strne	r0, [r0, #-9]
    490c:	00000a9a 	muleq	r0, sl, sl
    4910:	a020010a 	eorge	r0, r0, sl, lsl #2
    4914:	01000005 	tsteq	r0, r5
    4918:	0ba01250 	bleq	fe809260 <_STACK_TOP_+0xde801264>
    491c:	010c0000 	mrseq	r0, (UNDEF: 12)
    4920:	00000063 	andeq	r0, r0, r3, rrx
    4924:	00001a8d 	andeq	r1, r0, sp, lsl #21
    4928:	00001a8b 	andeq	r1, r0, fp, lsl #21
    492c:	0c951600 	ldceq	6, cr1, [r5], {0}
    4930:	58fb0000 	ldmpl	fp!, {}^	@ <UNPREDICTABLE>
    4934:	4400001c 	strmi	r0, [r0], #-28	@ 0xffffffe4
    4938:	01000000 	mrseq	r0, (UNDEF: 0)
    493c:	000a049c 	muleq	sl, ip, r4
    4940:	0a9a0f00 	beq	fe688548 <_STACK_TOP_+0xde68054c>
    4944:	1ffb0000 	svcne	0x00fb0000
    4948:	000005a0 	andeq	r0, r0, r0, lsr #11
    494c:	690b5001 	stmdbvs	fp, {r0, ip, lr}
    4950:	630bfd00 	movwvs	pc, #48384	@ 0xbd00	@ <UNPREDICTABLE>
    4954:	9d000000 	stcls	0, cr0, [r0, #-0]
    4958:	9500001a 	strls	r0, [r0, #-26]	@ 0xffffffe6
    495c:	0b00001a 	bleq	49cc <base_order+0x13b4>
    4960:	0efd006a 	cdpeq	0, 15, cr0, cr13, cr10, {3}
    4964:	00000063 	andeq	r0, r0, r3, rrx
    4968:	00001ac1 	andeq	r1, r0, r1, asr #21
    496c:	00001abb 			@ <UNDEFINED> instruction: 0x00001abb
    4970:	0c3c1600 	ldceq	6, cr1, [ip], #-0
    4974:	20ed0000 	rsccs	r0, sp, r0
    4978:	3800001c 	stmdacc	r0, {r2, r3, r4}
    497c:	01000000 	mrseq	r0, (UNDEF: 0)
    4980:	000a629c 	muleq	sl, ip, r2
    4984:	0c5e0f00 	mrrceq	15, 0, r0, lr, cr0
    4988:	21ed0000 	mvncs	r0, r0
    498c:	00000063 	andeq	r0, r0, r3, rrx
    4990:	9a0f5001 	bls	3d899c <__ROM_SIZE__+0x39899c>
    4994:	ed00000a 	stc	0, cr0, [r0, #-40]	@ 0xffffffd8
    4998:	0005a031 	andeq	sl, r5, r1, lsr r0
    499c:	0f510100 	svceq	0x00510100
    49a0:	00000c3f 	andeq	r0, r0, pc, lsr ip
    49a4:	042247ed 	strteq	r4, [r2], #-2029	@ 0xfffff813
    49a8:	52010000 	andpl	r0, r1, #0
    49ac:	ef00690b 	svc	0x0000690b
    49b0:	0000630b 	andeq	r6, r0, fp, lsl #6
    49b4:	001add00 	andseq	sp, sl, r0, lsl #26
    49b8:	001ad700 	andseq	sp, sl, r0, lsl #14
    49bc:	006a0b00 	rsbeq	r0, sl, r0, lsl #22
    49c0:	00630def 	rsbeq	r0, r3, pc, ror #27
    49c4:	1af80000 	bne	ffe049cc <_STACK_TOP_+0xdfdfc9d0>
    49c8:	1af40000 	bne	ffd049d0 <_STACK_TOP_+0xdfcfc9d4>
    49cc:	17000000 	strne	r0, [r0, -r0]
    49d0:	00000c69 	andeq	r0, r0, r9, ror #24
    49d4:	001fe2e5 	andseq	lr, pc, r5, ror #5
    49d8:	00000c00 	andeq	r0, r0, r0, lsl #24
    49dc:	bc9c0100 	ldflts	f0, [ip], {0}
    49e0:	0900000a 	stmdbeq	r0, {r1, r3}
    49e4:	00787463 	rsbseq	r7, r8, r3, ror #8
    49e8:	023f25e5 	eorseq	r2, pc, #960495616	@ 0x39400000
    49ec:	1b0d0000 	blne	3449f4 <__ROM_SIZE__+0x3049f4>
    49f0:	1b070000 	blne	1c49f8 <__ROM_SIZE__+0x1849f8>
    49f4:	69090000 	stmdbvs	r9, {}	@ <UNPREDICTABLE>
    49f8:	39e50076 	stmibcc	r5!, {r1, r2, r4, r5, r6}^
    49fc:	00000422 	andeq	r0, r0, r2, lsr #8
    4a00:	00001b2d 	andeq	r1, r0, sp, lsr #22
    4a04:	00001b29 	andeq	r1, r0, r9, lsr #22
    4a08:	001fec04 	andseq	lr, pc, r4, lsl #24
    4a0c:	00015c00 	andeq	r5, r1, r0, lsl #24
    4a10:	50010100 	andpl	r0, r1, r0, lsl #2
    4a14:	5001a306 	andpl	sl, r1, r6, lsl #6
    4a18:	0101f023 	tsteq	r1, r3, lsr #32	@ <UNPREDICTABLE>
    4a1c:	a3035101 	movwge	r5, #12545	@ 0x3101
    4a20:	01015101 	tsteq	r1, r1, lsl #2
    4a24:	00400152 	subeq	r0, r0, r2, asr r1
    4a28:	0b841700 	bleq	fe10a630 <_STACK_TOP_+0xde102634>
    4a2c:	cae00000 	bgt	ff804a34 <_STACK_TOP_+0xdf7fca38>
    4a30:	1800001f 	stmdane	r0, {r0, r1, r2, r3, r4}
    4a34:	01000000 	mrseq	r0, (UNDEF: 0)
    4a38:	000b409c 	muleq	fp, ip, r0
    4a3c:	74630900 	strbtvc	r0, [r3], #-2304	@ 0xfffff700
    4a40:	26e00078 	uxtabcs	r0, r0, r8
    4a44:	0000023f 	andeq	r0, r0, pc, lsr r2
    4a48:	00001b43 	andeq	r1, r0, r3, asr #22
    4a4c:	00001b3f 	andeq	r1, r0, pc, lsr fp
    4a50:	79656b09 	stmdbvc	r5!, {r0, r3, r8, r9, fp, sp, lr}^
    4a54:	223ae000 	eorscs	lr, sl, #0
    4a58:	56000004 	strpl	r0, [r0], -r4
    4a5c:	5200001b 	andpl	r0, r0, #27
    4a60:	0900001b 	stmdbeq	r0, {r0, r1, r3, r4}
    4a64:	e0007669 	and	r7, r0, r9, ror #12
    4a68:	0004224e 	andeq	r2, r4, lr, asr #4
    4a6c:	001b6c00 	andseq	r6, fp, r0, lsl #24
    4a70:	001b6800 	andseq	r6, fp, r0, lsl #16
    4a74:	1fd40200 	svcne	0x00d40200
    4a78:	0b930000 	bleq	fe4c4a80 <_STACK_TOP_+0xde4bca84>
    4a7c:	0b230000 	bleq	8c4a84 <__ROM_SIZE__+0x884a84>
    4a80:	01010000 	mrseq	r0, (UNDEF: 1)
    4a84:	00740250 	rsbseq	r0, r4, r0, asr r2
    4a88:	03510101 	cmpeq	r1, #1073741824	@ 0x40000000
    4a8c:	005101a3 	subseq	r0, r1, r3, lsr #3
    4a90:	001fe004 	andseq	lr, pc, r4
    4a94:	00015c00 	andeq	r5, r1, r0, lsl #24
    4a98:	50010100 	andpl	r0, r1, r0, lsl #2
    4a9c:	01f07403 	mvnseq	r7, r3, lsl #8
    4aa0:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    4aa4:	01010075 	tsteq	r1, r5, ror r0
    4aa8:	00400152 	subeq	r0, r0, r2, asr r1
    4aac:	05291700 	streq	r1, [r9, #-1792]!	@ 0xfffff900
    4ab0:	c2db0000 	sbcsgt	r0, fp, #0
    4ab4:	0800001f 	stmdaeq	r0, {r0, r1, r2, r3, r4}
    4ab8:	01000000 	mrseq	r0, (UNDEF: 0)
    4abc:	000b939c 	muleq	fp, ip, r3
    4ac0:	74630900 	strbtvc	r0, [r3], #-2304	@ 0xfffff700
    4ac4:	23db0078 	bicscs	r0, fp, #120	@ 0x78
    4ac8:	0000023f 	andeq	r0, r0, pc, lsr r2
    4acc:	00001b7f 	andeq	r1, r0, pc, ror fp
    4ad0:	00001b7b 	andeq	r1, r0, fp, ror fp
    4ad4:	79656b09 	stmdbvc	r5!, {r0, r3, r8, r9, fp, sp, lr}^
    4ad8:	2237db00 	eorscs	sp, r7, #0, 22
    4adc:	95000004 	strls	r0, [r0, #-4]
    4ae0:	9100001b 	tstls	r0, fp, lsl r0
    4ae4:	0400001b 	streq	r0, [r0], #-27	@ 0xffffffe5
    4ae8:	00001fc8 	andeq	r1, r0, r8, asr #31
    4aec:	00000b93 	muleq	r0, r3, fp
    4af0:	03500101 	cmpeq	r0, #1073741824	@ 0x40000000
    4af4:	015001a3 	cmpeq	r0, r3, lsr #3
    4af8:	a3035101 	movwge	r5, #12545	@ 0x3101
    4afc:	00005101 	andeq	r5, r0, r1, lsl #2
    4b00:	000c8516 	andeq	r8, ip, r6, lsl r5
    4b04:	1b009200 	blne	2930c <__RAM_SIZE__+0x2130c>
    4b08:	01200000 			@ <UNDEFINED> instruction: 0x01200000
    4b0c:	9c010000 	stcls	0, cr0, [r1], {-0}
    4b10:	00000c27 	andeq	r0, r0, r7, lsr #24
    4b14:	000c3f0f 	andeq	r3, ip, pc, lsl #30
    4b18:	44239200 	strtmi	r9, [r3], #-512	@ 0xfffffe00
    4b1c:	01000002 	tsteq	r0, r2
    4b20:	654b0950 	strbvs	r0, [fp, #-2384]	@ 0xfffff6b0
    4b24:	3c920079 	ldccc	0, cr0, [r2], {121}	@ 0x79
    4b28:	00000422 	andeq	r0, r0, r2, lsr #8
    4b2c:	00001bab 	andeq	r1, r0, fp, lsr #23
    4b30:	00001ba7 	andeq	r1, r0, r7, lsr #23
    4b34:	9400690b 	strls	r6, [r0], #-2315	@ 0xfffff6f5
    4b38:	0000390c 	andeq	r3, r0, ip, lsl #18
    4b3c:	001bc000 	andseq	ip, fp, r0
    4b40:	001bba00 	andseq	fp, fp, r0, lsl #20
    4b44:	006a0b00 	rsbeq	r0, sl, r0, lsl #22
    4b48:	00390f94 	mlaseq	r9, r4, pc, r0	@ <UNPREDICTABLE>
    4b4c:	1bd60000 	blne	ff584b54 <_STACK_TOP_+0xdf57cb58>
    4b50:	1bd20000 	blne	ff484b58 <_STACK_TOP_+0xdf47cb5c>
    4b54:	6b0b0000 	blvs	2c4b5c <__ROM_SIZE__+0x284b5c>
    4b58:	39129400 	ldmdbcc	r2, {sl, ip, pc}
    4b5c:	ed000000 	stc	0, cr0, [r0, #-0]
    4b60:	e300001b 	movw	r0, #27
    4b64:	1100001b 	tstne	r0, fp, lsl r0
    4b68:	00000b9a 	muleq	r0, sl, fp
    4b6c:	0c270b95 			@ <UNDEFINED> instruction: 0x0c270b95
    4b70:	91020000 	mrsls	r0, (UNDEF: 2)
    4b74:	1bac236c 	blne	feb0d92c <_STACK_TOP_+0xdeb05930>
    4b78:	00100000 	andseq	r0, r0, r0
    4b7c:	09240000 	stmdbeq	r4!, {}	@ <UNPREDICTABLE>
    4b80:	0100000c 	tsteq	r0, ip
    4b84:	006f17b3 	strhteq	r1, [pc], #-115
    4b88:	1c250000 	stcne	0, cr0, [r5], #-0
    4b8c:	1c1f0000 	ldcne	0, cr0, [pc], {-0}
    4b90:	00000000 	andeq	r0, r0, r0
    4b94:	00006325 	andeq	r6, r0, r5, lsr #6
    4b98:	00390a00 	eorseq	r0, r9, r0, lsl #20
    4b9c:	00030000 	andeq	r0, r3, r0
    4ba0:	00124100 	andseq	r4, r2, r0, lsl #2
    4ba4:	01000500 	tsteq	r0, r0, lsl #10
    4ba8:	001a5504 	andseq	r5, sl, r4, lsl #10
    4bac:	00141900 	andseq	r1, r4, r0, lsl #18
    4bb0:	591d0000 	ldmdbpl	sp, {}	@ <UNPREDICTABLE>
    4bb4:	7700000e 	strvc	r0, [r0, -lr]
    4bb8:	fc000001 	stc2	0, cr0, [r0], {1}
    4bbc:	80000020 	andhi	r0, r0, r0, lsr #32
    4bc0:	ac000005 	stcge	0, cr0, [r0], {5}
    4bc4:	08000039 	stmdaeq	r0, {r0, r3, r4, r5}
    4bc8:	00fe0601 	rscseq	r0, lr, r1, lsl #12
    4bcc:	02080000 	andeq	r0, r8, #0
    4bd0:	00016805 	andeq	r6, r1, r5, lsl #16
    4bd4:	05040800 	streq	r0, [r4, #-2048]	@ 0xfffff800
    4bd8:	00000158 	andeq	r0, r0, r8, asr r1
    4bdc:	53050808 	movwpl	r0, #22536	@ 0x5808
    4be0:	0f000001 	svceq	0x00000001
    4be4:	00000134 	andeq	r0, r0, r4, lsr r1
    4be8:	53182e02 	tstpl	r8, #2, 28
    4bec:	14000000 	strne	r0, [r0], #-0
    4bf0:	00000042 	andeq	r0, r0, r2, asr #32
    4bf4:	fc080108 	stc2	1, cr0, [r8], {8}
    4bf8:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
    4bfc:	010a0702 	tsteq	sl, r2, lsl #14
    4c00:	b10f0000 	mrslt	r0, CPSR
    4c04:	02000001 	andeq	r0, r0, #1
    4c08:	00721934 	rsbseq	r1, r2, r4, lsr r9
    4c0c:	61140000 	tstvs	r4, r0
    4c10:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
    4c14:	01220704 			@ <UNDEFINED> instruction: 0x01220704
    4c18:	08080000 	stmdaeq	r8, {}	@ <UNPREDICTABLE>
    4c1c:	00011d07 	andeq	r1, r1, r7, lsl #26
    4c20:	05041a00 	streq	r1, [r4, #-2560]	@ 0xfffff600
    4c24:	00746e69 	rsbseq	r6, r4, r9, ror #28
    4c28:	27070408 	strcs	r0, [r7, -r8, lsl #8]
    4c2c:	0f000001 	svceq	0x00000001
    4c30:	00000ddc 	ldrdeq	r0, [r0], -ip
    4c34:	9f124501 	svcls	0x00124501
    4c38:	14000000 	strne	r0, [r0], #-0
    4c3c:	0000008e 	andeq	r0, r0, lr, lsl #1
    4c40:	0000611b 	andeq	r6, r0, fp, lsl r1
    4c44:	0000af00 	andeq	sl, r0, r0, lsl #30
    4c48:	00871c00 	addeq	r1, r7, r0, lsl #24
    4c4c:	00050000 	andeq	r0, r5, r0
    4c50:	000cd60f 	andeq	sp, ip, pc, lsl #12
    4c54:	12460100 	subne	r0, r6, #0, 2
    4c58:	0000008e 	andeq	r0, r0, lr, lsl #1
    4c5c:	000cc40c 	andeq	ip, ip, ip, lsl #8
    4c60:	009a5e00 	addseq	r5, sl, r0, lsl #28
    4c64:	03050000 	movweq	r0, #20480	@ 0x5000
    4c68:	000035b8 			@ <UNDEFINED> instruction: 0x000035b8
    4c6c:	000e3c0c 	andeq	r3, lr, ip, lsl #24
    4c70:	009a5f00 	addseq	r5, sl, r0, lsl #30
    4c74:	03050000 	movweq	r0, #20480	@ 0x5000
    4c78:	000035d0 	ldrdeq	r3, [r0], -r0
    4c7c:	000e0f0c 	andeq	r0, lr, ip, lsl #30
    4c80:	009a6000 	addseq	r6, sl, r0
    4c84:	03050000 	movweq	r0, #20480	@ 0x5000
    4c88:	00003600 	andeq	r3, r0, r0, lsl #12
    4c8c:	000e160c 	andeq	r1, lr, ip, lsl #12
    4c90:	009a6100 	addseq	r6, sl, r0, lsl #2
    4c94:	03050000 	movweq	r0, #20480	@ 0x5000
    4c98:	000035e8 	andeq	r3, r0, r8, ror #11
    4c9c:	000d0a0c 	andeq	r0, sp, ip, lsl #20
    4ca0:	009a6200 	addseq	r6, sl, r0, lsl #4
    4ca4:	03050000 	movweq	r0, #20480	@ 0x5000
    4ca8:	00003618 	andeq	r3, r0, r8, lsl r6
    4cac:	00054616 	andeq	r4, r5, r6, lsl r6
    4cb0:	8002ea00 	andhi	lr, r2, r0, lsl #20
    4cb4:	34000000 	strcc	r0, [r0], #-0
    4cb8:	48000026 	stmdami	r0, {r1, r2, r5}
    4cbc:	01000000 	mrseq	r0, (UNDEF: 0)
    4cc0:	0001cd9c 	muleq	r1, ip, sp
    4cc4:	0d960900 	vldreq.16	s0, [r6]	@ <UNPREDICTABLE>
    4cc8:	02ea0000 	rsceq	r0, sl, #0
    4ccc:	0001cd27 	andeq	ip, r1, r7, lsr #26
    4cd0:	001c5200 	andseq	r5, ip, r0, lsl #4
    4cd4:	001c4e00 	andseq	r4, ip, r0, lsl #28
    4cd8:	0d720900 			@ <UNDEFINED> instruction: 0x0d720900
    4cdc:	02ea0000 	rsceq	r0, sl, #0
    4ce0:	0001cd43 	andeq	ip, r1, r3, asr #26
    4ce4:	001c6500 	andseq	r6, ip, r0, lsl #10
    4ce8:	001c6100 	andseq	r6, ip, r0, lsl #2
    4cec:	08e20900 	stmiaeq	r2!, {r8, fp}^
    4cf0:	02ea0000 	rsceq	r0, sl, #0
    4cf4:	0001d258 	andeq	sp, r1, r8, asr r2
    4cf8:	001c7800 	andseq	r7, ip, r0, lsl #16
    4cfc:	001c7400 	andseq	r7, ip, r0, lsl #8
    4d00:	265a1000 	ldrbcs	r1, [sl], -r0
    4d04:	00220000 	eoreq	r0, r2, r0
    4d08:	019c0000 	orrseq	r0, ip, r0
    4d0c:	69050000 	stmdbvs	r5, {}	@ <UNPREDICTABLE>
    4d10:	1202f100 	andne	pc, r2, #0, 2
    4d14:	00000087 	andeq	r0, r0, r7, lsl #1
    4d18:	00001c89 	andeq	r1, r0, r9, lsl #25
    4d1c:	00001c87 	andeq	r1, r0, r7, lsl #25
    4d20:	00267804 	eoreq	r7, r6, r4, lsl #16
    4d24:	00044600 	andeq	r4, r4, r0, lsl #12
    4d28:	50010100 	andpl	r0, r1, r0, lsl #2
    4d2c:	01007502 	tsteq	r0, r2, lsl #10
    4d30:	75025101 	strvc	r5, [r2, #-257]	@ 0xfffffeff
    4d34:	52010118 	andpl	r0, r1, #24, 2
    4d38:	00007602 	andeq	r7, r0, r2, lsl #12
    4d3c:	26480200 	strbcs	r0, [r8], -r0, lsl #4
    4d40:	09fa0000 	ldmibeq	sl!, {}^	@ <UNPREDICTABLE>
    4d44:	01b60000 			@ <UNDEFINED> instruction: 0x01b60000
    4d48:	01010000 	mrseq	r0, (UNDEF: 1)
    4d4c:	00740250 	rsbseq	r0, r4, r0, asr r2
    4d50:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    4d54:	04000077 	streq	r0, [r0], #-119	@ 0xffffff89
    4d58:	00002656 	andeq	r2, r0, r6, asr r6
    4d5c:	000002d6 	ldrdeq	r0, [r0], -r6
    4d60:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    4d64:	01010074 	tsteq	r1, r4, ror r0
    4d68:	00770251 	rsbseq	r0, r7, r1, asr r2
    4d6c:	4e110000 	cdpmi	0, 1, cr0, cr1, cr0, {0}
    4d70:	11000000 	mrsne	r0, (UNDEF: 0)
    4d74:	00000042 	andeq	r0, r0, r2, asr #32
    4d78:	0004a416 	andeq	sl, r4, r6, lsl r4
    4d7c:	8002cc00 	andhi	ip, r2, r0, lsl #24
    4d80:	e0000000 	and	r0, r0, r0
    4d84:	54000025 	strpl	r0, [r0], #-37	@ 0xffffffdb
    4d88:	01000000 	mrseq	r0, (UNDEF: 0)
    4d8c:	0002d69c 	muleq	r2, ip, r6
    4d90:	0d8b0900 	vstreq.16	s0, [fp]	@ <UNPREDICTABLE>
    4d94:	02cc0000 	sbceq	r0, ip, #0
    4d98:	0001d221 	andeq	sp, r1, r1, lsr #4
    4d9c:	001c9500 	andseq	r9, ip, r0, lsl #10
    4da0:	001c9100 	andseq	r9, ip, r0, lsl #2
    4da4:	0d960900 	vldreq.16	s0, [r6]	@ <UNPREDICTABLE>
    4da8:	02cc0000 	sbceq	r0, ip, #0
    4dac:	0001d236 	andeq	sp, r1, r6, lsr r2
    4db0:	001ca800 	andseq	sl, ip, r0, lsl #16
    4db4:	001ca400 	andseq	sl, ip, r0, lsl #8
    4db8:	26021000 	strcs	r1, [r2], -r0
    4dbc:	00240000 	eoreq	r0, r4, r0
    4dc0:	02990000 	addseq	r0, r9, #0
    4dc4:	4f120000 	svcmi	0x00120000
    4dc8:	d900000d 	stmdble	r0, {r0, r2, r3}
    4dcc:	00800902 	addeq	r0, r0, r2, lsl #18
    4dd0:	1cb90000 	ldcne	0, cr0, [r9]
    4dd4:	1cb70000 	ldcne	0, cr0, [r7]
    4dd8:	69050000 	stmdbvs	r5, {}	@ <UNPREDICTABLE>
    4ddc:	0902da00 	stmdbeq	r2, {r9, fp, ip, lr, pc}
    4de0:	00000080 	andeq	r0, r0, r0, lsl #1
    4de4:	00001cc3 	andeq	r1, r0, r3, asr #25
    4de8:	00001cc1 	andeq	r1, r0, r1, asr #25
    4dec:	00260802 	eoreq	r0, r6, r2, lsl #16
    4df0:	000ffe00 	andeq	pc, pc, r0, lsl #28
    4df4:	00026200 	andeq	r6, r2, r0, lsl #4
    4df8:	50010100 	andpl	r0, r1, r0, lsl #2
    4dfc:	36180305 	ldrcc	r0, [r8], -r5, lsl #6
    4e00:	02000000 	andeq	r0, r0, #0
    4e04:	00002614 	andeq	r2, r0, r4, lsl r6
    4e08:	000011d6 	ldrdeq	r1, [r0], -r6
    4e0c:	0000027c 	andeq	r0, r0, ip, ror r2
    4e10:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    4e14:	01010075 	tsteq	r1, r5, ror r0
    4e18:	00740251 	rsbseq	r0, r4, r1, asr r2
    4e1c:	26240400 	strtcs	r0, [r4], -r0, lsl #8
    4e20:	04460000 	strbeq	r0, [r6], #-0
    4e24:	01010000 	mrseq	r0, (UNDEF: 1)
    4e28:	00760250 	rsbseq	r0, r6, r0, asr r2
    4e2c:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    4e30:	01010077 	tsteq	r1, r7, ror r0
    4e34:	00750252 	rsbseq	r0, r5, r2, asr r2
    4e38:	f8020000 			@ <UNDEFINED> instruction: 0xf8020000
    4e3c:	bc000025 	stclt	0, cr0, [r0], {37}	@ 0x25
    4e40:	c500000a 	strgt	r0, [r0, #-10]
    4e44:	01000002 	tsteq	r0, r2
    4e48:	76025001 	strvc	r5, [r2], -r1
    4e4c:	51010100 	mrspl	r0, (UNDEF: 17)
    4e50:	01007702 	tsteq	r0, r2, lsl #14
    4e54:	03055201 	movweq	r5, #20993	@ 0x5201
    4e58:	00003600 	andeq	r3, r0, r0, lsl #12
    4e5c:	05530101 	ldrbeq	r0, [r3, #-257]	@ 0xfffffeff
    4e60:	0035e803 	eorseq	lr, r5, r3, lsl #16
    4e64:	fe040000 	cdp2	0, 0, cr0, cr4, cr0, {0}
    4e68:	fe000025 	cdp2	0, 0, cr0, cr0, cr5, {1}
    4e6c:	0100000f 	tsteq	r0, pc
    4e70:	75025001 	strvc	r5, [r2, #-1]
    4e74:	0d000000 	stceq	0, cr0, [r0, #-0]
    4e78:	00000d3d 	andeq	r0, r0, sp, lsr sp
    4e7c:	008002a8 	addeq	r0, r0, r8, lsr #5
    4e80:	25780000 	ldrbcs	r0, [r8, #-0]!
    4e84:	00680000 	rsbeq	r0, r8, r0
    4e88:	9c010000 	stcls	0, cr0, [r1], {-0}
    4e8c:	00000441 	andeq	r0, r0, r1, asr #8
    4e90:	a8007803 	stmdage	r0, {r0, r1, fp, ip, sp, lr}
    4e94:	04412e02 	strbeq	r2, [r1], #-3586	@ 0xfffff1fe
    4e98:	1ccf0000 	stclne	0, cr0, [pc], {0}
    4e9c:	1ccb0000 	stclne	0, cr0, [fp], {0}
    4ea0:	79030000 	stmdbvc	r3, {}	@ <UNPREDICTABLE>
    4ea4:	4102a800 	tstmi	r2, r0, lsl #16
    4ea8:	00000441 	andeq	r0, r0, r1, asr #8
    4eac:	00001ce2 	andeq	r1, r0, r2, ror #25
    4eb0:	00001cde 	ldrdeq	r1, [r0], -lr
    4eb4:	aa006106 	bge	1d2d4 <__RAM_SIZE__+0x152d4>
    4eb8:	00af0d02 	adceq	r0, pc, r2, lsl #26
    4ebc:	91020000 	mrsls	r0, (UNDEF: 2)
    4ec0:	00620658 	rsbeq	r0, r2, r8, asr r6
    4ec4:	af1002aa 	svcge	0x001002aa
    4ec8:	02000000 	andeq	r0, r0, #0
    4ecc:	84024091 	strhi	r4, [r2], #-145	@ 0xffffff6f
    4ed0:	fa000025 	blx	4f6c <base_order+0x1954>
    4ed4:	47000009 	strmi	r0, [r0, -r9]
    4ed8:	01000003 	tsteq	r0, r3
    4edc:	74025001 	strvc	r5, [r2], #-1
    4ee0:	51010100 	mrspl	r0, (UNDEF: 17)
    4ee4:	00007502 	andeq	r7, r0, r2, lsl #10
    4ee8:	00259602 	eoreq	r9, r5, r2, lsl #12
    4eec:	000d2600 	andeq	r2, sp, r0, lsl #12
    4ef0:	00036700 	andeq	r6, r3, r0, lsl #14
    4ef4:	50010100 	andpl	r0, r1, r0, lsl #2
    4ef8:	01589102 	cmpeq	r8, r2, lsl #2
    4efc:	74025101 	strvc	r5, [r2], #-257	@ 0xfffffeff
    4f00:	52010100 	andpl	r0, r1, #0, 2
    4f04:	00007402 	andeq	r7, r0, r2, lsl #8
    4f08:	0025a002 	eoreq	sl, r5, r2
    4f0c:	000d2600 	andeq	r2, sp, r0, lsl #12
    4f10:	00038700 	andeq	r8, r3, r0, lsl #14
    4f14:	50010100 	andpl	r0, r1, r0, lsl #2
    4f18:	01007d02 	tsteq	r0, r2, lsl #26
    4f1c:	91025101 	tstls	r2, r1, lsl #2
    4f20:	52010158 	andpl	r0, r1, #88, 2
    4f24:	00007402 	andeq	r7, r0, r2, lsl #8
    4f28:	0025aa02 	eoreq	sl, r5, r2, lsl #20
    4f2c:	000ea800 	andeq	sl, lr, r0, lsl #16
    4f30:	0003a700 	andeq	sl, r3, r0, lsl #14
    4f34:	50010100 	andpl	r0, r1, r0, lsl #2
    4f38:	01589102 	cmpeq	r8, r2, lsl #2
    4f3c:	91025101 	tstls	r2, r1, lsl #2
    4f40:	52010158 	andpl	r0, r1, #88, 2
    4f44:	00007d02 	andeq	r7, r0, r2, lsl #26
    4f48:	0025b402 	eoreq	fp, r5, r2, lsl #8
    4f4c:	000ea800 	andeq	sl, lr, r0, lsl #16
    4f50:	0003ca00 	andeq	ip, r3, r0, lsl #20
    4f54:	50010100 	andpl	r0, r1, r0, lsl #2
    4f58:	01589102 	cmpeq	r8, r2, lsl #2
    4f5c:	91025101 	tstls	r2, r1, lsl #2
    4f60:	52010158 	andpl	r0, r1, #88, 2
    4f64:	35d00305 	ldrbcc	r0, [r0, #773]	@ 0x305
    4f68:	02000000 	andeq	r0, r0, #0
    4f6c:	000025be 			@ <UNDEFINED> instruction: 0x000025be
    4f70:	00000d26 	andeq	r0, r0, r6, lsr #26
    4f74:	000003ea 	andeq	r0, r0, sl, ror #7
    4f78:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    4f7c:	0101007d 	tsteq	r1, sp, ror r0
    4f80:	00750251 	rsbseq	r0, r5, r1, asr r2
    4f84:	02520101 	subseq	r0, r2, #1073741824	@ 0x40000000
    4f88:	02000075 	andeq	r0, r0, #117	@ 0x75
    4f8c:	000025c8 	andeq	r2, r0, r8, asr #11
    4f90:	00000ea8 	andeq	r0, r0, r8, lsr #29
    4f94:	0000040a 	andeq	r0, r0, sl, lsl #8
    4f98:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    4f9c:	01015891 			@ <UNDEFINED> instruction: 0x01015891
    4fa0:	58910251 	ldmpl	r1, {r0, r4, r6, r9}
    4fa4:	02520101 	subseq	r0, r2, #1073741824	@ 0x40000000
    4fa8:	0200007d 	andeq	r0, r0, #125	@ 0x7d
    4fac:	000025d2 	ldrdeq	r2, [r0], -r2	@ <UNPREDICTABLE>
    4fb0:	00000d26 	andeq	r0, r0, r6, lsr #26
    4fb4:	0000042a 	andeq	r0, r0, sl, lsr #8
    4fb8:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    4fbc:	0101007d 	tsteq	r1, sp, ror r0
    4fc0:	00740251 	rsbseq	r0, r4, r1, asr r2
    4fc4:	02520101 	subseq	r0, r2, #1073741824	@ 0x40000000
    4fc8:	04000075 	streq	r0, [r0], #-117	@ 0xffffff8b
    4fcc:	000025da 	ldrdeq	r2, [r0], -sl
    4fd0:	000010c4 	andeq	r1, r0, r4, asr #1
    4fd4:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    4fd8:	01015891 			@ <UNDEFINED> instruction: 0x01015891
    4fdc:	007d0251 	rsbseq	r0, sp, r1, asr r2
    4fe0:	6d110000 	ldcvs	0, cr0, [r1, #-0]
    4fe4:	07000000 	streq	r0, [r0, -r0]
    4fe8:	00000e44 	andeq	r0, r0, r4, asr #28
    4fec:	25220274 	strcs	r0, [r2, #-628]!	@ 0xfffffd8c
    4ff0:	00560000 	subseq	r0, r6, r0
    4ff4:	9c010000 	stcls	0, cr0, [r1], {-0}
    4ff8:	0000057f 	andeq	r0, r0, pc, ror r5
    4ffc:	74007803 	strvc	r7, [r0], #-2051	@ 0xfffff7fd
    5000:	057f2402 	ldrbeq	r2, [pc, #-1026]!	@ 4c06 <base_order+0x15ee>
    5004:	1cf50000 	ldclne	0, cr0, [r5]
    5008:	1cf10000 	ldclne	0, cr0, [r1]
    500c:	79030000 	stmdbvc	r3, {}	@ <UNPREDICTABLE>
    5010:	31027400 	tstcc	r2, r0, lsl #8
    5014:	0000057f 	andeq	r0, r0, pc, ror r5
    5018:	00001d08 	andeq	r1, r0, r8, lsl #26
    501c:	00001d04 	andeq	r1, r0, r4, lsl #26
    5020:	70786503 	rsbsvc	r6, r8, r3, lsl #10
    5024:	43027400 	movwmi	r7, #9216	@ 0x2400
    5028:	00000441 	andeq	r0, r0, r1, asr #8
    502c:	00001d1b 	andeq	r1, r0, fp, lsl sp
    5030:	00001d17 	andeq	r1, r0, r7, lsl sp
    5034:	000ca817 	andeq	sl, ip, r7, lsl r8
    5038:	00af0d00 	adceq	r0, pc, r0, lsl #26
    503c:	91020000 	mrsls	r0, (UNDEF: 2)
    5040:	0cad1750 	stceq	7, cr1, [sp], #320	@ 0x140
    5044:	af130000 	svcge	0x00130000
    5048:	03000000 	movweq	r0, #0
    504c:	057fb891 	ldrbeq	fp, [pc, #-2193]!	@ 47c3 <base_order+0x11ab>
    5050:	02770069 	rsbseq	r0, r7, #105	@ 0x69
    5054:	00008007 	andeq	r8, r0, r7
    5058:	001d2c00 	andseq	r2, sp, r0, lsl #24
    505c:	001d2a00 	andseq	r2, sp, r0, lsl #20
    5060:	0d4f1200 	sfmeq	f1, 2, [pc, #-0]	@ 5068 <base_order+0x1a50>
    5064:	02780000 	rsbseq	r0, r8, #0
    5068:	00008007 	andeq	r8, r0, r7
    506c:	001d3a00 	andseq	r3, sp, r0, lsl #20
    5070:	001d3400 	andseq	r3, sp, r0, lsl #8
    5074:	25320200 	ldrcs	r0, [r2, #-512]!	@ 0xfffffe00
    5078:	0ffe0000 	svceq	0x00fe0000
    507c:	04e80000 	strbteq	r0, [r8], #0
    5080:	01010000 	mrseq	r0, (UNDEF: 1)
    5084:	00750250 	rsbseq	r0, r5, r0, asr r2
    5088:	253c0200 	ldrcs	r0, [ip, #-512]!	@ 0xfffffe00
    508c:	0a5d0000 	beq	1745094 <__ROM_SIZE__+0x1705094>
    5090:	05020000 	streq	r0, [r2, #-0]
    5094:	01010000 	mrseq	r0, (UNDEF: 1)
    5098:	50910250 	addspl	r0, r1, r0, asr r2
    509c:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    50a0:	0200007d 	andeq	r0, r0, #125	@ 0x7d
    50a4:	0000254e 	andeq	r2, r0, lr, asr #10
    50a8:	00000877 	andeq	r0, r0, r7, ror r8
    50ac:	0000051c 	andeq	r0, r0, ip, lsl r5
    50b0:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    50b4:	01015091 	swpeq	r5, r1, [r1]	@ <UNPREDICTABLE>
    50b8:	007d0251 	rsbseq	r0, sp, r1, asr r2
    50bc:	25560200 	ldrbcs	r0, [r6, #-512]	@ 0xfffffe00
    50c0:	12090000 	andne	r0, r9, #0
    50c4:	05360000 	ldreq	r0, [r6, #-0]!
    50c8:	01010000 	mrseq	r0, (UNDEF: 1)
    50cc:	00750250 	rsbseq	r0, r5, r0, asr r2
    50d0:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    50d4:	02000074 	andeq	r0, r0, #116	@ 0x74
    50d8:	00002566 	andeq	r2, r0, r6, ror #10
    50dc:	00000584 	andeq	r0, r0, r4, lsl #11
    50e0:	0000055c 	andeq	r0, r0, ip, asr r5
    50e4:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    50e8:	01015091 	swpeq	r5, r1, [r1]	@ <UNPREDICTABLE>
    50ec:	007d0251 	rsbseq	r0, sp, r1, asr r2
    50f0:	02520101 	subseq	r0, r2, #1073741824	@ 0x40000000
    50f4:	01010076 	tsteq	r1, r6, ror r0
    50f8:	00770253 	rsbseq	r0, r7, r3, asr r2
    50fc:	25740400 	ldrbcs	r0, [r4, #-1024]!	@ 0xfffffc00
    5100:	0abc0000 	beq	fef05108 <_STACK_TOP_+0xdeefd10c>
    5104:	01010000 	mrseq	r0, (UNDEF: 1)
    5108:	00760250 	rsbseq	r0, r6, r0, asr r2
    510c:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    5110:	01010077 	tsteq	r1, r7, ror r0
    5114:	50910252 	addspl	r0, r1, r2, asr r2
    5118:	02530101 	subseq	r0, r3, #1073741824	@ 0x40000000
    511c:	0000007d 	andeq	r0, r0, sp, ror r0
    5120:	00006111 	andeq	r6, r0, r1, lsl r1
    5124:	0e020700 	cdpeq	7, 0, cr0, cr2, cr0, {0}
    5128:	02420000 	subeq	r0, r2, #0
    512c:	0000244e 	andeq	r2, r0, lr, asr #8
    5130:	000000d4 	ldrdeq	r0, [r0], -r4
    5134:	08779c01 	ldmdaeq	r7!, {r0, sl, fp, ip, pc}^
    5138:	78030000 	stmdavc	r3, {}	@ <UNPREDICTABLE>
    513c:	02420031 	subeq	r0, r2, #49	@ 0x31
    5140:	00057f24 	andeq	r7, r5, r4, lsr #30
    5144:	001d5600 	andseq	r5, sp, r0, lsl #12
    5148:	001d5200 	andseq	r5, sp, r0, lsl #4
    514c:	31790300 	cmncc	r9, r0, lsl #6
    5150:	32024200 	andcc	r4, r2, #0, 4
    5154:	0000057f 	andeq	r0, r0, pc, ror r5
    5158:	00001d69 	andeq	r1, r0, r9, ror #26
    515c:	00001d65 	andeq	r1, r0, r5, ror #26
    5160:	00327803 	eorseq	r7, r2, r3, lsl #16
    5164:	41460242 	cmpmi	r6, r2, asr #4
    5168:	7c000004 	stcvc	0, cr0, [r0], {4}
    516c:	7800001d 	stmdavc	r0, {r0, r2, r3, r4}
    5170:	0300001d 	movweq	r0, #29
    5174:	42003279 	andmi	r3, r0, #-1879048185	@ 0x90000007
    5178:	04415a02 	strbeq	r5, [r1], #-2562	@ 0xfffff5fe
    517c:	1d8f0000 	stcne	0, cr0, [pc]	@ 5184 <base_order+0x1b6c>
    5180:	1d8b0000 	stcne	0, cr0, [fp]
    5184:	a6100000 	ldrge	r0, [r0], -r0
    5188:	7a000024 	bvc	5220 <base_order+0x1c08>
    518c:	b8000000 	stmdalt	r0, {}	@ <UNPREDICTABLE>
    5190:	06000007 	streq	r0, [r0], -r7
    5194:	025a0061 	subseq	r0, sl, #97	@ 0x61
    5198:	0000af13 	andeq	sl, r0, r3, lsl pc
    519c:	88910300 	ldmhi	r1, {r8, r9}
    51a0:	0062067f 	rsbeq	r0, r2, pc, ror r6
    51a4:	af16025a 	svcge	0x0016025a
    51a8:	03000000 	movweq	r0, #0
    51ac:	067fa091 			@ <UNDEFINED> instruction: 0x067fa091
    51b0:	025a0063 	subseq	r0, sl, #99	@ 0x63
    51b4:	0000af19 	andeq	sl, r0, r9, lsl pc
    51b8:	b8910300 	ldmlt	r1, {r8, r9}
    51bc:	0064067f 	rsbeq	r0, r4, pc, ror r6
    51c0:	af1c025a 	svcge	0x001c025a
    51c4:	02000000 	andeq	r0, r0, #0
    51c8:	b0025091 	mullt	r2, r1, r0
    51cc:	a8000024 	stmdage	r0, {r2, r5}
    51d0:	4900000e 	stmdbmi	r0, {r1, r2, r3}
    51d4:	01000006 	tsteq	r0, r6
    51d8:	7d025001 	stcvc	0, cr5, [r2, #-4]
    51dc:	51010100 	mrspl	r0, (UNDEF: 17)
    51e0:	01007702 	tsteq	r0, r2, lsl #14
    51e4:	76025201 	strvc	r5, [r2], -r1, lsl #4
    51e8:	ba020000 	blt	851f0 <__ROM_SIZE__+0x451f0>
    51ec:	a8000024 	stmdage	r0, {r2, r5}
    51f0:	6a00000e 	bvs	5230 <base_order+0x1c18>
    51f4:	01000006 	tsteq	r0, r6
    51f8:	91035001 	tstls	r3, r1
    51fc:	01017fa0 	smlatbeq	r1, r0, pc, r7	@ <UNPREDICTABLE>
    5200:	00740251 	rsbseq	r0, r4, r1, asr r2
    5204:	02520101 	subseq	r0, r2, #1073741824	@ 0x40000000
    5208:	02000075 	andeq	r0, r0, #117	@ 0x75
    520c:	000024c2 	andeq	r2, r0, r2, asr #9
    5210:	00000b50 	andeq	r0, r0, r0, asr fp
    5214:	00000686 	andeq	r0, r0, r6, lsl #13
    5218:	03500101 	cmpeq	r0, #1073741824	@ 0x40000000
    521c:	017fb891 			@ <UNDEFINED> instruction: 0x017fb891
    5220:	91035101 	tstls	r3, r1, lsl #2
    5224:	02007fa0 	andeq	r7, r0, #160, 30	@ 0x280
    5228:	000024cc 	andeq	r2, r0, ip, asr #9
    522c:	00000d26 	andeq	r0, r0, r6, lsr #26
    5230:	000006a8 	andeq	r0, r0, r8, lsr #13
    5234:	03500101 	cmpeq	r0, #1073741824	@ 0x40000000
    5238:	017fb891 			@ <UNDEFINED> instruction: 0x017fb891
    523c:	91035101 	tstls	r3, r1, lsl #2
    5240:	01017fb8 			@ <UNDEFINED> instruction: 0x01017fb8
    5244:	007d0252 	rsbseq	r0, sp, r2, asr r2
    5248:	24d60200 	ldrbcs	r0, [r6], #512	@ 0x200
    524c:	0d260000 	stceq	0, cr0, [r6, #-0]
    5250:	06ca0000 	strbeq	r0, [sl], r0
    5254:	01010000 	mrseq	r0, (UNDEF: 1)
    5258:	50910250 	addspl	r0, r1, r0, asr r2
    525c:	03510101 	cmpeq	r1, #1073741824	@ 0x40000000
    5260:	017fb891 			@ <UNDEFINED> instruction: 0x017fb891
    5264:	91035201 	tstls	r3, r1, lsl #4
    5268:	02007fb8 	andeq	r7, r0, #184, 30	@ 0x2e0
    526c:	000024e0 	andeq	r2, r0, r0, ror #9
    5270:	00000ea8 	andeq	r0, r0, r8, lsr #29
    5274:	000006eb 	andeq	r0, r0, fp, ror #13
    5278:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    527c:	01015091 	swpeq	r5, r1, [r1]	@ <UNPREDICTABLE>
    5280:	50910251 	addspl	r0, r1, r1, asr r2
    5284:	03520101 	cmpeq	r2, #1073741824	@ 0x40000000
    5288:	007fb891 			@ <UNDEFINED> instruction: 0x007fb891
    528c:	0024ea02 	eoreq	lr, r4, r2, lsl #20
    5290:	000ea800 	andeq	sl, lr, r0, lsl #16
    5294:	00070c00 	andeq	r0, r7, r0, lsl #24
    5298:	50010100 	andpl	r0, r1, r0, lsl #2
    529c:	01509102 	cmpeq	r0, r2, lsl #2
    52a0:	91025101 	tstls	r2, r1, lsl #2
    52a4:	52010150 	andpl	r0, r1, #80, 2
    52a8:	7fa09103 	svcvc	0x00a09103
    52ac:	24f00200 	ldrbtcs	r0, [r0], #512	@ 0x200
    52b0:	0e860000 	cdpeq	0, 8, cr0, cr6, cr0, {0}
    52b4:	07200000 	streq	r0, [r0, -r0]!
    52b8:	01010000 	mrseq	r0, (UNDEF: 1)
    52bc:	50910250 	addspl	r0, r1, r0, asr r2
    52c0:	24fa0200 	ldrbtcs	r0, [sl], #512	@ 0x200
    52c4:	0ea80000 	cdpeq	0, 10, cr0, cr8, cr0, {0}
    52c8:	07400000 	strbeq	r0, [r0, -r0]
    52cc:	01010000 	mrseq	r0, (UNDEF: 1)
    52d0:	00740250 	rsbseq	r0, r4, r0, asr r2
    52d4:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    52d8:	01010074 	tsteq	r1, r4, ror r0
    52dc:	50910252 	addspl	r0, r1, r2, asr r2
    52e0:	25040200 	strcs	r0, [r4, #-512]	@ 0xfffffe00
    52e4:	0d260000 	stceq	0, cr0, [r6, #-0]
    52e8:	07610000 	strbeq	r0, [r1, -r0]!
    52ec:	01010000 	mrseq	r0, (UNDEF: 1)
    52f0:	007d0250 	rsbseq	r0, sp, r0, asr r2
    52f4:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    52f8:	01010074 	tsteq	r1, r4, ror r0
    52fc:	b8910352 	ldmlt	r1, {r1, r4, r6, r8, r9}
    5300:	0e02007f 	mcreq	0, 0, r0, cr2, cr15, {3}
    5304:	a8000025 	stmdage	r0, {r0, r2, r5}
    5308:	8100000e 	tsthi	r0, lr
    530c:	01000007 	tsteq	r0, r7
    5310:	7d025001 	stcvc	0, cr5, [r2, #-4]
    5314:	51010100 	mrspl	r0, (UNDEF: 17)
    5318:	01007d02 	tsteq	r0, r2, lsl #26
    531c:	91025201 	tstls	r2, r1, lsl #4
    5320:	18020050 	stmdane	r2, {r4, r6}
    5324:	a8000025 	stmdage	r0, {r0, r2, r5}
    5328:	a100000e 	tstge	r0, lr
    532c:	01000007 	tsteq	r0, r7
    5330:	77025001 	strvc	r5, [r2, -r1]
    5334:	51010100 	mrspl	r0, (UNDEF: 17)
    5338:	01007702 	tsteq	r0, r2, lsl #14
    533c:	7d025201 	sfmvc	f5, 4, [r2, #-4]
    5340:	20040000 	andcs	r0, r4, r0
    5344:	9b000025 	blls	53e0 <base_order+0x1dc8>
    5348:	01000011 	tsteq	r0, r1, lsl r0
    534c:	74025001 	strvc	r5, [r2], #-1
    5350:	51010100 	mrspl	r0, (UNDEF: 17)
    5354:	00509102 	subseq	r9, r0, r2, lsl #2
    5358:	24620200 	strbtcs	r0, [r2], #-512	@ 0xfffffe00
    535c:	09fa0000 	ldmibeq	sl!, {}^	@ <UNPREDICTABLE>
    5360:	07d20000 	ldrbeq	r0, [r2, r0]
    5364:	01010000 	mrseq	r0, (UNDEF: 1)
    5368:	00750250 	rsbseq	r0, r5, r0, asr r2
    536c:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    5370:	02000076 	andeq	r0, r0, #118	@ 0x76
    5374:	0000246c 	andeq	r2, r0, ip, ror #8
    5378:	000009fa 	strdeq	r0, [r0], -sl
    537c:	000007ec 	andeq	r0, r0, ip, ror #15
    5380:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    5384:	01010074 	tsteq	r1, r4, ror r0
    5388:	00770251 	rsbseq	r0, r7, r1, asr r2
    538c:	24760200 	ldrbtcs	r0, [r6], #-512	@ 0xfffffe00
    5390:	10c40000 	sbcne	r0, r4, r0
    5394:	08060000 	stmdaeq	r6, {}	@ <UNPREDICTABLE>
    5398:	01010000 	mrseq	r0, (UNDEF: 1)
    539c:	00740250 	rsbseq	r0, r4, r0, asr r2
    53a0:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    53a4:	02000075 	andeq	r0, r0, #117	@ 0x75
    53a8:	00002480 	andeq	r2, r0, r0, lsl #9
    53ac:	000010c4 	andeq	r1, r0, r4, asr #1
    53b0:	00000820 	andeq	r0, r0, r0, lsr #16
    53b4:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    53b8:	01010077 	tsteq	r1, r7, ror r0
    53bc:	00760251 	rsbseq	r0, r6, r1, asr r2
    53c0:	248a0200 	strcs	r0, [sl], #512	@ 0x200
    53c4:	08770000 	ldmdaeq	r7!, {}^	@ <UNPREDICTABLE>
    53c8:	083a0000 	ldmdaeq	sl!, {}	@ <UNPREDICTABLE>
    53cc:	01010000 	mrseq	r0, (UNDEF: 1)
    53d0:	00740250 	rsbseq	r0, r4, r0, asr r2
    53d4:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    53d8:	02000077 	andeq	r0, r0, #119	@ 0x77
    53dc:	00002498 	muleq	r0, r8, r4
    53e0:	00000abc 			@ <UNDEFINED> instruction: 0x00000abc
    53e4:	00000860 	andeq	r0, r0, r0, ror #16
    53e8:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    53ec:	01010074 	tsteq	r1, r4, ror r0
    53f0:	00770251 	rsbseq	r0, r7, r1, asr r2
    53f4:	02520101 	subseq	r0, r2, #1073741824	@ 0x40000000
    53f8:	01010075 	tsteq	r1, r5, ror r0
    53fc:	00760253 	rsbseq	r0, r6, r3, asr r2
    5400:	24a40400 	strtcs	r0, [r4], #1024	@ 0x400
    5404:	0a5d0000 	beq	174540c <__ROM_SIZE__+0x170540c>
    5408:	01010000 	mrseq	r0, (UNDEF: 1)
    540c:	00740250 	rsbseq	r0, r4, r0, asr r2
    5410:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    5414:	00000077 	andeq	r0, r0, r7, ror r0
    5418:	000ced07 	andeq	lr, ip, r7, lsl #26
    541c:	e0022700 	and	r2, r2, r0, lsl #14
    5420:	6e000023 	cdpvs	0, 0, cr0, cr0, cr3, {1}
    5424:	01000000 	mrseq	r0, (UNDEF: 0)
    5428:	0009fa9c 	muleq	r9, ip, sl
    542c:	00780300 	rsbseq	r0, r8, r0, lsl #6
    5430:	7f270227 	svcvc	0x00270227
    5434:	a2000005 	andge	r0, r0, #5
    5438:	9e00001d 	mcrls	0, 0, r0, cr0, cr13, {0}
    543c:	0300001d 	movweq	r0, #29
    5440:	02270079 	eoreq	r0, r7, #121	@ 0x79
    5444:	00057f34 	andeq	r7, r5, r4, lsr pc
    5448:	001db500 	andseq	fp, sp, r0, lsl #10
    544c:	001db100 	andseq	fp, sp, r0, lsl #2
    5450:	23f81000 	mvnscs	r1, #0
    5454:	00540000 	subseq	r0, r4, r0
    5458:	09d50000 	ldmibeq	r5, {}^	@ <UNPREDICTABLE>
    545c:	6c060000 	stcvs	0, cr0, [r6], {-0}
    5460:	0f023000 	svceq	0x00023000
    5464:	000000af 	andeq	r0, r0, pc, lsr #1
    5468:	02589102 	subseq	r9, r8, #-2147483648	@ 0x80000000
    546c:	00002400 	andeq	r2, r0, r0, lsl #8
    5470:	00000b50 	andeq	r0, r0, r0, asr fp
    5474:	000008e4 	andeq	r0, r0, r4, ror #17
    5478:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    547c:	0101007d 	tsteq	r1, sp, ror r0
    5480:	00740251 	rsbseq	r0, r4, r1, asr r2
    5484:	240a0200 	strcs	r0, [sl], #-512	@ 0xfffffe00
    5488:	0d260000 	stceq	0, cr0, [r6, #-0]
    548c:	09040000 	stmdbeq	r4, {}	@ <UNPREDICTABLE>
    5490:	01010000 	mrseq	r0, (UNDEF: 1)
    5494:	007d0250 	rsbseq	r0, sp, r0, asr r2
    5498:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    549c:	0101007d 	tsteq	r1, sp, ror r0
    54a0:	00750252 	rsbseq	r0, r5, r2, asr r2
    54a4:	24140200 	ldrcs	r0, [r4], #-512	@ 0xfffffe00
    54a8:	0ea80000 	cdpeq	0, 10, cr0, cr8, cr0, {0}
    54ac:	09240000 	stmdbeq	r4!, {}	@ <UNPREDICTABLE>
    54b0:	01010000 	mrseq	r0, (UNDEF: 1)
    54b4:	007d0250 	rsbseq	r0, sp, r0, asr r2
    54b8:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    54bc:	0101007d 	tsteq	r1, sp, ror r0
    54c0:	00740252 	rsbseq	r0, r4, r2, asr r2
    54c4:	241e0200 	ldrcs	r0, [lr], #-512	@ 0xfffffe00
    54c8:	0d260000 	stceq	0, cr0, [r6, #-0]
    54cc:	09440000 	stmdbeq	r4, {}^	@ <UNPREDICTABLE>
    54d0:	01010000 	mrseq	r0, (UNDEF: 1)
    54d4:	00750250 	rsbseq	r0, r5, r0, asr r2
    54d8:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    54dc:	01010074 	tsteq	r1, r4, ror r0
    54e0:	00740252 	rsbseq	r0, r4, r2, asr r2
    54e4:	24280200 	strtcs	r0, [r8], #-512	@ 0xfffffe00
    54e8:	0d260000 	stceq	0, cr0, [r6, #-0]
    54ec:	09640000 	stmdbeq	r4!, {}^	@ <UNPREDICTABLE>
    54f0:	01010000 	mrseq	r0, (UNDEF: 1)
    54f4:	00740250 	rsbseq	r0, r4, r0, asr r2
    54f8:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    54fc:	0101007d 	tsteq	r1, sp, ror r0
    5500:	007d0252 	rsbseq	r0, sp, r2, asr r2
    5504:	242e0200 	strtcs	r0, [lr], #-512	@ 0xfffffe00
    5508:	0e860000 	cdpeq	0, 8, cr0, cr6, cr0, {0}
    550c:	09780000 	ldmdbeq	r8!, {}^	@ <UNPREDICTABLE>
    5510:	01010000 	mrseq	r0, (UNDEF: 1)
    5514:	007d0250 	rsbseq	r0, sp, r0, asr r2
    5518:	24380200 	ldrtcs	r0, [r8], #-512	@ 0xfffffe00
    551c:	0ea80000 	cdpeq	0, 10, cr0, cr8, cr0, {0}
    5520:	09980000 	ldmibeq	r8, {}	@ <UNPREDICTABLE>
    5524:	01010000 	mrseq	r0, (UNDEF: 1)
    5528:	00740250 	rsbseq	r0, r4, r0, asr r2
    552c:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    5530:	01010074 	tsteq	r1, r4, ror r0
    5534:	007d0252 	rsbseq	r0, sp, r2, asr r2
    5538:	24420200 	strbcs	r0, [r2], #-512	@ 0xfffffe00
    553c:	0d260000 	stceq	0, cr0, [r6, #-0]
    5540:	09b80000 	ldmibeq	r8!, {}	@ <UNPREDICTABLE>
    5544:	01010000 	mrseq	r0, (UNDEF: 1)
    5548:	007d0250 	rsbseq	r0, sp, r0, asr r2
    554c:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    5550:	0101007d 	tsteq	r1, sp, ror r0
    5554:	00740252 	rsbseq	r0, r4, r2, asr r2
    5558:	244c0400 	strbcs	r0, [ip], #-1024	@ 0xfffffc00
    555c:	0ea80000 	cdpeq	0, 10, cr0, cr8, cr0, {0}
    5560:	01010000 	mrseq	r0, (UNDEF: 1)
    5564:	00750250 	rsbseq	r0, r5, r0, asr r2
    5568:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    556c:	01010075 	tsteq	r1, r5, ror r0
    5570:	007d0252 	rsbseq	r0, sp, r2, asr r2
    5574:	ec020000 	stc	0, cr0, [r2], {-0}
    5578:	56000023 	strpl	r0, [r0], -r3, lsr #32
    557c:	e9000010 	stmdb	r0, {r4}
    5580:	01000009 	tsteq	r0, r9
    5584:	74025001 	strvc	r5, [r2], #-1
    5588:	f4040000 	vst4.8	{d0-d3}, [r4], r0
    558c:	94000023 	strls	r0, [r0], #-35	@ 0xffffffdd
    5590:	01000010 	tsteq	r0, r0, lsl r0
    5594:	75025001 	strvc	r5, [r2, #-1]
    5598:	0d000000 	stceq	0, cr0, [r0, #-0]
    559c:	00000dbf 			@ <UNDEFINED> instruction: 0x00000dbf
    55a0:	00800220 	addeq	r0, r0, r0, lsr #4
    55a4:	23ca0000 	biccs	r0, sl, #0
    55a8:	00160000 	andseq	r0, r6, r0
    55ac:	9c010000 	stcls	0, cr0, [r1], {-0}
    55b0:	00000a5d 	andeq	r0, r0, sp, asr sl
    55b4:	20007803 	andcs	r7, r0, r3, lsl #16
    55b8:	04412d02 	strbeq	r2, [r1], #-3330	@ 0xfffff2fe
    55bc:	1dc80000 	stclne	0, cr0, [r8]
    55c0:	1dc40000 	stclne	0, cr0, [r4]
    55c4:	79030000 	stmdbvc	r3, {}	@ <UNPREDICTABLE>
    55c8:	40022000 	andmi	r2, r2, r0
    55cc:	00000441 	andeq	r0, r0, r1, asr #8
    55d0:	00001dde 	ldrdeq	r1, [r0], -lr
    55d4:	00001dda 	ldrdeq	r1, [r0], -sl
    55d8:	0023d202 	eoreq	sp, r3, r2, lsl #4
    55dc:	00105600 	andseq	r5, r0, r0, lsl #12
    55e0:	000a4c00 	andeq	r4, sl, r0, lsl #24
    55e4:	50010100 	andpl	r0, r1, r0, lsl #2
    55e8:	5001a303 	andpl	sl, r1, r3, lsl #6
    55ec:	23da0400 	bicscs	r0, sl, #0, 8
    55f0:	10560000 	subsne	r0, r6, r0
    55f4:	01010000 	mrseq	r0, (UNDEF: 1)
    55f8:	00740250 	rsbseq	r0, r4, r0, asr r2
    55fc:	b2070000 	andlt	r0, r7, #0
    5600:	1a00000c 	bne	5638 <base_order+0x2020>
    5604:	0023ba02 	eoreq	fp, r3, r2, lsl #20
    5608:	00001000 	andeq	r1, r0, r0
    560c:	bc9c0100 	ldflts	f0, [ip], {0}
    5610:	0300000a 	movweq	r0, #10
    5614:	021a0078 	andseq	r0, sl, #120	@ 0x78
    5618:	00057f29 	andeq	r7, r5, r9, lsr #30
    561c:	001df100 	andseq	pc, sp, r0, lsl #2
    5620:	001ded00 	andseq	lr, sp, r0, lsl #26
    5624:	00790300 	rsbseq	r0, r9, r0, lsl #6
    5628:	7f36021a 	svcvc	0x0036021a
    562c:	07000005 	streq	r0, [r0, -r5]
    5630:	0300001e 	movweq	r0, #30
    5634:	0200001e 	andeq	r0, r0, #30
    5638:	000023c2 	andeq	r2, r0, r2, asr #7
    563c:	00001094 	muleq	r0, r4, r0
    5640:	00000aab 	andeq	r0, r0, fp, lsr #21
    5644:	03500101 	cmpeq	r0, #1073741824	@ 0x40000000
    5648:	005001a3 	subseq	r0, r0, r3, lsr #3
    564c:	0023c804 	eoreq	ip, r3, r4, lsl #16
    5650:	00109400 	andseq	r9, r0, r0, lsl #8
    5654:	50010100 	andpl	r0, r1, r0, lsl #2
    5658:	00007402 	andeq	r7, r0, r2, lsl #8
    565c:	0e2e0700 	cdpeq	7, 2, cr0, cr14, cr0, {0}
    5660:	02140000 	andseq	r0, r4, #0
    5664:	000023a4 	andeq	r2, r0, r4, lsr #7
    5668:	00000016 	andeq	r0, r0, r6, lsl r0
    566c:	0b509c01 	bleq	142c678 <__ROM_SIZE__+0x13ec678>
    5670:	78030000 	stmdavc	r3, {}	@ <UNPREDICTABLE>
    5674:	02140031 	andseq	r0, r4, #49	@ 0x31
    5678:	00057f25 	andeq	r7, r5, r5, lsr #30
    567c:	001e1a00 	andseq	r1, lr, r0, lsl #20
    5680:	001e1600 	andseq	r1, lr, r0, lsl #12
    5684:	31790300 	cmncc	r9, r0, lsl #6
    5688:	33021400 	movwcc	r1, #9216	@ 0x2400
    568c:	0000057f 	andeq	r0, r0, pc, ror r5
    5690:	00001e30 	andeq	r1, r0, r0, lsr lr
    5694:	00001e2c 	andeq	r1, r0, ip, lsr #28
    5698:	00327803 	eorseq	r7, r2, r3, lsl #16
    569c:	41470214 	cmpmi	r7, r4, lsl r2
    56a0:	43000004 	movwmi	r0, #4
    56a4:	3f00001e 	svccc	0x0000001e
    56a8:	0300001e 	movweq	r0, #30
    56ac:	14003279 	strne	r3, [r0], #-633	@ 0xfffffd87
    56b0:	04415b02 	strbeq	r5, [r1], #-2818	@ 0xfffff4fe
    56b4:	1e590000 	cdpne	0, 5, cr0, cr9, cr0, {0}
    56b8:	1e550000 	cdpne	0, 5, cr0, cr5, cr0, {0}
    56bc:	b0020000 	andlt	r0, r2, r0
    56c0:	9b000023 	blls	5754 <base_order+0x213c>
    56c4:	39000011 	stmdbcc	r0, {r0, r4}
    56c8:	0100000b 	tsteq	r0, fp
    56cc:	a3035001 	movwge	r5, #12289	@ 0x3001
    56d0:	01015001 	tsteq	r1, r1
    56d4:	01a30351 			@ <UNDEFINED> instruction: 0x01a30351
    56d8:	b8040052 	stmdalt	r4, {r1, r4, r6}
    56dc:	9b000023 	blls	5770 <base_order+0x2158>
    56e0:	01000011 	tsteq	r0, r1, lsl r0
    56e4:	74025001 	strvc	r5, [r2], #-1
    56e8:	51010100 	mrspl	r0, (UNDEF: 17)
    56ec:	00007502 	andeq	r7, r0, r2, lsl #10
    56f0:	0d300700 	ldceq	7, cr0, [r0, #-0]
    56f4:	01e60000 	mvneq	r0, r0
    56f8:	00002320 	andeq	r2, r0, r0, lsr #6
    56fc:	00000084 	andeq	r0, r0, r4, lsl #1
    5700:	0d269c01 	stceq	12, cr9, [r6, #-4]!
    5704:	7a030000 	bvc	c570c <__ROM_SIZE__+0x8570c>
    5708:	2401e600 	strcs	lr, [r1], #-1536	@ 0xfffffa00
    570c:	0000057f 	andeq	r0, r0, pc, ror r5
    5710:	00001e6e 	andeq	r1, r0, lr, ror #28
    5714:	00001e68 	andeq	r1, r0, r8, ror #28
    5718:	e6007803 	str	r7, [r0], -r3, lsl #16
    571c:	04413701 	strbeq	r3, [r1], #-1793	@ 0xfffff8ff
    5720:	1e8b0000 	cdpne	0, 8, cr0, cr11, cr0, {0}
    5724:	1e870000 	cdpne	0, 8, cr0, cr7, cr0, {0}
    5728:	75060000 	strvc	r0, [r6, #-0]
    572c:	0d01e800 	stceq	8, cr14, [r1, #-0]
    5730:	000000af 	andeq	r0, r0, pc, lsr #1
    5734:	06509102 	ldrbeq	r9, [r0], -r2, lsl #2
    5738:	01e80076 	mvneq	r0, r6, ror r0
    573c:	0000af10 	andeq	sl, r0, r0, lsl pc
    5740:	b8910300 	ldmlt	r1, {r8, r9}
    5744:	0067067f 	rsbeq	r0, r7, pc, ror r6
    5748:	af1301e8 	svcge	0x001301e8
    574c:	03000000 	movweq	r0, #0
    5750:	067fa091 			@ <UNDEFINED> instruction: 0x067fa091
    5754:	01e80068 	mvneq	r0, r8, rrx
    5758:	0000af16 	andeq	sl, r0, r6, lsl pc
    575c:	88910300 	ldmhi	r1, {r8, r9}
    5760:	0069057f 	rsbeq	r0, r9, pc, ror r5
    5764:	800701e9 	andhi	r0, r7, r9, ror #3
    5768:	a3000000 	movwge	r0, #0
    576c:	9d00001e 	stcls	0, cr0, [r0, #-120]	@ 0xffffff88
    5770:	0200001e 	andeq	r0, r0, #30
    5774:	0000232c 	andeq	r2, r0, ip, lsr #6
    5778:	0000119b 	muleq	r0, fp, r1
    577c:	00000bed 	andeq	r0, r0, sp, ror #23
    5780:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    5784:	01015091 	swpeq	r5, r1, [r1]	@ <UNPREDICTABLE>
    5788:	01a30351 			@ <UNDEFINED> instruction: 0x01a30351
    578c:	34020051 	strcc	r0, [r2], #-81	@ 0xffffffaf
    5790:	9b000023 	blls	5824 <base_order+0x220c>
    5794:	0b000011 	bleq	57e0 <base_order+0x21c8>
    5798:	0100000c 	tsteq	r0, ip
    579c:	91035001 	tstls	r3, r1
    57a0:	01017fb8 			@ <UNDEFINED> instruction: 0x01017fb8
    57a4:	b8030551 	stmdalt	r3, {r0, r4, r6, r8, sl}
    57a8:	00000035 	andeq	r0, r0, r5, lsr r0
    57ac:	00233a02 	eoreq	r3, r3, r2, lsl #20
    57b0:	00109400 	andseq	r9, r0, r0, lsl #8
    57b4:	000c2000 	andeq	r2, ip, r0
    57b8:	50010100 	andpl	r0, r1, r0, lsl #2
    57bc:	7fa09103 	svcvc	0x00a09103
    57c0:	23400200 	movtcs	r0, #512	@ 0x200
    57c4:	0f320000 	svceq	0x00320000
    57c8:	0c340000 	ldceq	0, cr0, [r4], #-0
    57cc:	01010000 	mrseq	r0, (UNDEF: 1)
    57d0:	00770250 	rsbseq	r0, r7, r0, asr r2
    57d4:	234c0200 	movtcs	r0, #49664	@ 0xc200
    57d8:	0f660000 	svceq	0x00660000
    57dc:	0c550000 	mraeq	r0, r5, acc0
    57e0:	01010000 	mrseq	r0, (UNDEF: 1)
    57e4:	007d0250 	rsbseq	r0, sp, r0, asr r2
    57e8:	03510101 	cmpeq	r1, #1073741824	@ 0x40000000
    57ec:	017fb891 			@ <UNDEFINED> instruction: 0x017fb891
    57f0:	76025201 	strvc	r5, [r2], -r1, lsl #4
    57f4:	56020000 	strpl	r0, [r2], -r0
    57f8:	a8000023 	stmdage	r0, {r0, r1, r5}
    57fc:	7500000e 	strvc	r0, [r0, #-14]
    5800:	0100000c 	tsteq	r0, ip
    5804:	91025001 	tstls	r2, r1
    5808:	51010150 	tstpl	r1, r0, asr r1
    580c:	01509102 	cmpeq	r0, r2, lsl #2
    5810:	7d025201 	sfmvc	f5, 4, [r2, #-4]
    5814:	60020000 	andvs	r0, r2, r0
    5818:	66000023 	strvs	r0, [r0], -r3, lsr #32
    581c:	9600000f 	strls	r0, [r0], -pc
    5820:	0100000c 	tsteq	r0, ip
    5824:	7d025001 	stcvc	0, cr5, [r2, #-4]
    5828:	51010100 	mrspl	r0, (UNDEF: 17)
    582c:	7fa09103 	svcvc	0x00a09103
    5830:	02520101 	subseq	r0, r2, #1073741824	@ 0x40000000
    5834:	02000076 	andeq	r0, r0, #118	@ 0x76
    5838:	0000236a 	andeq	r2, r0, sl, ror #6
    583c:	00000ea8 	andeq	r0, r0, r8, lsr #29
    5840:	00000cb6 			@ <UNDEFINED> instruction: 0x00000cb6
    5844:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    5848:	01010077 	tsteq	r1, r7, ror r0
    584c:	00770251 	rsbseq	r0, r7, r1, asr r2
    5850:	02520101 	subseq	r0, r2, #1073741824	@ 0x40000000
    5854:	0200007d 	andeq	r0, r0, #125	@ 0x7d
    5858:	00002370 	andeq	r2, r0, r0, ror r3
    585c:	00000ef4 	strdeq	r0, [r0], -r4
    5860:	00000cca 	andeq	r0, r0, sl, asr #25
    5864:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    5868:	02005091 	andeq	r5, r0, #145	@ 0x91
    586c:	00002378 	andeq	r2, r0, r8, ror r3
    5870:	00000ffe 	strdeq	r0, [r0], -lr
    5874:	00000cde 	ldrdeq	r0, [r0], -lr
    5878:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    587c:	02005091 	andeq	r5, r0, #145	@ 0x91
    5880:	00002380 	andeq	r2, r0, r0, lsl #7
    5884:	00000ffe 	strdeq	r0, [r0], -lr
    5888:	00000cf3 	strdeq	r0, [r0], -r3
    588c:	03500101 	cmpeq	r0, #1073741824	@ 0x40000000
    5890:	007fb891 			@ <UNDEFINED> instruction: 0x007fb891
    5894:	00238e02 	eoreq	r8, r3, r2, lsl #28
    5898:	00110b00 	andseq	r0, r1, r0, lsl #22
    589c:	000d0e00 	andeq	r0, sp, r0, lsl #28
    58a0:	50010100 	andpl	r0, r1, r0, lsl #2
    58a4:	01509102 	cmpeq	r0, r2, lsl #2
    58a8:	91035101 	tstls	r3, r1, lsl #2
    58ac:	04007fb8 	streq	r7, [r0], #-4024	@ 0xfffff048
    58b0:	00002396 	muleq	r0, r6, r3
    58b4:	0000110b 	andeq	r1, r0, fp, lsl #2
    58b8:	03500101 	cmpeq	r0, #1073741824	@ 0x40000000
    58bc:	017fa091 			@ <UNDEFINED> instruction: 0x017fa091
    58c0:	77025101 	strvc	r5, [r2, -r1, lsl #2]
    58c4:	07000000 	streq	r0, [r0, -r0]
    58c8:	00000df5 	strdeq	r0, [r0], -r5
    58cc:	22aa01b0 	adccs	r0, sl, #176, 2	@ 0x2c
    58d0:	00760000 	rsbseq	r0, r6, r0
    58d4:	9c010000 	stcls	0, cr0, [r1], {-0}
    58d8:	00000e86 	andeq	r0, r0, r6, lsl #29
    58dc:	b0007a03 	andlt	r7, r0, r3, lsl #20
    58e0:	057f2401 	ldrbeq	r2, [pc, #-1025]!	@ 54e7 <base_order+0x1ecf>
    58e4:	1ec40000 	cdpne	0, 12, cr0, cr4, cr0, {0}
    58e8:	1ebe0000 	cdpne	0, 11, cr0, cr14, cr0, {0}
    58ec:	78030000 	stmdavc	r3, {}	@ <UNPREDICTABLE>
    58f0:	3701b000 	strcc	fp, [r1, -r0]
    58f4:	00000441 	andeq	r0, r0, r1, asr #8
    58f8:	00001ee7 	andeq	r1, r0, r7, ror #29
    58fc:	00001edd 	ldrdeq	r1, [r0], -sp
    5900:	b0007903 	andlt	r7, r0, r3, lsl #18
    5904:	04414a01 	strbeq	r4, [r1], #-2561	@ 0xfffff5ff
    5908:	1f170000 	svcne	0x00170000
    590c:	1f110000 	svcne	0x00110000
    5910:	69050000 	stmdbvs	r5, {}	@ <UNPREDICTABLE>
    5914:	0701b200 	streq	fp, [r1, -r0, lsl #4]
    5918:	00000080 	andeq	r0, r0, r0, lsl #1
    591c:	00001f32 	andeq	r1, r0, r2, lsr pc
    5920:	00001f30 	andeq	r1, r0, r0, lsr pc
    5924:	706d7406 	rsbvc	r7, sp, r6, lsl #8
    5928:	0d01b300 	stceq	3, cr11, [r1, #-0]
    592c:	000000af 	andeq	r0, r0, pc, lsr #1
    5930:	02589102 	subseq	r9, r8, #-2147483648	@ 0x80000000
    5934:	000022ba 			@ <UNDEFINED> instruction: 0x000022ba
    5938:	0000119b 	muleq	r0, fp, r1
    593c:	00000dac 	andeq	r0, r0, ip, lsr #27
    5940:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    5944:	0101007d 	tsteq	r1, sp, ror r0
    5948:	00740251 	rsbseq	r0, r4, r1, asr r2
    594c:	22c20200 	sbccs	r0, r2, #0, 4
    5950:	12090000 	andne	r0, r9, #0
    5954:	0dc50000 	stcleq	0, cr0, [r5]
    5958:	01010000 	mrseq	r0, (UNDEF: 1)
    595c:	00750250 	rsbseq	r0, r5, r0, asr r2
    5960:	01510101 	cmpeq	r1, r1, lsl #2
    5964:	cc020030 	stcgt	0, cr0, [r2], {48}	@ 0x30
    5968:	9b000022 	blls	59f8 <base_order+0x23e0>
    596c:	df000011 	svcle	0x00000011
    5970:	0100000d 	tsteq	r0, sp
    5974:	76025001 	strvc	r5, [r2], -r1
    5978:	51010100 	mrspl	r0, (UNDEF: 17)
    597c:	00007402 	andeq	r7, r0, r2, lsl #8
    5980:	0022d602 	eoreq	sp, r2, r2, lsl #12
    5984:	00109400 	andseq	r9, r0, r0, lsl #8
    5988:	000df300 	andeq	pc, sp, r0, lsl #6
    598c:	50010100 	andpl	r0, r1, r0, lsl #2
    5990:	00007602 	andeq	r7, r0, r2, lsl #12
    5994:	0022e202 	eoreq	lr, r2, r2, lsl #4
    5998:	000ea800 	andeq	sl, lr, r0, lsl #16
    599c:	000e1600 	andeq	r1, lr, r0, lsl #12
    59a0:	50010100 	andpl	r0, r1, r0, lsl #2
    59a4:	01007d02 	tsteq	r0, r2, lsl #26
    59a8:	7d025101 	stfvcs	f5, [r2, #-4]
    59ac:	52010100 	andpl	r0, r1, #0, 2
    59b0:	35b80305 	ldrcc	r0, [r8, #773]!	@ 0x305
    59b4:	02000000 	andeq	r0, r0, #0
    59b8:	000022f4 	strdeq	r2, [r0], -r4
    59bc:	00000f66 	andeq	r0, r0, r6, ror #30
    59c0:	00000e35 	andeq	r0, r0, r5, lsr lr
    59c4:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    59c8:	0101007d 	tsteq	r1, sp, ror r0
    59cc:	007d0251 	rsbseq	r0, sp, r1, asr r2
    59d0:	01520101 	cmpeq	r2, r1, lsl #2
    59d4:	fc020031 	stc2	0, cr0, [r2], {49}	@ 0x31
    59d8:	09000022 	stmdbeq	r0, {r1, r5}
    59dc:	4f000012 	svcmi	0x00000012
    59e0:	0100000e 	tsteq	r0, lr
    59e4:	7d025001 	stcvc	0, cr5, [r2, #-4]
    59e8:	51010100 	mrspl	r0, (UNDEF: 17)
    59ec:	00a30802 	adceq	r0, r3, r2, lsl #16
    59f0:	00230802 	eoreq	r0, r3, r2, lsl #16
    59f4:	00120900 	andseq	r0, r2, r0, lsl #18
    59f8:	000e6900 	andeq	r6, lr, r0, lsl #18
    59fc:	50010100 	andpl	r0, r1, r0, lsl #2
    5a00:	01007502 	tsteq	r0, r2, lsl #10
    5a04:	74025101 	strvc	r5, [r2], #-257	@ 0xfffffeff
    5a08:	16040000 	strne	r0, [r4], -r0
    5a0c:	a8000023 	stmdage	r0, {r0, r1, r5}
    5a10:	0100000e 	tsteq	r0, lr
    5a14:	76025001 	strvc	r5, [r2], -r1
    5a18:	51010100 	mrspl	r0, (UNDEF: 17)
    5a1c:	01007602 	tsteq	r0, r2, lsl #12
    5a20:	7d025201 	sfmvc	f5, 4, [r2, #-4]
    5a24:	07000000 	streq	r0, [r0, -r0]
    5a28:	00000cfd 	strdeq	r0, [r0], -sp
    5a2c:	22a001a9 	adccs	r0, r0, #1073741866	@ 0x4000002a
    5a30:	000a0000 	andeq	r0, sl, r0
    5a34:	9c010000 	stcls	0, cr0, [r1], {-0}
    5a38:	00000ea8 	andeq	r0, r0, r8, lsr #29
    5a3c:	a900780a 	stmdbge	r0, {r1, r3, fp, ip, sp, lr}
    5a40:	057f2401 	ldrbeq	r2, [pc, #-1025]!	@ 5647 <base_order+0x202f>
    5a44:	50010000 	andpl	r0, r1, r0
    5a48:	0db20700 	ldceq	7, cr0, [r2]
    5a4c:	019f0000 	orrseq	r0, pc, r0
    5a50:	0000227e 	andeq	r2, r0, lr, ror r2
    5a54:	00000022 	andeq	r0, r0, r2, lsr #32
    5a58:	0ef49c01 	cdpeq	12, 15, cr9, cr4, cr1, {0}
    5a5c:	7a0a0000 	bvc	285a64 <__ROM_SIZE__+0x245a64>
    5a60:	24019f00 	strcs	r9, [r1], #-3840	@ 0xfffff100
    5a64:	0000057f 	andeq	r0, r0, pc, ror r5
    5a68:	780a5001 	stmdavc	sl, {r0, ip, lr}
    5a6c:	37019f00 	strcc	r9, [r1, -r0, lsl #30]
    5a70:	00000441 	andeq	r0, r0, r1, asr #8
    5a74:	790a5101 	stmdbvc	sl, {r0, r8, ip, lr}
    5a78:	4a019f00 	bmi	6d680 <__ROM_SIZE__+0x2d680>
    5a7c:	00000441 	andeq	r0, r0, r1, asr #8
    5a80:	69055201 	stmdbvs	r5, {r0, r9, ip, lr}
    5a84:	0701a100 	streq	sl, [r1, -r0, lsl #2]
    5a88:	00000080 	andeq	r0, r0, r0, lsl #1
    5a8c:	00001f3e 	andeq	r1, r0, lr, lsr pc
    5a90:	00001f3a 	andeq	r1, r0, sl, lsr pc
    5a94:	0da20d00 	stceq	13, cr0, [r2]
    5a98:	01770000 	cmneq	r7, r0
    5a9c:	00000080 	andeq	r0, r0, r0, lsl #1
    5aa0:	0000225c 	andeq	r2, r0, ip, asr r2
    5aa4:	00000022 	andeq	r0, r0, r2, lsr #32
    5aa8:	0f329c01 	svceq	0x00329c01
    5aac:	78030000 	stmdavc	r3, {}	@ <UNPREDICTABLE>
    5ab0:	2c017700 	stccs	7, cr7, [r1], {-0}
    5ab4:	00000441 	andeq	r0, r0, r1, asr #8
    5ab8:	00001f56 	andeq	r1, r0, r6, asr pc
    5abc:	00001f4e 	andeq	r1, r0, lr, asr #30
    5ac0:	7f006905 	svcvc	0x00006905
    5ac4:	00800701 	addeq	r0, r0, r1, lsl #14
    5ac8:	1f7b0000 	svcne	0x007b0000
    5acc:	1f790000 	svcne	0x00790000
    5ad0:	07000000 	streq	r0, [r0, -r0]
    5ad4:	00000e1d 	andeq	r0, r0, sp, lsl lr
    5ad8:	22480169 	subcs	r0, r8, #1073741850	@ 0x4000001a
    5adc:	00140000 	andseq	r0, r4, r0
    5ae0:	9c010000 	stcls	0, cr0, [r1], {-0}
    5ae4:	00000f66 	andeq	r0, r0, r6, ror #30
    5ae8:	6900780a 	stmdbvs	r0, {r1, r3, fp, ip, sp, lr}
    5aec:	057f2801 	ldrbeq	r2, [pc, #-2049]!	@ 52f3 <base_order+0x1cdb>
    5af0:	50010000 	andpl	r0, r1, r0
    5af4:	6e006905 	vmlavs.f16	s12, s0, s10	@ <UNPREDICTABLE>
    5af8:	00800701 	addeq	r0, r0, r1, lsl #14
    5afc:	1f870000 	svcne	0x00870000
    5b00:	1f830000 	svcne	0x00830000
    5b04:	07000000 	streq	r0, [r0, -r0]
    5b08:	00000d64 	andeq	r0, r0, r4, ror #26
    5b0c:	21d4013f 	bicscs	r0, r4, pc, lsr r1
    5b10:	00740000 	rsbseq	r0, r4, r0
    5b14:	9c010000 	stcls	0, cr0, [r1], {-0}
    5b18:	00000ffe 	strdeq	r0, [r0], -lr
    5b1c:	3f00780a 	svccc	0x0000780a
    5b20:	057f2401 	ldrbeq	r2, [pc, #-1025]!	@ 5727 <base_order+0x210f>
    5b24:	50010000 	andpl	r0, r1, r0
    5b28:	3f007903 	svccc	0x00007903
    5b2c:	04413601 	strbeq	r3, [r1], #-1537	@ 0xfffff9ff
    5b30:	1f9d0000 	svcne	0x009d0000
    5b34:	1f970000 	svcne	0x00970000
    5b38:	4f090000 	svcmi	0x00090000
    5b3c:	3f00000d 	svccc	0x0000000d
    5b40:	00803d01 	addeq	r3, r0, r1, lsl #26
    5b44:	1fbc0000 	svcne	0x00bc0000
    5b48:	1fb60000 	svcne	0x00b60000
    5b4c:	cf120000 	svcgt	0x00120000
    5b50:	4100000c 	tstmi	r0, ip
    5b54:	00800701 	addeq	r0, r0, r1, lsl #14
    5b58:	1fda0000 	svcne	0x00da0000
    5b5c:	1fd60000 	svcne	0x00d60000
    5b60:	69050000 	stmdbvs	r5, {}	@ <UNPREDICTABLE>
    5b64:	07014400 	streq	r4, [r1, -r0, lsl #8]
    5b68:	00000080 	andeq	r0, r0, r0, lsl #1
    5b6c:	00001fef 	andeq	r1, r0, pc, ror #31
    5b70:	00001fe9 	andeq	r1, r0, r9, ror #31
    5b74:	44006a05 	strmi	r6, [r0], #-2565	@ 0xfffff5fb
    5b78:	00800901 	addeq	r0, r0, r1, lsl #18
    5b7c:	200a0000 	andcs	r0, sl, r0
    5b80:	20060000 	andcs	r0, r6, r0
    5b84:	c7180000 	ldrgt	r0, [r8, -r0]
    5b88:	05000000 	streq	r0, [r0, #-0]
    5b8c:	01580069 	cmpeq	r8, r9, rrx
    5b90:	00008009 	andeq	r8, r0, r9
    5b94:	00201b00 	eoreq	r1, r0, r0, lsl #22
    5b98:	00201900 	eoreq	r1, r0, r0, lsl #18
    5b9c:	0d000000 	stceq	0, cr0, [r0, #-0]
    5ba0:	00000d7d 	andeq	r0, r0, sp, ror sp
    5ba4:	00800124 	addeq	r0, r0, r4, lsr #2
    5ba8:	21aa0000 			@ <UNDEFINED> instruction: 0x21aa0000
    5bac:	002a0000 	eoreq	r0, sl, r0
    5bb0:	9c010000 	stcls	0, cr0, [r1], {-0}
    5bb4:	00001056 	andeq	r1, r0, r6, asr r0
    5bb8:	24007803 	strcs	r7, [r0], #-2051	@ 0xfffff7fd
    5bbc:	04412901 	strbeq	r2, [r1], #-2305	@ 0xfffff6ff
    5bc0:	202b0000 	eorcs	r0, fp, r0
    5bc4:	20230000 	eorcs	r0, r3, r0
    5bc8:	69050000 	stmdbvs	r5, {}	@ <UNPREDICTABLE>
    5bcc:	07012600 	streq	r2, [r1, -r0, lsl #12]
    5bd0:	00000080 	andeq	r0, r0, r0, lsl #1
    5bd4:	0000204e 	andeq	r2, r0, lr, asr #32
    5bd8:	0000204a 	andeq	r2, r0, sl, asr #32
    5bdc:	0000bc18 	andeq	fp, r0, r8, lsl ip
    5be0:	0e511200 	cdpeq	2, 5, cr1, cr1, cr0, {0}
    5be4:	01340000 	teqeq	r4, r0
    5be8:	0000610e 	andeq	r6, r0, lr, lsl #2
    5bec:	00206100 	eoreq	r6, r0, r0, lsl #2
    5bf0:	00205f00 	eoreq	r5, r0, r0, lsl #30
    5bf4:	0d000000 	stceq	0, cr0, [r0, #-0]
    5bf8:	00000d21 	andeq	r0, r0, r1, lsr #26
    5bfc:	00800108 	addeq	r0, r0, r8, lsl #2
    5c00:	21900000 	orrscs	r0, r0, r0
    5c04:	001a0000 	andseq	r0, sl, r0
    5c08:	9c010000 	stcls	0, cr0, [r1], {-0}
    5c0c:	00001094 	muleq	r0, r4, r0
    5c10:	08007803 	stmdaeq	r0, {r0, r1, fp, ip, sp, lr}
    5c14:	04412a01 	strbeq	r2, [r1], #-2561	@ 0xfffff5ff
    5c18:	206d0000 	rsbcs	r0, sp, r0
    5c1c:	20690000 	rsbcs	r0, r9, r0
    5c20:	69050000 	stmdbvs	r5, {}	@ <UNPREDICTABLE>
    5c24:	0c010a00 			@ <UNDEFINED> instruction: 0x0c010a00
    5c28:	00000061 	andeq	r0, r0, r1, rrx
    5c2c:	00002083 	andeq	r2, r0, r3, lsl #1
    5c30:	0000207f 	andeq	r2, r0, pc, ror r0
    5c34:	0de51300 	stcleq	3, cr1, [r5]
    5c38:	7efd0000 	cdpvc	0, 15, cr0, cr13, cr0, {0}
    5c3c:	12000021 	andne	r0, r0, #33	@ 0x21
    5c40:	01000000 	mrseq	r0, (UNDEF: 0)
    5c44:	0010c49c 	mulseq	r0, ip, r4
    5c48:	00780e00 	rsbseq	r0, r8, r0, lsl #28
    5c4c:	057f26fd 	ldrbeq	r2, [pc, #-1789]!	@ 5557 <base_order+0x1f3f>
    5c50:	50010000 	andpl	r0, r1, r0
    5c54:	ff006915 			@ <UNDEFINED> instruction: 0xff006915
    5c58:	00000080 	andeq	r0, r0, r0, lsl #1
    5c5c:	00002097 	muleq	r0, r7, r0
    5c60:	00002093 	muleq	r0, r3, r0
    5c64:	0ce01d00 	stcleq	13, cr1, [r0]
    5c68:	e3010000 	movw	r0, #4096	@ 0x1000
    5c6c:	0000800c 	andeq	r8, r0, ip
    5c70:	00216000 	eoreq	r6, r1, r0
    5c74:	00001e00 	andeq	r1, r0, r0, lsl #28
    5c78:	0b9c0100 	bleq	fe706080 <_STACK_TOP_+0xde6fe084>
    5c7c:	0b000011 	bleq	5cc8 <base_order+0x26b0>
    5c80:	28e30078 	stmiacs	r3!, {r3, r4, r5, r6}^
    5c84:	00000441 	andeq	r0, r0, r1, asr #8
    5c88:	000020af 	andeq	r2, r0, pc, lsr #1
    5c8c:	000020a7 	andeq	r2, r0, r7, lsr #1
    5c90:	e300790e 	movw	r7, #2318	@ 0x90e
    5c94:	0004413a 	andeq	r4, r4, sl, lsr r1
    5c98:	15510100 	ldrbne	r0, [r1, #-256]	@ 0xffffff00
    5c9c:	80e50069 	rschi	r0, r5, r9, rrx
    5ca0:	d1000000 	mrsle	r0, (UNDEF: 0)
    5ca4:	cd000020 	stcgt	0, cr0, [r0, #-128]	@ 0xffffff80
    5ca8:	00000020 	andeq	r0, r0, r0, lsr #32
    5cac:	000dd013 	andeq	sp, sp, r3, lsl r0
    5cb0:	213cd900 	teqcs	ip, r0, lsl #18
    5cb4:	00240000 	eoreq	r0, r4, r0
    5cb8:	9c010000 	stcls	0, cr0, [r1], {-0}
    5cbc:	0000119b 	muleq	r0, fp, r1
    5cc0:	d900780b 	stmdble	r0, {r0, r1, r3, fp, ip, sp, lr}
    5cc4:	00057f22 	andeq	r7, r5, r2, lsr #30
    5cc8:	0020e400 	eoreq	lr, r0, r0, lsl #8
    5ccc:	0020de00 	eoreq	sp, r0, r0, lsl #28
    5cd0:	00790b00 	rsbseq	r0, r9, r0, lsl #22
    5cd4:	057f2ed9 	ldrbeq	r2, [pc, #-3801]!	@ 4e03 <base_order+0x17eb>
    5cd8:	20f80000 	rscscs	r0, r8, r0
    5cdc:	20f40000 	rscscs	r0, r4, r0
    5ce0:	741e0000 	ldrvc	r0, [lr], #-0
    5ce4:	0100706d 	tsteq	r0, sp, rrx
    5ce8:	008e0cdb 	ldrdeq	r0, [lr], fp
    5cec:	91020000 	mrsls	r0, (UNDEF: 2)
    5cf0:	214c0258 	cmpcs	ip, r8, asr r2
    5cf4:	119b0000 	orrsne	r0, fp, r0
    5cf8:	116a0000 	cmnne	sl, r0
    5cfc:	01010000 	mrseq	r0, (UNDEF: 1)
    5d00:	007d0250 	rsbseq	r0, sp, r0, asr r2
    5d04:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    5d08:	02000075 	andeq	r0, r0, #117	@ 0x75
    5d0c:	00002154 	andeq	r2, r0, r4, asr r1
    5d10:	0000119b 	muleq	r0, fp, r1
    5d14:	00001184 	andeq	r1, r0, r4, lsl #3
    5d18:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    5d1c:	01010075 	tsteq	r1, r5, ror r0
    5d20:	00740251 	rsbseq	r0, r4, r1, asr r2
    5d24:	215c0400 	cmpcs	ip, r0, lsl #8
    5d28:	119b0000 	orrsne	r0, fp, r0
    5d2c:	01010000 	mrseq	r0, (UNDEF: 1)
    5d30:	00740250 	rsbseq	r0, r4, r0, asr r2
    5d34:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    5d38:	0000007d 	andeq	r0, r0, sp, ror r0
    5d3c:	000d1513 	andeq	r1, sp, r3, lsl r5
    5d40:	2128d000 			@ <UNDEFINED> instruction: 0x2128d000
    5d44:	00140000 	andseq	r0, r4, r0
    5d48:	9c010000 	stcls	0, cr0, [r1], {-0}
    5d4c:	000011d6 	ldrdeq	r1, [r0], -r6
    5d50:	d000780e 	andle	r7, r0, lr, lsl #16
    5d54:	00057f22 	andeq	r7, r5, r2, lsr #30
    5d58:	0e500100 	rdfeqs	f0, f0, f0
    5d5c:	34d00079 	ldrbcc	r0, [r0], #121	@ 0x79
    5d60:	00000441 	andeq	r0, r0, r1, asr #8
    5d64:	69155101 	ldmdbvs	r5, {r0, r8, ip, lr}
    5d68:	0080d200 	addeq	sp, r0, r0, lsl #4
    5d6c:	21070000 	mrscs	r0, (UNDEF: 7)
    5d70:	21030000 	mrscs	r0, (UNDEF: 3)
    5d74:	13000000 	movwne	r0, #0
    5d78:	00000e8c 	andeq	r0, r0, ip, lsl #29
    5d7c:	00210ecb 	eoreq	r0, r1, fp, asr #29
    5d80:	00001a00 	andeq	r1, r0, r0, lsl #20
    5d84:	099c0100 	ldmibeq	ip, {r8}
    5d88:	0e000012 	mcreq	0, 0, r0, cr0, cr2, {0}
    5d8c:	25cb0078 	strbcs	r0, [fp, #120]	@ 0x78
    5d90:	0000057f 	andeq	r0, r0, pc, ror r5
    5d94:	690b5001 	stmdbvs	fp, {r0, ip, lr}
    5d98:	cb007864 	blgt	23f30 <__RAM_SIZE__+0x1bf30>
    5d9c:	00006d37 	andeq	r6, r0, r7, lsr sp
    5da0:	00211700 	eoreq	r1, r1, r0, lsl #14
    5da4:	00211300 	eoreq	r1, r1, r0, lsl #6
    5da8:	551f0000 	ldrpl	r0, [pc, #-0]	@ 5db0 <base_order+0x2798>
    5dac:	0100000d 	tsteq	r0, sp
    5db0:	00800cc6 	addeq	r0, r0, r6, asr #25
    5db4:	20fc0000 	rscscs	r0, ip, r0
    5db8:	00120000 	andseq	r0, r2, r0
    5dbc:	9c010000 	stcls	0, cr0, [r1], {-0}
    5dc0:	c600780b 	strgt	r7, [r0], -fp, lsl #16
    5dc4:	0004412a 	andeq	r4, r4, sl, lsr #2
    5dc8:	00212900 	eoreq	r2, r1, r0, lsl #18
    5dcc:	00212500 	eoreq	r2, r1, r0, lsl #10
    5dd0:	64690b00 	strbtvs	r0, [r9], #-2816	@ 0xfffff500
    5dd4:	3cc60078 	stclcc	0, cr0, [r6], {120}	@ 0x78
    5dd8:	0000006d 	andeq	r0, r0, sp, rrx
    5ddc:	0000213b 	andeq	r2, r0, fp, lsr r1
    5de0:	00002137 	andeq	r2, r0, r7, lsr r1
    5de4:	01470000 	mrseq	r0, (UNDEF: 71)
    5de8:	00050000 	andeq	r0, r5, r0
    5dec:	1c750401 	cfldrdne	mvd0, [r5], #-4
    5df0:	14050000 	strne	r0, [r5], #-0
    5df4:	1d000000 	stcne	0, cr0, [r0, #-0]
    5df8:	00000e9b 	muleq	r0, fp, lr
    5dfc:	00000177 	andeq	r0, r0, r7, ror r1
    5e00:	0000267c 	andeq	r2, r0, ip, ror r6
    5e04:	0000005c 	andeq	r0, r0, ip, asr r0
    5e08:	0000404e 	andeq	r4, r0, lr, asr #32
    5e0c:	fe060101 	cdp2	1, 0, cr0, cr6, cr1, {0}
    5e10:	01000000 	mrseq	r0, (UNDEF: 0)
    5e14:	01680502 	cmneq	r8, r2, lsl #10
    5e18:	04010000 	streq	r0, [r1], #-0
    5e1c:	00015805 	andeq	r5, r1, r5, lsl #16
    5e20:	05080100 	streq	r0, [r8, #-256]	@ 0xffffff00
    5e24:	00000153 	andeq	r0, r0, r3, asr r1
    5e28:	fc080101 	stc2	1, cr0, [r8], {1}
    5e2c:	01000000 	mrseq	r0, (UNDEF: 0)
    5e30:	010a0702 	tsteq	sl, r2, lsl #14
    5e34:	b1060000 	mrslt	r0, (UNDEF: 6)
    5e38:	02000001 	andeq	r0, r0, #1
    5e3c:	005c1934 	subseq	r1, ip, r4, lsr r9
    5e40:	04010000 	streq	r0, [r1], #-0
    5e44:	00012207 	andeq	r2, r1, r7, lsl #4
    5e48:	07080100 	streq	r0, [r8, -r0, lsl #2]
    5e4c:	0000011d 	andeq	r0, r0, sp, lsl r1
    5e50:	69050407 	stmdbvs	r5, {r0, r1, r2, sl}
    5e54:	0100746e 	tsteq	r0, lr, ror #8
    5e58:	01270704 			@ <UNDEFINED> instruction: 0x01270704
    5e5c:	7a080000 	bvc	205e64 <__ROM_SIZE__+0x1c5e64>
    5e60:	0100000b 	tsteq	r0, fp
    5e64:	00500a1b 	subseq	r0, r0, fp, lsl sl
    5e68:	269a0000 	ldrcs	r0, [sl], r0
    5e6c:	003e0000 	eorseq	r0, lr, r0
    5e70:	9c010000 	stcls	0, cr0, [r1], {-0}
    5e74:	000000e4 	andeq	r0, r0, r4, ror #1
    5e78:	72747303 	rsbsvc	r7, r4, #201326592	@ 0xc000000
    5e7c:	e41b1b00 	ldr	r1, [fp], #-2816	@ 0xfffff500
    5e80:	59000000 	stmdbpl	r0, {}	@ <UNPREDICTABLE>
    5e84:	55000021 	strpl	r0, [r0, #-33]	@ 0xffffffdf
    5e88:	02000021 	andeq	r0, r0, #33	@ 0x21
    5e8c:	00786568 	rsbseq	r6, r8, r8, ror #10
    5e90:	00500c1c 	subseq	r0, r0, ip, lsl ip
    5e94:	216c0000 	cmncs	ip, r0
    5e98:	21640000 	cmncs	r4, r0
    5e9c:	6a090000 	bvs	245ea4 <__ROM_SIZE__+0x205ea4>
    5ea0:	0100000a 	tsteq	r0, sl
    5ea4:	00500c1d 	subseq	r0, r0, sp, lsl ip
    5ea8:	218e0000 	orrcs	r0, lr, r0
    5eac:	21860000 	orrcs	r0, r6, r0
    5eb0:	e5040000 	str	r0, [r4, #-0]
    5eb4:	02000000 	andeq	r0, r0, #0
    5eb8:	111f0069 	tstne	pc, r9, rrx
    5ebc:	00000050 	andeq	r0, r0, r0, asr r0
    5ec0:	000021a8 	andeq	r2, r0, r8, lsr #3
    5ec4:	000021a4 	andeq	r2, r0, r4, lsr #3
    5ec8:	040a0000 	streq	r0, [sl], #-0
    5ecc:	000000f1 	strdeq	r0, [r0], -r1
    5ed0:	05080101 	streq	r0, [r8, #-257]	@ 0xfffffeff
    5ed4:	0b000001 	bleq	5ee0 <base_order+0x28c8>
    5ed8:	000000ea 	andeq	r0, r0, sl, ror #1
    5edc:	000b7f0c 	andeq	r7, fp, ip, lsl #30
    5ee0:	05130100 	ldreq	r0, [r3, #-256]	@ 0xffffff00
    5ee4:	0000006a 	andeq	r0, r0, sl, rrx
    5ee8:	0000267c 	andeq	r2, r0, ip, ror r6
    5eec:	0000001e 	andeq	r0, r0, lr, lsl r0
    5ef0:	73039c01 	movwvc	r9, #15361	@ 0x3c01
    5ef4:	13007274 	movwne	r7, #628	@ 0x274
    5ef8:	0000e416 	andeq	lr, r0, r6, lsl r4
    5efc:	0021b800 	eoreq	fp, r1, r0, lsl #16
    5f00:	0021b400 	eoreq	fp, r1, r0, lsl #8
    5f04:	65720200 	ldrbvs	r0, [r2, #-512]!	@ 0xfffffe00
    5f08:	07140073 			@ <UNDEFINED> instruction: 0x07140073
    5f0c:	0000006a 	andeq	r0, r0, sl, rrx
    5f10:	000021c9 	andeq	r2, r0, r9, asr #3
    5f14:	000021c3 	andeq	r2, r0, r3, asr #3
    5f18:	0000de04 	andeq	sp, r0, r4, lsl #28
    5f1c:	00690200 	rsbeq	r0, r9, r0, lsl #4
    5f20:	006a0c15 	rsbeq	r0, sl, r5, lsl ip
    5f24:	21de0000 	bicscs	r0, lr, r0
    5f28:	21da0000 	bicscs	r0, sl, r0
    5f2c:	00000000 	andeq	r0, r0, r0
    5f30:	00022600 	andeq	r2, r2, r0, lsl #12
    5f34:	01000500 	tsteq	r0, r0, lsl #10
    5f38:	001d3b04 	andseq	r3, sp, r4, lsl #22
    5f3c:	00140c00 	andseq	r0, r4, r0, lsl #24
    5f40:	0c1d0000 	ldceq	0, cr0, [sp], {-0}
    5f44:	7700000f 	strvc	r0, [r0, -pc]
    5f48:	d8000001 	stmdale	r0, {r0}
    5f4c:	ac000026 	stcge	0, cr0, [r0], {38}	@ 0x26
    5f50:	d7000000 	strle	r0, [r0, -r0]
    5f54:	01000041 	tsteq	r0, r1, asr #32
    5f58:	00fe0601 	rscseq	r0, lr, r1, lsl #12
    5f5c:	02010000 	andeq	r0, r1, #0
    5f60:	00016805 	andeq	r6, r1, r5, lsl #16
    5f64:	05040100 	streq	r0, [r4, #-256]	@ 0xffffff00
    5f68:	00000158 	andeq	r0, r0, r8, asr r1
    5f6c:	53050801 	movwpl	r0, #22529	@ 0x5801
    5f70:	02000001 	andeq	r0, r0, #1
    5f74:	00000134 	andeq	r0, r0, r4, lsr r1
    5f78:	53182e02 	tstpl	r8, #2, 28
    5f7c:	0d000000 	stceq	0, cr0, [r0, #-0]
    5f80:	00000042 	andeq	r0, r0, r2, asr #32
    5f84:	fc080101 	stc2	1, cr0, [r8], {1}
    5f88:	01000000 	mrseq	r0, (UNDEF: 0)
    5f8c:	010a0702 	tsteq	sl, r2, lsl #14
    5f90:	b1020000 	mrslt	r0, (UNDEF: 2)
    5f94:	02000001 	andeq	r0, r0, #1
    5f98:	006d1934 	rsbeq	r1, sp, r4, lsr r9
    5f9c:	04010000 	streq	r0, [r1], #-0
    5fa0:	00012207 	andeq	r2, r1, r7, lsl #4
    5fa4:	07080100 	streq	r0, [r8, -r0, lsl #2]
    5fa8:	0000011d 	andeq	r0, r0, sp, lsl r1
    5fac:	6905040e 	stmdbvs	r5, {r1, r2, r3, sl}
    5fb0:	0100746e 	tsteq	r0, lr, ror #8
    5fb4:	01270704 			@ <UNDEFINED> instruction: 0x01270704
    5fb8:	f00f0000 			@ <UNDEFINED> instruction: 0xf00f0000
    5fbc:	0700000e 	streq	r0, [r0, -lr]
    5fc0:	00005301 	andeq	r5, r0, r1, lsl #6
    5fc4:	0e160300 	cdpeq	3, 1, cr0, cr6, cr0, {0}
    5fc8:	000000b4 	strheq	r0, [r0], -r4
    5fcc:	000f4a07 	andeq	r4, pc, r7, lsl #20
    5fd0:	49080000 	stmdbmi	r8, {}	@ <UNPREDICTABLE>
    5fd4:	0100504e 	tsteq	r0, lr, asr #32
    5fd8:	54554f08 	ldrbpl	r4, [r5], #-3848	@ 0xfffff0f8
    5fdc:	67070200 	strvs	r0, [r7, -r0, lsl #4]
    5fe0:	0300000f 	movweq	r0, #15
    5fe4:	0f6f0200 	svceq	0x006f0200
    5fe8:	1b030000 	blne	c5ff0 <__ROM_SIZE__+0x85ff0>
    5fec:	00008903 	andeq	r8, r0, r3, lsl #18
    5ff0:	0ed21000 	cdpeq	0, 13, cr1, cr2, cr0, {0}
    5ff4:	030c0000 	movweq	r0, #49152	@ 0xc000
    5ff8:	00f2101d 	rscseq	r1, r2, sp, lsl r0
    5ffc:	40030000 	andmi	r0, r3, r0
    6000:	1e000008 	cdpne	0, 0, cr0, cr0, cr8, {0}
    6004:	0000f215 	andeq	pc, r0, r5, lsl r2	@ <UNPREDICTABLE>
    6008:	8c030000 	stchi	0, cr0, [r3], {-0}
    600c:	1f000008 	svcne	0x00000008
    6010:	0000610c 	andeq	r6, r0, ip, lsl #2
    6014:	01030400 	tsteq	r3, r0, lsl #8
    6018:	2100000f 	tstcs	r0, pc
    601c:	00007b07 	andeq	r7, r0, r7, lsl #22
    6020:	09000800 	stmdbeq	r0, {fp}
    6024:	0000004e 	andeq	r0, r0, lr, asr #32
    6028:	000ec702 	andeq	ip, lr, r2, lsl #14
    602c:	03220300 			@ <UNDEFINED> instruction: 0x03220300
    6030:	000000c0 	andeq	r0, r0, r0, asr #1
    6034:	00000d02 	andeq	r0, r0, r2, lsl #26
    6038:	17d60400 	ldrbne	r0, [r6, r0, lsl #8]
    603c:	00000082 	andeq	r0, r0, r2, lsl #1
    6040:	9e040801 	cdpls	8, 0, cr0, cr4, cr1, {0}
    6044:	04000001 	streq	r0, [r0], #-1
    6048:	00000f3e 	andeq	r0, r0, lr, lsr pc
    604c:	00f71314 	rscseq	r1, r7, r4, lsl r3
    6050:	03050000 	movweq	r0, #20480	@ 0x5000
    6054:	20000334 	andcs	r0, r0, r4, lsr r3
    6058:	000edb04 	andeq	sp, lr, r4, lsl #22
    605c:	f7201400 			@ <UNDEFINED> instruction: 0xf7201400
    6060:	05000000 	streq	r0, [r0, #-0]
    6064:	00032803 	andeq	r2, r3, r3, lsl #16
    6068:	0ee70420 	cdpeq	4, 14, cr0, cr7, cr0, {1}
    606c:	0f150000 	svceq	0x00150000
    6070:	000000b4 	strheq	r0, [r0], -r4
    6074:	03240305 			@ <UNDEFINED> instruction: 0x03240305
    6078:	12112000 	andsne	r2, r1, #0
    607c:	05000007 	streq	r0, [r0, #-7]
    6080:	01690741 	cmneq	r9, r1, asr #14
    6084:	01690000 	cmneq	r9, r0
    6088:	69050000 	stmdbvs	r5, {}	@ <UNPREDICTABLE>
    608c:	05000001 	streq	r0, [r0, #-1]
    6090:	0000007b 	andeq	r0, r0, fp, ror r0
    6094:	00010305 	andeq	r0, r1, r5, lsl #6
    6098:	04120000 	ldreq	r0, [r2], #-0
    609c:	000ef50a 	andeq	pc, lr, sl, lsl #10
    60a0:	27584800 	ldrbcs	r4, [r8, -r0, lsl #16]
    60a4:	002c0000 	eoreq	r0, ip, r0
    60a8:	9c010000 	stcls	0, cr0, [r1], {-0}
    60ac:	0000018c 	andeq	r0, r0, ip, lsl #3
    60b0:	01006313 	tsteq	r0, r3, lsl r3
    60b4:	018c1748 	orreq	r1, ip, r8, asr #14
    60b8:	50010000 	andpl	r0, r1, r0
    60bc:	08010100 	stmdaeq	r1, {r8}
    60c0:	00000105 	andeq	r0, r0, r5, lsl #2
    60c4:	000f5b14 	andeq	r5, pc, r4, lsl fp	@ <UNPREDICTABLE>
    60c8:	05340100 	ldreq	r0, [r4, #-256]!	@ 0xffffff00
    60cc:	0000007b 	andeq	r0, r0, fp, ror r0
    60d0:	00002718 	andeq	r2, r0, r8, lsl r7
    60d4:	00000040 	andeq	r0, r0, r0, asr #32
    60d8:	01c29c01 	biceq	r9, r2, r1, lsl #24
    60dc:	76150000 	ldrvc	r0, [r5], -r0
    60e0:	01006c61 	tsteq	r0, r1, ror #24
    60e4:	007b073d 	rsbseq	r0, fp, sp, lsr r7
    60e8:	21fa0000 	mvnscs	r0, r0
    60ec:	21f60000 	mvnscs	r0, r0
    60f0:	0a000000 	beq	60f8 <base_order+0x2ae0>
    60f4:	00000f4f 	andeq	r0, r0, pc, asr #30
    60f8:	0026d817 	eoreq	sp, r6, r7, lsl r8
    60fc:	00004000 	andeq	r4, r0, r0
    6100:	249c0100 	ldrcs	r0, [ip], #256	@ 0x100
    6104:	06000002 	streq	r0, [r0], -r2
    6108:	00000840 	andeq	r0, r0, r0, asr #16
    610c:	0002241b 	andeq	r2, r2, fp, lsl r4
    6110:	00220b00 	eoreq	r0, r2, r0, lsl #22
    6114:	00220500 	eoreq	r0, r2, r0, lsl #10
    6118:	088c0600 	stmeq	ip, {r9, sl}
    611c:	612a0000 			@ <UNDEFINED> instruction: 0x612a0000
    6120:	26000000 	strcs	r0, [r0], -r0
    6124:	1e000022 	cdpne	0, 0, cr0, cr0, cr2, {1}
    6128:	06000022 	streq	r0, [r0], -r2, lsr #32
    612c:	00000ef0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
    6130:	0000b437 	andeq	fp, r0, r7, lsr r4
    6134:	00224600 	eoreq	r4, r2, r0, lsl #12
    6138:	00223e00 	eoreq	r3, r2, r0, lsl #28
    613c:	27021600 	strcs	r1, [r2, -r0, lsl #12]
    6140:	01490000 	mrseq	r0, (UNDEF: 73)
    6144:	010b0000 	mrseq	r0, (UNDEF: 11)
    6148:	00750251 	rsbseq	r0, r5, r1, asr r2
    614c:	0352010b 	cmpeq	r2, #-1073741822	@ 0xc0000002
    6150:	005101a3 	subseq	r0, r1, r3, lsr #3
    6154:	00420900 	subeq	r0, r2, r0, lsl #18
    6158:	0a000000 	beq	6160 <base_order+0x2b48>
    615c:	05000002 	streq	r0, [r0, #-2]
    6160:	8d040100 	stfhis	f0, [r4, #-0]
    6164:	0900001e 	stmdbeq	r0, {r1, r2, r3, r4}
    6168:	00000014 	andeq	r0, r0, r4, lsl r0
    616c:	000f9a1d 	andeq	r9, pc, sp, lsl sl	@ <UNPREDICTABLE>
    6170:	00017700 	andeq	r7, r1, r0, lsl #14
    6174:	00278400 	eoreq	r8, r7, r0, lsl #8
    6178:	00006000 	andeq	r6, r0, r0
    617c:	0043e600 	subeq	lr, r3, r0, lsl #12
    6180:	05040a00 	streq	r0, [r4, #-2560]	@ 0xfffff600
    6184:	00746e69 	rsbseq	r6, r4, r9, ror #28
    6188:	00000d0b 	andeq	r0, r0, fp, lsl #26
    618c:	17d60200 	ldrbne	r0, [r6, r0, lsl #4]
    6190:	00000039 	andeq	r0, r0, r9, lsr r0
    6194:	27070402 	strcs	r0, [r7, -r2, lsl #8]
    6198:	02000001 	andeq	r0, r0, #1
    619c:	01530508 	cmpeq	r3, r8, lsl #10
    61a0:	08020000 	stmdaeq	r2, {}	@ <UNPREDICTABLE>
    61a4:	00019e04 	andeq	r9, r1, r4, lsl #28
    61a8:	07120300 	ldreq	r0, [r2, -r0, lsl #6]
    61ac:	07350000 	ldreq	r0, [r5, -r0]!
    61b0:	000000b7 	strheq	r0, [r0], -r7
    61b4:	000027d4 	ldrdeq	r2, [r0], -r4
    61b8:	00000010 	andeq	r0, r0, r0, lsl r0
    61bc:	00b79c01 	adcseq	r9, r7, r1, lsl #24
    61c0:	76010000 	strvc	r0, [r1], -r0
    61c4:	3500000f 	strcc	r0, [r0, #-15]
    61c8:	0000b714 	andeq	fp, r0, r4, lsl r7
    61cc:	00227200 	eoreq	r7, r2, r0, lsl #4
    61d0:	00226e00 	eoreq	r6, r2, r0, lsl #28
    61d4:	61760700 	cmnvs	r6, r0, lsl #14
    61d8:	1e35006c 	cdpne	0, 3, cr0, cr5, cr12, {3}
    61dc:	00000026 	andeq	r0, r0, r6, lsr #32
    61e0:	8c085101 	stfhis	f5, [r8], {1}
    61e4:	35000008 	strcc	r0, [r0, #-8]
    61e8:	00002d2a 	andeq	r2, r0, sl, lsr #26
    61ec:	04520100 	ldrbeq	r0, [r2], #-256	@ 0xffffff00
    61f0:	2d360069 	ldccs	0, cr0, [r6, #-420]!	@ 0xfffffe5c
    61f4:	84000000 	strhi	r0, [r0], #-0
    61f8:	80000022 	andhi	r0, r0, r2, lsr #32
    61fc:	05000022 	streq	r0, [r0, #-34]	@ 0xffffffde
    6200:	00000f87 	andeq	r0, r0, r7, lsl #31
    6204:	0000b937 	andeq	fp, r0, r7, lsr r9
    6208:	00229400 	eoreq	r9, r2, r0, lsl #8
    620c:	00229000 	eoreq	r9, r2, r0
    6210:	040c0000 	streq	r0, [ip], #-0
    6214:	0000be06 	andeq	fp, r0, r6, lsl #28
    6218:	08010200 	stmdaeq	r1, {r9}
    621c:	00000105 	andeq	r0, r0, r5, lsl #2
    6220:	0000be0d 	andeq	fp, r0, sp, lsl #28
    6224:	068a0300 	streq	r0, [sl], r0, lsl #6
    6228:	072b0000 	streq	r0, [fp, -r0]!
    622c:	000000b7 	strheq	r0, [r0], -r7
    6230:	000027be 			@ <UNDEFINED> instruction: 0x000027be
    6234:	00000016 	andeq	r0, r0, r6, lsl r0
    6238:	01459c01 	cmpeq	r5, r1, lsl #24
    623c:	76010000 	strvc	r0, [r1], -r0
    6240:	2b00000f 	blcs	6284 <base_order+0x2c6c>
    6244:	0000b714 	andeq	fp, r0, r4, lsl r7
    6248:	0022a600 	eoreq	sl, r2, r0, lsl #12
    624c:	0022a200 	eoreq	sl, r2, r0, lsl #4
    6250:	72730700 	rsbsvc	r0, r3, #0, 14
    6254:	262b0063 	strtcs	r0, [fp], -r3, rrx
    6258:	00000145 	andeq	r0, r0, r5, asr #2
    625c:	8c085101 	stfhis	f5, [r8], {1}
    6260:	2b000008 	blcs	6288 <base_order+0x2c70>
    6264:	00002d32 	andeq	r2, r0, r2, lsr sp
    6268:	04520100 	ldrbeq	r0, [r2], #-256	@ 0xffffff00
    626c:	2d2c0069 	stccs	0, cr0, [ip, #-420]!	@ 0xfffffe5c
    6270:	b8000000 	stmdalt	r0, {}	@ <UNPREDICTABLE>
    6274:	b4000022 	strlt	r0, [r0], #-34	@ 0xffffffde
    6278:	05000022 	streq	r0, [r0, #-34]	@ 0xffffffde
    627c:	00000f91 	muleq	r0, r1, pc	@ <UNPREDICTABLE>
    6280:	0000b92d 	andeq	fp, r0, sp, lsr #18
    6284:	0022c600 	eoreq	ip, r2, r0, lsl #12
    6288:	0022c400 	eoreq	ip, r2, r0, lsl #8
    628c:	0f870500 	svceq	0x00870500
    6290:	b92e0000 	stmdblt	lr!, {}	@ <UNPREDICTABLE>
    6294:	d0000000 	andle	r0, r0, r0
    6298:	cc000022 	stcgt	0, cr0, [r0], {34}	@ 0x22
    629c:	00000022 	andeq	r0, r0, r2, lsr #32
    62a0:	00014a06 	andeq	r4, r1, r6, lsl #20
    62a4:	7b030e00 	blvc	c9aac <__ROM_SIZE__+0x89aac>
    62a8:	2300000f 	movwcs	r0, #15
    62ac:	0000b907 	andeq	fp, r0, r7, lsl #18
    62b0:	0027aa00 	eoreq	sl, r7, r0, lsl #20
    62b4:	00001400 	andeq	r1, r0, r0, lsl #8
    62b8:	8b9c0100 	blhi	fe7066c0 <_STACK_TOP_+0xde6fe6c4>
    62bc:	01000001 	tsteq	r0, r1
    62c0:	00000f82 	andeq	r0, r0, r2, lsl #31
    62c4:	00b91423 	adcseq	r1, r9, r3, lsr #8
    62c8:	22e40000 	rsccs	r0, r4, #0
    62cc:	22de0000 	sbcscs	r0, lr, #0
    62d0:	f0010000 			@ <UNDEFINED> instruction: 0xf0010000
    62d4:	2300000a 	movwcs	r0, #10
    62d8:	00018b26 	andeq	r8, r1, r6, lsr #22
    62dc:	0022fa00 	eoreq	pc, r2, r0, lsl #20
    62e0:	0022f600 	eoreq	pc, r2, r0, lsl #12
    62e4:	c5060000 	strgt	r0, [r6, #-0]
    62e8:	03000000 	movweq	r0, #0
    62ec:	0000014c 	andeq	r0, r0, ip, asr #2
    62f0:	0026051b 	eoreq	r0, r6, fp, lsl r5
    62f4:	27940000 	ldrcs	r0, [r4, r0]
    62f8:	00160000 	andseq	r0, r6, r0
    62fc:	9c010000 	stcls	0, cr0, [r1], {-0}
    6300:	000001d0 	ldrdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
    6304:	000f8201 	andeq	r8, pc, r1, lsl #4
    6308:	8b181b00 	blhi	60cf10 <__ROM_SIZE__+0x5ccf10>
    630c:	09000001 	stmdbeq	r0, {r0}
    6310:	05000023 	streq	r0, [r0, #-35]	@ 0xffffffdd
    6314:	01000023 	tsteq	r0, r3, lsr #32
    6318:	00000af0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
    631c:	018b2a1b 	orreq	r2, fp, fp, lsl sl
    6320:	23180000 	tstcs	r8, #0
    6324:	23140000 	tstcs	r4, #0
    6328:	0f000000 	svceq	0x00000000
    632c:	000001aa 	andeq	r0, r0, sl, lsr #3
    6330:	2d081301 	stccs	3, cr1, [r8, #-4]
    6334:	84000000 	strhi	r0, [r0], #-0
    6338:	10000027 	andne	r0, r0, r7, lsr #32
    633c:	01000000 	mrseq	r0, (UNDEF: 0)
    6340:	7473109c 	ldrbtvc	r1, [r3], #-156	@ 0xffffff64
    6344:	13010072 	movwne	r0, #4210	@ 0x1072
    6348:	00018b1b 	andeq	r8, r1, fp, lsl fp
    634c:	00232700 	eoreq	r2, r3, r0, lsl #14
    6350:	00232300 	eoreq	r2, r3, r0, lsl #6
    6354:	656c0400 	strbvs	r0, [ip, #-1024]!	@ 0xfffffc00
    6358:	2d14006e 	ldccs	0, cr0, [r4, #-440]	@ 0xfffffe48
    635c:	36000000 	strcc	r0, [r0], -r0
    6360:	32000023 	andcc	r0, r0, #35	@ 0x23
    6364:	00000023 	andeq	r0, r0, r3, lsr #32
	...

Disassembly of section .debug_abbrev:

00000000 <.debug_abbrev>:
       0:	02004901 	andeq	r4, r0, #16384	@ 0x4000
       4:	00187e18 	andseq	r7, r8, r8, lsl lr
       8:	01480200 	mrseq	r0, (UNDEF: 104)
       c:	137f017d 	cmnne	pc, #1073741855	@ 0x4000001f
      10:	00001301 	andeq	r1, r0, r1, lsl #6
      14:	0b002403 	bleq	9028 <__RAM_SIZE__+0x1028>
      18:	030b3e0b 	movweq	r3, #48651	@ 0xbe0b
      1c:	0400000e 	streq	r0, [r0], #-14
      20:	13490005 	movtne	r0, #36869	@ 0x9005
      24:	0f050000 	svceq	0x00050000
      28:	04210b00 	strteq	r0, [r1], #-2816	@ 0xfffff500
      2c:	00001349 	andeq	r1, r0, r9, asr #6
      30:	03000d06 	movweq	r0, #3334	@ 0xd06
      34:	3b0b3a0e 	blcc	2ce874 <__ROM_SIZE__+0x28e874>
      38:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
      3c:	000b3813 	andeq	r3, fp, r3, lsl r8
      40:	012e0700 			@ <UNDEFINED> instruction: 0x012e0700
      44:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
      48:	0b3b0b3a 	bleq	ec2d38 <__ROM_SIZE__+0xe82d38>
      4c:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
      50:	193c1349 	ldmdbne	ip!, {r0, r3, r6, r8, r9, ip}
      54:	00001301 	andeq	r1, r0, r1, lsl #6
      58:	03001608 	movweq	r1, #1544	@ 0x608
      5c:	3b0b3a0e 	blcc	2ce89c <__ROM_SIZE__+0x28e89c>
      60:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
      64:	09000013 	stmdbeq	r0, {r0, r1, r4}
      68:	13490021 	movtne	r0, #36897	@ 0x9021
      6c:	00000b2f 	andeq	r0, r0, pc, lsr #22
      70:	0300340a 	movweq	r3, #1034	@ 0x40a
      74:	01213a08 			@ <UNDEFINED> instruction: 0x01213a08
      78:	0b390b3b 	bleq	e42d6c <__ROM_SIZE__+0xe02d6c>
      7c:	17021349 	strne	r1, [r2, -r9, asr #6]
      80:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
      84:	01480b00 	cmpeq	r8, r0, lsl #22
      88:	137f017d 	cmnne	pc, #1073741855	@ 0x4000001f
      8c:	260c0000 	strcs	r0, [ip], -r0
      90:	00134900 	andseq	r4, r3, r0, lsl #18
      94:	01010d00 	tsteq	r1, r0, lsl #26
      98:	13011349 	movwne	r1, #4937	@ 0x1349
      9c:	050e0000 	streq	r0, [lr, #-0]
      a0:	3a0e0300 	bcc	380ca8 <__ROM_SIZE__+0x340ca8>
      a4:	213b0121 	teqcs	fp, r1, lsr #2
      a8:	490b3906 	stmdbmi	fp, {r1, r2, r8, fp, ip, sp}
      ac:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
      b0:	00001742 	andeq	r1, r0, r2, asr #14
      b4:	11010b0f 	tstne	r1, pc, lsl #22
      b8:	01061201 	tsteq	r6, r1, lsl #4
      bc:	10000013 	andne	r0, r0, r3, lsl r0
      c0:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
      c4:	3b01213a 	blcc	485b4 <__ROM_SIZE__+0x85b4>
      c8:	1921390b 	stmdbne	r1!, {r0, r1, r3, r8, fp, ip, sp}
      cc:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
      d0:	11110000 	tstne	r1, r0
      d4:	130e2501 	movwne	r2, #58625	@ 0xe501
      d8:	1b0e030b 	blne	380d0c <__ROM_SIZE__+0x340d0c>
      dc:	1201110e 	andne	r1, r1, #-2147483645	@ 0x80000003
      e0:	00171006 	andseq	r1, r7, r6
      e4:	00241200 	eoreq	r1, r4, r0, lsl #4
      e8:	0b3e0b0b 	bleq	f82d1c <__ROM_SIZE__+0xf42d1c>
      ec:	00000803 	andeq	r0, r0, r3, lsl #16
      f0:	03011313 	movweq	r1, #4883	@ 0x1313
      f4:	3a050b0e 	bcc	142d34 <__ROM_SIZE__+0x102d34>
      f8:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
      fc:	0013010b 	andseq	r0, r3, fp, lsl #2
     100:	000d1400 	andeq	r1, sp, r0, lsl #8
     104:	0b3a0803 	bleq	e82118 <__ROM_SIZE__+0xe42118>
     108:	0b390b3b 	bleq	e42dfc <__ROM_SIZE__+0xe02dfc>
     10c:	0b381349 	bleq	e04e38 <__ROM_SIZE__+0xdc4e38>
     110:	16150000 	ldrne	r0, [r5], -r0
     114:	3a080300 	bcc	200d1c <__ROM_SIZE__+0x1c0d1c>
     118:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     11c:	0013490b 	andseq	r4, r3, fp, lsl #18
     120:	01151600 	tsteq	r5, r0, lsl #12
     124:	13491927 	movtne	r1, #39207	@ 0x9927
     128:	00001301 	andeq	r1, r0, r1, lsl #6
     12c:	0b011317 	bleq	44d90 <__ROM_SIZE__+0x4d90>
     130:	3b0b3a0b 	blcc	2ce964 <__ROM_SIZE__+0x28e964>
     134:	010b390b 	tsteq	fp, fp, lsl #18
     138:	18000013 	stmdane	r0, {r0, r1, r4}
     13c:	08030034 	stmdaeq	r3, {r2, r4, r5}
     140:	0b3b0b3a 	bleq	ec2e30 <__ROM_SIZE__+0xe82e30>
     144:	13490b39 	movtne	r0, #39737	@ 0x9b39
     148:	193c193f 	ldmdbne	ip!, {r0, r1, r2, r3, r4, r5, r8, fp, ip}
     14c:	34190000 	ldrcc	r0, [r9], #-0
     150:	3a0e0300 	bcc	380d58 <__ROM_SIZE__+0x340d58>
     154:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     158:	3f13490b 	svccc	0x0013490b
     15c:	00180219 	andseq	r0, r8, r9, lsl r2
     160:	012e1a00 			@ <UNDEFINED> instruction: 0x012e1a00
     164:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
     168:	0b3b0b3a 	bleq	ec2e58 <__ROM_SIZE__+0xe82e58>
     16c:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
     170:	1301193c 	movwne	r1, #6460	@ 0x193c
     174:	181b0000 	ldmdane	fp, {}	@ <UNPREDICTABLE>
     178:	1c000000 	stcne	0, cr0, [r0], {-0}
     17c:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
     180:	0b3a0e03 	bleq	e83994 <__ROM_SIZE__+0xe43994>
     184:	0b390b3b 	bleq	e42e78 <__ROM_SIZE__+0xe02e78>
     188:	13491927 	movtne	r1, #39207	@ 0x9927
     18c:	06120111 			@ <UNDEFINED> instruction: 0x06120111
     190:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
     194:	00001301 	andeq	r1, r0, r1, lsl #6
     198:	4901011d 	stmdbmi	r1, {r0, r2, r3, r4, r8}
     19c:	00000013 	andeq	r0, r0, r3, lsl r0
     1a0:	0b002401 	bleq	91ac <__RAM_SIZE__+0x11ac>
     1a4:	030b3e0b 	movweq	r3, #48651	@ 0xbe0b
     1a8:	0200000e 	andeq	r0, r0, #14
     1ac:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
     1b0:	0e030b13 	vmoveq.32	d3[0], r0
     1b4:	01110e1b 	tsteq	r1, fp, lsl lr
     1b8:	17100612 			@ <UNDEFINED> instruction: 0x17100612
     1bc:	16030000 	strne	r0, [r3], -r0
     1c0:	3a0e0300 	bcc	380dc8 <__ROM_SIZE__+0x340dc8>
     1c4:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     1c8:	0013490b 	andseq	r4, r3, fp, lsl #18
     1cc:	00240400 	eoreq	r0, r4, r0, lsl #8
     1d0:	0b3e0b0b 	bleq	f82e04 <__ROM_SIZE__+0xf42e04>
     1d4:	00000803 	andeq	r0, r0, r3, lsl #16
     1d8:	03003405 	movweq	r3, #1029	@ 0x405
     1dc:	3b0b3a0e 	blcc	2cea1c <__ROM_SIZE__+0x28ea1c>
     1e0:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
     1e4:	3c193f13 	ldccc	15, cr3, [r9], {19}
     1e8:	06000019 			@ <UNDEFINED> instruction: 0x06000019
     1ec:	13490101 	movtne	r0, #37121	@ 0x9101
     1f0:	00001301 	andeq	r1, r0, r1, lsl #6
     1f4:	49002107 	stmdbmi	r0, {r0, r1, r2, r8, sp}
     1f8:	000b2f13 	andeq	r2, fp, r3, lsl pc
     1fc:	00340800 	eorseq	r0, r4, r0, lsl #16
     200:	0b3a0e03 	bleq	e83a14 <__ROM_SIZE__+0xe43a14>
     204:	0b390b3b 	bleq	e42ef8 <__ROM_SIZE__+0xe02ef8>
     208:	193f1349 	ldmdbne	pc!, {r0, r3, r6, r8, r9, ip}	@ <UNPREDICTABLE>
     20c:	00001802 	andeq	r1, r0, r2, lsl #16
     210:	3f002e09 	svccc	0x00002e09
     214:	3a0e0319 	bcc	380e80 <__ROM_SIZE__+0x340e80>
     218:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     21c:	3c19270b 	ldccc	7, cr2, [r9], {11}
     220:	0a000019 	beq	28c <vector_table+0x28c>
     224:	193f002e 	ldmdbne	pc!, {r1, r2, r3, r5}	@ <UNPREDICTABLE>
     228:	0b3a0e03 	bleq	e83a3c <__ROM_SIZE__+0xe43a3c>
     22c:	0b390b3b 	bleq	e42f20 <__ROM_SIZE__+0xe02f20>
     230:	01111927 	tsteq	r1, r7, lsr #18
     234:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
     238:	0000197a 	andeq	r1, r0, sl, ror r9
     23c:	01110100 	tsteq	r1, r0, lsl #2
     240:	0b130e25 	bleq	4c3adc <__ROM_SIZE__+0x483adc>
     244:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
     248:	06120111 			@ <UNDEFINED> instruction: 0x06120111
     24c:	00001710 	andeq	r1, r0, r0, lsl r7
     250:	3f002e02 	svccc	0x00002e02
     254:	3a0e0319 	bcc	380ec0 <__ROM_SIZE__+0x340ec0>
     258:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     25c:	1119270b 	tstne	r9, fp, lsl #14
     260:	40061201 	andmi	r1, r6, r1, lsl #4
     264:	00197a18 	andseq	r7, r9, r8, lsl sl
     268:	002e0300 	eoreq	r0, lr, r0, lsl #6
     26c:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
     270:	0b3b0b3a 	bleq	ec2f60 <__ROM_SIZE__+0xe82f60>
     274:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
     278:	01111349 	tsteq	r1, r9, asr #6
     27c:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
     280:	0000197a 	andeq	r1, r0, sl, ror r9
     284:	0b002404 	bleq	929c <__RAM_SIZE__+0x129c>
     288:	030b3e0b 	movweq	r3, #48651	@ 0xbe0b
     28c:	05000008 	streq	r0, [r0, #-8]
     290:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
     294:	0b3a0e03 	bleq	e83aa8 <__ROM_SIZE__+0xe43aa8>
     298:	0b390b3b 	bleq	e42f8c <__ROM_SIZE__+0xe02f8c>
     29c:	01111927 	tsteq	r1, r7, lsr #18
     2a0:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
     2a4:	1301197a 	movwne	r1, #6522	@ 0x197a
     2a8:	05060000 	streq	r0, [r6, #-0]
     2ac:	3a080300 	bcc	200eb4 <__ROM_SIZE__+0x1c0eb4>
     2b0:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     2b4:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
     2b8:	1742b717 	smlaldne	fp, r2, r7, r7
     2bc:	48070000 	stmdami	r7, {}	@ <UNPREDICTABLE>
     2c0:	7f017d01 	svcvc	0x00017d01
     2c4:	08000013 	stmdaeq	r0, {r0, r1, r4}
     2c8:	18020049 	stmdane	r2, {r0, r3, r6}
     2cc:	0000187e 	andeq	r1, r0, lr, ror r8
     2d0:	0b002409 	bleq	92fc <__RAM_SIZE__+0x12fc>
     2d4:	030b3e0b 	movweq	r3, #48651	@ 0xbe0b
     2d8:	0000000e 	andeq	r0, r0, lr
     2dc:	25011101 	strcs	r1, [r1, #-257]	@ 0xfffffeff
     2e0:	030b130e 	movweq	r1, #45838	@ 0xb30e
     2e4:	110e1b0e 	tstne	lr, lr, lsl #22
     2e8:	10061201 	andne	r1, r6, r1, lsl #4
     2ec:	02000017 	andeq	r0, r0, #23
     2f0:	193f002e 	ldmdbne	pc!, {r1, r2, r3, r5}	@ <UNPREDICTABLE>
     2f4:	0b3a0e03 	bleq	e83b08 <__ROM_SIZE__+0xe43b08>
     2f8:	0b390b3b 	bleq	e42fec <__ROM_SIZE__+0xe02fec>
     2fc:	01111927 	tsteq	r1, r7, lsr #18
     300:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
     304:	0000197a 	andeq	r1, r0, sl, ror r9
     308:	3f002e03 	svccc	0x00002e03
     30c:	3a0e0319 	bcc	380f78 <__ROM_SIZE__+0x340f78>
     310:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     314:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
     318:	12011113 	andne	r1, r1, #-1073741820	@ 0xc0000004
     31c:	7a184006 	bvc	61033c <__ROM_SIZE__+0x5d033c>
     320:	04000019 	streq	r0, [r0], #-25	@ 0xffffffe7
     324:	0b0b0024 	bleq	2c03bc <__ROM_SIZE__+0x2803bc>
     328:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
     32c:	2e050000 	cdpcs	0, 0, cr0, cr5, cr0, {0}
     330:	03193f01 	tsteq	r9, #1, 30
     334:	3b0b3a0e 	blcc	2ceb74 <__ROM_SIZE__+0x28eb74>
     338:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
     33c:	12011119 	andne	r1, r1, #1073741830	@ 0x40000006
     340:	7a184006 	bvc	610360 <__ROM_SIZE__+0x5d0360>
     344:	00130119 	andseq	r0, r3, r9, lsl r1
     348:	00050600 	andeq	r0, r5, r0, lsl #12
     34c:	0b3a0803 	bleq	e82360 <__ROM_SIZE__+0xe42360>
     350:	0b390b3b 	bleq	e43044 <__ROM_SIZE__+0xe03044>
     354:	17021349 	strne	r1, [r2, -r9, asr #6]
     358:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
     35c:	01480700 	cmpeq	r8, r0, lsl #14
     360:	137f017d 	cmnne	pc, #1073741855	@ 0x4000001f
     364:	49080000 	stmdbmi	r8, {}	@ <UNPREDICTABLE>
     368:	7e180200 	cdpvc	2, 1, cr0, cr8, cr0, {0}
     36c:	09000018 	stmdbeq	r0, {r3, r4}
     370:	0b0b0024 	bleq	2c0408 <__ROM_SIZE__+0x280408>
     374:	0e030b3e 	vmoveq.16	d3[0], r0
     378:	01000000 	mrseq	r0, (UNDEF: 0)
     37c:	0b0b0024 	bleq	2c0414 <__ROM_SIZE__+0x280414>
     380:	0e030b3e 	vmoveq.16	d3[0], r0
     384:	05020000 	streq	r0, [r2, #-0]
     388:	00134900 	andseq	r4, r3, r0, lsl #18
     38c:	00480300 	subeq	r0, r8, r0, lsl #6
     390:	137f017d 	cmnne	pc, #1073741855	@ 0x4000001f
     394:	2e040000 	cdpcs	0, 0, cr0, cr4, cr0, {0}
     398:	03193f01 	tsteq	r9, #1, 30
     39c:	3b0b3a0e 	blcc	2cebdc <__ROM_SIZE__+0x28ebdc>
     3a0:	0621390b 	strteq	r3, [r1], -fp, lsl #18
     3a4:	193c1927 	ldmdbne	ip!, {r0, r1, r2, r5, r8, fp, ip}
     3a8:	00001301 	andeq	r1, r0, r1, lsl #6
     3ac:	0b000f05 	bleq	3fc8 <base_order+0x9b0>
     3b0:	13490421 	movtne	r0, #37921	@ 0x9421
     3b4:	2e060000 	cdpcs	0, 0, cr0, cr6, cr0, {0}
     3b8:	03193f00 	tsteq	r9, #0, 30
     3bc:	3b0b3a0e 	blcc	2cebfc <__ROM_SIZE__+0x28ebfc>
int car_mesg(int argc, char** argv) {
     3c0:	21392921 	teqcs	r9, r1, lsr #18
     3c4:	49192705 	ldmdbmi	r9, {r0, r2, r8, r9, sl, sp}
    printf("Received a message from the car:");
     3c8:	00193c13 	andseq	r3, r9, r3, lsl ip
     3cc:	002e0700 	eoreq	r0, lr, r0, lsl #14
    for (ctr = 1; ctr < argc; ctr++) {
     3d0:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
        printf(" %s", argv[ctr]);
     3d4:	213b0b3a 	teqcs	fp, sl, lsr fp
     3d8:	0621392f 	strteq	r3, [r1], -pc, lsr #18
    for (ctr = 1; ctr < argc; ctr++) {
     3dc:	193c1927 	ldmdbne	ip!, {r0, r1, r2, r5, r8, fp, ip}
     3e0:	11080000 	mrsne	r0, (UNDEF: 8)
    printf("\n");
     3e4:	130e2501 	movwne	r2, #58625	@ 0xe501
    if (argc > 1) {
     3e8:	1b0e030b 	blne	38101c <__ROM_SIZE__+0x34101c>
}
     3ec:	1201110e 	andne	r1, r1, #-2147483645	@ 0x80000003
     3f0:	00171006 	andseq	r1, r7, r6
        if (strcmp(argv[1], "PING_REPLY") == 0) {
     3f4:	00240900 	eoreq	r0, r4, r0, lsl #18
     3f8:	0b3e0b0b 	bleq	f8302c <__ROM_SIZE__+0xf4302c>
            printf("Got a ping reply.\n");
     3fc:	00000803 	andeq	r0, r0, r3, lsl #16
     400:	2701150a 	strcs	r1, [r1, -sl, lsl #10]
        else if (strcmp(argv[1], "AESB64") == 0) {
     404:	00130119 	andseq	r0, r3, r9, lsl r1
     408:	00150b00 	andseq	r0, r5, r0, lsl #22
     40c:	13491927 	movtne	r1, #39207	@ 0x9927
            if (argc == 3) { 
     410:	2e0c0000 	cdpcs	0, 0, cr0, cr12, cr0, {0}
                printf("Missing AESB64 encoded message\n");
     414:	03193f01 	tsteq	r9, #1, 30
     418:	3b0b3a0e 	blcc	2cec58 <__ROM_SIZE__+0x28ec58>
                len = decode_base64((uint8_t *) argv[2], strlen(argv[2]), decoded);
     41c:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
     420:	12011119 	andne	r1, r1, #1073741830	@ 0x40000006
     424:	7a184006 	bvc	610444 <__ROM_SIZE__+0x5d0444>
     428:	00130119 	andseq	r0, r3, r9, lsl r1
     42c:	002e0d00 	eoreq	r0, lr, r0, lsl #26
                AES_ECB_decrypt(&ctx, decoded);
     430:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
     434:	0b3b0b3a 	bleq	ec3124 <__ROM_SIZE__+0xe83124>
                decoded[len] = '\0';
     438:	01110b39 	tsteq	r1, r9, lsr fp
     43c:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
     440:	0000197a 	andeq	r1, r0, sl, ror r9
                printf("Decoded/decrypted as %s\n", decoded);
     444:	00490100 	subeq	r0, r9, r0, lsl #2
     448:	187e1802 	ldmdane	lr!, {r1, fp, ip}^
     44c:	05020000 	streq	r0, [r2, #-0]
        else if (strcmp(argv[1], "B64") == 0) {
     450:	00134900 	andseq	r4, r3, r0, lsl #18
     454:	00240300 	eoreq	r0, r4, r0, lsl #6
            if (argc == 3) { 
     458:	0b3e0b0b 	bleq	f8308c <__ROM_SIZE__+0xf4308c>
                printf("Missing Base64 encoded message\n");
     45c:	00000e03 	andeq	r0, r0, r3, lsl #28
     460:	7d014804 	stcvc	8, cr4, [r1, #-16]
                printf("Decoding Base64\n");
     464:	01137f01 	tsteq	r3, r1, lsl #30
     468:	05000013 	streq	r0, [r0, #-19]	@ 0xffffffed
                len = decode_base64((uint8_t *) argv[2], strlen(argv[2]), decoded);
     46c:	210b000f 	tstcs	fp, pc
     470:	00134904 	andseq	r4, r3, r4, lsl #18
     474:	000d0600 	andeq	r0, sp, r0, lsl #12
     478:	0b3a0e03 	bleq	e83c8c <__ROM_SIZE__+0xe43c8c>
                decoded[len] = '\0';
     47c:	0b390b3b 	bleq	e43170 <__ROM_SIZE__+0xe03170>
     480:	0b381349 	bleq	e051ac <__ROM_SIZE__+0xdc51ac>
     484:	21070000 	mrscs	r0, (UNDEF: 7)
                printf("Decoded as %s", decoded);
     488:	2f134900 	svccs	0x00134900
     48c:	0800000b 	stmdaeq	r0, {r0, r1, r3}
     490:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
            printf("Didn't know how to handle %s\n", argv[1]);
     494:	0b3a0e03 	bleq	e83ca8 <__ROM_SIZE__+0xe43ca8>
     498:	0b390b3b 	bleq	e4318c <__ROM_SIZE__+0xe0318c>
     49c:	13491927 	movtne	r1, #39207	@ 0x9927
     4a0:	1301193c 	movwne	r1, #6460	@ 0x193c
     4a4:	01090000 	mrseq	r0, (UNDEF: 9)
     4a8:	01134901 	tsteq	r3, r1, lsl #18
     4ac:	0a000013 	beq	500 <ugetc+0x4>
     4b0:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     4b4:	3b01213a 	blcc	489a4 <__ROM_SIZE__+0x89a4>
     4b8:	0d21390b 			@ <UNDEFINED> instruction: 0x0d21390b
     4bc:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
     4c0:	160b0000 	strne	r0, [fp], -r0
     4c4:	3a0e0300 	bcc	3810cc <__ROM_SIZE__+0x3410cc>
     4c8:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     4cc:	0013490b 	andseq	r4, r3, fp, lsl #18
     4d0:	00260c00 	eoreq	r0, r6, r0, lsl #24
     4d4:	00001349 	andeq	r1, r0, r9, asr #6
void uputc(char c) {
     4d8:	3f012e0d 	svccc	0x00012e0d
  while ((UARTFR >> 5) & 1)
     4dc:	3a0e0319 	bcc	381148 <__ROM_SIZE__+0x341148>
     4e0:	0b3b0221 	bleq	ec0d6c <__ROM_SIZE__+0xe80d6c>
  UART_DR = c;
     4e4:	27062139 	smladxcs	r6, r9, r1, r2
  if (c == '\n')
     4e8:	01193c19 	tsteq	r9, r9, lsl ip
}
     4ec:	0e000013 	mcreq	0, 0, r0, cr0, cr3, {0}
    uputc('\r');
     4f0:	00000018 	andeq	r0, r0, r8, lsl r0
}
     4f4:	0300050f 	movweq	r0, #1295	@ 0x50f
     4f8:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
  if (!((UARTFR >> 4) & 1)) return UART_DR;
     4fc:	3907213b 	stmdbcc	r7, {r0, r1, r3, r4, r5, r8, sp}
     500:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
     504:	1742b717 	smlaldne	fp, r2, r7, r7
     508:	11100000 	tstne	r0, r0
  return -1;
     50c:	130e2501 	movwne	r2, #58625	@ 0xe501
}
     510:	1b0e030b 	blne	381144 <__ROM_SIZE__+0x341144>
     514:	1201110e 	andne	r1, r1, #-2147483645	@ 0x80000003
  UARTCTL = 0;
     518:	00171006 	andseq	r1, r7, r6
     51c:	00241100 	eoreq	r1, r4, r0, lsl #2
  UARTIBRD = 8;
     520:	0b3e0b0b 	bleq	f83154 <__ROM_SIZE__+0xf43154>
  UARTFBRD = 44;
     524:	00000803 	andeq	r0, r0, r3, lsl #16
  UARTCC = 0;
     528:	03011312 	movweq	r1, #4882	@ 0x1312
  UARTLCRH = 0x60;
     52c:	3a050b0e 	bcc	14316c <__ROM_SIZE__+0x10316c>
  UARTCTL = 0x301;
     530:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
}
     534:	0013010b 	andseq	r0, r3, fp, lsl #2
     538:	000d1300 	andeq	r1, sp, r0, lsl #6
void u2putc(char c) {
     53c:	0b3a0803 	bleq	e82550 <__ROM_SIZE__+0xe42550>
  while ((UART2FR >> 5) & 1)
     540:	0b390b3b 	bleq	e43234 <__ROM_SIZE__+0xe03234>
     544:	0b381349 	bleq	e05270 <__ROM_SIZE__+0xdc5270>
  UART2_DR = c;
     548:	16140000 	ldrne	r0, [r4], -r0
  if (c == '\n')
     54c:	3a080300 	bcc	201154 <__ROM_SIZE__+0x1c1154>
}
     550:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    u2putc('\r');
     554:	0013490b 	andseq	r4, r3, fp, lsl #18
}
     558:	01151500 	tsteq	r5, r0, lsl #10
     55c:	13491927 	movtne	r1, #39207	@ 0x9927
  if (!((UART2FR >> 4) & 1)) return UART2_DR;
     560:	00001301 	andeq	r1, r0, r1, lsl #6
     564:	0b011316 	bleq	451c4 <__ROM_SIZE__+0x51c4>
     568:	3b0b3a0b 	blcc	2ced9c <__ROM_SIZE__+0x28ed9c>
     56c:	010b390b 	tsteq	fp, fp, lsl #18
  return -1;
     570:	17000013 	smladne	r0, r3, r0, r0
}
     574:	08030034 	stmdaeq	r3, {r2, r4, r5}
     578:	0b3b0b3a 	bleq	ec3268 <__ROM_SIZE__+0xe83268>
  UART2CTL = 0;
     57c:	13490b39 	movtne	r0, #39737	@ 0x9b39
     580:	193c193f 	ldmdbne	ip!, {r0, r1, r2, r3, r4, r5, r8, fp, ip}
  UART2IBRD = 8;
     584:	34180000 	ldrcc	r0, [r8], #-0
  UART2FBRD = 44;
     588:	3a0e0300 	bcc	381190 <__ROM_SIZE__+0x341190>
  UART2CC = 0;
     58c:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
  UART2LCRH = 0x60;
     590:	3f13490b 	svccc	0x0013490b
  UART2CTL = 0x301;
     594:	00180219 	andseq	r0, r8, r9, lsl r2
}
     598:	012e1900 			@ <UNDEFINED> instruction: 0x012e1900
     59c:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
  RCGCUART |= 3;
     5a0:	0b3b0b3a 	bleq	ec3290 <__ROM_SIZE__+0xe83290>
     5a4:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
     5a8:	01111349 	tsteq	r1, r9, asr #6
     5ac:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
  RCGCGPIO |= 3;
     5b0:	1301197a 	movwne	r1, #6522	@ 0x197a
     5b4:	341a0000 	ldrcc	r0, [sl], #-0
     5b8:	3a080300 	bcc	2011c0 <__ROM_SIZE__+0x1c11c0>
  GPIODEN = 0x03;
     5bc:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     5c0:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
  GPIOAFSEL = 0x03;
     5c4:	1742b717 	smlaldne	fp, r2, r7, r7
  GPIOPCTL |= 0x00000011;
     5c8:	481b0000 	ldmdami	fp, {}	@ <UNPREDICTABLE>
     5cc:	7f017d01 	svcvc	0x00017d01
     5d0:	1c000013 	stcne	0, cr0, [r0], {19}
  GPIODEN2 = 0x03;
     5d4:	13490101 	movtne	r0, #37121	@ 0x9101
     5d8:	01000000 	mrseq	r0, (UNDEF: 0)
  GPIOAFSEL2 = 0x03;
     5dc:	0b0b0024 	bleq	2c0674 <__ROM_SIZE__+0x280674>
  GPIOPCTL2 |= 0x00000011;
     5e0:	0e030b3e 	vmoveq.16	d3[0], r0
     5e4:	0f020000 	svceq	0x00020000
     5e8:	04210b00 	strteq	r0, [r1], #-2816	@ 0xfffff500
}
     5ec:	00001349 	andeq	r1, r0, r9, asr #6
     5f0:	49000503 	stmdbmi	r0, {r0, r1, r8, sl}
void platform_init() {
     5f4:	04000013 	streq	r0, [r0], #-19	@ 0xffffffed
    pin_setup();
     5f8:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
    uart_init();
     5fc:	3b02213a 	blcc	88aec <__ROM_SIZE__+0x48aec>
    uart2_init();
     600:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
    set_read_char(ugetc);
     604:	000b3813 	andeq	r3, fp, r3, lsl r8
    set_read_char2(u2getc);
     608:	012e0500 			@ <UNDEFINED> instruction: 0x012e0500
     60c:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
    set_write_char(uputc);
     610:	3b03213a 	blcc	c8b00 <__ROM_SIZE__+0x88b00>
    set_write_char2(u2putc);
     614:	0521390b 	streq	r3, [r1, #-2315]!	@ 0xfffff6f5
     618:	13491927 	movtne	r1, #39207	@ 0x9927
}
     61c:	1301193c 	movwne	r1, #6460	@ 0x193c
     620:	18060000 	stmdane	r6, {}	@ <UNPREDICTABLE>
     624:	07000000 	streq	r0, [r0, -r0]
     628:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
int aes_test(int argc, char** argv) {
     62c:	3b01213a 	blcc	48b1c <__ROM_SIZE__+0x8b1c>
    uint8_t text[17] = "0123456789abcdef";
     630:	0b390521 	bleq	e41abc <__ROM_SIZE__+0xe01abc>
     634:	17021349 	strne	r1, [r2, -r9, asr #6]
     638:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
     63c:	00490800 	subeq	r0, r9, r0, lsl #16
     640:	187e1802 	ldmdane	lr!, {r1, fp, ip}^
    printf("Plaintext is %s\n", text);
     644:	11090000 	mrsne	r0, (UNDEF: 9)
     648:	130e2501 	movwne	r2, #58625	@ 0xe501
    AES_ECB_encrypt(&ctx, text);
     64c:	1b0e030b 	blne	381280 <__ROM_SIZE__+0x341280>
     650:	1201110e 	andne	r1, r1, #-2147483645	@ 0x80000003
    len = encode_base64(text, 16, b64text);
     654:	00171006 	andseq	r1, r7, r6
     658:	00240a00 	eoreq	r0, r4, r0, lsl #20
     65c:	0b3e0b0b 	bleq	f83290 <__ROM_SIZE__+0xf43290>
    b64text[len] = '\0';
     660:	00000803 	andeq	r0, r0, r3, lsl #16
     664:	0300160b 	movweq	r1, #1547	@ 0x60b
     668:	3b0b3a08 	blcc	2cee90 <__ROM_SIZE__+0x28ee90>
    printf("Encrypted/encoded is %s\n", b64text);
     66c:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
     670:	0c000013 	stceq	0, cr0, [r0], {19}
    printf2("FOB_MESG AESB64 %s\n", b64text);
     674:	19270115 	stmdbne	r7!, {r0, r2, r4, r8}
     678:	13011349 	movwne	r1, #4937	@ 0x1349
    printf("Test the mesg handler with CAR_MESG AESB64 %s\n", b64text);
     67c:	260d0000 	strcs	r0, [sp], -r0
     680:	00134900 	andseq	r4, r3, r0, lsl #18
    len = decode_base64(b64text, len, decoded);
     684:	01130e00 	tsteq	r3, r0, lsl #28
     688:	0b3a0b0b 	bleq	e832bc <__ROM_SIZE__+0xe432bc>
     68c:	0b390b3b 	bleq	e43380 <__ROM_SIZE__+0xe03380>
    AES_ECB_decrypt(&ctx, decoded);
     690:	00001301 	andeq	r1, r0, r1, lsl #6
     694:	0300160f 	movweq	r1, #1551	@ 0x60f
    decoded[len] = '\0';
     698:	3b0b3a0e 	blcc	2ceed8 <__ROM_SIZE__+0x28eed8>
     69c:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
     6a0:	10000013 	andne	r0, r0, r3, lsl r0
    printf("After encrypting->encoding->decoding->decrypting we recover %s\n", decoded);
     6a4:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     6a8:	0b3b0b3a 	bleq	ec3398 <__ROM_SIZE__+0xe83398>
}
     6ac:	13490b39 	movtne	r0, #39737	@ 0x9b39
     6b0:	1802193f 	stmdane	r2, {r0, r1, r2, r3, r4, r5, r8, fp, ip}
     6b4:	2e110000 	cdpcs	0, 1, cr0, cr1, cr0, {0}
     6b8:	03193f01 	tsteq	r9, #1, 30
     6bc:	3b0b3a0e 	blcc	2ceefc <__ROM_SIZE__+0x28eefc>
     6c0:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
     6c4:	11134919 	tstne	r3, r9, lsl r9
     6c8:	40061201 	andmi	r1, r6, r1, lsl #4
     6cc:	00197a18 	andseq	r7, r9, r8, lsl sl
int pair(int argc, char** argv) {
     6d0:	01481200 	mrseq	r1, (UNDEF: 104)
    printf("Sending a pair request.\n");
     6d4:	137f017d 	cmnne	pc, #1073741855	@ 0x4000001f
    printf2("FOB_MESG PAIR\n");
     6d8:	00001301 	andeq	r1, r0, r1, lsl #6
     6dc:	7d014813 	stcvc	8, cr4, [r1, #-76]	@ 0xffffffb4
}
     6e0:	00137f01 	andseq	r7, r3, r1, lsl #30
     6e4:	49010000 	stmdbmi	r1, {}	@ <UNPREDICTABLE>
     6e8:	7e180200 	cdpvc	2, 1, cr0, cr8, cr0, {0}
int encode64(int argc, char** argv) {
     6ec:	02000018 	andeq	r0, r0, #24
    if (argc > 1) {
     6f0:	0b0b0024 	bleq	2c0788 <__ROM_SIZE__+0x280788>
     6f4:	0e030b3e 	vmoveq.16	d3[0], r0
        len = strlen(argv[1]);
     6f8:	05030000 	streq	r0, [r3, #-0]
     6fc:	00134900 	andseq	r4, r3, r0, lsl #18
        if (len < MAXARRAYLEN) {
     700:	000f0400 	andeq	r0, pc, r0, lsl #8
            len = encode_base64((uint8_t *) argv[1], len, encoded);
     704:	4904210b 	stmdbmi	r4, {r0, r1, r3, r8, sp}
     708:	05000013 	streq	r0, [r0, #-19]	@ 0xffffffed
            printf("Encoded %s as %s with %d characters\n", argv[1], encoded, len);
     70c:	017d0148 	cmneq	sp, r8, asr #2
     710:	0000137f 	andeq	r1, r0, pc, ror r3
     714:	3f012e06 	svccc	0x00012e06
            printf("String exceeds max length of %d characters", MAXARRAYLEN);
     718:	3a0e0319 	bcc	381384 <__ROM_SIZE__+0x341384>
     71c:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     720:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
        printf("Usage is 'encode64 string'\n");
     724:	01193c13 	tsteq	r9, r3, lsl ip
}
     728:	07000013 	smladeq	r0, r3, r0, r0
     72c:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
     730:	3b01213a 	blcc	48c20 <__ROM_SIZE__+0x8c20>
     734:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
     738:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
int decode64(int argc, char** argv) {
     73c:	00001742 	andeq	r1, r0, r2, asr #14
    if (argc > 1) {
     740:	03001608 	movweq	r1, #1544	@ 0x608
     744:	3b0b3a0e 	blcc	2cef84 <__ROM_SIZE__+0x28ef84>
        int len = strlen(argv[1]);
     748:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
     74c:	09000013 	stmdbeq	r0, {r0, r1, r4}
        if (len < MAXBASE64LEN) {
     750:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
                len = decode_base64((uint8_t *) argv[1], len, plaintext);
     754:	3b04213a 	blcc	108c44 <__ROM_SIZE__+0xc8c44>
     758:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
                plaintext[len] = '\0';
     75c:	000b3813 	andeq	r3, fp, r3, lsl r8
     760:	010b0a00 	tsteq	fp, r0, lsl #20
     764:	06120111 			@ <UNDEFINED> instruction: 0x06120111
                printf("Decoded %s as: %s\n", argv[1], plaintext);
     768:	00001301 	andeq	r1, r0, r1, lsl #6
     76c:	7d01480b 	stcvc	8, cr4, [r1, #-44]	@ 0xffffffd4
     770:	01137f01 	tsteq	r3, r1, lsl #30
            printf("String exceeds max base64 string length of %d characters", MAXBASE64LEN);
     774:	0c000013 	stceq	0, cr0, [r0], {19}
     778:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     77c:	3b01213a 	blcc	48c6c <__ROM_SIZE__+0x8c6c>
        printf("Usage is 'decode64 string'\n");
     780:	0121390b 			@ <UNDEFINED> instruction: 0x0121390b
}
     784:	193f1349 	ldmdbne	pc!, {r0, r3, r6, r8, r9, ip}	@ <UNPREDICTABLE>
     788:	00001802 	andeq	r1, r0, r2, lsl #16
     78c:	3f012e0d 	svccc	0x00012e0d
     790:	3a0e0319 	bcc	3813fc <__ROM_SIZE__+0x3413fc>
     794:	0b3b0121 	bleq	ec0c20 <__ROM_SIZE__+0xe80c20>
int ecdh_test(int argc, char** argv) {
     798:	27052139 	smladxcs	r5, r9, r1, r2
    uint8_t b64privkey2[32] = "wP/uwP/uwP/uwP/uwP/uwP/uwP/uwP/u";
     79c:	11134919 	tstne	r3, r9, lsl r9
     7a0:	40061201 	andmi	r1, r6, r1, lsl #4
     7a4:	01197a18 	tsteq	r9, r8, lsl sl
     7a8:	0e000013 	mcreq	0, 0, r0, cr0, cr3, {0}
     7ac:	08030034 	stmdaeq	r3, {r2, r4, r5}
    printf("Testing the ecdh key exchange\n");
     7b0:	3b01213a 	blcc	48ca0 <__ROM_SIZE__+0x8ca0>
     7b4:	0d21390b 			@ <UNDEFINED> instruction: 0x0d21390b
    decode_base64(ECDH_privkey_b64, 32, ECDH_privkey);
     7b8:	17021349 	strne	r1, [r2, -r9, asr #6]
     7bc:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
     7c0:	00340f00 	eorseq	r0, r4, r0, lsl #30
    decode_base64(b64privkey2, 32, privkey2);
     7c4:	213a0e03 	teqcs	sl, r3, lsl #28
     7c8:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
    ecdh_generate_keys(ECDH_pubkey, ECDH_privkey);
     7cc:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
     7d0:	10000018 	andne	r0, r0, r8, lsl r0
     7d4:	017d0048 	cmneq	sp, r8, asr #32
    ecdh_generate_keys(pubkey2, privkey2);
     7d8:	0000137f 	andeq	r1, r0, pc, ror r3
     7dc:	49002111 	stmdbmi	r0, {r0, r4, r8, sp}
    ecdh_shared_secret(ECDH_privkey, pubkey2, ECDH_shared);
     7e0:	000b2f13 	andeq	r2, fp, r3, lsl pc
     7e4:	01111200 	tsteq	r1, r0, lsl #4
     7e8:	0b130e25 	bleq	4c4084 <__ROM_SIZE__+0x484084>
    ecdh_shared_secret(privkey2, ECDH_pubkey, sharedsecret2);
     7ec:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
     7f0:	06120111 			@ <UNDEFINED> instruction: 0x06120111
    sha256_init(&shactx);
     7f4:	00001710 	andeq	r1, r0, r0, lsl r7
     7f8:	0b002413 	bleq	984c <__RAM_SIZE__+0x184c>
	sha256_update(&shactx, ECDH_shared, ECC_PUB_KEY_SIZE);
     7fc:	030b3e0b 	movweq	r3, #48651	@ 0xbe0b
     800:	14000008 	strne	r0, [r0], #-8
	sha256_final(&shactx, ECDH_AESkey);
     804:	08030016 	stmdaeq	r3, {r1, r2, r4}
     808:	0b3b0b3a 	bleq	ec34f8 <__ROM_SIZE__+0xe834f8>
     80c:	13490b39 	movtne	r0, #39737	@ 0x9b39
    len = encode_base64(ECDH_AESkey, AES_KEYLEN, b64test);
     810:	15150000 	ldrne	r0, [r5, #-0]
     814:	49192701 	ldmdbmi	r9, {r0, r8, r9, sl, sp}
    b64test[len] = '\0';
     818:	00130113 	andseq	r0, r3, r3, lsl r1
     81c:	00261600 	eoreq	r1, r6, r0, lsl #12
     820:	00001349 	andeq	r1, r0, r9, asr #6
     824:	0b011317 	bleq	45488 <__ROM_SIZE__+0x5488>
    printf("First shared key is %s\n", b64test);
     828:	3b0b3a0b 	blcc	2cf05c <__ROM_SIZE__+0x28f05c>
     82c:	010b390b 	tsteq	fp, fp, lsl #18
    sha256_init(&shactx);
     830:	18000013 	stmdane	r0, {r0, r1, r4}
    sha256_update(&shactx, sharedsecret2, ECC_PUB_KEY_SIZE);
     834:	00000018 	andeq	r0, r0, r8, lsl r0
     838:	49010119 	stmdbmi	r1, {r0, r3, r4, r8}
     83c:	00130113 	andseq	r0, r3, r3, lsl r1
	sha256_final(&shactx, keytest);
     840:	01011a00 	tsteq	r1, r0, lsl #20
     844:	00001349 	andeq	r1, r0, r9, asr #6
    len = encode_base64(keytest, AES_KEYLEN, b64test);
     848:	00490100 	subeq	r0, r9, r0, lsl #2
     84c:	187e1802 	ldmdane	lr!, {r1, fp, ip}^
    b64test[len] = '\0';
     850:	05020000 	streq	r0, [r2, #-0]
     854:	00134900 	andseq	r4, r3, r0, lsl #18
     858:	01480300 	mrseq	r0, (UNDEF: 120)
    printf("Should be same as %s\n", b64test);
     85c:	137f017d 	cmnne	pc, #1073741855	@ 0x4000001f
     860:	00001301 	andeq	r1, r0, r1, lsl #6
    printf("Switching fob AES key to new value. Try AES tests now.\n");
     864:	0b002404 	bleq	987c <__RAM_SIZE__+0x187c>
     868:	030b3e0b 	movweq	r3, #48651	@ 0xbe0b
    AES_init_ctx(&ctx, ECDH_AESkey);
     86c:	0500000e 	streq	r0, [r0, #-14]
     870:	210b000f 	tstcs	fp, pc
}
     874:	00134904 	andseq	r4, r3, r4, lsl #18
     878:	000d0600 	andeq	r0, sp, r0, lsl #12
     87c:	0b3a0e03 	bleq	e84090 <__ROM_SIZE__+0xe44090>
     880:	0b390b3b 	bleq	e43574 <__ROM_SIZE__+0xe03574>
     884:	0b381349 	bleq	e055b0 <__ROM_SIZE__+0xdc55b0>
     888:	01070000 	mrseq	r0, (UNDEF: 7)
     88c:	01134901 	tsteq	r3, r1, lsl #18
     890:	08000013 	stmdaeq	r0, {r0, r1, r4}
     894:	13490021 	movtne	r0, #36897	@ 0x9021
     898:	00000b2f 	andeq	r0, r0, pc, lsr #22
     89c:	03003409 	movweq	r3, #1033	@ 0x409
     8a0:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
int send_ping(int argc, char** argv) {
     8a4:	0b390b3b 	bleq	e43598 <__ROM_SIZE__+0xe03598>
    printf("Pinging the car.\n");
     8a8:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
    printf2("FOB_MESG PING\n");
     8ac:	160a0000 	strne	r0, [sl], -r0
     8b0:	3a0e0300 	bcc	3814b8 <__ROM_SIZE__+0x3414b8>
}
     8b4:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     8b8:	0013490b 	andseq	r4, r3, fp, lsl #18
     8bc:	00340b00 	eorseq	r0, r4, r0, lsl #22
int sha256_test(int argc, char** argv) {
     8c0:	213a0e03 	teqcs	sl, r3, lsl #28
    printf("Starting sha256 test\n");
     8c4:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
     8c8:	13491021 	movtne	r1, #36897	@ 0x9021
    BYTE text1[] = {"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"};
     8cc:	193c193f 	ldmdbne	ip!, {r0, r1, r2, r3, r4, r5, r8, fp, ip}
     8d0:	2e0c0000 	cdpcs	0, 0, cr0, cr12, cr0, {0}
     8d4:	03193f01 	tsteq	r9, #1, 30
     8d8:	3b0b3a0e 	blcc	2cf118 <__ROM_SIZE__+0x28f118>
     8dc:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
     8e0:	3c134919 			@ <UNDEFINED> instruction: 0x3c134919
     8e4:	00130119 	andseq	r0, r3, r9, lsl r1
     8e8:	012e0d00 			@ <UNDEFINED> instruction: 0x012e0d00
     8ec:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
    BYTE hash1[SHA256_BLOCK_SIZE] = {0x24,0x8d,0x6a,0x61,0xd2,0x06,0x38,0xb8,0xe5,0xc0,0x26,0x93,0x0c,0x3e,0x60,0x39,
     8f0:	0b3b0b3a 	bleq	ec35e0 <__ROM_SIZE__+0xe835e0>
     8f4:	27062139 	smladxcs	r6, r9, r1, r2
     8f8:	01193c19 	tsteq	r9, r9, lsl ip
     8fc:	0e000013 	mcreq	0, 0, r0, cr0, cr3, {0}
    sha256_init(&shactx);
     900:	13490026 	movtne	r0, #36902	@ 0x9026
	sha256_update(&shactx, text1, strlen((char *)text1));
     904:	130f0000 	movwne	r0, #61440	@ 0xf000
     908:	3a0b0b01 	bcc	2c3514 <__ROM_SIZE__+0x283514>
     90c:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     910:	13010921 	movwne	r0, #6433	@ 0x1921
	sha256_final(&shactx, buf);
     914:	05100000 	ldreq	r0, [r0, #-0]
     918:	3a0e0300 	bcc	381520 <__ROM_SIZE__+0x341520>
    len = encode_base64(hash1, SHA256_BLOCK_SIZE, b64_hash1);
     91c:	213b0121 	teqcs	fp, r1, lsr #2
     920:	490b390c 	stmdbmi	fp, {r2, r3, r8, fp, ip, sp}
     924:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
    b64_hash1[len] = '\0';
     928:	00001742 	andeq	r1, r0, r2, asr #14
    len = encode_base64(buf, SHA256_BLOCK_SIZE, b64_buf);
     92c:	25011111 	strcs	r1, [r1, #-273]	@ 0xfffffeef
     930:	030b130e 	movweq	r1, #45838	@ 0xb30e
     934:	110e1b0e 	tstne	lr, lr, lsl #22
    b64_buf[len] = '\0';
     938:	10061201 	andne	r1, r6, r1, lsl #4
    printf("Base64 of SHA-256 test is %s\n", b64_buf);
     93c:	12000017 	andne	r0, r0, #23
     940:	0b0b0024 	bleq	2c09d8 <__ROM_SIZE__+0x2809d8>
    printf("Should be %s\n", b64_hash1);
     944:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
     948:	13130000 	tstne	r3, #0
}
     94c:	0b0e0301 	bleq	381558 <__ROM_SIZE__+0x341558>
     950:	3b0b3a05 	blcc	2cf16c <__ROM_SIZE__+0x28f16c>
     954:	010b390b 	tsteq	fp, fp, lsl #18
     958:	14000013 	strne	r0, [r0], #-19	@ 0xffffffed
     95c:	0803000d 	stmdaeq	r3, {r0, r2, r3}
     960:	0b3b0b3a 	bleq	ec3650 <__ROM_SIZE__+0xe83650>
void __attribute__((optimize("O0"), weak)) initial_setup(void) {
     964:	13490b39 	movtne	r0, #39737	@ 0x9b39
     968:	00000b38 	andeq	r0, r0, r8, lsr fp
  char *src = &_etext, *dst = &_data;
     96c:	03001615 	movweq	r1, #1557	@ 0x615
     970:	3b0b3a08 	blcc	2cf198 <__ROM_SIZE__+0x28f198>
  if (dst != src)
     974:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
     978:	16000013 			@ <UNDEFINED> instruction: 0x16000013
    while (dst < &_edata) *(dst++) = *(src++);
     97c:	19270115 	stmdbne	r7!, {r0, r2, r4, r8}
     980:	13011349 	movwne	r1, #4937	@ 0x1349
     984:	21170000 	tstcs	r7, r0
     988:	18000000 	stmdane	r0, {}	@ <UNPREDICTABLE>
     98c:	08030034 	stmdaeq	r3, {r2, r4, r5}
     990:	0b3b0b3a 	bleq	ec3680 <__ROM_SIZE__+0xe83680>
  for (dst = &_bss; dst < &_ebss; dst++) *dst = 0;
     994:	13490b39 	movtne	r0, #39737	@ 0x9b39
     998:	193c193f 	ldmdbne	ip!, {r0, r1, r2, r3, r4, r5, r8, fp, ip}
     99c:	34190000 	ldrcc	r0, [r9], #-0
     9a0:	3a0e0300 	bcc	3815a8 <__ROM_SIZE__+0x3415a8>
     9a4:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     9a8:	3f13490b 	svccc	0x0013490b
     9ac:	00180219 	andseq	r0, r8, r9, lsl r2
  platform_init();
     9b0:	00181a00 	andseq	r1, r8, r0, lsl #20
}
     9b4:	2e1b0000 	cdpcs	0, 1, cr0, cr11, cr0, {0}
     9b8:	03193f01 	tsteq	r9, #1, 30
     9bc:	3b0b3a0e 	blcc	2cf1fc <__ROM_SIZE__+0x28f1fc>
     9c0:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
     9c4:	11134919 	tstne	r3, r9, lsl r9
     9c8:	40061201 	andmi	r1, r6, r1, lsl #4
     9cc:	01197a18 	tsteq	r9, r8, lsl sl
static void delete(void) {
     9d0:	1c000013 	stcne	0, cr0, [r0], {19}
  __write_char__(BACK_SPACE);
     9d4:	08030034 	stmdaeq	r3, {r2, r4, r5}
     9d8:	0b3b0b3a 	bleq	ec36c8 <__ROM_SIZE__+0xe836c8>
  __write_char__(SPACE);
     9dc:	13490b39 	movtne	r0, #39737	@ 0x9b39
  __write_char__(BACK_SPACE);
     9e0:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
     9e4:	1d000017 	stcne	0, cr0, [r0, #-92]	@ 0xffffffa4
}
     9e8:	017d0148 	cmneq	sp, r8, asr #2
static void clear_prompt(int char_count) {
     9ec:	0000137f 	andeq	r1, r0, pc, ror r3
  while (char_count) {
     9f0:	4901011e 	stmdbmi	r1, {r1, r2, r3, r4, r8}
    delete ();
     9f4:	00000013 	andeq	r0, r0, r3, lsl r0
  while (char_count) {
     9f8:	0b002401 	bleq	9a04 <__RAM_SIZE__+0x1a04>
}
     9fc:	030b3e0b 	movweq	r3, #48651	@ 0xbe0b
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
     a00:	0200000e 	andeq	r0, r0, #14
    auto_load[i].command(0, NULL);
     a04:	210b000f 	tstcs	fp, pc
     a08:	00134904 	andseq	r4, r3, r4, lsl #18
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
     a0c:	00050300 	andeq	r0, r5, r0, lsl #6
     a10:	00001349 	andeq	r1, r0, r9, asr #6
     a14:	03000d04 	movweq	r0, #3332	@ 0xd04
     a18:	02213a0e 	eoreq	r3, r1, #57344	@ 0xe000
     a1c:	0b390b3b 	bleq	e43710 <__ROM_SIZE__+0xe03710>
}
     a20:	0b381349 	bleq	e0574c <__ROM_SIZE__+0xdc574c>
static int show_history(int argc, char **argv) {
     a24:	2e050000 	cdpcs	0, 0, cr0, cr5, cr0, {0}
  uint32_t end_index = total_num_commands-1;
     a28:	03193f01 	tsteq	r9, #1, 30
  if (total_num_commands > NUM_HISTORY_ENTRIES) {
     a2c:	03213a0e 			@ <UNDEFINED> instruction: 0x03213a0e
     a30:	21390b3b 	teqcs	r9, fp, lsr fp
    beg_index = total_num_commands - NUM_HISTORY_ENTRIES;
     a34:	49192705 	ldmdbmi	r9, {r0, r2, r8, r9, sl, sp}
     a38:	01193c13 	tsteq	r9, r3, lsl ip
  uint32_t beg_index = 0;
     a3c:	06000013 			@ <UNDEFINED> instruction: 0x06000013
    printf("%s\n", cmd_history[index % NUM_HISTORY_ENTRIES]);
     a40:	00000018 	andeq	r0, r0, r8, lsl r0
     a44:	03000507 	movweq	r0, #1287	@ 0x507
     a48:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
     a4c:	3905213b 	stmdbcc	r5, {r0, r1, r3, r4, r5, r8, sp}
  for (uint32_t index = beg_index; index <= end_index; ++index) {
     a50:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
}
     a54:	1742b717 	smlaldne	fp, r2, r7, r7
     a58:	49080000 	stmdbmi	r8, {}	@ <UNPREDICTABLE>
     a5c:	7e180200 	cdpvc	2, 1, cr0, cr8, cr0, {0}
     a60:	09000018 	stmdbeq	r0, {r3, r4}
int cmd_exec_status(int argc, char **argv) {
     a64:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
  printf("%d\n", __cmd_exec_status);
     a68:	0e030b13 	vmoveq.32	d3[0], r0
     a6c:	01110e1b 	tsteq	r1, fp, lsl lr
     a70:	17100612 			@ <UNDEFINED> instruction: 0x17100612
}
     a74:	240a0000 	strcs	r0, [sl], #-0
     a78:	3e0b0b00 	vmlacc.f64	d0, d11, d0
     a7c:	0008030b 	andeq	r0, r8, fp, lsl #6
static int build_info(int argc, char **argv) {
     a80:	00160b00 	andseq	r0, r6, r0, lsl #22
  printf("Build: [" SHELL_VERSION ":" USER_REPO_VERSION "] - [" BUILD_USER
     a84:	0b3a0803 	bleq	e82a98 <__ROM_SIZE__+0xe42a98>
}
     a88:	0b390b3b 	bleq	e4377c <__ROM_SIZE__+0xe0377c>
     a8c:	00001349 	andeq	r1, r0, r9, asr #6
static void execute(int argc, char **argv) {
     a90:	2701150c 	strcs	r1, [r1, -ip, lsl #10]
     a94:	01134919 	tsteq	r3, r9, lsl r9
  for (int i = 0; table[i].command_name != NULL; i++) {
     a98:	0d000013 	stceq	0, cr0, [r0, #-76]	@ 0xffffffb4
     a9c:	13490026 	movtne	r0, #36902	@ 0x9026
     aa0:	130e0000 	movwne	r0, #57344	@ 0xe000
     aa4:	3a0b0b01 	bcc	2c36b0 <__ROM_SIZE__+0x2836b0>
     aa8:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    if (strcmp(argv[0], table[i].command_name) == 0) {
     aac:	0013010b 	andseq	r0, r3, fp, lsl #2
     ab0:	00160f00 	andseq	r0, r6, r0, lsl #30
      __cmd_exec_status = table[i].command(argc, &argv[0]);
     ab4:	0b3a0e03 	bleq	e842c8 <__ROM_SIZE__+0xe442c8>
     ab8:	0b390b3b 	bleq	e437ac <__ROM_SIZE__+0xe037ac>
     abc:	00001349 	andeq	r1, r0, r9, asr #6
     ac0:	03003410 	movweq	r3, #1040	@ 0x410
     ac4:	3b0b3a0e 	blcc	2cf304 <__ROM_SIZE__+0x28f304>
    printf("\"%s\": command not found. Use \"help\" to list all command.\n",
     ac8:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
     acc:	02193f13 	andseq	r3, r9, #19, 30	@ 0x4c
    __cmd_exec_status = -1;
     ad0:	11000018 	tstne	r0, r8, lsl r0
     ad4:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
     ad8:	0b3a0e03 	bleq	e842ec <__ROM_SIZE__+0xe442ec>
}
     adc:	0b390b3b 	bleq	e437d0 <__ROM_SIZE__+0xe037d0>
     ae0:	13491927 	movtne	r1, #39207	@ 0x9927
     ae4:	06120111 			@ <UNDEFINED> instruction: 0x06120111
     ae8:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
int help(int argc, char **argv) {
     aec:	48120000 	ldmdami	r2, {}	@ <UNPREDICTABLE>
  if (argc > 1 && (strcmp(argv[1], "-l")==0)) {
     af0:	7f017d01 	svcvc	0x00017d01
     af4:	00130113 	andseq	r0, r3, r3, lsl r1
     af8:	01481300 	mrseq	r1, (UNDEF: 120)
     afc:	137f017d 	cmnne	pc, #1073741855	@ 0x4000001f
    printf("use: help -l for list only.\n\n");
     b00:	01000000 	mrseq	r0, (UNDEF: 0)
  bool verbose = true;
     b04:	18020049 	stmdane	r2, {r0, r3, r6}
    verbose = false;
     b08:	0000187e 	andeq	r1, r0, lr, ror r8
    printf("\n");
     b0c:	49000502 	stmdbmi	r0, {r1, r8, sl}
    i++;
     b10:	03000013 	movweq	r0, #19
  while (table[i].command_name != NULL) {
     b14:	0b0b0024 	bleq	2c0bac <__ROM_SIZE__+0x280bac>
     b18:	0e030b3e 	vmoveq.16	d3[0], r0
     b1c:	0f040000 	svceq	0x00040000
    printf(table[i].command_name);
     b20:	04210b00 	strteq	r0, [r1], #-2816	@ 0xfffff500
    if (verbose) {
     b24:	00001349 	andeq	r1, r0, r9, asr #6
      printf("\n\t");
     b28:	7d014805 	stcvc	8, cr4, [r1, #-20]	@ 0xffffffec
      printf(table[i].command_help);
     b2c:	01137f01 	tsteq	r3, r1, lsl #30
     b30:	06000013 			@ <UNDEFINED> instruction: 0x06000013
     b34:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
    verbose = false;
     b38:	0b3b0b3a 	bleq	ec3828 <__ROM_SIZE__+0xe83828>
}
     b3c:	13490b39 	movtne	r0, #39737	@ 0x9b39
     b40:	00000b38 	andeq	r0, r0, r8, lsr fp
     b44:	03001607 	movweq	r1, #1543	@ 0x607
     b48:	3b0b3a0e 	blcc	2cf388 <__ROM_SIZE__+0x28f388>
     b4c:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
     b50:	08000013 	stmdaeq	r0, {r0, r1, r4}
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
     b54:	13490021 	movtne	r0, #36897	@ 0x9021
static void add_command_to_history(const char *cmd_str) {
     b58:	00000b2f 	andeq	r0, r0, pc, lsr #22
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
     b5c:	03003409 	movweq	r3, #1033	@ 0x409
     b60:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
  int index = total_num_commands % NUM_HISTORY_ENTRIES;
     b64:	0b390b3b 	bleq	e43858 <__ROM_SIZE__+0xe03858>
     b68:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
     b6c:	010a0000 	mrseq	r0, (UNDEF: 10)
     b70:	01134901 	tsteq	r3, r1, lsl #18
  memcpy(&cmd_history[index], cmd_str, LINE_BUFF_SIZE);
     b74:	0b000013 	bleq	bc8 <parse_line+0x2c>
     b78:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
     b7c:	0b3a0e03 	bleq	e84390 <__ROM_SIZE__+0xe44390>
     b80:	0b390b3b 	bleq	e43874 <__ROM_SIZE__+0xe03874>
  total_num_commands++;
     b84:	13491927 	movtne	r1, #39207	@ 0x9927
  curr_command_ptr = total_num_commands;
     b88:	1301193c 	movwne	r1, #6460	@ 0x193c
     b8c:	2e0c0000 	cdpcs	0, 0, cr0, cr12, cr0, {0}
     b90:	03193f01 	tsteq	r9, #1, 30
     b94:	04213a0e 	strteq	r3, [r1], #-2574	@ 0xfffff5f2
     b98:	21390b3b 	teqcs	r9, fp, lsr fp
static int parse_line(char **argv, char *line_buff, int argument_size) {
     b9c:	3c192706 	ldccc	7, cr2, [r9], {6}
     ba0:	00130119 	andseq	r0, r3, r9, lsl r1
  int length = strlen(line_buff);
     ba4:	00260d00 	eoreq	r0, r6, r0, lsl #26
     ba8:	00001349 	andeq	r1, r0, r9, asr #6
  int argc = 0;
     bac:	0b01130e 	bleq	457ec <__ROM_SIZE__+0x57ec>
         pos++)
     bb0:	3b0b3a0b 	blcc	2cf3e4 <__ROM_SIZE__+0x28f3e4>
    for (; line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
     bb4:	0921390b 	stmdbeq	r1!, {r0, r1, r3, r8, fp, ip, sp}
     bb8:	00001301 	andeq	r1, r0, r1, lsl #6
     bbc:	0300050f 	movweq	r0, #1295	@ 0x50f
     bc0:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
    if (line_buff[pos] == '\t' || line_buff[pos] == SPACE)
     bc4:	3904213b 	stmdbcc	r4, {r0, r1, r3, r4, r5, r8, sp}
     bc8:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
      line_buff[pos] = END_OF_LINE;
     bcc:	1742b717 	smlaldne	fp, r2, r7, r7
  while (pos <= length) {
     bd0:	11100000 	tstne	r0, r0
    if (line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
     bd4:	130e2501 	movwne	r2, #58625	@ 0xe501
     bd8:	1b0e030b 	blne	38180c <__ROM_SIZE__+0x34180c>
     bdc:	1201110e 	andne	r1, r1, #-2147483645	@ 0x80000003
     be0:	00171006 	andseq	r1, r7, r6
      argv[argc++] = &line_buff[pos];
     be4:	00241100 	eoreq	r1, r4, r0, lsl #2
     be8:	0b3e0b0b 	bleq	f8381c <__ROM_SIZE__+0xf4381c>
}
     bec:	00000803 	andeq	r0, r0, r3, lsl #16
static int prefix_match(char *sub, int len, const char *str) {
     bf0:	03001612 	movweq	r1, #1554	@ 0x612
     bf4:	3b0b3a08 	blcc	2cf41c <__ROM_SIZE__+0x28f41c>
  if (sub == NULL || str == NULL || len <= 0 || len > strlen(str)) {
     bf8:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
     bfc:	13000013 	movwne	r0, #19
     c00:	19270115 	stmdbne	r7!, {r0, r2, r4, r8}
     c04:	13011349 	movwne	r1, #4937	@ 0x1349
  for (int i = 0; i<len; ++i) {
     c08:	34140000 	ldrcc	r0, [r4], #-0
     c0c:	3a0e0300 	bcc	381814 <__ROM_SIZE__+0x341814>
    if (sub[i] != str[i]) {
     c10:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     c14:	3f13490b 	svccc	0x0013490b
  for (int i = 0; i<len; ++i) {
     c18:	00180219 	andseq	r0, r8, r9, lsl r2
}
     c1c:	00181500 	andseq	r1, r8, r0, lsl #10
  return TRUE;
     c20:	2e160000 	cdpcs	0, 1, cr0, cr6, cr0, {0}
      return FALSE;
     c24:	03193f01 	tsteq	r9, #1, 30
}
     c28:	3b0b3a0e 	blcc	2cf468 <__ROM_SIZE__+0x28f468>
static void handle_up_arrow(char *cmd_buff, int *char_count) {
     c2c:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
     c30:	11134919 	tstne	r3, r9, lsl r9
     c34:	40061201 	andmi	r1, r6, r1, lsl #4
     c38:	01197a18 	tsteq	r9, r8, lsl sl
     c3c:	17000013 	smladne	r0, r3, r0, r0
      curr_command_ptr == 0) {
     c40:	08030034 	stmdaeq	r3, {r2, r4, r5}
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
     c44:	0b3b0b3a 	bleq	ec3934 <__ROM_SIZE__+0xe83934>
    printf("%s", cmd_buff);
     c48:	13490b39 	movtne	r0, #39737	@ 0x9b39
     c4c:	00001802 	andeq	r1, r0, r2, lsl #16
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
     c50:	03003418 	movweq	r3, #1048	@ 0x418
     c54:	3b0b3a08 	blcc	2cf47c <__ROM_SIZE__+0x28f47c>
  curr_command_ptr--;
     c58:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
     c5c:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
     c60:	00001742 	andeq	r1, r0, r2, asr #14
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
     c64:	7d014819 	stcvc	8, cr4, [r1, #-100]	@ 0xffffff9c
     c68:	00137f01 	andseq	r7, r3, r1, lsl #30
     c6c:	01011a00 	tsteq	r1, r0, lsl #20
     c70:	00001349 	andeq	r1, r0, r9, asr #6
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
     c74:	00490100 	subeq	r0, r9, r0, lsl #2
     c78:	187e1802 	ldmdane	lr!, {r1, fp, ip}^
     c7c:	48020000 	stmdami	r2, {}	@ <UNPREDICTABLE>
  *char_count = strlen(cmd_buff);
     c80:	7f017d01 	svcvc	0x00017d01
     c84:	00130113 	andseq	r0, r3, r3, lsl r1
  printf("%s", cmd_buff);
     c88:	00050300 	andeq	r0, r5, r0, lsl #6
     c8c:	00001349 	andeq	r1, r0, r9, asr #6
     c90:	7d004804 	stcvc	8, cr4, [r0, #-16]
     c94:	00137f01 	andseq	r7, r3, r1, lsl #30
     c98:	00050500 	andeq	r0, r5, r0, lsl #10
static void handle_down_arrow(char *cmd_buff, int *char_count) {
     c9c:	213a0e03 	teqcs	sl, r3, lsl #28
     ca0:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
     ca4:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
     ca8:	1742b717 	smlaldne	fp, r2, r7, r7
  *char_count = 0;
     cac:	48060000 	stmdami	r6, {}	@ <UNPREDICTABLE>
  if (curr_command_ptr == total_num_commands) return;
     cb0:	7f017d01 	svcvc	0x00017d01
     cb4:	07000013 	smladeq	r0, r3, r0, r0
     cb8:	0b0b0024 	bleq	2c0d50 <__ROM_SIZE__+0x280d50>
  curr_command_ptr++;
     cbc:	0e030b3e 	vmoveq.16	d3[0], r0
     cc0:	0f080000 	svceq	0x00080000
     cc4:	04210b00 	strteq	r0, [r1], #-2816	@ 0xfffff500
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
     cc8:	00001349 	andeq	r1, r0, r9, asr #6
     ccc:	03003409 	movweq	r3, #1033	@ 0x409
     cd0:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
     cd4:	0b390b3b 	bleq	e439c8 <__ROM_SIZE__+0xe039c8>
     cd8:	193f1349 	ldmdbne	pc!, {r0, r3, r6, r8, r9, ip}	@ <UNPREDICTABLE>
     cdc:	00001802 	andeq	r1, r0, r2, lsl #16
     ce0:	0300340a 	movweq	r3, #1034	@ 0x40a
  *char_count = strlen(cmd_buff);
     ce4:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
     ce8:	0b390b3b 	bleq	e439dc <__ROM_SIZE__+0xe039dc>
  printf("%s", cmd_buff);
     cec:	17021349 	strne	r1, [r2, -r9, asr #6]
     cf0:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
}
     cf4:	00210b00 	eoreq	r0, r1, r0, lsl #22
     cf8:	0b2f1349 	bleq	bc5a24 <__ROM_SIZE__+0xb85a24>
void set_read_char(int (*func)(void)) { __read_char__ = func; }
     cfc:	010c0000 	mrseq	r0, (UNDEF: 12)
     d00:	01134901 	tsteq	r3, r1, lsl #18
     d04:	0d000013 	stceq	0, cr0, [r0, #-76]	@ 0xffffffb4
void set_read_char2(int (*func)(void)) { __read_char2__ = func; }
     d08:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
     d0c:	3b01213a 	blcc	491fc <__ROM_SIZE__+0x91fc>
     d10:	490b3905 	stmdbmi	fp, {r0, r2, r8, fp, ip, sp}
void set_write_char(void (*func)(char)) { __write_char__ = func; }
     d14:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
     d18:	00001742 	andeq	r1, r0, r2, asr #14
     d1c:	0300340e 	movweq	r3, #1038	@ 0x40e
void set_write_char2(void (*func)(char)) { __write_char2__ = func; }
     d20:	01213a08 			@ <UNDEFINED> instruction: 0x01213a08
     d24:	0b39053b 	bleq	e42218 <__ROM_SIZE__+0xe02218>
     d28:	17021349 	strne	r1, [r2, -r9, asr #6]
}
     d2c:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
}
     d30:	012e0f00 			@ <UNDEFINED> instruction: 0x012e0f00
  if (cmd_buff == NULL || char_count <= 0) {
     d34:	213a0e03 	teqcs	sl, r3, lsl #28
static void handle_tab(char *cmd_buff, int *char_count) {
     d38:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
     d3c:	19270d21 	stmdbne	r7!, {r0, r5, r8, sl, fp}
  int last_match = -1;
     d40:	06120111 			@ <UNDEFINED> instruction: 0x06120111
  int match_count = 0;
     d44:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
  int i = 0;
     d48:	00001301 	andeq	r1, r0, r1, lsl #6
    i++;
     d4c:	3f012e10 	svccc	0x00012e10
  while (table[i].command_name != NULL) { //loop over all commands
     d50:	3a0e0319 	bcc	3819bc <__ROM_SIZE__+0x3419bc>
     d54:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     d58:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
    if (prefix_match(cmd_buff, *char_count, table[i].command_name)) {
     d5c:	01193c13 	tsteq	r9, r3, lsl ip
     d60:	11000013 	tstne	r0, r3, lsl r0
     d64:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
      match_count++;
     d68:	3b01213a 	blcc	49258 <__ROM_SIZE__+0x9258>
      printf("\n%s", table[i].command_name);
     d6c:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
     d70:	00180213 	andseq	r0, r8, r3, lsl r2
      last_match = i;
     d74:	00341200 	eorseq	r1, r4, r0, lsl #4
  if (match_count == 1) {
     d78:	213a0e03 	teqcs	sl, r3, lsl #28
     d7c:	39053b01 	stmdbcc	r5, {r0, r8, r9, fp, ip, sp}
  if (match_count) {
     d80:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
}
     d84:	13000018 	movwne	r0, #24
    memcpy(cmd_buff, table[last_match].command_name, LINE_BUFF_SIZE);
     d88:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     d8c:	3b01213a 	blcc	4927c <__ROM_SIZE__+0x927c>
     d90:	39038c21 	stmdbcc	r3, {r0, r5, sl, fp, pc}
     d94:	3f13490b 	svccc	0x0013490b
    *char_count = strlen(cmd_buff);
     d98:	00193c19 	andseq	r3, r9, r9, lsl ip
     d9c:	00161400 	andseq	r1, r6, r0, lsl #8
     da0:	0b3a0e03 	bleq	e845b4 <__ROM_SIZE__+0xe445b4>
    printf("\n");
     da4:	0b390b3b 	bleq	e43a98 <__ROM_SIZE__+0xe03a98>
     da8:	00001349 	andeq	r1, r0, r9, asr #6
    prepend_prompt();
     dac:	03000d15 	movweq	r0, #3349	@ 0xd15
    printf(PROMPT);
     db0:	3b0b3a0e 	blcc	2cf5f0 <__ROM_SIZE__+0x28f5f0>
     db4:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
    printf("%s", cmd_buff);
     db8:	000b3813 	andeq	r3, fp, r3, lsl r8
     dbc:	012e1600 			@ <UNDEFINED> instruction: 0x012e1600
     dc0:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
     dc4:	3b01213a 	blcc	492b4 <__ROM_SIZE__+0x92b4>
     dc8:	05213905 	streq	r3, [r1, #-2309]!	@ 0xfffff6fb
     dcc:	13491927 	movtne	r1, #39207	@ 0x9927
     dd0:	06120111 			@ <UNDEFINED> instruction: 0x06120111
__attribute__((weak)) int active_prompt() { return TRUE; }
     dd4:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
static void shell(void) {
     dd8:	00001301 	andeq	r1, r0, r1, lsl #6
  int count = 0;
     ddc:	03003417 	movweq	r3, #1047	@ 0x417
  for (int i = 0; i < LINE_BUFF_SIZE; i++) line_buff[i] = 0;
     de0:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
     de4:	0b39053b 	bleq	e422d8 <__ROM_SIZE__+0xe022d8>
     de8:	17021349 	strne	r1, [r2, -r9, asr #6]
     dec:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
     df0:	01481800 	cmpeq	r8, r0, lsl #16
  for (int i = 0; i < MAX_ARG_COUNT; i++) argv[i] = NULL;
     df4:	1301017d 	movwne	r0, #4477	@ 0x117d
     df8:	34190000 	ldrcc	r0, [r9], #-0
     dfc:	3a080300 	bcc	201a04 <__ROM_SIZE__+0x1c1a04>
     e00:	0b3b0121 	bleq	ec128c <__ROM_SIZE__+0xe8128c>
     e04:	13490b39 	movtne	r0, #39737	@ 0x9b39
  prepend_prompt();
     e08:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
  printf(PROMPT);
     e0c:	1a000017 	bne	e70 <shell+0x98>
  int special_key = 0;
     e10:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
        special_key = 1;
     e14:	3b01213a 	blcc	49304 <__ROM_SIZE__+0x9304>
    if (s == -1) { s = __read_char2__();}
     e18:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
     e1c:	00180213 	andseq	r0, r8, r3, lsl r2
    if (s != -1) {
     e20:	00261b00 	eoreq	r1, r6, r0, lsl #22
     e24:	00001349 	andeq	r1, r0, r9, asr #6
      loop();
     e28:	4900351c 	stmdbmi	r0, {r2, r3, r4, r8, sl, ip, sp}
        line_buff[count] = END_OF_LINE;
     e2c:	1d000013 	stcne	0, cr0, [r0, #-76]	@ 0xffffffb4
     e30:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     e34:	3b01213a 	blcc	49324 <__ROM_SIZE__+0x9324>
     e38:	01213905 			@ <UNDEFINED> instruction: 0x01213905
        __write_char__(NEW_LINE);
     e3c:	193f1349 	ldmdbne	pc!, {r0, r3, r6, r8, r9, ip}	@ <UNPREDICTABLE>
     e40:	00001802 	andeq	r1, r0, r2, lsl #16
  add_command_to_history(line_buff);
     e44:	11010b1e 	tstne	r1, lr, lsl fp
  argc = parse_line(argv, line_buff, MAX_ARG_COUNT);
     e48:	00061201 	andeq	r1, r6, r1, lsl #4
     e4c:	01481f00 	cmpeq	r8, r0, lsl #30
     e50:	0000017d 	andeq	r0, r0, sp, ror r1
  if (argc > 0) execute(argc, argv);
     e54:	11010b20 	tstne	r1, r0, lsr #22
}
     e58:	01061201 	tsteq	r6, r1, lsl #4
        if (!__echo) {
     e5c:	21000013 	tstcs	r0, r3, lsl r0
     e60:	0e03012e 	adfeqsp	f0, f3, #0.5
        if (count == 0) continue;
     e64:	3b01213a 	blcc	49354 <__ROM_SIZE__+0x9354>
        count--;
     e68:	0c21390b 			@ <UNDEFINED> instruction: 0x0c21390b
        line_buff[count] = END_OF_LINE;
     e6c:	13491927 	movtne	r1, #39207	@ 0x9927
     e70:	06120111 			@ <UNDEFINED> instruction: 0x06120111
     e74:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
        delete ();
     e78:	00001301 	andeq	r1, r0, r1, lsl #6
      if (__echo) {
     e7c:	03000522 	movweq	r0, #1314	@ 0x522
        __write_char__(c);
     e80:	01213a08 			@ <UNDEFINED> instruction: 0x01213a08
     e84:	01a5213b 			@ <UNDEFINED> instruction: 0x01a5213b
    if (!active_prompt()) {
     e88:	13490b39 	movtne	r0, #39737	@ 0x9b39
     e8c:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
    s = __read_char__();
     e90:	23000017 	movwcs	r0, #23
     e94:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
    if (s == -1) { s = __read_char2__();}
     e98:	213a0e03 	teqcs	sl, r3, lsl #28
     e9c:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
      if (c == CARRIAGE_RETURN || c == NEW_LINE) {
     ea0:	19270621 	stmdbne	r7!, {r0, r5, r9, sl}
     ea4:	06120111 			@ <UNDEFINED> instruction: 0x06120111
      if (c == DELETE || c == BACK_SPACE) {
     ea8:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
     eac:	00001301 	andeq	r1, r0, r1, lsl #6
      } else if (c == ESCAPE) {
     eb0:	03003424 	movweq	r3, #1060	@ 0x424
      } else if (c == SQUARE_BRACKET_OPEN && special_key == 1) {
     eb4:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
      } else if ((c == 'C' || c == 'D') && special_key != 0) {
     eb8:	21390b3b 	teqcs	r9, fp, lsr fp
     ebc:	3f13491a 	svccc	0x0013491a
     ec0:	00193c19 	andseq	r3, r9, r9, lsl ip
      } else if ((c == 'A' || c == 'B') && special_key == 2) {
     ec4:	00342500 	eorseq	r2, r4, r0, lsl #10
     ec8:	213a0e03 	teqcs	sl, r3, lsl #28
      else if (c == TAB) {
     ecc:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
        line_buff[count] = c;
     ed0:	13491521 	movtne	r1, #38177	@ 0x9521
     ed4:	34260000 	strtcc	r0, [r6], #-0
     ed8:	3a080300 	bcc	201ae0 <__ROM_SIZE__+0x1c1ae0>
        count++;
     edc:	213b0121 	teqcs	fp, r1, lsr #2
     ee0:	0b39038d 	bleq	e41d1c <__ROM_SIZE__+0xe01d1c>
          delete ();
     ee4:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
          delete ();
     ee8:	2e270000 	cdpcs	0, 2, cr0, cr7, cr0, {0}
      } else if (c == SQUARE_BRACKET_OPEN && special_key == 1) {
     eec:	03193f00 	tsteq	r9, #0, 30
        special_key = 2;
     ef0:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
      } else if ((c == 'C' || c == 'D') && special_key != 0) {
     ef4:	21390b3b 	teqcs	r9, fp, lsr fp
        special_key = 0;
     ef8:	1119271c 	tstne	r9, ip, lsl r7
      } else if ((c == 'A' || c == 'B') && special_key == 2) {
     efc:	40061201 	andmi	r1, r6, r1, lsl #4
        if (!__echo) {
     f00:	00197a18 	andseq	r7, r9, r8, lsl sl
     f04:	01112800 	tsteq	r1, r0, lsl #16
          clear_prompt(count + 4);
     f08:	0b130e25 	bleq	4c47a4 <__ROM_SIZE__+0x4847a4>
     f0c:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
        if (c == 'A') {
     f10:	06120111 			@ <UNDEFINED> instruction: 0x06120111
          handle_down_arrow(line_buff, &count);
     f14:	00001710 	andeq	r1, r0, r0, lsl r7
     f18:	0b002429 	bleq	9fc4 <__RAM_SIZE__+0x1fc4>
        continue;
     f1c:	030b3e0b 	movweq	r3, #48651	@ 0xbe0b
          clear_prompt(count);
     f20:	2a000008 	bcs	f48 <shell+0x170>
     f24:	0e030113 	mcreq	1, 0, r0, cr3, cr3, {0}
          handle_up_arrow(line_buff, &count);
     f28:	0b3a050b 	bleq	e8235c <__ROM_SIZE__+0xe4235c>
     f2c:	0b390b3b 	bleq	e43c20 <__ROM_SIZE__+0xe03c20>
        handle_tab(line_buff, &count);
     f30:	00001301 	andeq	r1, r0, r1, lsl #6
     f34:	03000d2b 	movweq	r0, #3371	@ 0xd2b
        continue;
     f38:	3b0b3a08 	blcc	2cf760 <__ROM_SIZE__+0x28f760>
  if (argc > 0) execute(argc, argv);
     f3c:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
}
     f40:	000b3813 	andeq	r3, fp, r3, lsl r8
     f44:	00162c00 	andseq	r2, r6, r0, lsl #24
     f48:	0b3a0803 	bleq	e82f5c <__ROM_SIZE__+0xe42f5c>
     f4c:	0b390b3b 	bleq	e43c40 <__ROM_SIZE__+0xe03c40>
void prompt() {
     f50:	00001349 	andeq	r1, r0, r9, asr #6
  initial_setup();
     f54:	2701152d 	strcs	r1, [r1, -sp, lsr #10]
  exec_auto_cmds();
     f58:	01134919 	tsteq	r3, r9, lsl r9
  setup();
     f5c:	2e000013 	mcrcs	0, 0, r0, cr0, cr3, {0}
  decode_base64(AES_key_b64, 44, AES_key);
     f60:	0b0b0113 	bleq	2c13b4 <__ROM_SIZE__+0x2813b4>
     f64:	0b3b0b3a 	bleq	ec3c54 <__ROM_SIZE__+0xe83c54>
     f68:	13010b39 	movwne	r0, #6969	@ 0x1b39
     f6c:	342f0000 	strtcc	r0, [pc], #-0	@ f74 <prompt+0x24>
  AES_init_ctx(&ctx, AES_key);
     f70:	3a080300 	bcc	201b78 <__ROM_SIZE__+0x1c1b78>
     f74:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    shell();
     f78:	3f13490b 	svccc	0x0013490b
  while (TRUE) {
     f7c:	00180219 	andseq	r0, r8, r9, lsl r2
     f80:	00153000 	andseq	r3, r5, r0
     f84:	13491927 	movtne	r1, #39207	@ 0x9927
int exec(char *cmd_str) {
     f88:	15310000 	ldrne	r0, [r1, #-0]!
     f8c:	01192701 	tsteq	r9, r1, lsl #14
  argc = parse_line(argv, cmd_str, MAX_ARG_COUNT);
     f90:	32000013 	andcc	r0, r0, #19
     f94:	0b0b000f 	bleq	2c0fd8 <__ROM_SIZE__+0x280fd8>
  if (argc > 0) execute(argc, argv);
     f98:	26330000 	ldrtcs	r0, [r3], -r0
  return __cmd_exec_status;
     f9c:	34000000 	strcc	r0, [r0], #-0
}
     fa0:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
     fa4:	0b3a0e03 	bleq	e847b8 <__ROM_SIZE__+0xe447b8>
  if (argc > 0) execute(argc, argv);
     fa8:	0b390b3b 	bleq	e43c9c <__ROM_SIZE__+0xe03c9c>
     fac:	193c1927 	ldmdbne	ip!, {r0, r1, r2, r5, r8, fp, ip}
     fb0:	00001301 	andeq	r1, r0, r1, lsl #6
cmd get_function_addr(char *cmd_str) {
     fb4:	3f002e35 	svccc	0x00002e35
  for (int i = 0; table[i].command_name != NULL; i++) {
     fb8:	3a0e0319 	bcc	381c24 <__ROM_SIZE__+0x341c24>
     fbc:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     fc0:	3c19270b 	ldccc	7, cr2, [r9], {11}
     fc4:	36000019 			@ <UNDEFINED> instruction: 0x36000019
     fc8:	00000018 	andeq	r0, r0, r8, lsl r0
    if (strcmp(cmd_str, table[i].command_name) == 0) {
     fcc:	3f012e37 	svccc	0x00012e37
     fd0:	3a0e0319 	bcc	381c3c <__ROM_SIZE__+0x341c3c>
      return table[i].command;
     fd4:	39053b0b 	stmdbcc	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
     fd8:	1201110b 	andne	r1, r1, #-1073741822	@ 0xc0000002
  return NULL;
     fdc:	7a184006 	bvc	610ffc <__ROM_SIZE__+0x5d0ffc>
}
     fe0:	00130119 	andseq	r0, r3, r9, lsl r1
  if(v < 26) return v + 'A';
     fe4:	012e3800 			@ <UNDEFINED> instruction: 0x012e3800
  if(v < 52) return v + 71;
     fe8:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
  if(v < 62) return v - 4;
     fec:	053b0b3a 	ldreq	r0, [fp, #-2874]!	@ 0xfffff4c6
  if(v == 62) return '+';
     ff0:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
  if(v == 63) return '/';
     ff4:	06120111 			@ <UNDEFINED> instruction: 0x06120111
  return 64;
     ff8:	197c1840 	ldmdbne	ip!, {r6, fp, ip}^
  if(v < 26) return v + 'A';
     ffc:	00001301 	andeq	r1, r0, r1, lsl #6
    1000:	03012e39 	movweq	r2, #7737	@ 0x1e39
  if(v < 52) return v + 71;
    1004:	3b0b3a0e 	blcc	2cf844 <__ROM_SIZE__+0x28f844>
  if(v < 62) return v - 4;
    1008:	270b3905 	strcs	r3, [fp, -r5, lsl #18]
    100c:	11134919 	tstne	r3, r9, lsl r9
  if(v == 62) return '+';
    1010:	40061201 	andmi	r1, r6, r1, lsl #4
}
    1014:	01197a18 	tsteq	r9, r8, lsl sl
  if('A' <= c && c <= 'Z') return c - 'A';
    1018:	3a000013 	bcc	106c <decode_base64_length+0x4>
    101c:	0e03012e 	adfeqsp	f0, f3, #0.5
  if('a' <= c && c <= 'z') return c - 71;
    1020:	053b0b3a 	ldreq	r0, [fp, #-2874]!	@ 0xfffff4c6
    1024:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
    1028:	06120111 			@ <UNDEFINED> instruction: 0x06120111
  if('0' <= c && c <= '9') return c + 4;
    102c:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
    1030:	00001301 	andeq	r1, r0, r1, lsl #6
  if(c == '+') return 62;
    1034:	03012e3b 	movweq	r2, #7739	@ 0x1e3b
  if(c == '/') return 63;
    1038:	3b0b3a0e 	blcc	2cf878 <__ROM_SIZE__+0x28f878>
  return 255;
    103c:	270b3905 	strcs	r3, [fp, -r5, lsl #18]
  if('a' <= c && c <= 'z') return c - 71;
    1040:	12011119 	andne	r1, r1, #1073741830	@ 0x40000006
    1044:	7c184006 	ldcvc	0, cr4, [r8], {6}
  if('0' <= c && c <= '9') return c + 4;
    1048:	00130119 	andseq	r0, r3, r9, lsl r1
  if(c == '+') return 62;
    104c:	010b3c00 	tsteq	fp, r0, lsl #24
  if(c == '/') return 63;
    1050:	13011755 	movwne	r1, #5973	@ 0x1755
  return (input_length + 2)/3*4;
    1054:	2e3d0000 	cdpcs	0, 3, cr0, cr13, cr0, {0}
    1058:	03193f00 	tsteq	r9, #0, 30
    105c:	3b0b3a0e 	blcc	2cf89c <__ROM_SIZE__+0x28f89c>
}
    1060:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
    1064:	12011113 	andne	r1, r1, #-1073741820	@ 0xc0000004
unsigned int decode_base64_length(unsigned char input[], unsigned int input_length) {
    1068:	7a184006 	bvc	611088 <__ROM_SIZE__+0x5d1088>
    106c:	3e000019 	mcrcc	0, 0, r0, cr0, cr9, {0}
  while(base64_to_binary(input[0]) < 64 && (unsigned int) (input - start) < input_length) {
    1070:	193f002e 	ldmdbne	pc!, {r1, r2, r3, r5}	@ <UNPREDICTABLE>
    1074:	0b3a0e03 	bleq	e84888 <__ROM_SIZE__+0xe44888>
    1078:	0b390b3b 	bleq	e43d6c <__ROM_SIZE__+0xe03d6c>
    107c:	06120111 			@ <UNDEFINED> instruction: 0x06120111
    1080:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
  input_length = input - start;
    1084:	2e3f0000 	cdpcs	0, 3, cr0, cr15, cr0, {0}
  return input_length/4*3 + (input_length % 4 ? input_length % 4 - 1 : 0);
    1088:	03193f01 	tsteq	r9, #1, 30
    108c:	3b0b3a0e 	blcc	2cf8cc <__ROM_SIZE__+0x28f8cc>
    1090:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
}
    1094:	12011119 	andne	r1, r1, #1073741830	@ 0x40000006
  return input_length/4*3 + (input_length % 4 ? input_length % 4 - 1 : 0);
    1098:	7a184006 	bvc	6110b8 <__ROM_SIZE__+0x5d10b8>
unsigned int encode_base64(unsigned char input[], unsigned int input_length, unsigned char output[]) {
    109c:	00000019 	andeq	r0, r0, r9, lsl r0
    10a0:	7d004801 	stcvc	8, cr4, [r0, #-4]
    10a4:	00137f01 	andseq	r7, r3, r1, lsl #30
  unsigned int full_sets = input_length/3;
    10a8:	00050200 	andeq	r0, r5, r0, lsl #4
    10ac:	213a0e03 	teqcs	sl, r3, lsl #28
  for(unsigned int i = 0; i < full_sets; ++i) {
    10b0:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
    output[0] = binary_to_base64(                         input[0] >> 2);
    10b4:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
    10b8:	1742b717 	smlaldne	fp, r2, r7, r7
    output[1] = binary_to_base64((input[0] & 0x03) << 4 | input[1] >> 4);
    10bc:	2e030000 	cdpcs	0, 0, cr0, cr3, cr0, {0}
    10c0:	03193f01 	tsteq	r9, #1, 30
    10c4:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
    10c8:	0b390b3b 	bleq	e43dbc <__ROM_SIZE__+0xe03dbc>
    10cc:	13491927 	movtne	r1, #39207	@ 0x9927
    output[2] = binary_to_base64((input[1] & 0x0F) << 2 | input[2] >> 6);
    10d0:	06120111 			@ <UNDEFINED> instruction: 0x06120111
    10d4:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
    10d8:	00001301 	andeq	r1, r0, r1, lsl #6
    10dc:	03003404 	movweq	r3, #1028	@ 0x404
    10e0:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
    output[3] = binary_to_base64( input[2] & 0x3F);
    10e4:	0b390b3b 	bleq	e43dd8 <__ROM_SIZE__+0xe03dd8>
    10e8:	17021349 	strne	r1, [r2, -r9, asr #6]
    10ec:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
    input += 3;
    10f0:	00490500 	subeq	r0, r9, r0, lsl #10
  for(unsigned int i = 0; i < full_sets; ++i) {
    10f4:	187e1802 	ldmdane	lr!, {r1, fp, ip}^
    10f8:	0b060000 	bleq	181100 <__ROM_SIZE__+0x141100>
  switch(input_length % 3) {
    10fc:	12011101 	andne	r1, r1, #1073741824	@ 0x40000000
    1100:	00130106 	andseq	r0, r3, r6, lsl #2
    1104:	00340700 	eorseq	r0, r4, r0, lsl #14
    1108:	213a0803 	teqcs	sl, r3, lsl #16
    110c:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
    1110:	13491421 	movtne	r1, #37921	@ 0x9421
    1114:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
  return encode_base64_length(input_length);
    1118:	08000017 	stmdaeq	r0, {r0, r1, r2, r4}
}
    111c:	017d0148 	cmneq	sp, r8, asr #2
      output[0] = '\0';
    1120:	1301137f 	movwne	r1, #4991	@ 0x137f
      output[0] = binary_to_base64(                         input[0] >> 2);
    1124:	24090000 	strcs	r0, [r9], #-0
    1128:	3e0b0b00 	vmlacc.f64	d0, d11, d0
    112c:	000e030b 	andeq	r0, lr, fp, lsl #6
      output[1] = binary_to_base64((input[0] & 0x03) << 4);
    1130:	00050a00 	andeq	r0, r5, r0, lsl #20
    1134:	213a0803 	teqcs	sl, r3, lsl #16
    1138:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
      output[2] = '=';
    113c:	13492e21 	movtne	r2, #40481	@ 0x9e21
      output[3] = '=';
    1140:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
      output[4] = '\0';
    1144:	0b000017 	bleq	11a8 <decode_base64+0x24>
      output[0] = binary_to_base64(                         input[0] >> 2);
    1148:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
    114c:	0e030b13 	vmoveq.32	d3[0], r0
    1150:	01110e1b 	tsteq	r1, fp, lsl lr
      output[1] = binary_to_base64((input[0] & 0x03) << 4 | input[1] >> 4);
    1154:	17100612 			@ <UNDEFINED> instruction: 0x17100612
    1158:	0f0c0000 	svceq	0x000c0000
    115c:	490b0b00 	stmdbmi	fp, {r8, r9, fp}
    1160:	0d000013 	stceq	0, cr0, [r0, #-76]	@ 0xffffffb4
    1164:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
      output[2] = binary_to_base64((input[1] & 0x0F) << 2);
    1168:	0b3a0e03 	bleq	e8497c <__ROM_SIZE__+0xe4497c>
    116c:	0b390b3b 	bleq	e43e60 <__ROM_SIZE__+0xe03e60>
    1170:	13491927 	movtne	r1, #39207	@ 0x9927
      output[3] = '=';
    1174:	06120111 			@ <UNDEFINED> instruction: 0x06120111
      output[4] = '\0';
    1178:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
      break;
    117c:	01000000 	mrseq	r0, (UNDEF: 0)
    1180:	08030034 	stmdaeq	r3, {r2, r4, r5}
unsigned int decode_base64(unsigned char input[], unsigned int input_length, unsigned char output[]) {
    1184:	3b01213a 	blcc	49674 <__ROM_SIZE__+0x9674>
    1188:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
  unsigned int output_length = decode_base64_length(input, input_length);
    118c:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
    1190:	00001742 	andeq	r1, r0, r2, asr #14
  for(unsigned int i = 2; i < output_length; i += 3) {
    1194:	0b002402 	bleq	a1a4 <__RAM_SIZE__+0x21a4>
    output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
    1198:	030b3e0b 	movweq	r3, #48651	@ 0xbe0b
    119c:	0300000e 	movweq	r0, #14
    11a0:	18020049 	stmdane	r2, {r0, r3, r6}
    11a4:	0000187e 	andeq	r1, r0, lr, ror r8
    11a8:	03001604 	movweq	r1, #1540	@ 0x604
    output[1] = base64_to_binary(input[1]) << 4 | base64_to_binary(input[2]) >> 2;
    11ac:	3b0b3a0e 	blcc	2cf9ec <__ROM_SIZE__+0x28f9ec>
    11b0:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
    11b4:	05000013 	streq	r0, [r0, #-19]	@ 0xffffffed
    11b8:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
    11bc:	3b03213a 	blcc	c96ac <__ROM_SIZE__+0x896ac>
    output[2] = base64_to_binary(input[2]) << 6 | base64_to_binary(input[3]);
    11c0:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
    11c4:	000b3813 	andeq	r3, fp, r3, lsl r8
    11c8:	00210600 	eoreq	r0, r1, r0, lsl #12
    11cc:	0b2f1349 	bleq	bc5ef8 <__ROM_SIZE__+0xb85ef8>
    input += 4;
    11d0:	2e070000 	cdpcs	0, 0, cr0, cr7, cr0, {0}
  for(unsigned int i = 2; i < output_length; i += 3) {
    11d4:	03193f01 	tsteq	r9, #1, 30
    11d8:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
  switch(output_length % 3) {
    11dc:	21390b3b 	teqcs	r9, fp, lsr fp
    11e0:	11192706 	tstne	r9, r6, lsl #14
    11e4:	40061201 	andmi	r1, r6, r1, lsl #4
    11e8:	01197a18 	tsteq	r9, r8, lsl sl
    11ec:	08000013 	stmdaeq	r0, {r0, r1, r4}
    11f0:	08030005 	stmdaeq	r3, {r0, r2}
    11f4:	3b01213a 	blcc	496e4 <__ROM_SIZE__+0x96e4>
    11f8:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
      output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
    11fc:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
    1200:	00001742 	andeq	r1, r0, r2, asr #14
    1204:	49002609 	stmdbmi	r0, {r0, r3, r9, sl, sp}
    1208:	0a000013 	beq	125c <sha256_transform+0x1c>
    120c:	13490101 	movtne	r0, #37121	@ 0x9101
      output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
    1210:	00001301 	andeq	r1, r0, r1, lsl #6
    1214:	4900050b 	stmdbmi	r0, {r0, r1, r3, r8, sl}
    1218:	0c000013 	stceq	0, cr0, [r0], {19}
    121c:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
    1220:	3b01213a 	blcc	49710 <__ROM_SIZE__+0x9710>
      output[1] = base64_to_binary(input[1]) << 4 | base64_to_binary(input[2]) >> 2;
    1224:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
    1228:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
    122c:	00001742 	andeq	r1, r0, r2, asr #14
    1230:	0b000f0d 	bleq	4e6c <base_order+0x1854>
    1234:	13490421 	movtne	r0, #37921	@ 0x9421
  return output_length;
    1238:	340e0000 	strcc	r0, [lr], #-0
    123c:	3a080300 	bcc	201e44 <__ROM_SIZE__+0x1c1e44>
{
    1240:	0b3b0121 	bleq	ec16cc <__ROM_SIZE__+0xe816cc>
    1244:	13490b39 	movtne	r0, #39737	@ 0x9b39
	for (i = 0, j = 0; i < 16; ++i, j += 4)
    1248:	00001802 	andeq	r1, r0, r2, lsl #16
    124c:	7d01480f 	stcvc	8, cr4, [r1, #-60]	@ 0xffffffc4
		m[i] = (data[j] << 24) | (data[j + 1] << 16) | (data[j + 2] << 8) | (data[j + 3]);
    1250:	01137f01 	tsteq	r3, r1, lsl #30
    1254:	10000013 	andne	r0, r0, r3, lsl r0
    1258:	017d0148 	cmneq	sp, r8, asr #2
    125c:	0000137f 	andeq	r1, r0, pc, ror r3
    1260:	25011111 	strcs	r1, [r1, #-273]	@ 0xfffffeef
    1264:	030b130e 	movweq	r1, #45838	@ 0xb30e
    1268:	110e1b0e 	tstne	lr, lr, lsl #22
	for (i = 0, j = 0; i < 16; ++i, j += 4)
    126c:	10061201 	andne	r1, r6, r1, lsl #4
    1270:	12000017 	andne	r0, r0, #23
		m[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16];
    1274:	0b0b0024 	bleq	2c130c <__ROM_SIZE__+0x28130c>
    1278:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
    127c:	0f130000 	svceq	0x00130000
    1280:	000b0b00 	andeq	r0, fp, r0, lsl #22
    1284:	01131400 	tsteq	r3, r0, lsl #8
    1288:	0b3a0b0b 	bleq	e83ebc <__ROM_SIZE__+0xe43ebc>
    128c:	0b390b3b 	bleq	e43f80 <__ROM_SIZE__+0xe03f80>
    1290:	00001301 	andeq	r1, r0, r1, lsl #6
    1294:	3f012e15 	svccc	0x00012e15
    1298:	3a0e0319 	bcc	381f04 <__ROM_SIZE__+0x341f04>
    129c:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    12a0:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
    12a4:	01193c13 	tsteq	r9, r3, lsl ip
    12a8:	16000013 			@ <UNDEFINED> instruction: 0x16000013
    12ac:	08030005 	stmdaeq	r3, {r0, r2}
    12b0:	0b3b0b3a 	bleq	ec3fa0 <__ROM_SIZE__+0xe83fa0>
    12b4:	13490b39 	movtne	r0, #39737	@ 0x9b39
	for ( ; i < 64; ++i)
    12b8:	00001802 	andeq	r1, r0, r2, lsl #16
    12bc:	49010117 	stmdbmi	r1, {r0, r1, r2, r4, r8}
	a = ctx->state[0];
    12c0:	00000013 	andeq	r0, r0, r3, lsl r0
	b = ctx->state[1];
    12c4:	02004901 	andeq	r4, r0, #16384	@ 0x4000
	c = ctx->state[2];
    12c8:	00187e18 	andseq	r7, r8, r8, lsl lr
	d = ctx->state[3];
    12cc:	00340200 	eorseq	r0, r4, r0, lsl #4
	e = ctx->state[4];
    12d0:	213a0e03 	teqcs	sl, r3, lsl #28
	f = ctx->state[5];
    12d4:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
    12d8:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
	g = ctx->state[6];
    12dc:	1742b717 	smlaldne	fp, r2, r7, r7
	h = ctx->state[7];
    12e0:	24030000 	strcs	r0, [r3], #-0
    12e4:	3e0b0b00 	vmlacc.f64	d0, d11, d0
	d = ctx->state[3];
    12e8:	000e030b 	andeq	r0, lr, fp, lsl #6
	b = ctx->state[1];
    12ec:	00160400 	andseq	r0, r6, r0, lsl #8
	for (i = 0; i < 64; ++i) {
    12f0:	0b3a0e03 	bleq	e84b04 <__ROM_SIZE__+0xe44b04>
    12f4:	0b390b3b 	bleq	e43fe8 <__ROM_SIZE__+0xe03fe8>
    12f8:	00001349 	andeq	r1, r0, r9, asr #6
    12fc:	0b000f05 	bleq	4f18 <base_order+0x1900>
		t1 = h + EP1(e) + CH(e,f,g) + k[i] + m[i];
    1300:	13490421 	movtne	r0, #37921	@ 0x9421
    1304:	05060000 	streq	r0, [r6, #-0]
    1308:	3a080300 	bcc	201f10 <__ROM_SIZE__+0x1c1f10>
    130c:	0b3b0121 	bleq	ec1798 <__ROM_SIZE__+0xe81798>
    1310:	13490b39 	movtne	r0, #39737	@ 0x9b39
    1314:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
    1318:	07000017 	smladeq	r0, r7, r0, r0
    131c:	1755010b 	ldrbne	r0, [r5, -fp, lsl #2]
    1320:	00001301 	andeq	r1, r0, r1, lsl #6
    1324:	7d014808 	stcvc	8, cr4, [r1, #-32]	@ 0xffffffe0
    1328:	00137f01 	andseq	r7, r3, r1, lsl #30
		t2 = EP0(a) + MAJ(a,b,c);
    132c:	01480900 	cmpeq	r8, r0, lsl #18
    1330:	0000017d 	andeq	r0, r0, sp, ror r1
    1334:	0300280a 	movweq	r2, #2058	@ 0x80a
    1338:	000b1c0e 	andeq	r1, fp, lr, lsl #24
    133c:	01010b00 	tsteq	r1, r0, lsl #22
    1340:	13011349 	movwne	r1, #4937	@ 0x1349
    1344:	210c0000 	mrscs	r0, (UNDEF: 12)
    1348:	2f134900 	svccs	0x00134900
		h = g;
    134c:	0d00000b 	stceq	0, cr0, [r0, #-44]	@ 0xffffffd4
		f = e;
    1350:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
		e = d + t1;
    1354:	3b01213a 	blcc	49844 <__ROM_SIZE__+0x9844>
		c = b;
    1358:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
		a = t1 + t2;
    135c:	00180213 	andseq	r0, r8, r3, lsl r2
	for (i = 0; i < 64; ++i) {
    1360:	00050e00 	andeq	r0, r5, r0, lsl #28
	ctx->state[0] += a;
    1364:	213a0e03 	teqcs	sl, r3, lsl #28
    1368:	32213b01 	eorcc	r3, r1, #1024	@ 0x400
    136c:	13490b39 	movtne	r0, #39737	@ 0x9b39
    1370:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
    1374:	0f000017 	svceq	0x00000017
	ctx->state[1] += b;
    1378:	017d0148 	cmneq	sp, r8, asr #2
	ctx->state[2] += c;
    137c:	00001301 	andeq	r1, r0, r1, lsl #6
    1380:	25011110 	strcs	r1, [r1, #-272]	@ 0xfffffef0
	ctx->state[3] += d;
    1384:	030b130e 	movweq	r1, #45838	@ 0xb30e
	ctx->state[4] += e;
    1388:	110e1b0e 	tstne	lr, lr, lsl #22
    138c:	10061201 	andne	r1, r6, r1, lsl #4
	ctx->state[5] += f;
    1390:	11000017 	tstne	r0, r7, lsl r0
    1394:	0e030113 	mcreq	1, 0, r0, cr3, cr3, {0}
	ctx->state[6] += g;
    1398:	0b3a0b0b 	bleq	e83fcc <__ROM_SIZE__+0xe43fcc>
    139c:	13010b3b 	movwne	r0, #6971	@ 0x1b3b
	ctx->state[7] += h;
    13a0:	0d120000 	ldceq	0, cr0, [r2, #-0]
    13a4:	490e0300 	stmdbmi	lr, {r8, r9}
}
    13a8:	340b3813 	strcc	r3, [fp], #-2067	@ 0xfffff7ed
    13ac:	13000019 	movwne	r0, #25
    13b0:	0b0b000f 	bleq	2c13f4 <__ROM_SIZE__+0x2813f4>
	ctx->datalen = 0;
    13b4:	24140000 	ldrcs	r0, [r4], #-0
	ctx->bitlen = 0;
    13b8:	3e0b0b00 	vmlacc.f64	d0, d11, d0
    13bc:	0008030b 	andeq	r0, r8, fp, lsl #6
	ctx->state[0] = 0x6a09e667;
    13c0:	01151500 	tsteq	r5, r0, lsl #10
	ctx->state[1] = 0xbb67ae85;
    13c4:	13011927 	movwne	r1, #6439	@ 0x1927
	ctx->state[2] = 0x3c6ef372;
    13c8:	05160000 	ldreq	r0, [r6, #-0]
	ctx->state[3] = 0xa54ff53a;
    13cc:	00134900 	andseq	r4, r3, r0, lsl #18
	ctx->state[4] = 0x510e527f;
    13d0:	00261700 	eoreq	r1, r6, r0, lsl #14
	ctx->state[5] = 0x9b05688c;
    13d4:	00001349 	andeq	r1, r0, r9, asr #6
	ctx->state[6] = 0x1f83d9ab;
    13d8:	03003418 	movweq	r3, #1048	@ 0x418
	ctx->state[7] = 0x5be0cd19;
    13dc:	3b0b3a0e 	blcc	2cfc1c <__ROM_SIZE__+0x28fc1c>
    13e0:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
    13e4:	3c193f13 	ldccc	15, cr3, [r9], {19}
    13e8:	19000019 	stmdbne	r0, {r0, r3, r4}
}
    13ec:	0b3e0104 	bleq	f81804 <__ROM_SIZE__+0xf41804>
    13f0:	13490b0b 	movtne	r0, #39691	@ 0x9b0b
    13f4:	0b3b0b3a 	bleq	ec40e4 <__ROM_SIZE__+0xe840e4>
    13f8:	13010b39 	movwne	r0, #6969	@ 0x1b39
    13fc:	2e1a0000 	cdpcs	0, 1, cr0, cr10, cr0, {0}
    1400:	03193f01 	tsteq	r9, #1, 30
    1404:	3b0b3a0e 	blcc	2cfc44 <__ROM_SIZE__+0x28fc44>
{
    1408:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
    140c:	11134919 	tstne	r3, r9, lsl r9
	for (i = 0; i < len; ++i) {
    1410:	40061201 	andmi	r1, r6, r1, lsl #4
    1414:	01197c18 	tsteq	r9, r8, lsl ip
    1418:	1b000013 	blne	146c <sha256_final+0x24>
		ctx->data[ctx->datalen] = data[i];
    141c:	00000018 	andeq	r0, r0, r8, lsl r0
		ctx->datalen++;
    1420:	7d00481c 	stcvc	8, cr4, [r0, #-112]	@ 0xffffff90
		if (ctx->datalen == 64) {
    1424:	00137f01 	andseq	r7, r3, r1, lsl #30
			sha256_transform(ctx, ctx->data);
    1428:	012e1d00 			@ <UNDEFINED> instruction: 0x012e1d00
    142c:	0b3a0e03 	bleq	e84c40 <__ROM_SIZE__+0xe44c40>
			ctx->bitlen += 512;
    1430:	0b390b3b 	bleq	e44124 <__ROM_SIZE__+0xe04124>
    1434:	13491927 	movtne	r1, #39207	@ 0x9927
    1438:	06120111 			@ <UNDEFINED> instruction: 0x06120111
    143c:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
			ctx->datalen = 0;
    1440:	00001301 	andeq	r1, r0, r1, lsl #6
    1444:	0300341e 	movweq	r3, #1054	@ 0x41e
{
    1448:	3b0b3a08 	blcc	2cfc70 <__ROM_SIZE__+0x28fc70>
    144c:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
	if (ctx->datalen < 56) {
    1450:	00180213 	andseq	r0, r8, r3, lsl r2
		ctx->data[i++] = 0x80;
    1454:	010b1f00 	tsteq	fp, r0, lsl #30
    1458:	06120111 			@ <UNDEFINED> instruction: 0x06120111
			ctx->data[i++] = 0x00;
    145c:	00001301 	andeq	r1, r0, r1, lsl #6
    1460:	55010b20 	strpl	r0, [r1, #-2848]	@ 0xfffff4e0
		while (i < 56)
    1464:	21000017 	tstcs	r0, r7, lsl r0
	ctx->bitlen += ctx->datalen * 8;
    1468:	08030034 	stmdaeq	r3, {r2, r4, r5}
    146c:	0b3b0b3a 	bleq	ec415c <__ROM_SIZE__+0xe8415c>
    1470:	13490b39 	movtne	r0, #39737	@ 0x9b39
    1474:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
	ctx->data[63] = ctx->bitlen;
    1478:	22000017 	andcs	r0, r0, #23
	ctx->data[62] = ctx->bitlen >> 8;
    147c:	0e03012e 	adfeqsp	f0, f3, #0.5
    1480:	0b3b0b3a 	bleq	ec4170 <__ROM_SIZE__+0xe84170>
	ctx->data[61] = ctx->bitlen >> 16;
    1484:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
	ctx->data[60] = ctx->bitlen >> 24;
    1488:	06120111 			@ <UNDEFINED> instruction: 0x06120111
    148c:	197c1840 	ldmdbne	ip!, {r6, fp, ip}^
	ctx->data[59] = ctx->bitlen >> 32;
    1490:	01000000 	mrseq	r0, (UNDEF: 0)
	ctx->data[58] = ctx->bitlen >> 40;
    1494:	18020049 	stmdane	r2, {r0, r3, r6}
	ctx->data[57] = ctx->bitlen >> 48;
    1498:	0000187e 	andeq	r1, r0, lr, ror r8
    149c:	03003402 	movweq	r3, #1026	@ 0x402
	ctx->data[56] = ctx->bitlen >> 56;
    14a0:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
	sha256_transform(ctx, ctx->data);
    14a4:	0b390b3b 	bleq	e44198 <__ROM_SIZE__+0xe04198>
    14a8:	17021349 	strne	r1, [r2, -r9, asr #6]
	for (i = 0; i < 4; ++i) {
    14ac:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
		ctx->data[i++] = 0x80;
    14b0:	00240300 	eoreq	r0, r4, r0, lsl #6
    14b4:	0b3e0b0b 	bleq	f840e8 <__ROM_SIZE__+0xf440e8>
			ctx->data[i++] = 0x00;
    14b8:	00000e03 	andeq	r0, r0, r3, lsl #28
    14bc:	03001604 	movweq	r1, #1540	@ 0x604
		while (i < 64)
    14c0:	3b0b3a0e 	blcc	2cfd00 <__ROM_SIZE__+0x28fd00>
		sha256_transform(ctx, ctx->data);
    14c4:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
    14c8:	05000013 	streq	r0, [r0, #-19]	@ 0xffffffed
		memset(ctx->data, 0, 56);
    14cc:	210b000f 	tstcs	fp, pc
    14d0:	00134904 	andseq	r4, r3, r4, lsl #18
    14d4:	00050600 	andeq	r0, r5, r0, lsl #12
		hash[i]      = (ctx->state[0] >> (24 - i * 8)) & 0x000000ff;
    14d8:	213a0803 	teqcs	sl, r3, lsl #16
    14dc:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
    14e0:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
		hash[i + 4]  = (ctx->state[1] >> (24 - i * 8)) & 0x000000ff;
    14e4:	1742b717 	smlaldne	fp, r2, r7, r7
    14e8:	0b070000 	bleq	1c14f0 <__ROM_SIZE__+0x1814f0>
		hash[i + 8]  = (ctx->state[2] >> (24 - i * 8)) & 0x000000ff;
    14ec:	01175501 	tsteq	r7, r1, lsl #10
    14f0:	08000013 	stmdaeq	r0, {r0, r1, r4}
		hash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0x000000ff;
    14f4:	017d0148 	cmneq	sp, r8, asr #2
    14f8:	0000137f 	andeq	r1, r0, pc, ror r3
    14fc:	7d014809 	stcvc	8, cr4, [r1, #-36]	@ 0xffffffdc
		hash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0x000000ff;
    1500:	0a000001 	beq	150c <sha256_final+0xc4>
    1504:	0e030028 	cdpeq	0, 0, cr0, cr3, cr8, {1}
		hash[i + 20] = (ctx->state[5] >> (24 - i * 8)) & 0x000000ff;
    1508:	00000b1c 	andeq	r0, r0, ip, lsl fp
    150c:	4901010b 	stmdbmi	r1, {r0, r1, r3, r8}
    1510:	00130113 	andseq	r0, r3, r3, lsl r1
		hash[i + 24] = (ctx->state[6] >> (24 - i * 8)) & 0x000000ff;
    1514:	00210c00 	eoreq	r0, r1, r0, lsl #24
    1518:	0b2f1349 	bleq	bc6244 <__ROM_SIZE__+0xb86244>
		hash[i + 28] = (ctx->state[7] >> (24 - i * 8)) & 0x000000ff;
    151c:	340d0000 	strcc	r0, [sp], #-0
    1520:	3a0e0300 	bcc	382128 <__ROM_SIZE__+0x342128>
    1524:	0b3b0121 	bleq	ec19b0 <__ROM_SIZE__+0xe819b0>
	for (i = 0; i < 4; ++i) {
    1528:	13490b39 	movtne	r0, #39737	@ 0x9b39
}
    152c:	00001802 	andeq	r1, r0, r2, lsl #16
static void outstr(const char *str) {
    1530:	0300050e 	movweq	r0, #1294	@ 0x50e
  while (*str != '\0') {
    1534:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
    __write_char__(*str);
    1538:	3930213b 	ldmdbcc	r0!, {r0, r1, r3, r4, r5, r8, sp}
    str++;
    153c:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
  while (*str != '\0') {
    1540:	1742b717 	smlaldne	fp, r2, r7, r7
}
    1544:	480f0000 	stmdami	pc, {}	@ <UNPREDICTABLE>
    1548:	01017d01 	tsteq	r1, r1, lsl #26
static bool printf_numbers(const char fmt, va_list *args, int l_count) {
    154c:	10000013 	andne	r0, r0, r3, lsl r0
    1550:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
  switch (fmt) {
    1554:	0e030b13 	vmoveq.32	d3[0], r0
    1558:	01110e1b 	tsteq	r1, fp, lsl lr
    155c:	17100612 			@ <UNDEFINED> instruction: 0x17100612
      if (l_count == 0) {
    1560:	13110000 	tstne	r1, #0
    1564:	0b0e0301 	bleq	382170 <__ROM_SIZE__+0x342170>
        value = va_arg(*args, unsigned int);
    1568:	3b0b3a0b 	blcc	2cfd9c <__ROM_SIZE__+0x28fd9c>
    156c:	0013010b 	andseq	r0, r3, fp, lsl #2
      if (fmt == 'u') {
    1570:	000d1200 	andeq	r1, sp, r0, lsl #4
        if (value == 0) {
    1574:	13490e03 	movtne	r0, #40451	@ 0x9e03
          __write_char__(hextable[0]);
    1578:	19340b38 	ldmdbne	r4!, {r3, r4, r5, r8, r9, fp}
    157c:	0f130000 	svceq	0x00130000
  return true;
    1580:	000b0b00 	andeq	r0, fp, r0, lsl #22
  switch (fmt) {
    1584:	00241400 	eoreq	r1, r4, r0, lsl #8
      outstr("\nprintf-error\n");
    1588:	0b3e0b0b 	bleq	f841bc <__ROM_SIZE__+0xf441bc>
      return false;
    158c:	00000803 	andeq	r0, r0, r3, lsl #16
}
    1590:	27011515 	smladcs	r1, r5, r5, r1
      if (l_count == 0) {
    1594:	00130119 	andseq	r0, r3, r9, lsl r1
        value = va_arg(*args, int);
    1598:	00051600 	andeq	r1, r5, r0, lsl #12
    159c:	00001349 	andeq	r1, r0, r9, asr #6
      if (value < 0) {
    15a0:	49002617 	stmdbmi	r0, {r0, r1, r2, r4, r9, sl, sp}
        num[num_len++] = hextable[value % 10];
    15a4:	18000013 	stmdane	r0, {r0, r1, r4}
    15a8:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    15ac:	0b3b0b3a 	bleq	ec429c <__ROM_SIZE__+0xe8429c>
    15b0:	13490b39 	movtne	r0, #39737	@ 0x9b39
    15b4:	193c193f 	ldmdbne	ip!, {r0, r1, r2, r3, r4, r5, r8, fp, ip}
    15b8:	04190000 	ldreq	r0, [r9], #-0
    15bc:	0b0b3e01 	bleq	2d0dc8 <__ROM_SIZE__+0x290dc8>
    15c0:	3a13490b 	bcc	4d39f4 <__ROM_SIZE__+0x4939f4>
    15c4:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
        value = value / 10;
    15c8:	0013010b 	andseq	r0, r3, fp, lsl #2
      } while (value > 0);
    15cc:	012e1a00 			@ <UNDEFINED> instruction: 0x012e1a00
    15d0:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
        __write_char__('-');
    15d4:	0b3b0b3a 	bleq	ec42c4 <__ROM_SIZE__+0xe842c4>
    15d8:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
        value = -value;
    15dc:	01111349 	tsteq	r1, r9, asr #6
        __write_char__(num[--num_len]);
    15e0:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
    15e4:	1301197c 	movwne	r1, #6524	@ 0x197c
    15e8:	181b0000 	ldmdane	fp, {}	@ <UNPREDICTABLE>
    15ec:	1c000000 	stcne	0, cr0, [r0], {-0}
    15f0:	017d0048 	cmneq	sp, r8, asr #32
      while (num_len > 0) {
    15f4:	0000137f 	andeq	r1, r0, pc, ror r3
  return true;
    15f8:	03012e1d 	movweq	r2, #7709	@ 0x1e1d
          num[num_len++] = hextable[value % 10];
    15fc:	3b0b3a0e 	blcc	2cfe3c <__ROM_SIZE__+0x28fe3c>
    1600:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
    1604:	11134919 	tstne	r3, r9, lsl r9
    1608:	40061201 	andmi	r1, r6, r1, lsl #4
    160c:	01197a18 	tsteq	r9, r8, lsl sl
    1610:	1e000013 	mcrne	0, 0, r0, cr0, cr3, {0}
    1614:	08030034 	stmdaeq	r3, {r2, r4, r5}
    1618:	0b3b0b3a 	bleq	ec4308 <__ROM_SIZE__+0xe84308>
          value = value / 10;
    161c:	13490b39 	movtne	r0, #39737	@ 0x9b39
        } while (value > 0);
    1620:	00001802 	andeq	r1, r0, r2, lsl #16
        while (num_len > 0) {
    1624:	11010b1f 	tstne	r1, pc, lsl fp
          __write_char__(num[--num_len]);
    1628:	01061201 	tsteq	r6, r1, lsl #4
    162c:	20000013 	andcs	r0, r0, r3, lsl r0
    1630:	1755010b 	ldrbne	r0, [r5, -fp, lsl #2]
    1634:	34210000 	strtcc	r0, [r1], #-0
    1638:	3a080300 	bcc	202240 <__ROM_SIZE__+0x1c2240>
    163c:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
  return true;
    1640:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
              __write_char__(hextable[val]);
    1644:	1742b717 	smlaldne	fp, r2, r7, r7
    1648:	2e220000 	cdpcs	0, 2, cr0, cr2, cr0, {0}
              leading_zero_ignored = true;
    164c:	3a0e0301 	bcc	382258 <__ROM_SIZE__+0x342258>
          while (start_bit >= 0) {
    1650:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
            int val = (value >> start_bit) & 0xF;
    1654:	1119270b 	tstne	r9, fp, lsl #14
            if (val || leading_zero_ignored) {
    1658:	40061201 	andmi	r1, r6, r1, lsl #4
    165c:	00197c18 	andseq	r7, r9, r8, lsl ip
    1660:	34010000 	strcc	r0, [r1], #-0
          bool leading_zero_ignored = false;
    1664:	3a0e0300 	bcc	38226c <__ROM_SIZE__+0x34226c>
          int start_bit = LAST_NIBBLE_FIRST_BIT;
    1668:	0b3b0121 	bleq	ec1af4 <__ROM_SIZE__+0xe81af4>
  return true;
    166c:	13490b39 	movtne	r0, #39737	@ 0x9b39
        return false;
    1670:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
        return false;
    1674:	02000017 	andeq	r0, r0, #23
    1678:	18020049 	stmdane	r2, {r0, r3, r6}
    167c:	0000187e 	andeq	r1, r0, lr, ror r8
    1680:	0b002403 	bleq	a694 <__RAM_SIZE__+0x2694>
    1684:	030b3e0b 	movweq	r3, #48651	@ 0xbe0b
    1688:	0400000e 	streq	r0, [r0], #-14
int printf(const char *fmt, ...) {
    168c:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
    1690:	3b01213a 	blcc	49b80 <__ROM_SIZE__+0x9b80>
    1694:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
  va_start(args, fmt);
    1698:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
  while (*fmt) {
    169c:	00001742 	andeq	r1, r0, r2, asr #14
        if (*fmt == '%') {
    16a0:	7d004805 	stcvc	8, cr4, [r0, #-20]	@ 0xffffffec
        __write_char__(*fmt);
    16a4:	00137f01 	andseq	r7, r3, r1, lsl #30
        fmt++;
    16a8:	01480600 	cmpeq	r8, r0, lsl #12
  while (*fmt) {
    16ac:	137f017d 	cmnne	pc, #1073741855	@ 0x4000001f
    switch (state) {
    16b0:	05070000 	streq	r0, [r7, #-0]
    16b4:	00134900 	andseq	r4, r3, r0, lsl #18
          fmt++;
    16b8:	00340800 	eorseq	r0, r4, r0, lsl #16
          continue;
    16bc:	213a0e03 	teqcs	sl, r3, lsl #28
        while (*fmt && ((*fmt >= '0' && *fmt <= '9') || *fmt == '-')) {
    16c0:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
    16c4:	13490121 	movtne	r0, #37153	@ 0x9121
    16c8:	1802193f 	stmdane	r2, {r0, r1, r2, r3, r4, r5, r8, fp, ip}
    16cc:	48090000 	stmdami	r9, {}	@ <UNPREDICTABLE>
    16d0:	7f017d01 	svcvc	0x00017d01
        switch (*fmt) {
    16d4:	00130113 	andseq	r0, r3, r3, lsl r1
    16d8:	000f0a00 	andeq	r0, pc, r0, lsl #20
    16dc:	4904210b 	stmdbmi	r4, {r0, r1, r3, r8, sp}
    16e0:	0b000013 	bleq	1734 <printf+0xa8>
            __write_char__(*fmt);
    16e4:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
    16e8:	0b3b0b3a 	bleq	ec43d8 <__ROM_SIZE__+0xe843d8>
            state = CHECK_CH;
    16ec:	13490b39 	movtne	r0, #39737	@ 0x9b39
            break;
    16f0:	0d0c0000 	stceq	0, cr0, [ip, #-0]
    16f4:	3a0e0300 	bcc	3822fc <__ROM_SIZE__+0x3422fc>
            outstr(va_arg(args, const char *));
    16f8:	0b3b0321 	bleq	ec2384 <__ROM_SIZE__+0xe82384>
    16fc:	13490b39 	movtne	r0, #39737	@ 0x9b39
    1700:	00000b38 	andeq	r0, r0, r8, lsr fp
            fmt++;
    1704:	3f012e0d 	svccc	0x00012e0d
            break;
    1708:	3a0e0319 	bcc	382374 <__ROM_SIZE__+0x342374>
            __write_char__(va_arg(args, int));
    170c:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    1710:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
    1714:	01193c13 	tsteq	r9, r3, lsl ip
            fmt++;
    1718:	0e000013 	mcreq	0, 0, r0, cr0, cr3, {0}
            break;
    171c:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
            if (*fmt == 'l') {
    1720:	213a0e03 	teqcs	sl, r3, lsl #28
    1724:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
            if (printf_numbers(*fmt, &args, l_count)) {
    1728:	19270521 	stmdbne	r7!, {r0, r5, r8, sl}
    172c:	01111349 	tsteq	r1, r9, asr #6
    1730:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
              state = CHECK_CH;
    1734:	1301197a 	movwne	r1, #6522	@ 0x197a
              fmt++;
    1738:	0a0f0000 	beq	3c1740 <__ROM_SIZE__+0x381740>
              l_count++;
    173c:	3a0e0300 	bcc	382344 <__ROM_SIZE__+0x342344>
            if (printf_numbers(*fmt, &args, 0)) {
    1740:	0b3b0121 	bleq	ec1bcc <__ROM_SIZE__+0xe81bcc>
    1744:	11012139 	tstne	r1, r9, lsr r1
              fmt++;
    1748:	10000001 	andne	r0, r0, r1
              break;
    174c:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
            return -1;
    1750:	0e030b13 	vmoveq.32	d3[0], r0
}
    1754:	01110e1b 	tsteq	r1, fp, lsl lr
    1758:	17100612 			@ <UNDEFINED> instruction: 0x17100612
            return -1;
    175c:	24110000 	ldrcs	r0, [r1], #-0
    1760:	3e0b0b00 	vmlacc.f64	d0, d11, d0
    1764:	0008030b 	andeq	r0, r8, fp, lsl #6
static void outstr2(const char *str) {
    1768:	00161200 	andseq	r1, r6, r0, lsl #4
  while (*str != '\0') {
    176c:	0b3a0803 	bleq	e83780 <__ROM_SIZE__+0xe43780>
    __write_char2__(*str);
    1770:	0b390b3b 	bleq	e44464 <__ROM_SIZE__+0xe04464>
    str++;
    1774:	00001349 	andeq	r1, r0, r9, asr #6
  while (*str != '\0') {
    1778:	27011513 	smladcs	r1, r3, r5, r1
}
    177c:	01134919 	tsteq	r3, r9, lsl r9
    1780:	14000013 	strne	r0, [r0], #-19	@ 0xffffffed
static bool printf2_numbers(const char fmt, va_list *args, int l_count) {
    1784:	13490026 	movtne	r0, #36902	@ 0x9026
    1788:	13150000 	tstne	r5, #0
  switch (fmt) {
    178c:	3a0b0b01 	bcc	2c4398 <__ROM_SIZE__+0x284398>
    1790:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    1794:	0013010b 	andseq	r0, r3, fp, lsl #2
      if (l_count == 0) {
    1798:	00181600 	andseq	r1, r8, r0, lsl #12
    179c:	0b170000 	bleq	5c17a4 <__ROM_SIZE__+0x5817a4>
        value = va_arg(*args, unsigned int);
    17a0:	01175501 	tsteq	r7, r1, lsl #10
    17a4:	18000013 	stmdane	r0, {r0, r1, r4}
      if (fmt == 'u') {
    17a8:	08030034 	stmdaeq	r3, {r2, r4, r5}
        if (value == 0) {
    17ac:	0b3b0b3a 	bleq	ec449c <__ROM_SIZE__+0xe8449c>
          __write_char2__(hextable2[0]);
    17b0:	13490b39 	movtne	r0, #39737	@ 0x9b39
    17b4:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
  return true;
    17b8:	19000017 	stmdbne	r0, {r0, r1, r2, r4}
  switch (fmt) {
    17bc:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
      outstr2("\nprintf2-error\n");
    17c0:	0b3a0803 	bleq	e837d4 <__ROM_SIZE__+0xe437d4>
      return false;
    17c4:	0b390b3b 	bleq	e444b8 <__ROM_SIZE__+0xe044b8>
}
    17c8:	13491927 	movtne	r1, #39207	@ 0x9927
      if (l_count == 0) {
    17cc:	06120111 			@ <UNDEFINED> instruction: 0x06120111
        value = va_arg(*args, int);
    17d0:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
    17d4:	00001301 	andeq	r1, r0, r1, lsl #6
      if (value < 0) {
    17d8:	3f012e1a 	svccc	0x00012e1a
        num[num_len++] = hextable2[value % 10];
    17dc:	3a080319 	bcc	202448 <__ROM_SIZE__+0x1c2448>
    17e0:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    17e4:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
    17e8:	12011113 	andne	r1, r1, #-1073741820	@ 0xc0000004
    17ec:	7a184006 	bvc	61180c <__ROM_SIZE__+0x5d180c>
    17f0:	00000019 	andeq	r0, r0, r9, lsl r0
    17f4:	02004901 	andeq	r4, r0, #16384	@ 0x4000
    17f8:	00187e18 	andseq	r7, r8, r8, lsl lr
    17fc:	01480200 	mrseq	r0, (UNDEF: 104)
        value = value / 10;
    1800:	137f017d 	cmnne	pc, #1073741855	@ 0x4000001f
      } while (value > 0);
    1804:	00001301 	andeq	r1, r0, r1, lsl #6
    1808:	03003403 	movweq	r3, #1027	@ 0x403
        __write_char2__('-');
    180c:	01213a08 			@ <UNDEFINED> instruction: 0x01213a08
    1810:	0b39053b 	bleq	e42d04 <__ROM_SIZE__+0xe02d04>
        value = -value;
    1814:	17021349 	strne	r1, [r2, -r9, asr #6]
        __write_char2__(num[--num_len]);
    1818:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
    181c:	01480400 	cmpeq	r8, r0, lsl #8
    1820:	137f017d 	cmnne	pc, #1073741855	@ 0x4000001f
    1824:	05050000 	streq	r0, [r5, #-0]
    1828:	3a080300 	bcc	202430 <__ROM_SIZE__+0x1c2430>
      while (num_len > 0) {
    182c:	053b0121 	ldreq	r0, [fp, #-289]!	@ 0xfffffedf
  return true;
    1830:	13490b39 	movtne	r0, #39737	@ 0x9b39
          num[num_len++] = hextable2[value % 10];
    1834:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
    1838:	06000017 			@ <UNDEFINED> instruction: 0x06000017
    183c:	0b0b0024 	bleq	2c18d4 <__ROM_SIZE__+0x2818d4>
    1840:	0e030b3e 	vmoveq.16	d3[0], r0
    1844:	05070000 	streq	r0, [r7, #-0]
    1848:	3a0e0300 	bcc	382450 <__ROM_SIZE__+0x342450>
    184c:	053b0121 	ldreq	r0, [fp, #-289]!	@ 0xfffffedf
    1850:	13490b39 	movtne	r0, #39737	@ 0x9b39
          value = value / 10;
    1854:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
        } while (value > 0);
    1858:	08000017 	stmdaeq	r0, {r0, r1, r2, r4}
        while (num_len > 0) {
    185c:	0e03012e 	adfeqsp	f0, f3, #0.5
          __write_char2__(num[--num_len]);
    1860:	3b01213a 	blcc	49d50 <__ROM_SIZE__+0x9d50>
    1864:	0d213905 			@ <UNDEFINED> instruction: 0x0d213905
    1868:	01111927 	tsteq	r1, r7, lsr #18
    186c:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
    1870:	1301197a 	movwne	r1, #6522	@ 0x197a
    1874:	05090000 	streq	r0, [r9, #-0]
  return true;
    1878:	3a080300 	bcc	202480 <__ROM_SIZE__+0x1c2480>
              __write_char2__(hextable2[val]);
    187c:	0b3b0121 	bleq	ec1d08 <__ROM_SIZE__+0xe81d08>
    1880:	13490b39 	movtne	r0, #39737	@ 0x9b39
              leading_zero_ignored = true;
    1884:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
          while (start_bit >= 0) {
    1888:	0a000017 	beq	18ec <printf2+0x28>
            int val = (value >> start_bit) & 0xF;
    188c:	13490021 	movtne	r0, #36897	@ 0x9021
            if (val || leading_zero_ignored) {
    1890:	00000b2f 	andeq	r0, r0, pc, lsr #22
    1894:	0300340b 	movweq	r3, #1035	@ 0x40b
    1898:	01213a08 			@ <UNDEFINED> instruction: 0x01213a08
          bool leading_zero_ignored = false;
    189c:	0b390b3b 	bleq	e44590 <__ROM_SIZE__+0xe04590>
          int start_bit = LAST_NIBBLE_FIRST_BIT;
    18a0:	17021349 	strne	r1, [r2, -r9, asr #6]
  return true;
    18a4:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
        return false;
    18a8:	000f0c00 	andeq	r0, pc, r0, lsl #24
        return false;
    18ac:	4904210b 	stmdbmi	r4, {r0, r1, r3, r8, sp}
    18b0:	0d000013 	stceq	0, cr0, [r0, #-76]	@ 0xffffffb4
    18b4:	13490101 	movtne	r0, #37121	@ 0x9101
    18b8:	00001301 	andeq	r1, r0, r1, lsl #6
    18bc:	3f012e0e 	svccc	0x00012e0e
    18c0:	3a0e0319 	bcc	38252c <__ROM_SIZE__+0x34252c>
int printf2(const char *fmt, ...) {
    18c4:	053b0121 	ldreq	r0, [fp, #-289]!	@ 0xfffffedf
    18c8:	27062139 	smladxcs	r6, r9, r1, r2
    18cc:	12011119 	andne	r1, r1, #1073741830	@ 0x40000006
  va_start(args, fmt);
    18d0:	7a184006 	bvc	6118f0 <__ROM_SIZE__+0x5d18f0>
  while (*fmt) {
    18d4:	00130119 	andseq	r0, r3, r9, lsl r1
        if (*fmt == '%') {
    18d8:	00050f00 	andeq	r0, r5, r0, lsl #30
        __write_char2__(*fmt);
    18dc:	213a0e03 	teqcs	sl, r3, lsl #28
        fmt++;
    18e0:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
  while (*fmt) {
    18e4:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
    switch (state) {
    18e8:	10000018 	andne	r0, r0, r8, lsl r0
    18ec:	13490026 	movtne	r0, #36902	@ 0x9026
          fmt++;
    18f0:	34110000 	ldrcc	r0, [r1], #-0
          continue;
    18f4:	3a0e0300 	bcc	3824fc <__ROM_SIZE__+0x3424fc>
        while (*fmt && ((*fmt >= '0' && *fmt <= '9') || *fmt == '-')) {
    18f8:	0b3b0121 	bleq	ec1d84 <__ROM_SIZE__+0xe81d84>
    18fc:	13490b39 	movtne	r0, #39737	@ 0x9b39
    1900:	00001802 	andeq	r1, r0, r2, lsl #16
    1904:	03003412 	movweq	r3, #1042	@ 0x412
    1908:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
        switch (*fmt) {
    190c:	2139053b 	teqcs	r9, fp, lsr r5
    1910:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
    1914:	1742b717 	smlaldne	fp, r2, r7, r7
    1918:	16130000 	ldrne	r0, [r3], -r0
            __write_char2__(*fmt);
    191c:	3a0e0300 	bcc	382524 <__ROM_SIZE__+0x342524>
    1920:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
            state = CHECK_CH;
    1924:	0013490b 	andseq	r4, r3, fp, lsl #18
            break;
    1928:	00051400 	andeq	r1, r5, r0, lsl #8
    192c:	00001349 	andeq	r1, r0, r9, asr #6
            outstr2(va_arg(args, const char *));
    1930:	03000515 	movweq	r0, #1301	@ 0x515
    1934:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
    1938:	0b39053b 	bleq	e42e2c <__ROM_SIZE__+0xe02e2c>
            fmt++;
    193c:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
            break;
    1940:	2e160000 	cdpcs	0, 1, cr0, cr6, cr0, {0}
            __write_char2__(va_arg(args, int));
    1944:	3a0e0301 	bcc	382550 <__ROM_SIZE__+0x342550>
    1948:	0b3b0121 	bleq	ec1dd4 <__ROM_SIZE__+0xe81dd4>
    194c:	270d2139 	smladxcs	sp, r9, r1, r2
            fmt++;
    1950:	12011119 	andne	r1, r1, #1073741830	@ 0x40000006
            break;
    1954:	7a184006 	bvc	611974 <__ROM_SIZE__+0x5d1974>
            if (*fmt == 'l') {
    1958:	00130119 	andseq	r0, r3, r9, lsl r1
    195c:	012e1700 			@ <UNDEFINED> instruction: 0x012e1700
            if (printf2_numbers(*fmt, &args, l_count)) {
    1960:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
    1964:	3b01213a 	blcc	49e54 <__ROM_SIZE__+0x9e54>
    1968:	0621390b 	strteq	r3, [r1], -fp, lsl #18
              state = CHECK_CH;
    196c:	01111927 	tsteq	r1, r7, lsr #18
              fmt++;
    1970:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
              l_count++;
    1974:	1301197a 	movwne	r1, #6522	@ 0x197a
            if (printf2_numbers(*fmt, &args, 0)) {
    1978:	34180000 	ldrcc	r0, [r8], #-0
    197c:	3a0e0300 	bcc	382584 <__ROM_SIZE__+0x342584>
              fmt++;
    1980:	053b0121 	ldreq	r0, [fp, #-289]!	@ 0xfffffedf
              break;
    1984:	490b2139 	stmdbmi	fp, {r0, r3, r4, r5, r8, sp}
            return -1;
    1988:	00180213 	andseq	r0, r8, r3, lsl r2
}
    198c:	00051900 	andeq	r1, r5, r0, lsl #18
    1990:	213a0803 	teqcs	sl, r3, lsl #16
            return -1;
    1994:	ec213b01 			@ <UNDEFINED> instruction: 0xec213b01
    1998:	490b3903 	stmdbmi	fp, {r0, r1, r8, fp, ip, sp}
    199c:	00180213 	andseq	r0, r8, r3, lsl r2
int r32(int argc, char *argv[]) {
    19a0:	01111a00 	tsteq	r1, r0, lsl #20
  if (argc < 2) {
    19a4:	0b130e25 	bleq	4c5240 <__ROM_SIZE__+0x485240>
  uint32_t addr = atoh(argv[1]);
    19a8:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
    19ac:	06120111 			@ <UNDEFINED> instruction: 0x06120111
  printf("0x%x: 0x%x\n", addr, data);
    19b0:	00001710 	andeq	r1, r0, r0, lsl r7
    19b4:	0b00241b 	bleq	aa28 <__RAM_SIZE__+0x2a28>
}
    19b8:	030b3e0b 	movweq	r3, #48651	@ 0xbe0b
    printf("Usage: %s <address> (in hex)\n", argv[0]);
    19bc:	1c000008 	stcne	0, cr0, [r0], {8}
    19c0:	0e030113 	mcreq	1, 0, r0, cr3, cr3, {0}
    return -1;
    19c4:	0b3a050b 	bleq	e82df8 <__ROM_SIZE__+0xe42df8>
    19c8:	0b390b3b 	bleq	e446bc <__ROM_SIZE__+0xe046bc>
    19cc:	00001301 	andeq	r1, r0, r1, lsl #6
int w32(int argc, char *argv[]) {
    19d0:	03000d1d 	movweq	r0, #3357	@ 0xd1d
  if (argc < 3) {
    19d4:	3b0b3a0e 	blcc	2d0214 <__ROM_SIZE__+0x290214>
  uint32_t addr = atoh(argv[1]);
    19d8:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
    19dc:	000b3813 	andeq	r3, fp, r3, lsl r8
  uint32_t data = atoh(argv[2]);
    19e0:	000d1e00 	andeq	r1, sp, r0, lsl #28
    19e4:	0b3a0803 	bleq	e839f8 <__ROM_SIZE__+0xe439f8>
  return 0;
    19e8:	0b390b3b 	bleq	e446dc <__ROM_SIZE__+0xe046dc>
    printf("Usage: %s <address> (in hex) <value> (in hex)\n", argv[0]);
    19ec:	0b381349 	bleq	e06718 <__ROM_SIZE__+0xdc6718>
    19f0:	2e1f0000 	cdpcs	0, 1, cr0, cr15, cr0, {0}
    return -1;
    19f4:	03193f01 	tsteq	r9, #1, 30
    19f8:	3b0b3a0e 	blcc	2d0238 <__ROM_SIZE__+0x290238>
    19fc:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
int read_mem(int argc, char *argv[]) {
    1a00:	3c134919 			@ <UNDEFINED> instruction: 0x3c134919
  if (argc < 3) {
    1a04:	00130119 	andseq	r0, r3, r9, lsl r1
  uint32_t addr = atoh(argv[1]);
    1a08:	000f2000 	andeq	r2, pc, r0
    1a0c:	00000b0b 	andeq	r0, r0, fp, lsl #22
  uint32_t length = atoi(argv[2]);
    1a10:	00002621 	andeq	r2, r0, r1, lsr #12
    1a14:	012e2200 			@ <UNDEFINED> instruction: 0x012e2200
  for (uint32_t i = 0, data = 0; i < length; i++) {
    1a18:	0b3a0e03 	bleq	e8522c <__ROM_SIZE__+0xe4522c>
    printf("Usage: %s <address> (in hex) <num_words> (in decimal)\n", argv[0]);
    1a1c:	0b39053b 	bleq	e42f10 <__ROM_SIZE__+0xe02f10>
    1a20:	13491927 	movtne	r1, #39207	@ 0x9927
    return -1;
    1a24:	06120111 			@ <UNDEFINED> instruction: 0x06120111
    1a28:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
    printf("0x%x: 0x%x\n", addr, data);
    1a2c:	00001301 	andeq	r1, r0, r1, lsl #6
    1a30:	11010b23 	tstne	r1, r3, lsr #22
    addr += 4;
    1a34:	00061201 	andeq	r1, r6, r1, lsl #4
  for (uint32_t i = 0, data = 0; i < length; i++) {
    1a38:	00342400 	eorseq	r2, r4, r0, lsl #8
  return 0;
    1a3c:	0b3a0e03 	bleq	e85250 <__ROM_SIZE__+0xe45250>
}
    1a40:	0b390b3b 	bleq	e44734 <__ROM_SIZE__+0xe04734>
    1a44:	17021349 	strne	r1, [r2, -r9, asr #6]
{
    1a48:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
  if (argc < 4) {
    1a4c:	01012500 	tsteq	r1, r0, lsl #10
  uint32_t addr = atoh(argv[1]);
    1a50:	00001349 	andeq	r1, r0, r9, asr #6
    1a54:	00490100 	subeq	r0, r9, r0, lsl #2
  uint32_t bit_loc = atoi(argv[2]);
    1a58:	187e1802 	ldmdane	lr!, {r1, fp, ip}^
    1a5c:	48020000 	stmdami	r2, {}	@ <UNPREDICTABLE>
  uint32_t bit_val = atoi(argv[3]);
    1a60:	7f017d01 	svcvc	0x00017d01
    1a64:	00130113 	andseq	r0, r3, r3, lsl r1
  if (bit_loc > 31) {
    1a68:	00050300 	andeq	r0, r5, r0, lsl #6
  if (bit_val != 0 && bit_val != 1) {
    1a6c:	213a0803 	teqcs	sl, r3, lsl #16
  data = data | (bit_val << bit_loc);
    1a70:	39053b01 	stmdbcc	r5, {r0, r8, r9, fp, ip, sp}
    1a74:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
  data = data & ~(!bit_val << bit_loc);
    1a78:	1742b717 	smlaldne	fp, r2, r7, r7
    1a7c:	48040000 	stmdami	r4, {}	@ <UNPREDICTABLE>
    1a80:	7f017d01 	svcvc	0x00017d01
  return 0;
    1a84:	05000013 	streq	r0, [r0, #-19]	@ 0xffffffed
    printf("Error: Invalid bit location argument\n");
    1a88:	08030034 	stmdaeq	r3, {r2, r4, r5}
    1a8c:	3b01213a 	blcc	49f7c <__ROM_SIZE__+0x9f7c>
    printf("Error: Invalid bit value argument\n");
    1a90:	490b3905 	stmdbmi	fp, {r0, r2, r8, fp, ip, sp}
    1a94:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
  printf("Usage: %s <address_in_hex(32-bits)> <bit_location_in_decimal(0 to 31)> <bit_value(0 or 1)>\n", argv[0]);
    1a98:	00001742 	andeq	r1, r0, r2, asr #14
    1a9c:	03003406 	movweq	r3, #1030	@ 0x406
  return -1;
    1aa0:	01213a08 			@ <UNDEFINED> instruction: 0x01213a08
    1aa4:	0b39053b 	bleq	e42f98 <__ROM_SIZE__+0xe02f98>
    1aa8:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
    1aac:	2e070000 	cdpcs	0, 0, cr0, cr7, cr0, {0}
{
    1ab0:	3a0e0301 	bcc	3826bc <__ROM_SIZE__+0x3426bc>
  if (argc < 3) {
    1ab4:	053b0121 	ldreq	r0, [fp, #-289]!	@ 0xfffffedf
  uint32_t addr = atoh(argv[1]);
    1ab8:	270d2139 	smladxcs	sp, r9, r1, r2
    1abc:	12011119 	andne	r1, r1, #1073741830	@ 0x40000006
  uint32_t bit_loc = atoi(argv[2]);
    1ac0:	7a184006 	bvc	611ae0 <__ROM_SIZE__+0x5d1ae0>
    1ac4:	00130119 	andseq	r0, r3, r9, lsl r1
  if (bit_loc > 31) {
    1ac8:	00240800 	eoreq	r0, r4, r0, lsl #16
  uint32_t data = reg32(addr);
    1acc:	0b3e0b0b 	bleq	f84700 <__ROM_SIZE__+0xf44700>
  printf("Bit %u @ 0x%08x: %u\n", bit_loc, addr, bit_val);
    1ad0:	00000e03 	andeq	r0, r0, r3, lsl #28
    1ad4:	03000509 	movweq	r0, #1289	@ 0x509
    1ad8:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
  return 0;
    1adc:	0b39053b 	bleq	e42fd0 <__ROM_SIZE__+0xe02fd0>
    printf("Error: Invalid bit location argument\n");
    1ae0:	17021349 	strne	r1, [r2, -r9, asr #6]
    1ae4:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
  printf("Usage: %s <address_in_hex(32-bits)> <bit_location_in_decimal(0 to 31)\n", argv[0]);
    1ae8:	00050a00 	andeq	r0, r5, r0, lsl #20
    1aec:	213a0803 	teqcs	sl, r3, lsl #16
  return -1;
    1af0:	39053b01 	stmdbcc	r5, {r0, r8, r9, fp, ip, sp}
    1af4:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
    1af8:	0b000018 	bleq	1b60 <KeyExpansion+0x60>
    1afc:	08030005 	stmdaeq	r3, {r0, r2}
{
    1b00:	3b01213a 	blcc	49ff0 <__ROM_SIZE__+0x9ff0>
  for (i = 0; i < Nk; ++i)
    1b04:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
    RoundKey[(i * 4) + 0] = Key[(i * 4) + 0];
    1b08:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
    1b0c:	00001742 	andeq	r1, r0, r2, asr #14
    1b10:	0300340c 	movweq	r3, #1036	@ 0x40c
    RoundKey[(i * 4) + 1] = Key[(i * 4) + 1];
    1b14:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
    RoundKey[(i * 4) + 2] = Key[(i * 4) + 2];
    1b18:	21390b3b 	teqcs	r9, fp, lsr fp
    1b1c:	3f134911 	svccc	0x00134911
    RoundKey[(i * 4) + 3] = Key[(i * 4) + 3];
    1b20:	00180219 	andseq	r0, r8, r9, lsl r2
  for (i = 0; i < Nk; ++i)
    1b24:	012e0d00 			@ <UNDEFINED> instruction: 0x012e0d00
    1b28:	213a0e03 	teqcs	sl, r3, lsl #28
  for (i = Nk; i < Nb * (Nr + 1); ++i)
    1b2c:	39053b01 	stmdbcc	r5, {r0, r8, r9, fp, ip, sp}
    if (i % Nk == 4)
    1b30:	19270c21 	stmdbne	r7!, {r0, r5, sl, fp}
    j = i * 4; k=(i - Nk) * 4;
    1b34:	01111349 	tsteq	r1, r9, asr #6
    RoundKey[j + 0] = RoundKey[k + 0] ^ tempa[0];
    1b38:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
    1b3c:	1301197a 	movwne	r1, #6522	@ 0x197a
    1b40:	050e0000 	streq	r0, [lr, #-0]
    1b44:	3a080300 	bcc	20274c <__ROM_SIZE__+0x1c274c>
    RoundKey[j + 1] = RoundKey[k + 1] ^ tempa[1];
    1b48:	0b3b0121 	bleq	ec1fd4 <__ROM_SIZE__+0xe81fd4>
    1b4c:	13490b39 	movtne	r0, #39737	@ 0x9b39
    1b50:	00001802 	andeq	r1, r0, r2, lsl #16
    1b54:	0300160f 	movweq	r1, #1551	@ 0x60f
    1b58:	3b0b3a0e 	blcc	2d0398 <__ROM_SIZE__+0x290398>
    1b5c:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
    RoundKey[j + 2] = RoundKey[k + 2] ^ tempa[2];
    1b60:	10000013 	andne	r0, r0, r3, lsl r0
    1b64:	0111010b 	tsteq	r1, fp, lsl #2
    1b68:	13010612 	movwne	r0, #5650	@ 0x1612
    1b6c:	0f110000 	svceq	0x00110000
    RoundKey[j + 3] = RoundKey[k + 3] ^ tempa[3];
    1b70:	04210b00 	strteq	r0, [r1], #-2816	@ 0xfffff500
    1b74:	00001349 	andeq	r1, r0, r9, asr #6
    1b78:	03003412 	movweq	r3, #1042	@ 0x412
  for (i = Nk; i < Nb * (Nr + 1); ++i)
    1b7c:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
    1b80:	0b39053b 	bleq	e43074 <__ROM_SIZE__+0xe03074>
      tempa[0]=RoundKey[k + 0];
    1b84:	17021349 	strne	r1, [r2, -r9, asr #6]
    1b88:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
      tempa[1]=RoundKey[k + 1];
    1b8c:	012e1300 			@ <UNDEFINED> instruction: 0x012e1300
    1b90:	213a0e03 	teqcs	sl, r3, lsl #28
    1b94:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
      tempa[2]=RoundKey[k + 2];
    1b98:	19270d21 	stmdbne	r7!, {r0, r5, r8, sl, fp}
    1b9c:	06120111 			@ <UNDEFINED> instruction: 0x06120111
      tempa[3]=RoundKey[k + 3];
    1ba0:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
    1ba4:	00001301 	andeq	r1, r0, r1, lsl #6
    if (i % Nk == 0)
    1ba8:	49002614 	stmdbmi	r0, {r2, r4, r9, sl, sp}
        tempa[0] = tempa[1];
    1bac:	15000013 	strne	r0, [r0, #-19]	@ 0xffffffed
        tempa[1] = tempa[2];
    1bb0:	08030034 	stmdaeq	r3, {r2, r4, r5}
        tempa[2] = tempa[3];
    1bb4:	3b01213a 	blcc	4a0a4 <__ROM_SIZE__+0xa0a4>
        tempa[3] = u8tmp;
    1bb8:	0721390b 	streq	r3, [r1, -fp, lsl #18]!
        tempa[0] = getSBoxValue(tempa[0]);
    1bbc:	17021349 	strne	r1, [r2, -r9, asr #6]
    1bc0:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
        tempa[1] = getSBoxValue(tempa[1]);
    1bc4:	012e1600 			@ <UNDEFINED> instruction: 0x012e1600
    1bc8:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
        tempa[2] = getSBoxValue(tempa[2]);
    1bcc:	3b01213a 	blcc	4a0bc <__ROM_SIZE__+0xa0bc>
    1bd0:	05213905 	streq	r3, [r1, #-2309]!	@ 0xfffff6fb
        tempa[3] = getSBoxValue(tempa[3]);
    1bd4:	13491927 	movtne	r1, #39207	@ 0x9927
    1bd8:	06120111 			@ <UNDEFINED> instruction: 0x06120111
      tempa[0] = tempa[0] ^ Rcon[i/Nk];
    1bdc:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
    1be0:	00001301 	andeq	r1, r0, r1, lsl #6
    1be4:	03003417 	movweq	r3, #1047	@ 0x417
    1be8:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
        tempa[0] = getSBoxValue(tempa[0]);
    1bec:	04f6213b 	ldrbteq	r2, [r6], #315	@ 0x13b
    1bf0:	13490b39 	movtne	r0, #39737	@ 0x9b39
    1bf4:	00001802 	andeq	r1, r0, r2, lsl #16
        tempa[1] = getSBoxValue(tempa[1]);
    1bf8:	55010b18 	strpl	r0, [r1, #-2840]	@ 0xfffff4e8
    1bfc:	19000017 	stmdbne	r0, {r0, r1, r2, r4}
        tempa[2] = getSBoxValue(tempa[2]);
    1c00:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
    1c04:	0e030b13 	vmoveq.32	d3[0], r0
    1c08:	01110e1b 	tsteq	r1, fp, lsl lr
        tempa[3] = getSBoxValue(tempa[3]);
    1c0c:	17100612 			@ <UNDEFINED> instruction: 0x17100612
    1c10:	241a0000 	ldrcs	r0, [sl], #-0
    1c14:	3e0b0b00 	vmlacc.f64	d0, d11, d0
}
    1c18:	0008030b 	andeq	r0, r8, fp, lsl #6
    1c1c:	01011b00 	tsteq	r1, r0, lsl #22
{
    1c20:	13011349 	movwne	r1, #4937	@ 0x1349
  for (i = 0; i < 4; ++i)
    1c24:	211c0000 	tstcs	ip, r0
      (*state)[i][j] ^= RoundKey[(round * Nb * 4) + (i * Nb) + j];
    1c28:	2f134900 	svccs	0x00134900
    1c2c:	1d00000b 	stcne	0, cr0, [r0, #-44]	@ 0xffffffd4
    1c30:	0e03012e 	adfeqsp	f0, f3, #0.5
    1c34:	0b3b0b3a 	bleq	ec4924 <__ROM_SIZE__+0xe84924>
    1c38:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
    1c3c:	01111349 	tsteq	r1, r9, asr #6
    1c40:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
    for (j = 0; j < 4; ++j)
    1c44:	1301197a 	movwne	r1, #6522	@ 0x197a
    1c48:	341e0000 	ldrcc	r0, [lr], #-0
  for (i = 0; i < 4; ++i)
    1c4c:	3a080300 	bcc	202854 <__ROM_SIZE__+0x1c2854>
    1c50:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    for (j = 0; j < 4; ++j)
    1c54:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
  for (i = 0; i < 4; ++i)
    1c58:	1f000018 	svcne	0x00000018
    1c5c:	0e03012e 	adfeqsp	f0, f3, #0.5
    for (j = 0; j < 4; ++j)
    1c60:	0b3b0b3a 	bleq	ec4950 <__ROM_SIZE__+0xe84950>
{
    1c64:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
      (*state)[j][i] = getSBoxValue((*state)[j][i]);
    1c68:	01111349 	tsteq	r1, r9, asr #6
    1c6c:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
    1c70:	0000197a 	andeq	r1, r0, sl, ror r9
    1c74:	00240100 	eoreq	r0, r4, r0, lsl #2
    for (j = 0; j < 4; ++j)
    1c78:	0b3e0b0b 	bleq	f848ac <__ROM_SIZE__+0xf448ac>
    1c7c:	00000e03 	andeq	r0, r0, r3, lsl #28
  for (i = 0; i < 4; ++i)
    1c80:	03003402 	movweq	r3, #1026	@ 0x402
    1c84:	01213a08 			@ <UNDEFINED> instruction: 0x01213a08
    for (j = 0; j < 4; ++j)
    1c88:	0b390b3b 	bleq	e4497c <__ROM_SIZE__+0xe0497c>
}
    1c8c:	17021349 	strne	r1, [r2, -r9, asr #6]
  for (i = 0; i < 4; ++i)
    1c90:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
    1c94:	00050300 	andeq	r0, r5, r0, lsl #6
    1c98:	213a0803 	teqcs	sl, r3, lsl #16
  temp           = (*state)[0][1];
    1c9c:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
  (*state)[0][1] = (*state)[1][1];
    1ca0:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
  (*state)[1][1] = (*state)[2][1];
    1ca4:	1742b717 	smlaldne	fp, r2, r7, r7
  (*state)[2][1] = (*state)[3][1];
    1ca8:	0b040000 	bleq	101cb0 <__ROM_SIZE__+0xc1cb0>
  temp           = (*state)[0][2];
    1cac:	00175501 	andseq	r5, r7, r1, lsl #10
  (*state)[0][2] = (*state)[2][2];
    1cb0:	01110500 	tsteq	r1, r0, lsl #10
  temp           = (*state)[1][2];
    1cb4:	0b130e25 	bleq	4c5550 <__ROM_SIZE__+0x485550>
  (*state)[1][2] = (*state)[3][2];
    1cb8:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
  temp           = (*state)[0][3];
    1cbc:	06120111 			@ <UNDEFINED> instruction: 0x06120111
  (*state)[0][3] = (*state)[3][3];
    1cc0:	00001710 	andeq	r1, r0, r0, lsl r7
  (*state)[3][3] = (*state)[2][3];
    1cc4:	03001606 	movweq	r1, #1542	@ 0x606
  (*state)[2][3] = (*state)[1][3];
    1cc8:	3b0b3a0e 	blcc	2d0508 <__ROM_SIZE__+0x290508>
}
    1ccc:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
  return ((x<<1) ^ (((x>>7) & 1) * 0x1b));
    1cd0:	07000013 	smladeq	r0, r3, r0, r0
    1cd4:	0b0b0024 	bleq	2c1d6c <__ROM_SIZE__+0x281d6c>
    1cd8:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
}
    1cdc:	2e080000 	cdpcs	0, 0, cr0, cr8, cr0, {0}
{
    1ce0:	03193f01 	tsteq	r9, #1, 30
    1ce4:	3b0b3a0e 	blcc	2d0524 <__ROM_SIZE__+0x290524>
  for (i = 0; i < 4; ++i)
    1ce8:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
    t   = (*state)[i][0];
    1cec:	11134919 	tstne	r3, r9, lsl r9
    Tmp = (*state)[i][0] ^ (*state)[i][1] ^ (*state)[i][2] ^ (*state)[i][3] ;
    1cf0:	40061201 	andmi	r1, r6, r1, lsl #4
    1cf4:	01197a18 	tsteq	r9, r8, lsl sl
    1cf8:	09000013 	stmdbeq	r0, {r0, r1, r4}
    1cfc:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    1d00:	0b3b0b3a 	bleq	ec49f0 <__ROM_SIZE__+0xe849f0>
    1d04:	13490b39 	movtne	r0, #39737	@ 0x9b39
    Tm  = (*state)[i][0] ^ (*state)[i][1] ; Tm = xtime(Tm);  (*state)[i][0] ^= Tm ^ Tmp ;
    1d08:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
    1d0c:	0a000017 	beq	1d70 <InvMixColumns+0x1a>
    1d10:	0b0b000f 	bleq	2c1d54 <__ROM_SIZE__+0x281d54>
    Tm  = (*state)[i][1] ^ (*state)[i][2] ; Tm = xtime(Tm);  (*state)[i][1] ^= Tm ^ Tmp ;
    1d14:	00001349 	andeq	r1, r0, r9, asr #6
    1d18:	4900260b 	stmdbmi	r0, {r0, r1, r3, r9, sl, sp}
    1d1c:	0c000013 	stceq	0, cr0, [r0], {19}
    1d20:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
    1d24:	0b3a0e03 	bleq	e85538 <__ROM_SIZE__+0xe45538>
    Tm  = (*state)[i][2] ^ (*state)[i][3] ; Tm = xtime(Tm);  (*state)[i][2] ^= Tm ^ Tmp ;
    1d28:	0b390b3b 	bleq	e44a1c <__ROM_SIZE__+0xe04a1c>
    1d2c:	13491927 	movtne	r1, #39207	@ 0x9927
    1d30:	06120111 			@ <UNDEFINED> instruction: 0x06120111
    1d34:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
    Tm  = (*state)[i][3] ^ t ;              Tm = xtime(Tm);  (*state)[i][3] ^= Tm ^ Tmp ;
    1d38:	01000000 	mrseq	r0, (UNDEF: 0)
    1d3c:	0b0b0024 	bleq	2c1dd4 <__ROM_SIZE__+0x281dd4>
    1d40:	0e030b3e 	vmoveq.16	d3[0], r0
    1d44:	16020000 	strne	r0, [r2], -r0
    1d48:	3a0e0300 	bcc	382950 <__ROM_SIZE__+0x342950>
  for (i = 0; i < 4; ++i)
    1d4c:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    1d50:	0013490b 	andseq	r4, r3, fp, lsl #18
}
    1d54:	000d0300 	andeq	r0, sp, r0, lsl #6
{
    1d58:	213a0e03 	teqcs	sl, r3, lsl #28
    1d5c:	390b3b03 	stmdbcc	fp, {r0, r1, r8, r9, fp, ip, sp}
  for (i = 0; i < 4; ++i)
    1d60:	3813490b 	ldmdacc	r3, {r0, r1, r3, r8, fp, lr}
    a = (*state)[i][0];
    1d64:	0400000b 	streq	r0, [r0], #-11
    b = (*state)[i][1];
    1d68:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    1d6c:	3b01213a 	blcc	4a25c <__ROM_SIZE__+0xa25c>
    c = (*state)[i][2];
    1d70:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
    d = (*state)[i][3];
    1d74:	00180213 	andseq	r0, r8, r3, lsl r2
    (*state)[i][0] = Multiply(a, 0x0e) ^ Multiply(b, 0x0b) ^ Multiply(c, 0x0d) ^ Multiply(d, 0x09);
    1d78:	00050500 	andeq	r0, r5, r0, lsl #10
    1d7c:	00001349 	andeq	r1, r0, r9, asr #6
    1d80:	03000506 	movweq	r0, #1286	@ 0x506
    1d84:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
    1d88:	3917213b 	ldmdbcc	r7, {r0, r1, r3, r4, r5, r8, sp}
    1d8c:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
    1d90:	1742b717 	smlaldne	fp, r2, r7, r7
    1d94:	28070000 	stmdacs	r7, {}	@ <UNPREDICTABLE>
    1d98:	1c0e0300 	stcne	3, cr0, [lr], {-0}
    1d9c:	0800000b 	stmdaeq	r0, {r0, r1, r3}
    1da0:	08030028 	stmdaeq	r3, {r3, r5}
    1da4:	00000b1c 	andeq	r0, r0, ip, lsl fp
    1da8:	0b000f09 	bleq	59d4 <base_order+0x23bc>
    1dac:	13490421 	movtne	r0, #37921	@ 0x9421
    1db0:	2e0a0000 	cdpcs	0, 0, cr0, cr10, cr0, {0}
    1db4:	03193f01 	tsteq	r9, #1, 30
    1db8:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
    1dbc:	21390b3b 	teqcs	r9, fp, lsr fp
    1dc0:	11192706 	tstne	r9, r6, lsl #14
    1dc4:	40061201 	andmi	r1, r6, r1, lsl #4
    1dc8:	01197a18 	tsteq	r9, r8, lsl sl
    1dcc:	0b000013 	bleq	1e20 <InvMixColumns+0xca>
    1dd0:	18020049 	stmdane	r2, {r0, r3, r6}
    1dd4:	0000187e 	andeq	r1, r0, lr, ror r8
    1dd8:	2501110c 	strcs	r1, [r1, #-268]	@ 0xfffffef4
    1ddc:	030b130e 	movweq	r1, #45838	@ 0xb30e
    1de0:	110e1b0e 	tstne	lr, lr, lsl #22
    1de4:	10061201 	andne	r1, r6, r1, lsl #4
    1de8:	0d000017 	stceq	0, cr0, [r0, #-92]	@ 0xffffffa4
    1dec:	13490035 	movtne	r0, #36917	@ 0x9035
    1df0:	240e0000 	strcs	r0, [lr], #-0
    1df4:	3e0b0b00 	vmlacc.f64	d0, d11, d0
    1df8:	0008030b 	andeq	r0, r8, fp, lsl #6
    1dfc:	01040f00 	tsteq	r4, r0, lsl #30
    1e00:	0b3e0e03 	bleq	f85614 <__ROM_SIZE__+0xf45614>
    1e04:	13490b0b 	movtne	r0, #39691	@ 0x9b0b
    (*state)[i][1] = Multiply(a, 0x09) ^ Multiply(b, 0x0e) ^ Multiply(c, 0x0b) ^ Multiply(d, 0x0d);
    1e08:	0b3b0b3a 	bleq	ec4af8 <__ROM_SIZE__+0xe84af8>
    1e0c:	13010b39 	movwne	r0, #6969	@ 0x1b39
    1e10:	13100000 	tstne	r0, #0
    1e14:	0b0e0301 	bleq	382a20 <__ROM_SIZE__+0x342a20>
    1e18:	3b0b3a0b 	blcc	2d064c <__ROM_SIZE__+0x29064c>
    1e1c:	010b390b 	tsteq	fp, fp, lsl #18
    1e20:	11000013 	tstne	r0, r3, lsl r0
    1e24:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
    1e28:	0b3a0e03 	bleq	e8563c <__ROM_SIZE__+0xe4563c>
    1e2c:	0b390b3b 	bleq	e44b20 <__ROM_SIZE__+0xe04b20>
    1e30:	13491927 	movtne	r1, #39207	@ 0x9927
    1e34:	1301193c 	movwne	r1, #6460	@ 0x193c
    1e38:	0f120000 	svceq	0x00120000
    1e3c:	000b0b00 	andeq	r0, fp, r0, lsl #22
    (*state)[i][2] = Multiply(a, 0x0d) ^ Multiply(b, 0x09) ^ Multiply(c, 0x0e) ^ Multiply(d, 0x0b);
    1e40:	00051300 	andeq	r1, r5, r0, lsl #6
    1e44:	0b3a0803 	bleq	e83e58 <__ROM_SIZE__+0xe43e58>
    1e48:	0b390b3b 	bleq	e44b3c <__ROM_SIZE__+0xe04b3c>
    1e4c:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
    1e50:	2e140000 	cdpcs	0, 1, cr0, cr4, cr0, {0}
    1e54:	03193f01 	tsteq	r9, #1, 30
    1e58:	3b0b3a0e 	blcc	2d0698 <__ROM_SIZE__+0x290698>
    1e5c:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
    1e60:	11134919 	tstne	r3, r9, lsl r9
    1e64:	40061201 	andmi	r1, r6, r1, lsl #4
    1e68:	01197a18 	tsteq	r9, r8, lsl sl
    1e6c:	15000013 	strne	r0, [r0, #-19]	@ 0xffffffed
    (*state)[i][3] = Multiply(a, 0x0b) ^ Multiply(b, 0x0d) ^ Multiply(c, 0x09) ^ Multiply(d, 0x0e);
    1e70:	08030034 	stmdaeq	r3, {r2, r4, r5}
    1e74:	0b3b0b3a 	bleq	ec4b64 <__ROM_SIZE__+0xe84b64>
    1e78:	13490b39 	movtne	r0, #39737	@ 0x9b39
    1e7c:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
    1e80:	16000017 			@ <UNDEFINED> instruction: 0x16000017
    1e84:	017d0148 	cmneq	sp, r8, asr #2
    1e88:	0000137f 	andeq	r1, r0, pc, ror r3
    1e8c:	00050100 	andeq	r0, r5, r0, lsl #2
    1e90:	213a0e03 	teqcs	sl, r3, lsl #28
    1e94:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
    1e98:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
    1e9c:	1742b717 	smlaldne	fp, r2, r7, r7
    1ea0:	24020000 	strcs	r0, [r2], #-0
  for (i = 0; i < 4; ++i)
    1ea4:	3e0b0b00 	vmlacc.f64	d0, d11, d0
    1ea8:	000e030b 	andeq	r0, lr, fp, lsl #6
}
    1eac:	012e0300 			@ <UNDEFINED> instruction: 0x012e0300
  for (i = 0; i < 4; ++i)
    1eb0:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
    1eb4:	3b01213a 	blcc	4a3a4 <__ROM_SIZE__+0xa3a4>
    for (j = 0; j < 4; ++j)
    1eb8:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
{
    1ebc:	11134919 	tstne	r3, r9, lsl r9
      (*state)[j][i] = getSBoxInvert((*state)[j][i]);
    1ec0:	40061201 	andmi	r1, r6, r1, lsl #4
    1ec4:	01197a18 	tsteq	r9, r8, lsl sl
    1ec8:	04000013 	streq	r0, [r0], #-19	@ 0xffffffed
    1ecc:	08030034 	stmdaeq	r3, {r2, r4, r5}
    1ed0:	3b01213a 	blcc	4a3c0 <__ROM_SIZE__+0xa3c0>
    for (j = 0; j < 4; ++j)
    1ed4:	0a21390b 	beq	850308 <__ROM_SIZE__+0x810308>
    1ed8:	17021349 	strne	r1, [r2, -r9, asr #6]
  for (i = 0; i < 4; ++i)
    1edc:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
    1ee0:	00340500 	eorseq	r0, r4, r0, lsl #10
    for (j = 0; j < 4; ++j)
    1ee4:	213a0e03 	teqcs	sl, r3, lsl #28
}
    1ee8:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
  for (i = 0; i < 4; ++i)
    1eec:	13490921 	movtne	r0, #39201	@ 0x9921
    1ef0:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
    1ef4:	06000017 			@ <UNDEFINED> instruction: 0x06000017
  temp = (*state)[3][1];
    1ef8:	210b000f 	tstcs	fp, pc
  (*state)[3][1] = (*state)[2][1];
    1efc:	00134904 	andseq	r4, r3, r4, lsl #18
  (*state)[2][1] = (*state)[1][1];
    1f00:	00050700 	andeq	r0, r5, r0, lsl #14
  (*state)[1][1] = (*state)[0][1];
    1f04:	213a0803 	teqcs	sl, r3, lsl #16
  temp = (*state)[0][2];
    1f08:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
  (*state)[0][2] = (*state)[2][2];
    1f0c:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
  temp = (*state)[1][2];
    1f10:	08000018 	stmdaeq	r0, {r3, r4}
  (*state)[1][2] = (*state)[3][2];
    1f14:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
  temp = (*state)[0][3];
    1f18:	3b01213a 	blcc	4a408 <__ROM_SIZE__+0xa408>
  (*state)[0][3] = (*state)[1][3];
    1f1c:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
  (*state)[1][3] = (*state)[2][3];
    1f20:	00180213 	andseq	r0, r8, r3, lsl r2
  (*state)[2][3] = (*state)[3][3];
    1f24:	01110900 	tsteq	r1, r0, lsl #18
}
    1f28:	0b130e25 	bleq	4c57c4 <__ROM_SIZE__+0x4857c4>
{
    1f2c:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
  AddRoundKey(0, state, RoundKey);
    1f30:	06120111 			@ <UNDEFINED> instruction: 0x06120111
    1f34:	00001710 	andeq	r1, r0, r0, lsl r7
    1f38:	0b00240a 	bleq	af68 <__RAM_SIZE__+0x2f68>
  for (round = 1; ; ++round)
    1f3c:	030b3e0b 	movweq	r3, #48651	@ 0xbe0b
    MixColumns(state);
    1f40:	0b000008 	bleq	1f68 <Cipher+0x3e>
    AddRoundKey(round, state, RoundKey);
    1f44:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
    1f48:	0b3b0b3a 	bleq	ec4c38 <__ROM_SIZE__+0xe84c38>
    1f4c:	13490b39 	movtne	r0, #39737	@ 0x9b39
  for (round = 1; ; ++round)
    1f50:	0f0c0000 	svceq	0x000c0000
    SubBytes(state);
    1f54:	000b0b00 	andeq	r0, fp, r0, lsl #22
    ShiftRows(state);
    1f58:	00260d00 	eoreq	r0, r6, r0, lsl #26
    1f5c:	00001349 	andeq	r1, r0, r9, asr #6
    if (round == Nr) {
    1f60:	0000260e 	andeq	r2, r0, lr, lsl #12
  AddRoundKey(Nr, state, RoundKey);
    1f64:	012e0f00 			@ <UNDEFINED> instruction: 0x012e0f00
    1f68:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
}
    1f6c:	0b3b0b3a 	bleq	ec4c5c <__ROM_SIZE__+0xe84c5c>
{
    1f70:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
  AddRoundKey(Nr, state, RoundKey);
    1f74:	01111349 	tsteq	r1, r9, asr #6
    1f78:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
    1f7c:	0000197a 	andeq	r1, r0, sl, ror r9
  for (round = (Nr - 1); ; --round)
    1f80:	03000510 	movweq	r0, #1296	@ 0x510
    InvMixColumns(state);
    1f84:	3b0b3a08 	blcc	2d07ac <__ROM_SIZE__+0x2907ac>
  for (round = (Nr - 1); ; --round)
    1f88:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
    InvShiftRows(state);
    1f8c:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
    1f90:	00001742 	andeq	r1, r0, r2, asr #14
	...

Disassembly of section .debug_loclists:

00000000 <.debug_loclists>:
       0:	00000075 	andeq	r0, r0, r5, ror r0
       4:	00040005 	andeq	r0, r4, r5
	...
      10:	010a0004 	tsteq	sl, r4
      14:	940a0450 	strls	r0, [sl], #-1104	@ 0xfffffbb0
      18:	00550102 	subseq	r0, r5, r2, lsl #2
      1c:	00000000 	andeq	r0, r0, r0
      20:	010d0004 	tsteq	sp, r4
      24:	940d0451 	strls	r0, [sp], #-1105	@ 0xfffffbaf
      28:	00560102 	subseq	r0, r6, r2, lsl #2
      2c:	00000001 	andeq	r0, r0, r1
      30:	00000000 	andeq	r0, r0, r0
      34:	0e040000 	cdpeq	0, 0, cr0, cr4, cr0, {0}
      38:	9f310212 	svcls	0x00310212
      3c:	012c1204 			@ <UNDEFINED> instruction: 0x012c1204
      40:	5c320454 	cfldrspl	mvf0, [r2], #-336	@ 0xfffffeb0
      44:	8e045401 	cdphi	4, 0, cr5, cr4, cr1, {0}
      48:	0101ac01 	tsteq	r1, r1, lsl #24
      4c:	01d20454 	bicseq	r0, r2, r4, asr r4
      50:	54010294 	strpl	r0, [r1], #-660	@ 0xfffffd6c
      54:	00000000 	andeq	r0, r0, r0
      58:	04000000 	streq	r0, [r0], #-0
      5c:	5001726e 	andpl	r7, r1, lr, ror #4
      60:	017e7204 	cmneq	lr, r4, lsl #4
      64:	807e0454 	rsbshi	r0, lr, r4, asr r4
      68:	98730401 	ldmdals	r3!, {r0, sl}^
      6c:	00009f7f 	andeq	r9, r0, pc, ror pc
      70:	01bc0400 			@ <UNDEFINED> instruction: 0x01bc0400
      74:	500101cc 	andpl	r0, r1, ip, asr #3
      78:	00002b00 	andeq	r2, r0, r0, lsl #22
      7c:	04000500 	streq	r0, [r0], #-1280	@ 0xfffffb00
      80:	00000000 	andeq	r0, r0, r0
      84:	00000100 	andeq	r0, r0, r0, lsl #2
      88:	00000000 	andeq	r0, r0, r0
      8c:	14000400 	strne	r0, [r0], #-1024	@ 0xfffffc00
      90:	14045001 	strne	r5, [r4], #-1
      94:	01a30416 			@ <UNDEFINED> instruction: 0x01a30416
      98:	16049f50 			@ <UNDEFINED> instruction: 0x16049f50
      9c:	04500118 	ldrbeq	r0, [r0], #-280	@ 0xfffffee8
      a0:	a3042418 	movwge	r2, #17432	@ 0x4418
      a4:	009f5001 	addseq	r5, pc, r1
      a8:	0000002b 	andeq	r0, r0, fp, lsr #32
      ac:	00040005 	andeq	r0, r4, r5
      b0:	00000000 	andeq	r0, r0, r0
      b4:	00000001 	andeq	r0, r0, r1
      b8:	00000000 	andeq	r0, r0, r0
      bc:	01140004 	tsteq	r4, r4
      c0:	16140450 			@ <UNDEFINED> instruction: 0x16140450
      c4:	5001a304 	andpl	sl, r1, r4, lsl #6
      c8:	1816049f 	ldmdane	r6, {r0, r1, r2, r3, r4, r7, sl}
      cc:	18045001 	stmdane	r4, {r0, ip, lr}
      d0:	01a30424 			@ <UNDEFINED> instruction: 0x01a30424
      d4:	55009f50 	strpl	r9, [r0, #-3920]	@ 0xfffff0b0
      d8:	05000000 	streq	r0, [r0, #-0]
      dc:	00000400 	andeq	r0, r0, r0, lsl #8
      e0:	00000000 	andeq	r0, r0, r0
      e4:	04000000 	streq	r0, [r0], #-0
      e8:	50010c00 	andpl	r0, r1, r0, lsl #24
      ec:	01a40c04 			@ <UNDEFINED> instruction: 0x01a40c04
      f0:	5001a304 	andpl	sl, r1, r4, lsl #6
      f4:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
      f8:	00040000 	andeq	r0, r4, r0
      fc:	0451010c 	ldrbeq	r0, [r1], #-268	@ 0xfffffef4
     100:	0401a40c 	streq	sl, [r1], #-1036	@ 0xfffffbf4
     104:	9f5101a3 	svcls	0x005101a3
	...
     110:	04000000 	streq	r0, [r0], #-0
     114:	50014434 	andpl	r4, r1, r4, lsr r4
     118:	01644404 	cmneq	r4, r4, lsl #8
     11c:	68640454 	stmdavs	r4!, {r2, r4, r6, sl}^
     120:	68045001 	stmdavs	r4, {r0, ip, lr}
     124:	04540174 	ldrbeq	r0, [r4], #-372	@ 0xfffffe8c
     128:	73047f74 	movwvc	r7, #20340	@ 0x4f74
     12c:	009f7fb8 			@ <UNDEFINED> instruction: 0x009f7fb8
     130:	0000002c 	andeq	r0, r0, ip, lsr #32
     134:	00040005 	andeq	r0, r4, r5
	...
     140:	01040004 	tsteq	r4, r4
     144:	1c040450 	cfstrsne	mvf0, [r4], {80}	@ 0x50
     148:	5001a304 	andpl	sl, r1, r4, lsl #6
     14c:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
     150:	00040000 	andeq	r0, r4, r0
     154:	04510107 	ldrbeq	r0, [r1], #-263	@ 0xfffffef9
     158:	a3041c07 	movwge	r1, #19463	@ 0x4c07
     15c:	009f5101 	addseq	r5, pc, r1, lsl #2
     160:	000000e5 	andeq	r0, r0, r5, ror #1
     164:	00040005 	andeq	r0, r4, r5
	...
     174:	015c5004 	cmpeq	ip, r4
     178:	925c0450 	subsls	r0, ip, #80, 8	@ 0x50000000
     17c:	01a30401 			@ <UNDEFINED> instruction: 0x01a30401
     180:	92049f50 	andls	r9, r4, #80, 30	@ 0x140
     184:	01019401 	tsteq	r1, r1, lsl #8
     188:	01940450 	orrseq	r0, r4, r0, asr r4
     18c:	a30401ac 	movwge	r0, #16812	@ 0x41ac
     190:	009f5001 	addseq	r5, pc, r1
	...
     19c:	015f5004 	cmpeq	pc, r4
     1a0:	925f0451 	subsls	r0, pc, #1358954496	@ 0x51000000
     1a4:	04540101 	ldrbeq	r0, [r4], #-257	@ 0xfffffeff
     1a8:	01970192 			@ <UNDEFINED> instruction: 0x01970192
     1ac:	97045101 	strls	r5, [r4, -r1, lsl #2]
     1b0:	0401ac01 	streq	sl, [r1], #-3073	@ 0xfffff3ff
     1b4:	9f5101a3 	svcls	0x005101a3
	...
     1c0:	04000000 	streq	r0, [r0], #-0
     1c4:	50016a62 	andpl	r6, r1, r2, ror #20
     1c8:	016d6a04 	cmneq	sp, r4, lsl #20
     1cc:	766e0451 			@ <UNDEFINED> instruction: 0x766e0451
     1d0:	76045001 	strvc	r5, [r4], -r1
     1d4:	98730478 	ldmdals	r3!, {r3, r4, r5, r6, sl}^
     1d8:	88049f7f 	stmdahi	r4, {r0, r1, r2, r3, r4, r5, r6, r8, r9, sl, fp, ip, pc}
     1dc:	01018c01 	tsteq	r1, r1, lsl #24
     1e0:	00000050 	andeq	r0, r0, r0, asr r0
     1e4:	00000000 	andeq	r0, r0, r0
     1e8:	00040000 	andeq	r0, r4, r0
     1ec:	0450010c 	ldrbeq	r0, [r0], #-268	@ 0xfffffef4
     1f0:	a304360c 	movwge	r3, #17932	@ 0x460c
     1f4:	049f5001 	ldreq	r5, [pc], #1	@ 1fc <vector_table+0x1fc>
     1f8:	50013836 	andpl	r3, r1, r6, lsr r8
     1fc:	04503804 	ldrbeq	r3, [r0], #-2052	@ 0xfffff7fc
     200:	9f5001a3 	svcls	0x005001a3
	...
     20c:	0f000400 	svceq	0x00000400
     210:	0f045101 	svceq	0x00045101
     214:	04540136 	ldrbeq	r0, [r4], #-310	@ 0xfffffeca
     218:	51013b36 	tstpl	r1, r6, lsr fp
     21c:	04503b04 	ldrbeq	r3, [r0], #-2820	@ 0xfffff4fc
     220:	9f5101a3 	svcls	0x005101a3
	...
     22c:	04000000 	streq	r0, [r0], #-0
     230:	50011a12 	andpl	r1, r1, r2, lsl sl
     234:	011d1a04 	tsteq	sp, r4, lsl #20
     238:	26200451 			@ <UNDEFINED> instruction: 0x26200451
     23c:	26045001 	strcs	r5, [r4], -r1
     240:	04530129 	ldrbeq	r0, [r3], #-297	@ 0xfffffed7
     244:	5001302c 	andpl	r3, r1, ip, lsr #32
     248:	00006200 	andeq	r6, r0, r0, lsl #4
     24c:	04000500 	streq	r0, [r0], #-1280	@ 0xfffffb00
	...
     258:	0c000400 	cfstrseq	mvf0, [r0], {-0}
     25c:	0c045001 	stceq	0, cr5, [r4], {1}
     260:	a304028c 	movwge	r0, #17036	@ 0x428c
     264:	009f5001 	addseq	r5, pc, r1
     268:	00000000 	andeq	r0, r0, r0
     26c:	010c0004 	tsteq	ip, r4
     270:	8c0c0451 	cfstrshi	mvf0, [ip], {81}	@ 0x51
     274:	01a30402 			@ <UNDEFINED> instruction: 0x01a30402
     278:	06009f51 			@ <UNDEFINED> instruction: 0x06009f51
	...
     284:	80180400 	andshi	r0, r8, r0, lsl #8
     288:	9f300201 	svcls	0x00300201
     28c:	88018004 	stmdahi	r1, {r2, pc}
     290:	04500101 	ldrbeq	r0, [r0], #-257	@ 0xfffffeff
     294:	01950188 	orrseq	r0, r5, r8, lsl #3
     298:	7dc07304 	stclvc	3, cr7, [r0, #16]
     29c:	01b8049f 			@ <UNDEFINED> instruction: 0x01b8049f
     2a0:	500101c0 	andpl	r0, r1, r0, asr #3
     2a4:	cb01c004 	blgt	702bc <__ROM_SIZE__+0x302bc>
     2a8:	c0730401 	rsbsgt	r0, r3, r1, lsl #8
     2ac:	2c009f7d 	stccs	15, cr9, [r0], {125}	@ 0x7d
     2b0:	05000000 	streq	r0, [r0, #-0]
     2b4:	00000400 	andeq	r0, r0, r0, lsl #8
     2b8:	00000000 	andeq	r0, r0, r0
     2bc:	04000000 	streq	r0, [r0], #-0
     2c0:	50010400 	andpl	r0, r1, r0, lsl #8
     2c4:	041c0404 	ldreq	r0, [ip], #-1028	@ 0xfffffbfc
     2c8:	9f5001a3 	svcls	0x005001a3
     2cc:	00000000 	andeq	r0, r0, r0
     2d0:	07000400 	streq	r0, [r0, -r0, lsl #8]
     2d4:	07045101 	streq	r5, [r4, -r1, lsl #2]
     2d8:	01a3041c 			@ <UNDEFINED> instruction: 0x01a3041c
     2dc:	3d009f51 	stccc	15, cr9, [r0, #-324]	@ 0xfffffebc
     2e0:	05000000 	streq	r0, [r0, #-0]
     2e4:	00000400 	andeq	r0, r0, r0, lsl #8
     2e8:	00000000 	andeq	r0, r0, r0
     2ec:	04000000 	streq	r0, [r0], #-0
     2f0:	50010600 	andpl	r0, r1, r0, lsl #12
     2f4:	01a40604 			@ <UNDEFINED> instruction: 0x01a40604
     2f8:	5001a304 	andpl	sl, r1, r4, lsl #6
     2fc:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
     300:	00040000 	andeq	r0, r4, r0
     304:	04510109 	ldrbeq	r0, [r1], #-265	@ 0xfffffef7
     308:	0401a409 	streq	sl, [r1], #-1033	@ 0xfffffbf7
     30c:	9f5101a3 	svcls	0x005101a3
     310:	00000000 	andeq	r0, r0, r0
     314:	74680400 	strbtvc	r0, [r8], #-1024	@ 0xfffffc00
     318:	78045001 	stmdavc	r4, {r0, ip, lr}
     31c:	0050017e 	subseq	r0, r0, lr, ror r1
     320:	00000538 	andeq	r0, r0, r8, lsr r5
     324:	00040005 	andeq	r0, r4, r5
	...
     330:	8a028004 	bhi	a0348 <__ROM_SIZE__+0x60348>
     334:	04500102 	ldrbeq	r0, [r0], #-258	@ 0xfffffefe
     338:	029c028a 	addseq	r0, ip, #-1610612728	@ 0xa0000008
     33c:	5001a304 	andpl	sl, r1, r4, lsl #6
     340:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
     344:	80040000 	andhi	r0, r4, r0
     348:	01028802 	tsteq	r2, r2, lsl #16
     34c:	02880451 	addeq	r0, r8, #1358954496	@ 0x51000000
     350:	a304029c 	movwge	r0, #17052	@ 0x429c
     354:	009f5101 	addseq	r5, pc, r1, lsl #2
     358:	00000000 	andeq	r0, r0, r0
     35c:	94038804 	strls	r8, [r3], #-2052	@ 0xfffff7fc
     360:	04500103 	ldrbeq	r0, [r0], #-259	@ 0xfffffefd
     364:	03f00394 	mvnseq	r0, #148, 6	@ 0x50000002
     368:	5001a304 	andpl	sl, r1, r4, lsl #6
     36c:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
     370:	00000000 	andeq	r0, r0, r0
     374:	92038804 	andls	r8, r3, #4, 16	@ 0x40000
     378:	04510103 	ldrbeq	r0, [r1], #-259	@ 0xfffffefd
     37c:	03970392 	orrseq	r0, r7, #1207959554	@ 0x48000002
     380:	97045301 	strls	r5, [r4, -r1, lsl #6]
     384:	0403f003 	streq	pc, [r3], #-3
     388:	9f5101a3 	svcls	0x005101a3
     38c:	00000100 	andeq	r0, r0, r0, lsl #2
     390:	00000000 	andeq	r0, r0, r0
     394:	038a0400 	orreq	r0, sl, #0, 8
     398:	300203a6 	andcc	r0, r2, r6, lsr #7
     39c:	03a6049f 			@ <UNDEFINED> instruction: 0x03a6049f
     3a0:	550103d4 	strpl	r0, [r1, #-980]	@ 0xfffffc2c
     3a4:	d803d404 	stmdale	r3, {r2, sl, ip, lr, pc}
     3a8:	9f300203 	svcls	0x00300203
     3ac:	da03d804 	ble	f63c4 <__ROM_SIZE__+0xb63c4>
     3b0:	00550103 	subseq	r0, r5, r3, lsl #2
     3b4:	00000002 	andeq	r0, r0, r2
     3b8:	00000000 	andeq	r0, r0, r0
     3bc:	a2038a04 	andge	r8, r3, #4, 20	@ 0x4000
int car_mesg(int argc, char** argv) {
     3c0:	9f310203 	svcls	0x00310203
     3c4:	d403a604 	strle	sl, [r3], #-1540	@ 0xfffff9fc
    printf("Received a message from the car:");
     3c8:	04560103 	ldrbeq	r0, [r6], #-259	@ 0xfffffefd
     3cc:	03d803d4 	bicseq	r0, r8, #212, 6	@ 0x50000003
    for (ctr = 1; ctr < argc; ctr++) {
     3d0:	049f3102 	ldreq	r3, [pc], #258	@ 3d8 <car_mesg+0x18>
        printf(" %s", argv[ctr]);
     3d4:	03da03d8 	bicseq	r0, sl, #216, 6	@ 0x60000003
     3d8:	00005601 	andeq	r5, r0, r1, lsl #12
    for (ctr = 1; ctr < argc; ctr++) {
     3dc:	00000000 	andeq	r0, r0, r0
     3e0:	0cd00400 	cfldrdeq	mvd0, [r0], {0}
    printf("\n");
     3e4:	50010cd8 	ldrdpl	r0, [r1], -r8
    if (argc > 1) {
     3e8:	fc0cd804 	stc2	8, cr13, [ip], {4}
}
     3ec:	0456010c 	ldrbeq	r0, [r6], #-268	@ 0xfffffef4
     3f0:	0d800cfc 	stceq	12, cr0, [r0, #1008]	@ 0x3f0
        if (strcmp(argv[1], "PING_REPLY") == 0) {
     3f4:	5001a304 	andpl	sl, r1, r4, lsl #6
     3f8:	0002009f 	muleq	r2, pc, r0	@ <UNPREDICTABLE>
            printf("Got a ping reply.\n");
     3fc:	d4040000 	strle	r0, [r4], #-0
     400:	020cd80c 	andeq	sp, ip, #12, 16	@ 0xc0000
        else if (strcmp(argv[1], "AESB64") == 0) {
     404:	d8049f30 	stmdale	r4, {r4, r5, r8, r9, sl, fp, ip, pc}
     408:	010cfc0c 	tsteq	ip, ip, lsl #24	@ <UNPREDICTABLE>
     40c:	00000055 	andeq	r0, r0, r5, asr r0
            if (argc == 3) { 
     410:	00000000 	andeq	r0, r0, r0
                printf("Missing AESB64 encoded message\n");
     414:	ae0ca404 	cdpge	4, 0, cr10, cr12, cr4, {0}
     418:	0450010c 	ldrbeq	r0, [r0], #-268	@ 0xfffffef4
                len = decode_base64((uint8_t *) argv[2], strlen(argv[2]), decoded);
     41c:	0cb10cae 	ldceq	12, cr0, [r1], #696	@ 0x2b8
     420:	b1045101 	tstlt	r4, r1, lsl #2
     424:	040cd00c 	streq	sp, [ip], #-12
     428:	9f5001a3 	svcls	0x005001a3
     42c:	00000000 	andeq	r0, r0, r0
                AES_ECB_decrypt(&ctx, decoded);
     430:	0cb20400 	cfldrseq	mvf0, [r2]
     434:	50010cb6 			@ <UNDEFINED> instruction: 0x50010cb6
                decoded[len] = '\0';
     438:	c70cc204 	strgt	ip, [ip, -r4, lsl #4]
     43c:	0050010c 	subseq	r0, r0, ip, lsl #2
     440:	00000000 	andeq	r0, r0, r0
                printf("Decoded/decrypted as %s\n", decoded);
     444:	a0029c04 	andge	r9, r2, r4, lsl #24
     448:	04500102 	ldrbeq	r0, [r0], #-258	@ 0xfffffefe
     44c:	02ac02a0 	adceq	r0, ip, #160, 4
        else if (strcmp(argv[1], "B64") == 0) {
     450:	5001a304 	andpl	sl, r1, r4, lsl #6
     454:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
            if (argc == 3) { 
     458:	9c040000 	stcls	0, cr0, [r4], {-0}
                printf("Missing Base64 encoded message\n");
     45c:	0102a302 	tsteq	r2, r2, lsl #6
     460:	02a30451 	adceq	r0, r3, #1358954496	@ 0x51000000
                printf("Decoding Base64\n");
     464:	a30402ac 	movwge	r0, #17068	@ 0x42ac
     468:	009f5101 	addseq	r5, pc, r1, lsl #2
                len = decode_base64((uint8_t *) argv[2], strlen(argv[2]), decoded);
     46c:	00000002 	andeq	r0, r0, r2
     470:	a0019c04 	andge	r9, r1, r4, lsl #24
     474:	9f300201 	svcls	0x00300201
     478:	bc01a004 	stclt	0, cr10, [r1], {4}
                decoded[len] = '\0';
     47c:	00540101 	subseq	r0, r4, r1, lsl #2
     480:	00000000 	andeq	r0, r0, r0
     484:	b4040000 	strlt	r0, [r4], #-0
                printf("Decoded as %s", decoded);
     488:	0109bb09 	tsteq	r9, r9, lsl #22
     48c:	09bc0450 	ldmibeq	ip!, {r4, r6, sl}
     490:	500109c5 	andpl	r0, r1, r5, asr #19
            printf("Didn't know how to handle %s\n", argv[1]);
     494:	ba0ab404 	blt	2ad4ac <__ROM_SIZE__+0x26d4ac>
     498:	0050010a 	subseq	r0, r0, sl, lsl #2
     49c:	00000000 	andeq	r0, r0, r0
     4a0:	f209ee04 	vceq.f32	d14, d9, d4
     4a4:	04500109 	ldrbeq	r0, [r0], #-265	@ 0xfffffef7
     4a8:	0bdb0bd6 	bleq	ff6c3408 <_STACK_TOP_+0xdf6bb40c>
     4ac:	01005001 	tsteq	r0, r1
	...
     4b8:	01010000 	mrseq	r0, (UNDEF: 1)
     4bc:	04000000 	streq	r0, [r0], #-0
     4c0:	09b008fc 	ldmibeq	r0!, {r2, r3, r4, r5, r6, r7, fp}
     4c4:	049f3002 	ldreq	r3, [pc], #2	@ 4cc <car_mesg+0x10c>
     4c8:	09b209b0 	ldmibeq	r2!, {r4, r5, r7, r8, fp}
     4cc:	b4045501 	strlt	r5, [r4], #-1281	@ 0xfffffaff
     4d0:	0109c609 	tsteq	r9, r9, lsl #12
     4d4:	09c80455 	stmibeq	r8, {r0, r2, r4, r6, sl}^
void uputc(char c) {
     4d8:	55010b8e 	strpl	r0, [r1, #-2958]	@ 0xfffff472
  while ((UARTFR >> 5) & 1)
     4dc:	960b9004 	strls	r9, [fp], -r4
     4e0:	0455010b 	ldrbeq	r0, [r5], #-267	@ 0xfffffef5
  UART_DR = c;
     4e4:	0bb60b98 	bleq	fed8334c <_STACK_TOP_+0xded7b350>
  if (c == '\n')
     4e8:	b6045501 	strlt	r5, [r4], -r1, lsl #10
}
     4ec:	020bba0b 	andeq	fp, fp, #45056	@ 0xb000
    uputc('\r');
     4f0:	ba049f30 	blt	1281b8 <__ROM_SIZE__+0xe81b8>
}
     4f4:	010bec0b 	tsteq	fp, fp, lsl #24
     4f8:	00000055 	andeq	r0, r0, r5, asr r0
  if (!((UARTFR >> 4) & 1)) return UART_DR;
     4fc:	00000000 	andeq	r0, r0, r0
     500:	b409b004 	strlt	fp, [r9], #-4
     504:	04540109 	ldrbeq	r0, [r4], #-265	@ 0xfffffef7
     508:	0aa409c8 	beq	fe902c30 <_STACK_TOP_+0xde8fac34>
  return -1;
     50c:	bc045401 	cfstrslt	mvf5, [r4], {1}
}
     510:	010bec0a 	tsteq	fp, sl, lsl #24
     514:	00060054 	andeq	r0, r6, r4, asr r0
  UARTCTL = 0;
     518:	fc040000 	stc2	0, cr0, [r4], {-0}
     51c:	0208fe08 	andeq	pc, r8, #8, 28	@ 0x80
  UARTIBRD = 8;
     520:	fe049f30 	mcr2	15, 0, r9, cr4, cr0, {1}
  UARTFBRD = 44;
     524:	01099208 	tsteq	r9, r8, lsl #4
  UARTCC = 0;
     528:	00000053 	andeq	r0, r0, r3, asr r0
  UARTLCRH = 0x60;
     52c:	a5099404 	strge	r9, [r9, #-1028]	@ 0xfffffbfc
  UARTCTL = 0x301;
     530:	00530109 	subseq	r0, r3, r9, lsl #2
}
     534:	00000000 	andeq	r0, r0, r0
     538:	ac040000 	stcge	0, cr0, [r4], {-0}
void u2putc(char c) {
     53c:	0102b802 	tsteq	r2, r2, lsl #16
  while ((UART2FR >> 5) & 1)
     540:	02b80450 	adcseq	r0, r8, #80, 8	@ 0x50000000
     544:	580102fa 	stmdapl	r1, {r1, r3, r4, r5, r6, r7, r9}
  UART2_DR = c;
     548:	8802fa04 	stmdahi	r2, {r2, r9, fp, ip, sp, lr, pc}
  if (c == '\n')
     54c:	01a30403 			@ <UNDEFINED> instruction: 0x01a30403
}
     550:	00009f50 	andeq	r9, r0, r0, asr pc
    u2putc('\r');
     554:	00000000 	andeq	r0, r0, r0
}
     558:	02ac0400 	adceq	r0, ip, #0, 8
     55c:	510102b8 			@ <UNDEFINED> instruction: 0x510102b8
  if (!((UART2FR >> 4) & 1)) return UART2_DR;
     560:	fa02b804 	blx	ae578 <__ROM_SIZE__+0x6e578>
     564:	04560102 	ldrbeq	r0, [r6], #-258	@ 0xfffffefe
     568:	038802fa 	orreq	r0, r8, #-1610612721	@ 0xa000000f
     56c:	5101a304 	tstpl	r1, r4, lsl #6
  return -1;
     570:	0101009f 	swpeq	r0, pc, [r1]	@ <UNPREDICTABLE>
}
     574:	00000001 	andeq	r0, r0, r1
     578:	e202b404 	and	fp, r2, #4, 8	@ 0x4000000
  UART2CTL = 0;
     57c:	9f300202 	svcls	0x00300202
     580:	e402e204 	str	lr, [r2], #-516	@ 0xfffffdfc
  UART2IBRD = 8;
     584:	9f310202 	svcls	0x00310202
  UART2FBRD = 44;
     588:	f602e404 			@ <UNDEFINED> instruction: 0xf602e404
  UART2CC = 0;
     58c:	9f300202 	svcls	0x00300202
  UART2LCRH = 0x60;
     590:	00000300 	andeq	r0, r0, r0, lsl #6
  UART2CTL = 0x301;
     594:	02b40400 	adcseq	r0, r4, #0, 8
}
     598:	300202b8 			@ <UNDEFINED> instruction: 0x300202b8
     59c:	02b8049f 	adcseq	r0, r8, #-1627389952	@ 0x9f000000
  RCGCUART |= 3;
     5a0:	550102fa 	strpl	r0, [r1, #-762]	@ 0xfffffd06
     5a4:	00000000 	andeq	r0, r0, r0
     5a8:	04b80400 	ldrteq	r0, [r8], #1024	@ 0x400
     5ac:	500104c0 	andpl	r0, r1, r0, asr #9
  RCGCGPIO |= 3;
     5b0:	8a04c004 	bhi	1305c8 <__ROM_SIZE__+0xf05c8>
     5b4:	00550105 	subseq	r0, r5, r5, lsl #2
     5b8:	00000000 	andeq	r0, r0, r0
  GPIODEN = 0x03;
     5bc:	c304b804 	movwgt	fp, #18436	@ 0x4804
     5c0:	04510104 	ldrbeq	r0, [r1], #-260	@ 0xfffffefc
  GPIOAFSEL = 0x03;
     5c4:	058a04c3 	streq	r0, [sl, #1219]	@ 0x4c3
  GPIOPCTL |= 0x00000011;
     5c8:	00005401 	andeq	r5, r0, r1, lsl #8
     5cc:	04000000 	streq	r0, [r0], #-0
     5d0:	04c304b8 	strbeq	r0, [r3], #1208	@ 0x4b8
  GPIODEN2 = 0x03;
     5d4:	c3045201 	movwgt	r5, #16897	@ 0x4201
     5d8:	04058a04 	streq	r8, [r5], #-2564	@ 0xfffff5fc
  GPIOAFSEL2 = 0x03;
     5dc:	9f5201a3 	svcls	0x005201a3
  GPIOPCTL2 |= 0x00000011;
     5e0:	00000100 	andeq	r0, r0, r0, lsl #2
     5e4:	00000101 	andeq	r0, r0, r1, lsl #2
     5e8:	04be0400 	ldrteq	r0, [lr], #1024	@ 0x400
}
     5ec:	300204cc 	andcc	r0, r2, ip, asr #9
     5f0:	04cc049f 	strbeq	r0, [ip], #1183	@ 0x49f
void platform_init() {
     5f4:	50010580 	andpl	r0, r1, r0, lsl #11
    pin_setup();
     5f8:	86058004 	strhi	r8, [r5], -r4
    uart_init();
     5fc:	01700305 	cmneq	r0, r5, lsl #6
    uart2_init();
     600:	0586049f 	streq	r0, [r6, #1183]	@ 0x49f
    set_read_char(ugetc);
     604:	5001058a 	andpl	r0, r1, sl, lsl #11
    set_read_char2(u2getc);
     608:	00000200 	andeq	r0, r0, r0, lsl #4
     60c:	04be0400 	ldrteq	r0, [lr], #1024	@ 0x400
    set_write_char(uputc);
     610:	300204cc 	andcc	r0, r2, ip, asr #9
    set_write_char2(u2putc);
     614:	04cc049f 	strbeq	r0, [ip], #1183	@ 0x49f
     618:	5301058a 	movwpl	r0, #5514	@ 0x158a
}
     61c:	00000000 	andeq	r0, r0, r0
     620:	04c60400 	strbeq	r0, [r6], #1024	@ 0x400
     624:	500104ca 	andpl	r0, r1, sl, asr #9
     628:	8a04ca04 	bhi	132e40 <__ROM_SIZE__+0xf2e40>
int aes_test(int argc, char** argv) {
     62c:	005c0105 	subseq	r0, ip, r5, lsl #2
    uint8_t text[17] = "0123456789abcdef";
     630:	00000000 	andeq	r0, r0, r0
     634:	ce040000 	cdpgt	0, 0, cr0, cr4, cr0, {0}
     638:	0107e807 	tsteq	r7, r7, lsl #16
     63c:	07e80450 	ubfxeq	r0, r0, #8, #9
     640:	580108e0 	stmdapl	r1, {r5, r6, r7, fp}
    printf("Plaintext is %s\n", text);
     644:	f008e004 			@ <UNDEFINED> instruction: 0xf008e004
     648:	00500108 	subseq	r0, r0, r8, lsl #2
    AES_ECB_encrypt(&ctx, text);
     64c:	00000000 	andeq	r0, r0, r0
     650:	ce040000 	cdpgt	0, 0, cr0, cr4, cr0, {0}
    len = encode_base64(text, 16, b64text);
     654:	0107e807 	tsteq	r7, r7, lsl #16
     658:	07e80451 	ubfxeq	r0, r1, #8, #9
     65c:	560108e0 	strpl	r0, [r1], -r0, ror #17
    b64text[len] = '\0';
     660:	f008e004 			@ <UNDEFINED> instruction: 0xf008e004
     664:	00510108 	subseq	r0, r1, r8, lsl #2
     668:	00000000 	andeq	r0, r0, r0
    printf("Encrypted/encoded is %s\n", b64text);
     66c:	a007e804 	andge	lr, r7, r4, lsl #16
     670:	04550108 	ldrbeq	r0, [r5], #-264	@ 0xfffffef8
    printf2("FOB_MESG AESB64 %s\n", b64text);
     674:	08e008a4 	stmiaeq	r0!, {r2, r5, r7, fp}^
     678:	00005501 	andeq	r5, r0, r1, lsl #10
    printf("Test the mesg handler with CAR_MESG AESB64 %s\n", b64text);
     67c:	04000000 	streq	r0, [r0], #-0
     680:	08a007e8 	stmiaeq	r0!, {r3, r5, r6, r7, r8, r9, sl}
    len = decode_base64(b64text, len, decoded);
     684:	a4045901 	strge	r5, [r4], #-2305	@ 0xfffff6ff
     688:	0108e008 	tsteq	r8, r8
     68c:	01000059 	qaddeq	r0, r9, r0
    AES_ECB_decrypt(&ctx, decoded);
     690:	00000001 	andeq	r0, r0, r1
     694:	e8040000 	stmda	r4, {}	@ <UNPREDICTABLE>
    decoded[len] = '\0';
     698:	01088607 	tsteq	r8, r7, lsl #12
     69c:	0886045a 	stmeq	r6, {r1, r3, r4, r6, sl}
     6a0:	55010894 	strpl	r0, [r1, #-2196]	@ 0xfffff76c
    printf("After encrypting->encoding->decoding->decrypting we recover %s\n", decoded);
     6a4:	9a089404 	bls	2256bc <__ROM_SIZE__+0x1e56bc>
     6a8:	045a0108 	ldrbeq	r0, [sl], #-264	@ 0xfffffef8
}
     6ac:	08a808a4 	stmiaeq	r8!, {r2, r5, r7, fp}
     6b0:	00005a01 	andeq	r5, r0, r1, lsl #20
     6b4:	00000000 	andeq	r0, r0, r0
     6b8:	04000000 	streq	r0, [r0], #-0
     6bc:	059c058a 	ldreq	r0, [ip, #1418]	@ 0x58a
     6c0:	9c045001 	stcls	0, cr5, [r4], {1}
     6c4:	0105c205 	tsteq	r5, r5, lsl #4
     6c8:	05c20456 	strbeq	r0, [r2, #1110]	@ 0x456
     6cc:	500105c4 	andpl	r0, r1, r4, asr #11
int pair(int argc, char** argv) {
     6d0:	c605c404 	strgt	ip, [r5], -r4, lsl #8
    printf("Sending a pair request.\n");
     6d4:	01a30405 			@ <UNDEFINED> instruction: 0x01a30405
    printf2("FOB_MESG PAIR\n");
     6d8:	00009f50 	andeq	r9, r0, r0, asr pc
     6dc:	00000000 	andeq	r0, r0, r0
}
     6e0:	058a0400 	streq	r0, [sl, #1024]	@ 0x400
     6e4:	5101059f 			@ <UNDEFINED> instruction: 0x5101059f
     6e8:	c2059f04 	andgt	r9, r5, #4, 30
int encode64(int argc, char** argv) {
     6ec:	04550105 	ldrbeq	r0, [r5], #-261	@ 0xfffffefb
    if (argc > 1) {
     6f0:	05c605c2 	strbeq	r0, [r6, #1474]	@ 0x5c2
     6f4:	00005101 	andeq	r5, r0, r1, lsl #2
        len = strlen(argv[1]);
     6f8:	00000000 	andeq	r0, r0, r0
     6fc:	058a0400 	streq	r0, [sl, #1024]	@ 0x400
        if (len < MAXARRAYLEN) {
     700:	5201059f 	andpl	r0, r1, #666894336	@ 0x27c00000
            len = encode_base64((uint8_t *) argv[1], len, encoded);
     704:	c2059f04 	andgt	r9, r5, #4, 30
     708:	04540105 	ldrbeq	r0, [r4], #-261	@ 0xfffffefb
            printf("Encoded %s as %s with %d characters\n", argv[1], encoded, len);
     70c:	05c605c2 	strbeq	r0, [r6, #1474]	@ 0x5c2
     710:	00005201 	andeq	r5, r0, r1, lsl #4
     714:	04000000 	streq	r0, [r0], #-0
            printf("String exceeds max length of %d characters", MAXARRAYLEN);
     718:	05b605a6 	ldreq	r0, [r6, #1446]!	@ 0x5a6
     71c:	ba045301 	blt	115328 <__ROM_SIZE__+0xd5328>
     720:	0105c205 	tsteq	r5, r5, lsl #4
        printf("Usage is 'encode64 string'\n");
     724:	00000053 	andeq	r0, r0, r3, asr r0
}
     728:	c0040000 	andgt	r0, r4, r0
     72c:	0101da01 	tsteq	r1, r1, lsl #20
     730:	01da0450 	bicseq	r0, sl, r0, asr r4
     734:	a3040280 	movwge	r0, #17024	@ 0x4280
     738:	009f5001 	addseq	r5, pc, r1
int decode64(int argc, char** argv) {
     73c:	00000000 	andeq	r0, r0, r0
    if (argc > 1) {
     740:	da01c004 	ble	70758 <__ROM_SIZE__+0x30758>
     744:	04510101 	ldrbeq	r0, [r1], #-257	@ 0xfffffeff
        int len = strlen(argv[1]);
     748:	028001da 	addeq	r0, r0, #-2147483594	@ 0x80000036
     74c:	5101a304 	tstpl	r1, r4, lsl #6
        if (len < MAXBASE64LEN) {
     750:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
                len = decode_base64((uint8_t *) argv[1], len, plaintext);
     754:	f401c804 	vst2.8	{d12-d13}, [r1], r4
     758:	00550101 	subseq	r0, r5, r1, lsl #2
                plaintext[len] = '\0';
     75c:	00000001 	andeq	r0, r0, r1
     760:	c8040000 	stmdagt	r4, {}	@ <UNPREDICTABLE>
     764:	0201d401 	andeq	sp, r1, #16777216	@ 0x1000000
                printf("Decoded %s as: %s\n", argv[1], plaintext);
     768:	d4049f30 	strle	r9, [r4], #-3888	@ 0xfffff0d0
     76c:	0101d601 	tsteq	r1, r1, lsl #12
     770:	01d60454 	bicseq	r0, r6, r4, asr r4
            printf("String exceeds max base64 string length of %d characters", MAXBASE64LEN);
     774:	300201da 	ldrdcc	r0, [r2], -sl
     778:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
     77c:	f401da04 	vst1.8	{d13-d14}, [r1], r4
        printf("Usage is 'decode64 string'\n");
     780:	00540101 	subseq	r0, r4, r1, lsl #2
}
     784:	00000000 	andeq	r0, r0, r0
     788:	f0040000 			@ <UNDEFINED> instruction: 0xf0040000
     78c:	0103fb03 	tsteq	r3, r3, lsl #22	@ <UNPREDICTABLE>
     790:	03fb0450 	mvnseq	r0, #80, 8	@ 0x50000000
     794:	550104ac 	strpl	r0, [r1, #-1196]	@ 0xfffffb54
int ecdh_test(int argc, char** argv) {
     798:	b804ac04 	stmdalt	r4, {r2, sl, fp, sp, pc}
    uint8_t b64privkey2[32] = "wP/uwP/uwP/uwP/uwP/uwP/uwP/uwP/u";
     79c:	00500104 	subseq	r0, r0, r4, lsl #2
     7a0:	8e040000 	cdphi	0, 0, cr0, cr4, cr0, {0}
     7a4:	01049a04 	tsteq	r4, r4, lsl #20
     7a8:	00000050 	andeq	r0, r0, r0, asr r0
     7ac:	00000000 	andeq	r0, r0, r0
    printf("Testing the ecdh key exchange\n");
     7b0:	c506b804 	strgt	fp, [r6, #-2052]	@ 0xfffff7fc
     7b4:	04500106 	ldrbeq	r0, [r0], #-262	@ 0xfffffefa
    decode_base64(ECDH_privkey_b64, 32, ECDH_privkey);
     7b8:	079006c5 	ldreq	r0, [r0, r5, asr #13]
     7bc:	90045401 	andls	r5, r4, r1, lsl #8
     7c0:	04079807 	streq	r9, [r7], #-2055	@ 0xfffff7f9
    decode_base64(b64privkey2, 32, privkey2);
     7c4:	9f5001a3 	svcls	0x005001a3
     7c8:	00000000 	andeq	r0, r0, r0
    ecdh_generate_keys(ECDH_pubkey, ECDH_privkey);
     7cc:	04000000 	streq	r0, [r0], #-0
     7d0:	06c206b8 			@ <UNDEFINED> instruction: 0x06c206b8
     7d4:	c2045101 	andgt	r5, r4, #1073741824	@ 0x40000000
    ecdh_generate_keys(pubkey2, privkey2);
     7d8:	01079006 	tsteq	r7, r6
     7dc:	07900455 			@ <UNDEFINED> instruction: 0x07900455
    ecdh_shared_secret(ECDH_privkey, pubkey2, ECDH_shared);
     7e0:	a3040798 	movwge	r0, #18328	@ 0x4798
     7e4:	009f5101 	addseq	r5, pc, r1, lsl #2
     7e8:	f0040000 			@ <UNDEFINED> instruction: 0xf0040000
    ecdh_shared_secret(privkey2, ECDH_pubkey, sharedsecret2);
     7ec:	0106fd06 	tsteq	r6, r6, lsl #26	@ <UNPREDICTABLE>
     7f0:	00000053 	andeq	r0, r0, r3, asr r0
    sha256_init(&shactx);
     7f4:	00000000 	andeq	r0, r0, r0
     7f8:	c6040000 	strgt	r0, [r4], -r0
	sha256_update(&shactx, ECDH_shared, ECC_PUB_KEY_SIZE);
     7fc:	0105e605 	tsteq	r5, r5, lsl #12
     800:	05e60450 	strbeq	r0, [r6, #1104]!	@ 0x450
	sha256_final(&shactx, ECDH_AESkey);
     804:	540105ec 	strpl	r0, [r1], #-1516	@ 0xfffffa14
     808:	f305ec04 			@ <UNDEFINED> instruction: 0xf305ec04
     80c:	04500105 	ldrbeq	r0, [r0], #-261	@ 0xfffffefb
    len = encode_base64(ECDH_AESkey, AES_KEYLEN, b64test);
     810:	06b805f3 			@ <UNDEFINED> instruction: 0x06b805f3
     814:	00005401 	andeq	r5, r0, r1, lsl #8
    b64test[len] = '\0';
     818:	00000000 	andeq	r0, r0, r0
     81c:	04000000 	streq	r0, [r0], #-0
     820:	05e405c6 	strbeq	r0, [r4, #1478]!	@ 0x5c6
     824:	e4045101 	str	r5, [r4], #-257	@ 0xfffffeff
    printf("First shared key is %s\n", b64test);
     828:	0405ec05 	streq	lr, [r5], #-3077	@ 0xfffff3fb
     82c:	9f5101a3 	svcls	0x005101a3
    sha256_init(&shactx);
     830:	f005ec04 			@ <UNDEFINED> instruction: 0xf005ec04
    sha256_update(&shactx, sharedsecret2, ECC_PUB_KEY_SIZE);
     834:	04510105 	ldrbeq	r0, [r1], #-261	@ 0xfffffefb
     838:	06b805f0 			@ <UNDEFINED> instruction: 0x06b805f0
     83c:	00005501 	andeq	r5, r0, r1, lsl #10
	sha256_final(&shactx, keytest);
     840:	068e0400 	streq	r0, [lr], r0, lsl #8
     844:	51010696 			@ <UNDEFINED> instruction: 0x51010696
    len = encode_base64(keytest, AES_KEYLEN, b64test);
     848:	00000000 	andeq	r0, r0, r0
     84c:	01880400 	orreq	r0, r8, r0, lsl #8
    b64test[len] = '\0';
     850:	5001018e 	andpl	r0, r1, lr, lsl #3
     854:	9a018e04 	bls	6406c <__ROM_SIZE__+0x2406c>
     858:	00540101 	subseq	r0, r4, r1, lsl #2
    printf("Should be same as %s\n", b64test);
     85c:	00000199 	muleq	r0, r9, r1
     860:	00040005 	andeq	r0, r4, r5
	...
    AES_init_ctx(&ctx, ECDH_AESkey);
     86c:	ab03a004 	blge	e8884 <__ROM_SIZE__+0xa8884>
     870:	04500103 	ldrbeq	r0, [r0], #-259	@ 0xfffffefd
}
     874:	04dc03ab 	ldrbeq	r0, [ip], #939	@ 0x3ab
     878:	00005401 	andeq	r5, r0, r1, lsl #8
     87c:	04000000 	streq	r0, [r0], #-0
     880:	03ab03a0 			@ <UNDEFINED> instruction: 0x03ab03a0
     884:	ab045101 	blge	114c90 <__ROM_SIZE__+0xd4c90>
     888:	0404dc03 	streq	sp, [r4], #-3075	@ 0xfffff3fd
     88c:	9f5101a3 	svcls	0x005101a3
     890:	00000000 	andeq	r0, r0, r0
     894:	03a00400 	moveq	r0, #0, 8
     898:	520103ab 	andpl	r0, r1, #-1409286142	@ 0xac000002
     89c:	dc03ab04 			@ <UNDEFINED> instruction: 0xdc03ab04
     8a0:	00560104 	subseq	r0, r6, r4, lsl #2
int send_ping(int argc, char** argv) {
     8a4:	00000000 	andeq	r0, r0, r0
    printf("Pinging the car.\n");
     8a8:	b203ae04 	andlt	sl, r3, #4, 28	@ 0x40
    printf2("FOB_MESG PING\n");
     8ac:	04500103 	ldrbeq	r0, [r0], #-259	@ 0xfffffefd
     8b0:	04dc03b2 	ldrbeq	r0, [ip], #946	@ 0x3b2
}
     8b4:	02005801 	andeq	r5, r0, #65536	@ 0x10000
     8b8:	04000000 	streq	r0, [r0], #-0
     8bc:	03b203ae 			@ <UNDEFINED> instruction: 0x03b203ae
int sha256_test(int argc, char** argv) {
     8c0:	049f3202 	ldreq	r3, [pc], #514	@ 8c8 <sha256_test+0x8>
    printf("Starting sha256 test\n");
     8c4:	04dc03b2 	ldrbeq	r0, [ip], #946	@ 0x3b2
     8c8:	00005701 	andeq	r5, r0, r1, lsl #14
    BYTE text1[] = {"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"};
     8cc:	04000000 	streq	r0, [r0], #-0
     8d0:	01ce01b8 	strheq	r0, [lr, #24]
     8d4:	ce045001 	cdpgt	0, 0, cr5, cr4, cr1, {0}
     8d8:	0103a001 	tsteq	r3, r1
     8dc:	00000054 	andeq	r0, r0, r4, asr r0
     8e0:	b8040000 	stmdalt	r4, {}	@ <UNPREDICTABLE>
     8e4:	0101ce01 	tsteq	r1, r1, lsl #28
     8e8:	01ce0451 	biceq	r0, lr, r1, asr r4
     8ec:	580103a0 	stmdapl	r1, {r5, r7, r8, r9}
    BYTE hash1[SHA256_BLOCK_SIZE] = {0x24,0x8d,0x6a,0x61,0xd2,0x06,0x38,0xb8,0xe5,0xc0,0x26,0x93,0x0c,0x3e,0x60,0x39,
     8f0:	00000000 	andeq	r0, r0, r0
     8f4:	01b80400 			@ <UNDEFINED> instruction: 0x01b80400
     8f8:	520101ce 	andpl	r0, r1, #-2147483597	@ 0x80000033
     8fc:	a001ce04 	andge	ip, r1, r4, lsl #28
    sha256_init(&shactx);
     900:	00550103 	subseq	r0, r5, r3, lsl #2
	sha256_update(&shactx, text1, strlen((char *)text1));
     904:	ca040000 	bgt	10090c <__ROM_SIZE__+0xc090c>
     908:	0103a001 	tsteq	r3, r1
     90c:	00020057 	andeq	r0, r2, r7, asr r0
     910:	ca040000 	bgt	100918 <__ROM_SIZE__+0xc0918>
	sha256_final(&shactx, buf);
     914:	0201ce01 	andeq	ip, r1, #1, 28
     918:	ce049f30 	mcrgt	15, 0, r9, cr4, cr0, {1}
    len = encode_base64(hash1, SHA256_BLOCK_SIZE, b64_hash1);
     91c:	0103a001 	tsteq	r3, r1
     920:	00000056 	andeq	r0, r0, r6, asr r0
     924:	84040000 	strhi	r0, [r4], #-0
    b64_hash1[len] = '\0';
     928:	01018e01 	tsteq	r1, r1, lsl #28
    len = encode_base64(buf, SHA256_BLOCK_SIZE, b64_buf);
     92c:	018e0450 	orreq	r0, lr, r0, asr r4
     930:	540101a2 	strpl	r0, [r1], #-418	@ 0xfffffe5e
     934:	00000000 	andeq	r0, r0, r0
    b64_buf[len] = '\0';
     938:	04000000 	streq	r0, [r0], #-0
    printf("Base64 of SHA-256 test is %s\n", b64_buf);
     93c:	018e0184 	orreq	r0, lr, r4, lsl #3
     940:	8e045101 	adfhis	f5, f4, f1
    printf("Should be %s\n", b64_hash1);
     944:	0101a201 	tsteq	r1, r1, lsl #4
     948:	01a20456 			@ <UNDEFINED> instruction: 0x01a20456
}
     94c:	540101ac 	strpl	r0, [r1], #-428	@ 0xfffffe54
     950:	00000100 	andeq	r0, r0, r0, lsl #2
     954:	018a0400 	orreq	r0, sl, r0, lsl #8
     958:	5001018e 	andpl	r0, r1, lr, lsl #3
     95c:	b8018e04 	stmdalt	r1, {r2, r9, sl, fp, pc}
     960:	00550101 	subseq	r0, r5, r1, lsl #2
void __attribute__((optimize("O0"), weak)) initial_setup(void) {
     964:	00000000 	andeq	r0, r0, r0
     968:	70040000 	andvc	r0, r4, r0
  char *src = &_etext, *dst = &_data;
     96c:	04500172 	ldrbeq	r0, [r0], #-370	@ 0xfffffe8e
     970:	70037872 	andvc	r7, r3, r2, ror r8
  if (dst != src)
     974:	78049f7e 	stmdavc	r4, {r1, r2, r3, r4, r5, r6, r8, r9, sl, fp, ip, pc}
     978:	a3040184 	movwge	r0, #16772	@ 0x4184
    while (dst < &_edata) *(dst++) = *(src++);
     97c:	009f5001 	addseq	r5, pc, r1
     980:	00000000 	andeq	r0, r0, r0
     984:	01363204 	teqeq	r6, r4, lsl #4
     988:	70360450 	eorsvc	r0, r6, r0, asr r4
     98c:	5001a304 	andpl	sl, r1, r4, lsl #6
     990:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
	...
  for (dst = &_bss; dst < &_ebss; dst++) *dst = 0;
     9a8:	00040000 	andeq	r0, r4, r0
     9ac:	04500116 	ldrbeq	r0, [r0], #-278	@ 0xfffffeea
  platform_init();
     9b0:	a3041816 	movwge	r1, #18454	@ 0x4816
}
     9b4:	049f5001 	ldreq	r5, [pc], #1	@ 9bc <initial_setup+0x58>
     9b8:	50011a18 	andpl	r1, r1, r8, lsl sl
     9bc:	041e1a04 	ldreq	r1, [lr], #-2564	@ 0xfffff5fc
     9c0:	9f5001a3 	svcls	0x005001a3
     9c4:	01201e04 			@ <UNDEFINED> instruction: 0x01201e04
     9c8:	24200450 	strtcs	r0, [r0], #-1104	@ 0xfffffbb0
     9cc:	5001a304 	andpl	sl, r1, r4, lsl #6
static void delete(void) {
     9d0:	2624049f 			@ <UNDEFINED> instruction: 0x2624049f
  __write_char__(BACK_SPACE);
     9d4:	26045001 	strcs	r5, [r4], -r1
     9d8:	01a3042a 			@ <UNDEFINED> instruction: 0x01a3042a
  __write_char__(SPACE);
     9dc:	2a049f50 	bcs	128724 <__ROM_SIZE__+0xe8724>
  __write_char__(BACK_SPACE);
     9e0:	0450012c 	ldrbeq	r0, [r0], #-300	@ 0xfffffed4
     9e4:	a3042e2c 	movwge	r2, #20012	@ 0x4e2c
}
     9e8:	049f5001 	ldreq	r5, [pc], #1	@ 9f0 <clear_prompt+0x4>
static void clear_prompt(int char_count) {
     9ec:	5001302e 	andpl	r3, r1, lr, lsr #32
  while (char_count) {
     9f0:	04323004 	ldrteq	r3, [r2], #-4
    delete ();
     9f4:	9f5001a3 	svcls	0x005001a3
  while (char_count) {
     9f8:	00028d00 	andeq	r8, r2, r0, lsl #26
}
     9fc:	04000500 	streq	r0, [r0], #-1280	@ 0xfffffb00
	...
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
     a0c:	04880400 	streq	r0, [r8], #1024	@ 0x400
     a10:	500104a6 	andpl	r0, r1, r6, lsr #9
     a14:	f004a604 			@ <UNDEFINED> instruction: 0xf004a604
     a18:	04540104 	ldrbeq	r0, [r4], #-260	@ 0xfffffefc
     a1c:	058604f0 	streq	r0, [r6, #1264]	@ 0x4f0
}
     a20:	86045001 	strhi	r5, [r4], -r1
static int show_history(int argc, char **argv) {
     a24:	0105ee05 	tsteq	r5, r5, lsl #28
  uint32_t end_index = total_num_commands-1;
     a28:	00000054 	andeq	r0, r0, r4, asr r0
  if (total_num_commands > NUM_HISTORY_ENTRIES) {
     a2c:	00000000 	andeq	r0, r0, r0
     a30:	88040000 	stmdahi	r4, {}	@ <UNPREDICTABLE>
    beg_index = total_num_commands - NUM_HISTORY_ENTRIES;
     a34:	01049804 	tsteq	r4, r4, lsl #16
     a38:	04980451 	ldreq	r0, [r8], #1105	@ 0x451
  uint32_t beg_index = 0;
     a3c:	550104f0 	strpl	r0, [r1, #-1264]	@ 0xfffffb10
    printf("%s\n", cmd_history[index % NUM_HISTORY_ENTRIES]);
     a40:	f404f004 	vst4.8	{d15-d18}, [r4], r4
     a44:	04510104 	ldrbeq	r0, [r1], #-260	@ 0xfffffefc
     a48:	05ee04f4 	strbeq	r0, [lr, #1268]!	@ 0x4f4
     a4c:	00005501 	andeq	r5, r0, r1, lsl #10
  for (uint32_t index = beg_index; index <= end_index; ++index) {
     a50:	01010000 	mrseq	r0, (UNDEF: 1)
}
     a54:	01000000 	mrseq	r0, (UNDEF: 0)
     a58:	00000000 	andeq	r0, r0, r0
     a5c:	00000101 	andeq	r0, r0, r1, lsl #2
     a60:	04000000 	streq	r0, [r0], #-0
int cmd_exec_status(int argc, char **argv) {
     a64:	04960490 	ldreq	r0, [r6], #1168	@ 0x490
  printf("%d\n", __cmd_exec_status);
     a68:	96045201 	strls	r5, [r4], -r1, lsl #4
     a6c:	01049c04 	tsteq	r4, r4, lsl #24
     a70:	049c0453 	ldreq	r0, [ip], #1107	@ 0x453
}
     a74:	730304a2 	movwvc	r0, #13474	@ 0x34a2
     a78:	a2049f01 	andge	r9, r4, #1, 30
     a7c:	0104a604 	tsteq	r4, r4, lsl #12
static int build_info(int argc, char **argv) {
     a80:	04ec0453 	strbteq	r0, [ip], #1107	@ 0x453
  printf("Build: [" SHELL_VERSION ":" USER_REPO_VERSION "] - [" BUILD_USER
     a84:	300204f0 	strdcc	r0, [r2], -r0	@ <UNPREDICTABLE>
}
     a88:	04f0049f 	ldrbteq	r0, [r0], #1183	@ 0x49f
     a8c:	520104f2 	andpl	r0, r1, #-234881024	@ 0xf2000000
static void execute(int argc, char **argv) {
     a90:	f804f204 			@ <UNDEFINED> instruction: 0xf804f204
     a94:	04530104 	ldrbeq	r0, [r3], #-260	@ 0xfffffefc
  for (int i = 0; table[i].command_name != NULL; i++) {
     a98:	04fe04f8 	ldrbteq	r0, [lr], #1272	@ 0x4f8
     a9c:	9f017303 	svcls	0x00017303
     aa0:	8904fe04 	stmdbhi	r4, {r2, r9, sl, fp, ip, sp, lr, pc}
     aa4:	04530105 	ldrbeq	r0, [r3], #-261	@ 0xfffffefb
     aa8:	05ee0596 	strbeq	r0, [lr, #1430]!	@ 0x596
    if (strcmp(argv[0], table[i].command_name) == 0) {
     aac:	00005301 	andeq	r5, r0, r1, lsl #6
     ab0:	04000000 	streq	r0, [r0], #-0
      __cmd_exec_status = table[i].command(argc, &argv[0]);
     ab4:	03d403c8 	bicseq	r0, r4, #200, 6	@ 0x20000003
     ab8:	d4045001 	strle	r5, [r4], #-1
     abc:	01048803 	tsteq	r4, r3, lsl #16
     ac0:	00000054 	andeq	r0, r0, r4, asr r0
     ac4:	c8040000 	stmdagt	r4, {}	@ <UNPREDICTABLE>
    printf("\"%s\": command not found. Use \"help\" to list all command.\n",
     ac8:	0103d403 	tsteq	r3, r3, lsl #8
     acc:	03d40451 	bicseq	r0, r4, #1358954496	@ 0x51000000
    __cmd_exec_status = -1;
     ad0:	57010488 	strpl	r0, [r1, -r8, lsl #9]
     ad4:	00000000 	andeq	r0, r0, r0
     ad8:	03c80400 	biceq	r0, r8, #0, 8
}
     adc:	520103d4 	andpl	r0, r1, #212, 6	@ 0x50000003
     ae0:	8803d404 	stmdahi	r3, {r2, sl, ip, lr, pc}
     ae4:	00560104 	subseq	r0, r6, r4, lsl #2
     ae8:	00000002 	andeq	r0, r0, r2
int help(int argc, char **argv) {
     aec:	d403d004 	strle	sp, [r3], #-4
  if (argc > 1 && (strcmp(argv[1], "-l")==0)) {
     af0:	9f300203 	svcls	0x00300203
     af4:	8803d404 	stmdahi	r3, {r2, sl, ip, lr, pc}
     af8:	00550104 	subseq	r0, r5, r4, lsl #2
     afc:	00000000 	andeq	r0, r0, r0
    printf("use: help -l for list only.\n\n");
     b00:	00040000 	andeq	r0, r4, r0
  bool verbose = true;
     b04:	0450010a 	ldrbeq	r0, [r0], #-266	@ 0xfffffef6
    verbose = false;
     b08:	0102ee0a 	tsteq	r2, sl, lsl #28
    printf("\n");
     b0c:	02ee0459 	rsceq	r0, lr, #1493172224	@ 0x59000000
    i++;
     b10:	a30402f4 	movwge	r0, #17140	@ 0x42f4
  while (table[i].command_name != NULL) {
     b14:	009f5001 	addseq	r5, pc, r1
     b18:	00000000 	andeq	r0, r0, r0
     b1c:	01340004 	teqeq	r4, r4
    printf(table[i].command_name);
     b20:	f4340451 			@ <UNDEFINED> instruction: 0xf4340451
    if (verbose) {
     b24:	01a30402 			@ <UNDEFINED> instruction: 0x01a30402
      printf("\n\t");
     b28:	00009f51 	andeq	r9, r0, r1, asr pc
      printf(table[i].command_help);
     b2c:	08080000 	stmdaeq	r8, {}	@ <UNPREDICTABLE>
     b30:	04000000 	streq	r0, [r0], #-0
     b34:	01be0182 			@ <UNDEFINED> instruction: 0x01be0182
    verbose = false;
     b38:	be045a01 	vmlalt.f32	s10, s8, s2
}
     b3c:	01028a01 	tsteq	r2, r1, lsl #20
     b40:	028a045c 	addeq	r0, sl, #92, 8	@ 0x5c000000
     b44:	7a0602a0 	bvc	1815cc <__ROM_SIZE__+0x1415cc>
     b48:	22007100 	andcs	r7, r0, #0, 2
     b4c:	02a0049f 	adceq	r0, r0, #-1627389952	@ 0x9f000000
     b50:	5c0102f4 	sfmpl	f0, 4, [r1], {244}	@ 0xf4
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
     b54:	00000000 	andeq	r0, r0, r0
static void add_command_to_history(const char *cmd_str) {
     b58:	00000707 	andeq	r0, r0, r7, lsl #14
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
     b5c:	01860400 	orreq	r0, r6, r0, lsl #8
     b60:	5b0101be 	blpl	41260 <__ROM_SIZE__+0x1260>
  int index = total_num_commands % NUM_HISTORY_ENTRIES;
     b64:	8a01be04 	bhi	7037c <__ROM_SIZE__+0x3037c>
     b68:	04550102 	ldrbeq	r0, [r5], #-258	@ 0xfffffefe
     b6c:	02a0028a 	adceq	r0, r0, #-1610612728	@ 0xa0000008
     b70:	a0045c01 	andge	r5, r4, r1, lsl #24
  memcpy(&cmd_history[index], cmd_str, LINE_BUFF_SIZE);
     b74:	0102b802 	tsteq	r2, r2, lsl #16
     b78:	00000055 	andeq	r0, r0, r5, asr r0
     b7c:	00060600 	andeq	r0, r6, r0, lsl #12
     b80:	8a040000 	bhi	100b88 <__ROM_SIZE__+0xc0b88>
  total_num_commands++;
     b84:	0101be01 	tsteq	r1, r1, lsl #28
  curr_command_ptr = total_num_commands;
     b88:	01be0451 			@ <UNDEFINED> instruction: 0x01be0451
     b8c:	5401028a 	strpl	r0, [r1], #-650	@ 0xfffffd76
     b90:	9c028a04 			@ <UNDEFINED> instruction: 0x9c028a04
     b94:	04550102 	ldrbeq	r0, [r5], #-258	@ 0xfffffefe
     b98:	02be029c 	adcseq	r0, lr, #156, 4	@ 0xc0000009
static int parse_line(char **argv, char *line_buff, int argument_size) {
     b9c:	00005401 	andeq	r5, r0, r1, lsl #8
     ba0:	05050000 	streq	r0, [r5, #-0]
  int length = strlen(line_buff);
     ba4:	04000000 	streq	r0, [r0], #-0
     ba8:	01be018e 			@ <UNDEFINED> instruction: 0x01be018e
  int argc = 0;
     bac:	be045301 	cdplt	3, 0, cr5, cr4, cr1, {0}
         pos++)
     bb0:	01028a01 	tsteq	r2, r1, lsl #20
    for (; line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
     bb4:	028a0458 	addeq	r0, sl, #88, 8	@ 0x58000000
     bb8:	5401029a 	strpl	r0, [r1], #-666	@ 0xfffffd66
     bbc:	ee029a04 	vmla.f32	s18, s4, s8
     bc0:	00580102 	subseq	r0, r8, r2, lsl #2
    if (line_buff[pos] == '\t' || line_buff[pos] == SPACE)
     bc4:	00040400 	andeq	r0, r4, r0, lsl #8
     bc8:	94040000 	strls	r0, [r4], #-0
      line_buff[pos] = END_OF_LINE;
     bcc:	01028a01 	tsteq	r2, r1, lsl #20
  while (pos <= length) {
     bd0:	028a0452 	addeq	r0, sl, #1375731712	@ 0x52000000
    if (line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
     bd4:	78060296 	stmdavc	r6, {r1, r2, r4, r7, r9}
     bd8:	22007a00 	andcs	r7, r0, #0, 20
     bdc:	0296049f 	addseq	r0, r6, #-1627389952	@ 0x9f000000
     be0:	520102cc 	andpl	r0, r1, #204, 4	@ 0xc000000c
      argv[argc++] = &line_buff[pos];
     be4:	03030000 	movweq	r0, #12288	@ 0x3000
     be8:	04000000 	streq	r0, [r0], #-0
}
     bec:	028a019a 	addeq	r0, sl, #-2147483610	@ 0x80000026
static int prefix_match(char *sub, int len, const char *str) {
     bf0:	8a045701 	bhi	1167fc <__ROM_SIZE__+0xd67fc>
     bf4:	01029602 	tsteq	r2, r2, lsl #12
  if (sub == NULL || str == NULL || len <= 0 || len > strlen(str)) {
     bf8:	02960452 	addseq	r0, r6, #1375731712	@ 0x52000000
     bfc:	570102d4 			@ <UNDEFINED> instruction: 0x570102d4
     c00:	02020000 	andeq	r0, r2, #0
     c04:	04000000 	streq	r0, [r0], #-0
  for (int i = 0; i<len; ++i) {
     c08:	028a01a0 	addeq	r0, sl, #160, 2	@ 0x28
     c0c:	8a045601 	bhi	116418 <__ROM_SIZE__+0xd6418>
    if (sub[i] != str[i]) {
     c10:	01029202 	tsteq	r2, r2, lsl #4
     c14:	02920457 	addseq	r0, r2, #1459617792	@ 0x57000000
  for (int i = 0; i<len; ++i) {
     c18:	560102dc 			@ <UNDEFINED> instruction: 0x560102dc
}
     c1c:	00000000 	andeq	r0, r0, r0
  return TRUE;
     c20:	00000100 	andeq	r0, r0, r0, lsl #2
      return FALSE;
     c24:	01a60400 			@ <UNDEFINED> instruction: 0x01a60400
}
     c28:	500101b2 			@ <UNDEFINED> instruction: 0x500101b2
static void handle_up_arrow(char *cmd_buff, int *char_count) {
     c2c:	d001b204 	andle	fp, r1, r4, lsl #4
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
     c30:	045e0101 	ldrbeq	r0, [lr], #-257	@ 0xfffffeff
     c34:	0290028a 	addseq	r0, r0, #-1610612728	@ 0xa0000008
     c38:	90045601 	andls	r5, r4, r1, lsl #12
     c3c:	0102f402 	tsteq	r2, r2, lsl #8	@ <UNPREDICTABLE>
      curr_command_ptr == 0) {
     c40:	0002005e 	andeq	r0, r2, lr, asr r0
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
     c44:	00010000 	andeq	r0, r1, r0
    printf("%s", cmd_buff);
     c48:	08040000 	stmdaeq	r4, {}	@ <UNPREDICTABLE>
     c4c:	9f30020e 	svcls	0x0030020e
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
     c50:	01920e04 	orrseq	r0, r2, r4, lsl #28
     c54:	a6045201 	strge	r5, [r4], -r1, lsl #4
  curr_command_ptr--;
     c58:	0201be01 	andeq	fp, r1, #1, 28
     c5c:	be049f30 	mcrlt	15, 0, r9, cr4, cr0, {1}
     c60:	0102b201 	tsteq	r2, r1, lsl #4
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
     c64:	00020050 	andeq	r0, r2, r0, asr r0
     c68:	08040000 	stmdaeq	r4, {}	@ <UNPREDICTABLE>
     c6c:	9f30020e 	svcls	0x0030020e
     c70:	01340e04 	teqeq	r4, r4, lsl #28
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
     c74:	00000050 	andeq	r0, r0, r0, asr r0
     c78:	a001ec04 	andge	lr, r1, r4, lsl #24
     c7c:	005a0102 	subseq	r0, sl, r2, lsl #2
  *char_count = strlen(cmd_buff);
     c80:	8a040000 	bhi	100c88 <__ROM_SIZE__+0xc0c88>
     c84:	0102a002 	tsteq	r2, r2
  printf("%s", cmd_buff);
     c88:	038c0051 	orreq	r0, ip, #81	@ 0x51
     c8c:	00050000 	andeq	r0, r5, r0
     c90:	00000004 	andeq	r0, r0, r4
	...
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
     ca4:	dc040000 	stcle	0, cr0, [r4], {-0}
     ca8:	0202ee02 	andeq	lr, r2, #2, 28
  *char_count = 0;
     cac:	ee047091 	mcr	0, 0, r7, cr4, cr1, {4}
  if (curr_command_ptr == total_num_commands) return;
     cb0:	0103f002 	tsteq	r3, r2	@ <UNPREDICTABLE>
     cb4:	03f00454 	mvnseq	r0, #84, 8	@ 0x54000000
     cb8:	55010484 	strpl	r0, [r1, #-1156]	@ 0xfffffb7c
  curr_command_ptr++;
     cbc:	88048404 	stmdahi	r4, {r2, sl, pc}
     cc0:	04540104 	ldrbeq	r0, [r4], #-260	@ 0xfffffefc
     cc4:	048e0488 	streq	r0, [lr], #1160	@ 0x488
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
     cc8:	8e045501 	cfsh32hi	mvfx5, mvfx4, #1
     ccc:	01049e04 	tsteq	r4, r4, lsl #28
     cd0:	049e0454 	ldreq	r0, [lr], #1108	@ 0x454
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
     cd4:	550104a2 	strpl	r0, [r1, #-1186]	@ 0xfffffb5e
     cd8:	b804ac04 	stmdalt	r4, {r2, sl, fp, sp, pc}
     cdc:	00540104 	subseq	r0, r4, r4, lsl #2
     ce0:	01000001 	tsteq	r0, r1
  *char_count = strlen(cmd_buff);
     ce4:	01000001 	tsteq	r0, r1
     ce8:	01000001 	tsteq	r0, r1
  printf("%s", cmd_buff);
     cec:	01000001 	tsteq	r0, r1
     cf0:	00000001 	andeq	r0, r0, r1
}
     cf4:	01000001 	tsteq	r0, r1
     cf8:	00000001 	andeq	r0, r0, r1
void set_read_char(int (*func)(void)) { __read_char__ = func; }
     cfc:	ee02e804 	cdp	8, 0, cr14, cr2, cr4, {0}
     d00:	9f300202 	svcls	0x00300202
     d04:	8802ee04 	stmdahi	r2, {r2, r9, sl, fp, sp, lr, pc}
void set_read_char2(int (*func)(void)) { __read_char2__ = func; }
     d08:	04550103 	ldrbeq	r0, [r5], #-259	@ 0xfffffefd
     d0c:	038e0388 	orreq	r0, lr, #136, 6	@ 0x20000002
     d10:	049f3102 	ldreq	r3, [pc], #258	@ d18 <set_write_char+0x4>
void set_write_char(void (*func)(char)) { __write_char__ = func; }
     d14:	03bc038e 			@ <UNDEFINED> instruction: 0x03bc038e
     d18:	bc045501 	cfstr32lt	mvfx5, [r4], {1}
     d1c:	0203c003 	andeq	ip, r3, #3
void set_write_char2(void (*func)(char)) { __write_char2__ = func; }
     d20:	c0049f30 	andgt	r9, r4, r0, lsr pc
     d24:	0103d603 	tsteq	r3, r3, lsl #12
     d28:	03d60455 	bicseq	r0, r6, #1426063360	@ 0x55000000
}
     d2c:	300203da 	ldrdcc	r0, [r2], -sl
}
     d30:	03da049f 	bicseq	r0, sl, #-1627389952	@ 0x9f000000
  if (cmd_buff == NULL || char_count <= 0) {
     d34:	550103ea 	strpl	r0, [r1, #-1002]	@ 0xfffffc16
static void handle_tab(char *cmd_buff, int *char_count) {
     d38:	ee03ea04 	vmla.f32	s28, s6, s8
     d3c:	9f300203 	svcls	0x00300203
  int last_match = -1;
     d40:	f003ee04 			@ <UNDEFINED> instruction: 0xf003ee04
  int match_count = 0;
     d44:	04550103 	ldrbeq	r0, [r5], #-259	@ 0xfffffefd
  int i = 0;
     d48:	04880482 	streq	r0, [r8], #1154	@ 0x482
    i++;
     d4c:	049f3002 	ldreq	r3, [pc], #2	@ d54 <handle_tab+0x22>
  while (table[i].command_name != NULL) { //loop over all commands
     d50:	0498048e 	ldreq	r0, [r8], #1166	@ 0x48e
     d54:	98045501 	stmdals	r4, {r0, r8, sl, ip, lr}
     d58:	02049e04 	andeq	r9, r4, #4, 28	@ 0x40
    if (prefix_match(cmd_buff, *char_count, table[i].command_name)) {
     d5c:	ac049f30 	stcge	15, cr9, [r4], {48}	@ 0x30
     d60:	0104b804 	tsteq	r4, r4, lsl #16
     d64:	00010055 	andeq	r0, r1, r5, asr r0
      match_count++;
     d68:	01000000 	mrseq	r0, (UNDEF: 0)
      printf("\n%s", table[i].command_name);
     d6c:	ee040001 	cdp	0, 0, cr0, cr4, cr1, {0}
     d70:	0203f803 	andeq	pc, r3, #196608	@ 0x30000
      last_match = i;
     d74:	f8049f31 			@ <UNDEFINED> instruction: 0xf8049f31
  if (match_count == 1) {
     d78:	0103ff03 	tsteq	r3, r3, lsl #30	@ <UNPREDICTABLE>
     d7c:	04880452 	streq	r0, [r8], #1106	@ 0x452
  if (match_count) {
     d80:	31020488 	smlabbcc	r2, r8, r4, r0
}
     d84:	0488049f 	streq	r0, [r8], #1183	@ 0x49f
    memcpy(cmd_buff, table[last_match].command_name, LINE_BUFF_SIZE);
     d88:	3202048e 	andcc	r0, r2, #-1912602624	@ 0x8e000000
     d8c:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
	...
    printf("\n");
     da8:	1c040000 	stcne	0, cr0, [r4], {-0}
    prepend_prompt();
     dac:	0450014c 	ldrbeq	r0, [r0], #-332	@ 0xfffffeb4
    printf(PROMPT);
     db0:	a304524c 	movwge	r5, #16972	@ 0x424c
     db4:	049f5001 	ldreq	r5, [pc], #1	@ dbc <handle_tab+0x8a>
    printf("%s", cmd_buff);
     db8:	50015852 	andpl	r5, r1, r2, asr r8
     dbc:	04625804 	strbteq	r5, [r2], #-2052	@ 0xfffff7fc
     dc0:	9f5001a3 	svcls	0x005001a3
     dc4:	01726204 	cmneq	r2, r4, lsl #4
     dc8:	a2720450 	rsbsge	r0, r2, #80, 8	@ 0x50000000
     dcc:	01a30401 			@ <UNDEFINED> instruction: 0x01a30401
     dd0:	a2049f50 	andge	r9, r4, #80, 30	@ 0x140
__attribute__((weak)) int active_prompt() { return TRUE; }
     dd4:	0101a801 	tsteq	r1, r1, lsl #16
static void shell(void) {
     dd8:	01a80450 			@ <UNDEFINED> instruction: 0x01a80450
  int count = 0;
     ddc:	a30402b4 	movwge	r0, #17076	@ 0x42b4
  for (int i = 0; i < LINE_BUFF_SIZE; i++) line_buff[i] = 0;
     de0:	049f5001 	ldreq	r5, [pc], #1	@ de8 <shell+0x10>
     de4:	02ba02b4 	adcseq	r0, sl, #180, 4	@ 0x4000000b
     de8:	ba045001 	blt	114df4 <__ROM_SIZE__+0xd4df4>
     dec:	0402be02 	streq	fp, [r2], #-3586	@ 0xfffff1fe
     df0:	9f5001a3 	svcls	0x005001a3
  for (int i = 0; i < MAX_ARG_COUNT; i++) argv[i] = NULL;
     df4:	c002be04 	andgt	fp, r2, r4, lsl #28
     df8:	04500102 	ldrbeq	r0, [r0], #-258	@ 0xfffffefe
     dfc:	02c202c0 	sbceq	r0, r2, #192, 4
     e00:	5001a304 	andpl	sl, r1, r4, lsl #6
     e04:	02c2049f 	sbceq	r0, r2, #-1627389952	@ 0x9f000000
  prepend_prompt();
     e08:	500102c4 	andpl	r0, r1, r4, asr #5
  printf(PROMPT);
     e0c:	dc02c404 	cfstrsle	mvf12, [r2], {4}
  int special_key = 0;
     e10:	01a30402 			@ <UNDEFINED> instruction: 0x01a30402
        special_key = 1;
     e14:	00009f50 	andeq	r9, r0, r0, asr pc
	...
        line_buff[count] = END_OF_LINE;
     e2c:	4d1c0400 	cfldrsmi	mvf0, [ip, #-0]
     e30:	4d045101 	stfmis	f5, [r4, #-4]
     e34:	01a30452 			@ <UNDEFINED> instruction: 0x01a30452
     e38:	52049f51 	andpl	r9, r4, #324	@ 0x144
        __write_char__(NEW_LINE);
     e3c:	0451015b 	ldrbeq	r0, [r1], #-347	@ 0xfffffea5
     e40:	a304625b 	movwge	r6, #16987	@ 0x425b
  add_command_to_history(line_buff);
     e44:	049f5101 	ldreq	r5, [pc], #257	@ e4c <shell+0x74>
  argc = parse_line(argv, line_buff, MAX_ARG_COUNT);
     e48:	51017262 	tstpl	r1, r2, ror #4
     e4c:	01a27204 			@ <UNDEFINED> instruction: 0x01a27204
     e50:	5101a304 	tstpl	r1, r4, lsl #6
  if (argc > 0) execute(argc, argv);
     e54:	01a2049f 			@ <UNDEFINED> instruction: 0x01a2049f
}
     e58:	510101a9 	smlatbpl	r1, r9, r1, r0
        if (!__echo) {
     e5c:	b401a904 	strlt	sl, [r1], #-2308	@ 0xfffff6fc
     e60:	01a30402 			@ <UNDEFINED> instruction: 0x01a30402
        if (count == 0) continue;
     e64:	b4049f51 	strlt	r9, [r4], #-3921	@ 0xfffff0af
        count--;
     e68:	0102ba02 	tsteq	r2, r2, lsl #20
        line_buff[count] = END_OF_LINE;
     e6c:	02ba0451 	adcseq	r0, sl, #1358954496	@ 0x51000000
     e70:	a30402be 	movwge	r0, #17086	@ 0x42be
     e74:	049f5101 	ldreq	r5, [pc], #257	@ e7c <shell+0xa4>
        delete ();
     e78:	02dc02be 	sbcseq	r0, ip, #-536870901	@ 0xe000000b
      if (__echo) {
     e7c:	00005101 	andeq	r5, r0, r1, lsl #2
	...
    if (s == -1) { s = __read_char2__();}
     e98:	3a1c0400 	bcc	701ea0 <__ROM_SIZE__+0x6c1ea0>
     e9c:	3a045201 	bcc	1156a8 <__ROM_SIZE__+0xd56a8>
      if (c == CARRIAGE_RETURN || c == NEW_LINE) {
     ea0:	04540152 	ldrbeq	r0, [r4], #-338	@ 0xfffffeae
     ea4:	52015b52 	andpl	r5, r1, #83968	@ 0x14800
      if (c == DELETE || c == BACK_SPACE) {
     ea8:	015e5b04 	cmpeq	lr, r4, lsl #22
     eac:	625e0454 	subsvs	r0, lr, #84, 8	@ 0x54000000
      } else if (c == ESCAPE) {
     eb0:	5201a304 	andpl	sl, r1, #4, 6	@ 0x10000000
      } else if (c == SQUARE_BRACKET_OPEN && special_key == 1) {
     eb4:	6a62049f 	bvs	1882138 <__ROM_SIZE__+0x1842138>
      } else if ((c == 'C' || c == 'D') && special_key != 0) {
     eb8:	6a045201 	bvs	1156c4 <__ROM_SIZE__+0xd56c4>
     ebc:	04540172 	ldrbeq	r0, [r4], #-370	@ 0xfffffe8e
     ec0:	0401a272 	streq	sl, [r1], #-626	@ 0xfffffd8e
      } else if ((c == 'A' || c == 'B') && special_key == 2) {
     ec4:	9f5201a3 	svcls	0x005201a3
     ec8:	ae01a204 	cdpge	2, 0, cr10, cr1, cr4, {0}
      else if (c == TAB) {
     ecc:	04540101 	ldrbeq	r0, [r4], #-257	@ 0xfffffeff
        line_buff[count] = c;
     ed0:	02b401ae 	adcseq	r0, r4, #-2147483605	@ 0x8000002b
     ed4:	5201a304 	andpl	sl, r1, #4, 6	@ 0x10000000
     ed8:	02b4049f 	adcseq	r0, r4, #-1627389952	@ 0x9f000000
        count++;
     edc:	540102b8 	strpl	r0, [r1], #-696	@ 0xfffffd48
     ee0:	be02b804 	cdplt	8, 0, cr11, cr2, cr4, {0}
          delete ();
     ee4:	01a30402 			@ <UNDEFINED> instruction: 0x01a30402
          delete ();
     ee8:	be049f52 	mcrlt	15, 0, r9, cr4, cr2, {2}
      } else if (c == SQUARE_BRACKET_OPEN && special_key == 1) {
     eec:	0102dc02 	tsteq	r2, r2, lsl #24
        special_key = 2;
     ef0:	00020052 	andeq	r0, r2, r2, asr r0
	...
        if (!__echo) {
     f04:	025e2204 	subseq	r2, lr, #4, 4	@ 0x40000000
          clear_prompt(count + 4);
     f08:	62049f30 	andvs	r9, r4, #48, 30	@ 0xc0
     f0c:	9f300272 	svcls	0x00300272
        if (c == 'A') {
     f10:	01947204 	orrseq	r7, r4, r4, lsl #4
          handle_down_arrow(line_buff, &count);
     f14:	94045401 	strls	r5, [r4], #-1025	@ 0xfffffbff
     f18:	0301a201 	movweq	sl, #4609	@ 0x1201
        continue;
     f1c:	049f7f74 	ldreq	r7, [pc], #3956	@ f24 <shell+0x14c>
          clear_prompt(count);
     f20:	01ae01a2 			@ <UNDEFINED> instruction: 0x01ae01a2
     f24:	049f3002 	ldreq	r3, [pc], #2	@ f2c <shell+0x154>
          handle_up_arrow(line_buff, &count);
     f28:	01e801ae 	mvneq	r0, lr, lsr #3
     f2c:	e8045401 	stmda	r4, {r0, sl, ip, lr}
        handle_tab(line_buff, &count);
     f30:	0301f401 	movweq	pc, #5121	@ 0x1401	@ <UNPREDICTABLE>
     f34:	049f7f74 	ldreq	r7, [pc], #3956	@ f3c <shell+0x164>
        continue;
     f38:	029201f4 	addseq	r0, r2, #244, 2	@ 0x3d
  if (argc > 0) execute(argc, argv);
     f3c:	92045401 	andls	r5, r4, #16777216	@ 0x1000000
}
     f40:	0202dc02 	andeq	sp, r2, #512	@ 0x200
     f44:	01009f30 	tsteq	r0, r0, lsr pc
	...
void prompt() {
     f50:	6e620400 	cdpvs	4, 6, cr0, cr2, cr0, {0}
  initial_setup();
     f54:	049f3002 	ldreq	r3, [pc], #2	@ f5c <prompt+0xc>
  exec_auto_cmds();
     f58:	01019c72 	tsteq	r1, r2, ror ip
  setup();
     f5c:	019c0455 	orrseq	r0, ip, r5, asr r4
  decode_base64(AES_key_b64, 44, AES_key);
     f60:	510101a2 	smlatbpl	r1, r2, r1, r0
     f64:	ca01ac04 	bgt	6bf7c <__ROM_SIZE__+0x2bf7c>
     f68:	04550101 	ldrbeq	r0, [r5], #-257	@ 0xfffffeff
     f6c:	02c202be 	sbceq	r0, r2, #-536870901	@ 0xe000000b
  AES_init_ctx(&ctx, AES_key);
     f70:	009f3002 	addseq	r3, pc, r2
     f74:	00000001 	andeq	r0, r0, r1
    shell();
     f78:	00000000 	andeq	r0, r0, r0
  while (TRUE) {
     f7c:	30040000 	andcc	r0, r4, r0
     f80:	9f30023e 	svcls	0x0030023e
     f84:	f001ca04 			@ <UNDEFINED> instruction: 0xf001ca04
int exec(char *cmd_str) {
     f88:	04550101 	ldrbeq	r0, [r5], #-257	@ 0xfffffeff
     f8c:	01f401f0 	ldrsheq	r0, [r4, #16]!
  argc = parse_line(argv, cmd_str, MAX_ARG_COUNT);
     f90:	f4045101 	vst4.8	{d5,d7,d9,d11}, [r4], r1
     f94:	01029201 	tsteq	r2, r1, lsl #4
  if (argc > 0) execute(argc, argv);
     f98:	02c20455 	sbceq	r0, r2, #1426063360	@ 0x55000000
  return __cmd_exec_status;
     f9c:	300202dc 	ldrdcc	r0, [r2], -ip
}
     fa0:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
     fa4:	92040000 	andls	r0, r4, #0
  if (argc > 0) execute(argc, argv);
     fa8:	0102b402 	tsteq	r2, r2, lsl #8
     fac:	02ba0454 	adcseq	r0, sl, #84, 8	@ 0x54000000
     fb0:	540102be 	strpl	r0, [r1], #-702	@ 0xfffffd42
cmd get_function_addr(char *cmd_str) {
     fb4:	01010000 	mrseq	r0, (UNDEF: 1)
  for (int i = 0; table[i].command_name != NULL; i++) {
     fb8:	00000000 	andeq	r0, r0, r0
     fbc:	02920400 	addseq	r0, r2, #0, 8
     fc0:	52010292 	andpl	r0, r1, #536870921	@ 0x20000009
     fc4:	9e029204 	cdpls	2, 0, cr9, cr2, cr4, {0}
     fc8:	9f310202 	svcls	0x00310202
    if (strcmp(cmd_str, table[i].command_name) == 0) {
     fcc:	b4029e04 	strlt	r9, [r2], #-3588	@ 0xfffff1fc
     fd0:	04520102 	ldrbeq	r0, [r2], #-258	@ 0xfffffefe
      return table[i].command;
     fd4:	02be02ba 	adcseq	r0, lr, #-1610612725	@ 0xa000000b
     fd8:	00005201 	andeq	r5, r0, r1, lsl #4
  return NULL;
     fdc:	00000000 	andeq	r0, r0, r0
}
     fe0:	04000000 	streq	r0, [r0], #-0
  if(v < 26) return v + 'A';
     fe4:	029b0292 	addseq	r0, fp, #536870921	@ 0x20000009
  if(v < 52) return v + 71;
     fe8:	9b045301 	blls	115bf4 <__ROM_SIZE__+0xd5bf4>
  if(v < 62) return v - 4;
     fec:	0802a002 	stmdaeq	r2, {r1, sp, pc}
  if(v == 62) return '+';
     ff0:	00740075 	rsbseq	r0, r4, r5, ror r0
  if(v == 63) return '/';
     ff4:	9f1a3f25 	svcls	0x001a3f25
  return 64;
     ff8:	ac02a804 	stcge	8, cr10, [r2], {4}
  if(v < 26) return v + 'A';
     ffc:	00730502 	rsbseq	r0, r3, r2, lsl #10
    1000:	049f1a3f 	ldreq	r1, [pc], #2623	@ 1008 <binary_to_base64+0x24>
  if(v < 52) return v + 71;
    1004:	02b402ac 	adcseq	r0, r4, #172, 4	@ 0xc000000a
  if(v < 62) return v - 4;
    1008:	00005301 	andeq	r5, r0, r1, lsl #6
    100c:	04000000 	streq	r0, [r0], #-0
  if(v == 62) return '+';
    1010:	50010600 	andpl	r0, r1, r0, lsl #12
}
    1014:	01160604 	tsteq	r6, r4, lsl #12
  if('A' <= c && c <= 'Z') return c - 'A';
    1018:	038c0054 	orreq	r0, ip, #84	@ 0x54
    101c:	00050000 	andeq	r0, r5, r0
  if('a' <= c && c <= 'z') return c - 71;
    1020:	00000004 	andeq	r0, r0, r4
	...
  if(c == '+') return 62;
    1034:	dc040000 	stcle	0, cr0, [r4], {-0}
  if(c == '/') return 63;
    1038:	0202ee02 	andeq	lr, r2, #2, 28
  return 255;
    103c:	ee047091 	mcr	0, 0, r7, cr4, cr1, {4}
  if('a' <= c && c <= 'z') return c - 71;
    1040:	0103f002 	tsteq	r3, r2	@ <UNPREDICTABLE>
    1044:	03f00454 	mvnseq	r0, #84, 8	@ 0x54000000
  if('0' <= c && c <= '9') return c + 4;
    1048:	55010484 	strpl	r0, [r1, #-1156]	@ 0xfffffb7c
  if(c == '+') return 62;
    104c:	88048404 	stmdahi	r4, {r2, sl, pc}
  if(c == '/') return 63;
    1050:	04540104 	ldrbeq	r0, [r4], #-260	@ 0xfffffefc
  return (input_length + 2)/3*4;
    1054:	048e0488 	streq	r0, [lr], #1160	@ 0x488
    1058:	8e045501 	cfsh32hi	mvfx5, mvfx4, #1
    105c:	01049e04 	tsteq	r4, r4, lsl #28
}
    1060:	049e0454 	ldreq	r0, [lr], #1108	@ 0x454
    1064:	550104a2 	strpl	r0, [r1, #-1186]	@ 0xfffffb5e
unsigned int decode_base64_length(unsigned char input[], unsigned int input_length) {
    1068:	b804ac04 	stmdalt	r4, {r2, sl, fp, sp, pc}
    106c:	00540104 	subseq	r0, r4, r4, lsl #2
  while(base64_to_binary(input[0]) < 64 && (unsigned int) (input - start) < input_length) {
    1070:	01000001 	tsteq	r0, r1
    1074:	01000001 	tsteq	r0, r1
    1078:	01000001 	tsteq	r0, r1
    107c:	01000001 	tsteq	r0, r1
    1080:	00000001 	andeq	r0, r0, r1
  input_length = input - start;
    1084:	01000001 	tsteq	r0, r1
  return input_length/4*3 + (input_length % 4 ? input_length % 4 - 1 : 0);
    1088:	00000001 	andeq	r0, r0, r1
    108c:	ee02e804 	cdp	8, 0, cr14, cr2, cr4, {0}
    1090:	9f300202 	svcls	0x00300202
}
    1094:	8802ee04 	stmdahi	r2, {r2, r9, sl, fp, sp, lr, pc}
  return input_length/4*3 + (input_length % 4 ? input_length % 4 - 1 : 0);
    1098:	04550103 	ldrbeq	r0, [r5], #-259	@ 0xfffffefd
unsigned int encode_base64(unsigned char input[], unsigned int input_length, unsigned char output[]) {
    109c:	038e0388 	orreq	r0, lr, #136, 6	@ 0x20000002
    10a0:	049f3102 	ldreq	r3, [pc], #258	@ 10a8 <encode_base64+0xc>
    10a4:	03bc038e 			@ <UNDEFINED> instruction: 0x03bc038e
  unsigned int full_sets = input_length/3;
    10a8:	bc045501 	cfstr32lt	mvfx5, [r4], {1}
    10ac:	0203c003 	andeq	ip, r3, #3
  for(unsigned int i = 0; i < full_sets; ++i) {
    10b0:	c0049f30 	andgt	r9, r4, r0, lsr pc
    output[0] = binary_to_base64(                         input[0] >> 2);
    10b4:	0103d603 	tsteq	r3, r3, lsl #12
    10b8:	03d60455 	bicseq	r0, r6, #1426063360	@ 0x55000000
    output[1] = binary_to_base64((input[0] & 0x03) << 4 | input[1] >> 4);
    10bc:	300203da 	ldrdcc	r0, [r2], -sl
    10c0:	03da049f 	bicseq	r0, sl, #-1627389952	@ 0x9f000000
    10c4:	550103ea 	strpl	r0, [r1, #-1002]	@ 0xfffffc16
    10c8:	ee03ea04 	vmla.f32	s28, s6, s8
    10cc:	9f300203 	svcls	0x00300203
    output[2] = binary_to_base64((input[1] & 0x0F) << 2 | input[2] >> 6);
    10d0:	f003ee04 			@ <UNDEFINED> instruction: 0xf003ee04
    10d4:	04550103 	ldrbeq	r0, [r5], #-259	@ 0xfffffefd
    10d8:	04880482 	streq	r0, [r8], #1154	@ 0x482
    10dc:	049f3002 	ldreq	r3, [pc], #2	@ 10e4 <encode_base64+0x48>
    10e0:	0498048e 	ldreq	r0, [r8], #1166	@ 0x48e
    output[3] = binary_to_base64( input[2] & 0x3F);
    10e4:	98045501 	stmdals	r4, {r0, r8, sl, ip, lr}
    10e8:	02049e04 	andeq	r9, r4, #4, 28	@ 0x40
    10ec:	ac049f30 	stcge	15, cr9, [r4], {48}	@ 0x30
    input += 3;
    10f0:	0104b804 	tsteq	r4, r4, lsl #16
  for(unsigned int i = 0; i < full_sets; ++i) {
    10f4:	00010055 	andeq	r0, r1, r5, asr r0
    10f8:	01000000 	mrseq	r0, (UNDEF: 0)
  switch(input_length % 3) {
    10fc:	ee040001 	cdp	0, 0, cr0, cr4, cr1, {0}
    1100:	0203f803 	andeq	pc, r3, #196608	@ 0x30000
    1104:	f8049f31 			@ <UNDEFINED> instruction: 0xf8049f31
    1108:	0103ff03 	tsteq	r3, r3, lsl #30	@ <UNPREDICTABLE>
    110c:	04880452 	streq	r0, [r8], #1106	@ 0x452
    1110:	31020488 	smlabbcc	r2, r8, r4, r0
    1114:	0488049f 	streq	r0, [r8], #1183	@ 0x49f
  return encode_base64_length(input_length);
    1118:	3202048e 	andcc	r0, r2, #-1912602624	@ 0x8e000000
}
    111c:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
	...
      output[1] = binary_to_base64((input[0] & 0x03) << 4);
    1138:	1c040000 	stcne	0, cr0, [r4], {-0}
      output[2] = '=';
    113c:	0450014c 	ldrbeq	r0, [r0], #-332	@ 0xfffffeb4
      output[3] = '=';
    1140:	a304524c 	movwge	r5, #16972	@ 0x424c
      output[4] = '\0';
    1144:	049f5001 	ldreq	r5, [pc], #1	@ 114c <encode_base64+0xb0>
      output[0] = binary_to_base64(                         input[0] >> 2);
    1148:	50015852 	andpl	r5, r1, r2, asr r8
    114c:	04625804 	strbteq	r5, [r2], #-2052	@ 0xfffff7fc
    1150:	9f5001a3 	svcls	0x005001a3
      output[1] = binary_to_base64((input[0] & 0x03) << 4 | input[1] >> 4);
    1154:	01726204 	cmneq	r2, r4, lsl #4
    1158:	a2720450 	rsbsge	r0, r2, #80, 8	@ 0x50000000
    115c:	01a30401 			@ <UNDEFINED> instruction: 0x01a30401
    1160:	a2049f50 	andge	r9, r4, #80, 30	@ 0x140
    1164:	0101a801 	tsteq	r1, r1, lsl #16
      output[2] = binary_to_base64((input[1] & 0x0F) << 2);
    1168:	01a80450 			@ <UNDEFINED> instruction: 0x01a80450
    116c:	a30402b4 	movwge	r0, #17076	@ 0x42b4
    1170:	049f5001 	ldreq	r5, [pc], #1	@ 1178 <encode_base64+0xdc>
      output[3] = '=';
    1174:	02ba02b4 	adcseq	r0, sl, #180, 4	@ 0x4000000b
      output[4] = '\0';
    1178:	ba045001 	blt	115184 <__ROM_SIZE__+0xd5184>
      break;
    117c:	0402be02 	streq	fp, [r2], #-3586	@ 0xfffff1fe
    1180:	9f5001a3 	svcls	0x005001a3
unsigned int decode_base64(unsigned char input[], unsigned int input_length, unsigned char output[]) {
    1184:	c002be04 	andgt	fp, r2, r4, lsl #28
    1188:	04500102 	ldrbeq	r0, [r0], #-258	@ 0xfffffefe
  unsigned int output_length = decode_base64_length(input, input_length);
    118c:	02c202c0 	sbceq	r0, r2, #192, 4
    1190:	5001a304 	andpl	sl, r1, r4, lsl #6
  for(unsigned int i = 2; i < output_length; i += 3) {
    1194:	02c2049f 	sbceq	r0, r2, #-1627389952	@ 0x9f000000
    output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
    1198:	500102c4 	andpl	r0, r1, r4, asr #5
    119c:	dc02c404 	cfstrsle	mvf12, [r2], {4}
    11a0:	01a30402 			@ <UNDEFINED> instruction: 0x01a30402
    11a4:	00009f50 	andeq	r9, r0, r0, asr pc
	...
    output[1] = base64_to_binary(input[1]) << 4 | base64_to_binary(input[2]) >> 2;
    11bc:	4d1c0400 	cfldrsmi	mvf0, [ip, #-0]
    output[2] = base64_to_binary(input[2]) << 6 | base64_to_binary(input[3]);
    11c0:	4d045101 	stfmis	f5, [r4, #-4]
    11c4:	01a30452 			@ <UNDEFINED> instruction: 0x01a30452
    11c8:	52049f51 	andpl	r9, r4, #324	@ 0x144
    11cc:	0451015b 	ldrbeq	r0, [r1], #-347	@ 0xfffffea5
    input += 4;
    11d0:	a304625b 	movwge	r6, #16987	@ 0x425b
  for(unsigned int i = 2; i < output_length; i += 3) {
    11d4:	049f5101 	ldreq	r5, [pc], #257	@ 11dc <decode_base64+0x58>
    11d8:	51017262 	tstpl	r1, r2, ror #4
  switch(output_length % 3) {
    11dc:	01a27204 			@ <UNDEFINED> instruction: 0x01a27204
    11e0:	5101a304 	tstpl	r1, r4, lsl #6
    11e4:	01a2049f 			@ <UNDEFINED> instruction: 0x01a2049f
    11e8:	510101a9 	smlatbpl	r1, r9, r1, r0
    11ec:	b401a904 	strlt	sl, [r1], #-2308	@ 0xfffff6fc
    11f0:	01a30402 			@ <UNDEFINED> instruction: 0x01a30402
    11f4:	b4049f51 	strlt	r9, [r4], #-3921	@ 0xfffff0af
    11f8:	0102ba02 	tsteq	r2, r2, lsl #20
      output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
    11fc:	02ba0451 	adcseq	r0, sl, #1358954496	@ 0x51000000
    1200:	a30402be 	movwge	r0, #17086	@ 0x42be
    1204:	049f5101 	ldreq	r5, [pc], #257	@ 120c <decode_base64+0x88>
    1208:	02dc02be 	sbcseq	r0, ip, #-536870901	@ 0xe000000b
    120c:	00005101 	andeq	r5, r0, r1, lsl #2
	...
      output[1] = base64_to_binary(input[1]) << 4 | base64_to_binary(input[2]) >> 2;
    1228:	3a1c0400 	bcc	702230 <__ROM_SIZE__+0x6c2230>
    122c:	3a045201 	bcc	115a38 <__ROM_SIZE__+0xd5a38>
    1230:	04540152 	ldrbeq	r0, [r4], #-338	@ 0xfffffeae
    1234:	52015b52 	andpl	r5, r1, #83968	@ 0x14800
  return output_length;
    1238:	015e5b04 	cmpeq	lr, r4, lsl #22
    123c:	625e0454 	subsvs	r0, lr, #84, 8	@ 0x54000000
{
    1240:	5201a304 	andpl	sl, r1, #4, 6	@ 0x10000000
    1244:	6a62049f 	bvs	18824c8 <__ROM_SIZE__+0x18424c8>
	for (i = 0, j = 0; i < 16; ++i, j += 4)
    1248:	6a045201 	bvs	115a54 <__ROM_SIZE__+0xd5a54>
    124c:	04540172 	ldrbeq	r0, [r4], #-370	@ 0xfffffe8e
		m[i] = (data[j] << 24) | (data[j + 1] << 16) | (data[j + 2] << 8) | (data[j + 3]);
    1250:	0401a272 	streq	sl, [r1], #-626	@ 0xfffffd8e
    1254:	9f5201a3 	svcls	0x005201a3
    1258:	ae01a204 	cdpge	2, 0, cr10, cr1, cr4, {0}
    125c:	04540101 	ldrbeq	r0, [r4], #-257	@ 0xfffffeff
    1260:	02b401ae 	adcseq	r0, r4, #-2147483605	@ 0x8000002b
    1264:	5201a304 	andpl	sl, r1, #4, 6	@ 0x10000000
    1268:	02b4049f 	adcseq	r0, r4, #-1627389952	@ 0x9f000000
	for (i = 0, j = 0; i < 16; ++i, j += 4)
    126c:	540102b8 	strpl	r0, [r1], #-696	@ 0xfffffd48
    1270:	be02b804 	cdplt	8, 0, cr11, cr2, cr4, {0}
		m[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16];
    1274:	01a30402 			@ <UNDEFINED> instruction: 0x01a30402
    1278:	be049f52 	mcrlt	15, 0, r9, cr4, cr2, {2}
    127c:	0102dc02 	tsteq	r2, r2, lsl #24
    1280:	00020052 	andeq	r0, r2, r2, asr r0
	...
    1294:	025e2204 	subseq	r2, lr, #4, 4	@ 0x40000000
    1298:	62049f30 	andvs	r9, r4, #48, 30	@ 0xc0
    129c:	9f300272 	svcls	0x00300272
    12a0:	01947204 	orrseq	r7, r4, r4, lsl #4
    12a4:	94045401 	strls	r5, [r4], #-1025	@ 0xfffffbff
    12a8:	0301a201 	movweq	sl, #4609	@ 0x1201
    12ac:	049f7f74 	ldreq	r7, [pc], #3956	@ 12b4 <sha256_transform+0x74>
    12b0:	01ae01a2 			@ <UNDEFINED> instruction: 0x01ae01a2
    12b4:	049f3002 	ldreq	r3, [pc], #2	@ 12bc <sha256_transform+0x7c>
	for ( ; i < 64; ++i)
    12b8:	01e801ae 	mvneq	r0, lr, lsr #3
    12bc:	e8045401 	stmda	r4, {r0, sl, ip, lr}
	a = ctx->state[0];
    12c0:	0301f401 	movweq	pc, #5121	@ 0x1401	@ <UNPREDICTABLE>
	b = ctx->state[1];
    12c4:	049f7f74 	ldreq	r7, [pc], #3956	@ 12cc <sha256_transform+0x8c>
	c = ctx->state[2];
    12c8:	029201f4 	addseq	r0, r2, #244, 2	@ 0x3d
	d = ctx->state[3];
    12cc:	92045401 	andls	r5, r4, #16777216	@ 0x1000000
	e = ctx->state[4];
    12d0:	0202dc02 	andeq	sp, r2, #512	@ 0x200
	f = ctx->state[5];
    12d4:	01009f30 	tsteq	r0, r0, lsr pc
	...
	h = ctx->state[7];
    12e0:	6e620400 	cdpvs	4, 6, cr0, cr2, cr0, {0}
    12e4:	049f3002 	ldreq	r3, [pc], #2	@ 12ec <sha256_transform+0xac>
	d = ctx->state[3];
    12e8:	01019c72 	tsteq	r1, r2, ror ip
	b = ctx->state[1];
    12ec:	019c0455 	orrseq	r0, ip, r5, asr r4
	for (i = 0; i < 64; ++i) {
    12f0:	510101a2 	smlatbpl	r1, r2, r1, r0
    12f4:	ca01ac04 	bgt	6c30c <__ROM_SIZE__+0x2c30c>
    12f8:	04550101 	ldrbeq	r0, [r5], #-257	@ 0xfffffeff
    12fc:	02c202be 	sbceq	r0, r2, #-536870901	@ 0xe000000b
		t1 = h + EP1(e) + CH(e,f,g) + k[i] + m[i];
    1300:	009f3002 	addseq	r3, pc, r2
    1304:	00000001 	andeq	r0, r0, r1
    1308:	00000000 	andeq	r0, r0, r0
    130c:	30040000 	andcc	r0, r4, r0
    1310:	9f30023e 	svcls	0x0030023e
    1314:	f001ca04 			@ <UNDEFINED> instruction: 0xf001ca04
    1318:	04550101 	ldrbeq	r0, [r5], #-257	@ 0xfffffeff
    131c:	01f401f0 	ldrsheq	r0, [r4, #16]!
    1320:	f4045101 	vst4.8	{d5,d7,d9,d11}, [r4], r1
    1324:	01029201 	tsteq	r2, r1, lsl #4
    1328:	02c20455 	sbceq	r0, r2, #1426063360	@ 0x55000000
		t2 = EP0(a) + MAJ(a,b,c);
    132c:	300202dc 	ldrdcc	r0, [r2], -ip
    1330:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
    1334:	92040000 	andls	r0, r4, #0
    1338:	0102b402 	tsteq	r2, r2, lsl #8
    133c:	02ba0454 	adcseq	r0, sl, #84, 8	@ 0x54000000
    1340:	540102be 	strpl	r0, [r1], #-702	@ 0xfffffd42
    1344:	01010000 	mrseq	r0, (UNDEF: 1)
    1348:	00000000 	andeq	r0, r0, r0
		h = g;
    134c:	02920400 	addseq	r0, r2, #0, 8
		f = e;
    1350:	52010292 	andpl	r0, r1, #536870921	@ 0x20000009
		e = d + t1;
    1354:	9e029204 	cdpls	2, 0, cr9, cr2, cr4, {0}
		c = b;
    1358:	9f310202 	svcls	0x00310202
		a = t1 + t2;
    135c:	b4029e04 	strlt	r9, [r2], #-3588	@ 0xfffff1fc
	for (i = 0; i < 64; ++i) {
    1360:	04520102 	ldrbeq	r0, [r2], #-258	@ 0xfffffefe
	ctx->state[0] += a;
    1364:	02be02ba 	adcseq	r0, lr, #-1610612725	@ 0xa000000b
    1368:	00005201 	andeq	r5, r0, r1, lsl #4
    136c:	00000000 	andeq	r0, r0, r0
    1370:	04000000 	streq	r0, [r0], #-0
    1374:	029b0292 	addseq	r0, fp, #536870921	@ 0x20000009
	ctx->state[1] += b;
    1378:	9b045301 	blls	115f84 <__ROM_SIZE__+0xd5f84>
	ctx->state[2] += c;
    137c:	0802a002 	stmdaeq	r2, {r1, sp, pc}
    1380:	00740075 	rsbseq	r0, r4, r5, ror r0
	ctx->state[3] += d;
    1384:	9f1a3f25 	svcls	0x001a3f25
	ctx->state[4] += e;
    1388:	ac02a804 	stcge	8, cr10, [r2], {4}
    138c:	00730502 	rsbseq	r0, r3, r2, lsl #10
	ctx->state[5] += f;
    1390:	049f1a3f 	ldreq	r1, [pc], #2623	@ 1398 <sha256_transform+0x158>
    1394:	02b402ac 	adcseq	r0, r4, #172, 4	@ 0xc000000a
	ctx->state[6] += g;
    1398:	00005301 	andeq	r5, r0, r1, lsl #6
    139c:	04000000 	streq	r0, [r0], #-0
	ctx->state[7] += h;
    13a0:	50010600 	andpl	r0, r1, r0, lsl #12
    13a4:	01160604 	tsteq	r6, r4, lsl #12
}
    13a8:	027e0054 	rsbseq	r0, lr, #84	@ 0x54
    13ac:	00050000 	andeq	r0, r5, r0
    13b0:	00000004 	andeq	r0, r0, r4
	ctx->datalen = 0;
    13b4:	00000000 	andeq	r0, r0, r0
	ctx->bitlen = 0;
    13b8:	90040000 	andls	r0, r4, r0
    13bc:	01029a02 	tsteq	r2, r2, lsl #20
	ctx->state[0] = 0x6a09e667;
    13c0:	029a0450 	addseq	r0, sl, #80, 8	@ 0x50000000
	ctx->state[1] = 0xbb67ae85;
    13c4:	a30402e0 	movwge	r0, #17120	@ 0x42e0
	ctx->state[2] = 0x3c6ef372;
    13c8:	009f5001 	addseq	r5, pc, r1
	ctx->state[3] = 0xa54ff53a;
    13cc:	00000000 	andeq	r0, r0, r0
	ctx->state[4] = 0x510e527f;
    13d0:	9d029004 	stcls	0, cr9, [r2, #-16]
	ctx->state[5] = 0x9b05688c;
    13d4:	04510102 	ldrbeq	r0, [r1], #-258	@ 0xfffffefe
	ctx->state[6] = 0x1f83d9ab;
    13d8:	02e0029d 	rsceq	r0, r0, #-805306359	@ 0xd0000009
	ctx->state[7] = 0x5be0cd19;
    13dc:	00005401 	andeq	r5, r0, r1, lsl #8
    13e0:	00000000 	andeq	r0, r0, r0
    13e4:	02a00401 	adceq	r0, r0, #16777216	@ 0x1000000
    13e8:	500102a2 	andpl	r0, r1, r2, lsr #5
}
    13ec:	be02a204 	cdplt	2, 0, cr10, cr2, cr4, {0}
    13f0:	04550102 	ldrbeq	r0, [r5], #-258	@ 0xfffffefe
    13f4:	02c602c0 	sbceq	r0, r6, #192, 4
    13f8:	00005501 	andeq	r5, r0, r1, lsl #10
    13fc:	00000000 	andeq	r0, r0, r0
    1400:	04000000 	streq	r0, [r0], #-0
    1404:	02b802a8 	adcseq	r0, r8, #168, 4	@ 0x8000000a
{
    1408:	b8045001 	stmdalt	r4, {r0, ip, lr}
    140c:	0102bb02 	tsteq	r2, r2, lsl #22
	for (i = 0; i < len; ++i) {
    1410:	02c00451 	sbceq	r0, r0, #1358954496	@ 0x51000000
    1414:	500102c2 	andpl	r0, r1, r2, asr #5
    1418:	c502c204 	strgt	ip, [r2, #-516]	@ 0xfffffdfc
		ctx->data[ctx->datalen] = data[i];
    141c:	00510102 	subseq	r0, r1, r2, lsl #2
		ctx->datalen++;
    1420:	ae040000 	cdpge	0, 0, cr0, cr4, cr0, {0}
		if (ctx->datalen == 64) {
    1424:	0102b002 	tsteq	r2, r2
			sha256_transform(ctx, ctx->data);
    1428:	00000053 	andeq	r0, r0, r3, asr r0
    142c:	b0040000 	andlt	r0, r4, r0
			ctx->bitlen += 512;
    1430:	0502b402 	streq	fp, [r2, #-1026]	@ 0xfffffbfe
    1434:	1a310073 	bne	c41608 <__ROM_SIZE__+0xc01608>
    1438:	02b4049f 	adcseq	r0, r4, #-1627389952	@ 0x9f000000
    143c:	530102bb 	movwpl	r0, #4795	@ 0x12bb
			ctx->datalen = 0;
    1440:	00000000 	andeq	r0, r0, r0
    1444:	01a80400 			@ <UNDEFINED> instruction: 0x01a80400
{
    1448:	500101b2 			@ <UNDEFINED> instruction: 0x500101b2
    144c:	9001b204 	andls	fp, r1, r4, lsl #4
	if (ctx->datalen < 56) {
    1450:	01a30402 			@ <UNDEFINED> instruction: 0x01a30402
		ctx->data[i++] = 0x80;
    1454:	00009f50 	andeq	r9, r0, r0, asr pc
    1458:	04000000 	streq	r0, [r0], #-0
			ctx->data[i++] = 0x00;
    145c:	01b501a8 			@ <UNDEFINED> instruction: 0x01b501a8
    1460:	b5045101 	strlt	r5, [r4, #-257]	@ 0xfffffeff
		while (i < 56)
    1464:	01029001 	tsteq	r2, r1
	ctx->bitlen += ctx->datalen * 8;
    1468:	00000054 	andeq	r0, r0, r4, asr r0
    146c:	01000000 	mrseq	r0, (UNDEF: 0)
    1470:	ba01b804 	blt	6f488 <__ROM_SIZE__+0x2f488>
    1474:	04500101 	ldrbeq	r0, [r0], #-257	@ 0xfffffeff
	ctx->data[63] = ctx->bitlen;
    1478:	01e601ba 	strheq	r0, [r6, #26]!
	ctx->data[62] = ctx->bitlen >> 8;
    147c:	e8045601 	stmda	r4, {r0, r9, sl, ip, lr}
    1480:	0101f601 	tsteq	r1, r1, lsl #12	@ <UNPREDICTABLE>
	ctx->data[61] = ctx->bitlen >> 16;
    1484:	00000056 	andeq	r0, r0, r6, asr r0
	ctx->data[60] = ctx->bitlen >> 24;
    1488:	01000000 	mrseq	r0, (UNDEF: 0)
    148c:	c201c004 	andgt	ip, r1, #4
	ctx->data[59] = ctx->bitlen >> 32;
    1490:	04500101 	ldrbeq	r0, [r0], #-257	@ 0xfffffeff
	ctx->data[58] = ctx->bitlen >> 40;
    1494:	01e601c2 	mvneq	r0, r2, asr #3
	ctx->data[57] = ctx->bitlen >> 48;
    1498:	e8045501 	stmda	r4, {r0, r8, sl, ip, lr}
    149c:	0101f601 	tsteq	r1, r1, lsl #12	@ <UNPREDICTABLE>
	ctx->data[56] = ctx->bitlen >> 56;
    14a0:	00000055 	andeq	r0, r0, r5, asr r0
	sha256_transform(ctx, ctx->data);
    14a4:	00000000 	andeq	r0, r0, r0
    14a8:	e601c604 	str	ip, [r1], -r4, lsl #12
	for (i = 0; i < 4; ++i) {
    14ac:	04500101 	ldrbeq	r0, [r0], #-257	@ 0xfffffeff
		ctx->data[i++] = 0x80;
    14b0:	01ea01e8 	mvneq	r0, r8, ror #3
    14b4:	f0045001 			@ <UNDEFINED> instruction: 0xf0045001
			ctx->data[i++] = 0x00;
    14b8:	0101f201 	tsteq	r1, r1, lsl #4	@ <UNPREDICTABLE>
    14bc:	00000050 	andeq	r0, r0, r0, asr r0
		while (i < 64)
    14c0:	d0040000 	andle	r0, r4, r0
		sha256_transform(ctx, ctx->data);
    14c4:	0101e201 	tsteq	r1, r1, lsl #4
    14c8:	01e20452 	mvneq	r0, r2, asr r4
		memset(ctx->data, 0, 56);
    14cc:	530101e6 	movwpl	r0, #4582	@ 0x11e6
	...
		hash[i]      = (ctx->state[0] >> (24 - i * 8)) & 0x000000ff;
    14d8:	6a600400 	bvs	18024e0 <__ROM_SIZE__+0x17c24e0>
    14dc:	6a045001 	bvs	1154e8 <__ROM_SIZE__+0xd54e8>
    14e0:	01a3047c 			@ <UNDEFINED> instruction: 0x01a3047c
		hash[i + 4]  = (ctx->state[1] >> (24 - i * 8)) & 0x000000ff;
    14e4:	7c049f50 	stcvc	15, cr9, [r4], {80}	@ 0x50
    14e8:	50010180 	andpl	r0, r1, r0, lsl #3
		hash[i + 8]  = (ctx->state[2] >> (24 - i * 8)) & 0x000000ff;
    14ec:	a8018004 	stmdage	r1, {r2, pc}
    14f0:	01a30401 			@ <UNDEFINED> instruction: 0x01a30401
		hash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0x000000ff;
    14f4:	00009f50 	andeq	r9, r0, r0, asr pc
	...
		hash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0x000000ff;
    1500:	04000000 	streq	r0, [r0], #-0
    1504:	51016d60 	tstpl	r1, r0, ror #26
		hash[i + 20] = (ctx->state[5] >> (24 - i * 8)) & 0x000000ff;
    1508:	017a6d04 	cmneq	sl, r4, lsl #26
    150c:	7c7a0455 	cfldrdvc	mvd0, [sl], #-340	@ 0xfffffeac
    1510:	5101a304 	tstpl	r1, r4, lsl #6
		hash[i + 24] = (ctx->state[6] >> (24 - i * 8)) & 0x000000ff;
    1514:	7e7c049f 	mrcvc	4, 3, r0, cr12, cr15, {4}
    1518:	7e045101 	adfvcs	f5, f4, f1
		hash[i + 28] = (ctx->state[7] >> (24 - i * 8)) & 0x000000ff;
    151c:	5501018a 	strpl	r0, [r1, #-394]	@ 0xfffffe76
    1520:	a8018a04 	stmdage	r1, {r2, r9, fp, pc}
    1524:	01a30401 			@ <UNDEFINED> instruction: 0x01a30401
	for (i = 0; i < 4; ++i) {
    1528:	00009f51 	andeq	r9, r0, r1, asr pc
}
    152c:	00000000 	andeq	r0, r0, r0
static void outstr(const char *str) {
    1530:	72700400 	rsbsvc	r0, r0, #0, 8
  while (*str != '\0') {
    1534:	72045001 	andvc	r5, r4, #1
    __write_char__(*str);
    1538:	0454017c 	ldrbeq	r0, [r4], #-380	@ 0xfffffe84
    str++;
    153c:	019e018a 	orrseq	r0, lr, sl, lsl #3
  while (*str != '\0') {
    1540:	00005401 	andeq	r5, r0, r1, lsl #8
}
    1544:	04000000 	streq	r0, [r0], #-0
    1548:	50017c78 	andpl	r7, r1, r8, ror ip
static bool printf_numbers(const char fmt, va_list *args, int l_count) {
    154c:	9e018a04 	vmlals.f32	s16, s2, s8
    1550:	00560101 	subseq	r0, r6, r1, lsl #2
  switch (fmt) {
    1554:	00000002 	andeq	r0, r0, r2
    1558:	027c7804 	rsbseq	r7, ip, #4, 16	@ 0x40000
    155c:	8a049f30 	bhi	129224 <__ROM_SIZE__+0xe9224>
      if (l_count == 0) {
    1560:	01019e01 	tsteq	r1, r1, lsl #28
    1564:	00020055 	andeq	r0, r2, r5, asr r0
        value = va_arg(*args, unsigned int);
    1568:	78040000 	stmdavc	r4, {}	@ <UNPREDICTABLE>
    156c:	9f30027c 	svcls	0x0030027c
      if (fmt == 'u') {
    1570:	93018c04 	movwls	r8, #7172	@ 0x1c04
        if (value == 0) {
    1574:	00520101 	subseq	r0, r2, r1, lsl #2
	...
  return true;
    1580:	013a3004 	teqeq	sl, r4
  switch (fmt) {
    1584:	4c3a0450 	cfldrsmi	mvf0, [sl], #-320	@ 0xfffffec0
      outstr("\nprintf-error\n");
    1588:	5001a304 	andpl	sl, r1, r4, lsl #6
      return false;
    158c:	504c049f 	umaalpl	r0, ip, pc, r4	@ <UNPREDICTABLE>
}
    1590:	50045001 	andpl	r5, r4, r1
      if (l_count == 0) {
    1594:	01a30460 			@ <UNDEFINED> instruction: 0x01a30460
        value = va_arg(*args, int);
    1598:	00009f50 	andeq	r9, r0, r0, asr pc
    159c:	00000000 	andeq	r0, r0, r0
      if (value < 0) {
    15a0:	04000000 	streq	r0, [r0], #-0
        num[num_len++] = hextable[value % 10];
    15a4:	51013d30 	tstpl	r1, r0, lsr sp
    15a8:	014c3d04 	cmpeq	ip, r4, lsl #26
    15ac:	4e4c0454 	mcrmi	4, 2, r0, cr12, cr4, {2}
    15b0:	4e045101 	adfmis	f5, f4, f1
    15b4:	00540160 	subseq	r0, r4, r0, ror #2
    15b8:	00000000 	andeq	r0, r0, r0
    15bc:	01424004 	cmpeq	r2, r4
    15c0:	4a420450 	bmi	1082708 <__ROM_SIZE__+0x1042708>
    15c4:	00005501 	andeq	r5, r0, r1, lsl #10
        value = value / 10;
    15c8:	4a460400 	bmi	11825d0 <__ROM_SIZE__+0x11425d0>
      } while (value > 0);
    15cc:	00005001 	andeq	r5, r0, r1
    15d0:	00000000 	andeq	r0, r0, r0
        __write_char__('-');
    15d4:	04000000 	streq	r0, [r0], #-0
    15d8:	50010800 	andpl	r0, r1, r0, lsl #16
        value = -value;
    15dc:	041a0804 	ldreq	r0, [sl], #-2052	@ 0xfffff7fc
        __write_char__(num[--num_len]);
    15e0:	9f5001a3 	svcls	0x005001a3
    15e4:	011e1a04 	tsteq	lr, r4, lsl #20
    15e8:	301e0450 	andscc	r0, lr, r0, asr r4
    15ec:	5001a304 	andpl	sl, r1, r4, lsl #6
    15f0:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
      while (num_len > 0) {
    15f4:	00000000 	andeq	r0, r0, r0
  return true;
    15f8:	00040000 	andeq	r0, r4, r0
          num[num_len++] = hextable[value % 10];
    15fc:	0451010b 	ldrbeq	r0, [r1], #-267	@ 0xfffffef5
    1600:	a3041a0b 	movwge	r1, #18955	@ 0x4a0b
    1604:	049f5101 	ldreq	r5, [pc], #257	@ 160c <printf_numbers+0xc0>
    1608:	51011c1a 	tstpl	r1, sl, lsl ip
    160c:	04301c04 	ldrteq	r1, [r0], #-3076	@ 0xfffff3fc
    1610:	9f5101a3 	svcls	0x005101a3
    1614:	00000000 	andeq	r0, r0, r0
    1618:	120e0400 	andne	r0, lr, #0, 8
          value = value / 10;
    161c:	12045001 	andne	r5, r4, #1
        } while (value > 0);
    1620:	00510115 	subseq	r0, r1, r5, lsl r1
        while (num_len > 0) {
    1624:	10040000 	andne	r0, r4, r0
          __write_char__(num[--num_len]);
    1628:	00520115 	subseq	r0, r2, r5, lsl r1
    162c:	00000612 	andeq	r0, r0, r2, lsl r6
    1630:	00040005 	andeq	r0, r4, r5
	...
    163c:	980b8804 	stmdals	fp, {r2, fp, pc}
  return true;
    1640:	0450010b 	ldrbeq	r0, [r0], #-267	@ 0xfffffef5
              __write_char__(hextable[val]);
    1644:	0bfc0b98 	bleq	fff044ac <_STACK_TOP_+0xdfefc4b0>
    1648:	00005701 	andeq	r5, r0, r1, lsl #14
              leading_zero_ignored = true;
    164c:	04000000 	streq	r0, [r0], #-0
          while (start_bit >= 0) {
    1650:	0b980b88 	bleq	fe604478 <_STACK_TOP_+0xde5fc47c>
            int val = (value >> start_bit) & 0xF;
    1654:	98045101 	stmdals	r4, {r0, r8, ip, lr}
            if (val || leading_zero_ignored) {
    1658:	010bfc0b 	tsteq	fp, fp, lsl #24	@ <UNPREDICTABLE>
    165c:	00000055 	andeq	r0, r0, r5, asr r0
    1660:	88040000 	stmdahi	r4, {}	@ <UNPREDICTABLE>
          bool leading_zero_ignored = false;
    1664:	010b980b 	tsteq	fp, fp, lsl #16
          int start_bit = LAST_NIBBLE_FIRST_BIT;
    1668:	0b980452 	bleq	fe6027b8 <_STACK_TOP_+0xde5fa7bc>
  return true;
    166c:	56010bfc 			@ <UNDEFINED> instruction: 0x56010bfc
        return false;
    1670:	00000400 	andeq	r0, r0, r0, lsl #8
        return false;
    1674:	0b920400 	bleq	fe48267c <_STACK_TOP_+0xde47a680>
    1678:	30020b98 	mulcc	r2, r8, fp
    167c:	0b98049f 	bleq	fe602900 <_STACK_TOP_+0xde5fa904>
    1680:	54010bfc 	strpl	r0, [r1], #-3068	@ 0xfffff404
    1684:	00000400 	andeq	r0, r0, r0, lsl #8
    1688:	00000100 	andeq	r0, r0, r0, lsl #2
int printf(const char *fmt, ...) {
    168c:	04000000 	streq	r0, [r0], #-0
    1690:	0b980b92 	bleq	fe6044e0 <_STACK_TOP_+0xde5fc4e4>
    1694:	049f4002 	ldreq	r4, [pc], #2	@ 169c <printf+0x10>
  va_start(args, fmt);
    1698:	0bd30b98 	bleq	ff4c4500 <_STACK_TOP_+0xdf4bc504>
  while (*fmt) {
    169c:	dc045301 	stcle	3, cr5, [r4], {1}
        if (*fmt == '%') {
    16a0:	020bde0b 	andeq	sp, fp, #11, 28	@ 0xb0
        __write_char__(*fmt);
    16a4:	de049f3f 	mcrle	15, 0, r9, cr4, cr15, {1}
        fmt++;
    16a8:	010bee0b 	tsteq	fp, fp, lsl #28
  while (*fmt) {
    16ac:	0bf80453 	bleq	ffe02800 <_STACK_TOP_+0xdfdfa804>
    switch (state) {
    16b0:	53010bfc 	movwpl	r0, #7164	@ 0x1bfc
    16b4:	00000000 	andeq	r0, r0, r0
          fmt++;
    16b8:	0ac20400 	beq	ff0826c0 <_STACK_TOP_+0xdf07a6c4>
          continue;
    16bc:	50010ad2 	ldrdpl	r0, [r1], -r2
        while (*fmt && ((*fmt >= '0' && *fmt <= '9') || *fmt == '-')) {
    16c0:	880ad204 	stmdahi	sl, {r2, r9, ip, lr, pc}
    16c4:	0057010b 	subseq	r0, r7, fp, lsl #2
    16c8:	00000000 	andeq	r0, r0, r0
    16cc:	d20ac204 	andle	ip, sl, #4, 4	@ 0x40000000
    16d0:	0451010a 	ldrbeq	r0, [r1], #-266	@ 0xfffffef6
        switch (*fmt) {
    16d4:	0b880ad2 	bleq	fe204224 <_STACK_TOP_+0xde1fc228>
    16d8:	00005401 	andeq	r5, r0, r1, lsl #8
    16dc:	04000000 	streq	r0, [r0], #-0
    16e0:	0ad20ac2 	beq	ff4841f0 <_STACK_TOP_+0xdf47c1f4>
            __write_char__(*fmt);
    16e4:	d2045201 	andle	r5, r4, #268435456	@ 0x10000000
    16e8:	010b880a 	tsteq	fp, sl, lsl #16
            state = CHECK_CH;
    16ec:	00030058 	andeq	r0, r3, r8, asr r0
            break;
    16f0:	ce040000 	cdpgt	0, 0, cr0, cr4, cr0, {0}
    16f4:	020ad20a 	andeq	sp, sl, #-1610612736	@ 0xa0000000
            outstr(va_arg(args, const char *));
    16f8:	d2049f30 	andle	r9, r4, #48, 30	@ 0xc0
    16fc:	010b880a 	tsteq	fp, sl, lsl #16
    1700:	00000055 	andeq	r0, r0, r5, asr r0
            fmt++;
    1704:	8a040000 	bhi	10170c <__ROM_SIZE__+0xc170c>
            break;
    1708:	010a9e0a 	tsteq	sl, sl, lsl #28
            __write_char__(va_arg(args, int));
    170c:	0a9e0450 	beq	fe782854 <_STACK_TOP_+0xde77a858>
    1710:	56010ac2 	strpl	r0, [r1], -r2, asr #21
    1714:	00000000 	andeq	r0, r0, r0
            fmt++;
    1718:	00000202 	andeq	r0, r0, r2, lsl #4
            break;
    171c:	0a8a0400 	beq	fe282724 <_STACK_TOP_+0xde27a728>
            if (*fmt == 'l') {
    1720:	51010a9a 			@ <UNDEFINED> instruction: 0x51010a9a
    1724:	ac0a9a04 			@ <UNDEFINED> instruction: 0xac0a9a04
            if (printf_numbers(*fmt, &args, l_count)) {
    1728:	0454010a 	ldrbeq	r0, [r4], #-266	@ 0xfffffef6
    172c:	0ab20aac 	beq	fec841e4 <_STACK_TOP_+0xdec7c1e8>
    1730:	9f107403 	svcls	0x00107403
              state = CHECK_CH;
    1734:	c20ab204 	andgt	fp, sl, #4, 4	@ 0x40000000
              fmt++;
    1738:	0054010a 	subseq	r0, r4, sl, lsl #2
              l_count++;
    173c:	00000000 	andeq	r0, r0, r0
            if (printf_numbers(*fmt, &args, 0)) {
    1740:	9e0a8a04 	vmlals.f32	s16, s20, s8
    1744:	0452010a 	ldrbeq	r0, [r2], #-266	@ 0xfffffef6
              fmt++;
    1748:	0ac20a9e 	beq	ff0841c8 <_STACK_TOP_+0xdf07c1cc>
              break;
    174c:	01005701 	tsteq	r0, r1, lsl #14
            return -1;
    1750:	04000000 	streq	r0, [r0], #-0
}
    1754:	0a9e0a98 	beq	fe7841bc <_STACK_TOP_+0xde77c1c0>
    1758:	049f3002 	ldreq	r3, [pc], #2	@ 1760 <printf+0xd4>
            return -1;
    175c:	0ac20a9e 	beq	ff0841dc <_STACK_TOP_+0xdf07c1e0>
    1760:	00005501 	andeq	r5, r0, r1, lsl #10
    1764:	01000000 	mrseq	r0, (UNDEF: 0)
static void outstr2(const char *str) {
    1768:	04000000 	streq	r0, [r0], #-0
  while (*str != '\0') {
    176c:	0a9e0a98 	beq	fe7841d4 <_STACK_TOP_+0xde77c1d8>
    __write_char2__(*str);
    1770:	9e045801 	cdpls	8, 0, cr5, cr4, cr1, {0}
    str++;
    1774:	010aa30a 	tsteq	sl, sl, lsl #6
  while (*str != '\0') {
    1778:	0aac0451 	beq	feb028c4 <_STACK_TOP_+0xdeafa8c8>
}
    177c:	54010ab2 	strpl	r0, [r1], #-2738	@ 0xfffff54e
    1780:	bd0ab204 	sfmlt	f3, 1, [sl, #-16]
static bool printf2_numbers(const char fmt, va_list *args, int l_count) {
    1784:	0051010a 	subseq	r0, r1, sl, lsl #2
    1788:	00000003 	andeq	r0, r0, r3
  switch (fmt) {
    178c:	a8040000 	stmdage	r4, {}	@ <UNPREDICTABLE>
    1790:	0209ac09 	andeq	sl, r9, #2304	@ 0x900
    1794:	ac049f30 	stcge	15, cr9, [r4], {48}	@ 0x30
      if (l_count == 0) {
    1798:	0109ba09 	tsteq	r9, r9, lsl #20
    179c:	09bc0453 	ldmibeq	ip!, {r0, r1, r4, r6, sl}
        value = va_arg(*args, unsigned int);
    17a0:	530109c2 	movwpl	r0, #6594	@ 0x19c2
    17a4:	00000000 	andeq	r0, r0, r0
      if (fmt == 'u') {
    17a8:	04000000 	streq	r0, [r0], #-0
        if (value == 0) {
    17ac:	0a8409fc 	beq	fe103fa4 <_STACK_TOP_+0xde0fbfa8>
          __write_char2__(hextable2[0]);
    17b0:	84045001 	strhi	r5, [r4], #-1
    17b4:	010a870a 	tsteq	sl, sl, lsl #14
  return true;
    17b8:	0a870451 	beq	fe1c2904 <_STACK_TOP_+0xde1ba908>
  switch (fmt) {
    17bc:	a3040a8a 	movwge	r0, #19082	@ 0x4a8a
      outstr2("\nprintf2-error\n");
    17c0:	009f5001 	addseq	r5, pc, r1
      return false;
    17c4:	00000000 	andeq	r0, r0, r0
}
    17c8:	fc040000 	stc2	0, cr0, [r4], {-0}
      if (l_count == 0) {
    17cc:	010a8209 	tsteq	sl, r9, lsl #4
        value = va_arg(*args, int);
    17d0:	0a820451 	beq	fe08291c <_STACK_TOP_+0xde07a920>
    17d4:	53010a87 	movwpl	r0, #6791	@ 0x1a87
      if (value < 0) {
    17d8:	8a0a8704 	bhi	2a33f0 <__ROM_SIZE__+0x2633f0>
        num[num_len++] = hextable2[value % 10];
    17dc:	01a3040a 			@ <UNDEFINED> instruction: 0x01a3040a
    17e0:	00009f51 	andeq	r9, r0, r1, asr pc
    17e4:	00000000 	andeq	r0, r0, r0
    17e8:	09ee0400 	stmibeq	lr!, {sl}^
    17ec:	500109f6 	strdpl	r0, [r1], -r6
    17f0:	f909f604 			@ <UNDEFINED> instruction: 0xf909f604
    17f4:	04510109 	ldrbeq	r0, [r1], #-265	@ 0xfffffef7
    17f8:	09fc09f9 	ldmibeq	ip!, {r0, r3, r4, r5, r6, r7, r8, fp}^
    17fc:	5001a304 	andpl	sl, r1, r4, lsl #6
        value = value / 10;
    1800:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
      } while (value > 0);
    1804:	00000000 	andeq	r0, r0, r0
    1808:	f409ee04 			@ <UNDEFINED> instruction: 0xf409ee04
        __write_char2__('-');
    180c:	04510109 	ldrbeq	r0, [r1], #-265	@ 0xfffffef7
    1810:	09f909f4 	ldmibeq	r9!, {r2, r4, r5, r6, r7, r8, fp}^
        value = -value;
    1814:	f9045301 			@ <UNDEFINED> instruction: 0xf9045301
        __write_char2__(num[--num_len]);
    1818:	0409fc09 	streq	pc, [r9], #-3081	@ 0xfffff3f7
    181c:	9f5101a3 	svcls	0x005101a3
    1820:	00000000 	andeq	r0, r0, r0
    1824:	04000000 	streq	r0, [r0], #-0
    1828:	08fa08ee 	ldmeq	sl!, {r1, r2, r3, r5, r6, r7, fp}^
      while (num_len > 0) {
    182c:	fa045001 	blx	115838 <__ROM_SIZE__+0xd5838>
  return true;
    1830:	0108fd08 	tsteq	r8, r8, lsl #26	@ <UNPREDICTABLE>
          num[num_len++] = hextable2[value % 10];
    1834:	08fd0451 	ldmeq	sp!, {r0, r4, r6, sl}^
    1838:	550109a8 	strpl	r0, [r1, #-2472]	@ 0xfffff658
    183c:	00000000 	andeq	r0, r0, r0
    1840:	04000000 	streq	r0, [r0], #-0
    1844:	08f808ee 	ldmeq	r8!, {r1, r2, r3, r5, r6, r7, fp}^
    1848:	f8045101 			@ <UNDEFINED> instruction: 0xf8045101
    184c:	0108fd08 	tsteq	r8, r8, lsl #26	@ <UNPREDICTABLE>
    1850:	08fd0452 	ldmeq	sp!, {r1, r4, r6, sl}^
          value = value / 10;
    1854:	560109a8 	strpl	r0, [r1], -r8, lsr #19
        } while (value > 0);
    1858:	01010100 	mrseq	r0, (UNDEF: 17)
        while (num_len > 0) {
    185c:	00000000 	andeq	r0, r0, r0
          __write_char2__(num[--num_len]);
    1860:	08f40400 	ldmeq	r4!, {sl}^
    1864:	300208fe 	strdcc	r0, [r2], -lr
    1868:	08fe049f 	ldmeq	lr!, {r0, r1, r2, r3, r4, r7, sl}^
    186c:	3d020982 	vstrcc.16	s0, [r2, #-260]	@ 0xfffffefc	@ <UNPREDICTABLE>
    1870:	0982049f 	stmibeq	r2, {r0, r1, r2, r3, r4, r7, sl}
    1874:	5401098a 	strpl	r0, [r1], #-2442	@ 0xfffff676
  return true;
    1878:	a8098c04 	stmdage	r9, {r2, sl, fp, pc}
              __write_char2__(hextable2[val]);
    187c:	00540109 	subseq	r0, r4, r9, lsl #2
    1880:	00000000 	andeq	r0, r0, r0
              leading_zero_ignored = true;
    1884:	aa040000 	bge	10188c <__ROM_SIZE__+0xc188c>
          while (start_bit >= 0) {
    1888:	0108b608 	tsteq	r8, r8, lsl #12
            int val = (value >> start_bit) & 0xF;
    188c:	08b60450 	ldmeq	r6!, {r4, r6, sl}
            if (val || leading_zero_ignored) {
    1890:	510108b9 			@ <UNDEFINED> instruction: 0x510108b9
    1894:	ee08b904 	vmla.f16	s22, s16, s8
    1898:	00550108 	subseq	r0, r5, r8, lsl #2
          bool leading_zero_ignored = false;
    189c:	00000000 	andeq	r0, r0, r0
          int start_bit = LAST_NIBBLE_FIRST_BIT;
    18a0:	aa040000 	bge	1018a8 <__ROM_SIZE__+0xc18a8>
  return true;
    18a4:	0108b408 	tsteq	r8, r8, lsl #8
        return false;
    18a8:	08b40451 	ldmeq	r4!, {r0, r4, r6, sl}
        return false;
    18ac:	520108b9 	andpl	r0, r1, #12124160	@ 0xb90000
    18b0:	ee08b904 	vmla.f16	s22, s16, s8
    18b4:	00560108 	subseq	r0, r6, r8, lsl #2
    18b8:	00010101 	andeq	r0, r1, r1, lsl #2
    18bc:	00000000 	andeq	r0, r0, r0
    18c0:	ba08b004 	blt	22d8d8 <__ROM_SIZE__+0x1ed8d8>
int printf2(const char *fmt, ...) {
    18c4:	9f300208 	svcls	0x00300208
    18c8:	be08ba04 	vmlalt.f32	s22, s16, s8
    18cc:	9f310208 	svcls	0x00310208
  va_start(args, fmt);
    18d0:	d008be04 	andle	fp, r8, r4, lsl #28
  while (*fmt) {
    18d4:	04540108 	ldrbeq	r0, [r4], #-264	@ 0xfffffef8
        if (*fmt == '%') {
    18d8:	08ee08d2 	stmiaeq	lr!, {r1, r4, r6, r7, fp}^
        __write_char2__(*fmt);
    18dc:	00005401 	andeq	r5, r0, r1, lsl #8
        fmt++;
    18e0:	07fa0400 	ldrbeq	r0, [sl, r0, lsl #8]!
  while (*fmt) {
    18e4:	530108aa 	movwpl	r0, #6314	@ 0x18aa
    switch (state) {
    18e8:	00000300 	andeq	r0, r0, r0, lsl #6
    18ec:	00000000 	andeq	r0, r0, r0
          fmt++;
    18f0:	07b00400 	ldreq	r0, [r0, r0, lsl #8]!
          continue;
    18f4:	300207b2 			@ <UNDEFINED> instruction: 0x300207b2
        while (*fmt && ((*fmt >= '0' && *fmt <= '9') || *fmt == '-')) {
    18f8:	07b2049f 			@ <UNDEFINED> instruction: 0x07b2049f
    18fc:	510107dc 	ldrdpl	r0, [r1, -ip]
    1900:	ec07de04 	stc	14, cr13, [r7], {4}
    1904:	04510107 	ldrbeq	r0, [r1], #-263	@ 0xfffffef9
    1908:	07f807ee 	ldrbeq	r0, [r8, lr, ror #15]!
        switch (*fmt) {
    190c:	00005101 	andeq	r5, r0, r1, lsl #2
    1910:	00000000 	andeq	r0, r0, r0
    1914:	07b80400 	ldreq	r0, [r8, r0, lsl #8]!
    1918:	530107d4 	movwpl	r0, #6100	@ 0x17d4
            __write_char2__(*fmt);
    191c:	e407d604 	str	sp, [r7], #-1540	@ 0xfffff9fc
    1920:	04530107 	ldrbeq	r0, [r3], #-263	@ 0xfffffef9
            state = CHECK_CH;
    1924:	07f007e6 	ldrbeq	r0, [r0, r6, ror #15]!
            break;
    1928:	00005301 	andeq	r5, r0, r1, lsl #6
    192c:	00000000 	andeq	r0, r0, r0
            outstr2(va_arg(args, const char *));
    1930:	04d60400 	ldrbeq	r0, [r6], #1024	@ 0x400
    1934:	500104e2 	andpl	r0, r1, r2, ror #9
    1938:	ac04e204 	sfmge	f6, 1, [r4], {4}
            fmt++;
    193c:	007d0207 	rsbseq	r0, sp, r7, lsl #4
            break;
    1940:	b007ac04 	andlt	sl, r7, r4, lsl #24
            __write_char2__(va_arg(args, int));
    1944:	b0910307 	addslt	r0, r1, r7, lsl #6
    1948:	0003007f 	andeq	r0, r3, pc, ror r0
    194c:	de040000 	cdple	0, 0, cr0, cr4, cr0, {0}
            fmt++;
    1950:	0204e204 	andeq	lr, r4, #4, 4	@ 0x40000000
            break;
    1954:	e2049f30 	and	r9, r4, #48, 30	@ 0xc0
            if (*fmt == 'l') {
    1958:	0107b004 	tsteq	r7, r4
    195c:	00000054 	andeq	r0, r0, r4, asr r0
            if (printf2_numbers(*fmt, &args, l_count)) {
    1960:	a404e804 	strge	lr, [r4], #-2052	@ 0xfffff7fc
    1964:	005b0107 	subseq	r0, fp, r7, lsl #2
    1968:	f0040000 			@ <UNDEFINED> instruction: 0xf0040000
              state = CHECK_CH;
    196c:	0107a404 	tsteq	r7, r4, lsl #8
              fmt++;
    1970:	0000005a 	andeq	r0, r0, sl, asr r0
              l_count++;
    1974:	a404f404 	strge	pc, [r4], #-1028	@ 0xfffffbfc
            if (printf2_numbers(*fmt, &args, 0)) {
    1978:	00590107 	subseq	r0, r9, r7, lsl #2
    197c:	f8040000 			@ <UNDEFINED> instruction: 0xf8040000
              fmt++;
    1980:	0106e404 	tsteq	r6, r4, lsl #8
              break;
    1984:	00000055 	andeq	r0, r0, r5, asr r0
            return -1;
    1988:	e0040000 	and	r0, r4, r0
}
    198c:	0103ea03 	tsteq	r3, r3, lsl #20
    1990:	03ea0450 	mvneq	r0, #80, 8	@ 0x50000000
            return -1;
    1994:	590104d6 	stmdbpl	r1, {r1, r2, r4, r6, r7, sl}
    1998:	00000300 	andeq	r0, r0, r0, lsl #6
    199c:	04000000 	streq	r0, [r0], #-0
int r32(int argc, char *argv[]) {
    19a0:	03ea03e6 	mvneq	r0, #-1744830461	@ 0x98000003
  if (argc < 2) {
    19a4:	049f3002 	ldreq	r3, [pc], #2	@ 19ac <r32+0xc>
  uint32_t addr = atoh(argv[1]);
    19a8:	04cc03ea 	strbeq	r0, [ip], #1002	@ 0x3ea
    19ac:	ce045501 	cfsh32gt	mvfx5, mvfx4, #1
  printf("0x%x: 0x%x\n", addr, data);
    19b0:	0104d604 	tsteq	r4, r4, lsl #12
    19b4:	00000055 	andeq	r0, r0, r5, asr r0
}
    19b8:	c8048604 	stmdagt	r4, {r2, r9, sl, pc}
    printf("Usage: %s <address> (in hex)\n", argv[0]);
    19bc:	00540104 	subseq	r0, r4, r4, lsl #2
    19c0:	00000001 	andeq	r0, r0, r1
    return -1;
    19c4:	00010000 	andeq	r0, r1, r0
    19c8:	00000000 	andeq	r0, r0, r0
    19cc:	00010000 	andeq	r0, r1, r0
int w32(int argc, char *argv[]) {
    19d0:	00000000 	andeq	r0, r0, r0
  if (argc < 3) {
    19d4:	00010000 	andeq	r0, r1, r0
  uint32_t addr = atoh(argv[1]);
    19d8:	00000000 	andeq	r0, r0, r0
    19dc:	86040000 	strhi	r0, [r4], -r0
  uint32_t data = atoh(argv[2]);
    19e0:	01048904 	tsteq	r4, r4, lsl #18
    19e4:	04890450 	streq	r0, [r9], #1104	@ 0x450
  return 0;
    19e8:	7b06048a 	blvc	182c18 <__ROM_SIZE__+0x142c18>
    printf("Usage: %s <address> (in hex) <value> (in hex)\n", argv[0]);
    19ec:	27007a00 	strcs	r7, [r0, -r0, lsl #20]
    19f0:	048a049f 	streq	r0, [sl], #1183	@ 0x49f
    return -1;
    19f4:	5001048c 	andpl	r0, r1, ip, lsl #9
    19f8:	98049404 	stmdals	r4, {r2, sl, ip, pc}
    19fc:	007b0604 	rsbseq	r0, fp, r4, lsl #12
int read_mem(int argc, char *argv[]) {
    1a00:	9f270078 	svcls	0x00270078
  if (argc < 3) {
    1a04:	9b049804 	blls	127a1c <__ROM_SIZE__+0xe7a1c>
  uint32_t addr = atoh(argv[1]);
    1a08:	04500104 	ldrbeq	r0, [r0], #-260	@ 0xfffffefc
    1a0c:	049c049b 	ldreq	r0, [ip], #1179	@ 0x49b
  uint32_t length = atoi(argv[2]);
    1a10:	78007b06 	stmdavc	r0, {r1, r2, r8, r9, fp, ip, sp, lr}
    1a14:	049f2700 	ldreq	r2, [pc], #1792	@ 1a1c <read_mem+0x1c>
  for (uint32_t i = 0, data = 0; i < length; i++) {
    1a18:	049e049c 	ldreq	r0, [lr], #1180	@ 0x49c
    printf("Usage: %s <address> (in hex) <num_words> (in decimal)\n", argv[0]);
    1a1c:	a6045001 	strge	r5, [r4], -r1
    1a20:	0604aa04 	streq	sl, [r4], -r4, lsl #20
    return -1;
    1a24:	00770078 	rsbseq	r0, r7, r8, ror r0
    1a28:	aa049f27 	bge	1296cc <__ROM_SIZE__+0xe96cc>
    printf("0x%x: 0x%x\n", addr, data);
    1a2c:	0104ad04 	tsteq	r4, r4, lsl #26
    1a30:	04ad0450 	strteq	r0, [sp], #1104	@ 0x450
    addr += 4;
    1a34:	780604ae 	stmdavc	r6, {r1, r2, r3, r5, r7, sl}
  for (uint32_t i = 0, data = 0; i < length; i++) {
    1a38:	27007700 	strcs	r7, [r0, -r0, lsl #14]
  return 0;
    1a3c:	04ae049f 	strteq	r0, [lr], #1183	@ 0x49f
}
    1a40:	500104b0 			@ <UNDEFINED> instruction: 0x500104b0
    1a44:	bc04b804 	stclt	8, cr11, [r4], {4}
{
    1a48:	00770604 	rsbseq	r0, r7, r4, lsl #12
  if (argc < 4) {
    1a4c:	9f27007a 	svcls	0x0027007a
  uint32_t addr = atoh(argv[1]);
    1a50:	bf04bc04 	svclt	0x0004bc04
    1a54:	04500104 	ldrbeq	r0, [r0], #-260	@ 0xfffffefc
  uint32_t bit_loc = atoi(argv[2]);
    1a58:	04c004bf 	strbeq	r0, [r0], #1215	@ 0x4bf
    1a5c:	7a007706 	bvc	1f67c <__RAM_SIZE__+0x1767c>
  uint32_t bit_val = atoi(argv[3]);
    1a60:	049f2700 	ldreq	r2, [pc], #1792	@ 1a68 <w32_bit+0x20>
    1a64:	04ce04c0 	strbeq	r0, [lr], #1216	@ 0x4c0
  if (bit_loc > 31) {
    1a68:	00005001 	andeq	r5, r0, r1
  if (bit_val != 0 && bit_val != 1) {
    1a6c:	03ee0400 	mvneq	r0, #0, 8
  data = data | (bit_val << bit_loc);
    1a70:	5a0104ce 	bpl	42db0 <__ROM_SIZE__+0x2db0>
    1a74:	00000000 	andeq	r0, r0, r0
  data = data & ~(!bit_val << bit_loc);
    1a78:	03ce0400 	biceq	r0, lr, #0, 8
    1a7c:	500103dc 	ldrdpl	r0, [r1], -ip
    1a80:	e003dc04 	and	sp, r3, r4, lsl #24
  return 0;
    1a84:	01a30403 			@ <UNDEFINED> instruction: 0x01a30403
    printf("Error: Invalid bit location argument\n");
    1a88:	00009f50 	andeq	r9, r0, r0, asr pc
    1a8c:	039e0400 	orrseq	r0, lr, #0, 8
    printf("Error: Invalid bit value argument\n");
    1a90:	530103ce 	movwpl	r0, #5070	@ 0x13ce
    1a94:	00000300 	andeq	r0, r0, r0, lsl #6
  printf("Usage: %s <address_in_hex(32-bits)> <bit_location_in_decimal(0 to 31)> <bit_value(0 or 1)>\n", argv[0]);
    1a98:	00000000 	andeq	r0, r0, r0
    1a9c:	02d80400 	sbcseq	r0, r8, #0, 8
  return -1;
    1aa0:	300202da 	ldrdcc	r0, [r2], -sl
    1aa4:	02da049f 	sbcseq	r0, sl, #-1627389952	@ 0x9f000000
    1aa8:	52010382 	andpl	r0, r1, #134217730	@ 0x8000002
    1aac:	92038404 	andls	r8, r3, #4, 8	@ 0x4000000
{
    1ab0:	04520103 	ldrbeq	r0, [r2], #-259	@ 0xfffffefd
  if (argc < 3) {
    1ab4:	039c0394 	orrseq	r0, ip, #148, 6	@ 0x50000002
  uint32_t addr = atoh(argv[1]);
    1ab8:	00005201 	andeq	r5, r0, r1, lsl #4
    1abc:	00000000 	andeq	r0, r0, r0
  uint32_t bit_loc = atoi(argv[2]);
    1ac0:	02e00400 	rsceq	r0, r0, #0, 8
    1ac4:	530102fa 	movwpl	r0, #4858	@ 0x12fa
  if (bit_loc > 31) {
    1ac8:	8a02fc04 	bhi	c0ae0 <__ROM_SIZE__+0x80ae0>
  uint32_t data = reg32(addr);
    1acc:	04530103 	ldrbeq	r0, [r3], #-259	@ 0xfffffefd
  printf("Bit %u @ 0x%08x: %u\n", bit_loc, addr, bit_val);
    1ad0:	0396038c 	orrseq	r0, r6, #140, 6	@ 0x30000002
    1ad4:	02005301 	andeq	r5, r0, #67108864	@ 0x4000000
    1ad8:	00000000 	andeq	r0, r0, r0
  return 0;
    1adc:	02a20400 	adceq	r0, r2, #0, 8
    printf("Error: Invalid bit location argument\n");
    1ae0:	300202a6 	andcc	r0, r2, r6, lsr #5
    1ae4:	02a6049f 	adceq	r0, r6, #-1627389952	@ 0x9f000000
  printf("Usage: %s <address_in_hex(32-bits)> <bit_location_in_decimal(0 to 31)\n", argv[0]);
    1ae8:	540102cc 	strpl	r0, [r1], #-716	@ 0xfffffd34
    1aec:	d802ce04 	stmdale	r2, {r2, r9, sl, fp, lr, pc}
  return -1;
    1af0:	00540102 	subseq	r0, r4, r2, lsl #2
    1af4:	00000000 	andeq	r0, r0, r0
    1af8:	c402a604 	strgt	sl, [r2], #-1540	@ 0xfffff9fc
    1afc:	04530102 	ldrbeq	r0, [r3], #-258	@ 0xfffffefe
{
    1b00:	02ce02c6 	sbceq	r0, lr, #1610612748	@ 0x6000000c
  for (i = 0; i < Nk; ++i)
    1b04:	00005301 	andeq	r5, r0, r1, lsl #6
    RoundKey[(i * 4) + 0] = Key[(i * 4) + 0];
    1b08:	00000000 	andeq	r0, r0, r0
    1b0c:	09e20400 	stmibeq	r2!, {sl}^
    1b10:	500109e8 	andpl	r0, r1, r8, ror #19
    RoundKey[(i * 4) + 1] = Key[(i * 4) + 1];
    1b14:	eb09e804 	bl	27bb2c <__ROM_SIZE__+0x23bb2c>
    RoundKey[(i * 4) + 2] = Key[(i * 4) + 2];
    1b18:	90700409 	rsbsls	r0, r0, r9, lsl #8
    1b1c:	eb049f7e 	bl	12991c <__ROM_SIZE__+0xe991c>
    RoundKey[(i * 4) + 3] = Key[(i * 4) + 3];
    1b20:	0409ee09 	streq	lr, [r9], #-3593	@ 0xfffff1f7
  for (i = 0; i < Nk; ++i)
    1b24:	9f5001a3 	svcls	0x005001a3
    1b28:	00000000 	andeq	r0, r0, r0
  for (i = Nk; i < Nb * (Nr + 1); ++i)
    1b2c:	09e20400 	stmibeq	r2!, {sl}^
    if (i % Nk == 4)
    1b30:	510109eb 	smlattpl	r1, fp, r9, r0
    j = i * 4; k=(i - Nk) * 4;
    1b34:	ee09eb04 	vmla.f64	d14, d9, d4
    RoundKey[j + 0] = RoundKey[k + 0] ^ tempa[0];
    1b38:	01a30409 			@ <UNDEFINED> instruction: 0x01a30409
    1b3c:	00009f51 	andeq	r9, r0, r1, asr pc
    1b40:	04000000 	streq	r0, [r0], #-0
    1b44:	09d309ca 	ldmibeq	r3, {r1, r3, r6, r7, r8, fp}^
    RoundKey[j + 1] = RoundKey[k + 1] ^ tempa[1];
    1b48:	d3045001 	movwle	r5, #16385	@ 0x4001
    1b4c:	0109e209 	tsteq	r9, r9, lsl #4
    1b50:	00000054 	andeq	r0, r0, r4, asr r0
    1b54:	ca040000 	bgt	101b5c <__ROM_SIZE__+0xc1b5c>
    1b58:	0109d309 	tsteq	r9, r9, lsl #6
    1b5c:	09d30451 	ldmibeq	r3, {r0, r4, r6, sl}^
    RoundKey[j + 2] = RoundKey[k + 2] ^ tempa[2];
    1b60:	a30409e2 	movwge	r0, #18914	@ 0x49e2
    1b64:	009f5101 	addseq	r5, pc, r1, lsl #2
    1b68:	00000000 	andeq	r0, r0, r0
    1b6c:	d309ca04 	movwle	ip, #39428	@ 0x9a04
    RoundKey[j + 3] = RoundKey[k + 3] ^ tempa[3];
    1b70:	04520109 	ldrbeq	r0, [r2], #-265	@ 0xfffffef7
    1b74:	09e209d3 	stmibeq	r2!, {r0, r1, r4, r6, r7, r8, fp}^
    1b78:	00005501 	andeq	r5, r0, r1, lsl #10
  for (i = Nk; i < Nb * (Nr + 1); ++i)
    1b7c:	04000000 	streq	r0, [r0], #-0
    1b80:	09c709c2 	stmibeq	r7, {r1, r6, r7, r8, fp}^
      tempa[0]=RoundKey[k + 0];
    1b84:	c7045001 	strgt	r5, [r4, -r1]
    1b88:	0409ca09 	streq	ip, [r9], #-2569	@ 0xfffff5f7
      tempa[1]=RoundKey[k + 1];
    1b8c:	9f5001a3 	svcls	0x005001a3
    1b90:	00000000 	andeq	r0, r0, r0
    1b94:	09c20400 	stmibeq	r2, {sl}^
      tempa[2]=RoundKey[k + 2];
    1b98:	510109c7 	smlabtpl	r1, r7, r9, r0
    1b9c:	ca09c704 	bgt	2737b4 <__ROM_SIZE__+0x2337b4>
      tempa[3]=RoundKey[k + 3];
    1ba0:	01a30409 			@ <UNDEFINED> instruction: 0x01a30409
    1ba4:	00009f51 	andeq	r9, r0, r1, asr pc
    if (i % Nk == 0)
    1ba8:	04000000 	streq	r0, [r0], #-0
        tempa[0] = tempa[1];
    1bac:	51012e00 	tstpl	r1, r0, lsl #28
        tempa[1] = tempa[2];
    1bb0:	02a02e04 	adceq	r2, r0, #4, 28	@ 0x40
        tempa[2] = tempa[3];
    1bb4:	5101a304 	tstpl	r1, r4, lsl #6
        tempa[3] = u8tmp;
    1bb8:	0003009f 	muleq	r3, pc, r0	@ <UNPREDICTABLE>
        tempa[0] = getSBoxValue(tempa[0]);
    1bbc:	00000000 	andeq	r0, r0, r0
    1bc0:	02080404 	andeq	r0, r8, #4, 8	@ 0x4000000
        tempa[1] = getSBoxValue(tempa[1]);
    1bc4:	08049f30 	stmdaeq	r4, {r4, r5, r8, r9, sl, fp, ip, pc}
    1bc8:	0452012e 	ldrbeq	r0, [r2], #-302	@ 0xfffffed2
        tempa[2] = getSBoxValue(tempa[2]);
    1bcc:	0102a02e 	tsteq	r2, lr, lsr #32
    1bd0:	00000053 	andeq	r0, r0, r3, asr r0
        tempa[3] = getSBoxValue(tempa[3]);
    1bd4:	34040000 	strcc	r0, [r4], #-0
    1bd8:	04510178 	ldrbeq	r0, [r1], #-376	@ 0xfffffe88
      tempa[0] = tempa[0] ^ Rcon[i/Nk];
    1bdc:	71037e78 	tstvc	r3, r8, ror lr
    1be0:	00009f7d 	andeq	r9, r0, sp, ror pc
	...
        tempa[0] = getSBoxValue(tempa[0]);
    1bec:	382e0400 	stmdacc	lr!, {sl}
    1bf0:	327f7305 	rsbscc	r7, pc, #335544320	@ 0x14000000
    1bf4:	38049f24 	stmdacc	r4, {r2, r5, r8, r9, sl, fp, ip, pc}
        tempa[1] = getSBoxValue(tempa[1]);
    1bf8:	0072054c 	rsbseq	r0, r2, ip, asr #10
    1bfc:	049f2432 	ldreq	r2, [pc], #1074	@ 1c04 <KeyExpansion+0x104>
        tempa[2] = getSBoxValue(tempa[2]);
    1c00:	73057e4c 	movwvc	r7, #24140	@ 0x5e4c
    1c04:	9f243278 	svcls	0x00243278
    1c08:	90018404 	andls	r8, r1, r4, lsl #8
        tempa[3] = getSBoxValue(tempa[3]);
    1c0c:	00720501 	rsbseq	r0, r2, r1, lsl #10
    1c10:	049f2432 	ldreq	r2, [pc], #1074	@ 1c18 <KeyExpansion+0x118>
    1c14:	02960190 	addseq	r0, r6, #144, 2	@ 0x24
}
    1c18:	327f7305 	rsbscc	r7, pc, #335544320	@ 0x14000000
    1c1c:	01009f24 	tsteq	r0, r4, lsr #30
{
    1c20:	00000000 	andeq	r0, r0, r0
  for (i = 0; i < 4; ++i)
    1c24:	01ac0400 			@ <UNDEFINED> instruction: 0x01ac0400
      (*state)[i][j] ^= RoundKey[(round * Nb * 4) + (i * Nb) + j];
    1c28:	510101d6 	ldrdpl	r0, [r1, -r6]
    1c2c:	da01d604 	ble	77444 <__ROM_SIZE__+0x37444>
    1c30:	6f910201 	svcvs	0x00910201
    1c34:	ea01da04 	b	7844c <__ROM_SIZE__+0x3844c>
    1c38:	7f730701 	svcvc	0x00730701
    1c3c:	00702432 	rsbseq	r2, r0, r2, lsr r4
    1c40:	05030022 	streq	r0, [r3, #-34]	@ 0xffffffde
    for (j = 0; j < 4; ++j)
    1c44:	00050000 	andeq	r0, r5, r0
    1c48:	00000004 	andeq	r0, r0, r4
  for (i = 0; i < 4; ++i)
    1c4c:	00000000 	andeq	r0, r0, r0
    1c50:	b8040000 	stmdalt	r4, {}	@ <UNPREDICTABLE>
    for (j = 0; j < 4; ++j)
    1c54:	010ac80a 	tsteq	sl, sl, lsl #16
  for (i = 0; i < 4; ++i)
    1c58:	0ac80450 	beq	ff202da0 <_STACK_TOP_+0xdf1fada4>
    1c5c:	56010b80 	strpl	r0, [r1], -r0, lsl #23
    for (j = 0; j < 4; ++j)
    1c60:	00000000 	andeq	r0, r0, r0
{
    1c64:	0ab80400 	beq	fee02c6c <_STACK_TOP_+0xdedfac70>
      (*state)[j][i] = getSBoxValue((*state)[j][i]);
    1c68:	51010ac6 	smlabtpl	r1, r6, sl, r0
    1c6c:	800ac604 	andhi	ip, sl, r4, lsl #12
    1c70:	0054010b 	subseq	r0, r4, fp, lsl #2
    1c74:	00000000 	andeq	r0, r0, r0
    for (j = 0; j < 4; ++j)
    1c78:	cb0ab804 	blgt	2afc90 <__ROM_SIZE__+0x26fc90>
    1c7c:	0452010a 	ldrbeq	r0, [r2], #-266	@ 0xfffffef6
  for (i = 0; i < 4; ++i)
    1c80:	0b800acb 	bleq	fe0047b4 <_STACK_TOP_+0xddffc7b8>
    1c84:	00005501 	andeq	r5, r0, r1, lsl #10
    for (j = 0; j < 4; ++j)
    1c88:	0ae20400 	beq	ff882c90 <_STACK_TOP_+0xdf87ac94>
}
    1c8c:	53010afb 	movwpl	r0, #6907	@ 0x1afb
  for (i = 0; i < 4; ++i)
    1c90:	00000000 	andeq	r0, r0, r0
    1c94:	09e40400 	stmibeq	r4!, {sl}^
    1c98:	500109fb 	strdpl	r0, [r1], -fp
  temp           = (*state)[0][1];
    1c9c:	b809fb04 	stmdalt	r9, {r2, r8, r9, fp, ip, sp, lr, pc}
  (*state)[0][1] = (*state)[1][1];
    1ca0:	0056010a 	subseq	r0, r6, sl, lsl #2
  (*state)[1][1] = (*state)[2][1];
    1ca4:	00000000 	andeq	r0, r0, r0
  (*state)[2][1] = (*state)[3][1];
    1ca8:	f809e404 			@ <UNDEFINED> instruction: 0xf809e404
  temp           = (*state)[0][2];
    1cac:	04510109 	ldrbeq	r0, [r1], #-265	@ 0xfffffef7
  (*state)[0][2] = (*state)[2][2];
    1cb0:	0ab809f8 	beq	fee04498 <_STACK_TOP_+0xdedfc49c>
  temp           = (*state)[1][2];
    1cb4:	00005501 	andeq	r5, r0, r1, lsl #10
  (*state)[1][2] = (*state)[3][2];
    1cb8:	0a8c0400 	beq	fe302cc0 <_STACK_TOP_+0xde2facc4>
  temp           = (*state)[0][3];
    1cbc:	50010a90 	mulpl	r1, r0, sl
  (*state)[0][3] = (*state)[3][3];
    1cc0:	04000000 	streq	r0, [r0], #-0
  (*state)[3][3] = (*state)[2][3];
    1cc4:	0aaa0a8e 	beq	fea84704 <_STACK_TOP_+0xdea7c708>
  (*state)[2][3] = (*state)[1][3];
    1cc8:	00005401 	andeq	r5, r0, r1, lsl #8
}
    1ccc:	04000000 	streq	r0, [r0], #-0
  return ((x<<1) ^ (((x>>7) & 1) * 0x1b));
    1cd0:	098708fc 	stmibeq	r7, {r2, r3, r4, r5, r6, r7, fp}
    1cd4:	87045001 	strhi	r5, [r4, -r1]
    1cd8:	0109e409 	tsteq	r9, r9, lsl #8
}
    1cdc:	00000054 	andeq	r0, r0, r4, asr r0
{
    1ce0:	fc040000 	stc2	0, cr0, [r4], {-0}
    1ce4:	01098708 	tsteq	r9, r8, lsl #14
  for (i = 0; i < 4; ++i)
    1ce8:	09870451 	stmibeq	r7, {r0, r4, r6, sl}
    t   = (*state)[i][0];
    1cec:	550109e4 	strpl	r0, [r1, #-2532]	@ 0xfffff61c
    Tmp = (*state)[i][0] ^ (*state)[i][1] ^ (*state)[i][2] ^ (*state)[i][3] ;
    1cf0:	00000000 	andeq	r0, r0, r0
    1cf4:	08a60400 	stmiaeq	r6!, {sl}
    1cf8:	500108b2 			@ <UNDEFINED> instruction: 0x500108b2
    1cfc:	fc08b204 	stc2	2, cr11, [r8], {4}
    1d00:	00560108 	subseq	r0, r6, r8, lsl #2
    1d04:	00000000 	andeq	r0, r0, r0
    Tm  = (*state)[i][0] ^ (*state)[i][1] ; Tm = xtime(Tm);  (*state)[i][0] ^= Tm ^ Tmp ;
    1d08:	b508a604 	strlt	sl, [r8, #-1540]	@ 0xfffff9fc
    1d0c:	04510108 	ldrbeq	r0, [r1], #-264	@ 0xfffffef8
    1d10:	08fc08b5 	ldmeq	ip!, {r0, r2, r4, r5, r7, fp}^
    Tm  = (*state)[i][1] ^ (*state)[i][2] ; Tm = xtime(Tm);  (*state)[i][1] ^= Tm ^ Tmp ;
    1d14:	00005701 	andeq	r5, r0, r1, lsl #14
    1d18:	04000000 	streq	r0, [r0], #-0
    1d1c:	08b508a6 	ldmeq	r5!, {r1, r2, r5, r7, fp}
    1d20:	b5045201 	strlt	r5, [r4, #-513]	@ 0xfffffdff
    1d24:	0108fc08 	tsteq	r8, r8, lsl #24	@ <UNPREDICTABLE>
    Tm  = (*state)[i][2] ^ (*state)[i][3] ; Tm = xtime(Tm);  (*state)[i][2] ^= Tm ^ Tmp ;
    1d28:	00000055 	andeq	r0, r0, r5, asr r0
    1d2c:	fc08c204 	stc2	2, cr12, [r8], {4}
    1d30:	00540108 	subseq	r0, r4, r8, lsl #2
    1d34:	00000000 	andeq	r0, r0, r0
    Tm  = (*state)[i][3] ^ t ;              Tm = xtime(Tm);  (*state)[i][3] ^= Tm ^ Tmp ;
    1d38:	b8040000 	stmdalt	r4, {}	@ <UNPREDICTABLE>
    1d3c:	0108bc08 	tsteq	r8, r8, lsl #24
    1d40:	08bc0450 	ldmeq	ip!, {r4, r6, sl}
    1d44:	540108c2 	strpl	r0, [r1], #-2242	@ 0xfffff73e
    1d48:	c408c204 	strgt	ip, [r8], #-516	@ 0xfffffdfc
  for (i = 0; i < 4; ++i)
    1d4c:	01740308 	cmneq	r4, r8, lsl #6
    1d50:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
}
    1d54:	d2040000 	andle	r0, r4, #0
{
    1d58:	0106e206 	tsteq	r6, r6, lsl #4
    1d5c:	06e20450 	usateq	r0, #2, r0, asr #8
  for (i = 0; i < 4; ++i)
    1d60:	540108a6 	strpl	r0, [r1], #-2214	@ 0xfffff75a
    a = (*state)[i][0];
    1d64:	00000000 	andeq	r0, r0, r0
    b = (*state)[i][1];
    1d68:	06d20400 	ldrbeq	r0, [r2], r0, lsl #8
    1d6c:	510106e0 	smlattpl	r1, r0, r6, r0
    c = (*state)[i][2];
    1d70:	a606e004 	strge	lr, [r6], -r4
    d = (*state)[i][3];
    1d74:	00570108 	subseq	r0, r7, r8, lsl #2
    (*state)[i][0] = Multiply(a, 0x0e) ^ Multiply(b, 0x0b) ^ Multiply(c, 0x0d) ^ Multiply(d, 0x09);
    1d78:	00000000 	andeq	r0, r0, r0
    1d7c:	e506d204 	str	sp, [r6, #-516]	@ 0xfffffdfc
    1d80:	04520106 	ldrbeq	r0, [r2], #-262	@ 0xfffffefa
    1d84:	08a606e5 	stmiaeq	r6!, {r0, r2, r5, r6, r7, r9, sl}
    1d88:	00005501 	andeq	r5, r0, r1, lsl #10
    1d8c:	04000000 	streq	r0, [r0], #-0
    1d90:	06e506d2 	usateq	r0, #5, r2, asr #13
    1d94:	e5045301 	str	r5, [r4, #-769]	@ 0xfffffcff
    1d98:	0108a606 	tsteq	r8, r6, lsl #12
    1d9c:	00000056 	andeq	r0, r0, r6, asr r0
    1da0:	e4040000 	str	r0, [r4], #-0
    1da4:	0105ef05 	tsteq	r5, r5, lsl #30
    1da8:	05ef0450 	strbeq	r0, [pc, #1104]!	@ 2200 <bitvec_lshift+0x2c>
    1dac:	540106d2 	strpl	r0, [r1], #-1746	@ 0xfffff92e
    1db0:	00000000 	andeq	r0, r0, r0
    1db4:	05e40400 	strbeq	r0, [r4, #1024]!	@ 0x400
    1db8:	510105ef 	smlattpl	r1, pc, r5, r0
    1dbc:	d205ef04 	andle	lr, r5, #4, 30
    1dc0:	00550106 	subseq	r0, r5, r6, lsl #2
    1dc4:	00000000 	andeq	r0, r0, r0
    1dc8:	d505ce04 	strle	ip, [r5, #-3588]	@ 0xfffff1fc
    1dcc:	04500105 	ldrbeq	r0, [r0], #-261	@ 0xfffffefb
    1dd0:	05e405d5 	strbeq	r0, [r4, #1493]!	@ 0x5d5
    1dd4:	5001a304 	andpl	sl, r1, r4, lsl #6
    1dd8:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
    1ddc:	ce040000 	cdpgt	0, 0, cr0, cr4, cr0, {0}
    1de0:	0105d505 	tsteq	r5, r5, lsl #10
    1de4:	05d50451 	ldrbeq	r0, [r5, #1105]	@ 0x451
    1de8:	540105e4 	strpl	r0, [r1], #-1508	@ 0xfffffa1c
    1dec:	00000000 	andeq	r0, r0, r0
    1df0:	05be0400 	ldreq	r0, [lr, #1024]!	@ 0x400
    1df4:	500105c5 	andpl	r0, r1, r5, asr #11
    1df8:	ce05c504 	cfsh32gt	mvfx12, mvfx5, #4
    1dfc:	01a30405 			@ <UNDEFINED> instruction: 0x01a30405
    1e00:	00009f50 	andeq	r9, r0, r0, asr pc
    1e04:	04000000 	streq	r0, [r0], #-0
    (*state)[i][1] = Multiply(a, 0x09) ^ Multiply(b, 0x0e) ^ Multiply(c, 0x0b) ^ Multiply(d, 0x0d);
    1e08:	05c505be 	strbeq	r0, [r5, #1470]	@ 0x5be
    1e0c:	c5045101 	strgt	r5, [r4, #-257]	@ 0xfffffeff
    1e10:	0105ce05 	tsteq	r5, r5, lsl #28
    1e14:	00000054 	andeq	r0, r0, r4, asr r0
    1e18:	a8040000 	stmdage	r4, {}	@ <UNPREDICTABLE>
    1e1c:	0105b305 	tsteq	r5, r5, lsl #6
    1e20:	05b30450 	ldreq	r0, [r3, #1104]!	@ 0x450
    1e24:	a30405be 	movwge	r0, #17854	@ 0x45be
    1e28:	009f5001 	addseq	r5, pc, r1
    1e2c:	00000000 	andeq	r0, r0, r0
    1e30:	b005a804 	andlt	sl, r5, r4, lsl #16
    1e34:	04510105 	ldrbeq	r0, [r1], #-261	@ 0xfffffefb
    1e38:	05be05b0 	ldreq	r0, [lr, #1456]!	@ 0x5b0
    1e3c:	00005401 	andeq	r5, r0, r1, lsl #8
    (*state)[i][2] = Multiply(a, 0x0d) ^ Multiply(b, 0x09) ^ Multiply(c, 0x0e) ^ Multiply(d, 0x0b);
    1e40:	04000000 	streq	r0, [r0], #-0
    1e44:	05b305a8 	ldreq	r0, [r3, #1448]!	@ 0x5a8
    1e48:	b3045201 	movwlt	r5, #16897	@ 0x4201
    1e4c:	0405be05 	streq	fp, [r5], #-3589	@ 0xfffff1fb
    1e50:	9f5201a3 	svcls	0x005201a3
    1e54:	00000000 	andeq	r0, r0, r0
    1e58:	05a80400 	streq	r0, [r8, #1024]!	@ 0x400
    1e5c:	530105b3 	movwpl	r0, #5555	@ 0x15b3
    1e60:	be05b304 	cdplt	3, 0, cr11, cr5, cr4, {0}
    1e64:	00550105 	subseq	r0, r5, r5, lsl #2
    1e68:	00000000 	andeq	r0, r0, r0
    1e6c:	a4040000 	strge	r0, [r4], #-0
    (*state)[i][3] = Multiply(a, 0x0b) ^ Multiply(b, 0x0d) ^ Multiply(c, 0x09) ^ Multiply(d, 0x0e);
    1e70:	0104ac04 	tsteq	r4, r4, lsl #24
    1e74:	04ac0450 	strteq	r0, [ip], #1104	@ 0x450
    1e78:	570105a2 	strpl	r0, [r1, -r2, lsr #11]
    1e7c:	a805a204 	stmdage	r5, {r2, r9, sp, pc}
    1e80:	01a30405 			@ <UNDEFINED> instruction: 0x01a30405
    1e84:	00009f50 	andeq	r9, r0, r0, asr pc
    1e88:	04000000 	streq	r0, [r0], #-0
    1e8c:	04af04a4 	strteq	r0, [pc], #1188	@ 1e94 <InvMixColumns+0x13e>
    1e90:	af045101 	svcge	0x00045101
    1e94:	0405a804 	streq	sl, [r5], #-2052	@ 0xfffff7fc
    1e98:	9f5101a3 	svcls	0x005101a3
    1e9c:	00000000 	andeq	r0, r0, r0
    1ea0:	04000000 	streq	r0, [r0], #-0
  for (i = 0; i < 4; ++i)
    1ea4:	04ee04c6 	strbteq	r0, [lr], #1222	@ 0x4c6
    1ea8:	86045601 	strhi	r5, [r4], -r1, lsl #12
}
    1eac:	06058805 	streq	r8, [r5], -r5, lsl #16
  for (i = 0; i < 4; ++i)
    1eb0:	00700074 	rsbseq	r0, r0, r4, ror r0
    1eb4:	88049f1c 	stmdahi	r4, {r2, r3, r4, r8, r9, sl, fp, ip, pc}
    for (j = 0; j < 4; ++j)
    1eb8:	01059e05 	tsteq	r5, r5, lsl #28
{
    1ebc:	00000056 	andeq	r0, r0, r6, asr r0
      (*state)[j][i] = getSBoxInvert((*state)[j][i]);
    1ec0:	00000000 	andeq	r0, r0, r0
    1ec4:	ba03ae04 	blt	ed6dc <__ROM_SIZE__+0xad6dc>
    1ec8:	04500103 	ldrbeq	r0, [r0], #-259	@ 0xfffffefd
    1ecc:	04a003ba 	strteq	r0, [r0], #954	@ 0x3ba
    1ed0:	a0045601 	andge	r5, r4, r1, lsl #12
    for (j = 0; j < 4; ++j)
    1ed4:	0404a404 	streq	sl, [r4], #-1028	@ 0xfffffbfc
    1ed8:	9f5001a3 	svcls	0x005001a3
	...
    1ee4:	04000000 	streq	r0, [r0], #-0
}
    1ee8:	03bd03ae 			@ <UNDEFINED> instruction: 0x03bd03ae
  for (i = 0; i < 4; ++i)
    1eec:	bd045101 	stflts	f5, [r4, #-4]
    1ef0:	0103d203 	tsteq	r3, r3, lsl #4
    1ef4:	03d20454 	bicseq	r0, r2, #84, 8	@ 0x54000000
  temp = (*state)[3][1];
    1ef8:	a30403d4 	movwge	r0, #17364	@ 0x43d4
  (*state)[3][1] = (*state)[2][1];
    1efc:	049f5101 	ldreq	r5, [pc], #257	@ 1f04 <InvShiftRows+0xc>
  (*state)[2][1] = (*state)[1][1];
    1f00:	03dc03d4 	bicseq	r0, ip, #212, 6	@ 0x50000003
  (*state)[1][1] = (*state)[0][1];
    1f04:	dc045401 	cfstrsle	mvf5, [r4], {1}
  temp = (*state)[0][2];
    1f08:	0404a403 	streq	sl, [r4], #-1027	@ 0xfffffbfd
  (*state)[0][2] = (*state)[2][2];
    1f0c:	9f5101a3 	svcls	0x005101a3
  temp = (*state)[1][2];
    1f10:	00000000 	andeq	r0, r0, r0
  (*state)[1][2] = (*state)[3][2];
    1f14:	04000000 	streq	r0, [r0], #-0
  temp = (*state)[0][3];
    1f18:	03bd03ae 			@ <UNDEFINED> instruction: 0x03bd03ae
  (*state)[0][3] = (*state)[1][3];
    1f1c:	bd045201 	sfmlt	f5, 4, [r4, #-4]
  (*state)[1][3] = (*state)[2][3];
    1f20:	0104a003 	tsteq	r4, r3
  (*state)[2][3] = (*state)[3][3];
    1f24:	04a00455 	strteq	r0, [r0], #1109	@ 0x455
}
    1f28:	a30404a4 	movwge	r0, #17572	@ 0x44a4
{
    1f2c:	009f5201 	addseq	r5, pc, r1, lsl #4
  AddRoundKey(0, state, RoundKey);
    1f30:	dc040000 	stcle	0, cr0, [r4], {-0}
    1f34:	0104a003 	tsteq	r4, r3
    1f38:	00030054 	andeq	r0, r3, r4, asr r0
  for (round = 1; ; ++round)
    1f3c:	82040000 	andhi	r0, r4, #0
    MixColumns(state);
    1f40:	02038403 	andeq	r8, r3, #50331648	@ 0x3000000
    AddRoundKey(round, state, RoundKey);
    1f44:	84049f30 	strhi	r9, [r4], #-3888	@ 0xfffff0d0
    1f48:	0103a403 	tsteq	r3, r3, lsl #8
    1f4c:	00000053 	andeq	r0, r0, r3, asr r0
  for (round = 1; ; ++round)
    1f50:	00000000 	andeq	r0, r0, r0
    SubBytes(state);
    1f54:	e0040000 	and	r0, r4, r0
    ShiftRows(state);
    1f58:	0102fa02 	tsteq	r2, r2, lsl #20	@ <UNPREDICTABLE>
    1f5c:	02fa0450 	rscseq	r0, sl, #80, 8	@ 0x50000000
    if (round == Nr) {
    1f60:	a30402fe 	movwge	r0, #17150	@ 0x42fe
  AddRoundKey(Nr, state, RoundKey);
    1f64:	049f5001 	ldreq	r5, [pc], #1	@ 1f6c <Cipher+0x42>
    1f68:	038002fe 	orreq	r0, r0, #-536870897	@ 0xe000000f
}
    1f6c:	80045001 	andhi	r5, r4, r1
{
    1f70:	04038203 	streq	r8, [r3], #-515	@ 0xfffffdfd
  AddRoundKey(Nr, state, RoundKey);
    1f74:	9f5001a3 	svcls	0x005001a3
    1f78:	04000000 	streq	r0, [r0], #-0
    1f7c:	02fe02e6 	rscseq	r0, lr, #1610612750	@ 0x6000000e
  for (round = (Nr - 1); ; --round)
    1f80:	02005301 	andeq	r5, r0, #67108864	@ 0x4000000
    InvMixColumns(state);
    1f84:	04000000 	streq	r0, [r0], #-0
  for (round = (Nr - 1); ; --round)
    1f88:	02d202d0 	sbcseq	r0, r2, #208, 4
    InvShiftRows(state);
    1f8c:	049f3102 	ldreq	r3, [pc], #258	@ 1f94 <InvCipher+0x26>
    1f90:	02e002d2 	rsceq	r0, r0, #536870925	@ 0x2000000d
    InvSubBytes(state);
    1f94:	00005301 	andeq	r5, r0, r1, lsl #6
    AddRoundKey(round, state, RoundKey);
    1f98:	00000000 	andeq	r0, r0, r0
    1f9c:	01d80400 	bicseq	r0, r8, r0, lsl #8
    1fa0:	51010298 			@ <UNDEFINED> instruction: 0x51010298
    if (round == 0) {
    1fa4:	c8029804 	stmdagt	r2, {r2, fp, ip, pc}
  for (i = 0; i < AES_BLOCKLEN; ++i) // The block in AES is always 128bit no matter the key size
    1fa8:	01a30402 			@ <UNDEFINED> instruction: 0x01a30402
    buf[i] ^= Iv[i];
    1fac:	c8049f51 	stmdagt	r4, {r0, r4, r6, r8, r9, sl, fp, ip, pc}
    1fb0:	0102cc02 	tsteq	r2, r2, lsl #24
    1fb4:	01000051 	qaddeq	r0, r1, r0
  for (i = 0; i < AES_BLOCKLEN; ++i) // The block in AES is always 128bit no matter the key size
    1fb8:	00000001 	andeq	r0, r0, r1
    1fbc:	9201d804 	andls	sp, r1, #4, 16	@ 0x40000
}
    1fc0:	04520102 	ldrbeq	r0, [r2], #-258	@ 0xfffffefe
  KeyExpansion(ctx->RoundKey, key);
    1fc4:	02960292 	addseq	r0, r6, #536870921	@ 0x20000009
}
    1fc8:	4f007205 	svcmi	0x00007205
{
    1fcc:	96049f1a 			@ <UNDEFINED> instruction: 0x96049f1a
  KeyExpansion(ctx->RoundKey, key);
    1fd0:	0102cc02 	tsteq	r2, r2, lsl #24
  memcpy (ctx->Iv, iv, AES_BLOCKLEN);
    1fd4:	00000052 	andeq	r0, r0, r2, asr r0
    1fd8:	e4040000 	str	r0, [r4], #-0
    1fdc:	0101e801 	tsteq	r1, r1, lsl #16
}
    1fe0:	01ee045c 	mvneq	r0, ip, asr r4
  memcpy (ctx->Iv, iv, AES_BLOCKLEN);
    1fe4:	5c0101fe 	stfpls	f0, [r1], {254}	@ 0xfe
    1fe8:	00000200 	andeq	r0, r0, r0, lsl #4
}
    1fec:	04000000 	streq	r0, [r0], #-0
{
    1ff0:	01e801e4 	mvneq	r0, r4, ror #3
  Cipher((state_t*)buf, ctx->RoundKey);
    1ff4:	049f3002 	ldreq	r3, [pc], #2	@ 1ffc <AES_ECB_decrypt>
    1ff8:	029801ee 	addseq	r0, r8, #-2147483589	@ 0x8000003b
{
    1ffc:	c8045301 	stmdagt	r4, {r0, r8, r9, ip, lr}
  InvCipher((state_t*)buf, ctx->RoundKey);
    2000:	0102ca02 	tsteq	r2, r2, lsl #20
    2004:	00000053 	andeq	r0, r0, r3, asr r0
}
    2008:	80040000 	andhi	r0, r4, r0
{
    200c:	01029802 	tsteq	r2, r2, lsl #16
    2010:	02c8045c 	sbceq	r0, r8, #92, 8	@ 0x5c000000
  uint8_t *Iv = ctx->Iv;
    2014:	5c0102cc 	sfmpl	f0, 4, [r1], {204}	@ 0xcc
    2018:	04000000 	streq	r0, [r0], #-0
  for (i = 0; i < length; i += AES_BLOCKLEN)
    201c:	02c2029c 	sbceq	r0, r2, #156, 4	@ 0xc0000009
    XorWithIv(buf, Iv);
    2020:	00005301 	andeq	r5, r0, r1, lsl #6
    Cipher((state_t*)buf, ctx->RoundKey);
    2024:	00000000 	andeq	r0, r0, r0
    2028:	04000000 	streq	r0, [r0], #-0
  for (i = 0; i < length; i += AES_BLOCKLEN)
    202c:	01b201ae 			@ <UNDEFINED> instruction: 0x01b201ae
    buf += AES_BLOCKLEN;
    2030:	b2045001 	andlt	r5, r4, #1
  for (i = 0; i < length; i += AES_BLOCKLEN)
    2034:	0101b801 	tsteq	r1, r1, lsl #16
  memcpy(ctx->Iv, Iv, AES_BLOCKLEN);
    2038:	01b80453 			@ <UNDEFINED> instruction: 0x01b80453
    203c:	730301bc 	movwvc	r0, #12732	@ 0x31bc
}
    2040:	bc049f7c 	stclt	15, cr9, [r4], {124}	@ 0x7c
{
    2044:	0101d801 	tsteq	r1, r1, lsl #16
    2048:	00020053 	andeq	r0, r2, r3, asr r0
    204c:	ae040000 	cdpge	0, 0, cr0, cr4, cr0, {0}
  for (i = 0; i < length; i += AES_BLOCKLEN)
    2050:	0301b401 	movweq	fp, #5121	@ 0x1401
    memcpy(storeNextIv, buf, AES_BLOCKLEN);
    2054:	049fc008 	ldreq	ip, [pc], #8	@ 205c <AES_CBC_decrypt_buffer+0x1a>
    2058:	01d801b4 	ldrheq	r0, [r8, #20]
    InvCipher((state_t*)buf, ctx->RoundKey);
    205c:	00005001 	andeq	r5, r0, r1
    2060:	01c60400 	biceq	r0, r6, r0, lsl #8
    XorWithIv(buf, ctx->Iv);
    2064:	520101d2 	andpl	r0, r1, #-2147483596	@ 0x80000034
    2068:	00000000 	andeq	r0, r0, r0
    206c:	01940400 	orrseq	r0, r4, r0, lsl #8
    memcpy(ctx->Iv, storeNextIv, AES_BLOCKLEN);
    2070:	500101aa 	andpl	r0, r1, sl, lsr #3
    2074:	ae01aa04 	vmlage.f32	s20, s2, s8
    2078:	01a30401 			@ <UNDEFINED> instruction: 0x01a30401
  for (i = 0; i < length; i += AES_BLOCKLEN)
    207c:	02009f50 	andeq	r9, r0, #80, 30	@ 0x140
    2080:	04000000 	streq	r0, [r0], #-0
}
    2084:	01960194 			@ <UNDEFINED> instruction: 0x01960194
{
    2088:	049f3002 	ldreq	r3, [pc], #2	@ 2090 <AES_CTR_xcrypt_buffer+0x8>
    208c:	01ae0196 			@ <UNDEFINED> instruction: 0x01ae0196
    2090:	03005301 	movweq	r5, #769	@ 0x301
  for (i = 0, bi = AES_BLOCKLEN; i < length; ++i, ++bi)
    2094:	04000000 	streq	r0, [r0], #-0
          ctx->Iv[bi] = 0;
    2098:	01860182 	orreq	r0, r6, r2, lsl #3
    209c:	049f3002 	ldreq	r3, [pc], #2	@ 20a4 <AES_CTR_xcrypt_buffer+0x1c>
      for (bi = (AES_BLOCKLEN - 1); bi >= 0; --bi)
    20a0:	01940186 	orrseq	r0, r4, r6, lsl #3
      bi = 0;
    20a4:	00005301 	andeq	r5, r0, r1, lsl #6
    buf[i] = (buf[i] ^ buffer[bi]);
    20a8:	00000000 	andeq	r0, r0, r0
    20ac:	04000000 	streq	r0, [r0], #-0
    20b0:	50017c64 	andpl	r7, r1, r4, ror #24
    20b4:	047e7c04 	ldrbteq	r7, [lr], #-3076	@ 0xfffff3fc
    20b8:	9f5001a3 	svcls	0x005001a3
  for (i = 0, bi = AES_BLOCKLEN; i < length; ++i, ++bi)
    20bc:	01807e04 	orreq	r7, r0, r4, lsl #28
    20c0:	80045001 	andhi	r5, r4, r1
    if (bi == AES_BLOCKLEN) /* we need to regen xor compliment in buffer */
    20c4:	04018201 	streq	r8, [r1], #-513	@ 0xfffffdff
      memcpy(buffer, ctx->Iv, AES_BLOCKLEN);
    20c8:	9f5001a3 	svcls	0x005001a3
    20cc:	00000300 	andeq	r0, r0, r0, lsl #6
    20d0:	66640400 	strbtvs	r0, [r4], -r0, lsl #8
      Cipher((state_t*)buffer,ctx->RoundKey);
    20d4:	049f3002 	ldreq	r3, [pc], #2	@ 20dc <AES_CTR_xcrypt_buffer+0x54>
    20d8:	01018266 	tsteq	r1, r6, ror #4
      for (bi = (AES_BLOCKLEN - 1); bi >= 0; --bi)
    20dc:	00000053 	andeq	r0, r0, r3, asr r0
    20e0:	00000000 	andeq	r0, r0, r0
        if (ctx->Iv[bi] == 255)
    20e4:	014c4004 	cmpeq	ip, r4
    20e8:	4f4c0450 	svcmi	0x004c0450
        ctx->Iv[bi] += 1;
    20ec:	4f045101 	svcmi	0x00045101
    20f0:	00550164 	subseq	r0, r5, r4, ror #2
      bi = 0;
    20f4:	00000000 	andeq	r0, r0, r0
}
    20f8:	014a4004 	cmpeq	sl, r4
  return ((x[idx / 32U] >> (idx & 31U) & 1U));
    20fc:	644a0451 	strbvs	r0, [sl], #-1105	@ 0xfffffbaf
    2100:	03005401 	movweq	r5, #1025	@ 0x401
    2104:	04000000 	streq	r0, [r0], #-0
}
    2108:	3002302c 	andcc	r3, r2, ip, lsr #32
    210c:	4030049f 	mlasmi	r0, pc, r4, r0	@ <UNPREDICTABLE>
  x[idx / 32U] &= ~(1U << (idx & 31U));
    2110:	00005301 	andeq	r5, r0, r1, lsl #6
    2114:	04000000 	streq	r0, [r0], #-0
    2118:	51011e12 	tstpl	r1, r2, lsl lr
    211c:	042c1e04 	strteq	r1, [ip], #-3588	@ 0xfffff1fc
    2120:	9f5101a3 	svcls	0x005101a3
    2124:	00000000 	andeq	r0, r0, r0
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2128:	06000400 	streq	r0, [r0], -r0, lsl #8
    x[i] = y[i];
    212c:	06045001 	streq	r5, [r4], -r1
    2130:	01a30412 			@ <UNDEFINED> instruction: 0x01a30412
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2134:	00009f50 	andeq	r9, r0, r0, asr pc
    2138:	04000000 	streq	r0, [r0], #-0
{
    213c:	51010a00 	tstpl	r1, r0, lsl #20
    2140:	04120a04 	ldreq	r0, [r2], #-2564	@ 0xfffff5fc
  bitvec_copy(tmp, x);
    2144:	9f5101a3 	svcls	0x005101a3
    2148:	00009d00 	andeq	r9, r0, r0, lsl #26
  bitvec_copy(x, y);
    214c:	04000500 	streq	r0, [r0], #-1280	@ 0xfffffb00
	...
  bitvec_copy(y, tmp);
    2158:	241e0400 	ldrcs	r0, [lr], #-1024	@ 0xfffffc00
}
    215c:	24045001 	strcs	r5, [r4], #-1
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2160:	005c015c 	subseq	r0, ip, ip, asr r1
    2164:	01000001 	tsteq	r0, r1
    if (x[i] != y[i])
    2168:	00000001 	andeq	r0, r0, r1
    216c:	02262004 	eoreq	r2, r6, #4
    2170:	26049f30 			@ <UNDEFINED> instruction: 0x26049f30
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2174:	04500132 	ldrbeq	r0, [r0], #-306	@ 0xfffffece
  return 1;
    2178:	70053632 	andvc	r3, r5, r2, lsr r6
}
    217c:	9f243400 	svcls	0x00243400
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2180:	015c3604 	cmpeq	ip, r4, lsl #12
    x[i] = 0;
    2184:	00020050 	andeq	r0, r2, r0, asr r0
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2188:	00000000 	andeq	r0, r0, r0
    218c:	20040000 	andcs	r0, r4, r0
  uint32_t i = 0;
    2190:	9f300226 	svcls	0x00300226
  while (i < BITVEC_NWORDS)
    2194:	01363204 	teqeq	r6, r4, lsl #4
    if (x[i] != 0)
    2198:	4c4a0453 	cfstrdmi	mvd0, [sl], {83}	@ 0x53
    i += 1;
    219c:	58045301 	stmdapl	r4, {r0, r8, r9, ip, lr}
}
    21a0:	0053015a 	subseq	r0, r3, sl, asr r1
    21a4:	00000004 	andeq	r0, r0, r4
    21a8:	02262004 	eoreq	r2, r6, #4
  x += BITVEC_NWORDS;
    21ac:	26049f30 			@ <UNDEFINED> instruction: 0x26049f30
          && (*(--x)) == 0)
    21b0:	0051015c 	subseq	r0, r1, ip, asr r1
    21b4:	00000000 	andeq	r0, r0, r0
    21b8:	01060004 	tsteq	r6, r4
    i -= 32;
    21bc:	1e060450 	cfmvsrne	mvf6, r0
  if (i != 0)
    21c0:	01005101 	tsteq	r0, r1, lsl #2
      i -= 1;
    21c4:	00000000 	andeq	r0, r0, r0
    while (((*x) & u32mask) == 0)
    21c8:	08020400 	stmdaeq	r2, {sl}
}
    21cc:	049f3002 	ldreq	r3, [pc], #2	@ 21d4 <bitvec_lshift>
    uint32_t u32mask = ((uint32_t)1 << 31);
    21d0:	50010c08 	andpl	r0, r1, r8, lsl #24
{
    21d4:	011e1404 	tsteq	lr, r4, lsl #8
  int nwords = (nbits / 32);
    21d8:	00030050 	andeq	r0, r3, r0, asr r0
    21dc:	02040000 	andeq	r0, r4, #0
  for (i = 0; i < nwords; ++i)
    21e0:	9f300208 	svcls	0x00300208
  int nwords = (nbits / 32);
    21e4:	011e0804 	tsteq	lr, r4, lsl #16
    21e8:	00740052 	rsbseq	r0, r4, r2, asr r0
    x[i] = 0;
    21ec:	00050000 	andeq	r0, r5, r0
  for (i = 0; i < nwords; ++i)
    21f0:	00000004 	andeq	r0, r0, r4
    21f4:	00000000 	andeq	r0, r0, r0
  j = 0;
    21f8:	58040000 	stmdapl	r4, {}	@ <UNPREDICTABLE>
    x[i] = y[j];
    21fc:	04500168 	ldrbeq	r0, [r0], #-360	@ 0xfffffe98
    2200:	5001706a 	andpl	r7, r1, sl, rrx
    i += 1;
    2204:	00000000 	andeq	r0, r0, r0
    j += 1;
    2208:	04000000 	streq	r0, [r0], #-0
  while (i < BITVEC_NWORDS)
    220c:	50012900 	andpl	r2, r1, r0, lsl #18
  if (nbits != 0)
    2210:	042c2904 	strteq	r2, [ip], #-2308	@ 0xfffff6fc
}
    2214:	9f5001a3 	svcls	0x005001a3
      x[i]  = (x[i] << nbits) | (x[i - 1] >> (32 - nbits));
    2218:	01402c04 	cmpeq	r0, r4, lsl #24
    221c:	00000050 	andeq	r0, r0, r0, asr r0
    2220:	00000000 	andeq	r0, r0, r0
    2224:	00040000 	andeq	r0, r4, r0
    2228:	04510126 	ldrbeq	r0, [r1], #-294	@ 0xfffffeda
    222c:	52012926 	andpl	r2, r1, #622592	@ 0x98000
    2230:	042c2904 	strteq	r2, [ip], #-2308	@ 0xfffff6fc
    2234:	9f5101a3 	svcls	0x005101a3
    for (i = (BITVEC_NWORDS - 1); i > 0; --i)
    2238:	01402c04 	cmpeq	r0, r4, lsl #24
    x[0] <<= nbits;
    223c:	00000051 	andeq	r0, r0, r1, asr r0
    2240:	00000000 	andeq	r0, r0, r0
    for (i = (BITVEC_NWORDS - 1); i > 0; --i)
    2244:	00040000 	andeq	r0, r4, r0
  x[0] = 1;
    2248:	04520124 	ldrbeq	r0, [r2], #-292	@ 0xfffffedc
  for (i = 1; i < BITVEC_NWORDS; ++i)
    224c:	03052924 	movweq	r2, #22820	@ 0x5924
    x[i] = 0;
    2250:	20000324 	andcs	r0, r0, r4, lsr #6
  for (i = 1; i < BITVEC_NWORDS; ++i)
    2254:	042c2904 	strteq	r2, [ip], #-2308	@ 0xfffff6fc
    2258:	9f5201a3 	svcls	0x005201a3
  if (x[0] != 1)
    225c:	01402c04 	cmpeq	r0, r4, lsl #24
    2260:	00dc0052 	sbcseq	r0, ip, r2, asr r0
  for (i = 1; i < BITVEC_NWORDS; ++i)
    2264:	00050000 	andeq	r0, r5, r0
    if (x[i] != 0)
    2268:	00000004 	andeq	r0, r0, r4
  for (i = 1; i < BITVEC_NWORDS; ++i)
    226c:	00000000 	andeq	r0, r0, r0
  return (i == BITVEC_NWORDS);
    2270:	50040000 	andpl	r0, r4, r0
    2274:	0450015e 	ldrbeq	r0, [r0], #-350	@ 0xfffffea2
    2278:	a304605e 	movwge	r6, #16478	@ 0x405e
}
    227c:	009f5001 	addseq	r5, pc, r1
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2280:	00000004 	andeq	r0, r0, r4
{
    2284:	02545004 	subseq	r5, r4, #4
    z[i] = (x[i] ^ y[i]);
    2288:	54049f30 	strpl	r9, [r4], #-3888	@ 0xfffff0d0
    228c:	00530160 	subseq	r0, r3, r0, ror #2
    2290:	00000003 	andeq	r0, r0, r3
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2294:	015e5004 	cmpeq	lr, r4
    2298:	605e0450 	subsvs	r0, lr, r0, asr r4
}
    229c:	5001a304 	andpl	sl, r1, r4, lsl #6
  x[0] ^= 1;
    22a0:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
    22a4:	3a040000 	bcc	1022ac <__ROM_SIZE__+0xc22ac>
}
    22a8:	0450014e 	ldrbeq	r0, [r0], #-334	@ 0xfffffeb2
{
    22ac:	a304504e 	movwge	r5, #16462	@ 0x404e
    22b0:	009f5001 	addseq	r5, pc, r1
  bitvec_copy(tmp, x);
    22b4:	00000005 	andeq	r0, r0, r5
    22b8:	023e3a04 	eorseq	r3, lr, #4, 20	@ 0x4000
  if (bitvec_get_bit(y, 0) != 0)
    22bc:	3e049f30 	mcrcc	15, 0, r9, cr4, cr0, {1}
    22c0:	00530150 	subseq	r0, r3, r0, asr r1
    bitvec_copy(z, x);
    22c4:	3a040003 	bcc	1022d8 <__ROM_SIZE__+0xc22d8>
    22c8:	00510150 	subseq	r0, r1, r0, asr r1
{
    22cc:	00000004 	andeq	r0, r0, r4
    bitvec_set_zero(z);
    22d0:	014e3a04 	cmpeq	lr, r4, lsl #20
    22d4:	504e0450 	subpl	r0, lr, r0, asr r4
      gf2field_add(tmp, tmp, polynomial);
    22d8:	5001a304 	andpl	sl, r1, r4, lsl #6
    22dc:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
    22e0:	00000000 	andeq	r0, r0, r0
  for (i = 1; i < CURVE_DEGREE; ++i)
    22e4:	012a2604 			@ <UNDEFINED> instruction: 0x012a2604
    22e8:	2e2a0450 	mcrcs	4, 1, r0, cr10, cr0, {2}
    bitvec_lshift(tmp, tmp, 1);
    22ec:	9f017003 	svcls	0x00017003
    22f0:	01382e04 	teqeq	r8, r4, lsl #28
    if (bitvec_get_bit(tmp, CURVE_DEGREE))
    22f4:	00000050 	andeq	r0, r0, r0, asr r0
    22f8:	26040000 	strcs	r0, [r4], -r0
    22fc:	0451012a 	ldrbeq	r0, [r1], #-298	@ 0xfffffed6
    if (bitvec_get_bit(y, i))
    2300:	51013a2a 	tstpl	r1, sl, lsr #20
    2304:	00000000 	andeq	r0, r0, r0
    2308:	14100400 	ldrne	r0, [r0], #-1024	@ 0xfffffc00
      gf2field_add(z, z, tmp);
    230c:	14045001 	strne	r5, [r4], #-1
    2310:	00500122 	subseq	r0, r0, r2, lsr #2
    2314:	00000000 	andeq	r0, r0, r0
}
    2318:	01161004 	tsteq	r6, r4
    231c:	26160451 			@ <UNDEFINED> instruction: 0x26160451
{
    2320:	00005101 	andeq	r5, r0, r1, lsl #2
    2324:	04000000 	streq	r0, [r0], #-0
  bitvec_copy(u, x);
    2328:	50010400 	andpl	r0, r1, r0, lsl #8
  bitvec_copy(v, polynomial);
    232c:	01100404 	tsteq	r0, r4, lsl #8
    2330:	00010052 	andeq	r0, r1, r2, asr r0
  bitvec_set_zero(g);
    2334:	02040000 	andeq	r0, r4, #0
    2338:	9f300206 	svcls	0x00300206
  gf2field_set_one(z);
    233c:	01100604 	tsteq	r0, r4, lsl #12
  while (!gf2field_is_one(u))
    2340:	Address 0x2340 is out of bounds.


Disassembly of section .debug_aranges:

00000000 <.debug_aranges>:
   0:	0000001c 	andeq	r0, r0, ip, lsl r0
   4:	00000002 	andeq	r0, r0, r2
   8:	00040000 	andeq	r0, r4, r0
   c:	00000000 	andeq	r0, r0, r0
  10:	000003c0 	andeq	r0, r0, r0, asr #7
  14:	00000114 	andeq	r0, r0, r4, lsl r1
	...
  20:	0000001c 	andeq	r0, r0, ip, lsl r0
  24:	045e0002 	ldrbeq	r0, [lr], #-2
  28:	00040000 	andeq	r0, r4, r0
  2c:	00000000 	andeq	r0, r0, r0
  30:	000004d4 	ldrdeq	r0, [r0], -r4
  34:	00000002 	andeq	r0, r0, r2
	...
  40:	0000001c 	andeq	r0, r0, ip, lsl r0
  44:	051f0002 	ldreq	r0, [pc, #-2]	@ 4a <vector_table+0x4a>
  48:	00040000 	andeq	r0, r4, r0
  4c:	00000000 	andeq	r0, r0, r0
  50:	000004d8 	ldrdeq	r0, [r0], -r8
  54:	00000064 	andeq	r0, r0, r4, rrx
	...
  60:	0000001c 	andeq	r0, r0, ip, lsl r0
  64:	05b40002 	ldreq	r0, [r4, #2]!
  68:	00040000 	andeq	r0, r4, r0
  6c:	00000000 	andeq	r0, r0, r0
  70:	0000053c 	andeq	r0, r0, ip, lsr r5
  74:	00000064 	andeq	r0, r0, r4, rrx
	...
  80:	0000001c 	andeq	r0, r0, ip, lsl r0
  84:	06490002 	strbeq	r0, [r9], -r2
  88:	00040000 	andeq	r0, r4, r0
  8c:	00000000 	andeq	r0, r0, r0
  90:	000005a0 	andeq	r0, r0, r0, lsr #11
  94:	0000008c 	andeq	r0, r0, ip, lsl #1
	...
  a0:	0000001c 	andeq	r0, r0, ip, lsl r0
  a4:	07cc0002 	strbeq	r0, [ip, r2]
  a8:	00040000 	andeq	r0, r4, r0
  ac:	00000000 	andeq	r0, r0, r0
  b0:	0000062c 	andeq	r0, r0, ip, lsr #12
  b4:	000000a4 	andeq	r0, r0, r4, lsr #1
	...
  c0:	0000001c 	andeq	r0, r0, ip, lsl r0
  c4:	0b750002 	bleq	1d400d4 <__ROM_SIZE__+0x1d000d4>
  c8:	00040000 	andeq	r0, r4, r0
  cc:	00000000 	andeq	r0, r0, r0
  d0:	000006d0 	ldrdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
  d4:	0000001c 	andeq	r0, r0, ip, lsl r0
	...
  e0:	0000001c 	andeq	r0, r0, ip, lsl r0
  e4:	0d040002 	stceq	0, cr0, [r4, #-8]
  e8:	00040000 	andeq	r0, r4, r0
  ec:	00000000 	andeq	r0, r0, r0
  f0:	000006ec 	andeq	r0, r0, ip, ror #13
  f4:	000000ac 	andeq	r0, r0, ip, lsr #1
	...
 100:	0000001c 	andeq	r0, r0, ip, lsl r0
 104:	106a0002 	rsbne	r0, sl, r2
 108:	00040000 	andeq	r0, r4, r0
 10c:	00000000 	andeq	r0, r0, r0
 110:	00000798 	muleq	r0, r8, r7
 114:	0000010c 	andeq	r0, r0, ip, lsl #2
	...
 120:	0000001c 	andeq	r0, r0, ip, lsl r0
 124:	16b30002 	ldrtne	r0, [r3], r2
 128:	00040000 	andeq	r0, r4, r0
 12c:	00000000 	andeq	r0, r0, r0
 130:	000008a4 	andeq	r0, r0, r4, lsr #17
 134:	0000001c 	andeq	r0, r0, ip, lsl r0
	...
 140:	0000001c 	andeq	r0, r0, ip, lsl r0
 144:	18420002 	stmdane	r2, {r1}^
 148:	00040000 	andeq	r0, r4, r0
 14c:	00000000 	andeq	r0, r0, r0
 150:	000008c0 	andeq	r0, r0, r0, asr #17
 154:	000000a4 	andeq	r0, r0, r4, lsr #1
	...
 160:	0000001c 	andeq	r0, r0, ip, lsl r0
 164:	1c4c0002 	mcrrne	0, 0, r0, ip, cr2
 168:	00040000 	andeq	r0, r4, r0
 16c:	00000000 	andeq	r0, r0, r0
 170:	00000964 	andeq	r0, r0, r4, ror #18
 174:	00000680 	andeq	r0, r0, r0, lsl #13
	...
 180:	0000001c 	andeq	r0, r0, ip, lsl r0
 184:	2ce10002 	stclcs	0, cr0, [r1], #8
 188:	00040000 	andeq	r0, r4, r0
 18c:	00000000 	andeq	r0, r0, r0
 190:	00000fe4 	andeq	r0, r0, r4, ror #31
 194:	0000025c 	andeq	r0, r0, ip, asr r2
	...
 1a0:	0000001c 	andeq	r0, r0, ip, lsl r0
 1a4:	2fea0002 	svccs	0x00ea0002
 1a8:	00040000 	andeq	r0, r4, r0
 1ac:	00000000 	andeq	r0, r0, r0
 1b0:	00001240 	andeq	r1, r0, r0, asr #4
 1b4:	000002ee 	andeq	r0, r0, lr, ror #5
	...
 1c0:	0000001c 	andeq	r0, r0, ip, lsl r0
 1c4:	33a30002 			@ <UNDEFINED> instruction: 0x33a30002
 1c8:	00040000 	andeq	r0, r4, r0
 1cc:	00000000 	andeq	r0, r0, r0
 1d0:	00001530 	andeq	r1, r0, r0, lsr r5
 1d4:	00000238 	andeq	r0, r0, r8, lsr r2
	...
 1e0:	0000001c 	andeq	r0, r0, ip, lsl r0
 1e4:	36d20002 	ldrbcc	r0, [r2], r2
 1e8:	00040000 	andeq	r0, r4, r0
 1ec:	00000000 	andeq	r0, r0, r0
 1f0:	00001768 	andeq	r1, r0, r8, ror #14
 1f4:	00000238 	andeq	r0, r0, r8, lsr r2
	...
 200:	0000001c 	andeq	r0, r0, ip, lsl r0
 204:	3a010002 	bcc	40214 <__ROM_SIZE__+0x214>
 208:	00040000 	andeq	r0, r4, r0
 20c:	00000000 	andeq	r0, r0, r0
 210:	000019a0 	andeq	r1, r0, r0, lsr #19
 214:	00000160 	andeq	r0, r0, r0, ror #2
	...
 220:	0000001c 	andeq	r0, r0, ip, lsl r0
 224:	3f6d0002 	svccc	0x006d0002
 228:	00040000 	andeq	r0, r4, r0
 22c:	00000000 	andeq	r0, r0, r0
 230:	00001b00 	andeq	r1, r0, r0, lsl #22
 234:	000005fc 	strdeq	r0, [r0], -ip
	...
 240:	0000001c 	andeq	r0, r0, ip, lsl r0
 244:	4ba10002 	blmi	fe840254 <_STACK_TOP_+0xde838258>
 248:	00040000 	andeq	r0, r4, r0
 24c:	00000000 	andeq	r0, r0, r0
 250:	000020fc 	strdeq	r2, [r0], -ip
 254:	00000580 	andeq	r0, r0, r0, lsl #11
	...
 260:	0000001c 	andeq	r0, r0, ip, lsl r0
 264:	5de60002 	stclpl	0, cr0, [r6, #8]!
 268:	00040000 	andeq	r0, r4, r0
 26c:	00000000 	andeq	r0, r0, r0
 270:	0000267c 	andeq	r2, r0, ip, ror r6
 274:	0000005c 	andeq	r0, r0, ip, asr r0
	...
 280:	0000001c 	andeq	r0, r0, ip, lsl r0
 284:	5f310002 	svcpl	0x00310002
 288:	00040000 	andeq	r0, r4, r0
 28c:	00000000 	andeq	r0, r0, r0
 290:	000026d8 	ldrdeq	r2, [r0], -r8
 294:	000000ac 	andeq	r0, r0, ip, lsr #1
	...
 2a0:	0000001c 	andeq	r0, r0, ip, lsl r0
 2a4:	615b0002 	cmpvs	fp, r2
 2a8:	00040000 	andeq	r0, r4, r0
 2ac:	00000000 	andeq	r0, r0, r0
 2b0:	00002784 	andeq	r2, r0, r4, lsl #15
 2b4:	00000060 	andeq	r0, r0, r0, rrx
	...

Disassembly of section .debug_line:

00000000 <.debug_line>:
       0:	00000261 	andeq	r0, r0, r1, ror #4
       4:	01980003 	orrseq	r0, r8, r3
       8:	01020000 	mrseq	r0, (UNDEF: 2)
       c:	000d0efb 	strdeq	r0, [sp], -fp
      10:	01010101 	tsteq	r1, r1, lsl #2
      14:	01000000 	mrseq	r0, (UNDEF: 0)
      18:	2f010000 	svccs	0x00010000
      1c:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
      20:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
      24:	63652f66 	cmnvs	r5, #408	@ 0x198
      28:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
      2c:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
      30:	652f7265 	strvs	r7, [pc, #-613]!	@ fffffdd3 <_STACK_TOP_+0xdfff7dd7>
      34:	2f667463 	svccs	0x00667463
      38:	00626f66 	rsbeq	r6, r2, r6, ror #30
      3c:	74706f2f 	ldrbtvc	r6, [r0], #-3887	@ 0xfffff0d1
      40:	6363672f 	cmnvs	r3, #12320768	@ 0xbc0000
      44:	6d72612d 	ldfvse	f6, [r2, #-180]!	@ 0xffffff4c
      48:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
      4c:	61652d65 	cmnvs	r5, r5, ror #26
      50:	6c2f6962 			@ <UNDEFINED> instruction: 0x6c2f6962
      54:	672f6269 	strvs	r6, [pc, -r9, ror #4]!
      58:	612f6363 			@ <UNDEFINED> instruction: 0x612f6363
      5c:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
      60:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	@ 0xfffffe44
      64:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
      68:	2e32312f 	rsfcssp	f3, f2, #10.0
      6c:	2f312e32 	svccs	0x00312e32
      70:	6c636e69 	stclvs	14, cr6, [r3], #-420	@ 0xfffffe5c
      74:	00656475 	rsbeq	r6, r5, r5, ror r4
      78:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ ffffffc4 <_STACK_TOP_+0xdfff7fc8>
      7c:	63652f65 	cmnvs	r5, #404	@ 0x194
      80:	652f6674 	strvs	r6, [pc, #-1652]!	@ fffffa14 <_STACK_TOP_+0xdfff7a18>
      84:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
      88:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
      8c:	2f72656e 	svccs	0x0072656e
      90:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
      94:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
      98:	69742f62 	ldmdbvs	r4!, {r1, r5, r6, r8, r9, sl, fp, sp}^
      9c:	612d796e 			@ <UNDEFINED> instruction: 0x612d796e
      a0:	2f007365 	svccs	0x00007365
      a4:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
      a8:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
      ac:	63652f66 	cmnvs	r5, #408	@ 0x198
      b0:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
      b4:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
      b8:	732f7265 			@ <UNDEFINED> instruction: 0x732f7265
      bc:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
      c0:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
      c4:	2f006c6c 	svccs	0x00006c6c
      c8:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
      cc:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
      d0:	63652f66 	cmnvs	r5, #408	@ 0x198
      d4:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
      d8:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
      dc:	732f7265 			@ <UNDEFINED> instruction: 0x732f7265
      e0:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
      e4:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
      e8:	7361622f 	cmnvc	r1, #-268435454	@ 0xf0000002
      ec:	00343665 	eorseq	r3, r4, r5, ror #12
      f0:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 3c <vector_table+0x3c>
      f4:	63652f65 	cmnvs	r5, #404	@ 0x194
      f8:	652f6674 	strvs	r6, [pc, #-1652]!	@ fffffa8c <_STACK_TOP_+0xdfff7a90>
      fc:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
     100:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
     104:	2f72656e 	svccs	0x0072656e
     108:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
     10c:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
     110:	74732f62 	ldrbtvc	r2, [r3], #-3938	@ 0xfffff09e
     114:	676e6972 			@ <UNDEFINED> instruction: 0x676e6972
     118:	6f682f00 	svcvs	0x00682f00
     11c:	652f656d 	strvs	r6, [pc, #-1389]!	@ fffffbb7 <_STACK_TOP_+0xdfff7bbb>
     120:	2f667463 	svccs	0x00667463
     124:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
     128:	6172742d 	cmnvs	r2, sp, lsr #8
     12c:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
     130:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
     134:	6c2f6c6c 	stcvs	12, cr6, [pc], #-432	@ ffffff8c <_STACK_TOP_+0xdfff7f90>
     138:	702f6269 	eorvc	r6, pc, r9, ror #4
     13c:	746e6972 	strbtvc	r6, [lr], #-2418	@ 0xfffff68e
     140:	6d000066 	stcvs	0, cr0, [r0, #-408]	@ 0xfffffe68
     144:	2e677365 	cdpcs	3, 6, cr7, cr7, cr5, {3}
     148:	00010063 	andeq	r0, r1, r3, rrx
     14c:	64747300 	ldrbtvs	r7, [r4], #-768	@ 0xfffffd00
     150:	2d746e69 	ldclcs	14, cr6, [r4, #-420]!	@ 0xfffffe5c
     154:	2e636367 	cdpcs	3, 6, cr6, cr3, cr7, {3}
     158:	00020068 	andeq	r0, r2, r8, rrx
     15c:	64747300 	ldrbtvs	r7, [r4], #-768	@ 0xfffffd00
     160:	2e666564 	cdpcs	5, 6, cr6, cr6, cr4, {3}
     164:	00020068 	andeq	r0, r2, r8, rrx
     168:	73656100 	cmnvc	r5, #0, 2
     16c:	0300682e 	movweq	r6, #2094	@ 0x82e
     170:	68730000 	ldmdavs	r3!, {}^	@ <UNPREDICTABLE>
     174:	2e6c6c65 	cdpcs	12, 6, cr6, cr12, cr5, {3}
     178:	00040068 	andeq	r0, r4, r8, rrx
     17c:	73616200 	cmnvc	r1, #0, 4
     180:	2e343665 	cfmsuba32cs	mvax3, mvax3, mvfx4, mvfx5
     184:	00050068 	andeq	r0, r5, r8, rrx
     188:	72747300 	rsbsvc	r7, r4, #0, 6
     18c:	2e676e69 	cdpcs	14, 6, cr6, cr7, cr9, {3}
     190:	00060068 	andeq	r0, r6, r8, rrx
     194:	69727000 	ldmdbvs	r2!, {ip, sp, lr}^
     198:	2e66746e 	cdpcs	4, 6, cr7, cr6, cr14, {3}
     19c:	00070068 	andeq	r0, r7, r8, rrx
     1a0:	25050000 	strcs	r0, [r5, #-0]
     1a4:	c0020500 	andgt	r0, r2, r0, lsl #10
     1a8:	17000003 	strne	r0, [r0, -r3]
     1ac:	05050106 	streq	r0, [r5, #-262]	@ 0xfffffefa
     1b0:	06134b06 	ldreq	r4, [r3], -r6, lsl #22
     1b4:	052f0620 	streq	r0, [pc, #-1568]!	@ fffffb9c <_STACK_TOP_+0xdfff7ba0>
     1b8:	0501060e 	streq	r0, [r1, #-1550]	@ 0xfffff9f2
     1bc:	09052005 	stmdbeq	r5, {r0, r2, sp}
     1c0:	03040200 	movweq	r0, #16896	@ 0x4200
     1c4:	22052106 	andcs	r2, r5, #-2147483647	@ 0x80000001
     1c8:	03040200 	movweq	r0, #16896	@ 0x4200
     1cc:	00170557 	andseq	r0, r7, r7, asr r5
     1d0:	20010402 	andcs	r0, r1, r2, lsl #8
     1d4:	3e310505 	cdpcc	5, 3, cr0, cr1, cr5, {0}
     1d8:	01060805 	tsteq	r6, r5, lsl #16
     1dc:	03060505 	movweq	r0, #25861	@ 0x6505
     1e0:	01052e24 	tsteq	r5, r4, lsr #28
     1e4:	09051306 	stmdbeq	r5, {r1, r2, r8, r9, ip}
     1e8:	3c5d0306 	mrrccc	3, 0, r0, sp, cr6
     1ec:	01060d05 	tsteq	r6, r5, lsl #26
     1f0:	054a0c05 	strbeq	r0, [sl, #-3077]	@ 0xfffff3fb
     1f4:	0521060d 	streq	r0, [r1, #-1549]!	@ 0xfffff9f3
     1f8:	12054c0e 	andne	r4, r5, #3584	@ 0xe00
     1fc:	11050106 	tstne	r5, r6, lsl #2
     200:	060d054a 	streq	r0, [sp], -sl, asr #10
     204:	06100521 	ldreq	r0, [r0], -r1, lsr #10
     208:	06110501 	ldreq	r0, [r1], -r1, lsl #10
     20c:	032e0903 			@ <UNDEFINED> instruction: 0x032e0903
     210:	13134a78 	tstne	r3, #120, 20	@ 0x78000
     214:	01061705 	tsteq	r6, r5, lsl #14
     218:	06110520 	ldreq	r0, [r1], -r0, lsr #10
     21c:	062e0691 			@ <UNDEFINED> instruction: 0x062e0691
     220:	061e052f 	ldreq	r0, [lr], -pc, lsr #10
     224:	05204a01 	streq	r4, [r0, #-2561]!	@ 0xfffff5ff
     228:	052f0611 	streq	r0, [pc, #-1553]!	@ fffffc1f <_STACK_TOP_+0xdfff7c23>
     22c:	12055e0e 	andne	r5, r5, #14, 28	@ 0xe0
     230:	11050106 	tstne	r5, r6, lsl #2
     234:	060d054a 	streq	r0, [sp], -sl, asr #10
     238:	06100521 	ldreq	r0, [r0], -r1, lsr #10
     23c:	06110501 	ldreq	r0, [r1], -r1, lsl #10
     240:	032e0903 			@ <UNDEFINED> instruction: 0x032e0903
     244:	133d4a78 	teqne	sp, #120, 20	@ 0x78000
     248:	06170513 			@ <UNDEFINED> instruction: 0x06170513
     24c:	11052001 	tstne	r5, r1
     250:	1e058306 	cdpne	3, 0, cr8, cr5, cr6, {0}
     254:	11050106 	tstne	r5, r6, lsl #2
     258:	2e066706 	cdpcs	7, 0, cr6, cr6, cr6, {0}
     25c:	43060d05 	movwmi	r0, #27909	@ 0x6d05
     260:	01002102 	tsteq	r0, r2, lsl #2
     264:	0000c001 	andeq	ip, r0, r1
     268:	9b000300 	blls	e70 <shell+0x98>
     26c:	02000000 	andeq	r0, r0, #0
     270:	0d0efb01 	vstreq	d15, [lr, #-4]
     274:	01010100 	mrseq	r0, (UNDEF: 17)
     278:	00000001 	andeq	r0, r0, r1
     27c:	01000001 	tsteq	r0, r1
     280:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 1cc <vector_table+0x1cc>
     284:	63652f65 	cmnvs	r5, #404	@ 0x194
     288:	652f6674 	strvs	r6, [pc, #-1652]!	@ fffffc1c <_STACK_TOP_+0xdfff7c20>
     28c:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
     290:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
     294:	2f72656e 	svccs	0x0072656e
     298:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
     29c:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
     2a0:	616c702f 	cmnvs	ip, pc, lsr #32
     2a4:	726f6674 	rsbvc	r6, pc, #116, 12	@ 0x7400000
     2a8:	6f2f006d 	svcvs	0x002f006d
     2ac:	672f7470 			@ <UNDEFINED> instruction: 0x672f7470
     2b0:	612d6363 			@ <UNDEFINED> instruction: 0x612d6363
     2b4:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
     2b8:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	@ 0xfffffe44
     2bc:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
     2c0:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
     2c4:	6363672f 	cmnvs	r3, #12320768	@ 0xbc0000
     2c8:	6d72612f 	ldfvse	f6, [r2, #-188]!	@ 0xffffff44
     2cc:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
     2d0:	61652d65 	cmnvs	r5, r5, ror #26
     2d4:	312f6962 			@ <UNDEFINED> instruction: 0x312f6962
     2d8:	2e322e32 	mrccs	14, 1, r2, cr2, cr2, {1}
     2dc:	6e692f31 	mcrvs	15, 3, r2, cr9, cr1, {1}
     2e0:	64756c63 	ldrbtvs	r6, [r5], #-3171	@ 0xfffff39d
     2e4:	76000065 	strvc	r0, [r0], -r5, rrx
     2e8:	6f746365 	svcvs	0x00746365
     2ec:	61745f72 	cmnvs	r4, r2, ror pc
     2f0:	2e656c62 	cdpcs	12, 6, cr6, cr5, cr2, {3}
     2f4:	00010063 	andeq	r0, r1, r3, rrx
     2f8:	64747300 	ldrbtvs	r7, [r4], #-768	@ 0xfffffd00
     2fc:	2d746e69 	ldclcs	14, cr6, [r4, #-420]!	@ 0xfffffe5c
     300:	2e636367 	cdpcs	3, 6, cr6, cr3, cr7, {3}
     304:	00020068 	andeq	r0, r2, r8, rrx
     308:	1c050000 	stcne	0, cr0, [r5], {-0}
     30c:	d4020500 	strle	r0, [r2], #-1280	@ 0xfffffb00
     310:	03000004 	movweq	r0, #4
     314:	03050116 	movweq	r0, #20758	@ 0x5116
     318:	01040200 	mrseq	r0, R12_usr
     31c:	00090513 	andeq	r0, r9, r3, lsl r5
     320:	01010402 	tsteq	r1, r2, lsl #8
     324:	01000102 	tsteq	r0, r2, lsl #2
     328:	0000f901 	andeq	pc, r0, r1, lsl #18
     32c:	4c000300 	stcmi	3, cr0, [r0], {-0}
     330:	02000000 	andeq	r0, r0, #0
     334:	0d0efb01 	vstreq	d15, [lr, #-4]
     338:	01010100 	mrseq	r0, (UNDEF: 17)
     33c:	00000001 	andeq	r0, r0, r1
     340:	01000001 	tsteq	r0, r1
     344:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 290 <vector_table+0x290>
     348:	63652f65 	cmnvs	r5, #404	@ 0x194
     34c:	652f6674 	strvs	r6, [pc, #-1652]!	@ fffffce0 <_STACK_TOP_+0xdfff7ce4>
     350:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
     354:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
     358:	2f72656e 	svccs	0x0072656e
     35c:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
     360:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
     364:	616c702f 	cmnvs	ip, pc, lsr #32
     368:	726f6674 	rsbvc	r6, pc, #116, 12	@ 0x7400000
     36c:	61752f6d 	cmnvs	r5, sp, ror #30
     370:	00007472 	andeq	r7, r0, r2, ror r4
     374:	74726175 	ldrbtvc	r6, [r2], #-373	@ 0xfffffe8b
     378:	0100632e 	tsteq	r0, lr, lsr #6
     37c:	05000000 	streq	r0, [r0, #-0]
     380:	02050014 	andeq	r0, r5, #20
     384:	000004d8 	ldrdeq	r0, [r0], -r8
     388:	06011203 	streq	r1, [r1], -r3, lsl #4
     38c:	000a0501 	andeq	r0, sl, r1, lsl #10
     390:	06010402 	streq	r0, [r1], -r2, lsl #8
     394:	000b0521 	andeq	r0, fp, r1, lsr #10
     398:	06010402 	streq	r0, [r1], -r2, lsl #8
     39c:	000a0501 	andeq	r0, sl, r1, lsl #10
     3a0:	2e010402 	cdpcs	4, 0, cr0, cr1, cr2, {0}
     3a4:	3f060305 	svccc	0x00060305
     3a8:	01060b05 	tsteq	r6, r5, lsl #22
     3ac:	2f060305 	svccs	0x00060305
     3b0:	01060605 	tsteq	r6, r5, lsl #12
     3b4:	05300105 	ldreq	r0, [r0, #-261]!	@ 0xfffffefb
     3b8:	061f0605 	ldreq	r0, [pc], -r5, lsl #12
     3bc:	2f010520 	svccs	0x00010520
int car_mesg(int argc, char** argv) {
     3c0:	00061105 	andeq	r1, r6, r5, lsl #2
     3c4:	04fc0205 	ldrbteq	r0, [ip], #517	@ 0x205
    printf("Received a message from the car:");
     3c8:	05140000 	ldreq	r0, [r4, #-0]
     3cc:	0a051303 	beq	144fe0 <__ROM_SIZE__+0x104fe0>
    for (ctr = 1; ctr < argc; ctr++) {
     3d0:	06050106 	streq	r0, [r5], -r6, lsl #2
        printf(" %s", argv[ctr]);
     3d4:	001d052e 	andseq	r0, sp, lr, lsr #10
     3d8:	06010402 	streq	r0, [r1], -r2, lsl #8
    for (ctr = 1; ctr < argc; ctr++) {
     3dc:	0024053c 	eoreq	r0, r4, ip, lsr r5
     3e0:	06010402 	streq	r0, [r1], -r2, lsl #8
    printf("\n");
     3e4:	3e0a0501 	cfsh32cc	mvfx0, mvfx10, #1
    if (argc > 1) {
     3e8:	052f0105 	streq	r0, [pc, #-261]!	@ 2eb <vector_table+0x2eb>
}
     3ec:	054c0616 	strbeq	r0, [ip, #-1558]	@ 0xfffff9ea
     3f0:	0b051403 	bleq	145404 <__ROM_SIZE__+0x105404>
        if (strcmp(argv[1], "PING_REPLY") == 0) {
     3f4:	03050106 	movweq	r0, #20742	@ 0x5106
     3f8:	0c053f06 	stceq	15, cr3, [r5], {6}
            printf("Got a ping reply.\n");
     3fc:	03050106 	movweq	r0, #20742	@ 0x5106
     400:	0c052f06 	stceq	15, cr2, [r5], {6}
        else if (strcmp(argv[1], "AESB64") == 0) {
     404:	03050106 	movweq	r0, #20742	@ 0x5106
     408:	0a053106 	beq	14c828 <__ROM_SIZE__+0x10c828>
     40c:	03050106 	movweq	r0, #20742	@ 0x5106
            if (argc == 3) { 
     410:	0c053106 	stfeqs	f3, [r5], {6}
                printf("Missing AESB64 encoded message\n");
     414:	03050106 	movweq	r0, #20742	@ 0x5106
     418:	0b053106 	bleq	14c838 <__ROM_SIZE__+0x10c838>
                len = decode_base64((uint8_t *) argv[2], strlen(argv[2]), decoded);
     41c:	01050106 	tsteq	r5, r6, lsl #2
     420:	0004023d 	andeq	r0, r4, sp, lsr r2
     424:	00fa0101 	rscseq	r0, sl, r1, lsl #2
     428:	00030000 	andeq	r0, r3, r0
     42c:	0000004d 	andeq	r0, r0, sp, asr #32
                AES_ECB_decrypt(&ctx, decoded);
     430:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
     434:	0101000d 	tsteq	r1, sp
                decoded[len] = '\0';
     438:	00000101 	andeq	r0, r0, r1, lsl #2
     43c:	00000100 	andeq	r0, r0, r0, lsl #2
     440:	6f682f01 	svcvs	0x00682f01
                printf("Decoded/decrypted as %s\n", decoded);
     444:	652f656d 	strvs	r6, [pc, #-1389]!	@ fffffedf <_STACK_TOP_+0xdfff7ee3>
     448:	2f667463 	svccs	0x00667463
     44c:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
        else if (strcmp(argv[1], "B64") == 0) {
     450:	6172742d 	cmnvs	r2, sp, lsr #8
     454:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
            if (argc == 3) { 
     458:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
                printf("Missing Base64 encoded message\n");
     45c:	6f662f66 	svcvs	0x00662f66
     460:	6c702f62 	ldclvs	15, cr2, [r0], #-392	@ 0xfffffe78
                printf("Decoding Base64\n");
     464:	6f667461 	svcvs	0x00667461
     468:	752f6d72 	strvc	r6, [pc, #-3442]!	@ fffff6fe <_STACK_TOP_+0xdfff7702>
                len = decode_base64((uint8_t *) argv[2], strlen(argv[2]), decoded);
     46c:	00747261 	rsbseq	r7, r4, r1, ror #4
     470:	72617500 	rsbvc	r7, r1, #0, 10
     474:	632e3274 			@ <UNDEFINED> instruction: 0x632e3274
     478:	00000100 	andeq	r0, r0, r0, lsl #2
                decoded[len] = '\0';
     47c:	00150500 	andseq	r0, r5, r0, lsl #10
     480:	053c0205 	ldreq	r0, [ip, #-517]!	@ 0xfffffdfb
     484:	12030000 	andne	r0, r3, #0
                printf("Decoded as %s", decoded);
     488:	05010601 	streq	r0, [r1, #-1537]	@ 0xfffff9ff
     48c:	0402000a 	streq	r0, [r2], #-10
     490:	05210601 	streq	r0, [r1, #-1537]!	@ 0xfffff9ff
            printf("Didn't know how to handle %s\n", argv[1]);
     494:	0402000b 	streq	r0, [r2], #-11
     498:	05010601 	streq	r0, [r1, #-1537]	@ 0xfffff9ff
     49c:	0402000a 	streq	r0, [r2], #-10
     4a0:	03052e01 	movweq	r2, #24065	@ 0x5e01
     4a4:	0c053f06 	stceq	15, cr3, [r5], {6}
     4a8:	03050106 	movweq	r0, #20742	@ 0x5106
     4ac:	06052f06 	streq	r2, [r5], -r6, lsl #30
     4b0:	01050106 	tsteq	r5, r6, lsl #2
     4b4:	06050530 			@ <UNDEFINED> instruction: 0x06050530
     4b8:	0520061f 	streq	r0, [r0, #-1567]!	@ 0xfffff9e1
     4bc:	12052f01 	andne	r2, r5, #1, 30
     4c0:	02050006 	andeq	r0, r5, #6
     4c4:	00000560 	andeq	r0, r0, r0, ror #10
     4c8:	13030514 	movwne	r0, #13588	@ 0x3514
     4cc:	01060a05 	tsteq	r6, r5, lsl #20
     4d0:	052e0605 	streq	r0, [lr, #-1541]!	@ 0xfffff9fb
     4d4:	0402001e 	streq	r0, [r2], #-30	@ 0xffffffe2
void uputc(char c) {
     4d8:	053c0601 	ldreq	r0, [ip, #-1537]!	@ 0xfffff9ff
  while ((UARTFR >> 5) & 1)
     4dc:	04020025 	streq	r0, [r2], #-37	@ 0xffffffdb
     4e0:	05010601 	streq	r0, [r1, #-1537]	@ 0xfffff9ff
  UART_DR = c;
     4e4:	01053e0a 	tsteq	r5, sl, lsl #28
  if (c == '\n')
     4e8:	0617052f 	ldreq	r0, [r7], -pc, lsr #10
}
     4ec:	1403054c 	strne	r0, [r3], #-1356	@ 0xfffffab4
    uputc('\r');
     4f0:	01060c05 	tsteq	r6, r5, lsl #24
}
     4f4:	3f060305 	svccc	0x00060305
     4f8:	01060d05 	tsteq	r6, r5, lsl #26
  if (!((UARTFR >> 4) & 1)) return UART_DR;
     4fc:	2f060305 	svccs	0x00060305
     500:	01060d05 	tsteq	r6, r5, lsl #26
     504:	31060305 	tstcc	r6, r5, lsl #6
     508:	01060b05 	tsteq	r6, r5, lsl #22
  return -1;
     50c:	31060305 	tstcc	r6, r5, lsl #6
}
     510:	01060d05 	tsteq	r6, r5, lsl #26
     514:	31060305 	tstcc	r6, r5, lsl #6
  UARTCTL = 0;
     518:	01060c05 	tsteq	r6, r5, lsl #24
     51c:	023d0105 	eorseq	r0, sp, #1073741825	@ 0x40000001
  UARTIBRD = 8;
     520:	01010004 	tsteq	r1, r4
  UARTFBRD = 44;
     524:	00000128 	andeq	r0, r0, r8, lsr #2
  UARTCC = 0;
     528:	00be0003 	adcseq	r0, lr, r3
  UARTLCRH = 0x60;
     52c:	01020000 	mrseq	r0, (UNDEF: 2)
  UARTCTL = 0x301;
     530:	000d0efb 	strdeq	r0, [sp], -fp
}
     534:	01010101 	tsteq	r1, r1, lsl #2
     538:	01000000 	mrseq	r0, (UNDEF: 0)
void u2putc(char c) {
     53c:	2f010000 	svccs	0x00010000
  while ((UART2FR >> 5) & 1)
     540:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
     544:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
  UART2_DR = c;
     548:	63652f66 	cmnvs	r5, #408	@ 0x198
  if (c == '\n')
     54c:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
}
     550:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
    u2putc('\r');
     554:	652f7265 	strvs	r7, [pc, #-613]!	@ 2f7 <vector_table+0x2f7>
}
     558:	2f667463 	svccs	0x00667463
     55c:	2f626f66 	svccs	0x00626f66
  if (!((UART2FR >> 4) & 1)) return UART2_DR;
     560:	74616c70 	strbtvc	r6, [r1], #-3184	@ 0xfffff390
     564:	6d726f66 	ldclvs	15, cr6, [r2, #-408]!	@ 0xfffffe68
     568:	6f682f00 	svcvs	0x00682f00
     56c:	652f656d 	strvs	r6, [pc, #-1389]!	@ 7 <vector_table+0x7>
  return -1;
     570:	2f667463 	svccs	0x00667463
}
     574:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
     578:	6172742d 	cmnvs	r2, sp, lsr #8
  UART2CTL = 0;
     57c:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
     580:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
  UART2IBRD = 8;
     584:	6f662f66 	svcvs	0x00662f66
  UART2FBRD = 44;
     588:	6c702f62 	ldclvs	15, cr2, [r0], #-392	@ 0xfffffe78
  UART2CC = 0;
     58c:	6f667461 	svcvs	0x00667461
  UART2LCRH = 0x60;
     590:	752f6d72 	strvc	r6, [pc, #-3442]!	@ fffff826 <_STACK_TOP_+0xdfff782a>
  UART2CTL = 0x301;
     594:	00747261 	rsbseq	r7, r4, r1, ror #4
}
     598:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 4e4 <uputc+0xc>
     59c:	63652f65 	cmnvs	r5, #404	@ 0x194
  RCGCUART |= 3;
     5a0:	652f6674 	strvs	r6, [pc, #-1652]!	@ ffffff34 <_STACK_TOP_+0xdfff7f38>
     5a4:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
     5a8:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
     5ac:	2f72656e 	svccs	0x0072656e
  RCGCGPIO |= 3;
     5b0:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
     5b4:	68732f6c 	ldmdavs	r3!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
     5b8:	006c6c65 	rsbeq	r6, ip, r5, ror #24
  GPIODEN = 0x03;
     5bc:	616c7000 	cmnvs	ip, r0
     5c0:	726f6674 	rsbvc	r6, pc, #116, 12	@ 0x7400000
  GPIOAFSEL = 0x03;
     5c4:	00632e6d 	rsbeq	r2, r3, sp, ror #28
  GPIOPCTL |= 0x00000011;
     5c8:	75000001 	strvc	r0, [r0, #-1]
     5cc:	32747261 	rsbscc	r7, r4, #268435462	@ 0x10000006
     5d0:	0200682e 	andeq	r6, r0, #3014656	@ 0x2e0000
  GPIODEN2 = 0x03;
     5d4:	68730000 	ldmdavs	r3!, {}^	@ <UNPREDICTABLE>
     5d8:	2e6c6c65 	cdpcs	12, 6, cr6, cr12, cr5, {3}
  GPIOAFSEL2 = 0x03;
     5dc:	00030068 	andeq	r0, r3, r8, rrx
  GPIOPCTL2 |= 0x00000011;
     5e0:	72617500 	rsbvc	r7, r1, #0, 10
     5e4:	00682e74 	rsbeq	r2, r8, r4, ror lr
     5e8:	00000002 	andeq	r0, r0, r2
}
     5ec:	05001205 	streq	r1, [r0, #-517]	@ 0xfffffdfb
     5f0:	0005a002 	andeq	sl, r5, r2
void platform_init() {
     5f4:	01210300 			@ <UNDEFINED> instruction: 0x01210300
    pin_setup();
     5f8:	05150305 	ldreq	r0, [r5, #-773]	@ 0xfffffcfb
    uart_init();
     5fc:	053c060c 	ldreq	r0, [ip, #-1548]!	@ 0xfffff9f4
    uart2_init();
     600:	054c0603 	strbeq	r0, [ip, #-1539]	@ 0xfffff9fd
    set_read_char(ugetc);
     604:	052e060c 	streq	r0, [lr, #-1548]!	@ 0xfffff9f4
    set_read_char2(u2getc);
     608:	054d0603 	strbeq	r0, [sp, #-1539]	@ 0xfffff9fd
     60c:	0501060b 	streq	r0, [r1, #-1547]	@ 0xfffff9f5
    set_write_char(uputc);
     610:	05590603 	ldrbeq	r0, [r9, #-1539]	@ 0xfffff9fd
    set_write_char2(u2putc);
     614:	0501060d 	streq	r0, [r1, #-1549]	@ 0xfffff9f3
     618:	052f0603 	streq	r0, [pc, #-1539]!	@ 1d <vector_table+0x1d>
}
     61c:	052e060c 	streq	r0, [lr, #-1548]!	@ 0xfffff9f4
     620:	054d0603 	strbeq	r0, [sp, #-1539]	@ 0xfffff9fd
     624:	0501060c 	streq	r0, [r1, #-1548]	@ 0xfffff9f4
     628:	054b0603 	strbeq	r0, [fp, #-1539]	@ 0xfffff9fd
int aes_test(int argc, char** argv) {
     62c:	0501060e 	streq	r0, [r1, #-1550]	@ 0xfffff9f2
    uint8_t text[17] = "0123456789abcdef";
     630:	052f0603 	streq	r0, [pc, #-1539]!	@ 35 <vector_table+0x35>
     634:	052e060d 	streq	r0, [lr, #-1549]!	@ 0xfffff9f3
     638:	16054b01 	strne	r4, [r5], -r1, lsl #22
     63c:	05055006 	streq	r5, [r5, #-6]
     640:	2f2f2f21 	svccs	0x002f2f21
    printf("Plaintext is %s\n", text);
     644:	053d3d3d 	ldreq	r3, [sp, #-3389]!	@ 0xfffff2c3
     648:	023d0601 	eorseq	r0, sp, #1048576	@ 0x100000
    AES_ECB_encrypt(&ctx, text);
     64c:	01010009 	tsteq	r1, r9
     650:	000001b5 			@ <UNDEFINED> instruction: 0x000001b5
    len = encode_base64(text, 16, b64text);
     654:	015b0003 	cmpeq	fp, r3
     658:	01020000 	mrseq	r0, (UNDEF: 2)
     65c:	000d0efb 	strdeq	r0, [sp], -fp
    b64text[len] = '\0';
     660:	01010101 	tsteq	r1, r1, lsl #2
     664:	01000000 	mrseq	r0, (UNDEF: 0)
     668:	2f010000 	svccs	0x00010000
    printf("Encrypted/encoded is %s\n", b64text);
     66c:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
     670:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
    printf2("FOB_MESG AESB64 %s\n", b64text);
     674:	63652f66 	cmnvs	r5, #408	@ 0x198
     678:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
    printf("Test the mesg handler with CAR_MESG AESB64 %s\n", b64text);
     67c:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
     680:	652f7265 	strvs	r7, [pc, #-613]!	@ 423 <car_mesg+0x63>
    len = decode_base64(b64text, len, decoded);
     684:	2f667463 	svccs	0x00667463
     688:	00626f66 	rsbeq	r6, r2, r6, ror #30
     68c:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 5d8 <pin_setup+0x38>
    AES_ECB_decrypt(&ctx, decoded);
     690:	63652f65 	cmnvs	r5, #404	@ 0x194
     694:	652f6674 	strvs	r6, [pc, #-1652]!	@ 28 <vector_table+0x28>
    decoded[len] = '\0';
     698:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
     69c:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
     6a0:	2f72656e 	svccs	0x0072656e
    printf("After encrypting->encoding->decoding->decrypting we recover %s\n", decoded);
     6a4:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
     6a8:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
}
     6ac:	69742f62 	ldmdbvs	r4!, {r1, r5, r6, r8, r9, sl, fp, sp}^
     6b0:	612d796e 			@ <UNDEFINED> instruction: 0x612d796e
     6b4:	2f007365 	svccs	0x00007365
     6b8:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
     6bc:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
     6c0:	63652f66 	cmnvs	r5, #408	@ 0x198
     6c4:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
     6c8:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
     6cc:	732f7265 			@ <UNDEFINED> instruction: 0x732f7265
int pair(int argc, char** argv) {
     6d0:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
    printf("Sending a pair request.\n");
     6d4:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
    printf2("FOB_MESG PAIR\n");
     6d8:	2f006c6c 	svccs	0x00006c6c
     6dc:	2f74706f 	svccs	0x0074706f
}
     6e0:	2d636367 	stclcs	3, cr6, [r3, #-412]!	@ 0xfffffe64
     6e4:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	@ 0xfffffe7c
     6e8:	656e6f6e 	strbvs	r6, [lr, #-3950]!	@ 0xfffff092
int encode64(int argc, char** argv) {
     6ec:	6261652d 	rsbvs	r6, r1, #188743680	@ 0xb400000
    if (argc > 1) {
     6f0:	696c2f69 	stmdbvs	ip!, {r0, r3, r5, r6, r8, r9, sl, fp, sp}^
     6f4:	63672f62 	cmnvs	r7, #392	@ 0x188
        len = strlen(argv[1]);
     6f8:	72612f63 	rsbvc	r2, r1, #396	@ 0x18c
     6fc:	6f6e2d6d 	svcvs	0x006e2d6d
        if (len < MAXARRAYLEN) {
     700:	652d656e 	strvs	r6, [sp, #-1390]!	@ 0xfffffa92
            len = encode_base64((uint8_t *) argv[1], len, encoded);
     704:	2f696261 	svccs	0x00696261
     708:	322e3231 	eorcc	r3, lr, #268435459	@ 0x10000003
            printf("Encoded %s as %s with %d characters\n", argv[1], encoded, len);
     70c:	692f312e 	stmdbvs	pc!, {r1, r2, r3, r5, r8, ip, sp}	@ <UNPREDICTABLE>
     710:	756c636e 	strbvc	r6, [ip, #-878]!	@ 0xfffffc92
     714:	2f006564 	svccs	0x00006564
            printf("String exceeds max length of %d characters", MAXARRAYLEN);
     718:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
     71c:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
     720:	63652f66 	cmnvs	r5, #408	@ 0x198
        printf("Usage is 'encode64 string'\n");
     724:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
}
     728:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
     72c:	732f7265 			@ <UNDEFINED> instruction: 0x732f7265
     730:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
     734:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
     738:	7361622f 	cmnvc	r1, #-268435454	@ 0xf0000002
int decode64(int argc, char** argv) {
     73c:	00343665 	eorseq	r3, r4, r5, ror #12
    if (argc > 1) {
     740:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 68c <aes_test+0x60>
     744:	63652f65 	cmnvs	r5, #404	@ 0x194
        int len = strlen(argv[1]);
     748:	652f6674 	strvs	r6, [pc, #-1652]!	@ dc <vector_table+0xdc>
     74c:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
        if (len < MAXBASE64LEN) {
     750:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
                len = decode_base64((uint8_t *) argv[1], len, plaintext);
     754:	2f72656e 	svccs	0x0072656e
     758:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
                plaintext[len] = '\0';
     75c:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
     760:	72702f62 	rsbsvc	r2, r0, #392	@ 0x188
     764:	66746e69 	ldrbtvs	r6, [r4], -r9, ror #28
                printf("Decoded %s as: %s\n", argv[1], plaintext);
     768:	65610000 	strbvs	r0, [r1, #-0]!
     76c:	65745f73 	ldrbvs	r5, [r4, #-3955]!	@ 0xfffff08d
     770:	632e7473 			@ <UNDEFINED> instruction: 0x632e7473
            printf("String exceeds max base64 string length of %d characters", MAXBASE64LEN);
     774:	00000100 	andeq	r0, r0, r0, lsl #2
     778:	2e736561 	cdpcs	5, 7, cr6, cr3, cr1, {3}
     77c:	00020068 	andeq	r0, r2, r8, rrx
        printf("Usage is 'decode64 string'\n");
     780:	65687300 	strbvs	r7, [r8, #-768]!	@ 0xfffffd00
}
     784:	682e6c6c 	stmdavs	lr!, {r2, r3, r5, r6, sl, fp, sp, lr}
     788:	00000300 	andeq	r0, r0, r0, lsl #6
     78c:	69647473 	stmdbvs	r4!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
     790:	672d746e 	strvs	r7, [sp, -lr, ror #8]!
     794:	682e6363 	stmdavs	lr!, {r0, r1, r5, r6, r8, r9, sp, lr}
int ecdh_test(int argc, char** argv) {
     798:	00000400 	andeq	r0, r0, r0, lsl #8
    uint8_t b64privkey2[32] = "wP/uwP/uwP/uwP/uwP/uwP/uwP/uwP/u";
     79c:	65736162 	ldrbvs	r6, [r3, #-354]!	@ 0xfffffe9e
     7a0:	682e3436 	stmdavs	lr!, {r1, r2, r4, r5, sl, ip, sp}
     7a4:	00000500 	andeq	r0, r0, r0, lsl #10
     7a8:	6e697270 	mcrvs	2, 3, r7, cr9, cr0, {3}
     7ac:	682e6674 	stmdavs	lr!, {r2, r4, r5, r6, r9, sl, sp, lr}
    printf("Testing the ecdh key exchange\n");
     7b0:	00000600 	andeq	r0, r0, r0, lsl #12
     7b4:	00250500 	eoreq	r0, r5, r0, lsl #10
    decode_base64(ECDH_privkey_b64, 32, ECDH_privkey);
     7b8:	062c0205 	strteq	r0, [ip], -r5, lsl #4
     7bc:	06180000 	ldreq	r0, [r8], -r0
     7c0:	06050501 	streq	r0, [r5], -r1, lsl #10
    decode_base64(b64privkey2, 32, privkey2);
     7c4:	060d0530 			@ <UNDEFINED> instruction: 0x060d0530
     7c8:	05054a01 	streq	r4, [r5, #-2561]	@ 0xfffff5ff
    ecdh_generate_keys(ECDH_pubkey, ECDH_privkey);
     7cc:	14135906 	ldrne	r5, [r3], #-2310	@ 0xfffff6fa
     7d0:	05135b4b 	ldreq	r5, [r3, #-2891]	@ 0xfffff4b5
     7d4:	0501060b 	streq	r0, [r1, #-1547]	@ 0xfffff9f5
    ecdh_generate_keys(pubkey2, privkey2);
     7d8:	05670605 	strbeq	r0, [r7, #-1541]!	@ 0xfffff9fb
     7dc:	05010612 	streq	r0, [r1, #-1554]	@ 0xfffff9ee
    ecdh_shared_secret(ECDH_privkey, pubkey2, ECDH_shared);
     7e0:	06670605 	strbteq	r0, [r7], -r5, lsl #12
     7e4:	4b2f062e 	blmi	bc20a4 <__ROM_SIZE__+0xb820a4>
     7e8:	0b05134c 	bleq	145520 <__ROM_SIZE__+0x105520>
    ecdh_shared_secret(privkey2, ECDH_pubkey, sharedsecret2);
     7ec:	05050106 	streq	r0, [r5, #-262]	@ 0xfffffefa
     7f0:	2e066706 	cdpcs	7, 0, cr6, cr6, cr6, {0}
    sha256_init(&shactx);
     7f4:	12052f06 	andne	r2, r5, #6, 30
     7f8:	054a0106 	strbeq	r0, [sl, #-262]	@ 0xfffffefa
	sha256_update(&shactx, ECDH_shared, ECC_PUB_KEY_SIZE);
     7fc:	4b300605 	blmi	c02018 <__ROM_SIZE__+0xbc2018>
     800:	13060105 	movwne	r0, #24837	@ 0x6105
	sha256_final(&shactx, ECDH_AESkey);
     804:	01001202 	tsteq	r0, r2, lsl #4
     808:	0000c601 	andeq	ip, r0, r1, lsl #12
     80c:	a2000300 	andge	r0, r0, #0, 6
    len = encode_base64(ECDH_AESkey, AES_KEYLEN, b64test);
     810:	02000000 	andeq	r0, r0, #0
     814:	0d0efb01 	vstreq	d15, [lr, #-4]
    b64test[len] = '\0';
     818:	01010100 	mrseq	r0, (UNDEF: 17)
     81c:	00000001 	andeq	r0, r0, r1
     820:	01000001 	tsteq	r0, r1
     824:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 770 <decode64+0x34>
    printf("First shared key is %s\n", b64test);
     828:	63652f65 	cmnvs	r5, #404	@ 0x194
     82c:	652f6674 	strvs	r6, [pc, #-1652]!	@ 1c0 <vector_table+0x1c0>
    sha256_init(&shactx);
     830:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
    sha256_update(&shactx, sharedsecret2, ECC_PUB_KEY_SIZE);
     834:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
     838:	2f72656e 	svccs	0x0072656e
     83c:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
	sha256_final(&shactx, keytest);
     840:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
     844:	6f682f00 	svcvs	0x00682f00
    len = encode_base64(keytest, AES_KEYLEN, b64test);
     848:	652f656d 	strvs	r6, [pc, #-1389]!	@ 2e3 <vector_table+0x2e3>
     84c:	2f667463 	svccs	0x00667463
    b64test[len] = '\0';
     850:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
     854:	6172742d 	cmnvs	r2, sp, lsr #8
     858:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
    printf("Should be same as %s\n", b64test);
     85c:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
     860:	732f6c6c 			@ <UNDEFINED> instruction: 0x732f6c6c
    printf("Switching fob AES key to new value. Try AES tests now.\n");
     864:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
     868:	6f682f00 	svcvs	0x00682f00
    AES_init_ctx(&ctx, ECDH_AESkey);
     86c:	652f656d 	strvs	r6, [pc, #-1389]!	@ 307 <vector_table+0x307>
     870:	2f667463 	svccs	0x00667463
}
     874:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
     878:	6172742d 	cmnvs	r2, sp, lsr #8
     87c:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
     880:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
     884:	6c2f6c6c 	stcvs	12, cr6, [pc], #-432	@ 6dc <pair+0xc>
     888:	702f6269 	eorvc	r6, pc, r9, ror #4
     88c:	746e6972 	strbtvc	r6, [lr], #-2418	@ 0xfffff68e
     890:	70000066 	andvc	r0, r0, r6, rrx
     894:	2e726961 	vsubcs.f16	s13, s4, s3	@ <UNPREDICTABLE>
     898:	00010063 	andeq	r0, r1, r3, rrx
     89c:	65687300 	strbvs	r7, [r8, #-768]!	@ 0xfffffd00
     8a0:	682e6c6c 	stmdavs	lr!, {r2, r3, r5, r6, sl, fp, sp, lr}
int send_ping(int argc, char** argv) {
     8a4:	00000200 	andeq	r0, r0, r0, lsl #4
    printf("Pinging the car.\n");
     8a8:	6e697270 	mcrvs	2, 3, r7, cr9, cr0, {3}
    printf2("FOB_MESG PING\n");
     8ac:	682e6674 	stmdavs	lr!, {r2, r4, r5, r6, r9, sl, sp, lr}
     8b0:	00000300 	andeq	r0, r0, r0, lsl #6
}
     8b4:	00210500 	eoreq	r0, r1, r0, lsl #10
     8b8:	06d00205 	ldrbeq	r0, [r0], r5, lsl #4
     8bc:	06160000 	ldreq	r0, [r6], -r0
int sha256_test(int argc, char** argv) {
     8c0:	06050501 	streq	r0, [r5], -r1, lsl #10
    printf("Starting sha256 test\n");
     8c4:	06200621 	strteq	r0, [r0], -r1, lsr #12
     8c8:	01053d2f 	tsteq	r5, pc, lsr #26
    BYTE text1[] = {"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"};
     8cc:	07021306 	streq	r1, [r2, -r6, lsl #6]
     8d0:	10010100 	andne	r0, r1, r0, lsl #2
     8d4:	03000002 	movweq	r0, #2
     8d8:	00016600 	andeq	r6, r1, r0, lsl #12
     8dc:	fb010200 	blx	410e6 <__ROM_SIZE__+0x10e6>
     8e0:	01000d0e 	tsteq	r0, lr, lsl #26
     8e4:	00010101 	andeq	r0, r1, r1, lsl #2
     8e8:	00010000 	andeq	r0, r1, r0
     8ec:	682f0100 	stmdavs	pc!, {r8}	@ <UNPREDICTABLE>
    BYTE hash1[SHA256_BLOCK_SIZE] = {0x24,0x8d,0x6a,0x61,0xd2,0x06,0x38,0xb8,0xe5,0xc0,0x26,0x93,0x0c,0x3e,0x60,0x39,
     8f0:	2f656d6f 	svccs	0x00656d6f
     8f4:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
     8f8:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
     8fc:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
    sha256_init(&shactx);
     900:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
	sha256_update(&shactx, text1, strlen((char *)text1));
     904:	63652f72 	cmnvs	r5, #456	@ 0x1c8
     908:	662f6674 			@ <UNDEFINED> instruction: 0x662f6674
     90c:	2f00626f 	svccs	0x0000626f
     910:	2f74706f 	svccs	0x0074706f
	sha256_final(&shactx, buf);
     914:	2d636367 	stclcs	3, cr6, [r3, #-412]!	@ 0xfffffe64
     918:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	@ 0xfffffe7c
    len = encode_base64(hash1, SHA256_BLOCK_SIZE, b64_hash1);
     91c:	656e6f6e 	strbvs	r6, [lr, #-3950]!	@ 0xfffff092
     920:	6261652d 	rsbvs	r6, r1, #188743680	@ 0xb400000
     924:	696c2f69 	stmdbvs	ip!, {r0, r3, r5, r6, r8, r9, sl, fp, sp}^
    b64_hash1[len] = '\0';
     928:	63672f62 	cmnvs	r7, #392	@ 0x188
    len = encode_base64(buf, SHA256_BLOCK_SIZE, b64_buf);
     92c:	72612f63 	rsbvc	r2, r1, #396	@ 0x18c
     930:	6f6e2d6d 	svcvs	0x006e2d6d
     934:	652d656e 	strvs	r6, [sp, #-1390]!	@ 0xfffffa92
    b64_buf[len] = '\0';
     938:	2f696261 	svccs	0x00696261
    printf("Base64 of SHA-256 test is %s\n", b64_buf);
     93c:	322e3231 	eorcc	r3, lr, #268435459	@ 0x10000003
     940:	692f312e 	stmdbvs	pc!, {r1, r2, r3, r5, r8, ip, sp}	@ <UNPREDICTABLE>
    printf("Should be %s\n", b64_hash1);
     944:	756c636e 	strbvc	r6, [ip, #-878]!	@ 0xfffffc92
     948:	2f006564 	svccs	0x00006564
}
     94c:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
     950:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
     954:	63652f66 	cmnvs	r5, #408	@ 0x198
     958:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
     95c:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
     960:	732f7265 			@ <UNDEFINED> instruction: 0x732f7265
void __attribute__((optimize("O0"), weak)) initial_setup(void) {
     964:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
     968:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
  char *src = &_etext, *dst = &_data;
     96c:	2f006c6c 	svccs	0x00006c6c
     970:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
  if (dst != src)
     974:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
     978:	63652f66 	cmnvs	r5, #408	@ 0x198
    while (dst < &_edata) *(dst++) = *(src++);
     97c:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
     980:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
     984:	732f7265 			@ <UNDEFINED> instruction: 0x732f7265
     988:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
     98c:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
     990:	7361622f 	cmnvc	r1, #-268435454	@ 0xf0000002
  for (dst = &_bss; dst < &_ebss; dst++) *dst = 0;
     994:	00343665 	eorseq	r3, r4, r5, ror #12
     998:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 8e4 <sha256_test+0x24>
     99c:	63652f65 	cmnvs	r5, #404	@ 0x194
     9a0:	652f6674 	strvs	r6, [pc, #-1652]!	@ 334 <vector_table+0x334>
     9a4:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
     9a8:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
     9ac:	2f72656e 	svccs	0x0072656e
  platform_init();
     9b0:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
}
     9b4:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
     9b8:	72702f62 	rsbsvc	r2, r0, #392	@ 0x188
     9bc:	66746e69 	ldrbtvs	r6, [r4], -r9, ror #28
     9c0:	6f682f00 	svcvs	0x00682f00
     9c4:	652f656d 	strvs	r6, [pc, #-1389]!	@ 45f <car_mesg+0x9f>
     9c8:	2f667463 	svccs	0x00667463
     9cc:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
static void delete(void) {
     9d0:	6172742d 	cmnvs	r2, sp, lsr #8
  __write_char__(BACK_SPACE);
     9d4:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
     9d8:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
  __write_char__(SPACE);
     9dc:	6c2f6c6c 	stcvs	12, cr6, [pc], #-432	@ 834 <ecdh_test+0x9c>
  __write_char__(BACK_SPACE);
     9e0:	732f6269 			@ <UNDEFINED> instruction: 0x732f6269
     9e4:	6e697274 	mcrvs	2, 3, r7, cr9, cr4, {3}
}
     9e8:	62000067 	andvs	r0, r0, #103	@ 0x67
static void clear_prompt(int char_count) {
     9ec:	36657361 	strbtcc	r7, [r5], -r1, ror #6
  while (char_count) {
     9f0:	00632e34 	rsbeq	r2, r3, r4, lsr lr
    delete ();
     9f4:	73000001 	movwvc	r0, #1
  while (char_count) {
     9f8:	6e696474 	mcrvs	4, 3, r6, cr9, cr4, {3}
}
     9fc:	63672d74 	cmnvs	r7, #116, 26	@ 0x1d00
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
     a00:	00682e63 	rsbeq	r2, r8, r3, ror #28
    auto_load[i].command(0, NULL);
     a04:	73000002 	movwvc	r0, #2
     a08:	65646474 	strbvs	r6, [r4, #-1140]!	@ 0xfffffb8c
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
     a0c:	00682e66 	rsbeq	r2, r8, r6, ror #28
     a10:	73000002 	movwvc	r0, #2
     a14:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
     a18:	0300682e 	movweq	r6, #2094	@ 0x82e
     a1c:	61620000 	cmnvs	r2, r0
}
     a20:	34366573 	ldrtcc	r6, [r6], #-1395	@ 0xfffffa8d
static int show_history(int argc, char **argv) {
     a24:	0400682e 	streq	r6, [r0], #-2094	@ 0xfffff7d2
  uint32_t end_index = total_num_commands-1;
     a28:	72700000 	rsbsvc	r0, r0, #0
  if (total_num_commands > NUM_HISTORY_ENTRIES) {
     a2c:	66746e69 	ldrbtvs	r6, [r4], -r9, ror #28
     a30:	0500682e 	streq	r6, [r0, #-2094]	@ 0xfffff7d2
    beg_index = total_num_commands - NUM_HISTORY_ENTRIES;
     a34:	74730000 	ldrbtvc	r0, [r3], #-0
     a38:	676e6972 			@ <UNDEFINED> instruction: 0x676e6972
  uint32_t beg_index = 0;
     a3c:	0600682e 	streq	r6, [r0], -lr, lsr #16
    printf("%s\n", cmd_history[index % NUM_HISTORY_ENTRIES]);
     a40:	05000000 	streq	r0, [r0, #-0]
     a44:	02050025 	andeq	r0, r5, #37	@ 0x25
     a48:	000006ec 	andeq	r0, r0, ip, ror #13
     a4c:	0501061a 	streq	r0, [r1, #-1562]	@ 0xfffff9e6
  for (uint32_t index = beg_index; index <= end_index; ++index) {
     a50:	05300605 	ldreq	r0, [r0, #-1541]!	@ 0xfffff9fb
}
     a54:	05010608 	streq	r0, [r1, #-1544]	@ 0xfffff9f8
     a58:	133e0609 	teqne	lr, #9437184	@ 0x900000
     a5c:	060f0514 			@ <UNDEFINED> instruction: 0x060f0514
     a60:	052e2001 	streq	r2, [lr, #-1]!
int cmd_exec_status(int argc, char **argv) {
     a64:	05210609 	streq	r0, [r1, #-1545]!	@ 0xfffff9f7
  printf("%d\n", __cmd_exec_status);
     a68:	0501060c 	streq	r0, [r1, #-1548]	@ 0xfffff9f4
     a6c:	052f060d 	streq	r0, [pc, #-1549]!	@ 467 <car_mesg+0xa7>
     a70:	2e010613 	mcrcs	6, 0, r0, cr1, cr3, {0}
}
     a74:	060d052e 	streq	r0, [sp], -lr, lsr #10
     a78:	2e3c0621 	cfmsuba32cs	mvax1, mvax0, mvfx12, mvfx1
     a7c:	2e062306 	cdpcs	3, 0, cr2, cr6, cr6, {0}
static int build_info(int argc, char **argv) {
     a80:	0609053c 			@ <UNDEFINED> instruction: 0x0609053c
  printf("Build: [" SHELL_VERSION ":" USER_REPO_VERSION "] - [" BUILD_USER
     a84:	05200616 	streq	r0, [r0, #-1558]!	@ 0xfffff9ea
}
     a88:	05310605 	ldreq	r0, [r1, #-1541]!	@ 0xfffff9fb
     a8c:	05130601 	ldreq	r0, [r3, #-1537]	@ 0xfffff9ff
static void execute(int argc, char **argv) {
     a90:	05000625 	streq	r0, [r0, #-1573]	@ 0xfffff9db
     a94:	00073c02 	andeq	r3, r7, r2, lsl #24
  for (int i = 0; table[i].command_name != NULL; i++) {
     a98:	01061400 	tsteq	r6, r0, lsl #8
     a9c:	30060505 	andcc	r0, r6, r5, lsl #10
     aa0:	01060805 	tsteq	r6, r5, lsl #16
     aa4:	3e060905 	vmlacc.f16	s0, s12, s10	@ <UNPREDICTABLE>
     aa8:	01061305 	tsteq	r6, r5, lsl #6
    if (strcmp(argv[0], table[i].command_name) == 0) {
     aac:	09052e20 	stmdbeq	r5, {r5, r9, sl, fp, sp}
     ab0:	0c052206 	sfmeq	f2, 4, [r5], {6}
      __cmd_exec_status = table[i].command(argc, &argv[0]);
     ab4:	11050106 	tstne	r5, r6, lsl #2
     ab8:	05133006 	ldreq	r3, [r3, #-6]
     abc:	2e010617 	mcrcs	6, 0, r0, cr1, cr7, {0}
     ac0:	2f061105 	svccs	0x00061105
     ac4:	01062005 	tsteq	r6, r5
    printf("\"%s\": command not found. Use \"help\" to list all command.\n",
     ac8:	1105204a 	tstne	r5, sl, asr #32
     acc:	0d052f06 	stceq	15, cr2, [r5, #-24]	@ 0xffffffe8
    __cmd_exec_status = -1;
     ad0:	3c2e0669 	stccc	6, cr0, [lr], #-420	@ 0xfffffe5c
     ad4:	16060905 	strne	r0, [r6], -r5, lsl #18
     ad8:	05052006 	streq	r2, [r5, #-6]
}
     adc:	01053106 	tsteq	r5, r6, lsl #2
     ae0:	0a021306 	beq	85700 <__ROM_SIZE__+0x45700>
     ae4:	3f010100 	svccc	0x00010100
     ae8:	03000002 	movweq	r0, #2
int help(int argc, char **argv) {
     aec:	0001d300 	andeq	sp, r1, r0, lsl #6
  if (argc > 1 && (strcmp(argv[1], "-l")==0)) {
     af0:	fb010200 	blx	412fa <__ROM_SIZE__+0x12fa>
     af4:	01000d0e 	tsteq	r0, lr, lsl #26
     af8:	00010101 	andeq	r0, r1, r1, lsl #2
     afc:	00010000 	andeq	r0, r1, r0
    printf("use: help -l for list only.\n\n");
     b00:	682f0100 	stmdavs	pc!, {r8}	@ <UNPREDICTABLE>
  bool verbose = true;
     b04:	2f656d6f 	svccs	0x00656d6f
    verbose = false;
     b08:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    printf("\n");
     b0c:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
    i++;
     b10:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
  while (table[i].command_name != NULL) {
     b14:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
     b18:	63652f72 	cmnvs	r5, #456	@ 0x1c8
     b1c:	662f6674 			@ <UNDEFINED> instruction: 0x662f6674
    printf(table[i].command_name);
     b20:	2f00626f 	svccs	0x0000626f
    if (verbose) {
     b24:	2f74706f 	svccs	0x0074706f
      printf("\n\t");
     b28:	2d636367 	stclcs	3, cr6, [r3, #-412]!	@ 0xfffffe64
      printf(table[i].command_help);
     b2c:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	@ 0xfffffe7c
     b30:	656e6f6e 	strbvs	r6, [lr, #-3950]!	@ 0xfffff092
     b34:	6261652d 	rsbvs	r6, r1, #188743680	@ 0xb400000
    verbose = false;
     b38:	696c2f69 	stmdbvs	ip!, {r0, r3, r5, r6, r8, r9, sl, fp, sp}^
}
     b3c:	63672f62 	cmnvs	r7, #392	@ 0x188
     b40:	72612f63 	rsbvc	r2, r1, #396	@ 0x18c
     b44:	6f6e2d6d 	svcvs	0x006e2d6d
     b48:	652d656e 	strvs	r6, [sp, #-1390]!	@ 0xfffffa92
     b4c:	2f696261 	svccs	0x00696261
     b50:	322e3231 	eorcc	r3, lr, #268435459	@ 0x10000003
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
     b54:	692f312e 	stmdbvs	pc!, {r1, r2, r3, r5, r8, ip, sp}	@ <UNPREDICTABLE>
static void add_command_to_history(const char *cmd_str) {
     b58:	756c636e 	strbvc	r6, [ip, #-878]!	@ 0xfffffc92
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
     b5c:	2f006564 	svccs	0x00006564
     b60:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
  int index = total_num_commands % NUM_HISTORY_ENTRIES;
     b64:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
     b68:	63652f66 	cmnvs	r5, #408	@ 0x198
     b6c:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
     b70:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
  memcpy(&cmd_history[index], cmd_str, LINE_BUFF_SIZE);
     b74:	732f7265 			@ <UNDEFINED> instruction: 0x732f7265
     b78:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
     b7c:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
     b80:	6168732f 	cmnvs	r8, pc, lsr #6
  total_num_commands++;
     b84:	00363532 	eorseq	r3, r6, r2, lsr r5
  curr_command_ptr = total_num_commands;
     b88:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ ad4 <execute+0x44>
     b8c:	63652f65 	cmnvs	r5, #404	@ 0x194
     b90:	652f6674 	strvs	r6, [pc, #-1652]!	@ 524 <uart_init+0xc>
     b94:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
     b98:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
static int parse_line(char **argv, char *line_buff, int argument_size) {
     b9c:	2f72656e 	svccs	0x0072656e
     ba0:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
  int length = strlen(line_buff);
     ba4:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
     ba8:	69742f62 	ldmdbvs	r4!, {r1, r5, r6, r8, r9, sl, fp, sp}^
  int argc = 0;
     bac:	612d796e 			@ <UNDEFINED> instruction: 0x612d796e
         pos++)
     bb0:	2f007365 	svccs	0x00007365
    for (; line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
     bb4:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
     bb8:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
     bbc:	63652f66 	cmnvs	r5, #408	@ 0x198
     bc0:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
    if (line_buff[pos] == '\t' || line_buff[pos] == SPACE)
     bc4:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
     bc8:	732f7265 			@ <UNDEFINED> instruction: 0x732f7265
      line_buff[pos] = END_OF_LINE;
     bcc:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
  while (pos <= length) {
     bd0:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
    if (line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
     bd4:	2f006c6c 	svccs	0x00006c6c
     bd8:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
     bdc:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
     be0:	63652f66 	cmnvs	r5, #408	@ 0x198
      argv[argc++] = &line_buff[pos];
     be4:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
     be8:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
}
     bec:	732f7265 			@ <UNDEFINED> instruction: 0x732f7265
static int prefix_match(char *sub, int len, const char *str) {
     bf0:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
     bf4:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
  if (sub == NULL || str == NULL || len <= 0 || len > strlen(str)) {
     bf8:	7361622f 	cmnvc	r1, #-268435454	@ 0xf0000002
     bfc:	00343665 	eorseq	r3, r4, r5, ror #12
     c00:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ b4c <help+0x60>
     c04:	63652f65 	cmnvs	r5, #404	@ 0x194
  for (int i = 0; i<len; ++i) {
     c08:	652f6674 	strvs	r6, [pc, #-1652]!	@ 59c <uart2_init+0x20>
     c0c:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
    if (sub[i] != str[i]) {
     c10:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
     c14:	2f72656e 	svccs	0x0072656e
  for (int i = 0; i<len; ++i) {
     c18:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
}
     c1c:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
  return TRUE;
     c20:	69742f62 	ldmdbvs	r4!, {r1, r5, r6, r8, r9, sl, fp, sp}^
      return FALSE;
     c24:	652d796e 	strvs	r7, [sp, #-2414]!	@ 0xfffff692
}
     c28:	00686463 	rsbeq	r6, r8, r3, ror #8
static void handle_up_arrow(char *cmd_buff, int *char_count) {
     c2c:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ b78 <add_command_to_history+0x24>
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
     c30:	63652f65 	cmnvs	r5, #404	@ 0x194
     c34:	652f6674 	strvs	r6, [pc, #-1652]!	@ 5c8 <pin_setup+0x28>
     c38:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
     c3c:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
      curr_command_ptr == 0) {
     c40:	2f72656e 	svccs	0x0072656e
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
     c44:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
    printf("%s", cmd_buff);
     c48:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
     c4c:	72702f62 	rsbsvc	r2, r0, #392	@ 0x188
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
     c50:	66746e69 	ldrbtvs	r6, [r4], -r9, ror #28
     c54:	63650000 	cmnvs	r5, #0
  curr_command_ptr--;
     c58:	745f6864 	ldrbvc	r6, [pc], #-2148	@ c60 <handle_up_arrow+0x36>
     c5c:	2e747365 	cdpcs	3, 7, cr7, cr4, cr5, {3}
     c60:	00010063 	andeq	r0, r1, r3, rrx
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
     c64:	64747300 	ldrbtvs	r7, [r4], #-768	@ 0xfffffd00
     c68:	2d746e69 	ldclcs	14, cr6, [r4, #-420]!	@ 0xfffffe5c
     c6c:	2e636367 	cdpcs	3, 6, cr6, cr3, cr7, {3}
     c70:	00020068 	andeq	r0, r2, r8, rrx
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
     c74:	64747300 	ldrbtvs	r7, [r4], #-768	@ 0xfffffd00
     c78:	2e666564 	cdpcs	5, 6, cr6, cr6, cr4, {3}
     c7c:	00020068 	andeq	r0, r2, r8, rrx
  *char_count = strlen(cmd_buff);
     c80:	61687300 	cmnvs	r8, r0, lsl #6
     c84:	2e363532 	mrccs	5, 1, r3, cr6, cr2, {1}
  printf("%s", cmd_buff);
     c88:	00030068 	andeq	r0, r3, r8, rrx
     c8c:	73656100 	cmnvc	r5, #0, 2
     c90:	0400682e 	streq	r6, [r0], #-2094	@ 0xfffff7d2
     c94:	68730000 	ldmdavs	r3!, {}^	@ <UNPREDICTABLE>
     c98:	2e6c6c65 	cdpcs	12, 6, cr6, cr12, cr5, {3}
static void handle_down_arrow(char *cmd_buff, int *char_count) {
     c9c:	00050068 	andeq	r0, r5, r8, rrx
     ca0:	73616200 	cmnvc	r1, #0, 4
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
     ca4:	2e343665 	cfmsuba32cs	mvax3, mvax3, mvfx4, mvfx5
     ca8:	00060068 	andeq	r0, r6, r8, rrx
  *char_count = 0;
     cac:	64636500 	strbtvs	r6, [r3], #-1280	@ 0xfffffb00
  if (curr_command_ptr == total_num_commands) return;
     cb0:	00682e68 	rsbeq	r2, r8, r8, ror #28
     cb4:	70000007 	andvc	r0, r0, r7
     cb8:	746e6972 	strbtvc	r6, [lr], #-2418	@ 0xfffff68e
  curr_command_ptr++;
     cbc:	00682e66 	rsbeq	r2, r8, r6, ror #28
     cc0:	00000008 	andeq	r0, r0, r8
     cc4:	05002605 	streq	r2, [r0, #-1541]	@ 0xfffff9fb
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
     cc8:	00079802 	andeq	r9, r7, r2, lsl #16
     ccc:	010b0300 	mrseq	r0, (UNDEF: 59)
     cd0:	05050106 	streq	r0, [r5, #-262]	@ 0xfffffefa
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
     cd4:	0d053006 	stceq	0, cr3, [r5, #-24]	@ 0xffffffe8
     cd8:	054a0106 	strbeq	r0, [sl, #-262]	@ 0xfffffefa
     cdc:	13670605 	cmnne	r7, #5242880	@ 0x500000
     ce0:	13131313 	tstne	r3, #1275068416	@ 0x4c000000
  *char_count = strlen(cmd_buff);
     ce4:	5a673e14 	bpl	19d053c <__ROM_SIZE__+0x199053c>
     ce8:	5a674c59 	bpl	19d3e54 <__ROM_SIZE__+0x1993e54>
  printf("%s", cmd_buff);
     cec:	3d020513 	cfstr32cc	mvfx0, [r2, #-76]	@ 0xffffffb4
     cf0:	5a050559 	bpl	14225c <__ROM_SIZE__+0x10225c>
}
     cf4:	01060b05 	tsteq	r6, r5, lsl #22
     cf8:	59060505 	stmdbpl	r6, {r0, r2, r8, sl}
void set_read_char(int (*func)(void)) { __read_char__ = func; }
     cfc:	01061205 	tsteq	r6, r5, lsl #4
     d00:	0605054a 	streq	r0, [r5], -sl, asr #10
     d04:	053d4c3e 	ldreq	r4, [sp, #-3134]!	@ 0xfffff3c2
void set_read_char2(int (*func)(void)) { __read_char2__ = func; }
     d08:	05055902 	streq	r5, [r5, #-2306]	@ 0xfffff6fe
     d0c:	060b054c 	streq	r0, [fp], -ip, asr #10
     d10:	06050501 	streq	r0, [r5], -r1, lsl #10
void set_write_char(void (*func)(char)) { __write_char__ = func; }
     d14:	06120559 			@ <UNDEFINED> instruction: 0x06120559
     d18:	05054a01 	streq	r4, [r5, #-2561]	@ 0xfffff5ff
     d1c:	3e4c2f06 	cdpcc	15, 4, cr2, cr12, cr6, {0}
void set_write_char2(void (*func)(char)) { __write_char2__ = func; }
     d20:	0601054c 	streq	r0, [r1], -ip, asr #10
     d24:	00190213 	andseq	r0, r9, r3, lsl r2
     d28:	00c60101 	sbceq	r0, r6, r1, lsl #2
}
     d2c:	00030000 	andeq	r0, r3, r0
}
     d30:	000000a2 	andeq	r0, r0, r2, lsr #1
  if (cmd_buff == NULL || char_count <= 0) {
     d34:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
static void handle_tab(char *cmd_buff, int *char_count) {
     d38:	0101000d 	tsteq	r1, sp
     d3c:	00000101 	andeq	r0, r0, r1, lsl #2
  int last_match = -1;
     d40:	00000100 	andeq	r0, r0, r0, lsl #2
  int match_count = 0;
     d44:	6f682f01 	svcvs	0x00682f01
  int i = 0;
     d48:	652f656d 	strvs	r6, [pc, #-1389]!	@ 7e3 <ecdh_test+0x4b>
    i++;
     d4c:	2f667463 	svccs	0x00667463
  while (table[i].command_name != NULL) { //loop over all commands
     d50:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
     d54:	6172742d 	cmnvs	r2, sp, lsr #8
     d58:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
    if (prefix_match(cmd_buff, *char_count, table[i].command_name)) {
     d5c:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
     d60:	6f662f66 	svcvs	0x00662f66
     d64:	682f0062 	stmdavs	pc!, {r1, r5, r6}	@ <UNPREDICTABLE>
      match_count++;
     d68:	2f656d6f 	svccs	0x00656d6f
      printf("\n%s", table[i].command_name);
     d6c:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
     d70:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
      last_match = i;
     d74:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
  if (match_count == 1) {
     d78:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
     d7c:	68732f72 	ldmdavs	r3!, {r1, r4, r5, r6, r8, r9, sl, fp, sp}^
  if (match_count) {
     d80:	2f6c6c65 	svccs	0x006c6c65
}
     d84:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
    memcpy(cmd_buff, table[last_match].command_name, LINE_BUFF_SIZE);
     d88:	682f006c 	stmdavs	pc!, {r2, r3, r5, r6}	@ <UNPREDICTABLE>
     d8c:	2f656d6f 	svccs	0x00656d6f
     d90:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
     d94:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
    *char_count = strlen(cmd_buff);
     d98:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
     d9c:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
     da0:	68732f72 	ldmdavs	r3!, {r1, r4, r5, r6, r8, r9, sl, fp, sp}^
    printf("\n");
     da4:	2f6c6c65 	svccs	0x006c6c65
     da8:	2f62696c 	svccs	0x0062696c
    prepend_prompt();
     dac:	6e697270 	mcrvs	2, 3, r7, cr9, cr0, {3}
    printf(PROMPT);
     db0:	00006674 	andeq	r6, r0, r4, ror r6
     db4:	676e6970 			@ <UNDEFINED> instruction: 0x676e6970
    printf("%s", cmd_buff);
     db8:	0100632e 	tsteq	r0, lr, lsr #6
     dbc:	68730000 	ldmdavs	r3!, {}^	@ <UNPREDICTABLE>
     dc0:	2e6c6c65 	cdpcs	12, 6, cr6, cr12, cr5, {3}
     dc4:	00020068 	andeq	r0, r2, r8, rrx
     dc8:	69727000 	ldmdbvs	r2!, {ip, sp, lr}^
     dcc:	2e66746e 	cdpcs	4, 6, cr7, cr6, cr14, {3}
     dd0:	00030068 	andeq	r0, r3, r8, rrx
__attribute__((weak)) int active_prompt() { return TRUE; }
     dd4:	26050000 	strcs	r0, [r5], -r0
static void shell(void) {
     dd8:	a4020500 	strge	r0, [r2], #-1280	@ 0xfffffb00
  int count = 0;
     ddc:	16000008 	strne	r0, [r0], -r8
  for (int i = 0; i < LINE_BUFF_SIZE; i++) line_buff[i] = 0;
     de0:	05050106 	streq	r0, [r5, #-262]	@ 0xfffffefa
     de4:	20062106 	andcs	r2, r6, r6, lsl #2
     de8:	053d2f06 	ldreq	r2, [sp, #-3846]!	@ 0xfffff0fa
     dec:	02130601 	andseq	r0, r3, #1048576	@ 0x100000
     df0:	01010007 	tsteq	r1, r7
  for (int i = 0; i < MAX_ARG_COUNT; i++) argv[i] = NULL;
     df4:	00000206 	andeq	r0, r0, r6, lsl #4
     df8:	01a00003 	moveq	r0, r3
     dfc:	01020000 	mrseq	r0, (UNDEF: 2)
     e00:	000d0efb 	strdeq	r0, [sp], -fp
     e04:	01010101 	tsteq	r1, r1, lsl #2
  prepend_prompt();
     e08:	01000000 	mrseq	r0, (UNDEF: 0)
  printf(PROMPT);
     e0c:	2f010000 	svccs	0x00010000
  int special_key = 0;
     e10:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
        special_key = 1;
     e14:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
    if (s == -1) { s = __read_char2__();}
     e18:	63652f66 	cmnvs	r5, #408	@ 0x198
     e1c:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
    if (s != -1) {
     e20:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
     e24:	652f7265 	strvs	r7, [pc, #-613]!	@ bc7 <parse_line+0x2b>
      loop();
     e28:	2f667463 	svccs	0x00667463
        line_buff[count] = END_OF_LINE;
     e2c:	00626f66 	rsbeq	r6, r2, r6, ror #30
     e30:	74706f2f 	ldrbtvc	r6, [r0], #-3887	@ 0xfffff0d1
     e34:	6363672f 	cmnvs	r3, #12320768	@ 0xbc0000
     e38:	6d72612d 	ldfvse	f6, [r2, #-180]!	@ 0xffffff4c
        __write_char__(NEW_LINE);
     e3c:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
     e40:	61652d65 	cmnvs	r5, r5, ror #26
  add_command_to_history(line_buff);
     e44:	6c2f6962 			@ <UNDEFINED> instruction: 0x6c2f6962
  argc = parse_line(argv, line_buff, MAX_ARG_COUNT);
     e48:	672f6269 	strvs	r6, [pc, -r9, ror #4]!
     e4c:	612f6363 			@ <UNDEFINED> instruction: 0x612f6363
     e50:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
  if (argc > 0) execute(argc, argv);
     e54:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	@ 0xfffffe44
}
     e58:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
        if (!__echo) {
     e5c:	2e32312f 	rsfcssp	f3, f2, #10.0
     e60:	2f312e32 	svccs	0x00312e32
        if (count == 0) continue;
     e64:	6c636e69 	stclvs	14, cr6, [r3], #-420	@ 0xfffffe5c
        count--;
     e68:	00656475 	rsbeq	r6, r5, r5, ror r4
        line_buff[count] = END_OF_LINE;
     e6c:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ db8 <handle_tab+0x86>
     e70:	63652f65 	cmnvs	r5, #404	@ 0x194
     e74:	652f6674 	strvs	r6, [pc, #-1652]!	@ 808 <ecdh_test+0x70>
        delete ();
     e78:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
      if (__echo) {
     e7c:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
        __write_char__(c);
     e80:	2f72656e 	svccs	0x0072656e
     e84:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
    if (!active_prompt()) {
     e88:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
     e8c:	68732f62 	ldmdavs	r3!, {r1, r5, r6, r8, r9, sl, fp, sp}^
    s = __read_char__();
     e90:	36353261 	ldrtcc	r3, [r5], -r1, ror #4
     e94:	6f682f00 	svcvs	0x00682f00
    if (s == -1) { s = __read_char2__();}
     e98:	652f656d 	strvs	r6, [pc, #-1389]!	@ 933 <sha256_test+0x73>
     e9c:	2f667463 	svccs	0x00667463
      if (c == CARRIAGE_RETURN || c == NEW_LINE) {
     ea0:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
     ea4:	6172742d 	cmnvs	r2, sp, lsr #8
      if (c == DELETE || c == BACK_SPACE) {
     ea8:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
     eac:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
      } else if (c == ESCAPE) {
     eb0:	732f6c6c 			@ <UNDEFINED> instruction: 0x732f6c6c
      } else if (c == SQUARE_BRACKET_OPEN && special_key == 1) {
     eb4:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
      } else if ((c == 'C' || c == 'D') && special_key != 0) {
     eb8:	6f682f00 	svcvs	0x00682f00
     ebc:	652f656d 	strvs	r6, [pc, #-1389]!	@ 957 <sha256_test+0x97>
     ec0:	2f667463 	svccs	0x00667463
      } else if ((c == 'A' || c == 'B') && special_key == 2) {
     ec4:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
     ec8:	6172742d 	cmnvs	r2, sp, lsr #8
      else if (c == TAB) {
     ecc:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
        line_buff[count] = c;
     ed0:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
     ed4:	6c2f6c6c 	stcvs	12, cr6, [pc], #-432	@ d2c <setup>
     ed8:	622f6269 	eorvs	r6, pc, #-1879048186	@ 0x90000006
        count++;
     edc:	36657361 	strbtcc	r7, [r5], -r1, ror #6
     ee0:	682f0034 	stmdavs	pc!, {r2, r4, r5}	@ <UNPREDICTABLE>
          delete ();
     ee4:	2f656d6f 	svccs	0x00656d6f
          delete ();
     ee8:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
      } else if (c == SQUARE_BRACKET_OPEN && special_key == 1) {
     eec:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
        special_key = 2;
     ef0:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
      } else if ((c == 'C' || c == 'D') && special_key != 0) {
     ef4:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
        special_key = 0;
     ef8:	68732f72 	ldmdavs	r3!, {r1, r4, r5, r6, r8, r9, sl, fp, sp}^
      } else if ((c == 'A' || c == 'B') && special_key == 2) {
     efc:	2f6c6c65 	svccs	0x006c6c65
        if (!__echo) {
     f00:	2f62696c 	svccs	0x0062696c
     f04:	69727473 	ldmdbvs	r2!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
          clear_prompt(count + 4);
     f08:	2f00676e 	svccs	0x0000676e
     f0c:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
        if (c == 'A') {
     f10:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
          handle_down_arrow(line_buff, &count);
     f14:	63652f66 	cmnvs	r5, #408	@ 0x198
     f18:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
        continue;
     f1c:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
          clear_prompt(count);
     f20:	732f7265 			@ <UNDEFINED> instruction: 0x732f7265
     f24:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
          handle_up_arrow(line_buff, &count);
     f28:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
     f2c:	6972702f 	ldmdbvs	r2!, {r0, r1, r2, r3, r5, ip, sp, lr}^
        handle_tab(line_buff, &count);
     f30:	0066746e 	rsbeq	r7, r6, lr, ror #8
     f34:	61687300 	cmnvs	r8, r0, lsl #6
        continue;
     f38:	5f363532 	svcpl	0x00363532
  if (argc > 0) execute(argc, argv);
     f3c:	74736574 	ldrbtvc	r6, [r3], #-1396	@ 0xfffffa8c
}
     f40:	0100632e 	tsteq	r0, lr, lsr #6
     f44:	74730000 	ldrbtvc	r0, [r3], #-0
     f48:	746e6964 	strbtvc	r6, [lr], #-2404	@ 0xfffff69c
     f4c:	6363672d 	cmnvs	r3, #11796480	@ 0xb40000
void prompt() {
     f50:	0200682e 	andeq	r6, r0, #3014656	@ 0x2e0000
  initial_setup();
     f54:	74730000 	ldrbtvc	r0, [r3], #-0
  exec_auto_cmds();
     f58:	66656464 	strbtvs	r6, [r5], -r4, ror #8
  setup();
     f5c:	0200682e 	andeq	r6, r0, #3014656	@ 0x2e0000
  decode_base64(AES_key_b64, 44, AES_key);
     f60:	68730000 	ldmdavs	r3!, {}^	@ <UNPREDICTABLE>
     f64:	36353261 	ldrtcc	r3, [r5], -r1, ror #4
     f68:	0300682e 	movweq	r6, #2094	@ 0x82e
     f6c:	68730000 	ldmdavs	r3!, {}^	@ <UNPREDICTABLE>
  AES_init_ctx(&ctx, AES_key);
     f70:	2e6c6c65 	cdpcs	12, 6, cr6, cr12, cr5, {3}
     f74:	00040068 	andeq	r0, r4, r8, rrx
    shell();
     f78:	73616200 	cmnvc	r1, #0, 4
  while (TRUE) {
     f7c:	2e343665 	cfmsuba32cs	mvax3, mvax3, mvfx4, mvfx5
     f80:	00050068 	andeq	r0, r5, r8, rrx
     f84:	72747300 	rsbsvc	r7, r4, #0, 6
int exec(char *cmd_str) {
     f88:	2e676e69 	cdpcs	14, 6, cr6, cr7, cr9, {3}
     f8c:	00060068 	andeq	r0, r6, r8, rrx
  argc = parse_line(argv, cmd_str, MAX_ARG_COUNT);
     f90:	69727000 	ldmdbvs	r2!, {ip, sp, lr}^
     f94:	2e66746e 	cdpcs	4, 6, cr7, cr6, cr14, {3}
  if (argc > 0) execute(argc, argv);
     f98:	00070068 	andeq	r0, r7, r8, rrx
  return __cmd_exec_status;
     f9c:	28050000 	stmdacs	r5, {}	@ <UNPREDICTABLE>
}
     fa0:	c0020500 	andgt	r0, r2, r0, lsl #10
     fa4:	15000008 	strne	r0, [r0, #-8]
  if (argc > 0) execute(argc, argv);
     fa8:	05050106 	streq	r0, [r5, #-262]	@ 0xfffffefa
     fac:	20062f06 	andcs	r2, r6, r6, lsl #30
     fb0:	05133006 	ldreq	r3, [r3, #-6]
cmd get_function_addr(char *cmd_str) {
     fb4:	0501060a 	streq	r0, [r1, #-1546]	@ 0xfffff9f6
  for (int i = 0; table[i].command_name != NULL; i++) {
     fb8:	21080605 	tstcs	r8, r5, lsl #12
     fbc:	01060a05 	tsteq	r6, r5, lsl #20
     fc0:	84060505 	strhi	r0, [r6], #-1285	@ 0xfffffafb
     fc4:	14131314 	ldrne	r1, [r3], #-788	@ 0xfffffcec
     fc8:	833d0205 	teqhi	sp, #1342177280	@ 0x50000000
    if (strcmp(cmd_str, table[i].command_name) == 0) {
     fcc:	054c0505 	strbeq	r0, [ip, #-1285]	@ 0xfffffafb
     fd0:	0501060b 	streq	r0, [r1, #-1547]	@ 0xfffff9f5
      return table[i].command;
     fd4:	05670605 	strbeq	r0, [r7, #-1541]!	@ 0xfffff9fb
     fd8:	05010614 	streq	r0, [r1, #-1556]	@ 0xfffff9ec
  return NULL;
     fdc:	05300605 	ldreq	r0, [r0, #-1541]!	@ 0xfffff9fb
}
     fe0:	4a01060b 	bmi	42814 <__ROM_SIZE__+0x2814>
  if(v < 26) return v + 'A';
     fe4:	2f060505 	svccs	0x00060505
  if(v < 52) return v + 71;
     fe8:	01061205 	tsteq	r6, r5, lsl #4
  if(v < 62) return v - 4;
     fec:	22060505 	andcs	r0, r6, #20971520	@ 0x1400000
  if(v == 62) return '+';
     ff0:	2f062e06 	svccs	0x00062e06
  if(v == 63) return '/';
     ff4:	0601054c 	streq	r0, [r1], -ip, asr #10
  return 64;
     ff8:	000d0213 	andeq	r0, sp, r3, lsl r2
  if(v < 26) return v + 'A';
     ffc:	09d10101 	ldmibeq	r1, {r0, r8}^
    1000:	00030000 	andeq	r0, r3, r0
  if(v < 52) return v + 71;
    1004:	00000178 	andeq	r0, r0, r8, ror r1
  if(v < 62) return v - 4;
    1008:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
    100c:	0101000d 	tsteq	r1, sp
  if(v == 62) return '+';
    1010:	00000101 	andeq	r0, r0, r1, lsl #2
}
    1014:	00000100 	andeq	r0, r0, r0, lsl #2
  if('A' <= c && c <= 'Z') return c - 'A';
    1018:	6f682f01 	svcvs	0x00682f01
    101c:	652f656d 	strvs	r6, [pc, #-1389]!	@ ab7 <execute+0x27>
  if('a' <= c && c <= 'z') return c - 71;
    1020:	2f667463 	svccs	0x00667463
    1024:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    1028:	6172742d 	cmnvs	r2, sp, lsr #8
  if('0' <= c && c <= '9') return c + 4;
    102c:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
    1030:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
  if(c == '+') return 62;
    1034:	732f6c6c 			@ <UNDEFINED> instruction: 0x732f6c6c
  if(c == '/') return 63;
    1038:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
  return 255;
    103c:	706f2f00 	rsbvc	r2, pc, r0, lsl #30
  if('a' <= c && c <= 'z') return c - 71;
    1040:	63672f74 	cmnvs	r7, #116, 30	@ 0x1d0
    1044:	72612d63 	rsbvc	r2, r1, #6336	@ 0x18c0
  if('0' <= c && c <= '9') return c + 4;
    1048:	6f6e2d6d 	svcvs	0x006e2d6d
  if(c == '+') return 62;
    104c:	652d656e 	strvs	r6, [sp, #-1390]!	@ 0xfffffa92
  if(c == '/') return 63;
    1050:	2f696261 	svccs	0x00696261
  return (input_length + 2)/3*4;
    1054:	2f62696c 	svccs	0x0062696c
    1058:	2f636367 	svccs	0x00636367
    105c:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	@ 0xfffffe7c
}
    1060:	656e6f6e 	strbvs	r6, [lr, #-3950]!	@ 0xfffff092
    1064:	6261652d 	rsbvs	r6, r1, #188743680	@ 0xb400000
unsigned int decode_base64_length(unsigned char input[], unsigned int input_length) {
    1068:	32312f69 	eorscc	r2, r1, #420	@ 0x1a4
    106c:	312e322e 			@ <UNDEFINED> instruction: 0x312e322e
  while(base64_to_binary(input[0]) < 64 && (unsigned int) (input - start) < input_length) {
    1070:	636e692f 	cmnvs	lr, #770048	@ 0xbc000
    1074:	6564756c 	strbvs	r7, [r4, #-1388]!	@ 0xfffffa94
    1078:	6f682f00 	svcvs	0x00682f00
    107c:	652f656d 	strvs	r6, [pc, #-1389]!	@ b17 <help+0x2b>
    1080:	2f667463 	svccs	0x00667463
  input_length = input - start;
    1084:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
  return input_length/4*3 + (input_length % 4 ? input_length % 4 - 1 : 0);
    1088:	6172742d 	cmnvs	r2, sp, lsr #8
    108c:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
    1090:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
}
    1094:	6c2f6c6c 	stcvs	12, cr6, [pc], #-432	@ eec <shell+0x114>
  return input_length/4*3 + (input_length % 4 ? input_length % 4 - 1 : 0);
    1098:	742f6269 	strtvc	r6, [pc], #-617	@ 10a0 <encode_base64+0x4>
unsigned int encode_base64(unsigned char input[], unsigned int input_length, unsigned char output[]) {
    109c:	2d796e69 	ldclcs	14, cr6, [r9, #-420]!	@ 0xfffffe5c
    10a0:	00736561 	rsbseq	r6, r3, r1, ror #10
    10a4:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ ff0 <binary_to_base64+0xc>
  unsigned int full_sets = input_length/3;
    10a8:	63652f65 	cmnvs	r5, #404	@ 0x194
    10ac:	652f6674 	strvs	r6, [pc, #-1652]!	@ a40 <show_history+0x1c>
  for(unsigned int i = 0; i < full_sets; ++i) {
    10b0:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
    output[0] = binary_to_base64(                         input[0] >> 2);
    10b4:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
    10b8:	2f72656e 	svccs	0x0072656e
    output[1] = binary_to_base64((input[0] & 0x03) << 4 | input[1] >> 4);
    10bc:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
    10c0:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
    10c4:	74732f62 	ldrbtvc	r2, [r3], #-3938	@ 0xfffff09e
    10c8:	676e6972 			@ <UNDEFINED> instruction: 0x676e6972
    10cc:	6f682f00 	svcvs	0x00682f00
    output[2] = binary_to_base64((input[1] & 0x0F) << 2 | input[2] >> 6);
    10d0:	652f656d 	strvs	r6, [pc, #-1389]!	@ b6b <add_command_to_history+0x17>
    10d4:	2f667463 	svccs	0x00667463
    10d8:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    10dc:	6172742d 	cmnvs	r2, sp, lsr #8
    10e0:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
    output[3] = binary_to_base64( input[2] & 0x3F);
    10e4:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
    10e8:	6c2f6c6c 	stcvs	12, cr6, [pc], #-432	@ f40 <shell+0x168>
    10ec:	622f6269 	eorvs	r6, pc, #-1879048186	@ 0x90000006
    input += 3;
    10f0:	36657361 	strbtcc	r7, [r5], -r1, ror #6
  for(unsigned int i = 0; i < full_sets; ++i) {
    10f4:	682f0034 	stmdavs	pc!, {r2, r4, r5}	@ <UNPREDICTABLE>
    10f8:	2f656d6f 	svccs	0x00656d6f
  switch(input_length % 3) {
    10fc:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    1100:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
    1104:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
    1108:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
    110c:	68732f72 	ldmdavs	r3!, {r1, r4, r5, r6, r8, r9, sl, fp, sp}^
    1110:	2f6c6c65 	svccs	0x006c6c65
    1114:	2f62696c 	svccs	0x0062696c
  return encode_base64_length(input_length);
    1118:	6e697270 	mcrvs	2, 3, r7, cr9, cr0, {3}
}
    111c:	00006674 	andeq	r6, r0, r4, ror r6
      output[0] = '\0';
    1120:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
      output[0] = binary_to_base64(                         input[0] >> 2);
    1124:	00632e6c 	rsbeq	r2, r3, ip, ror #28
    1128:	73000001 	movwvc	r0, #1
    112c:	6e696474 	mcrvs	4, 3, r6, cr9, cr4, {3}
      output[1] = binary_to_base64((input[0] & 0x03) << 4);
    1130:	63672d74 	cmnvs	r7, #116, 26	@ 0x1d00
    1134:	00682e63 	rsbeq	r2, r8, r3, ror #28
    1138:	73000002 	movwvc	r0, #2
      output[2] = '=';
    113c:	65646474 	strbvs	r6, [r4, #-1140]!	@ 0xfffffb8c
      output[3] = '=';
    1140:	00682e66 	rsbeq	r2, r8, r6, ror #28
      output[4] = '\0';
    1144:	61000002 	tstvs	r0, r2
      output[0] = binary_to_base64(                         input[0] >> 2);
    1148:	682e7365 	stmdavs	lr!, {r0, r2, r5, r6, r8, r9, ip, sp, lr}
    114c:	00000300 	andeq	r0, r0, r0, lsl #6
    1150:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
      output[1] = binary_to_base64((input[0] & 0x03) << 4 | input[1] >> 4);
    1154:	00682e6c 	rsbeq	r2, r8, ip, ror #28
    1158:	73000001 	movwvc	r0, #1
    115c:	6e697274 	mcrvs	2, 3, r7, cr9, cr4, {3}
    1160:	00682e67 	rsbeq	r2, r8, r7, ror #28
    1164:	62000004 	andvs	r0, r0, #4
      output[2] = binary_to_base64((input[1] & 0x0F) << 2);
    1168:	36657361 	strbtcc	r7, [r5], -r1, ror #6
    116c:	00682e34 	rsbeq	r2, r8, r4, lsr lr
    1170:	70000005 	andvc	r0, r0, r5
      output[3] = '=';
    1174:	746e6972 	strbtvc	r6, [lr], #-2418	@ 0xfffff68e
      output[4] = '\0';
    1178:	00682e66 	rsbeq	r2, r8, r6, ror #28
      break;
    117c:	00000006 	andeq	r0, r0, r6
    1180:	05004005 	streq	r4, [r0, #-5]
unsigned int decode_base64(unsigned char input[], unsigned int input_length, unsigned char output[]) {
    1184:	00096402 	andeq	r6, r9, r2, lsl #8
    1188:	03800300 	orreq	r0, r0, #0, 6
  unsigned int output_length = decode_base64_length(input, input_length);
    118c:	03090501 	movweq	r0, #38145	@ 0x9501
    1190:	19053c0c 	stmdbne	r5, {r2, r3, sl, fp, ip, sp}
  for(unsigned int i = 2; i < output_length; i += 3) {
    1194:	3506052e 	strcc	r0, [r6, #-1326]	@ 0xfffffad2
    output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
    1198:	054b0b05 	strbeq	r0, [fp, #-2821]	@ 0xfffff4fb
    119c:	0402002b 	streq	r0, [r2], #-43	@ 0xffffffd5
    11a0:	20052002 	andcs	r2, r5, r2
    11a4:	02040200 	andeq	r0, r4, #0, 4
    11a8:	0026053c 	eoreq	r0, r6, ip, lsr r5
    output[1] = base64_to_binary(input[1]) << 4 | base64_to_binary(input[2]) >> 2;
    11ac:	3c020402 	cfstrscc	mvf0, [r2], {2}
    11b0:	02002405 	andeq	r2, r0, #83886080	@ 0x5000000
    11b4:	05200204 	streq	r0, [r0, #-516]!	@ 0xfffffdfc
    11b8:	04020010 	streq	r0, [r2], #-16
    11bc:	0c052001 	stceq	0, cr2, [r5], {1}
    output[2] = base64_to_binary(input[2]) << 6 | base64_to_binary(input[3]);
    11c0:	2e03054d 	cfsh32cs	mvfx0, mvfx3, #45
    11c4:	02002f05 	andeq	r2, r0, #5, 30
    11c8:	05200304 	streq	r0, [r0, #-772]!	@ 0xfffffcfc
    11cc:	04020026 	streq	r0, [r2], #-38	@ 0xffffffda
    input += 4;
    11d0:	19053c03 	stmdbne	r5, {r0, r1, sl, fp, ip, sp}
  for(unsigned int i = 2; i < output_length; i += 3) {
    11d4:	01040200 	mrseq	r0, R12_usr
    11d8:	0303053c 	movweq	r0, #13628	@ 0x353c
  switch(output_length % 3) {
    11dc:	01054a10 	tsteq	r5, r0, lsl sl
    11e0:	031a052f 	tsteq	sl, #197132288	@ 0xbc00000
    11e4:	05e47dab 	strbeq	r7, [r4, #3499]!	@ 0xdab
    11e8:	3d4b2103 	stfcce	f2, [fp, #-12]
    11ec:	3d060105 	stfccs	f0, [r6, #-20]	@ 0xffffffec
    11f0:	3e062a05 	vmlacc.f32	s4, s12, s10
    11f4:	03050106 	movweq	r0, #20742	@ 0x5106
    11f8:	09052f06 	stmdbeq	r5, {r1, r2, r8, r9, sl, fp, sp}
      output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
    11fc:	05050106 	streq	r0, [r5, #-262]	@ 0xfffffefa
    1200:	052f2106 	streq	r2, [pc, #-262]!	@ 1102 <encode_base64+0x66>
    1204:	0501060f 	streq	r0, [r1, #-1551]	@ 0xfffff9f1
    1208:	051e060a 	ldreq	r0, [lr, #-1546]	@ 0xfffff9f6
    120c:	20320601 	eorscs	r0, r2, r1, lsl #12
      output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
    1210:	00062205 	andeq	r2, r6, r5, lsl #4
    1214:	09fe0205 	ldmibeq	lr!, {r0, r2, r9}^
    1218:	95030000 	strls	r0, [r3, #-0]
    121c:	03050102 	movweq	r0, #20738	@ 0x5102
    1220:	01080521 	tsteq	r8, r1, lsr #10
      output[1] = base64_to_binary(input[1]) << 4 | base64_to_binary(input[2]) >> 2;
    1224:	01060c05 	tsteq	r6, r5, lsl #24
    1228:	05200305 	streq	r0, [r0, #-773]!	@ 0xfffffcfb
    122c:	04020005 	streq	r0, [r2], #-5
    1230:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
    1234:	04020011 	streq	r0, [r2], #-17	@ 0xffffffef
  return output_length;
    1238:	05010603 	streq	r0, [r1, #-1539]	@ 0xfffff9fd
    123c:	04020005 	streq	r0, [r2], #-5
{
    1240:	37052003 	strcc	r2, [r5, -r3]
    1244:	03040200 	movweq	r0, #16896	@ 0x4200
	for (i = 0, j = 0; i < 16; ++i, j += 4)
    1248:	2d053b06 	vstrcs	d3, [r5, #-24]	@ 0xffffffe8
    124c:	01040200 	mrseq	r0, R12_usr
		m[i] = (data[j] << 24) | (data[j + 1] << 16) | (data[j + 2] << 8) | (data[j + 3]);
    1250:	001c0520 	andseq	r0, ip, r0, lsr #10
    1254:	06010402 	streq	r0, [r1], -r2, lsl #8
    1258:	001f0501 	andseq	r0, pc, r1, lsl #10
    125c:	58010402 	stmdapl	r1, {r1, sl}
    1260:	02002d05 	andeq	r2, r0, #320	@ 0x140
    1264:	05200104 	streq	r0, [r0, #-260]!	@ 0xfffffefc
    1268:	05203101 	streq	r3, [r0, #-257]!	@ 0xfffffeff
	for (i = 0, j = 0; i < 16; ++i, j += 4)
    126c:	05000630 	streq	r0, [r0, #-1584]	@ 0xfffff9d0
    1270:	000a2402 	andeq	r2, sl, r2, lsl #8
		m[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16];
    1274:	7e990300 	cdpvc	3, 9, cr0, cr9, cr0, {0}
    1278:	05010601 	streq	r0, [r1, #-1537]	@ 0xfffff9ff
    127c:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
    1280:	0501062a 	streq	r0, [r1, #-1578]	@ 0xfffff9d6
    1284:	133d0603 	teqne	sp, #3145728	@ 0x300000
    1288:	01061a05 	tsteq	r6, r5, lsl #20
    128c:	05200605 	streq	r0, [r0, #-1541]!	@ 0xfffff9fb
    1290:	052f0605 	streq	r0, [pc, #-1541]!	@ c93 <handle_up_arrow+0x69>
    1294:	3c010624 	stccc	6, cr0, [r1], {36}	@ 0x24
    1298:	051e0c05 	ldreq	r0, [lr, #-3077]	@ 0xfffff3fb
    129c:	04020005 	streq	r0, [r2], #-5
    12a0:	05330603 	ldreq	r0, [r3, #-1539]!	@ 0xfffff9fd
    12a4:	04020026 	streq	r0, [r2], #-38	@ 0xffffffda
    12a8:	05010603 	streq	r0, [r1, #-1539]	@ 0xfffff9fd
    12ac:	04020005 	streq	r0, [r2], #-5
    12b0:	38052e03 	stmdacc	r5, {r0, r1, r9, sl, fp, sp}
    12b4:	03040200 	movweq	r0, #16896	@ 0x4200
	for ( ; i < 64; ++i)
    12b8:	2a056506 	bcs	15a6d8 <__ROM_SIZE__+0x11a6d8>
    12bc:	01040200 	mrseq	r0, R12_usr
	a = ctx->state[0];
    12c0:	32030520 	andcc	r0, r3, #32, 10	@ 0x8000000
	b = ctx->state[1];
    12c4:	13060105 	movwne	r0, #24837	@ 0x6105
	c = ctx->state[2];
    12c8:	062c052e 	strteq	r0, [ip], -lr, lsr #10
	d = ctx->state[3];
    12cc:	64020500 	strvs	r0, [r2], #-1280	@ 0xfffffb00
	e = ctx->state[4];
    12d0:	0300000a 	movweq	r0, #10
	f = ctx->state[5];
    12d4:	060102d2 			@ <UNDEFINED> instruction: 0x060102d2
    12d8:	06030501 	streq	r0, [r3], -r1, lsl #10
	g = ctx->state[6];
    12dc:	203c0621 	eorscs	r0, ip, r1, lsr #12
	h = ctx->state[7];
    12e0:	01052f06 	tsteq	r5, r6, lsl #30
    12e4:	2e051306 	cdpcs	3, 0, cr1, cr5, cr6, {0}
	d = ctx->state[3];
    12e8:	02050006 	andeq	r0, r5, #6
	b = ctx->state[1];
    12ec:	00000a80 	andeq	r0, r0, r0, lsl #21
	for (i = 0; i < 64; ++i) {
    12f0:	017f8903 	cmneq	pc, r3, lsl #18
    12f4:	03050106 	movweq	r0, #20742	@ 0x5106
    12f8:	20062106 	andcs	r2, r6, r6, lsl #2
    12fc:	01053006 	tsteq	r5, r6
		t1 = h + EP1(e) + CH(e,f,g) + k[i] + m[i];
    1300:	2c051306 	stccs	3, cr1, [r5], {6}
    1304:	02050006 	andeq	r0, r5, #6
    1308:	00000a90 	muleq	r0, r0, sl
    130c:	017ef103 	cmneq	lr, r3, lsl #2	@ <UNPREDICTABLE>
    1310:	03050106 	movweq	r0, #20742	@ 0x5106
    1314:	05144b06 	ldreq	r4, [r4, #-2822]	@ 0xfffff4fa
    1318:	0c050108 	stfeqs	f0, [r5], {8}
    131c:	03050106 	movweq	r0, #20742	@ 0x5106
    1320:	00330520 	eorseq	r0, r3, r0, lsr #10
    1324:	06020402 	streq	r0, [r2], -r2, lsl #8
    1328:	00290520 	eoreq	r0, r9, r0, lsr #10
		t2 = EP0(a) + MAJ(a,b,c);
    132c:	20010402 	andcs	r0, r1, r2, lsl #8
    1330:	02001805 	andeq	r1, r0, #327680	@ 0x50000
    1334:	01060104 	tsteq	r6, r4, lsl #2
    1338:	02001b05 	andeq	r1, r0, #5120	@ 0x1400
    133c:	054a0104 	strbeq	r0, [sl, #-260]	@ 0xfffffefc
    1340:	04020029 	streq	r0, [r2], #-41	@ 0xffffffd7
    1344:	05052001 	streq	r2, [r5, #-1]
    1348:	09052106 	stmdbeq	r5, {r1, r2, r8, sp}
		h = g;
    134c:	08050106 	stmdaeq	r5, {r1, r2, r8}
		f = e;
    1350:	0607053c 			@ <UNDEFINED> instruction: 0x0607053c
		e = d + t1;
    1354:	0620052f 	strteq	r0, [r0], -pc, lsr #10
		c = b;
    1358:	2e230501 	cfsh64cs	mvdx0, mvdx3, #1
		a = t1 + t2;
    135c:	05201b05 	streq	r1, [r0, #-2821]!	@ 0xfffff4fb
	for (i = 0; i < 64; ++i) {
    1360:	07053c19 	smladeq	r5, r9, ip, r3
	ctx->state[0] += a;
    1364:	06133d06 	ldreq	r3, [r3], -r6, lsl #26
    1368:	06030501 	streq	r0, [r3], -r1, lsl #10
    136c:	05052016 	streq	r2, [r5, #-22]	@ 0xffffffea
    1370:	17054c13 	smladne	r5, r3, ip, r4
    1374:	01050106 	tsteq	r5, r6, lsl #2
	ctx->state[1] += b;
    1378:	21052e5a 	tstcs	r5, sl, asr lr
	ctx->state[2] += c;
    137c:	02050006 	andeq	r0, r5, #6
    1380:	00000aec 	andeq	r0, r0, ip, ror #21
	ctx->state[3] += d;
    1384:	0101d503 	tsteq	r1, r3, lsl #10
	ctx->state[4] += e;
    1388:	03050106 	movweq	r0, #20742	@ 0x5106
    138c:	14142106 	ldrne	r2, [r4], #-262	@ 0xfffffefa
	ctx->state[5] += f;
    1390:	01060605 	tsteq	r6, r5, lsl #12
    1394:	02001405 	andeq	r1, r0, #83886080	@ 0x5000000
	ctx->state[6] += g;
    1398:	003c0104 	eorseq	r0, ip, r4, lsl #2
    139c:	20010402 	andcs	r0, r1, r2, lsl #8
	ctx->state[7] += h;
    13a0:	01040200 	mrseq	r0, R12_usr
    13a4:	00100520 	andseq	r0, r0, r0, lsr #10
}
    13a8:	2e010402 	cdpcs	4, 0, cr0, cr1, cr2, {0}
    13ac:	23060505 	movwcs	r0, #25861	@ 0x6505
    13b0:	37060805 	strcc	r0, [r6, -r5, lsl #16]
	ctx->datalen = 0;
    13b4:	05230d05 	streq	r0, [r3, #-3333]!	@ 0xfffff2fb
	ctx->bitlen = 0;
    13b8:	0d030605 	stceq	6, cr0, [r3, #-20]	@ 0xffffffec
    13bc:	06053d2e 	streq	r3, [r5], -lr, lsr #26
	ctx->state[0] = 0x6a09e667;
    13c0:	20050106 	andcs	r0, r5, r6, lsl #2
	ctx->state[1] = 0xbb67ae85;
    13c4:	20770306 	rsbscs	r0, r7, r6, lsl #6
	ctx->state[2] = 0x3c6ef372;
    13c8:	01060f05 	tsteq	r6, r5, lsl #30
	ctx->state[3] = 0xa54ff53a;
    13cc:	054a1205 	strbeq	r1, [sl, #-517]	@ 0xfffffdfb
	ctx->state[4] = 0x510e527f;
    13d0:	05052020 	streq	r2, [r5, #-32]	@ 0xffffffe0
	ctx->state[5] = 0x9b05688c;
    13d4:	05302106 	ldreq	r2, [r0, #-262]!	@ 0xfffffefa
	ctx->state[6] = 0x1f83d9ab;
    13d8:	05010608 	streq	r0, [r1, #-1544]	@ 0xfffff9f8
	ctx->state[7] = 0x5be0cd19;
    13dc:	3d2f0607 	stccc	6, cr0, [pc, #-28]!	@ 13c8 <sha256_init+0x14>
    13e0:	01061305 	tsteq	r6, r5, lsl #6
    13e4:	052e0705 	streq	r0, [lr, #-1797]!	@ 0xfffff8fb
    13e8:	4a76030d 	bmi	1d82024 <__ROM_SIZE__+0x1d42024>
}
    13ec:	03060305 	movweq	r0, #25349	@ 0x6305
    13f0:	01052e11 	tsteq	r5, r1, lsl lr
    13f4:	05201306 	streq	r1, [r0, #-774]!	@ 0xfffffcfa
    13f8:	05000639 	streq	r0, [r0, #-1593]	@ 0xfffff9c7
    13fc:	000b5402 	andeq	r5, fp, r2, lsl #8
    1400:	7d990300 	ldcvc	3, cr0, [r9]
    1404:	15030501 	strne	r0, [r3, #-1281]	@ 0xfffffaff
{
    1408:	01060605 	tsteq	r6, r5, lsl #12
    140c:	02003905 	andeq	r3, r0, #81920	@ 0x14000
	for (i = 0; i < len; ++i) {
    1410:	051d0104 	ldreq	r0, [sp, #-260]	@ 0xfffffefc
    1414:	0402001a 	streq	r0, [r2], #-26	@ 0xffffffe6
    1418:	17053101 	strne	r3, [r5, -r1, lsl #2]
		ctx->data[ctx->datalen] = data[i];
    141c:	01040200 	mrseq	r0, R12_usr
		ctx->datalen++;
    1420:	2701053c 	smladxcs	r1, ip, r5, r0
		if (ctx->datalen == 64) {
    1424:	1c060305 	stcne	3, cr0, [r6], {5}
			sha256_transform(ctx, ctx->data);
    1428:	01062205 	tsteq	r6, r5, lsl #4
    142c:	052e0705 	streq	r0, [lr, #-1797]!	@ 0xfffff8fb
			ctx->bitlen += 512;
    1430:	05590603 	ldrbeq	r0, [r9, #-1539]	@ 0xfffff9fd
    1434:	0501060a 	streq	r0, [r1, #-1546]	@ 0xfffff9f6
    1438:	064a2e03 	strbeq	r2, [sl], -r3, lsl #28
    143c:	0615052f 	ldreq	r0, [r5], -pc, lsr #10
			ctx->datalen = 0;
    1440:	06030501 	streq	r0, [r3], -r1, lsl #10
    1444:	0614053d 			@ <UNDEFINED> instruction: 0x0614053d
{
    1448:	48054a01 	stmdami	r5, {r0, r9, fp, lr}
    144c:	00c90306 	sbceq	r0, r9, r6, lsl #6
	if (ctx->datalen < 56) {
    1450:	05010666 	streq	r0, [r1, #-1638]	@ 0xfffff99a
		ctx->data[i++] = 0x80;
    1454:	133d0603 	teqne	sp, #3145728	@ 0x300000
    1458:	06100513 			@ <UNDEFINED> instruction: 0x06100513
			ctx->data[i++] = 0x00;
    145c:	052e2001 	streq	r2, [lr, #-1]!
    1460:	05220603 	streq	r0, [r2, #-1539]!	@ 0xfffff9fd
		while (i < 56)
    1464:	1f0f0607 	svcne	0x000f0607
	ctx->bitlen += ctx->datalen * 8;
    1468:	05240905 	streq	r0, [r4, #-2309]!	@ 0xfffff6fb
    146c:	0527060d 	streq	r0, [r7, #-1549]!	@ 0xfffff9f3
    1470:	15051e3e 	strne	r1, [r5, #-3646]	@ 0xfffff1c2
    1474:	3e050106 	adfccs	f0, f5, f6
	ctx->data[63] = ctx->bitlen;
    1478:	0023052e 	eoreq	r0, r3, lr, lsr #10
	ctx->data[62] = ctx->bitlen >> 8;
    147c:	2e010402 	cdpcs	4, 0, cr0, cr1, cr2, {0}
    1480:	02003e05 	andeq	r3, r0, #5, 28	@ 0x50
	ctx->data[61] = ctx->bitlen >> 16;
    1484:	052e0204 	streq	r0, [lr, #-516]!	@ 0xfffffdfc
	ctx->data[60] = ctx->bitlen >> 24;
    1488:	05330605 	ldreq	r0, [r3, #-1541]!	@ 0xfffff9fb
    148c:	05010608 	streq	r0, [r1, #-1544]	@ 0xfffff9f8
	ctx->data[59] = ctx->bitlen >> 32;
    1490:	04020020 	streq	r0, [r2], #-32	@ 0xffffffe0
	ctx->data[58] = ctx->bitlen >> 40;
    1494:	07052e01 	streq	r2, [r5, -r1, lsl #28]
	ctx->data[57] = ctx->bitlen >> 48;
    1498:	16052f06 	strne	r2, [r5], -r6, lsl #30
    149c:	05050106 	streq	r0, [r5, #-262]	@ 0xfffffefa
	ctx->data[56] = ctx->bitlen >> 56;
    14a0:	08053006 	stmdaeq	r5, {r1, r2, ip, sp}
	sha256_transform(ctx, ctx->data);
    14a4:	0e050106 	adfeqs	f0, f5, f6
    14a8:	20730306 	rsbscs	r0, r3, r6, lsl #6
	for (i = 0; i < 4; ++i) {
    14ac:	052f0505 	streq	r0, [pc, #-1285]!	@ faf <exec+0x27>
		ctx->data[i++] = 0x80;
    14b0:	05010612 	streq	r0, [r1, #-1554]	@ 0xfffff9ee
    14b4:	20052e08 	andcs	r2, r5, r8, lsl #28
			ctx->data[i++] = 0x00;
    14b8:	01040200 	mrseq	r0, R12_usr
    14bc:	003b052e 	eorseq	r0, fp, lr, lsr #10
		while (i < 64)
    14c0:	2e020402 	cdpcs	4, 0, cr0, cr2, cr2, {0}
		sha256_transform(ctx, ctx->data);
    14c4:	30060705 	andcc	r0, r6, r5, lsl #14
    14c8:	01061405 	tsteq	r6, r5, lsl #8
		memset(ctx->data, 0, 56);
    14cc:	202e1005 	eorcs	r1, lr, r5
    14d0:	03060305 	movweq	r0, #25349	@ 0x6305
    14d4:	0105200d 	tsteq	r5, sp
		hash[i]      = (ctx->state[0] >> (24 - i * 8)) & 0x000000ff;
    14d8:	05201306 	streq	r1, [r0, #-774]!	@ 0xfffffcfa
    14dc:	0500063e 	streq	r0, [r0, #-1598]	@ 0xfffff9c2
    14e0:	000bee02 	andeq	lr, fp, r2, lsl #28
		hash[i + 4]  = (ctx->state[1] >> (24 - i * 8)) & 0x000000ff;
    14e4:	7fb80300 	svcvc	0x00b80300
    14e8:	13030501 	movwne	r0, #13569	@ 0x3501
		hash[i + 8]  = (ctx->state[2] >> (24 - i * 8)) & 0x000000ff;
    14ec:	01060605 	tsteq	r6, r5, lsl #12
    14f0:	02003e05 	andeq	r3, r0, #5, 28	@ 0x50
		hash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0x000000ff;
    14f4:	051f0104 	ldreq	r0, [pc, #-260]	@ 13f8 <sha256_init+0x44>
    14f8:	04020013 	streq	r0, [r2], #-19	@ 0xffffffed
    14fc:	22054b01 	andcs	r4, r5, #1024	@ 0x400
		hash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0x000000ff;
    1500:	02040200 	andeq	r0, r4, #0, 4
    1504:	00370520 	eorseq	r0, r7, r0, lsr #10
		hash[i + 20] = (ctx->state[5] >> (24 - i * 8)) & 0x000000ff;
    1508:	2e030402 	cdpcs	4, 0, cr0, cr3, cr2, {0}
    150c:	03040200 	movweq	r0, #16896	@ 0x4200
    1510:	002e0520 	eoreq	r0, lr, r0, lsr #10
		hash[i + 24] = (ctx->state[6] >> (24 - i * 8)) & 0x000000ff;
    1514:	2e030402 	cdpcs	4, 0, cr0, cr3, cr2, {0}
    1518:	05320c05 	ldreq	r0, [r2, #-3077]!	@ 0xfffff3fb
		hash[i + 28] = (ctx->state[7] >> (24 - i * 8)) & 0x000000ff;
    151c:	04020014 	streq	r0, [r2], #-20	@ 0xffffffec
    1520:	05200601 	streq	r0, [r0, #-1537]!	@ 0xfffff9ff
    1524:	0c052f05 	stceq	15, cr2, [r5], {5}
	for (i = 0; i < 4; ++i) {
    1528:	10050106 	andne	r0, r5, r6, lsl #2
}
    152c:	20080520 	andcs	r0, r8, r0, lsr #10
static void outstr(const char *str) {
    1530:	02001a05 	andeq	r1, r0, #20480	@ 0x5000
  while (*str != '\0') {
    1534:	2d060204 	sfmcs	f0, 4, [r6, #-16]
    __write_char__(*str);
    1538:	02040200 	andeq	r0, r4, #0, 4
    str++;
    153c:	02002006 	andeq	r2, r0, #6
  while (*str != '\0') {
    1540:	05200204 	streq	r0, [r0, #-516]!	@ 0xfffffdfc
}
    1544:	050f0605 	streq	r0, [pc, #-1541]	@ f47 <shell+0x16f>
    1548:	0501060c 	streq	r0, [r1, #-1548]	@ 0xfffff9f4
static bool printf_numbers(const char fmt, va_list *args, int l_count) {
    154c:	200a0301 	andcs	r0, sl, r1, lsl #6
    1550:	051f0a05 	ldreq	r0, [pc, #-2565]	@ b53 <help+0x67>
  switch (fmt) {
    1554:	052e2a0e 	streq	r2, [lr, #-2574]!	@ 0xfffff5f2
    1558:	050d0605 	streq	r0, [sp, #-1541]	@ 0xfffff9fb
    155c:	0501060c 	streq	r0, [r1, #-1548]	@ 0xfffff9f4
      if (l_count == 0) {
    1560:	200a0301 	andcs	r0, sl, r1, lsl #6
    1564:	03063e05 	movweq	r3, #28165	@ 0x6e05
        value = va_arg(*args, unsigned int);
    1568:	06207fb6 			@ <UNDEFINED> instruction: 0x06207fb6
    156c:	06030501 	streq	r0, [r3], -r1, lsl #10
      if (fmt == 'u') {
    1570:	062d052f 	strteq	r0, [sp], -pc, lsr #10
        if (value == 0) {
    1574:	3c180501 	cfldr32cc	mvfx0, [r8], {1}
          __write_char__(hextable[0]);
    1578:	052e0605 	streq	r0, [lr, #-1541]!	@ 0xfffff9fb
    157c:	04020018 	streq	r0, [r2], #-24	@ 0xffffffe8
  return true;
    1580:	43053d01 	movwmi	r3, #23809	@ 0x5d01
  switch (fmt) {
    1584:	01040200 	mrseq	r0, R12_usr
      outstr("\nprintf-error\n");
    1588:	0605053b 			@ <UNDEFINED> instruction: 0x0605053b
      return false;
    158c:	20200622 	eorcs	r0, r0, r2, lsr #12
}
    1590:	01052f06 	tsteq	r5, r6, lsl #30
      if (l_count == 0) {
    1594:	010b0306 	tsteq	fp, r6, lsl #6
        value = va_arg(*args, int);
    1598:	03060305 	movweq	r0, #25349	@ 0x6305
    159c:	2e062078 	mcrcs	0, 0, r2, cr6, cr8, {3}
      if (value < 0) {
    15a0:	13053006 	movwne	r3, #20486	@ 0x5006
        num[num_len++] = hextable[value % 10];
    15a4:	03050106 	movweq	r0, #20742	@ 0x5106
    15a8:	21056706 	tstcs	r5, r6, lsl #14
    15ac:	07050106 	streq	r0, [r5, -r6, lsl #2]
    15b0:	0603052e 	streq	r0, [r3], -lr, lsr #10
    15b4:	06140559 			@ <UNDEFINED> instruction: 0x06140559
    15b8:	20030501 	andcs	r0, r3, r1, lsl #10
    15bc:	053d063c 	ldreq	r0, [sp, #-1596]!	@ 0xfffff9c4
    15c0:	05010611 	streq	r0, [r1, #-1553]	@ 0xfffff9ef
    15c4:	03053c0f 	movweq	r3, #23567	@ 0x5c0f
        value = value / 10;
    15c8:	40052206 	andmi	r2, r5, r6, lsl #4
      } while (value > 0);
    15cc:	050106a1 	streq	r0, [r1, #-1697]	@ 0xfffff95f
    15d0:	063d0603 	ldrteq	r0, [sp], -r3, lsl #12
        __write_char__('-');
    15d4:	052f062e 	streq	r0, [pc, #-1582]!	@ fae <exec+0x26>
    15d8:	0501060f 	streq	r0, [r1, #-1551]	@ 0xfffff9f1
        value = -value;
    15dc:	052f0603 	streq	r0, [pc, #-1539]!	@ fe1 <get_function_addr+0x2d>
        __write_char__(num[--num_len]);
    15e0:	05010618 	streq	r0, [r1, #-1560]	@ 0xfffff9e8
    15e4:	03054a06 	movweq	r4, #23046	@ 0x5a06
    15e8:	13053006 	movwne	r3, #20486	@ 0x5006
    15ec:	03050106 	movweq	r0, #20742	@ 0x5106
    15f0:	21056706 	tstcs	r5, r6, lsl #14
      while (num_len > 0) {
    15f4:	07050106 	streq	r0, [r5, -r6, lsl #2]
  return true;
    15f8:	0603052e 	streq	r0, [r3], -lr, lsr #10
          num[num_len++] = hextable[value % 10];
    15fc:	06140559 			@ <UNDEFINED> instruction: 0x06140559
    1600:	20030501 	andcs	r0, r3, r1, lsl #10
    1604:	11056706 	tstne	r5, r6, lsl #14
    1608:	0f050106 	svceq	0x00050106
    160c:	0603053c 			@ <UNDEFINED> instruction: 0x0603053c
    1610:	06010522 	streq	r0, [r1], -r2, lsr #10
    1614:	2705204b 	strcs	r2, [r5, -fp, asr #32]
    1618:	02050006 	andeq	r0, r5, #6
          value = value / 10;
    161c:	00000cfc 	strdeq	r0, [r0], -ip
        } while (value > 0);
    1620:	017fba03 	cmneq	pc, r3, lsl #20
        while (num_len > 0) {
    1624:	05012905 	streq	r2, [r1, #-2309]	@ 0xfffff6fb
          __write_char__(num[--num_len]);
    1628:	05010637 	streq	r0, [r1, #-1591]	@ 0xfffff9c9
    162c:	28053c3f 	stmdacs	r5, {r0, r1, r2, r3, r4, r5, sl, fp, ip, sp}
    1630:	2a053d06 	bcs	150a50 <__ROM_SIZE__+0x110a50>
    1634:	06390501 	ldrteq	r0, [r9], -r1, lsl #10
    1638:	3c410501 	cfstr64cc	mvdx0, [r1], {1}
    163c:	3e062905 	vmlacc.f16	s4, s12, s10	@ <UNPREDICTABLE>
  return true;
    1640:	05012b05 	streq	r2, [r1, #-2821]	@ 0xfffff4fb
              __write_char__(hextable[val]);
    1644:	0501063a 	streq	r0, [r1, #-1594]	@ 0xfffff9c6
    1648:	2a052e42 	bcs	14cf58 <__ROM_SIZE__+0x10cf58>
              leading_zero_ignored = true;
    164c:	2c054b06 			@ <UNDEFINED> instruction: 0x2c054b06
          while (start_bit >= 0) {
    1650:	063c0501 	ldrteq	r0, [ip], -r1, lsl #10
            int val = (value >> start_bit) & 0xF;
    1654:	3c440501 	cfstr64cc	mvdx0, [r4], {1}
            if (val || leading_zero_ignored) {
    1658:	3e062805 	cdpcc	8, 0, cr2, cr6, cr5, {0}
    165c:	05140105 	ldreq	r0, [r4, #-261]	@ 0xfffffefb
    1660:	01052227 	tsteq	r5, r7, lsr #4
          bool leading_zero_ignored = false;
    1664:	232d0514 			@ <UNDEFINED> instruction: 0x232d0514
          int start_bit = LAST_NIBBLE_FIRST_BIT;
    1668:	05130305 	ldreq	r0, [r3, #-773]	@ 0xfffffcfb
  return true;
    166c:	05130601 	ldreq	r0, [r3, #-1537]	@ 0xfffff9ff
        return false;
    1670:	e4030639 	str	r0, [r3], #-1593	@ 0xfffff9c7
        return false;
    1674:	03052000 	movweq	r2, #20480	@ 0x5000
    1678:	06060513 			@ <UNDEFINED> instruction: 0x06060513
    167c:	00390501 	eorseq	r0, r9, r1, lsl #10
    1680:	2d010402 	cfstrscs	mvf0, [r1, #-8]
    1684:	02001805 	andeq	r1, r0, #327680	@ 0x50000
    1688:	054b0104 	strbeq	r0, [fp, #-260]	@ 0xfffffefc
int printf(const char *fmt, ...) {
    168c:	2d2d2607 	stccs	6, cr2, [sp, #-28]!	@ 0xffffffe4
    1690:	03060505 	movweq	r0, #25861	@ 0x6505
    1694:	06052e0c 	streq	r2, [r5], -ip, lsl #28
  va_start(args, fmt);
    1698:	20050106 	andcs	r0, r5, r6, lsl #2
  while (*fmt) {
    169c:	20770306 	rsbscs	r0, r7, r6, lsl #6
        if (*fmt == '%') {
    16a0:	01060f05 	tsteq	r6, r5, lsl #30
        __write_char__(*fmt);
    16a4:	054a1205 	strbeq	r1, [sl, #-517]	@ 0xfffffdfb
        fmt++;
    16a8:	05052020 	streq	r2, [r5, #-32]	@ 0xffffffe0
  while (*fmt) {
    16ac:	09052306 	stmdbeq	r5, {r1, r2, r8, r9, sp}
    switch (state) {
    16b0:	08050106 	stmdaeq	r5, {r1, r2, r8}
    16b4:	0607054a 	streq	r0, [r7], -sl, asr #10
          fmt++;
    16b8:	0612052f 	ldreq	r0, [r2], -pc, lsr #10
          continue;
    16bc:	06070501 	streq	r0, [r7], -r1, lsl #10
        while (*fmt && ((*fmt >= '0' && *fmt <= '9') || *fmt == '-')) {
    16c0:	1205132f 	andne	r1, r5, #-1140850688	@ 0xbc000000
    16c4:	03055706 	movweq	r5, #22278	@ 0x5706
    16c8:	06053606 	streq	r3, [r5], -r6, lsl #12
    16cc:	03050106 	movweq	r0, #20742	@ 0x5106
    16d0:	06054206 	streq	r4, [r5], -r6, lsl #4
        switch (*fmt) {
    16d4:	01050106 	tsteq	r5, r6, lsl #2
    16d8:	06050542 	streq	r0, [r5], -r2, asr #10
    16dc:	052e7503 	streq	r7, [lr, #-1283]!	@ 0xfffffafd
    16e0:	0501061b 	streq	r0, [r1, #-1563]	@ 0xfffff9e5
            __write_char__(*fmt);
    16e4:	67062e05 	strvs	r2, [r6, -r5, lsl #28]
    16e8:	01061305 	tsteq	r6, r5, lsl #6
            state = CHECK_CH;
    16ec:	053c1105 	ldreq	r1, [ip, #-261]!	@ 0xfffffefb
            break;
    16f0:	59330605 	ldmdbpl	r3!, {r0, r2, r9, sl}
    16f4:	66064b2f 	strvs	r4, [r6], -pc, lsr #22
            outstr(va_arg(args, const char *));
    16f8:	03062b05 	movweq	r2, #27397	@ 0x6b05
    16fc:	05827f81 	streq	r7, [r2, #3969]	@ 0xf81
    1700:	3a05012d 	bcc	141bbc <__ROM_SIZE__+0x101bbc>
            fmt++;
    1704:	19050106 	stmdbne	r5, {r1, r2, r8}
            break;
    1708:	02050006 	andeq	r0, r5, #6
            __write_char__(va_arg(args, int));
    170c:	00000dd8 	ldrdeq	r0, [r0], -r8
    1710:	0101af03 	tsteq	r1, r3, lsl #30
    1714:	132f0305 			@ <UNDEFINED> instruction: 0x132f0305
            fmt++;
    1718:	01060705 	tsteq	r6, r5, lsl #14
            break;
    171c:	2f060305 	svccs	0x00060305
            if (*fmt == 'l') {
    1720:	14131413 	ldrne	r1, [r3], #-1043	@ 0xfffffbed
    1724:	05010805 	streq	r0, [r1, #-2053]	@ 0xfffff7fb
            if (printf_numbers(*fmt, &args, l_count)) {
    1728:	05010603 	streq	r0, [r1, #-1539]	@ 0xfffff9fd
    172c:	0402002c 	streq	r0, [r2], #-44	@ 0xffffffd4
    1730:	05200603 	streq	r0, [r0, #-1539]!	@ 0xfffff9fd
              state = CHECK_CH;
    1734:	04020039 	streq	r0, [r2], #-57	@ 0xffffffc7
              fmt++;
    1738:	05010603 	streq	r0, [r1, #-1539]	@ 0xfffff9fd
              l_count++;
    173c:	04020028 	streq	r0, [r2], #-40	@ 0xffffffd8
            if (printf_numbers(*fmt, &args, 0)) {
    1740:	05660603 	strbeq	r0, [r6, #-1539]!	@ 0xfffff9fd
    1744:	04020015 	streq	r0, [r2], #-21	@ 0xffffffeb
              fmt++;
    1748:	0c052001 	stceq	0, cr2, [r5], {1}
              break;
    174c:	05203006 	streq	r3, [r0, #-6]!
            return -1;
    1750:	0402002b 	streq	r0, [r2], #-43	@ 0xffffffd5
}
    1754:	05200603 	streq	r0, [r0, #-1539]!	@ 0xfffff9fd
    1758:	04020033 	streq	r0, [r2], #-51	@ 0xffffffcd
            return -1;
    175c:	05010603 	streq	r0, [r1, #-1539]	@ 0xfffff9fd
    1760:	04020027 	streq	r0, [r2], #-39	@ 0xffffffd9
    1764:	054a0603 	strbeq	r0, [sl, #-1539]	@ 0xfffff9fd
static void outstr2(const char *str) {
    1768:	04020015 	streq	r0, [r2], #-21	@ 0xffffffeb
  while (*str != '\0') {
    176c:	03052001 	movweq	r2, #20481	@ 0x5001
    __write_char2__(*str);
    1770:	07052f30 	smladxeq	r5, r0, pc, r2	@ <UNPREDICTABLE>
    str++;
    1774:	3c750306 	ldclcc	3, cr0, [r5], #-24	@ 0xffffffe8
  while (*str != '\0') {
    1778:	30031505 	andcc	r1, r3, r5, lsl #10
}
    177c:	1405202e 	strne	r2, [r5], #-46	@ 0xffffffd2
    1780:	01040200 	mrseq	r0, R12_usr
static bool printf2_numbers(const char fmt, va_list *args, int l_count) {
    1784:	20660306 	rsbcs	r0, r6, r6, lsl #6
    1788:	02001805 	andeq	r1, r0, #327680	@ 0x50000
  switch (fmt) {
    178c:	01060104 	tsteq	r6, r4, lsl #2
    1790:	02000505 	andeq	r0, r0, #20971520	@ 0x1400000
    1794:	4d060104 	stfmis	f0, [r6, #-16]
      if (l_count == 0) {
    1798:	02000805 	andeq	r0, r0, #327680	@ 0x50000
    179c:	01060104 	tsteq	r6, r4, lsl #2
        value = va_arg(*args, unsigned int);
    17a0:	03060705 	movweq	r0, #26373	@ 0x6705
    17a4:	063c00c3 	ldrteq	r0, [ip], -r3, asr #1
      if (fmt == 'u') {
    17a8:	0609052e 	streq	r0, [r9], -lr, lsr #10
        if (value == 0) {
    17ac:	05204103 	streq	r4, [r0, #-259]!	@ 0xfffffefd
          __write_char2__(hextable2[0]);
    17b0:	05010612 	streq	r0, [r1, #-1554]	@ 0xfffff9ee
    17b4:	0905201a 	stmdbeq	r5, {r1, r3, r4, sp}
  return true;
    17b8:	054b6706 	strbeq	r6, [fp, #-1798]	@ 0xfffff8fa
  switch (fmt) {
    17bc:	00c70303 	sbceq	r0, r7, r3, lsl #6
      outstr2("\nprintf2-error\n");
    17c0:	0a054001 	beq	1517cc <__ROM_SIZE__+0x1117cc>
      return false;
    17c4:	03050106 	movweq	r0, #20742	@ 0x5106
}
    17c8:	06055b06 	streq	r5, [r5], -r6, lsl #22
      if (l_count == 0) {
    17cc:	05200106 	streq	r0, [r0, #-262]!	@ 0xfffffefa
        value = va_arg(*args, int);
    17d0:	09052101 	stmdbeq	r5, {r0, r8, sp}
    17d4:	7fb50306 	svcvc	0x00b50306
      if (value < 0) {
    17d8:	060d052e 	streq	r0, [sp], -lr, lsr #10
        num[num_len++] = hextable2[value % 10];
    17dc:	2e0c0501 	cfsh32cs	mvfx0, mvfx12, #1
    17e0:	34060905 	strcc	r0, [r6], #-2309	@ 0xfffff6fb
    17e4:	01061305 	tsteq	r6, r5, lsl #6
    17e8:	05200c05 	streq	r0, [r0, #-3077]!	@ 0xfffff3fb
    17ec:	05220609 	streq	r0, [r2, #-1545]!	@ 0xfffff9f7
    17f0:	0501060e 	streq	r0, [r1, #-1550]	@ 0xfffff9f2
    17f4:	05300609 	ldreq	r0, [r0, #-1545]!	@ 0xfffff9f7
    17f8:	0501061a 	streq	r0, [r1, #-1562]	@ 0xfffff9e6
    17fc:	05670609 	strbeq	r0, [r7, #-1545]!	@ 0xfffff9f7
        value = value / 10;
    1800:	2e2a0307 	cdpcs	3, 2, cr0, cr10, cr7, {0}
      } while (value > 0);
    1804:	01060b05 	tsteq	r6, r5, lsl #22
    1808:	052e0a05 	streq	r0, [lr, #-2565]!	@ 0xfffff5fb
        __write_char2__('-');
    180c:	05210609 	streq	r0, [r1, #-1545]!	@ 0xfffff9f7
    1810:	7fb40303 	svcvc	0x00b40303
        value = -value;
    1814:	1305054a 	movwne	r0, #21834	@ 0x554a
        __write_char2__(num[--num_len]);
    1818:	01060a05 	tsteq	r6, r5, lsl #20
    181c:	052e0805 	streq	r0, [lr, #-2053]!	@ 0xfffff7fb
    1820:	05330605 	ldreq	r0, [r3, #-1541]!	@ 0xfffff9fb
    1824:	05010609 	streq	r0, [r1, #-1545]	@ 0xfffff9f7
    1828:	054d0605 	strbeq	r0, [sp, #-1541]	@ 0xfffff9fb
      while (num_len > 0) {
    182c:	05010608 	streq	r0, [r1, #-1544]	@ 0xfffff9f8
  return true;
    1830:	05400607 	strbeq	r0, [r0, #-1543]	@ 0xfffff9f9
          num[num_len++] = hextable2[value % 10];
    1834:	05010609 	streq	r0, [r1, #-1545]	@ 0xfffff9f7
    1838:	05220607 	streq	r0, [r2, #-1543]!	@ 0xfffff9f9
    183c:	0501060a 	streq	r0, [r1, #-1546]	@ 0xfffff9f6
    1840:	04020020 	streq	r0, [r2], #-32	@ 0xffffffe0
    1844:	07052e01 	streq	r2, [r5, -r1, lsl #28]
    1848:	0a053406 	beq	14e868 <__ROM_SIZE__+0x10e868>
    184c:	17050106 	strne	r0, [r5, -r6, lsl #2]
    1850:	01040200 	mrseq	r0, R12_usr
          value = value / 10;
    1854:	060e052e 	streq	r0, [lr], -lr, lsr #10
        } while (value > 0);
    1858:	052e0d03 	streq	r0, [lr, #-3331]!	@ 0xfffff2fd
        while (num_len > 0) {
    185c:	05010611 	streq	r0, [r1, #-1553]	@ 0xfffff9ef
          __write_char2__(num[--num_len]);
    1860:	0531060e 	ldreq	r0, [r1, #-1550]!	@ 0xfffff9f2
    1864:	05010611 	streq	r0, [r1, #-1553]	@ 0xfffff9ef
    1868:	0531060e 	ldreq	r0, [r1, #-1550]!	@ 0xfffff9f2
    186c:	0501061c 	streq	r0, [r1, #-1564]	@ 0xfffff9e4
    1870:	0e053c11 	mcreq	12, 0, r3, cr5, cr1, {0}
    1874:	1c053206 	sfmne	f3, 4, [r5], {6}
  return true;
    1878:	11050106 	tstne	r5, r6, lsl #2
              __write_char2__(hextable2[val]);
    187c:	060c053c 			@ <UNDEFINED> instruction: 0x060c053c
    1880:	052e1603 	streq	r1, [lr, #-1539]!	@ 0xfffff9fd
              leading_zero_ignored = true;
    1884:	0501060f 	streq	r0, [r1, #-1551]	@ 0xfffff9f1
          while (start_bit >= 0) {
    1888:	05340609 	ldreq	r0, [r4, #-1545]!	@ 0xfffff9f7
            int val = (value >> start_bit) & 0xF;
    188c:	05010612 	streq	r0, [r1, #-1554]	@ 0xfffff9ee
            if (val || leading_zero_ignored) {
    1890:	0905201a 	stmdbeq	r5, {r1, r3, r4, sp}
    1894:	0e055906 	vmlaeq.f16	s10, s10, s12	@ <UNPREDICTABLE>
    1898:	0b050106 	bleq	141cb8 <__ROM_SIZE__+0x101cb8>
          bool leading_zero_ignored = false;
    189c:	3c4e0306 	mcrrcc	3, 0, r0, lr, cr6
          int start_bit = LAST_NIBBLE_FIRST_BIT;
    18a0:	002b052f 	eoreq	r0, fp, pc, lsr #10
  return true;
    18a4:	06010402 	streq	r0, [r1], -r2, lsl #8
        return false;
    18a8:	053c0d03 	ldreq	r0, [ip, #-3331]!	@ 0xfffff2fd
        return false;
    18ac:	05202f15 	streq	r2, [r0, #-3861]!	@ 0xfffff0eb
    18b0:	04020029 	streq	r0, [r2], #-41	@ 0xffffffd7
    18b4:	15052201 	strne	r2, [r5, #-513]	@ 0xfffffdff
    18b8:	29052030 	stmdbcs	r5, {r4, r5, sp}
    18bc:	01040200 	mrseq	r0, R12_usr
    18c0:	06090522 	streq	r0, [r9], -r2, lsr #10
int printf2(const char *fmt, ...) {
    18c4:	060d052f 	streq	r0, [sp], -pc, lsr #10
    18c8:	2e0c0501 	cfsh32cs	mvfx0, mvfx12, #1
    18cc:	21060b05 	tstcs	r6, r5, lsl #22
  va_start(args, fmt);
    18d0:	0a030905 	beq	c3cec <__ROM_SIZE__+0x83cec>
  while (*fmt) {
    18d4:	060c054a 	streq	r0, [ip], -sl, asr #10
        if (*fmt == '%') {
    18d8:	060b0501 	streq	r0, [fp], -r1, lsl #10
        __write_char2__(*fmt);
    18dc:	4d090531 	cfstr32mi	mvfx0, [r9, #-196]	@ 0xffffff3c
        fmt++;
    18e0:	06150513 			@ <UNDEFINED> instruction: 0x06150513
  while (*fmt) {
    18e4:	21090511 	tstcs	r9, r1, lsl r5
    switch (state) {
    18e8:	03060b05 	movweq	r0, #27397	@ 0x6b05
    18ec:	09032071 	stmdbeq	r3, {r0, r4, r5, r6, sp}
          fmt++;
    18f0:	0009054a 	andeq	r0, r9, sl, asr #10
          continue;
    18f4:	03010402 	movweq	r0, #5122	@ 0x1402
        while (*fmt && ((*fmt >= '0' && *fmt <= '9') || *fmt == '-')) {
    18f8:	0200580a 	andeq	r5, r0, #655360	@ 0xa0000
    18fc:	054b0104 	strbeq	r0, [fp, #-260]	@ 0xfffffefc
    1900:	04020011 	streq	r0, [r2], #-17	@ 0xffffffef
    1904:	201c0301 	andscs	r0, ip, r1, lsl #6
    1908:	02000105 	andeq	r0, r0, #1073741825	@ 0x40000001
        switch (*fmt) {
    190c:	3d060104 	stfccs	f0, [r6, #-16]
    1910:	00060f05 	andeq	r0, r6, r5, lsl #30
    1914:	0f500205 	svceq	0x00500205
    1918:	3d030000 	stccc	0, cr0, [r3, #-0]
            __write_char2__(*fmt);
    191c:	21030501 	tstcs	r3, r1, lsl #10
    1920:	832f2f2f 			@ <UNDEFINED> instruction: 0x832f2f2f
            state = CHECK_CH;
    1924:	01040200 	mrseq	r0, R12_usr
            break;
    1928:	0005055b 	andeq	r0, r5, fp, asr r5
    192c:	13010402 	movwne	r0, #5122	@ 0x1402
            outstr2(va_arg(args, const char *));
    1930:	02000905 	andeq	r0, r0, #81920	@ 0x14000
    1934:	052d0104 	streq	r0, [sp, #-260]!	@ 0xfffffefc
    1938:	02050019 	andeq	r0, r5, #25
            fmt++;
    193c:	00000f88 	andeq	r0, r0, r8, lsl #31
            break;
    1940:	05010617 	streq	r0, [r1, #-1559]	@ 0xfffff9e9
            __write_char2__(va_arg(args, int));
    1944:	153d0603 	ldrne	r0, [sp, #-1539]!	@ 0xfffff9fd
    1948:	060a0515 			@ <UNDEFINED> instruction: 0x060a0515
    194c:	03052e01 	movweq	r2, #24065	@ 0x5e01
            fmt++;
    1950:	06053106 	streq	r3, [r5], -r6, lsl #2
            break;
    1954:	05200106 	streq	r0, [r0, #-262]!	@ 0xfffffefa
            if (*fmt == 'l') {
    1958:	05220603 	streq	r0, [r2, #-1539]!	@ 0xfffff9fd
    195c:	0501060a 	streq	r0, [r1, #-1546]	@ 0xfffff9f6
            if (printf2_numbers(*fmt, &args, l_count)) {
    1960:	11053d01 	tstne	r5, r1, lsl #26
    1964:	01040200 	mrseq	r0, R12_usr
    1968:	02003906 	andeq	r3, r0, #98304	@ 0x18000
              state = CHECK_CH;
    196c:	3c060104 	stfccs	f0, [r6], {4}
              fmt++;
    1970:	00062605 	andeq	r2, r6, r5, lsl #12
              l_count++;
    1974:	0fb40205 	svceq	0x00b40205
            if (printf2_numbers(*fmt, &args, 0)) {
    1978:	06170000 	ldreq	r0, [r7], -r0
    197c:	06030501 	streq	r0, [r3], -r1, lsl #10
              fmt++;
    1980:	0108052f 	tsteq	r8, pc, lsr #10
              break;
    1984:	01060c05 	tsteq	r6, r5, lsl #24
            return -1;
    1988:	05200305 	streq	r0, [r0, #-773]!	@ 0xfffffcfb
}
    198c:	04020033 	streq	r0, [r2], #-51	@ 0xffffffcd
    1990:	05200602 	streq	r0, [r0, #-1538]!	@ 0xfffff9fe
            return -1;
    1994:	04020029 	streq	r0, [r2], #-41	@ 0xffffffd7
    1998:	18052001 	stmdane	r5, {r0, sp}
    199c:	01040200 	mrseq	r0, R12_usr
int r32(int argc, char *argv[]) {
    19a0:	1b050106 	blne	141dc0 <__ROM_SIZE__+0x101dc0>
  if (argc < 2) {
    19a4:	01040200 	mrseq	r0, R12_usr
  uint32_t addr = atoh(argv[1]);
    19a8:	0029054a 	eoreq	r0, r9, sl, asr #10
    19ac:	20010402 	andcs	r0, r1, r2, lsl #8
  printf("0x%x: 0x%x\n", addr, data);
    19b0:	21060505 	tstcs	r6, r5, lsl #10
    19b4:	01060905 	tsteq	r6, r5, lsl #18
}
    19b8:	053c0805 	ldreq	r0, [ip, #-2053]!	@ 0xfffff7fb
    printf("Usage: %s <address> (in hex)\n", argv[0]);
    19bc:	052f0607 	streq	r0, [pc, #-1543]!	@ 13bd <sha256_init+0x9>
    19c0:	05010613 	streq	r0, [r1, #-1555]	@ 0xfffff9ed
    return -1;
    19c4:	052e2e16 	streq	r2, [lr, #-3606]!	@ 0xfffff1ea
    19c8:	0105150a 	tsteq	r5, sl, lsl #10
    19cc:	02022021 	andeq	r2, r2, #33	@ 0x21
int w32(int argc, char *argv[]) {
    19d0:	62010100 	andvs	r0, r1, #0, 2
  if (argc < 3) {
    19d4:	03000004 	movweq	r0, #4
  uint32_t addr = atoh(argv[1]);
    19d8:	00004800 	andeq	r4, r0, r0, lsl #16
    19dc:	fb010200 	blx	421e6 <__ROM_SIZE__+0x21e6>
  uint32_t data = atoh(argv[2]);
    19e0:	01000d0e 	tsteq	r0, lr, lsl #26
    19e4:	00010101 	andeq	r0, r1, r1, lsl #2
  return 0;
    19e8:	00010000 	andeq	r0, r1, r0
    printf("Usage: %s <address> (in hex) <value> (in hex)\n", argv[0]);
    19ec:	682f0100 	stmdavs	pc!, {r8}	@ <UNPREDICTABLE>
    19f0:	2f656d6f 	svccs	0x00656d6f
    return -1;
    19f4:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    19f8:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
    19fc:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
int read_mem(int argc, char *argv[]) {
    1a00:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
  if (argc < 3) {
    1a04:	68732f72 	ldmdavs	r3!, {r1, r4, r5, r6, r8, r9, sl, fp, sp}^
  uint32_t addr = atoh(argv[1]);
    1a08:	2f6c6c65 	svccs	0x006c6c65
    1a0c:	2f62696c 	svccs	0x0062696c
  uint32_t length = atoi(argv[2]);
    1a10:	65736162 	ldrbvs	r6, [r3, #-354]!	@ 0xfffffe9e
    1a14:	00003436 	andeq	r3, r0, r6, lsr r4
  for (uint32_t i = 0, data = 0; i < length; i++) {
    1a18:	65736162 	ldrbvs	r6, [r3, #-354]!	@ 0xfffffe9e
    printf("Usage: %s <address> (in hex) <num_words> (in decimal)\n", argv[0]);
    1a1c:	632e3436 			@ <UNDEFINED> instruction: 0x632e3436
    1a20:	00000100 	andeq	r0, r0, r0, lsl #2
    return -1;
    1a24:	00310500 	eorseq	r0, r1, r0, lsl #10
    1a28:	0fe40205 	svceq	0x00e40205
    printf("0x%x: 0x%x\n", addr, data);
    1a2c:	05140000 	ldreq	r0, [r4, #-0]
    1a30:	05051403 	streq	r1, [r5, #-1027]	@ 0xfffffbfd
    addr += 4;
    1a34:	03050106 	movweq	r0, #20742	@ 0x5106
  for (uint32_t i = 0, data = 0; i < length; i++) {
    1a38:	05053106 	streq	r3, [r5, #-262]	@ 0xfffffefa
  return 0;
    1a3c:	03050106 	movweq	r0, #20742	@ 0x5106
}
    1a40:	05053106 	streq	r3, [r5, #-262]	@ 0xfffffefa
    1a44:	03050106 	movweq	r0, #20742	@ 0x5106
{
    1a48:	05053106 	streq	r3, [r5, #-262]	@ 0xfffffefa
  if (argc < 4) {
    1a4c:	03050106 	movweq	r0, #20742	@ 0x5106
  uint32_t addr = atoh(argv[1]);
    1a50:	05053106 	streq	r3, [r5, #-262]	@ 0xfffffefa
    1a54:	0a050106 	beq	141e74 <__ROM_SIZE__+0x101e74>
  uint32_t bit_loc = atoi(argv[2]);
    1a58:	0e052030 	mcreq	0, 0, r2, cr5, cr0, {1}
    1a5c:	01040200 	mrseq	r0, R12_usr
  uint32_t bit_val = atoi(argv[3]);
    1a60:	20720306 	rsbscs	r0, r2, r6, lsl #6
    1a64:	02001705 	andeq	r1, r0, #1310720	@ 0x140000
  if (bit_loc > 31) {
    1a68:	01060104 	tsteq	r6, r4, lsl #2
  if (bit_val != 0 && bit_val != 1) {
    1a6c:	01040200 	mrseq	r0, R12_usr
  data = data | (bit_val << bit_loc);
    1a70:	000e0520 	andeq	r0, lr, r0, lsr #10
    1a74:	06010402 	streq	r0, [r1], -r2, lsl #8
  data = data & ~(!bit_val << bit_loc);
    1a78:	00170531 	andseq	r0, r7, r1, lsr r5
    1a7c:	06010402 	streq	r0, [r1], -r2, lsl #8
    1a80:	04020001 	streq	r0, [r2], #-1
  return 0;
    1a84:	0e052001 	cdpeq	0, 0, cr2, cr5, cr1, {0}
    printf("Error: Invalid bit location argument\n");
    1a88:	01040200 	mrseq	r0, R12_usr
    1a8c:	17053106 	strne	r3, [r5, -r6, lsl #2]
    printf("Error: Invalid bit value argument\n");
    1a90:	01040200 	mrseq	r0, R12_usr
    1a94:	02000106 	andeq	r0, r0, #-2147483647	@ 0x80000001
  printf("Usage: %s <address_in_hex(32-bits)> <bit_location_in_decimal(0 to 31)> <bit_value(0 or 1)>\n", argv[0]);
    1a98:	05200104 	streq	r0, [r0, #-260]!	@ 0xfffffefc
    1a9c:	23203116 			@ <UNDEFINED> instruction: 0x23203116
  return -1;
    1aa0:	05230105 	streq	r0, [r3, #-261]!	@ 0xfffffefb
    1aa4:	06220631 			@ <UNDEFINED> instruction: 0x06220631
    1aa8:	06030501 	streq	r0, [r3], -r1, lsl #10
    1aac:	060f0522 	streq	r0, [pc], -r2, lsr #10
{
    1ab0:	05052001 	streq	r2, [r5, #-1]
  if (argc < 3) {
    1ab4:	06030520 	streq	r0, [r3], -r0, lsr #10
  uint32_t addr = atoh(argv[1]);
    1ab8:	060f0531 			@ <UNDEFINED> instruction: 0x060f0531
    1abc:	3c050501 	cfstr32cc	mvfx0, [r5], {1}
  uint32_t bit_loc = atoi(argv[2]);
    1ac0:	31060305 	tstcc	r6, r5, lsl #6
    1ac4:	01060f05 	tsteq	r6, r5, lsl #30
  if (bit_loc > 31) {
    1ac8:	053c0505 	ldreq	r0, [ip, #-1285]!	@ 0xfffffafb
  uint32_t data = reg32(addr);
    1acc:	05310603 	ldreq	r0, [r1, #-1539]!	@ 0xfffff9fd
  printf("Bit %u @ 0x%08x: %u\n", bit_loc, addr, bit_val);
    1ad0:	05010605 	streq	r0, [r1, #-1541]	@ 0xfffff9fb
    1ad4:	05310603 	ldreq	r0, [r1, #-1539]!	@ 0xfffff9fd
    1ad8:	05010605 	streq	r0, [r1, #-1541]	@ 0xfffff9fb
  return 0;
    1adc:	1c05300a 	stcne	0, cr3, [r5], {10}
    printf("Error: Invalid bit location argument\n");
    1ae0:	01040200 	mrseq	r0, R12_usr
    1ae4:	2e750306 	cdpcs	3, 7, cr0, cr5, cr6, {0}
  printf("Usage: %s <address_in_hex(32-bits)> <bit_location_in_decimal(0 to 31)\n", argv[0]);
    1ae8:	02002505 	andeq	r2, r0, #20971520	@ 0x1400000
    1aec:	01060104 	tsteq	r6, r4, lsl #2
  return -1;
    1af0:	02001c05 	andeq	r1, r0, #1280	@ 0x500
    1af4:	3f060104 	svccc	0x00060104
    1af8:	02002505 	andeq	r2, r0, #20971520	@ 0x1400000
    1afc:	01060104 	tsteq	r6, r4, lsl #2
{
    1b00:	313f1705 	teqcc	pc, r5, lsl #14
  for (i = 0; i < Nk; ++i)
    1b04:	05230105 	streq	r0, [r3, #-261]!	@ 0xfffffefb
    RoundKey[(i * 4) + 0] = Key[(i * 4) + 0];
    1b08:	0522063e 	streq	r0, [r2, #-1598]!	@ 0xfffff9c2
    1b0c:	18051303 	stmdane	r5, {r0, r1, r8, r9, ip}
    1b10:	1c050106 	stfnes	f0, [r5], {6}
    RoundKey[(i * 4) + 1] = Key[(i * 4) + 1];
    1b14:	01053c20 	tsteq	r5, r0, lsr #24
    RoundKey[(i * 4) + 2] = Key[(i * 4) + 2];
    1b18:	06550521 	ldrbeq	r0, [r5], -r1, lsr #10
    1b1c:	0501065a 	streq	r0, [r1, #-1626]	@ 0xfffff9a6
    RoundKey[(i * 4) + 3] = Key[(i * 4) + 3];
    1b20:	143d0603 	ldrtne	r0, [sp], #-1539	@ 0xfffff9fd
  for (i = 0; i < Nk; ++i)
    1b24:	01060805 	tsteq	r6, r5, lsl #16
    1b28:	2f060505 	svccs	0x00060505
  for (i = Nk; i < Nb * (Nr + 1); ++i)
    1b2c:	051f2905 	ldreq	r2, [pc, #-2309]	@ 122f <decode_base64+0xab>
    if (i % Nk == 4)
    1b30:	05010609 	streq	r0, [r1, #-1545]	@ 0xfffff9f7
    j = i * 4; k=(i - Nk) * 4;
    1b34:	42053c29 	andmi	r3, r5, #10496	@ 0x2900
    RoundKey[j + 0] = RoundKey[k + 0] ^ tempa[0];
    1b38:	01040200 	mrseq	r0, R12_usr
    1b3c:	0029052e 	eoreq	r0, r9, lr, lsr #10
    1b40:	20010402 	andcs	r0, r1, r2, lsl #8
    1b44:	32060305 	andcc	r0, r6, #335544320	@ 0x14000000
    RoundKey[j + 1] = RoundKey[k + 1] ^ tempa[1];
    1b48:	01061805 	tsteq	r6, r5, lsl #16
    1b4c:	21060305 	tstcs	r6, r5, lsl #6
    1b50:	01061605 	tsteq	r6, r5, lsl #12
    1b54:	05201805 	streq	r1, [r0, #-2053]!	@ 0xfffff7fb
    1b58:	002e2e46 	eoreq	r2, lr, r6, asr #28
    1b5c:	20010402 	andcs	r0, r1, r2, lsl #8
    RoundKey[j + 2] = RoundKey[k + 2] ^ tempa[2];
    1b60:	02000105 	andeq	r0, r0, #1073741825	@ 0x40000001
    1b64:	05210404 	streq	r0, [r1, #-1028]!	@ 0xfffffbfc
    1b68:	66052d46 	strvs	r2, [r5], -r6, asr #26
    1b6c:	02050006 	andeq	r0, r5, #6
    RoundKey[j + 3] = RoundKey[k + 3] ^ tempa[3];
    1b70:	0000109c 	muleq	r0, ip, r0
    1b74:	05010615 	streq	r0, [r1, #-1557]	@ 0xfffff9eb
    1b78:	05590603 	ldrbeq	r0, [r9, #-1539]	@ 0xfffff9fd
  for (i = Nk; i < Nb * (Nr + 1); ++i)
    1b7c:	05010610 	streq	r0, [r1, #-1552]	@ 0xfffff9f0
    1b80:	054d0603 	strbeq	r0, [sp, #-1539]	@ 0xfffff9fd
      tempa[0]=RoundKey[k + 0];
    1b84:	14050107 	strne	r0, [r5], #-263	@ 0xfffffef9
    1b88:	03050106 	movweq	r0, #20742	@ 0x5106
      tempa[1]=RoundKey[k + 1];
    1b8c:	00050520 	andeq	r0, r5, r0, lsr #10
    1b90:	06030402 	streq	r0, [r3], -r2, lsl #8
    1b94:	00400521 	subeq	r0, r0, r1, lsr #10
      tempa[2]=RoundKey[k + 2];
    1b98:	06030402 	streq	r0, [r3], -r2, lsl #8
    1b9c:	00110501 	andseq	r0, r1, r1, lsl #10
      tempa[3]=RoundKey[k + 3];
    1ba0:	20030402 	andcs	r0, r3, r2, lsl #8
    1ba4:	02000f05 	andeq	r0, r0, #5, 30
    if (i % Nk == 0)
    1ba8:	053c0304 	ldreq	r0, [ip, #-772]!	@ 0xfffffcfc
        tempa[0] = tempa[1];
    1bac:	04020005 	streq	r0, [r2], #-5
        tempa[1] = tempa[2];
    1bb0:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
        tempa[2] = tempa[3];
    1bb4:	04020028 	streq	r0, [r2], #-40	@ 0xffffffd8
        tempa[3] = u8tmp;
    1bb8:	05010603 	streq	r0, [r1, #-1539]	@ 0xfffff9fd
        tempa[0] = getSBoxValue(tempa[0]);
    1bbc:	04020034 	streq	r0, [r2], #-52	@ 0xffffffcc
    1bc0:	40052003 	andmi	r2, r5, r3
        tempa[1] = getSBoxValue(tempa[1]);
    1bc4:	03040200 	movweq	r0, #16896	@ 0x4200
    1bc8:	0011053c 	andseq	r0, r1, ip, lsr r5
        tempa[2] = getSBoxValue(tempa[2]);
    1bcc:	20030402 	andcs	r0, r3, r2, lsl #8
    1bd0:	02000f05 	andeq	r0, r0, #5, 30
        tempa[3] = getSBoxValue(tempa[3]);
    1bd4:	054a0304 	strbeq	r0, [sl, #-772]	@ 0xfffffcfc
    1bd8:	04020005 	streq	r0, [r2], #-5
      tempa[0] = tempa[0] ^ Rcon[i/Nk];
    1bdc:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
    1be0:	04020028 	streq	r0, [r2], #-40	@ 0xffffffd8
    1be4:	05010603 	streq	r0, [r1, #-1539]	@ 0xfffff9fd
    1be8:	04020034 	streq	r0, [r2], #-52	@ 0xffffffcc
        tempa[0] = getSBoxValue(tempa[0]);
    1bec:	40052003 	andmi	r2, r5, r3
    1bf0:	03040200 	movweq	r0, #16896	@ 0x4200
    1bf4:	0011053c 	andseq	r0, r1, ip, lsr r5
        tempa[1] = getSBoxValue(tempa[1]);
    1bf8:	20030402 	andcs	r0, r3, r2, lsl #8
    1bfc:	02000f05 	andeq	r0, r0, #5, 30
        tempa[2] = getSBoxValue(tempa[2]);
    1c00:	054a0304 	strbeq	r0, [sl, #-772]	@ 0xfffffcfc
    1c04:	04020005 	streq	r0, [r2], #-5
    1c08:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
        tempa[3] = getSBoxValue(tempa[3]);
    1c0c:	04020028 	streq	r0, [r2], #-40	@ 0xffffffd8
    1c10:	05010603 	streq	r0, [r1, #-1539]	@ 0xfffff9fd
    1c14:	04020011 	streq	r0, [r2], #-17	@ 0xffffffef
}
    1c18:	0f052003 	svceq	0x00052003
    1c1c:	03040200 	movweq	r0, #16896	@ 0x4200
{
    1c20:	0005054a 	andeq	r0, r5, sl, asr #10
  for (i = 0; i < 4; ++i)
    1c24:	06030402 	streq	r0, [r3], -r2, lsl #8
      (*state)[i][j] ^= RoundKey[(round * Nb * 4) + (i * Nb) + j];
    1c28:	000b0522 	andeq	r0, fp, r2, lsr #10
    1c2c:	06030402 	streq	r0, [r3], -r2, lsl #8
    1c30:	00050501 	andeq	r0, r5, r1, lsl #10
    1c34:	06030402 	streq	r0, [r3], -r2, lsl #8
    1c38:	000c0521 	andeq	r0, ip, r1, lsr #10
    1c3c:	06030402 	streq	r0, [r3], -r2, lsl #8
    1c40:	002a0501 	eoreq	r0, sl, r1, lsl #10
    for (j = 0; j < 4; ++j)
    1c44:	06030402 	streq	r0, [r3], -r2, lsl #8
    1c48:	05207903 	streq	r7, [r0, #-2307]!	@ 0xfffff6fd
  for (i = 0; i < 4; ++i)
    1c4c:	0402001d 	streq	r0, [r2], #-29	@ 0xffffffe3
    1c50:	02002001 	andeq	r2, r0, #1
    for (j = 0; j < 4; ++j)
    1c54:	2e060104 	adfcss	f0, f6, f4
  for (i = 0; i < 4; ++i)
    1c58:	03060305 	movweq	r0, #25349	@ 0x6305
    1c5c:	1705010a 	strne	r0, [r5, -sl, lsl #2]
    for (j = 0; j < 4; ++j)
    1c60:	03050106 	movweq	r0, #20742	@ 0x5106
{
    1c64:	14030690 	strne	r0, [r3], #-1680	@ 0xfffff970
      (*state)[j][i] = getSBoxValue((*state)[j][i]);
    1c68:	060a0558 			@ <UNDEFINED> instruction: 0x060a0558
    1c6c:	3d010501 	cfstr32cc	mvfx0, [r1, #-4]
    1c70:	03060705 	movweq	r0, #26373	@ 0x6705
    1c74:	11052e6d 	tstne	r5, sp, ror #28
    for (j = 0; j < 4; ++j)
    1c78:	07050106 	streq	r0, [r5, -r6, lsl #2]
    1c7c:	05222106 	streq	r2, [r2, #-262]!	@ 0xfffffefa
  for (i = 0; i < 4; ++i)
    1c80:	05010642 	streq	r0, [r1, #-1602]	@ 0xfffff9be
    1c84:	11052013 	tstne	r5, r3, lsl r0
    for (j = 0; j < 4; ++j)
    1c88:	0607053c 			@ <UNDEFINED> instruction: 0x0607053c
}
    1c8c:	062a0521 	strteq	r0, [sl], -r1, lsr #10
  for (i = 0; i < 4; ++i)
    1c90:	20360501 	eorscs	r0, r6, r1, lsl #10
    1c94:	05201305 	streq	r1, [r0, #-773]!	@ 0xfffffcfb
    1c98:	07054a11 	smladeq	r5, r1, sl, r4
  temp           = (*state)[0][1];
    1c9c:	11052106 	tstne	r5, r6, lsl #2
  (*state)[0][1] = (*state)[1][1];
    1ca0:	07050106 	streq	r0, [r5, -r6, lsl #2]
  (*state)[1][1] = (*state)[2][1];
    1ca4:	11052f06 	tstne	r5, r6, lsl #30
  (*state)[2][1] = (*state)[3][1];
    1ca8:	07050106 	streq	r0, [r5, -r6, lsl #2]
  temp           = (*state)[0][2];
    1cac:	11052106 	tstne	r5, r6, lsl #2
  (*state)[0][2] = (*state)[2][2];
    1cb0:	07050106 	streq	r0, [r5, -r6, lsl #2]
  temp           = (*state)[1][2];
    1cb4:	05222f06 	streq	r2, [r2, #-3846]!	@ 0xfffff0fa
  (*state)[1][2] = (*state)[3][2];
    1cb8:	05010642 	streq	r0, [r1, #-1602]	@ 0xfffff9be
  temp           = (*state)[0][3];
    1cbc:	11052013 	tstne	r5, r3, lsl r0
  (*state)[0][3] = (*state)[3][3];
    1cc0:	0607053c 			@ <UNDEFINED> instruction: 0x0607053c
  (*state)[3][3] = (*state)[2][3];
    1cc4:	062a0521 	strteq	r0, [sl], -r1, lsr #10
  (*state)[2][3] = (*state)[1][3];
    1cc8:	20360501 	eorscs	r0, r6, r1, lsl #10
}
    1ccc:	053c4205 	ldreq	r4, [ip, #-517]!	@ 0xfffffdfb
  return ((x<<1) ^ (((x>>7) & 1) * 0x1b));
    1cd0:	11052013 	tstne	r5, r3, lsl r0
    1cd4:	0607054a 	streq	r0, [r7], -sl, asr #10
    1cd8:	062a0521 	strteq	r0, [sl], -r1, lsr #10
}
    1cdc:	20360501 	eorscs	r0, r6, r1, lsl #10
{
    1ce0:	05201305 	streq	r1, [r0, #-773]!	@ 0xfffffcfb
    1ce4:	07054a11 	smladeq	r5, r1, sl, r4
  for (i = 0; i < 4; ++i)
    1ce8:	11052106 	tstne	r5, r6, lsl #2
    t   = (*state)[i][0];
    1cec:	07050106 	streq	r0, [r5, -r6, lsl #2]
    Tmp = (*state)[i][0] ^ (*state)[i][1] ^ (*state)[i][2] ^ (*state)[i][3] ;
    1cf0:	11052f06 	tstne	r5, r6, lsl #30
    1cf4:	07050106 	streq	r0, [r5, -r6, lsl #2]
    1cf8:	66052f06 	strvs	r2, [r5], -r6, lsl #30
    1cfc:	84020500 	strhi	r0, [r2], #-1280	@ 0xfffffb00
    1d00:	19000011 	stmdbne	r0, {r0, r4}
    1d04:	03050106 	movweq	r0, #20742	@ 0x5106
    Tm  = (*state)[i][0] ^ (*state)[i][1] ; Tm = xtime(Tm);  (*state)[i][0] ^= Tm ^ Tmp ;
    1d08:	20054b06 	andcs	r4, r5, r6, lsl #22
    1d0c:	052e0106 	streq	r0, [lr, #-262]!	@ 0xfffffefa
    1d10:	05230603 	streq	r0, [r3, #-1539]!	@ 0xfffff9fd
    Tm  = (*state)[i][1] ^ (*state)[i][2] ; Tm = xtime(Tm);  (*state)[i][1] ^= Tm ^ Tmp ;
    1d14:	14050107 	strne	r0, [r5], #-263	@ 0xfffffef9
    1d18:	03050106 	movweq	r0, #20742	@ 0x5106
    1d1c:	00050520 	andeq	r0, r5, r0, lsr #10
    1d20:	06030402 	streq	r0, [r3], -r2, lsl #8
    1d24:	00110521 	andseq	r0, r1, r1, lsr #10
    Tm  = (*state)[i][2] ^ (*state)[i][3] ; Tm = xtime(Tm);  (*state)[i][2] ^= Tm ^ Tmp ;
    1d28:	06030402 	streq	r0, [r3], -r2, lsl #8
    1d2c:	002c0501 	eoreq	r0, ip, r1, lsl #10
    1d30:	3c030402 	cfstrscc	mvf0, [r3], {2}
    1d34:	02003305 	andeq	r3, r0, #335544320	@ 0x14000000
    Tm  = (*state)[i][3] ^ t ;              Tm = xtime(Tm);  (*state)[i][3] ^= Tm ^ Tmp ;
    1d38:	05200304 	streq	r0, [r0, #-772]!	@ 0xfffffcfc
    1d3c:	04020031 	streq	r0, [r2], #-49	@ 0xffffffcf
    1d40:	0f053c03 	svceq	0x00053c03
    1d44:	03040200 	movweq	r0, #16896	@ 0x4200
    1d48:	0005052e 	andeq	r0, r5, lr, lsr #10
  for (i = 0; i < 4; ++i)
    1d4c:	06030402 	streq	r0, [r3], -r2, lsl #8
    1d50:	00110521 	andseq	r0, r1, r1, lsr #10
}
    1d54:	06030402 	streq	r0, [r3], -r2, lsl #8
{
    1d58:	002c0501 	eoreq	r0, ip, r1, lsl #10
    1d5c:	3c030402 	cfstrscc	mvf0, [r3], {2}
  for (i = 0; i < 4; ++i)
    1d60:	02003305 	andeq	r3, r0, #335544320	@ 0x14000000
    a = (*state)[i][0];
    1d64:	05200304 	streq	r0, [r0, #-772]!	@ 0xfffffcfc
    b = (*state)[i][1];
    1d68:	04020031 	streq	r0, [r2], #-49	@ 0xffffffcf
    1d6c:	0f053c03 	svceq	0x00053c03
    c = (*state)[i][2];
    1d70:	03040200 	movweq	r0, #16896	@ 0x4200
    d = (*state)[i][3];
    1d74:	0005052e 	andeq	r0, r5, lr, lsr #10
    (*state)[i][0] = Multiply(a, 0x0e) ^ Multiply(b, 0x0b) ^ Multiply(c, 0x0d) ^ Multiply(d, 0x09);
    1d78:	06030402 	streq	r0, [r3], -r2, lsl #8
    1d7c:	00110521 	andseq	r0, r1, r1, lsr #10
    1d80:	06030402 	streq	r0, [r3], -r2, lsl #8
    1d84:	002c0501 	eoreq	r0, ip, r1, lsl #10
    1d88:	3c030402 	cfstrscc	mvf0, [r3], {2}
    1d8c:	02003305 	andeq	r3, r0, #335544320	@ 0x14000000
    1d90:	05200304 	streq	r0, [r0, #-772]!	@ 0xfffffcfc
    1d94:	04020031 	streq	r0, [r2], #-49	@ 0xffffffcf
    1d98:	0f053c03 	svceq	0x00053c03
    1d9c:	03040200 	movweq	r0, #16896	@ 0x4200
    1da0:	00050520 	andeq	r0, r5, r0, lsr #10
    1da4:	06030402 	streq	r0, [r3], -r2, lsl #8
    1da8:	000b0522 	andeq	r0, fp, r2, lsr #10
    1dac:	06030402 	streq	r0, [r3], -r2, lsl #8
    1db0:	00050501 	andeq	r0, r5, r1, lsl #10
    1db4:	06030402 	streq	r0, [r3], -r2, lsl #8
    1db8:	000c0521 	andeq	r0, ip, r1, lsr #10
    1dbc:	06030402 	streq	r0, [r3], -r2, lsl #8
    1dc0:	00300501 	eorseq	r0, r0, r1, lsl #10
    1dc4:	06030402 	streq	r0, [r3], -r2, lsl #8
    1dc8:	05207a03 	streq	r7, [r0, #-2563]!	@ 0xfffff5fd
    1dcc:	0402001d 	streq	r0, [r2], #-29	@ 0xffffffe3
    1dd0:	02002001 	andeq	r2, r0, #1
    1dd4:	2e060104 	adfcss	f0, f6, f4
    1dd8:	03060305 	movweq	r0, #25349	@ 0x6305
    1ddc:	18050109 	stmdane	r5, {r0, r3, r8}
    1de0:	03050106 	movweq	r0, #20742	@ 0x5106
    1de4:	03010590 	movweq	r0, #5520	@ 0x1590
    1de8:	07054a0b 	streq	r4, [r5, -fp, lsl #20]
    1dec:	3c770306 	ldclcc	3, cr0, [r7], #-24	@ 0xffffffe8
    1df0:	01061305 	tsteq	r6, r5, lsl #6
    1df4:	053c2e05 	ldreq	r2, [ip, #-3589]!	@ 0xfffff1fb
    1df8:	33052035 	movwcc	r2, #20533	@ 0x5035
    1dfc:	2e11053c 	mrccs	5, 0, r0, cr1, cr12, {1}
    1e00:	21060705 	tstcs	r6, r5, lsl #14
    1e04:	06130522 	ldreq	r0, [r3], -r2, lsr #10
    (*state)[i][1] = Multiply(a, 0x09) ^ Multiply(b, 0x0e) ^ Multiply(c, 0x0b) ^ Multiply(d, 0x0d);
    1e08:	3c2e0501 	cfstr32cc	mvfx0, [lr], #-4
    1e0c:	05203505 	streq	r3, [r0, #-1285]!	@ 0xfffffafb
    1e10:	11053c33 	tstne	r5, r3, lsr ip
    1e14:	0607052e 	streq	r0, [r7], -lr, lsr #10
    1e18:	06130521 	ldreq	r0, [r3], -r1, lsr #10
    1e1c:	3c2e0501 	cfstr32cc	mvfx0, [lr], #-4
    1e20:	05203505 	streq	r3, [r0, #-1285]!	@ 0xfffffafb
    1e24:	11053c33 	tstne	r5, r3, lsr ip
    1e28:	0607052e 	streq	r0, [r7], -lr, lsr #10
    1e2c:	15030521 	strne	r0, [r3, #-1313]	@ 0xfffffadf
    1e30:	01060a05 	tsteq	r6, r5, lsl #20
    1e34:	01000402 	tsteq	r0, r2, lsl #8
    1e38:	0005f401 	andeq	pc, r5, r1, lsl #8
    1e3c:	d1000300 	mrsle	r0, LR_irq
    (*state)[i][2] = Multiply(a, 0x0d) ^ Multiply(b, 0x09) ^ Multiply(c, 0x0e) ^ Multiply(d, 0x0b);
    1e40:	02000000 	andeq	r0, r0, #0
    1e44:	0d0efb01 	vstreq	d15, [lr, #-4]
    1e48:	01010100 	mrseq	r0, (UNDEF: 17)
    1e4c:	00000001 	andeq	r0, r0, r1
    1e50:	01000001 	tsteq	r0, r1
    1e54:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 1da0 <InvMixColumns+0x4a>
    1e58:	63652f65 	cmnvs	r5, #404	@ 0x194
    1e5c:	652f6674 	strvs	r6, [pc, #-1652]!	@ 17f0 <printf2_numbers+0x6c>
    1e60:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
    1e64:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
    1e68:	2f72656e 	svccs	0x0072656e
    1e6c:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
    (*state)[i][3] = Multiply(a, 0x0b) ^ Multiply(b, 0x0d) ^ Multiply(c, 0x09) ^ Multiply(d, 0x0e);
    1e70:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
    1e74:	68732f62 	ldmdavs	r3!, {r1, r5, r6, r8, r9, sl, fp, sp}^
    1e78:	36353261 	ldrtcc	r3, [r5], -r1, ror #4
    1e7c:	706f2f00 	rsbvc	r2, pc, r0, lsl #30
    1e80:	63672f74 	cmnvs	r7, #116, 30	@ 0x1d0
    1e84:	72612d63 	rsbvc	r2, r1, #6336	@ 0x18c0
    1e88:	6f6e2d6d 	svcvs	0x006e2d6d
    1e8c:	652d656e 	strvs	r6, [sp, #-1390]!	@ 0xfffffa92
    1e90:	2f696261 	svccs	0x00696261
    1e94:	2f62696c 	svccs	0x0062696c
    1e98:	2f636367 	svccs	0x00636367
    1e9c:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	@ 0xfffffe7c
    1ea0:	656e6f6e 	strbvs	r6, [lr, #-3950]!	@ 0xfffff092
  for (i = 0; i < 4; ++i)
    1ea4:	6261652d 	rsbvs	r6, r1, #188743680	@ 0xb400000
    1ea8:	32312f69 	eorscc	r2, r1, #420	@ 0x1a4
}
    1eac:	312e322e 			@ <UNDEFINED> instruction: 0x312e322e
  for (i = 0; i < 4; ++i)
    1eb0:	636e692f 	cmnvs	lr, #770048	@ 0xbc000
    1eb4:	6564756c 	strbvs	r7, [r4, #-1388]!	@ 0xfffffa94
    for (j = 0; j < 4; ++j)
    1eb8:	6f682f00 	svcvs	0x00682f00
{
    1ebc:	652f656d 	strvs	r6, [pc, #-1389]!	@ 1957 <printf2+0x93>
      (*state)[j][i] = getSBoxInvert((*state)[j][i]);
    1ec0:	2f667463 	svccs	0x00667463
    1ec4:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    1ec8:	6172742d 	cmnvs	r2, sp, lsr #8
    1ecc:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
    1ed0:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
    for (j = 0; j < 4; ++j)
    1ed4:	6c2f6c6c 	stcvs	12, cr6, [pc], #-432	@ 1d2c <MixColumns+0x4c>
    1ed8:	732f6269 			@ <UNDEFINED> instruction: 0x732f6269
  for (i = 0; i < 4; ++i)
    1edc:	6e697274 	mcrvs	2, 3, r7, cr9, cr4, {3}
    1ee0:	73000067 	movwvc	r0, #103	@ 0x67
    for (j = 0; j < 4; ++j)
    1ee4:	35326168 	ldrcc	r6, [r2, #-360]!	@ 0xfffffe98
}
    1ee8:	00632e36 	rsbeq	r2, r3, r6, lsr lr
  for (i = 0; i < 4; ++i)
    1eec:	73000001 	movwvc	r0, #1
    1ef0:	65646474 	strbvs	r6, [r4, #-1140]!	@ 0xfffffb8c
    1ef4:	00682e66 	rsbeq	r2, r8, r6, ror #28
  temp = (*state)[3][1];
    1ef8:	73000002 	movwvc	r0, #2
  (*state)[3][1] = (*state)[2][1];
    1efc:	35326168 	ldrcc	r6, [r2, #-360]!	@ 0xfffffe98
  (*state)[2][1] = (*state)[1][1];
    1f00:	00682e36 	rsbeq	r2, r8, r6, lsr lr
  (*state)[1][1] = (*state)[0][1];
    1f04:	73000001 	movwvc	r0, #1
  temp = (*state)[0][2];
    1f08:	6e697274 	mcrvs	2, 3, r7, cr9, cr4, {3}
  (*state)[0][2] = (*state)[2][2];
    1f0c:	00682e67 	rsbeq	r2, r8, r7, ror #28
  temp = (*state)[1][2];
    1f10:	00000003 	andeq	r0, r0, r3
  (*state)[1][2] = (*state)[3][2];
    1f14:	05000105 	streq	r0, [r0, #-261]	@ 0xfffffefb
  temp = (*state)[0][3];
    1f18:	00124002 	andseq	r4, r2, r2
  (*state)[0][3] = (*state)[1][3];
    1f1c:	012c0300 			@ <UNDEFINED> instruction: 0x012c0300
  (*state)[1][3] = (*state)[2][3];
    1f20:	02050106 	andeq	r0, r5, #-2147483647	@ 0x80000001
  (*state)[2][3] = (*state)[3][3];
    1f24:	05144b06 	ldreq	r4, [r4, #-2822]	@ 0xfffff4fa
}
    1f28:	05010610 	streq	r0, [r1, #-1552]	@ 0xfffff9f0
{
    1f2c:	02052009 	andeq	r2, r5, #9
  AddRoundKey(0, state, RoundKey);
    1f30:	00030520 	andeq	r0, r3, r0, lsr #10
    1f34:	06030402 	streq	r0, [r3], -r2, lsl #8
    1f38:	000f0521 	andeq	r0, pc, r1, lsr #10
  for (round = 1; ; ++round)
    1f3c:	06030402 	streq	r0, [r3], -r2, lsl #8
    MixColumns(state);
    1f40:	00210501 	eoreq	r0, r1, r1, lsl #10
    AddRoundKey(round, state, RoundKey);
    1f44:	20030402 	andcs	r0, r3, r2, lsl #8
    1f48:	02002905 	andeq	r2, r0, #81920	@ 0x14000
    1f4c:	052e0304 	streq	r0, [lr, #-772]!	@ 0xfffffcfc
  for (round = 1; ; ++round)
    1f50:	0402001a 	streq	r0, [r2], #-26	@ 0xffffffe6
    SubBytes(state);
    1f54:	37052003 	strcc	r2, [r5, -r3]
    ShiftRows(state);
    1f58:	03040200 	movweq	r0, #16896	@ 0x4200
    1f5c:	0030052e 	eorseq	r0, r0, lr, lsr #10
    if (round == Nr) {
    1f60:	20030402 	andcs	r0, r3, r2, lsl #8
  AddRoundKey(Nr, state, RoundKey);
    1f64:	02004c05 	andeq	r4, r0, #1280	@ 0x500
    1f68:	052e0304 	streq	r0, [lr, #-772]!	@ 0xfffffcfc
}
    1f6c:	04020045 	streq	r0, [r2], #-69	@ 0xffffffbb
{
    1f70:	08052003 	stmdaeq	r5, {r0, r1, sp}
  AddRoundKey(Nr, state, RoundKey);
    1f74:	03040200 	movweq	r0, #16896	@ 0x4200
    1f78:	00200520 	eoreq	r0, r0, r0, lsr #10
    1f7c:	06030402 	streq	r0, [r3], -r2, lsl #8
  for (round = (Nr - 1); ; --round)
    1f80:	001d053b 	andseq	r0, sp, fp, lsr r5
    InvMixColumns(state);
    1f84:	06030402 	streq	r0, [r3], -r2, lsl #8
  for (round = (Nr - 1); ; --round)
    1f88:	00240501 	eoreq	r0, r4, r1, lsl #10
    InvShiftRows(state);
    1f8c:	20030402 	andcs	r0, r3, r2, lsl #8
    1f90:	02001705 	andeq	r1, r0, #1310720	@ 0x140000
    InvSubBytes(state);
    1f94:	20060104 	andcs	r0, r6, r4, lsl #2
    AddRoundKey(round, state, RoundKey);
    1f98:	02000305 	andeq	r0, r0, #335544320	@ 0x14000000
    1f9c:	053f0204 	ldreq	r0, [pc, #-516]!	@ 1da0 <InvMixColumns+0x4a>
    1fa0:	0402000a 	streq	r0, [r2], #-10
    if (round == 0) {
    1fa4:	05010602 	streq	r0, [r1, #-1538]	@ 0xfffff9fe
  for (i = 0; i < AES_BLOCKLEN; ++i) // The block in AES is always 128bit no matter the key size
    1fa8:	0402001f 	streq	r0, [r2], #-31	@ 0xffffffe1
    buf[i] ^= Iv[i];
    1fac:	1c059e02 	stcne	14, cr9, [r5], {2}
    1fb0:	02040200 	andeq	r0, r4, #0, 4
    1fb4:	00190520 	andseq	r0, r9, r0, lsr #10
  for (i = 0; i < AES_BLOCKLEN; ++i) // The block in AES is always 128bit no matter the key size
    1fb8:	3c020402 	cfstrscc	mvf0, [r2], {2}
    1fbc:	02002605 	andeq	r2, r0, #5242880	@ 0x500000
}
    1fc0:	05200204 	streq	r0, [r0, #-516]!	@ 0xfffffdfc
  KeyExpansion(ctx->RoundKey, key);
    1fc4:	04020024 	streq	r0, [r2], #-36	@ 0xffffffdc
}
    1fc8:	3c059e02 	stccc	14, cr9, [r5], {2}
{
    1fcc:	02040200 	andeq	r0, r4, #0, 4
  KeyExpansion(ctx->RoundKey, key);
    1fd0:	00390520 	eorseq	r0, r9, r0, lsr #10
  memcpy (ctx->Iv, iv, AES_BLOCKLEN);
    1fd4:	2e020402 	cdpcs	4, 0, cr0, cr2, cr2, {0}
    1fd8:	02003605 	andeq	r3, r0, #5242880	@ 0x500000
    1fdc:	053c0204 	ldreq	r0, [ip, #-516]!	@ 0xfffffdfc
}
    1fe0:	04020008 	streq	r0, [r2], #-8
  memcpy (ctx->Iv, iv, AES_BLOCKLEN);
    1fe4:	12052002 	andne	r2, r5, #2
    1fe8:	02040200 	andeq	r0, r4, #0, 4
}
    1fec:	0c052d06 	stceq	13, cr2, [r5], {6}
{
    1ff0:	01040200 	mrseq	r0, R12_usr
  Cipher((state_t*)buf, ctx->RoundKey);
    1ff4:	31020520 	tstcc	r2, r0, lsr #10
    1ff8:	01060405 	tsteq	r6, r5, lsl #8
{
    1ffc:	2f060205 	svccs	0x00060205
  InvCipher((state_t*)buf, ctx->RoundKey);
    2000:	01060405 	tsteq	r6, r5, lsl #8
    2004:	2f060205 	svccs	0x00060205
}
    2008:	01060405 	tsteq	r6, r5, lsl #8
{
    200c:	2f060205 	svccs	0x00060205
    2010:	01060405 	tsteq	r6, r5, lsl #8
  uint8_t *Iv = ctx->Iv;
    2014:	2f060205 	svccs	0x00060205
    2018:	01060405 	tsteq	r6, r5, lsl #8
  for (i = 0; i < length; i += AES_BLOCKLEN)
    201c:	0602052e 	streq	r0, [r2], -lr, lsr #10
    XorWithIv(buf, Iv);
    2020:	06040521 	streq	r0, [r4], -r1, lsr #10
    Cipher((state_t*)buf, ctx->RoundKey);
    2024:	06020501 	streq	r0, [r2], -r1, lsl #10
    2028:	0604053d 			@ <UNDEFINED> instruction: 0x0604053d
  for (i = 0; i < length; i += AES_BLOCKLEN)
    202c:	06020501 	streq	r0, [r2], -r1, lsl #10
    buf += AES_BLOCKLEN;
    2030:	0604053d 			@ <UNDEFINED> instruction: 0x0604053d
  for (i = 0; i < length; i += AES_BLOCKLEN)
    2034:	06020501 	streq	r0, [r2], -r1, lsl #10
  memcpy(ctx->Iv, Iv, AES_BLOCKLEN);
    2038:	0604053e 			@ <UNDEFINED> instruction: 0x0604053e
    203c:	1f1f1c10 	svcne	0x001f1c10
}
    2040:	0309051f 	movweq	r0, #38175	@ 0x951f
{
    2044:	05202009 	streq	r2, [r0, #-9]!
    2048:	03055802 	movweq	r5, #22530	@ 0x5802
    204c:	03040200 	movweq	r0, #16896	@ 0x4200
  for (i = 0; i < length; i += AES_BLOCKLEN)
    2050:	0c052106 	stfeqs	f2, [r5], {6}
    memcpy(storeNextIv, buf, AES_BLOCKLEN);
    2054:	03040200 	movweq	r0, #16896	@ 0x4200
    2058:	0a050106 	beq	142478 <__ROM_SIZE__+0x102478>
    InvCipher((state_t*)buf, ctx->RoundKey);
    205c:	03040200 	movweq	r0, #16896	@ 0x4200
    2060:	00150566 	andseq	r0, r5, r6, ror #10
    XorWithIv(buf, ctx->Iv);
    2064:	20030402 	andcs	r0, r3, r2, lsl #8
    2068:	03040200 	movweq	r0, #16896	@ 0x4200
    206c:	0013052e 	andseq	r0, r3, lr, lsr #10
    memcpy(ctx->Iv, storeNextIv, AES_BLOCKLEN);
    2070:	4a030402 	bmi	c3080 <__ROM_SIZE__+0x83080>
    2074:	02002205 	andeq	r2, r0, #1342177280	@ 0x50000000
    2078:	05200304 	streq	r0, [r0, #-772]!	@ 0xfffffcfc
  for (i = 0; i < length; i += AES_BLOCKLEN)
    207c:	0402001f 	streq	r0, [r2], #-31	@ 0xffffffe1
    2080:	29053c03 	stmdbcs	r5, {r0, r1, sl, fp, ip, sp}
}
    2084:	03040200 	movweq	r0, #16896	@ 0x4200
{
    2088:	0006052e 	andeq	r0, r6, lr, lsr #10
    208c:	3c030402 	cfstrscc	mvf0, [r3], {2}
    2090:	02000305 	andeq	r0, r0, #335544320	@ 0x14000000
  for (i = 0, bi = AES_BLOCKLEN; i < length; ++i, ++bi)
    2094:	21060304 	tstcs	r6, r4, lsl #6
          ctx->Iv[bi] = 0;
    2098:	02000805 	andeq	r0, r0, #327680	@ 0x50000
    209c:	01060304 	tsteq	r6, r4, lsl #6
      for (bi = (AES_BLOCKLEN - 1); bi >= 0; --bi)
    20a0:	02001105 	andeq	r1, r0, #1073741825	@ 0x40000001
      bi = 0;
    20a4:	05660304 	strbeq	r0, [r6, #-772]!	@ 0xfffffcfc
    buf[i] = (buf[i] ^ buffer[bi]);
    20a8:	04020006 	streq	r0, [r2], #-6
    20ac:	03058203 	movweq	r8, #20995	@ 0x5203
    20b0:	03040200 	movweq	r0, #16896	@ 0x4200
    20b4:	02002106 	andeq	r2, r0, #-2147483647	@ 0x80000001
    20b8:	00130304 	andseq	r0, r3, r4, lsl #6
  for (i = 0, bi = AES_BLOCKLEN; i < length; ++i, ++bi)
    20bc:	13030402 	movwne	r0, #13314	@ 0x3402
    20c0:	03040200 	movweq	r0, #16896	@ 0x4200
    if (bi == AES_BLOCKLEN) /* we need to regen xor compliment in buffer */
    20c4:	04020013 	streq	r0, [r2], #-19	@ 0xffffffed
      memcpy(buffer, ctx->Iv, AES_BLOCKLEN);
    20c8:	02001303 	andeq	r1, r0, #201326592	@ 0xc000000
    20cc:	00130304 	andseq	r0, r3, r4, lsl #6
    20d0:	13030402 	movwne	r0, #13314	@ 0x3402
      Cipher((state_t*)buffer,ctx->RoundKey);
    20d4:	03040200 	movweq	r0, #16896	@ 0x4200
    20d8:	00160513 	andseq	r0, r6, r3, lsl r5
      for (bi = (AES_BLOCKLEN - 1); bi >= 0; --bi)
    20dc:	03030402 	movweq	r0, #13314	@ 0x3402
    20e0:	05050176 	streq	r0, [r5, #-374]	@ 0xfffffe8a
        if (ctx->Iv[bi] == 255)
    20e4:	03040200 	movweq	r0, #16896	@ 0x4200
    20e8:	02002306 	andeq	r2, r0, #402653184	@ 0x18000000
        ctx->Iv[bi] += 1;
    20ec:	00210304 	eoreq	r0, r1, r4, lsl #6
    20f0:	21030402 	tstcs	r3, r2, lsl #8
      bi = 0;
    20f4:	03040200 	movweq	r0, #16896	@ 0x4200
}
    20f8:	04020021 	streq	r0, [r2], #-33	@ 0xffffffdf
  return ((x[idx / 32U] >> (idx & 31U) & 1U));
    20fc:	02002f03 	andeq	r2, r0, #3, 30
    2100:	00210304 	eoreq	r0, r1, r4, lsl #6
    2104:	21030402 	tstcs	r3, r2, lsl #8
}
    2108:	03040200 	movweq	r0, #16896	@ 0x4200
    210c:	00100521 	andseq	r0, r0, r1, lsr #10
  x[idx / 32U] &= ~(1U << (idx & 31U));
    2110:	06010402 	streq	r0, [r1], -r2, lsl #8
    2114:	062e7603 	strteq	r7, [lr], -r3, lsl #12
    2118:	052e0d03 	streq	r0, [lr, #-3331]!	@ 0xfffff2fd
    211c:	05580602 	ldrbeq	r0, [r8, #-1538]	@ 0xfffff9fe
    2120:	2e010610 	mcrcs	6, 0, r0, cr1, cr0, {0}
    2124:	2f060205 	svccs	0x00060205
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2128:	01061005 	tsteq	r6, r5
    x[i] = y[i];
    212c:	06020520 	streq	r0, [r2], -r0, lsr #10
    2130:	0610052f 	ldreq	r0, [r0], -pc, lsr #10
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2134:	02052001 	andeq	r2, r5, #1
    2138:	10052f06 	andne	r2, r5, r6, lsl #30
{
    213c:	02050106 	andeq	r0, r5, #-2147483647	@ 0x80000001
    2140:	10053d06 	andne	r3, r5, r6, lsl #26
  bitvec_copy(tmp, x);
    2144:	052e0106 	streq	r0, [lr, #-262]!	@ 0xfffffefa
    2148:	052f0602 	streq	r0, [pc, #-1538]!	@ 1b4e <KeyExpansion+0x4e>
  bitvec_copy(x, y);
    214c:	2e010610 	mcrcs	6, 0, r0, cr1, cr0, {0}
    2150:	2f060205 	svccs	0x00060205
  bitvec_copy(y, tmp);
    2154:	01061005 	tsteq	r6, r5
    2158:	0602052e 	streq	r0, [r2], -lr, lsr #10
}
    215c:	0610052f 	ldreq	r0, [r0], -pc, lsr #10
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2160:	4b010501 	blmi	4356c <__ROM_SIZE__+0x356c>
    2164:	0500063c 	streq	r0, [r0, #-1596]	@ 0xfffff9c4
    if (x[i] != y[i])
    2168:	0013b402 	andseq	fp, r3, r2, lsl #8
    216c:	02051500 	andeq	r1, r5, #0, 10
    2170:	060f0513 			@ <UNDEFINED> instruction: 0x060f0513
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2174:	06020501 	streq	r0, [r2], -r1, lsl #10
  return 1;
    2178:	060e052f 	streq	r0, [lr], -pc, lsr #10
}
    217c:	06020501 	streq	r0, [r2], -r1, lsl #10
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2180:	0610054b 	ldreq	r0, [r0], -fp, asr #10
    x[i] = 0;
    2184:	06020501 	streq	r0, [r2], -r1, lsl #10
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2188:	0610052f 	ldreq	r0, [r0], -pc, lsr #10
    218c:	06020501 	streq	r0, [r2], -r1, lsl #10
  uint32_t i = 0;
    2190:	0610052f 	ldreq	r0, [r0], -pc, lsr #10
  while (i < BITVEC_NWORDS)
    2194:	06020501 	streq	r0, [r2], -r1, lsl #10
    if (x[i] != 0)
    2198:	0610052f 	ldreq	r0, [r0], -pc, lsr #10
    i += 1;
    219c:	06020501 	streq	r0, [r2], -r1, lsl #10
}
    21a0:	0610052f 	ldreq	r0, [r0], -pc, lsr #10
    21a4:	06020501 	streq	r0, [r2], -r1, lsl #10
    21a8:	0610052f 	ldreq	r0, [r0], -pc, lsr #10
  x += BITVEC_NWORDS;
    21ac:	06020501 	streq	r0, [r2], -r1, lsl #10
          && (*(--x)) == 0)
    21b0:	0610052f 	ldreq	r0, [r0], -pc, lsr #10
    21b4:	06020501 	streq	r0, [r2], -r1, lsl #10
    21b8:	0610052f 	ldreq	r0, [r0], -pc, lsr #10
    i -= 32;
    21bc:	75010501 	strvc	r0, [r1, #-1281]	@ 0xfffffaff
  if (i != 0)
    21c0:	0106e706 	tsteq	r6, r6, lsl #14
      i -= 1;
    21c4:	4b060205 	blmi	1829e0 <__ROM_SIZE__+0x1429e0>
    while (((*x) & u32mask) == 0)
    21c8:	06090514 			@ <UNDEFINED> instruction: 0x06090514
}
    21cc:	20020501 	andcs	r0, r2, r1, lsl #10
    uint32_t u32mask = ((uint32_t)1 << 31);
    21d0:	02001705 	andeq	r1, r0, #1310720	@ 0x140000
{
    21d4:	20060204 	andcs	r0, r6, r4, lsl #4
  int nwords = (nbits / 32);
    21d8:	02001005 	andeq	r1, r0, #5
    21dc:	05200104 	streq	r0, [r0, #-260]!	@ 0xfffffefc
  for (i = 0; i < nwords; ++i)
    21e0:	10052f03 	andne	r2, r5, r3, lsl #30
  int nwords = (nbits / 32);
    21e4:	21050106 	tstcs	r5, r6, lsl #2
    21e8:	201b0520 	andscs	r0, fp, r0, lsr #10
    x[i] = 0;
    21ec:	21060305 	tstcs	r6, r5, lsl #6
  for (i = 0; i < nwords; ++i)
    21f0:	01060f05 	tsteq	r6, r5, lsl #30
    21f4:	2f060305 	svccs	0x00060305
  j = 0;
    21f8:	01060605 	tsteq	r6, r5, lsl #12
    x[i] = y[j];
    21fc:	2f060405 	svccs	0x00060405
    2200:	0607054b 	streq	r0, [r7], -fp, asr #10
    i += 1;
    2204:	2e100501 	cfmul32cs	mvfx0, mvfx0, mvfx1
    j += 1;
    2208:	67060405 	strvs	r0, [r6, -r5, lsl #8]
  while (i < BITVEC_NWORDS)
    220c:	01061105 	tsteq	r6, r5, lsl #2
  if (nbits != 0)
    2210:	203f0105 	eorscs	r0, pc, r5, lsl #2
}
    2214:	02050006 	andeq	r0, r5, #6
      x[i]  = (x[i] << nbits) | (x[i - 1] >> (32 - nbits));
    2218:	00001448 	andeq	r1, r0, r8, asr #8
    221c:	05010615 	streq	r0, [r1, #-1557]	@ 0xfffff9eb
    2220:	143d0602 	ldrtne	r0, [sp], #-1538	@ 0xfffff9fe
    2224:	01060405 	tsteq	r6, r5, lsl #8
    2228:	23060205 	movwcs	r0, #25093	@ 0x6205
    222c:	01060505 	tsteq	r6, r5, lsl #10
    2230:	2f060305 	svccs	0x00060305
    2234:	01060e05 	tsteq	r6, r5, lsl #28
    for (i = (BITVEC_NWORDS - 1); i > 0; --i)
    2238:	20201205 	eorcs	r1, r0, r5, lsl #4
    x[0] <<= nbits;
    223c:	21060305 	tstcs	r6, r5, lsl #6
    2240:	01060905 	tsteq	r6, r5, lsl #18
    for (i = (BITVEC_NWORDS - 1); i > 0; --i)
    2244:	21060405 	tstcs	r6, r5, lsl #8
  x[0] = 1;
    2248:	01061305 	tsteq	r6, r5, lsl #6
  for (i = 1; i < BITVEC_NWORDS; ++i)
    224c:	052e0f05 	streq	r0, [lr, #-3845]!	@ 0xfffff0fb
    x[i] = 0;
    2250:	051f060c 	ldreq	r0, [pc, #-1548]	@ 1c4c <AddRoundKey+0x2c>
  for (i = 1; i < BITVEC_NWORDS; ++i)
    2254:	2e0c0302 	cdpcs	3, 0, cr0, cr12, cr2, {0}
    2258:	01060505 	tsteq	r6, r5, lsl #10
  if (x[0] != 1)
    225c:	052e1405 	streq	r1, [lr, #-1029]!	@ 0xfffffbfb
    2260:	0e05201e 	mcreq	0, 0, r2, cr5, cr14, {0}
  for (i = 1; i < BITVEC_NWORDS; ++i)
    2264:	06020520 	streq	r0, [r2], -r0, lsr #10
    if (x[i] != 0)
    2268:	06100559 			@ <UNDEFINED> instruction: 0x06100559
  for (i = 1; i < BITVEC_NWORDS; ++i)
    226c:	06020501 	streq	r0, [r2], -r1, lsl #10
  return (i == BITVEC_NWORDS);
    2270:	061e052f 	ldreq	r0, [lr], -pc, lsr #10
    2274:	20100501 	andscs	r0, r0, r1, lsl #10
    2278:	2f060205 	svccs	0x00060205
}
    227c:	01061e05 	tsteq	r6, r5, lsl #28
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2280:	05201005 	streq	r1, [r0, #-5]!
{
    2284:	052f0602 	streq	r0, [pc, #-1538]!	@ 1c8a <SubBytes+0x32>
    z[i] = (x[i] ^ y[i]);
    2288:	0501061e 	streq	r0, [r1, #-1566]	@ 0xfffff9e2
    228c:	02052010 	andeq	r2, r5, #16
    2290:	10052f06 	andne	r2, r5, r6, lsl #30
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2294:	02050106 	andeq	r0, r5, #-2147483647	@ 0x80000001
    2298:	1e052f06 	cdpne	15, 0, cr2, cr5, cr6, {0}
}
    229c:	10050106 	andne	r0, r5, r6, lsl #2
  x[0] ^= 1;
    22a0:	06020520 	streq	r0, [r2], -r0, lsr #10
    22a4:	061e052f 	ldreq	r0, [lr], -pc, lsr #10
}
    22a8:	20100501 	andscs	r0, r0, r1, lsl #10
{
    22ac:	2f060205 	svccs	0x00060205
    22b0:	01061e05 	tsteq	r6, r5, lsl #28
  bitvec_copy(tmp, x);
    22b4:	05201005 	streq	r1, [r0, #-5]!
    22b8:	4e2f0602 	cfmadda32mi	mvax0, mvax0, mvfx15, mvfx2
  if (bitvec_get_bit(y, 0) != 0)
    22bc:	01060905 	tsteq	r6, r5, lsl #18
    22c0:	05200205 	streq	r0, [r0, #-517]!	@ 0xfffffdfb
    bitvec_copy(z, x);
    22c4:	6b030603 	blvs	c3ad8 <__ROM_SIZE__+0x83ad8>
    22c8:	060e0520 	streq	r0, [lr], -r0, lsr #10
{
    22cc:	20120501 	andscs	r0, r2, r1, lsl #10
    bitvec_set_zero(z);
    22d0:	06030520 	streq	r0, [r3], -r0, lsr #10
    22d4:	06090521 	streq	r0, [r9], -r1, lsr #10
      gf2field_add(tmp, tmp, polynomial);
    22d8:	06040501 	streq	r0, [r4], -r1, lsl #10
    22dc:	06130521 	ldreq	r0, [r3], -r1, lsr #10
    22e0:	2e0f0501 	cfsh32cs	mvfx0, mvfx15, #1
  for (i = 1; i < CURVE_DEGREE; ++i)
    22e4:	1f060c05 	svcne	0x00060c05
    22e8:	06300305 	ldrteq	r0, [r0], -r5, lsl #6
    bitvec_lshift(tmp, tmp, 1);
    22ec:	002f062e 	eoreq	r0, pc, lr, lsr #12
    22f0:	03030402 	movweq	r0, #13314	@ 0x3402
    if (bitvec_get_bit(tmp, CURVE_DEGREE))
    22f4:	1d056612 	stcne	6, cr6, [r5, #-72]	@ 0xffffffb8
    22f8:	03040200 	movweq	r0, #16896	@ 0x4200
    22fc:	28050106 	stmdacs	r5, {r1, r2, r8}
    if (bitvec_get_bit(y, i))
    2300:	03040200 	movweq	r0, #16896	@ 0x4200
    2304:	00210520 	eoreq	r0, r1, r0, lsr #10
    2308:	3c030402 	cfstrscc	mvf0, [r3], {2}
      gf2field_add(z, z, tmp);
    230c:	02001005 	andeq	r1, r0, #5
    2310:	05200304 	streq	r0, [r0, #-772]!	@ 0xfffffcfc
    2314:	04020003 	streq	r0, [r2], #-3
}
    2318:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
    231c:	0402001d 	streq	r0, [r2], #-29	@ 0xffffffe3
{
    2320:	05010603 	streq	r0, [r1, #-1539]	@ 0xfffff9fd
    2324:	04020021 	streq	r0, [r2], #-33	@ 0xffffffdf
  bitvec_copy(u, x);
    2328:	07052003 	streq	r2, [r5, -r3]
  bitvec_copy(v, polynomial);
    232c:	03040200 	movweq	r0, #16896	@ 0x4200
    2330:	00100520 	andseq	r0, r0, r0, lsr #10
  bitvec_set_zero(g);
    2334:	20030402 	andcs	r0, r3, r2, lsl #8
    2338:	02000305 	andeq	r0, r0, #335544320	@ 0x14000000
  gf2field_set_one(z);
    233c:	21060304 	tstcs	r6, r4, lsl #6
  while (!gf2field_is_one(u))
    2340:	02001d05 	andeq	r1, r0, #320	@ 0x140
    bitvec_lshift(h, v, i);
    2344:	01060304 	tsteq	r6, r4, lsl #6
    2348:	02002105 	andeq	r2, r0, #1073741825	@ 0x40000001
    gf2field_add(u, u, h);
    234c:	05200304 	streq	r0, [r0, #-772]!	@ 0xfffffcfc
    2350:	04020007 	streq	r0, [r2], #-7
    2354:	10052003 	andne	r2, r5, r3
    bitvec_lshift(h, g, i);
    2358:	03040200 	movweq	r0, #16896	@ 0x4200
    235c:	0003052e 	andeq	r0, r3, lr, lsr #10
    gf2field_add(z, z, h);
    2360:	06030402 	streq	r0, [r3], -r2, lsl #8
    2364:	001d0521 	andseq	r0, sp, r1, lsr #10
    2368:	06030402 	streq	r0, [r3], -r2, lsl #8
  while (!gf2field_is_one(u))
    236c:	00210501 	eoreq	r0, r1, r1, lsl #10
    2370:	20030402 	andcs	r0, r3, r2, lsl #8
    i = (bitvec_degree(u) - bitvec_degree(v));
    2374:	02000705 	andeq	r0, r0, #1310720	@ 0x140000
    2378:	05200304 	streq	r0, [r0, #-772]!	@ 0xfffffcfc
    237c:	04020010 	streq	r0, [r2], #-16
    2380:	03052e03 	movweq	r2, #24067	@ 0x5e03
    if (i < 0)
    2384:	03040200 	movweq	r0, #16896	@ 0x4200
      bitvec_swap(u, v);
    2388:	1d052106 	stfnes	f2, [r5, #-24]	@ 0xffffffe8
    238c:	03040200 	movweq	r0, #16896	@ 0x4200
      bitvec_swap(g, z);
    2390:	21050106 	tstcs	r5, r6, lsl #2
    2394:	03040200 	movweq	r0, #16896	@ 0x4200
      i = -i;
    2398:	00070520 	andeq	r0, r7, r0, lsr #10
}
    239c:	20030402 	andcs	r0, r3, r2, lsl #8
    23a0:	02001005 	andeq	r1, r0, #5
{
    23a4:	052e0304 	streq	r0, [lr, #-772]!	@ 0xfffffcfc
    23a8:	04020003 	streq	r0, [r2], #-3
  bitvec_copy(x1, x2);
    23ac:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
  bitvec_copy(y1, y2);
    23b0:	0402001d 	streq	r0, [r2], #-29	@ 0xffffffe3
    23b4:	05010603 	streq	r0, [r1, #-1539]	@ 0xfffff9fd
}
    23b8:	04020021 	streq	r0, [r2], #-33	@ 0xffffffdf
{
    23bc:	07052003 	streq	r2, [r5, -r3]
  bitvec_set_zero(x);
    23c0:	03040200 	movweq	r0, #16896	@ 0x4200
  bitvec_set_zero(y);
    23c4:	00100520 	andseq	r0, r0, r0, lsr #10
}
    23c8:	2e030402 	cdpcs	4, 0, cr0, cr3, cr2, {0}
{
    23cc:	02000305 	andeq	r0, r0, #335544320	@ 0x14000000
  return (    bitvec_is_zero(x)
    23d0:	21060304 	tstcs	r6, r4, lsl #6
           && bitvec_is_zero(y));
    23d4:	02001d05 	andeq	r1, r0, #320	@ 0x140
    23d8:	01060304 	tsteq	r6, r4, lsl #6
    23dc:	02002105 	andeq	r2, r0, #1073741825	@ 0x40000001
{
    23e0:	05200304 	streq	r0, [r0, #-772]!	@ 0xfffffcfc
    23e4:	04020007 	streq	r0, [r2], #-7
  if (bitvec_is_zero(x))
    23e8:	10052003 	andne	r2, r5, r3
    23ec:	03040200 	movweq	r0, #16896	@ 0x4200
    bitvec_set_zero(y);
    23f0:	0003052e 	andeq	r0, r3, lr, lsr #10
}
    23f4:	06030402 	streq	r0, [r3], -r2, lsl #8
    gf2field_inv(l, x);
    23f8:	001d0521 	andseq	r0, sp, r1, lsr #10
    23fc:	06030402 	streq	r0, [r3], -r2, lsl #8
    gf2field_mul(l, l, y);
    2400:	00210501 	eoreq	r0, r1, r1, lsl #10
    2404:	20030402 	andcs	r0, r3, r2, lsl #8
    2408:	02000705 	andeq	r0, r0, #1310720	@ 0x140000
    gf2field_add(l, l, x);
    240c:	05200304 	streq	r0, [r0, #-772]!	@ 0xfffffcfc
    2410:	04020010 	streq	r0, [r2], #-16
    gf2field_mul(y, x, x);
    2414:	15052e03 	strne	r2, [r5, #-3587]	@ 0xfffff1fd
    2418:	03040200 	movweq	r0, #16896	@ 0x4200
    241c:	20780306 	rsbscs	r0, r8, r6, lsl #6
    gf2field_mul(x, l, l);
    2420:	02001005 	andeq	r1, r0, #5
    2424:	05200104 	streq	r0, [r0, #-260]!	@ 0xfffffefc
    gf2field_inc(l);
    2428:	0a030601 	beq	c3c34 <__ROM_SIZE__+0x83c34>
    242c:	0100202e 	tsteq	r0, lr, lsr #32
    gf2field_add(x, x, l);
    2430:	00039f01 	andeq	r9, r3, r1, lsl #30
    2434:	9e000300 	cdpls	3, 0, cr0, cr0, cr0, {0}
    gf2field_mul(l, l, x);
    2438:	02000000 	andeq	r0, r0, #0
    243c:	0d0efb01 	vstreq	d15, [lr, #-4]
    2440:	01010100 	mrseq	r0, (UNDEF: 17)
    gf2field_add(y, y, l);
    2444:	00000001 	andeq	r0, r0, r1
    2448:	01000001 	tsteq	r0, r1
}
    244c:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 2398 <gf2field_inv+0x78>
{
    2450:	63652f65 	cmnvs	r5, #404	@ 0x194
    2454:	652f6674 	strvs	r6, [pc, #-1652]!	@ 1de8 <InvMixColumns+0x92>
    2458:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
  if (!gf2point_is_zero(x2, y2))
    245c:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
    2460:	2f72656e 	svccs	0x0072656e
    if (gf2point_is_zero(x1, y1))
    2464:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
    2468:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
    246c:	72702f62 	rsbsvc	r2, r0, #392	@ 0x188
      if (bitvec_equal(x1, x2))
    2470:	66746e69 	ldrbtvs	r6, [r4], -r9, ror #28
    2474:	706f2f00 	rsbvc	r2, pc, r0, lsl #30
        if (bitvec_equal(y1, y2))
    2478:	63672f74 	cmnvs	r7, #116, 30	@ 0x1d0
    247c:	72612d63 	rsbvc	r2, r1, #6336	@ 0x18c0
    2480:	6f6e2d6d 	svcvs	0x006e2d6d
          gf2point_double(x1, y1);
    2484:	652d656e 	strvs	r6, [sp, #-1390]!	@ 0xfffffa92
    2488:	2f696261 	svccs	0x00696261
      gf2point_copy(x1, y1, x2, y2);
    248c:	2f62696c 	svccs	0x0062696c
    2490:	2f636367 	svccs	0x00636367
    2494:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	@ 0xfffffe7c
}
    2498:	656e6f6e 	strbvs	r6, [lr, #-3950]!	@ 0xfffff092
          gf2point_set_zero(x1, y1);
    249c:	6261652d 	rsbvs	r6, r1, #188743680	@ 0xb400000
    24a0:	32312f69 	eorscc	r2, r1, #420	@ 0x1a4
    24a4:	312e322e 			@ <UNDEFINED> instruction: 0x312e322e
        gf2field_add(a, y1, y2);
    24a8:	636e692f 	cmnvs	lr, #770048	@ 0xbc000
    24ac:	6564756c 	strbvs	r7, [r4, #-1388]!	@ 0xfffffa94
        gf2field_add(b, x1, x2);
    24b0:	72700000 	rsbsvc	r0, r0, #0
    24b4:	66746e69 	ldrbtvs	r6, [r4], -r9, ror #28
    24b8:	0100632e 	tsteq	r0, lr, lsr #6
        gf2field_inv(c, b);
    24bc:	74730000 	ldrbtvc	r0, [r3], #-0
    24c0:	67726164 	ldrbvs	r6, [r2, -r4, ror #2]!
        gf2field_mul(c, c, a);
    24c4:	0200682e 	andeq	r6, r0, #3014656	@ 0x2e0000
    24c8:	623c0000 	eorsvs	r0, ip, #0
        gf2field_mul(d, c, c);
    24cc:	746c6975 	strbtvc	r6, [ip], #-2421	@ 0xfffff68b
    24d0:	3e6e692d 	vmulcc.f16	s13, s28, s27	@ <UNPREDICTABLE>
    24d4:	00000000 	andeq	r0, r0, r0
        gf2field_add(d, d, c);
    24d8:	00250500 	eoreq	r0, r5, r0, lsl #10
    24dc:	15300205 	ldrne	r0, [r0, #-517]!	@ 0xfffffdfb
        gf2field_add(d, d, b);
    24e0:	2a030000 	bcs	c24e8 <__ROM_SIZE__+0x824e8>
    24e4:	05010601 	streq	r0, [r1, #-1537]	@ 0xfffff9ff
    24e8:	052f0603 	streq	r0, [pc, #-1539]!	@ 1eed <InvSubBytes+0x3d>
        gf2field_inc(d);
    24ec:	05010609 	streq	r0, [r1, #-1545]	@ 0xfffff9f7
        gf2field_add(x1, x1, d);
    24f0:	3d210605 	stccc	6, cr0, [r1, #-20]!	@ 0xffffffec
    24f4:	01060805 	tsteq	r6, r5, lsl #16
    24f8:	1e060f05 	cdpne	15, 0, cr0, cr6, cr5, {0}
        gf2field_mul(a, x1, c);
    24fc:	01060a05 	tsteq	r6, r5, lsl #20
    2500:	05200f05 	streq	r0, [r0, #-3845]!	@ 0xfffff0fb
        gf2field_add(a, a, d);
    2504:	05203201 	streq	r3, [r0, #-513]!	@ 0xfffffdff
    2508:	05000648 	streq	r0, [r0, #-1608]	@ 0xfffff9b8
    250c:	00154c02 	andseq	r4, r5, r2, lsl #24
        gf2field_add(y1, y1, a);
    2510:	01061400 	tsteq	r6, r0, lsl #8
    2514:	3d060305 	stccc	3, cr0, [r6, #-20]	@ 0xffffffec
        bitvec_copy(x1, d);
    2518:	07051413 	smladeq	r5, r3, r4, r1
    251c:	14743b03 	ldrbtne	r3, [r4], #-2819	@ 0xfffff4fd
}
    2520:	01060a05 	tsteq	r6, r5, lsl #20
{
    2524:	3d060905 	vstrcc.16	s0, [r6, #-10]	@ <UNPREDICTABLE>
    2528:	01060f05 	tsteq	r6, r5, lsl #30
  int nbits = bitvec_degree(exp);
    252c:	0607052e 	streq	r0, [r7], -lr, lsr #10
    2530:	052e1103 	streq	r1, [lr, #-259]!	@ 0xfffffefd
  gf2point_set_zero(tmpx, tmpy);
    2534:	0501060a 	streq	r0, [r1, #-1546]	@ 0xfffff9f6
    2538:	0a030609 	beq	c3d64 <__ROM_SIZE__+0x83d64>
  for (i = (nbits - 1); i >= 0; --i)
    253c:	060c052e 	streq	r0, [ip], -lr, lsr #10
    2540:	060b0501 	streq	r0, [fp], -r1, lsl #10
    2544:	203c062f 	eorscs	r0, ip, pc, lsr #12
    gf2point_double(tmpx, tmpy);
    2548:	16030a05 	strne	r0, [r3], -r5, lsl #20
    254c:	03052e01 	movweq	r2, #24065	@ 0x5e01
    if (bitvec_get_bit(exp, i))
    2550:	017f9003 	cmneq	pc, r3
    2554:	03060705 	movweq	r0, #26373	@ 0x6705
    2558:	062e00ed 	strteq	r0, [lr], -sp, ror #1
      gf2point_add(tmpx, tmpy, x, y);
    255c:	052f0620 	streq	r0, [pc, #-1568]!	@ 1f44 <Cipher+0x1a>
    2560:	0501060e 	streq	r0, [r1, #-1550]	@ 0xfffff9f2
    2564:	07052301 	streq	r2, [r5, -r1, lsl #6]
  gf2point_copy(x, y, tmpx, tmpy);
    2568:	7f9a0306 	svcvc	0x009a0306
    256c:	0a05142e 	beq	14762c <__ROM_SIZE__+0x10762c>
    2570:	09050106 	stmdbeq	r5, {r1, r2, r8}
}
    2574:	0f052f06 	svceq	0x00052f06
{
    2578:	052e0106 	streq	r0, [lr, #-262]!	@ 0xfffffefa
    257c:	12030607 	andne	r0, r3, #7340032	@ 0x700000
  if (gf2point_is_zero(x, y))
    2580:	060a052e 	streq	r0, [sl], -lr, lsr #10
    2584:	00070501 	andeq	r0, r7, r1, lsl #10
}
    2588:	06010402 	streq	r0, [r1], -r2, lsl #8
    gf2field_mul(a, x, x);
    258c:	00090533 	andeq	r0, r9, r3, lsr r5
    2590:	13010402 	movwne	r0, #5122	@ 0x1402
    2594:	02002905 	andeq	r2, r0, #81920	@ 0x14000
    gf2field_mul(b, a, x);
    2598:	01060104 	tsteq	r6, r4, lsl #2
    259c:	02002205 	andeq	r2, r0, #1342177280	@ 0x50000000
    gf2field_add(a, a, b);
    25a0:	05ac0104 	streq	r0, [ip, #260]!	@ 0x104
    25a4:	04020018 	streq	r0, [r2], #-24	@ 0xffffffe8
    25a8:	02002e01 	andeq	r2, r0, #1, 28
    gf2field_add(a, a, coeff_b);
    25ac:	054a0104 	strbeq	r0, [sl, #-260]	@ 0xfffffefc
    25b0:	04020009 	streq	r0, [r2], #-9
    gf2field_mul(b, y, y);
    25b4:	052f0601 	streq	r0, [pc, #-1537]!	@ 1fbb <XorWithIv+0x13>
    25b8:	0402000f 	streq	r0, [r2], #-15
    25bc:	05200601 	streq	r0, [r0, #-1537]!	@ 0xfffff9ff
    gf2field_add(a, a, b);
    25c0:	04020016 	streq	r0, [r2], #-22	@ 0xffffffea
    25c4:	05210601 	streq	r0, [r1, #-1537]!	@ 0xfffff9ff
    gf2field_mul(b, x, y);
    25c8:	3c790309 	ldclcc	3, cr0, [r9], #-36	@ 0xffffffdc
    25cc:	21063c06 	tstcs	r6, r6, lsl #24
    25d0:	01060f05 	tsteq	r6, r5, lsl #30
    return bitvec_equal(a, b);
    25d4:	06090520 	streq	r0, [r9], -r0, lsr #10
    25d8:	06200903 	strteq	r0, [r0], -r3, lsl #18
    25dc:	06160520 	ldreq	r0, [r6], -r0, lsr #10
{
    25e0:	060a058f 	streq	r0, [sl], -pc, lsl #11
    25e4:	2e00c603 	cfmadd32cs	mvax0, mvfx12, mvfx0, mvfx3
  gf2point_copy((uint32_t*)public_key, (uint32_t*)(public_key + BITVEC_NBYTES), base_x, base_y);
    25e8:	02000905 	andeq	r0, r0, #81920	@ 0x14000
    25ec:	03060104 	movweq	r0, #24836	@ 0x6104
    25f0:	0b052e60 	bleq	14df78 <__ROM_SIZE__+0x10df78>
    25f4:	01040200 	mrseq	r0, R12_usr
  if (bitvec_degree((uint32_t*)private_key) < (CURVE_DEGREE / 2))
    25f8:	002b0513 	eoreq	r0, fp, r3, lsl r5
    25fc:	06010402 	streq	r0, [r1], -r2, lsl #8
    2600:	00240501 	eoreq	r0, r4, r1, lsl #10
    int nbits = bitvec_degree(base_order);
    2604:	90010402 	andls	r0, r1, r2, lsl #8
    for (i = (nbits - 1); i < (BITVEC_NWORDS * 32); ++i)
    2608:	02001a05 	andeq	r1, r0, #20480	@ 0x5000
      bitvec_clr_bit((uint32_t*)private_key, i);
    260c:	002e0104 	eoreq	r0, lr, r4, lsl #2
    2610:	4a010402 	bmi	43620 <__ROM_SIZE__+0x3620>
    for (i = (nbits - 1); i < (BITVEC_NWORDS * 32); ++i)
    2614:	02000b05 	andeq	r0, r0, #5120	@ 0x1400
    2618:	2f060104 	svccs	0x00060104
    gf2point_mul((uint32_t*)public_key, (uint32_t*)(public_key + BITVEC_NBYTES), (uint32_t*)private_key);
    261c:	02001105 	andeq	r1, r0, #1073741825	@ 0x40000001
    2620:	20060104 	andcs	r0, r6, r4, lsl #2
    return 1;
    2624:	02001805 	andeq	r1, r0, #327680	@ 0x50000
    return 0;
    2628:	21060104 	tstcs	r6, r4, lsl #2
    262c:	2f0b0530 	svccs	0x000b0530
    2630:	059e2006 	ldreq	r2, [lr, #6]
{
    2634:	011a030a 	tsteq	sl, sl, lsl #6
    2638:	03060f05 	movweq	r0, #28421	@ 0x6f05
  if (    !gf2point_is_zero ((uint32_t*)others_pub, (uint32_t*)(others_pub + BITVEC_NBYTES))
    263c:	05132e73 	ldreq	r2, [r3, #-3699]	@ 0xfffff18d
    2640:	05570624 	ldrbeq	r0, [r7, #-1572]	@ 0xfffff9dc
    2644:	0523060d 	streq	r0, [r3, #-1549]!	@ 0xfffff9f3
    2648:	20010617 	andcs	r0, r1, r7, lsl r6
}
    264c:	03061c05 	movweq	r1, #27653	@ 0x6c05
       &&  gf2point_on_curve((uint32_t*)others_pub, (uint32_t*)(others_pub + BITVEC_NBYTES)) )
    2650:	0d05017a 	stfeqs	f0, [r5, #-488]	@ 0xfffffe18
    2654:	061e052f 	ldreq	r0, [lr], -pc, lsr #10
    2658:	060d0501 	streq	r0, [sp], -r1, lsl #10
    for (i = 0; i < (BITVEC_NBYTES * 2); ++i)
    265c:	0610052f 	ldreq	r0, [r0], -pc, lsr #10
      output[i] = others_pub[i];
    2660:	15052e01 	strne	r2, [r5, #-3585]	@ 0xfffff1ff
    2664:	01040200 	mrseq	r0, R12_usr
    for (i = 0; i < (BITVEC_NBYTES * 2); ++i)
    2668:	04020020 	streq	r0, [r2], #-32	@ 0xffffffe0
    gf2point_mul((uint32_t*)output,(uint32_t*)(output + BITVEC_NBYTES), (const uint32_t*)private_key);
    266c:	10053c01 	andne	r3, r5, r1, lsl #24
    2670:	1f0f050e 	svcne	0x000f050e
    2674:	0a052020 	beq	14a6fc <__ROM_SIZE__+0x10a6fc>
    return 1;
    2678:	05011303 	streq	r1, [r1, #-771]	@ 0xfffffcfd
int atoi(const char* str) {
    267c:	7fac0310 	svcvc	0x00ac0310
  int res = 0;
    2680:	0320202e 			@ <UNDEFINED> instruction: 0x0320202e
    res = res * 10 + str[i] - '0';
    2684:	05200130 	streq	r0, [r0, #-304]!	@ 0xfffffed0
    2688:	05000622 	streq	r0, [r0, #-1570]	@ 0xfffff9de
    268c:	00168c02 	andseq	r8, r6, r2, lsl #24
  for (int i = 0; str[i] != '\0'; ++i) {
    2690:	01270300 			@ <UNDEFINED> instruction: 0x01270300
    2694:	03050106 	movweq	r0, #20742	@ 0x5106
}
    2698:	14136706 	ldrne	r6, [r3], #-1798	@ 0xfffff8fa
  for (uint32_t i = 0; str[i] != '\0'; i++) {
    269c:	06100522 	ldreq	r0, [r0], -r2, lsr #10
    26a0:	2509050d 	strcs	r0, [r9, #-1293]	@ 0xfffffaf3
    } else if (str[i] >= 'a' && str[i] <= 'f') {
    26a4:	0c052306 	stceq	3, cr2, [r5], {6}
    26a8:	09050106 	stmdbeq	r5, {r1, r2, r8}
      value = str[i] - 'a' + 10;
    26ac:	053d3306 	ldreq	r3, [sp, #-774]!	@ 0xfffffcfa
    hex |= value;
    26b0:	0501060c 	streq	r0, [r1, #-1548]	@ 0xfffff9f4
  for (uint32_t i = 0; str[i] != '\0'; i++) {
    26b4:	05210609 	streq	r0, [r1, #-1545]!	@ 0xfffff9f7
    26b8:	0176030a 	cmneq	r6, sl, lsl #6
    if (str[i] >= '0' && str[i] <= '9') {
    26bc:	053d0505 	ldreq	r0, [sp, #-1285]!	@ 0xfffffafb
    26c0:	0402000b 	streq	r0, [r2], #-11
      value = str[i] - '0';
    26c4:	02004d01 	andeq	r4, r0, #1, 26	@ 0x40
    } else if (str[i] >= 'A' && str[i] <= 'F') {
    26c8:	05130104 	ldreq	r0, [r3, #-260]	@ 0xfffffefc
    26cc:	0402000e 	streq	r0, [r2], #-14
    26d0:	05010601 	streq	r0, [r1, #-1537]	@ 0xfffff9ff
      value = str[i] - 'A' + 10;
    26d4:	0402000b 	streq	r0, [r2], #-11
  selected_mode = mode;
    26d8:	05210601 	streq	r0, [r1, #-1537]!	@ 0xfffff9ff
  if (selected_mode == NONE) {
    26dc:	04020011 	streq	r0, [r2], #-17	@ 0xffffffef
  out_buf_rgn.addr = addr;
    26e0:	05100601 	ldreq	r0, [r0, #-1537]	@ 0xfffff9ff
  out_buf_rgn.size = size / 2;
    26e4:	0402000b 	streq	r0, [r2], #-11
  out_buf_rgn.curr_index = 0;
    26e8:	03062201 	movweq	r2, #25089	@ 0x6201
  inp_buf_rgn.addr = addr + size / 2;
    26ec:	0e052009 	cdpeq	0, 0, cr2, cr5, cr9, {0}
  inp_buf_rgn.curr_index = 0;
    26f0:	15050106 	strne	r0, [r5, #-262]	@ 0xfffffefa
  if (!(selected_mode & INP)) {
    26f4:	10051f06 	andne	r1, r5, r6, lsl #30
    out_buf_rgn.size = size;
    26f8:	15050106 	strne	r0, [r5, #-262]	@ 0xfffffefa
  memset(addr, 0, size);
    26fc:	00260520 	eoreq	r0, r6, r0, lsr #10
    2700:	20010402 	andcs	r0, r1, r2, lsl #8
  } else if (!(selected_mode & OUT)) {
    2704:	02001505 	andeq	r1, r0, #20971520	@ 0x1400000
    2708:	053c0104 	ldreq	r0, [ip, #-260]!	@ 0xfffffefc
    inp_buf_rgn.addr = addr;
    270c:	04020036 	streq	r0, [r2], #-54	@ 0xffffffca
    inp_buf_rgn.size = size;
    2710:	09052e02 	stmdbeq	r5, {r1, r9, sl, fp, sp}
    2714:	0d053206 	sfmeq	f3, 4, [r5, #-24]	@ 0xffffffe8
  if (!(selected_mode & INP)) {
    2718:	10053d92 	mulne	r5, r2, sp
    271c:	0d050106 	stfeqs	f0, [r5, #-24]	@ 0xffffffe8
    2720:	05132106 	ldreq	r2, [r3, #-262]	@ 0xfffffefa
  if (inp_buf_rgn.addr[inp_buf_rgn.curr_index] == 0) {
    2724:	05110613 	ldreq	r0, [r1, #-1555]	@ 0xfffff9ed
    2728:	0620210d 	strteq	r2, [r0], -sp, lsl #2
  int val = inp_buf_rgn.addr[inp_buf_rgn.curr_index];
    272c:	674a0903 	strbvs	r0, [sl, -r3, lsl #18]
  inp_buf_rgn.addr[inp_buf_rgn.curr_index] = 0;
    2730:	01061005 	tsteq	r6, r5
  inp_buf_rgn.curr_index++;
    2734:	21060d05 	tstcs	r6, r5, lsl #26
    2738:	06130513 			@ <UNDEFINED> instruction: 0x06130513
  if (inp_buf_rgn.curr_index == inp_buf_rgn.size) {
    273c:	210d0511 	tstcs	sp, r1, lsl r5
}
    2740:	20770306 	rsbscs	r0, r7, r6, lsl #6
    inp_buf_rgn.curr_index = 0;
    2744:	2e061c05 	cdpcs	12, 0, cr1, cr6, cr5, {0}
    return -1;
    2748:	063c0d05 	ldrteq	r0, [ip], -r5, lsl #26
    274c:	0610052f 	ldreq	r0, [r0], -pc, lsr #10
    return -1;
    2750:	060d0501 	streq	r0, [sp], -r1, lsl #10
    2754:	13051321 	movwne	r1, #21281	@ 0x5321
  if (!(selected_mode & OUT) || c == 0) {
    2758:	0d051106 	stfeqs	f1, [r5, #-24]	@ 0xffffffe8
    275c:	13280621 			@ <UNDEFINED> instruction: 0x13280621
    2760:	01061005 	tsteq	r6, r5
  out_buf_rgn.addr[out_buf_rgn.curr_index] = (uint8_t) c;
    2764:	21060d05 	tstcs	r6, r5, lsl #26
    2768:	01061105 	tsteq	r6, r5, lsl #2
  out_buf_rgn.curr_index++;
    276c:	05201005 	streq	r1, [r0, #-5]!
  if (out_buf_rgn.curr_index == out_buf_rgn.size) {
    2770:	0d052c11 	stceq	12, cr2, [r5, #-68]	@ 0xffffffbc
    2774:	11052606 	tstne	r5, r6, lsl #12
    out_buf_rgn.curr_index = 0;
    2778:	10050106 	andne	r0, r5, r6, lsl #2
    277c:	060f054a 	streq	r0, [pc], -sl, asr #10
    2780:	12051321 	andne	r1, r5, #-2080374784	@ 0x84000000
size_t strlen(const char *str) {
    2784:	0f050106 	svceq	0x00050106
  while (str[len]) {
    2788:	15052106 	strne	r2, [r5, #-262]	@ 0xfffffefa
    278c:	0f051006 	svceq	0x00051006
    2790:	7a030622 	bvc	c4020 <__ROM_SIZE__+0x84020>
  while (*str1 && (*str1 == *str2)) {
    2794:	12051320 	andne	r1, r5, #32, 6	@ 0x80000000
    str2++;
    2798:	16050106 	strne	r0, [r5], -r6, lsl #2
  while (*str1 && (*str1 == *str2)) {
    279c:	0d052e1f 	stceq	14, cr2, [r5, #-124]	@ 0xffffff84
    27a0:	010b0306 	tsteq	fp, r6, lsl #6
  return *str1 - *str2;
    27a4:	01061105 	tsteq	r6, r5, lsl #2
}
    27a8:	054a1005 	strbeq	r1, [sl, #-5]
    *(str1++) = *(str2++);
    27ac:	1321060f 			@ <UNDEFINED> instruction: 0x1321060f
    27b0:	01061205 	tsteq	r6, r5, lsl #4
  while (*str2) {
    27b4:	21060f05 	tstcs	r6, r5, lsl #30
  *str1 = '\0';
    27b8:	10061505 	andne	r1, r6, r5, lsl #10
}
    27bc:	05220f05 	streq	r0, [r2, #-3845]!	@ 0xfffff0fb
  for (i = 0; i < size; i++) {
    27c0:	207a0314 	rsbscs	r0, sl, r4, lsl r3
    dest_char[i] = src_char[i];
    27c4:	0301052e 	movweq	r0, #5422	@ 0x152e
    27c8:	14050111 	strne	r0, [r5], #-273	@ 0xfffffeef
  for (i = 0; i < size; i++) {
    27cc:	02587703 	subseq	r7, r8, #786432	@ 0xc0000
}
    27d0:	01010006 	tsteq	r1, r6
  for (i = 0; i < size; i++) {
    27d4:	000003a0 	andeq	r0, r0, r0, lsr #7
    dest_char[i] = val;
    27d8:	009f0003 	addseq	r0, pc, r3
  for (i = 0; i < size; i++) {
    27dc:	01020000 	mrseq	r0, (UNDEF: 2)
}
    27e0:	000d0efb 	strdeq	r0, [sp], -fp
    27e4:	01010101 	tsteq	r1, r1, lsl #2
    27e8:	01000000 	mrseq	r0, (UNDEF: 0)
    27ec:	2f010000 	svccs	0x00010000
    27f0:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
    27f4:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
    27f8:	63652f66 	cmnvs	r5, #408	@ 0x198
    27fc:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
    2800:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
    2804:	732f7265 			@ <UNDEFINED> instruction: 0x732f7265
    2808:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
    280c:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
    2810:	6972702f 	ldmdbvs	r2!, {r0, r1, r2, r3, r5, ip, sp, lr}^
    2814:	0066746e 	rsbeq	r7, r6, lr, ror #8
    2818:	74706f2f 	ldrbtvc	r6, [r0], #-3887	@ 0xfffff0d1
    281c:	6363672f 	cmnvs	r3, #12320768	@ 0xbc0000
    2820:	6d72612d 	ldfvse	f6, [r2, #-180]!	@ 0xffffff4c
    2824:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
    2828:	61652d65 	cmnvs	r5, r5, ror #26
    282c:	6c2f6962 			@ <UNDEFINED> instruction: 0x6c2f6962
    2830:	672f6269 	strvs	r6, [pc, -r9, ror #4]!
    2834:	612f6363 			@ <UNDEFINED> instruction: 0x612f6363
    2838:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
    283c:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	@ 0xfffffe44
    2840:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
    2844:	2e32312f 	rsfcssp	f3, f2, #10.0
    2848:	2f312e32 	svccs	0x00312e32
    284c:	6c636e69 	stclvs	14, cr6, [r3], #-420	@ 0xfffffe5c
    2850:	00656475 	rsbeq	r6, r5, r5, ror r4
    2854:	69727000 	ldmdbvs	r2!, {ip, sp, lr}^
    2858:	3266746e 	rsbcc	r7, r6, #1845493760	@ 0x6e000000
    285c:	0100632e 	tsteq	r0, lr, lsr #6
    2860:	74730000 	ldrbtvc	r0, [r3], #-0
    2864:	67726164 	ldrbvs	r6, [r2, -r4, ror #2]!
    2868:	0200682e 	andeq	r6, r0, #3014656	@ 0x2e0000
    286c:	623c0000 	eorsvs	r0, ip, #0
    2870:	746c6975 	strbtvc	r6, [ip], #-2421	@ 0xfffff68b
    2874:	3e6e692d 	vmulcc.f16	s13, s28, s27	@ <UNPREDICTABLE>
    2878:	00000000 	andeq	r0, r0, r0
    287c:	00260500 	eoreq	r0, r6, r0, lsl #10
    2880:	17680205 	strbne	r0, [r8, -r5, lsl #4]!
    2884:	28030000 	stmdacs	r3, {}	@ <UNPREDICTABLE>
    2888:	05010601 	streq	r0, [r1, #-1537]	@ 0xfffff9ff
    288c:	052f0603 	streq	r0, [pc, #-1539]!	@ 2291 <gf2field_add+0x13>
    2890:	05010609 	streq	r0, [r1, #-1545]	@ 0xfffff9f7
    2894:	3d210605 	stccc	6, cr0, [r1, #-20]!	@ 0xffffffec
    2898:	01060805 	tsteq	r6, r5, lsl #16
    289c:	1e060f05 	cdpne	15, 0, cr0, cr6, cr5, {0}
    28a0:	01060a05 	tsteq	r6, r5, lsl #20
    28a4:	05200f05 	streq	r0, [r0, #-3845]!	@ 0xfffff0fb
    28a8:	05203201 	streq	r3, [r0, #-513]!	@ 0xfffffdff
    28ac:	05000649 	streq	r0, [r0, #-1609]	@ 0xfffff9b7
    28b0:	00178402 	andseq	r8, r7, r2, lsl #8
    28b4:	01061400 	tsteq	r6, r0, lsl #8
    28b8:	3d060305 	stccc	3, cr0, [r6, #-20]	@ 0xffffffec
    28bc:	07051413 	smladeq	r5, r3, r4, r1
    28c0:	14743b03 	ldrbtne	r3, [r4], #-2819	@ 0xfffff4fd
    28c4:	01060a05 	tsteq	r6, r5, lsl #20
    28c8:	3d060905 	vstrcc.16	s0, [r6, #-10]	@ <UNPREDICTABLE>
    28cc:	01060f05 	tsteq	r6, r5, lsl #30
    28d0:	0607052e 	streq	r0, [r7], -lr, lsr #10
    28d4:	052e1103 	streq	r1, [lr, #-259]!	@ 0xfffffefd
    28d8:	0501060a 	streq	r0, [r1, #-1546]	@ 0xfffff9f6
    28dc:	0a030609 	beq	c4108 <__ROM_SIZE__+0x84108>
    28e0:	060c052e 	streq	r0, [ip], -lr, lsr #10
    28e4:	060b0501 	streq	r0, [fp], -r1, lsl #10
    28e8:	203c062f 	eorscs	r0, ip, pc, lsr #12
    28ec:	16030a05 	strne	r0, [r3], -r5, lsl #20
    28f0:	03052e01 	movweq	r2, #24065	@ 0x5e01
    28f4:	017f9003 	cmneq	pc, r3
    28f8:	03060705 	movweq	r0, #26373	@ 0x6705
    28fc:	062e00ed 	strteq	r0, [lr], -sp, ror #1
    2900:	052f0620 	streq	r0, [pc, #-1568]!	@ 22e8 <gf2field_mul+0x3e>
    2904:	0501060e 	streq	r0, [r1, #-1550]	@ 0xfffff9f2
    2908:	07052301 	streq	r2, [r5, -r1, lsl #6]
    290c:	7f9a0306 	svcvc	0x009a0306
    2910:	0a05142e 	beq	1479d0 <__ROM_SIZE__+0x1079d0>
    2914:	09050106 	stmdbeq	r5, {r1, r2, r8}
    2918:	0f052f06 	svceq	0x00052f06
    291c:	052e0106 	streq	r0, [lr, #-262]!	@ 0xfffffefa
    2920:	12030607 	andne	r0, r3, #7340032	@ 0x700000
    2924:	060a052e 	streq	r0, [sl], -lr, lsr #10
    2928:	00070501 	andeq	r0, r7, r1, lsl #10
    292c:	06010402 	streq	r0, [r1], -r2, lsl #8
    2930:	00090533 	andeq	r0, r9, r3, lsr r5
    2934:	13010402 	movwne	r0, #5122	@ 0x1402
    2938:	02002a05 	andeq	r2, r0, #20480	@ 0x5000
    293c:	01060104 	tsteq	r6, r4, lsl #2
    2940:	02002305 	andeq	r2, r0, #335544320	@ 0x14000000
    2944:	05ac0104 	streq	r0, [ip, #260]!	@ 0x104
    2948:	04020018 	streq	r0, [r2], #-24	@ 0xffffffe8
    294c:	02002e01 	andeq	r2, r0, #1, 28
    2950:	054a0104 	strbeq	r0, [sl, #-260]	@ 0xfffffefc
    2954:	04020009 	streq	r0, [r2], #-9
    2958:	052f0601 	streq	r0, [pc, #-1537]!	@ 235f <gf2field_inv+0x3f>
    295c:	0402000f 	streq	r0, [r2], #-15
    2960:	05200601 	streq	r0, [r0, #-1537]!	@ 0xfffff9ff
    2964:	04020016 	streq	r0, [r2], #-22	@ 0xffffffea
    2968:	05210601 	streq	r0, [r1, #-1537]!	@ 0xfffff9ff
    296c:	3c790309 	ldclcc	3, cr0, [r9], #-36	@ 0xffffffdc
    2970:	21063c06 	tstcs	r6, r6, lsl #24
    2974:	01060f05 	tsteq	r6, r5, lsl #30
    2978:	06090520 	streq	r0, [r9], -r0, lsr #10
    297c:	06200903 	strteq	r0, [r0], -r3, lsl #18
    2980:	06160520 	ldreq	r0, [r6], -r0, lsr #10
    2984:	060a058f 	streq	r0, [sl], -pc, lsl #11
    2988:	2e00c603 	cfmadd32cs	mvax0, mvfx12, mvfx0, mvfx3
    298c:	02000905 	andeq	r0, r0, #81920	@ 0x14000
    2990:	03060104 	movweq	r0, #24836	@ 0x6104
    2994:	0b052e60 	bleq	14e31c <__ROM_SIZE__+0x10e31c>
    2998:	01040200 	mrseq	r0, R12_usr
    299c:	002c0513 	eoreq	r0, ip, r3, lsl r5
    29a0:	06010402 	streq	r0, [r1], -r2, lsl #8
    29a4:	00250501 	eoreq	r0, r5, r1, lsl #10
    29a8:	90010402 	andls	r0, r1, r2, lsl #8
    29ac:	02001a05 	andeq	r1, r0, #20480	@ 0x5000
    29b0:	002e0104 	eoreq	r0, lr, r4, lsl #2
    29b4:	4a010402 	bmi	439c4 <__ROM_SIZE__+0x39c4>
    29b8:	02000b05 	andeq	r0, r0, #5120	@ 0x1400
    29bc:	2f060104 	svccs	0x00060104
    29c0:	02001105 	andeq	r1, r0, #1073741825	@ 0x40000001
    29c4:	20060104 	andcs	r0, r6, r4, lsl #2
    29c8:	02001805 	andeq	r1, r0, #327680	@ 0x50000
    29cc:	21060104 	tstcs	r6, r4, lsl #2
    29d0:	2f0b0530 	svccs	0x000b0530
    29d4:	059e2006 	ldreq	r2, [lr, #6]
    29d8:	011a030a 	tsteq	sl, sl, lsl #6
    29dc:	03060f05 	movweq	r0, #28421	@ 0x6f05
    29e0:	05132e73 	ldreq	r2, [r3, #-3699]	@ 0xfffff18d
    29e4:	05570624 	ldrbeq	r0, [r7, #-1572]	@ 0xfffff9dc
    29e8:	0523060d 	streq	r0, [r3, #-1549]!	@ 0xfffff9f3
    29ec:	20010617 	andcs	r0, r1, r7, lsl r6
    29f0:	03061c05 	movweq	r1, #27653	@ 0x6c05
    29f4:	0d05017a 	stfeqs	f0, [r5, #-488]	@ 0xfffffe18
    29f8:	061e052f 	ldreq	r0, [lr], -pc, lsr #10
    29fc:	060d0501 	streq	r0, [sp], -r1, lsl #10
    2a00:	0610052f 	ldreq	r0, [r0], -pc, lsr #10
    2a04:	15052e01 	strne	r2, [r5, #-3585]	@ 0xfffff1ff
    2a08:	01040200 	mrseq	r0, R12_usr
    2a0c:	04020020 	streq	r0, [r2], #-32	@ 0xffffffe0
    2a10:	10053c01 	andne	r3, r5, r1, lsl #24
    2a14:	1f0f050e 	svcne	0x000f050e
    2a18:	0a052020 	beq	14aaa0 <__ROM_SIZE__+0x10aaa0>
    2a1c:	05011303 	streq	r1, [r1, #-771]	@ 0xfffffcfd
    2a20:	7fac0310 	svcvc	0x00ac0310
    2a24:	0320202e 			@ <UNDEFINED> instruction: 0x0320202e
    2a28:	05200130 	streq	r0, [r0, #-304]!	@ 0xfffffed0
    2a2c:	05000623 	streq	r0, [r0, #-1571]	@ 0xfffff9dd
    2a30:	0018c402 	andseq	ip, r8, r2, lsl #8
    2a34:	01270300 			@ <UNDEFINED> instruction: 0x01270300
    2a38:	03050106 	movweq	r0, #20742	@ 0x5106
    2a3c:	14136706 	ldrne	r6, [r3], #-1798	@ 0xfffff8fa
    2a40:	06110522 	ldreq	r0, [r1], -r2, lsr #10
    2a44:	2509050d 	strcs	r0, [r9, #-1293]	@ 0xfffffaf3
    2a48:	0c052306 	stceq	3, cr2, [r5], {6}
    2a4c:	09050106 	stmdbeq	r5, {r1, r2, r8}
    2a50:	053d3306 	ldreq	r3, [sp, #-774]!	@ 0xfffffcfa
    2a54:	0501060c 	streq	r0, [r1, #-1548]	@ 0xfffff9f4
    2a58:	05210609 	streq	r0, [r1, #-1545]!	@ 0xfffff9f7
    2a5c:	0176030a 	cmneq	r6, sl, lsl #6
    2a60:	053d0505 	ldreq	r0, [sp, #-1285]!	@ 0xfffffafb
    2a64:	0402000b 	streq	r0, [r2], #-11
    2a68:	02004d01 	andeq	r4, r0, #1, 26	@ 0x40
    2a6c:	05130104 	ldreq	r0, [r3, #-260]	@ 0xfffffefc
    2a70:	0402000e 	streq	r0, [r2], #-14
    2a74:	05010601 	streq	r0, [r1, #-1537]	@ 0xfffff9ff
    2a78:	0402000b 	streq	r0, [r2], #-11
    2a7c:	05210601 	streq	r0, [r1, #-1537]!	@ 0xfffff9ff
    2a80:	04020011 	streq	r0, [r2], #-17	@ 0xffffffef
    2a84:	05100601 	ldreq	r0, [r0, #-1537]	@ 0xfffff9ff
    2a88:	0402000b 	streq	r0, [r2], #-11
    2a8c:	03062201 	movweq	r2, #25089	@ 0x6201
    2a90:	0e052009 	cdpeq	0, 0, cr2, cr5, cr9, {0}
    2a94:	15050106 	strne	r0, [r5, #-262]	@ 0xfffffefa
    2a98:	10051f06 	andne	r1, r5, r6, lsl #30
    2a9c:	15050106 	strne	r0, [r5, #-262]	@ 0xfffffefa
    2aa0:	00260520 	eoreq	r0, r6, r0, lsr #10
    2aa4:	20010402 	andcs	r0, r1, r2, lsl #8
    2aa8:	02001505 	andeq	r1, r0, #20971520	@ 0x1400000
    2aac:	053c0104 	ldreq	r0, [ip, #-260]!	@ 0xfffffefc
    2ab0:	04020036 	streq	r0, [r2], #-54	@ 0xffffffca
    2ab4:	09052e02 	stmdbeq	r5, {r1, r9, sl, fp, sp}
    2ab8:	0d053206 	sfmeq	f3, 4, [r5, #-24]	@ 0xffffffe8
    2abc:	10053d92 	mulne	r5, r2, sp
    2ac0:	0d050106 	stfeqs	f0, [r5, #-24]	@ 0xffffffe8
    2ac4:	05132106 	ldreq	r2, [r3, #-262]	@ 0xfffffefa
    2ac8:	05110613 	ldreq	r0, [r1, #-1555]	@ 0xfffff9ed
    2acc:	0620210d 	strteq	r2, [r0], -sp, lsl #2
    2ad0:	674a0903 	strbvs	r0, [sl, -r3, lsl #18]
    2ad4:	01061005 	tsteq	r6, r5
    2ad8:	21060d05 	tstcs	r6, r5, lsl #26
    2adc:	06130513 			@ <UNDEFINED> instruction: 0x06130513
    2ae0:	210d0511 	tstcs	sp, r1, lsl r5
    2ae4:	20770306 	rsbscs	r0, r7, r6, lsl #6
    2ae8:	2e061d05 	cdpcs	13, 0, cr1, cr6, cr5, {0}
    2aec:	063c0d05 	ldrteq	r0, [ip], -r5, lsl #26
    2af0:	0610052f 	ldreq	r0, [r0], -pc, lsr #10
    2af4:	060d0501 	streq	r0, [sp], -r1, lsl #10
    2af8:	13051321 	movwne	r1, #21281	@ 0x5321
    2afc:	0d051106 	stfeqs	f1, [r5, #-24]	@ 0xffffffe8
    2b00:	13280621 			@ <UNDEFINED> instruction: 0x13280621
    2b04:	01061005 	tsteq	r6, r5
    2b08:	21060d05 	tstcs	r6, r5, lsl #26
    2b0c:	01061105 	tsteq	r6, r5, lsl #2
    2b10:	05201005 	streq	r1, [r0, #-5]!
    2b14:	0d052c11 	stceq	12, cr2, [r5, #-68]	@ 0xffffffbc
    2b18:	11052606 	tstne	r5, r6, lsl #12
    2b1c:	10050106 	andne	r0, r5, r6, lsl #2
    2b20:	060f054a 	streq	r0, [pc], -sl, asr #10
    2b24:	12051321 	andne	r1, r5, #-2080374784	@ 0x84000000
    2b28:	0f050106 	svceq	0x00050106
    2b2c:	15052106 	strne	r2, [r5, #-262]	@ 0xfffffefa
    2b30:	0f051006 	svceq	0x00051006
    2b34:	7a030622 	bvc	c43c4 <__ROM_SIZE__+0x843c4>
    2b38:	12051320 	andne	r1, r5, #32, 6	@ 0x80000000
    2b3c:	16050106 	strne	r0, [r5], -r6, lsl #2
    2b40:	0d052e1f 	stceq	14, cr2, [r5, #-124]	@ 0xffffff84
    2b44:	010b0306 	tsteq	fp, r6, lsl #6
    2b48:	01061105 	tsteq	r6, r5, lsl #2
    2b4c:	054a1005 	strbeq	r1, [sl, #-5]
    2b50:	1321060f 			@ <UNDEFINED> instruction: 0x1321060f
    2b54:	01061205 	tsteq	r6, r5, lsl #4
    2b58:	21060f05 	tstcs	r6, r5, lsl #30
    2b5c:	10061505 	andne	r1, r6, r5, lsl #10
    2b60:	05220f05 	streq	r0, [r2, #-3845]!	@ 0xfffff0fb
    2b64:	207a0314 	rsbscs	r0, sl, r4, lsl r3
    2b68:	0301052e 	movweq	r0, #5422	@ 0x152e
    2b6c:	14050111 	strne	r0, [r5], #-273	@ 0xfffffeef
    2b70:	02587703 	subseq	r7, r8, #786432	@ 0xc0000
    2b74:	01010006 	tsteq	r1, r6
    2b78:	0000031f 	andeq	r0, r0, pc, lsl r3
    2b7c:	01250003 			@ <UNDEFINED> instruction: 0x01250003
    2b80:	01020000 	mrseq	r0, (UNDEF: 2)
    2b84:	000d0efb 	strdeq	r0, [sp], -fp
    2b88:	01010101 	tsteq	r1, r1, lsl #2
    2b8c:	01000000 	mrseq	r0, (UNDEF: 0)
    2b90:	2f010000 	svccs	0x00010000
    2b94:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
    2b98:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
    2b9c:	63652f66 	cmnvs	r5, #408	@ 0x198
    2ba0:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
    2ba4:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
    2ba8:	732f7265 			@ <UNDEFINED> instruction: 0x732f7265
    2bac:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
    2bb0:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
    2bb4:	6974752f 	ldmdbvs	r4!, {r0, r1, r2, r3, r5, r8, sl, ip, sp, lr}^
    2bb8:	2f00736c 	svccs	0x0000736c
    2bbc:	2f74706f 	svccs	0x0074706f
    2bc0:	2d636367 	stclcs	3, cr6, [r3, #-412]!	@ 0xfffffe64
    2bc4:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	@ 0xfffffe7c
    2bc8:	656e6f6e 	strbvs	r6, [lr, #-3950]!	@ 0xfffff092
    2bcc:	6261652d 	rsbvs	r6, r1, #188743680	@ 0xb400000
    2bd0:	696c2f69 	stmdbvs	ip!, {r0, r3, r5, r6, r8, r9, sl, fp, sp}^
    2bd4:	63672f62 	cmnvs	r7, #392	@ 0x188
    2bd8:	72612f63 	rsbvc	r2, r1, #396	@ 0x18c
    2bdc:	6f6e2d6d 	svcvs	0x006e2d6d
    2be0:	652d656e 	strvs	r6, [sp, #-1390]!	@ 0xfffffa92
    2be4:	2f696261 	svccs	0x00696261
    2be8:	322e3231 	eorcc	r3, lr, #268435459	@ 0x10000003
    2bec:	692f312e 	stmdbvs	pc!, {r1, r2, r3, r5, r8, ip, sp}	@ <UNPREDICTABLE>
    2bf0:	756c636e 	strbvc	r6, [ip, #-878]!	@ 0xfffffc92
    2bf4:	2f006564 	svccs	0x00006564
    2bf8:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
    2bfc:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
    2c00:	63652f66 	cmnvs	r5, #408	@ 0x198
    2c04:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
    2c08:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
    2c0c:	732f7265 			@ <UNDEFINED> instruction: 0x732f7265
    2c10:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
    2c14:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
    2c18:	2f006c6c 	svccs	0x00006c6c
    2c1c:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
    2c20:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
    2c24:	63652f66 	cmnvs	r5, #408	@ 0x198
    2c28:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
    2c2c:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
    2c30:	732f7265 			@ <UNDEFINED> instruction: 0x732f7265
    2c34:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
    2c38:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
    2c3c:	6932612f 	ldmdbvs	r2!, {r0, r1, r2, r3, r5, r8, sp, lr}
    2c40:	6f682f00 	svcvs	0x00682f00
    2c44:	652f656d 	strvs	r6, [pc, #-1389]!	@ 26df <memlog_init+0x7>
    2c48:	2f667463 	svccs	0x00667463
    2c4c:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    2c50:	6172742d 	cmnvs	r2, sp, lsr #8
    2c54:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
    2c58:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
    2c5c:	6c2f6c6c 	stcvs	12, cr6, [pc], #-432	@ 2ab4 <cmd_end_+0x1a8>
    2c60:	702f6269 	eorvc	r6, pc, r9, ror #4
    2c64:	746e6972 	strbtvc	r6, [lr], #-2418	@ 0xfffff68e
    2c68:	75000066 	strvc	r0, [r0, #-102]	@ 0xffffff9a
    2c6c:	736c6974 	cmnvc	ip, #116, 18	@ 0x1d0000
    2c70:	0100632e 	tsteq	r0, lr, lsr #6
    2c74:	74730000 	ldrbtvc	r0, [r3], #-0
    2c78:	746e6964 	strbtvc	r6, [lr], #-2404	@ 0xfffff69c
    2c7c:	6363672d 	cmnvs	r3, #11796480	@ 0xb40000
    2c80:	0200682e 	andeq	r6, r0, #3014656	@ 0x2e0000
    2c84:	68730000 	ldmdavs	r3!, {}^	@ <UNPREDICTABLE>
    2c88:	2e6c6c65 	cdpcs	12, 6, cr6, cr12, cr5, {3}
    2c8c:	00030068 	andeq	r0, r3, r8, rrx
    2c90:	69326100 	ldmdbvs	r2!, {r8, sp, lr}
    2c94:	0400682e 	streq	r6, [r0], #-2094	@ 0xfffff7d2
    2c98:	72700000 	rsbsvc	r0, r0, #0
    2c9c:	66746e69 	ldrbtvs	r6, [r4], -r9, ror #28
    2ca0:	0500682e 	streq	r6, [r0, #-2094]	@ 0xfffff7d2
    2ca4:	05000000 	streq	r0, [r0, #-0]
    2ca8:	02050021 	andeq	r0, r5, #33	@ 0x21
    2cac:	000019a0 	andeq	r1, r0, r0, lsr #19
    2cb0:	06011803 	streq	r1, [r1], -r3, lsl #16
    2cb4:	06030501 	streq	r0, [r3], -r1, lsl #10
    2cb8:	06060521 	streq	r0, [r6], -r1, lsr #10
    2cbc:	06030501 	streq	r0, [r3], -r1, lsl #10
    2cc0:	06130533 			@ <UNDEFINED> instruction: 0x06130533
    2cc4:	052e2001 	streq	r2, [lr, #-1]!
    2cc8:	14210603 	strtne	r0, [r1], #-1539	@ 0xfffff9fd
    2ccc:	01060805 	tsteq	r6, r5, lsl #16
    2cd0:	22060305 	andcs	r0, r6, #335544320	@ 0x14000000
    2cd4:	2f062006 	svccs	0x00062006
    2cd8:	01060a05 	tsteq	r6, r5, lsl #20
    2cdc:	05210105 	streq	r0, [r1, #-261]!	@ 0xfffffefb
    2ce0:	75030605 	strvc	r0, [r3, #-1541]	@ 0xfffff9fb
    2ce4:	20200620 	eorcs	r0, r0, r0, lsr #12
    2ce8:	0c052f06 	stceq	15, cr2, [r5], {6}
    2cec:	21050106 	tstcs	r5, r6, lsl #2
    2cf0:	740c0306 	strvc	r0, [ip], #-774	@ 0xfffffcfa
    2cf4:	03050106 	movweq	r0, #20742	@ 0x5106
    2cf8:	06052f06 	streq	r2, [r5], -r6, lsl #30
    2cfc:	03050106 	movweq	r0, #20742	@ 0x5106
    2d00:	13053206 	movwne	r3, #20998	@ 0x5206
    2d04:	2e200106 	sufcss	f0, f0, f6
    2d08:	21060305 	tstcs	r6, r5, lsl #6
    2d0c:	01061305 	tsteq	r6, r5, lsl #6
    2d10:	06030520 	streq	r0, [r3], -r0, lsr #10
    2d14:	060f052f 	streq	r0, [pc], -pc, lsr #10
    2d18:	06030501 	streq	r0, [r3], -r1, lsl #10
    2d1c:	060a0522 	streq	r0, [sl], -r2, lsr #10
    2d20:	21010501 	tstcs	r1, r1, lsl #10
    2d24:	03060505 	movweq	r0, #25861	@ 0x6505
    2d28:	20062078 	andcs	r2, r6, r8, ror r0
    2d2c:	052f0620 	streq	r0, [pc, #-1568]!	@ 2714 <memlog_init+0x3c>
    2d30:	0501060c 	streq	r0, [r1, #-1548]	@ 0xfffff9f4
    2d34:	09030626 	stmdbeq	r3, {r1, r2, r5, r9, sl}
    2d38:	05010666 	streq	r0, [r1, #-1638]	@ 0xfffff99a
    2d3c:	052f0603 	streq	r0, [pc, #-1539]!	@ 2741 <memlog_getc+0x29>
    2d40:	05010606 	streq	r0, [r1, #-1542]	@ 0xfffff9fa
    2d44:	05330603 	ldreq	r0, [r3, #-1539]!	@ 0xfffff9fd
    2d48:	20010613 	andcs	r0, r1, r3, lsl r6
    2d4c:	0603052e 	streq	r0, [r3], -lr, lsr #10
    2d50:	06150521 	ldreq	r0, [r5], -r1, lsr #10
    2d54:	03052001 	movweq	r2, #20481	@ 0x5001
    2d58:	08053e06 	stmdaeq	r5, {r1, r2, r9, sl, fp, ip, sp}
    2d5c:	06110501 	ldreq	r0, [r1], -r1, lsl #10
    2d60:	20030501 	andcs	r0, r3, r1, lsl #10
    2d64:	06050520 	streq	r0, [r5], -r0, lsr #10
    2d68:	06017903 	streq	r7, [r1], -r3, lsl #18
    2d6c:	2f062020 	svccs	0x00062020
    2d70:	01060c05 	tsteq	r6, r5, lsl #24
    2d74:	02000505 	andeq	r0, r0, #20971520	@ 0x1400000
    2d78:	43060304 	movwmi	r0, #25348	@ 0x6304
    2d7c:	02000a05 	andeq	r0, r0, #20480	@ 0x5000
    2d80:	01060304 	tsteq	r6, r4, lsl #6
    2d84:	02000505 	andeq	r0, r0, #20971520	@ 0x1400000
    2d88:	21060304 	tstcs	r6, r4, lsl #6
    2d8c:	03040200 	movweq	r0, #16896	@ 0x4200
    2d90:	000a054c 	andeq	r0, sl, ip, asr #10
    2d94:	06030402 	streq	r0, [r3], -r2, lsl #8
    2d98:	002f0501 	eoreq	r0, pc, r1, lsl #10
    2d9c:	06030402 	streq	r0, [r3], -r2, lsl #8
    2da0:	0024051c 	eoreq	r0, r4, ip, lsl r5
    2da4:	20010402 	andcs	r0, r1, r2, lsl #8
    2da8:	01040200 	mrseq	r0, R12_usr
    2dac:	0a052e06 	beq	14e5cc <__ROM_SIZE__+0x10e5cc>
    2db0:	21010519 	tstcs	r1, r9, lsl r5
    2db4:	01065c06 	tsteq	r6, r6, lsl #24
    2db8:	2f060305 	svccs	0x00060305
    2dbc:	01060605 	tsteq	r6, r5, lsl #12
    2dc0:	32060305 	andcc	r0, r6, #335544320	@ 0x14000000
    2dc4:	01061305 	tsteq	r6, r5, lsl #6
    2dc8:	03052e20 	movweq	r2, #24096	@ 0x5e20
    2dcc:	16052106 	strne	r2, [r5], -r6, lsl #2
    2dd0:	05200106 	streq	r0, [r0, #-262]!	@ 0xfffffefa
    2dd4:	053d0603 	ldreq	r0, [sp, #-1539]!	@ 0xfffff9fd
    2dd8:	20010616 	andcs	r0, r1, r6, lsl r6
    2ddc:	30060305 	andcc	r0, r6, r5, lsl #6
    2de0:	01060605 	tsteq	r6, r5, lsl #12
    2de4:	33060305 	movwcc	r0, #25349	@ 0x6305
    2de8:	01060605 	tsteq	r6, r5, lsl #12
    2dec:	33060305 	movwcc	r0, #25349	@ 0x6305
    2df0:	01060c05 	tsteq	r6, r5, lsl #24
    2df4:	21060305 	tstcs	r6, r5, lsl #6
    2df8:	01061a05 	tsteq	r6, r5, lsl #20
    2dfc:	052e0805 	streq	r0, [lr, #-2053]!	@ 0xfffff7fb
    2e00:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
    2e04:	05010613 	streq	r0, [r1, #-1555]	@ 0xfffff9ed
    2e08:	08053c1c 	stmdaeq	r5, {r2, r3, r4, sl, fp, ip, sp}
    2e0c:	06030520 	streq	r0, [r3], -r0, lsr #10
    2e10:	060f052f 	streq	r0, [pc], -pc, lsr #10
    2e14:	06030501 	streq	r0, [r3], -r1, lsl #10
    2e18:	060a0522 	streq	r0, [sl], -r2, lsr #10
    2e1c:	24010501 	strcs	r0, [r1], #-1281	@ 0xfffffaff
    2e20:	03060505 	movweq	r0, #25861	@ 0x6505
    2e24:	2006206e 	andcs	r2, r6, lr, rrx
    2e28:	06242f06 	strteq	r2, [r4], -r6, lsl #30
    2e2c:	052f0620 	streq	r0, [pc, #-1568]!	@ 2814 <_etext+0x28>
    2e30:	010a0303 	tsteq	sl, r3, lsl #6
    2e34:	060a054b 	streq	r0, [sl], -fp, asr #10
    2e38:	06010501 	streq	r0, [r1], -r1, lsl #10
    2e3c:	05010694 	streq	r0, [r1, #-1684]	@ 0xfffff96c
    2e40:	052f0603 	streq	r0, [pc, #-1539]!	@ 2845 <_varcar_mesg+0x5>
    2e44:	05010606 	streq	r0, [r1, #-1542]	@ 0xfffff9fa
    2e48:	05320603 	ldreq	r0, [r2, #-1539]!	@ 0xfffff9fd
    2e4c:	20010613 	andcs	r0, r1, r3, lsl r6
    2e50:	0603052e 	streq	r0, [r3], -lr, lsr #10
    2e54:	06160521 	ldreq	r0, [r6], -r1, lsr #10
    2e58:	03052001 	movweq	r2, #20481	@ 0x5001
    2e5c:	06053e06 	streq	r3, [r5], -r6, lsl #28
    2e60:	03050106 	movweq	r0, #20742	@ 0x5106
    2e64:	0c053306 	stceq	3, cr3, [r5], {6}
    2e68:	03050106 	movweq	r0, #20742	@ 0x5106
    2e6c:	1c052106 	stfnes	f2, [r5], {6}
    2e70:	03050106 	movweq	r0, #20742	@ 0x5106
    2e74:	2e062106 	adfcss	f2, f6, f6
    2e78:	052f062e 	streq	r0, [pc, #-1582]!	@ 2852 <_varaes_test+0x6>
    2e7c:	0501060a 	streq	r0, [r1, #-1546]	@ 0xfffff9f6
    2e80:	05052501 	streq	r2, [r5, #-1281]	@ 0xfffffaff
    2e84:	20740306 	rsbscs	r0, r4, r6, lsl #6
    2e88:	2f062006 	svccs	0x00062006
    2e8c:	09030305 	stmdbeq	r3, {r0, r2, r8, r9}
    2e90:	0a054b01 	beq	155a9c <__ROM_SIZE__+0x115a9c>
    2e94:	09020106 	stmdbeq	r2, {r1, r2, r8}
    2e98:	0d010100 	stfeqs	f0, [r1, #-0]
    2e9c:	0300000b 	movweq	r0, #11
    2ea0:	0000dd00 	andeq	sp, r0, r0, lsl #26
    2ea4:	fb010200 	blx	436ae <__ROM_SIZE__+0x36ae>
    2ea8:	01000d0e 	tsteq	r0, lr, lsl #26
    2eac:	00010101 	andeq	r0, r1, r1, lsl #2
    2eb0:	00010000 	andeq	r0, r1, r0
    2eb4:	682f0100 	stmdavs	pc!, {r8}	@ <UNPREDICTABLE>
    2eb8:	2f656d6f 	svccs	0x00656d6f
    2ebc:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    2ec0:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
    2ec4:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
    2ec8:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
    2ecc:	68732f72 	ldmdavs	r3!, {r1, r4, r5, r6, r8, r9, sl, fp, sp}^
    2ed0:	2f6c6c65 	svccs	0x006c6c65
    2ed4:	2f62696c 	svccs	0x0062696c
    2ed8:	796e6974 	stmdbvc	lr!, {r2, r4, r5, r6, r8, fp, sp, lr}^
    2edc:	7365612d 	cmnvc	r5, #1073741835	@ 0x4000000b
    2ee0:	706f2f00 	rsbvc	r2, pc, r0, lsl #30
    2ee4:	63672f74 	cmnvs	r7, #116, 30	@ 0x1d0
    2ee8:	72612d63 	rsbvc	r2, r1, #6336	@ 0x18c0
    2eec:	6f6e2d6d 	svcvs	0x006e2d6d
    2ef0:	652d656e 	strvs	r6, [sp, #-1390]!	@ 0xfffffa92
    2ef4:	2f696261 	svccs	0x00696261
    2ef8:	2f62696c 	svccs	0x0062696c
    2efc:	2f636367 	svccs	0x00636367
    2f00:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	@ 0xfffffe7c
    2f04:	656e6f6e 	strbvs	r6, [lr, #-3950]!	@ 0xfffff092
    2f08:	6261652d 	rsbvs	r6, r1, #188743680	@ 0xb400000
    2f0c:	32312f69 	eorscc	r2, r1, #420	@ 0x1a4
    2f10:	312e322e 			@ <UNDEFINED> instruction: 0x312e322e
    2f14:	636e692f 	cmnvs	lr, #770048	@ 0xbc000
    2f18:	6564756c 	strbvs	r7, [r4, #-1388]!	@ 0xfffffa94
    2f1c:	6f682f00 	svcvs	0x00682f00
    2f20:	652f656d 	strvs	r6, [pc, #-1389]!	@ 29bb <cmd_end_+0xaf>
    2f24:	2f667463 	svccs	0x00667463
    2f28:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    2f2c:	6172742d 	cmnvs	r2, sp, lsr #8
    2f30:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
    2f34:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
    2f38:	6c2f6c6c 	stcvs	12, cr6, [pc], #-432	@ 2d90 <cmd_end_+0x484>
    2f3c:	732f6269 			@ <UNDEFINED> instruction: 0x732f6269
    2f40:	6e697274 	mcrvs	2, 3, r7, cr9, cr4, {3}
    2f44:	61000067 	tstvs	r0, r7, rrx
    2f48:	632e7365 			@ <UNDEFINED> instruction: 0x632e7365
    2f4c:	00000100 	andeq	r0, r0, r0, lsl #2
    2f50:	64647473 	strbtvs	r7, [r4], #-1139	@ 0xfffffb8d
    2f54:	682e6665 	stmdavs	lr!, {r0, r2, r5, r6, r9, sl, sp, lr}
    2f58:	00000200 	andeq	r0, r0, r0, lsl #4
    2f5c:	69647473 	stmdbvs	r4!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
    2f60:	672d746e 	strvs	r7, [sp, -lr, ror #8]!
    2f64:	682e6363 	stmdavs	lr!, {r0, r1, r5, r6, r8, r9, sp, lr}
    2f68:	00000200 	andeq	r0, r0, r0, lsl #4
    2f6c:	2e736561 	cdpcs	5, 7, cr6, cr3, cr1, {3}
    2f70:	00010068 	andeq	r0, r1, r8, rrx
    2f74:	72747300 	rsbsvc	r7, r4, #0, 6
    2f78:	2e676e69 	cdpcs	14, 6, cr6, cr7, cr9, {3}
    2f7c:	00030068 	andeq	r0, r3, r8, rrx
    2f80:	01050000 	mrseq	r0, (UNDEF: 5)
    2f84:	00020500 	andeq	r0, r2, r0, lsl #10
    2f88:	0300001b 	movweq	r0, #27
    2f8c:	06010192 			@ <UNDEFINED> instruction: 0x06010192
    2f90:	06030501 	streq	r0, [r3], -r1, lsl #10
    2f94:	0515132f 	ldreq	r1, [r5, #-815]	@ 0xfffffcd1
    2f98:	0501060a 	streq	r0, [r1, #-1546]	@ 0xfffff9f6
    2f9c:	05052003 	streq	r2, [r5, #-3]
    2fa0:	03040200 	movweq	r0, #16896	@ 0x4200
    2fa4:	24052206 	strcs	r2, [r5], #-518	@ 0xfffffdfa
    2fa8:	03040200 	movweq	r0, #16896	@ 0x4200
    2fac:	20050106 	andcs	r0, r5, r6, lsl #2
    2fb0:	03040200 	movweq	r0, #16896	@ 0x4200
    2fb4:	001b0520 	andseq	r0, fp, r0, lsr #10
    2fb8:	2e030402 	cdpcs	4, 0, cr0, cr3, cr2, {0}
    2fbc:	02000505 	andeq	r0, r0, #20971520	@ 0x1400000
    2fc0:	2f060304 	svccs	0x00060304
    2fc4:	02002005 	andeq	r2, r0, #5
    2fc8:	01060304 	tsteq	r6, r4, lsl #6
    2fcc:	02001b05 	andeq	r1, r0, #5120	@ 0x1400
    2fd0:	052e0304 	streq	r0, [lr, #-772]!	@ 0xfffffcfc
    2fd4:	04020005 	streq	r0, [r2], #-5
    2fd8:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
    2fdc:	04020020 	streq	r0, [r2], #-32	@ 0xffffffe0
    2fe0:	05010603 	streq	r0, [r1, #-1539]	@ 0xfffff9fd
    2fe4:	0402001b 	streq	r0, [r2], #-27	@ 0xffffffe5
    2fe8:	05052e03 	streq	r2, [r5, #-3587]	@ 0xfffff1fd
    2fec:	03040200 	movweq	r0, #16896	@ 0x4200
    2ff0:	20052106 	andcs	r2, r5, r6, lsl #2
    2ff4:	03040200 	movweq	r0, #16896	@ 0x4200
    2ff8:	1b050106 	blne	143418 <__ROM_SIZE__+0x103418>
    2ffc:	03040200 	movweq	r0, #16896	@ 0x4200
    3000:	0017052e 	andseq	r0, r7, lr, lsr #10
    3004:	06030402 	streq	r0, [r3], -r2, lsl #8
    3008:	0011051b 	andseq	r0, r1, fp, lsl r5
    300c:	20010402 	andcs	r0, r1, r2, lsl #8
    3010:	03060a05 	movweq	r0, #27141	@ 0x6a05
    3014:	05052e09 	streq	r2, [r5, #-3593]	@ 0xfffff1f7
    3018:	2e270306 	cdpcs	3, 2, cr0, cr7, cr6, {0}
    301c:	01060805 	tsteq	r6, r5, lsl #16
    3020:	02000505 	andeq	r0, r0, #20971520	@ 0x1400000
    3024:	03060204 	movweq	r0, #25092	@ 0x6204
    3028:	07052e0b 	streq	r2, [r5, -fp, lsl #28]
    302c:	02040200 	andeq	r0, r4, #0, 4
    3030:	10050106 	andne	r0, r5, r6, lsl #2
    3034:	02040200 	andeq	r0, r4, #0, 4
    3038:	15052006 	strne	r2, [r5, #-6]
    303c:	02040200 	andeq	r0, r4, #0, 4
    3040:	05050106 	streq	r0, [r5, #-262]	@ 0xfffffefa
    3044:	02040200 	andeq	r0, r4, #0, 4
    3048:	1f052f06 	svcne	0x00052f06
    304c:	02040200 	andeq	r0, r4, #0, 4
    3050:	2e050106 	adfcss	f0, f5, f6
    3054:	02040200 	andeq	r0, r4, #0, 4
    3058:	0015052e 	andseq	r0, r5, lr, lsr #10
    305c:	2e020402 	cdpcs	4, 0, cr0, cr2, cr2, {0}
    3060:	02000505 	andeq	r0, r0, #20971520	@ 0x1400000
    3064:	4b060204 	blmi	18387c <__ROM_SIZE__+0x14387c>
    3068:	02001f05 	andeq	r1, r0, #5, 30
    306c:	01060204 	tsteq	r6, r4, lsl #4
    3070:	02040200 	andeq	r0, r4, #0, 4
    3074:	002e052e 	eoreq	r0, lr, lr, lsr #10
    3078:	2e020402 	cdpcs	4, 0, cr0, cr2, cr2, {0}
    307c:	02000d05 	andeq	r0, r0, #320	@ 0x140
    3080:	052e0204 	streq	r0, [lr, #-516]!	@ 0xfffffdfc
    3084:	04020015 	streq	r0, [r2], #-21	@ 0xffffffeb
    3088:	05052002 	streq	r2, [r5, #-2]
    308c:	02040200 	andeq	r0, r4, #0, 4
    3090:	1f054b06 	svcne	0x00054b06
    3094:	02040200 	andeq	r0, r4, #0, 4
    3098:	2e050106 	adfcss	f0, f5, f6
    309c:	02040200 	andeq	r0, r4, #0, 4
    30a0:	000d052e 	andeq	r0, sp, lr, lsr #10
    30a4:	2e020402 	cdpcs	4, 0, cr0, cr2, cr2, {0}
    30a8:	02001505 	andeq	r1, r0, #20971520	@ 0x1400000
    30ac:	05200204 	streq	r0, [r0, #-516]!	@ 0xfffffdfc
    30b0:	04020005 	streq	r0, [r2], #-5
    30b4:	054b0602 	strbeq	r0, [fp, #-1538]	@ 0xfffff9fe
    30b8:	0402001f 	streq	r0, [r2], #-31	@ 0xffffffe1
    30bc:	05010602 	streq	r0, [r1, #-1538]	@ 0xfffff9fe
    30c0:	0402002e 	streq	r0, [r2], #-46	@ 0xffffffd2
    30c4:	0d052002 	stceq	0, cr2, [r5, #-8]
    30c8:	02040200 	andeq	r0, r4, #0, 4
    30cc:	0015052e 	andseq	r0, r5, lr, lsr #10
    30d0:	20020402 	andcs	r0, r2, r2, lsl #8
    30d4:	02002305 	andeq	r2, r0, #335544320	@ 0x14000000
    30d8:	03060204 	movweq	r0, #25092	@ 0x6204
    30dc:	12052e4a 	andne	r2, r5, #1184	@ 0x4a0
    30e0:	01040200 	mrseq	r0, R12_usr
    30e4:	31070520 	tstcc	r7, r0, lsr #10
    30e8:	01060e05 	tsteq	r6, r5, lsl #28
    30ec:	21060705 	tstcs	r6, r5, lsl #14
    30f0:	01061805 	tsteq	r6, r5, lsl #16
    30f4:	052e0f05 	streq	r0, [lr, #-3845]!	@ 0xfffff0fb
    30f8:	052f0607 	streq	r0, [pc, #-1543]!	@ 2af9 <cmd_end_+0x1ed>
    30fc:	2e010618 	mcrcs	6, 0, r0, cr1, cr8, {0}
    3100:	05200f05 	streq	r0, [r0, #-3845]!	@ 0xfffff0fb
    3104:	052f0607 	streq	r0, [pc, #-1543]!	@ 2b05 <cmd_end_+0x1f9>
    3108:	05010618 	streq	r0, [r1, #-1560]	@ 0xfffff9e8
    310c:	07052e0f 	streq	r2, [r5, -pc, lsl #28]
    3110:	18052f06 	stmdane	r5, {r1, r2, r8, r9, sl, fp, sp}
    3114:	0f050106 	svceq	0x00050106
    3118:	0605052e 	streq	r0, [r5], -lr, lsr #10
    311c:	06080532 			@ <UNDEFINED> instruction: 0x06080532
    3120:	06090501 	streq	r0, [r9], -r1, lsl #10
    3124:	12051343 	andne	r1, r5, #201326593	@ 0xc000001
    3128:	09050106 	stmdbeq	r5, {r1, r2, r8}
    312c:	12052f06 	andne	r2, r5, #6, 30
    3130:	09050106 	stmdbeq	r5, {r1, r2, r8}
    3134:	12052f06 	andne	r2, r5, #6, 30
    3138:	09050106 	stmdbeq	r5, {r1, r2, r8}
    313c:	12052f06 	andne	r2, r5, #6, 30
    3140:	09050106 	stmdbeq	r5, {r1, r2, r8}
    3144:	14053606 	strne	r3, [r5], #-1542	@ 0xfffff9fa
    3148:	12050106 	andne	r0, r5, #-2147483647	@ 0x80000001
    314c:	0609052e 	streq	r0, [r9], -lr, lsr #10
    3150:	0614052f 	ldreq	r0, [r4], -pc, lsr #10
    3154:	2e120501 	cfmul32cs	mvfx0, mvfx2, mvfx1
    3158:	2f060905 	svccs	0x00060905
    315c:	01061405 	tsteq	r6, r5, lsl #8
    3160:	052e1205 	streq	r1, [lr, #-517]!	@ 0xfffffdfb
    3164:	052f0609 	streq	r0, [pc, #-1545]!	@ 2b63 <cmd_end_+0x257>
    3168:	05010614 	streq	r0, [r1, #-1556]	@ 0xfffff9ec
    316c:	07052012 	smladeq	r5, r2, r0, r2
    3170:	21053106 	tstcs	r5, r6, lsl #2
    3174:	10050106 	andne	r0, r5, r6, lsl #2
    3178:	0609054a 	streq	r0, [r9], -sl, asr #10
    317c:	06140551 			@ <UNDEFINED> instruction: 0x06140551
    3180:	4a120501 	bmi	48458c <__ROM_SIZE__+0x44458c>
    3184:	2f060905 	svccs	0x00060905
    3188:	01061405 	tsteq	r6, r5, lsl #8
    318c:	053c1205 	ldreq	r1, [ip, #-517]!	@ 0xfffffdfb
    3190:	052f0609 	streq	r0, [pc, #-1545]!	@ 2b8f <cmd_end_+0x283>
    3194:	05010614 	streq	r0, [r1, #-1556]	@ 0xfffff9ec
    3198:	09053c12 	stmdbeq	r5, {r1, r4, sl, fp, ip, sp}
    319c:	14052f06 	strne	r2, [r5], #-3846	@ 0xfffff0fa
    31a0:	12050106 	andne	r0, r5, #-2147483647	@ 0x80000001
    31a4:	0301053c 	movweq	r0, #5436	@ 0x153c
    31a8:	00063c0a 	andeq	r3, r6, sl, lsl #24
    31ac:	1c200205 	sfmne	f0, 4, [r0], #-20	@ 0xffffffec
    31b0:	15030000 	strne	r0, [r3, #-0]
    31b4:	05010601 	streq	r0, [r1, #-1537]	@ 0xfffff9ff
    31b8:	13210603 			@ <UNDEFINED> instruction: 0x13210603
    31bc:	01060a05 	tsteq	r6, r5, lsl #20
    31c0:	05200305 	streq	r0, [r0, #-773]!	@ 0xfffffcfb
    31c4:	04020007 	streq	r0, [r2], #-7
    31c8:	05240603 	streq	r0, [r4, #-1539]!	@ 0xfffff9fd
    31cc:	04020012 	streq	r0, [r2], #-18	@ 0xffffffee
    31d0:	05010603 	streq	r0, [r1, #-1539]	@ 0xfffff9fd
    31d4:	04020033 	streq	r0, [r2], #-51	@ 0xffffffcd
    31d8:	3e054a03 	vmlacc.f32	s8, s10, s6
    31dc:	03040200 	movweq	r0, #16896	@ 0x4200
    31e0:	0021052e 	eoreq	r0, r1, lr, lsr #10
    31e4:	2e030402 	cdpcs	4, 0, cr0, cr3, cr2, {0}
    31e8:	02001605 	andeq	r1, r0, #5242880	@ 0x500000
    31ec:	052e0304 	streq	r0, [lr, #-772]!	@ 0xfffffcfc
    31f0:	04020018 	streq	r0, [r2], #-24	@ 0xffffffe8
    31f4:	00480603 	subeq	r0, r8, r3, lsl #12
    31f8:	06030402 	streq	r0, [r3], -r2, lsl #8
    31fc:	00130520 	andseq	r0, r3, r0, lsr #10
    3200:	06010402 	streq	r0, [r1], -r2, lsl #8
    3204:	00160520 	andseq	r0, r6, r0, lsr #10
    3208:	2c020402 	cfstrscs	mvf0, [r2], {2}
    320c:	02040200 	andeq	r0, r4, #0, 4
    3210:	11052006 	tstne	r5, r6
    3214:	01040200 	mrseq	r0, R12_usr
    3218:	0c052006 	stceq	0, cr2, [r5], {6}
    321c:	01053006 	tsteq	r5, r6
    3220:	00062033 	andeq	r2, r6, r3, lsr r0
    3224:	1c580205 	lfmne	f0, 2, [r8], {5}
    3228:	05170000 	ldreq	r0, [r7, #-0]
    322c:	05131303 	ldreq	r1, [r3, #-771]	@ 0xfffffcfd
    3230:	0501060a 	streq	r0, [r1, #-1546]	@ 0xfffff9f6
    3234:	05200611 	streq	r0, [r0, #-1553]!	@ 0xfffff9ef
    3238:	0530060c 	ldreq	r0, [r0, #-1548]!	@ 0xfffff9f4
    323c:	05200613 	streq	r0, [r0, #-1555]!	@ 0xfffff9ed
    3240:	052a0601 	streq	r0, [sl, #-1537]!	@ 0xfffff9ff
    3244:	04020007 	streq	r0, [r2], #-7
    3248:	05260603 	streq	r0, [r6, #-1539]!	@ 0xfffff9fd
    324c:	04020018 	streq	r0, [r2], #-24	@ 0xffffffe8
    3250:	05010603 	streq	r0, [r1, #-1539]	@ 0xfffff9fd
    3254:	04020016 	streq	r0, [r2], #-22	@ 0xffffffea
    3258:	18057403 	stmdane	r5, {r0, r1, sl, ip, sp, lr}
    325c:	03040200 	movweq	r0, #16896	@ 0x4200
    3260:	02002c06 	andeq	r2, r0, #1536	@ 0x600
    3264:	20060304 	andcs	r0, r6, r4, lsl #6
    3268:	02001305 	andeq	r1, r0, #335544320	@ 0x14000000
    326c:	20060104 	andcs	r0, r6, r4, lsl #2
    3270:	02001605 	andeq	r1, r0, #5242880	@ 0x500000
    3274:	002c0204 	eoreq	r0, ip, r4, lsl #4
    3278:	06020402 	streq	r0, [r2], -r2, lsl #8
    327c:	00110520 	andseq	r0, r1, r0, lsr #10
    3280:	06020402 	streq	r0, [r2], -r2, lsl #8
    3284:	060c0520 	streq	r0, [ip], -r0, lsr #10
    3288:	01052030 	tsteq	r5, r0, lsr r0
    328c:	06160525 	ldreq	r0, [r6], -r5, lsr #10
    3290:	062e7903 	strteq	r7, [lr], -r3, lsl #18
    3294:	05202020 	streq	r2, [r0, #-32]!	@ 0xffffffe0
    3298:	0d030601 	stceq	6, cr0, [r3, #-4]
    329c:	1303053c 	movwne	r0, #13628	@ 0x353c
    32a0:	06120515 			@ <UNDEFINED> instruction: 0x06120515
    32a4:	06030501 	streq	r0, [r3], -r1, lsl #10
    32a8:	061f0521 	ldreq	r0, [pc], -r1, lsr #10
    32ac:	20120501 	andscs	r0, r2, r1, lsl #10
    32b0:	21060305 	tstcs	r6, r5, lsl #6
    32b4:	01061f05 	tsteq	r6, r5, lsl #30
    32b8:	05201205 	streq	r1, [r0, #-517]!	@ 0xfffffdfb
    32bc:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
    32c0:	0501061f 	streq	r0, [r1, #-1567]	@ 0xfffff9e1
    32c4:	03052012 	movweq	r2, #20498	@ 0x5012
    32c8:	12052106 	andne	r2, r5, #-2147483647	@ 0x80000001
    32cc:	03050106 	movweq	r0, #20742	@ 0x5106
    32d0:	12052306 	andne	r2, r5, #402653184	@ 0x18000000
    32d4:	03050106 	movweq	r0, #20742	@ 0x5106
    32d8:	1f052106 	svcne	0x00052106
    32dc:	12050106 	andne	r0, r5, #-2147483647	@ 0x80000001
    32e0:	06030520 	streq	r0, [r3], -r0, lsr #10
    32e4:	06120521 	ldreq	r0, [r2], -r1, lsr #10
    32e8:	06030501 	streq	r0, [r3], -r1, lsl #10
    32ec:	06120522 	ldreq	r0, [r2], -r2, lsr #10
    32f0:	06030501 	streq	r0, [r3], -r1, lsl #10
    32f4:	061f0521 	ldreq	r0, [pc], -r1, lsr #10
    32f8:	20120501 	andscs	r0, r2, r1, lsl #10
    32fc:	21060305 	tstcs	r6, r5, lsl #6
    3300:	01061205 	tsteq	r6, r5, lsl #4
    3304:	23060305 	movwcs	r0, #25349	@ 0x6305
    3308:	01061205 	tsteq	r6, r5, lsl #4
    330c:	21060305 	tstcs	r6, r5, lsl #6
    3310:	01061f05 	tsteq	r6, r5, lsl #30
    3314:	05201205 	streq	r1, [r0, #-517]!	@ 0xfffffdfb
    3318:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
    331c:	0501061f 	streq	r0, [r1, #-1567]	@ 0xfffff9e1
    3320:	03052012 	movweq	r2, #20498	@ 0x5012
    3324:	1f052106 	svcne	0x00052106
    3328:	12050106 	andne	r0, r5, #-2147483647	@ 0x80000001
    332c:	06030520 	streq	r0, [r3], -r0, lsr #10
    3330:	06120521 	ldreq	r0, [r2], -r1, lsr #10
    3334:	21010501 	tstcs	r1, r1, lsl #10
    3338:	03052306 	movweq	r2, #21254	@ 0x5306
    333c:	06120513 			@ <UNDEFINED> instruction: 0x06120513
    3340:	75010501 	strvc	r0, [r1, #-1281]	@ 0xfffffaff
    3344:	01063206 	tsteq	r6, r6, lsl #4
    3348:	3d060305 	stccc	3, cr0, [r6, #-20]	@ 0xffffffec
    334c:	0a051313 	beq	147fa0 <__ROM_SIZE__+0x107fa0>
    3350:	03050106 	movweq	r0, #20742	@ 0x5106
    3354:	00050520 	andeq	r0, r5, r0, lsr #10
    3358:	06030402 	streq	r0, [r3], -r2, lsl #8
    335c:	00090522 	andeq	r0, r9, r2, lsr #10
    3360:	06030402 	streq	r0, [r3], -r2, lsl #8
    3364:	00050501 	andeq	r0, r5, r1, lsl #10
    3368:	06030402 	streq	r0, [r3], -r2, lsl #8
    336c:	0027052f 	eoreq	r0, r7, pc, lsr #10
    3370:	06030402 	streq	r0, [r3], -r2, lsl #8
    3374:	00090501 	andeq	r0, r9, r1, lsl #10
    3378:	4a030402 	bmi	c4388 <__ROM_SIZE__+0x84388>
    337c:	02003805 	andeq	r3, r0, #327680	@ 0x50000
    3380:	052e0304 	streq	r0, [lr, #-772]!	@ 0xfffffcfc
    3384:	04020049 	streq	r0, [r2], #-73	@ 0xffffffb7
    3388:	09052e03 	stmdbeq	r5, {r0, r1, r9, sl, fp, sp}
    338c:	03040200 	movweq	r0, #16896	@ 0x4200
    3390:	00050520 	andeq	r0, r5, r0, lsr #10
    3394:	06030402 	streq	r0, [r3], -r2, lsl #8
    3398:	002d053d 	eoreq	r0, sp, sp, lsr r5
    339c:	01030402 	tsteq	r3, r2, lsl #8
    33a0:	02003205 	andeq	r3, r0, #1342177280	@ 0x50000000
    33a4:	01060304 	tsteq	r6, r4, lsl #6
    33a8:	02003e05 	andeq	r3, r0, #5, 28	@ 0x50
    33ac:	2e060304 	cdpcs	3, 0, cr0, cr6, cr4, {0}
    33b0:	02004d05 	andeq	r4, r0, #320	@ 0x140
    33b4:	01060304 	tsteq	r6, r4, lsl #6
    33b8:	03040200 	movweq	r0, #16896	@ 0x4200
    33bc:	00050520 	andeq	r0, r5, r0, lsr #10
    33c0:	06030402 	streq	r0, [r3], -r2, lsl #8
    33c4:	002d054b 	eoreq	r0, sp, fp, asr #10
    33c8:	01030402 	tsteq	r3, r2, lsl #8
    33cc:	02003205 	andeq	r3, r0, #1342177280	@ 0x50000000
    33d0:	01060304 	tsteq	r6, r4, lsl #6
    33d4:	03040200 	movweq	r0, #16896	@ 0x4200
    33d8:	003e052e 	eorseq	r0, lr, lr, lsr #10
    33dc:	06030402 	streq	r0, [r3], -r2, lsl #8
    33e0:	004d052e 	subeq	r0, sp, lr, lsr #10
    33e4:	06030402 	streq	r0, [r3], -r2, lsl #8
    33e8:	04020001 	streq	r0, [r2], #-1
    33ec:	05052003 	streq	r2, [r5, #-3]
    33f0:	03040200 	movweq	r0, #16896	@ 0x4200
    33f4:	2d054b06 	vstrcs	d4, [r5, #-24]	@ 0xffffffe8
    33f8:	03040200 	movweq	r0, #16896	@ 0x4200
    33fc:	00320501 	eorseq	r0, r2, r1, lsl #10
    3400:	06030402 	streq	r0, [r3], -r2, lsl #8
    3404:	04020001 	streq	r0, [r2], #-1
    3408:	3e052e03 	cdpcc	14, 0, cr2, cr5, cr3, {0}
    340c:	03040200 	movweq	r0, #16896	@ 0x4200
    3410:	4d052e06 	stcmi	14, cr2, [r5, #-24]	@ 0xffffffe8
    3414:	03040200 	movweq	r0, #16896	@ 0x4200
    3418:	02000106 	andeq	r0, r0, #-2147483647	@ 0x80000001
    341c:	05200304 	streq	r0, [r0, #-772]!	@ 0xfffffcfc
    3420:	04020005 	streq	r0, [r2], #-5
    3424:	054b0603 	strbeq	r0, [fp, #-1539]	@ 0xfffff9fd
    3428:	0402002d 	streq	r0, [r2], #-45	@ 0xffffffd3
    342c:	32050103 	andcc	r0, r5, #-1073741824	@ 0xc0000000
    3430:	03040200 	movweq	r0, #16896	@ 0x4200
    3434:	02000106 	andeq	r0, r0, #-2147483647	@ 0x80000001
    3438:	052e0304 	streq	r0, [lr, #-772]!	@ 0xfffffcfc
    343c:	0402003e 	streq	r0, [r2], #-62	@ 0xffffffc2
    3440:	052e0603 	streq	r0, [lr, #-1539]!	@ 0xfffff9fd
    3444:	0402004d 	streq	r0, [r2], #-77	@ 0xffffffb3
    3448:	00010603 	andeq	r0, r1, r3, lsl #12
    344c:	4a030402 	bmi	c445c <__ROM_SIZE__+0x8445c>
    3450:	02001605 	andeq	r1, r0, #5242880	@ 0x500000
    3454:	03060304 	movweq	r0, #25348	@ 0x6304
    3458:	02002079 	andeq	r2, r0, #121	@ 0x79
    345c:	20060304 	andcs	r0, r6, r4, lsl #6
    3460:	02001105 	andeq	r1, r0, #1073741825	@ 0x40000001
    3464:	20060104 	andcs	r0, r6, r4, lsl #2
    3468:	03060105 	movweq	r0, #24837	@ 0x6105
    346c:	062e2e09 	strteq	r2, [lr], -r9, lsl #28
    3470:	56020500 	strpl	r0, [r2], -r0, lsl #10
    3474:	0300001d 	movweq	r0, #29
    3478:	01060126 	tsteq	r6, r6, lsr #2
    347c:	4b060305 	blmi	184098 <__ROM_SIZE__+0x144098>
    3480:	0a051313 	beq	1480d4 <__ROM_SIZE__+0x1080d4>
    3484:	03050106 	movweq	r0, #20742	@ 0x5106
    3488:	00050520 	andeq	r0, r5, r0, lsr #10
    348c:	06030402 	streq	r0, [r3], -r2, lsl #8
    3490:	00070522 	andeq	r0, r7, r2, lsr #10
    3494:	06030402 	streq	r0, [r3], -r2, lsl #8
    3498:	00050501 	andeq	r0, r5, r1, lsl #10
    349c:	06030402 	streq	r0, [r3], -r2, lsl #8
    34a0:	0007053d 	andeq	r0, r7, sp, lsr r5
    34a4:	06030402 	streq	r0, [r3], -r2, lsl #8
    34a8:	00050501 	andeq	r0, r5, r1, lsl #10
    34ac:	06030402 	streq	r0, [r3], -r2, lsl #8
    34b0:	0007054b 	andeq	r0, r7, fp, asr #10
    34b4:	06030402 	streq	r0, [r3], -r2, lsl #8
    34b8:	00050501 	andeq	r0, r5, r1, lsl #10
    34bc:	06030402 	streq	r0, [r3], -r2, lsl #8
    34c0:	0007052f 	andeq	r0, r7, pc, lsr #10
    34c4:	06030402 	streq	r0, [r3], -r2, lsl #8
    34c8:	00050501 	andeq	r0, r5, r1, lsl #10
    34cc:	06030402 	streq	r0, [r3], -r2, lsl #8
    34d0:	00160530 	andseq	r0, r6, r0, lsr r5
    34d4:	06030402 	streq	r0, [r3], -r2, lsl #8
    34d8:	002a0501 	eoreq	r0, sl, r1, lsl #10
    34dc:	9e030402 	cdpls	4, 0, cr0, cr3, cr2, {0}
    34e0:	02003e05 	andeq	r3, r0, #5, 28	@ 0x50
    34e4:	059e0304 	ldreq	r0, [lr, #772]	@ 0x304
    34e8:	04020052 	streq	r0, [r2], #-82	@ 0xffffffae
    34ec:	16059e03 	strne	r9, [r5], -r3, lsl #28
    34f0:	03040200 	movweq	r0, #16896	@ 0x4200
    34f4:	002a0590 	mlaeq	sl, r0, r5, r0
    34f8:	90030402 	andls	r0, r3, r2, lsl #8
    34fc:	02002805 	andeq	r2, r0, #327680	@ 0x50000
    3500:	05740304 	ldrbeq	r0, [r4, #-772]!	@ 0xfffffcfc
    3504:	0402003e 	streq	r0, [r2], #-62	@ 0xffffffc2
    3508:	3c052003 	stccc	0, cr2, [r5], {3}
    350c:	03040200 	movweq	r0, #16896	@ 0x4200
    3510:	00520566 	subseq	r0, r2, r6, ror #10
    3514:	20030402 	andcs	r0, r3, r2, lsl #8
    3518:	02005005 	andeq	r5, r0, #5
    351c:	053c0304 	ldreq	r0, [ip, #-772]!	@ 0xfffffcfc
    3520:	04020014 	streq	r0, [r2], #-20	@ 0xffffffec
    3524:	05052003 	streq	r2, [r5, #-3]
    3528:	03040200 	movweq	r0, #16896	@ 0x4200
    352c:	16054b06 	strne	r4, [r5], -r6, lsl #22
    3530:	03040200 	movweq	r0, #16896	@ 0x4200
    3534:	2a050106 	bcs	143954 <__ROM_SIZE__+0x103954>
    3538:	03040200 	movweq	r0, #16896	@ 0x4200
    353c:	0028053c 	eoreq	r0, r8, ip, lsr r5
    3540:	82030402 	andhi	r0, r3, #33554432	@ 0x2000000
    3544:	02003e05 	andeq	r3, r0, #5, 28	@ 0x50
    3548:	05200304 	streq	r0, [r0, #-772]!	@ 0xfffffcfc
    354c:	0402003c 	streq	r0, [r2], #-60	@ 0xffffffc4
    3550:	52057403 	andpl	r7, r5, #50331648	@ 0x3000000
    3554:	03040200 	movweq	r0, #16896	@ 0x4200
    3558:	00500520 	subseq	r0, r0, r0, lsr #10
    355c:	58030402 	stmdapl	r3, {r1, sl}
    3560:	02001405 	andeq	r1, r0, #83886080	@ 0x5000000
    3564:	05200304 	streq	r0, [r0, #-772]!	@ 0xfffffcfc
    3568:	04020005 	streq	r0, [r2], #-5
    356c:	052f0603 	streq	r0, [pc, #-1539]!	@ 2f71 <cmd_end_+0x665>
    3570:	04020016 	streq	r0, [r2], #-22	@ 0xffffffea
    3574:	05010603 	streq	r0, [r1, #-1539]	@ 0xfffff9fd
    3578:	0402002a 	streq	r0, [r2], #-42	@ 0xffffffd6
    357c:	28056603 	stmdacs	r5, {r0, r1, r9, sl, sp, lr}
    3580:	03040200 	movweq	r0, #16896	@ 0x4200
    3584:	003e053c 	eorseq	r0, lr, ip, lsr r5
    3588:	20030402 	andcs	r0, r3, r2, lsl #8
    358c:	02003c05 	andeq	r3, r0, #1280	@ 0x500
    3590:	05660304 	strbeq	r0, [r6, #-772]!	@ 0xfffffcfc
    3594:	04020052 	streq	r0, [r2], #-82	@ 0xffffffae
    3598:	02002003 	andeq	r2, r0, #3
    359c:	052e0304 	streq	r0, [lr, #-772]!	@ 0xfffffcfc
    35a0:	04020050 	streq	r0, [r2], #-80	@ 0xffffffb0
    35a4:	14053c03 	strne	r3, [r5], #-3075	@ 0xfffff3fd
    35a8:	03040200 	movweq	r0, #16896	@ 0x4200
    35ac:	00050520 	andeq	r0, r5, r0, lsr #10
    35b0:	06030402 	streq	r0, [r3], -r2, lsl #8
    35b4:	0016052f 	andseq	r0, r6, pc, lsr #10
    35b8:	06030402 	streq	r0, [r3], -r2, lsl #8
    35bc:	002a0501 	eoreq	r0, sl, r1, lsl #10
    35c0:	58030402 	stmdapl	r3, {r1, sl}
    35c4:	02002805 	andeq	r2, r0, #327680	@ 0x50000
    35c8:	05660304 	strbeq	r0, [r6, #-772]!	@ 0xfffffcfc
    35cc:	0402003e 	streq	r0, [r2], #-62	@ 0xffffffc2
    35d0:	3c052003 	stccc	0, cr2, [r5], {3}
    35d4:	03040200 	movweq	r0, #16896	@ 0x4200
    35d8:	0052053c 	subseq	r0, r2, ip, lsr r5
    35dc:	20030402 	andcs	r0, r3, r2, lsl #8
    35e0:	02005005 	andeq	r5, r0, #5
    35e4:	05660304 	strbeq	r0, [r6, #-772]!	@ 0xfffffcfc
    35e8:	04020014 	streq	r0, [r2], #-20	@ 0xffffffec
    35ec:	16052003 	strne	r2, [r5], -r3
    35f0:	03040200 	movweq	r0, #16896	@ 0x4200
    35f4:	2e760306 	cdpcs	3, 7, cr0, cr6, cr6, {0}
    35f8:	02001105 	andeq	r1, r0, #1073741825	@ 0x40000001
    35fc:	05200104 	streq	r0, [r0, #-260]!	@ 0xfffffefc
    3600:	0c030601 	stceq	6, cr0, [r3], {1}
    3604:	062e203c 			@ <UNDEFINED> instruction: 0x062e203c
    3608:	b0020500 	andlt	r0, r2, r0, lsl #10
    360c:	1800001e 	stmdane	r0, {r1, r2, r3, r4}
    3610:	13130305 	tstne	r3, #335544320	@ 0x14000000
    3614:	01060a05 	tsteq	r6, r5, lsl #20
    3618:	20061105 	andcs	r1, r6, r5, lsl #2
    361c:	30060c05 	andcc	r0, r6, r5, lsl #24
    3620:	20061305 	andcs	r1, r6, r5, lsl #6
    3624:	2a060105 	bcs	183a40 <__ROM_SIZE__+0x143a40>
    3628:	02000705 	andeq	r0, r0, #1310720	@ 0x140000
    362c:	26060304 	strcs	r0, [r6], -r4, lsl #6
    3630:	02001805 	andeq	r1, r0, #327680	@ 0x50000
    3634:	01060304 	tsteq	r6, r4, lsl #6
    3638:	02001605 	andeq	r1, r0, #5242880	@ 0x500000
    363c:	05820304 	streq	r0, [r2, #772]	@ 0x304
    3640:	04020018 	streq	r0, [r2], #-24	@ 0xffffffe8
    3644:	002c0603 	eoreq	r0, ip, r3, lsl #12
    3648:	06030402 	streq	r0, [r3], -r2, lsl #8
    364c:	00130520 	andseq	r0, r3, r0, lsr #10
    3650:	06010402 	streq	r0, [r1], -r2, lsl #8
    3654:	00160520 	andseq	r0, r6, r0, lsr #10
    3658:	2c020402 	cfstrscs	mvf0, [r2], {2}
    365c:	02040200 	andeq	r0, r4, #0, 4
    3660:	11052006 	tstne	r5, r6
    3664:	02040200 	andeq	r0, r4, #0, 4
    3668:	0c052006 	stceq	0, cr2, [r5], {6}
    366c:	05203006 	streq	r3, [r0, #-6]!
    3670:	16052501 	strne	r2, [r5], -r1, lsl #10
    3674:	2e790306 	cdpcs	3, 7, cr0, cr9, cr6, {0}
    3678:	20202006 	eorcs	r2, r0, r6
    367c:	03060105 	movweq	r0, #24837	@ 0x6105
    3680:	03054a0a 	movweq	r4, #23050	@ 0x5a0a
    3684:	08051513 	stmdaeq	r5, {r0, r1, r4, r8, sl, ip}
    3688:	03050106 	movweq	r0, #20742	@ 0x5106
    368c:	1f052106 	svcne	0x00052106
    3690:	12050106 	andne	r0, r5, #-2147483647	@ 0x80000001
    3694:	06030520 	streq	r0, [r3], -r0, lsr #10
    3698:	061f0521 	ldreq	r0, [pc], -r1, lsr #10
    369c:	20120501 	andscs	r0, r2, r1, lsl #10
    36a0:	21060305 	tstcs	r6, r5, lsl #6
    36a4:	01061f05 	tsteq	r6, r5, lsl #30
    36a8:	05201205 	streq	r1, [r0, #-517]!	@ 0xfffffdfb
    36ac:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
    36b0:	05010612 	streq	r0, [r1, #-1554]	@ 0xfffff9ee
    36b4:	05230603 	streq	r0, [r3, #-1539]!	@ 0xfffff9fd
    36b8:	05010608 	streq	r0, [r1, #-1544]	@ 0xfffff9f8
    36bc:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
    36c0:	0501061f 	streq	r0, [r1, #-1567]	@ 0xfffff9e1
    36c4:	03052012 	movweq	r2, #20498	@ 0x5012
    36c8:	12052106 	andne	r2, r5, #-2147483647	@ 0x80000001
    36cc:	03050106 	movweq	r0, #20742	@ 0x5106
    36d0:	08052206 	stmdaeq	r5, {r1, r2, r9, sp}
    36d4:	03050106 	movweq	r0, #20742	@ 0x5106
    36d8:	1f052106 	svcne	0x00052106
    36dc:	12050106 	andne	r0, r5, #-2147483647	@ 0x80000001
    36e0:	06030520 	streq	r0, [r3], -r0, lsr #10
    36e4:	06120521 	ldreq	r0, [r2], -r1, lsr #10
    36e8:	06030501 	streq	r0, [r3], -r1, lsl #10
    36ec:	06080523 	streq	r0, [r8], -r3, lsr #10
    36f0:	06030501 	streq	r0, [r3], -r1, lsl #10
    36f4:	061f0521 	ldreq	r0, [pc], -r1, lsr #10
    36f8:	20120501 	andscs	r0, r2, r1, lsl #10
    36fc:	21060305 	tstcs	r6, r5, lsl #6
    3700:	01061f05 	tsteq	r6, r5, lsl #30
    3704:	05201205 	streq	r1, [r0, #-517]!	@ 0xfffffdfb
    3708:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
    370c:	0501061f 	streq	r0, [r1, #-1567]	@ 0xfffff9e1
    3710:	03052012 	movweq	r2, #20498	@ 0x5012
    3714:	12052106 	andne	r2, r5, #-2147483647	@ 0x80000001
    3718:	01050106 	tsteq	r5, r6, lsl #2
    371c:	06250621 	strteq	r0, [r5], -r1, lsr #12
    3720:	06030501 	streq	r0, [r3], -r1, lsl #10
    3724:	2e06153d 	mcrcs	5, 0, r1, cr6, cr13, {1}
    3728:	05340620 	ldreq	r0, [r4, #-1568]!	@ 0xfffff9e0
    372c:	0501060e 	streq	r0, [r1, #-1550]	@ 0xfffff9f2
    3730:	3d350605 	ldccc	6, cr0, [r5, #-20]!	@ 0xffffffec
    3734:	78031505 	stmdavc	r3, {r0, r2, r8, sl, ip}
    3738:	05200658 	streq	r0, [r0, #-1624]!	@ 0xfffff9a8
    373c:	05200603 	streq	r0, [r0, #-1539]!	@ 0xfffff9fd
    3740:	3d3d1405 	cfldrscc	mvf1, [sp, #-20]!	@ 0xffffffec
    3744:	01060805 	tsteq	r6, r5, lsl #16
    3748:	35060305 	strcc	r0, [r6, #-773]	@ 0xfffffcfb
    374c:	59060105 	stmdbpl	r6, {r0, r2, r8}
    3750:	05000620 	streq	r0, [r0, #-1568]	@ 0xfffff9e0
    3754:	001f6e02 	andseq	r6, pc, r2, lsl #28
    3758:	01061600 	tsteq	r6, r0, lsl #12
    375c:	3d060305 	stccc	3, cr0, [r6, #-20]	@ 0xffffffec
    3760:	202e0615 	eorcs	r0, lr, r5, lsl r6
    3764:	0e053406 	cdpeq	4, 0, cr3, cr5, cr6, {0}
    3768:	05050106 	streq	r0, [r5, #-262]	@ 0xfffffefa
    376c:	1c053606 	stcne	6, cr3, [r5], {6}
    3770:	063c7803 	ldrteq	r7, [ip], -r3, lsl #16
    3774:	06030520 	streq	r0, [r3], -r0, lsr #10
    3778:	14050520 	strne	r0, [r5], #-1312	@ 0xfffffae0
    377c:	05593d3d 	ldrbeq	r3, [r9, #-3389]	@ 0xfffff2c3
    3780:	05010608 	streq	r0, [r1, #-1544]	@ 0xfffff9f8
    3784:	06203401 	strteq	r3, [r0], -r1, lsl #8
    3788:	a8020500 	stmdage	r2, {r8, sl}
    378c:	0300001f 	movweq	r0, #31
    3790:	03050120 	movweq	r0, #20768	@ 0x5120
    3794:	0a051313 	beq	1483e8 <__ROM_SIZE__+0x1083e8>
    3798:	03050106 	movweq	r0, #20742	@ 0x5106
    379c:	00050520 	andeq	r0, r5, r0, lsr #10
    37a0:	06030402 	streq	r0, [r3], -r2, lsl #8
    37a4:	00080522 	andeq	r0, r8, r2, lsr #10
    37a8:	06030402 	streq	r0, [r3], -r2, lsl #8
    37ac:	00110501 	andseq	r0, r1, r1, lsl #10
    37b0:	20030402 	andcs	r0, r3, r2, lsl #8
    37b4:	02000c05 	andeq	r0, r0, #1280	@ 0x500
    37b8:	052e0304 	streq	r0, [lr, #-772]!	@ 0xfffffcfc
    37bc:	04020021 	streq	r0, [r2], #-33	@ 0xffffffdf
    37c0:	003a0603 	eorseq	r0, sl, r3, lsl #12
    37c4:	06030402 	streq	r0, [r3], -r2, lsl #8
    37c8:	00110520 	andseq	r0, r1, r0, lsr #10
    37cc:	06010402 	streq	r0, [r1], -r2, lsl #8
    37d0:	06010520 	streq	r0, [r1], -r0, lsr #10
    37d4:	e9030632 	stmdb	r3, {r1, r4, r5, r9, sl}
    37d8:	0106207d 	tsteq	r6, sp, ror r0
    37dc:	21060305 	tstcs	r6, r5, lsl #6
    37e0:	2f060105 	svccs	0x00060105
    37e4:	01062306 	tsteq	r6, r6, lsl #6
    37e8:	3d060305 	stccc	3, cr0, [r6, #-20]	@ 0xffffffec
    37ec:	0601052f 	streq	r0, [r1], -pc, lsr #10
    37f0:	00062067 	andeq	r2, r6, r7, rrx
    37f4:	1fe20205 	svcne	0x00e20205
    37f8:	06140000 	ldreq	r0, [r4], -r0
    37fc:	06030501 	streq	r0, [r3], -r1, lsl #10
    3800:	052e0621 	streq	r0, [lr, #-1569]!	@ 0xfffff9df
    3804:	03062f01 	movweq	r2, #28417	@ 0x6f01
    3808:	062001ef 	strteq	r0, [r0], -pc, ror #3
    380c:	06030501 	streq	r0, [r3], -r1, lsl #10
    3810:	20200630 	eorcs	r0, r0, r0, lsr r6
    3814:	062f0105 	strteq	r0, [pc], -r5, lsl #2
    3818:	05010623 	streq	r0, [r1, #-1571]	@ 0xfffff9dd
    381c:	06300603 	ldrteq	r0, [r0], -r3, lsl #12
    3820:	01052020 	tsteq	r5, r0, lsr #32
    3824:	1603062f 	strne	r0, [r3], -pc, lsr #12
    3828:	05010620 	streq	r0, [r1, #-1568]	@ 0xfffff9e0
    382c:	13590603 	cmpne	r9, #3145728	@ 0x300000
    3830:	01060c05 	tsteq	r6, r5, lsl #24
    3834:	2f060305 	svccs	0x00060305
    3838:	11060c05 	tstne	r6, r5, lsl #24
    383c:	05210a05 	streq	r0, [r1, #-2565]!	@ 0xfffff5fb
    3840:	05052003 	streq	r2, [r5, #-3]
    3844:	03040200 	movweq	r0, #16896	@ 0x4200
    3848:	02002206 	andeq	r2, r0, #1610612736	@ 0x60000000
    384c:	003d0304 	eorseq	r0, sp, r4, lsl #6
    3850:	4b030402 	blmi	c4860 <__ROM_SIZE__+0x84860>
    3854:	03040200 	movweq	r0, #16896	@ 0x4200
    3858:	001d0513 	andseq	r0, sp, r3, lsl r5
    385c:	0d030402 	cfstrseq	mvf0, [r3, #-8]
    3860:	02000805 	andeq	r0, r0, #327680	@ 0x50000
    3864:	24060304 	strcs	r0, [r6], #-772	@ 0xfffffcfc
    3868:	02000905 	andeq	r0, r0, #81920	@ 0x14000
    386c:	05210304 	streq	r0, [r1, #-772]!	@ 0xfffffcfc
    3870:	04020011 	streq	r0, [r2], #-17	@ 0xffffffef
    3874:	051b0601 	ldreq	r0, [fp, #-1537]	@ 0xfffff9ff
    3878:	01053603 	tsteq	r5, r3, lsl #12
    387c:	062e4b06 	strteq	r4, [lr], -r6, lsl #22
    3880:	42020500 	andmi	r0, r2, #0, 10
    3884:	15000020 	strne	r0, [r0, #-32]	@ 0xffffffe0
    3888:	03050106 	movweq	r0, #20742	@ 0x5106
    388c:	13136706 	tstne	r3, #1572864	@ 0x180000
    3890:	01060a05 	tsteq	r6, r5, lsl #20
    3894:	05200305 	streq	r0, [r0, #-773]!	@ 0xfffffcfb
    3898:	04020005 	streq	r0, [r2], #-5
    389c:	00220603 	eoreq	r0, r2, r3, lsl #12
    38a0:	59030402 	stmdbpl	r3, {r1, sl}
    38a4:	03040200 	movweq	r0, #16896	@ 0x4200
    38a8:	0017054b 	andseq	r0, r7, fp, asr #10
    38ac:	06030402 	streq	r0, [r3], -r2, lsl #8
    38b0:	00050501 	andeq	r0, r5, r1, lsl #10
    38b4:	2e030402 	cdpcs	4, 0, cr0, cr3, cr2, {0}
    38b8:	03040200 	movweq	r0, #16896	@ 0x4200
    38bc:	02004b06 	andeq	r4, r0, #6144	@ 0x1800
    38c0:	05590304 	ldrbeq	r0, [r9, #-772]	@ 0xfffffcfc
    38c4:	04020009 	streq	r0, [r2], #-9
    38c8:	05010603 	streq	r0, [r1, #-1539]	@ 0xfffff9fd
    38cc:	0402001d 	streq	r0, [r2], #-29	@ 0xffffffe3
    38d0:	7a030603 	bvc	c50e4 <__ROM_SIZE__+0x850e4>
    38d4:	00110520 	andseq	r0, r1, r0, lsr #10
    38d8:	20010402 	andcs	r0, r1, r2, lsl #8
    38dc:	03060105 	movweq	r0, #24837	@ 0x6105
    38e0:	063c2e09 	ldrteq	r2, [ip], -r9, lsl #28
    38e4:	88020500 	stmdahi	r2, {r8, sl}
    38e8:	03000020 	movweq	r0, #32
    38ec:	0106010a 	tsteq	r6, sl, lsl #2
    38f0:	59060305 	stmdbpl	r6, {r0, r2, r8, r9}
    38f4:	05131314 	ldreq	r1, [r3, #-788]	@ 0xfffffcec
    38f8:	05010612 	streq	r0, [r1, #-1554]	@ 0xfffff9ee
    38fc:	0305200a 	movweq	r2, #20490	@ 0x500a
    3900:	000b0520 	andeq	r0, fp, r0, lsr #10
    3904:	06010402 	streq	r0, [r1], -r2, lsl #8
    3908:	05200e03 	streq	r0, [r0, #-3587]!	@ 0xfffff1fd
    390c:	04020017 	streq	r0, [r2], #-23	@ 0xffffffe9
    3910:	05010601 	streq	r0, [r1, #-1537]	@ 0xfffff9ff
    3914:	0402000b 	streq	r0, [r2], #-11
    3918:	054b0601 	strbeq	r0, [fp, #-1537]	@ 0xfffff9ff
    391c:	0402002e 	streq	r0, [r2], #-46	@ 0xffffffd2
    3920:	017a0301 	cmneq	sl, r1, lsl #6
    3924:	01040200 	mrseq	r0, R12_usr
    3928:	0a052006 	beq	14b948 <__ROM_SIZE__+0x10b948>
    392c:	05200b03 	streq	r0, [r0, #-2819]!	@ 0xfffff4fd
    3930:	04020005 	streq	r0, [r2], #-5
    3934:	05230602 	streq	r0, [r3, #-1538]!	@ 0xfffff9fe
    3938:	04020012 	streq	r0, [r2], #-18	@ 0xffffffee
    393c:	05010602 	streq	r0, [r1, #-1538]	@ 0xfffff9fe
    3940:	0402001e 	streq	r0, [r2], #-30	@ 0xffffffe2
    3944:	0c052e02 	stceq	14, cr2, [r5], {2}
    3948:	02040200 	andeq	r0, r4, #0, 4
    394c:	00310558 	eorseq	r0, r1, r8, asr r5
    3950:	06020402 	streq	r0, [r2], -r2, lsl #8
    3954:	054a6903 	strbeq	r6, [sl, #-2307]	@ 0xfffff6fd
    3958:	0402002e 	streq	r0, [r2], #-46	@ 0xffffffd2
    395c:	05010602 	streq	r0, [r1, #-1538]	@ 0xfffff9fe
    3960:	04020033 	streq	r0, [r2], #-51	@ 0xffffffcd
    3964:	24052002 	strcs	r2, [r5], #-2
    3968:	01040200 	mrseq	r0, R12_usr
    396c:	05052006 	streq	r2, [r5, #-6]
    3970:	06080530 			@ <UNDEFINED> instruction: 0x06080530
    3974:	06070501 	streq	r0, [r7], -r1, lsl #10
    3978:	054d6731 	strbeq	r6, [sp, #-1841]	@ 0xfffff8cf
    397c:	0501060f 	streq	r0, [r1, #-1551]	@ 0xfffff9f1
    3980:	04020028 	streq	r0, [r2], #-40	@ 0xffffffd8
    3984:	05200601 	streq	r0, [r0, #-1537]!	@ 0xfffff9ff
    3988:	14053109 	strne	r3, [r5], #-265	@ 0xfffffef7
    398c:	0c050106 	stfeqs	f0, [r5], {6}
    3990:	0609053c 			@ <UNDEFINED> instruction: 0x0609053c
    3994:	06150533 			@ <UNDEFINED> instruction: 0x06150533
    3998:	09052001 	stmdbeq	r5, {r0, sp}
    399c:	0a053d06 	beq	152dbc <__ROM_SIZE__+0x112dbc>
    39a0:	09051406 	stmdbeq	r5, {r1, r2, sl, ip}
    39a4:	2701051e 	smladcs	r1, lr, r5, r0
    39a8:	0101002e 	tsteq	r1, lr, lsr #32
    39ac:	0000069e 	muleq	r0, lr, r6
    39b0:	00950003 	addseq	r0, r5, r3
    39b4:	01020000 	mrseq	r0, (UNDEF: 2)
    39b8:	000d0efb 	strdeq	r0, [sp], -fp
    39bc:	01010101 	tsteq	r1, r1, lsl #2
    39c0:	01000000 	mrseq	r0, (UNDEF: 0)
    39c4:	2f010000 	svccs	0x00010000
    39c8:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
    39cc:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
    39d0:	63652f66 	cmnvs	r5, #408	@ 0x198
    39d4:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
    39d8:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
    39dc:	732f7265 			@ <UNDEFINED> instruction: 0x732f7265
    39e0:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
    39e4:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
    39e8:	6e69742f 	cdpvs	4, 6, cr7, cr9, cr15, {1}
    39ec:	63652d79 	cmnvs	r5, #7744	@ 0x1e40
    39f0:	2f006864 	svccs	0x00006864
    39f4:	2f74706f 	svccs	0x0074706f
    39f8:	2d636367 	stclcs	3, cr6, [r3, #-412]!	@ 0xfffffe64
    39fc:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	@ 0xfffffe7c
    3a00:	656e6f6e 	strbvs	r6, [lr, #-3950]!	@ 0xfffff092
    3a04:	6261652d 	rsbvs	r6, r1, #188743680	@ 0xb400000
    3a08:	696c2f69 	stmdbvs	ip!, {r0, r3, r5, r6, r8, r9, sl, fp, sp}^
    3a0c:	63672f62 	cmnvs	r7, #392	@ 0x188
    3a10:	72612f63 	rsbvc	r2, r1, #396	@ 0x18c
    3a14:	6f6e2d6d 	svcvs	0x006e2d6d
    3a18:	652d656e 	strvs	r6, [sp, #-1390]!	@ 0xfffffa92
    3a1c:	2f696261 	svccs	0x00696261
    3a20:	322e3231 	eorcc	r3, lr, #268435459	@ 0x10000003
    3a24:	692f312e 	stmdbvs	pc!, {r1, r2, r3, r5, r8, ip, sp}	@ <UNPREDICTABLE>
    3a28:	756c636e 	strbvc	r6, [ip, #-878]!	@ 0xfffffc92
    3a2c:	00006564 	andeq	r6, r0, r4, ror #10
    3a30:	68646365 	stmdavs	r4!, {r0, r2, r5, r6, r8, r9, sp, lr}^
    3a34:	0100632e 	tsteq	r0, lr, lsr #6
    3a38:	74730000 	ldrbtvc	r0, [r3], #-0
    3a3c:	746e6964 	strbtvc	r6, [lr], #-2404	@ 0xfffff69c
    3a40:	6363672d 	cmnvs	r3, #11796480	@ 0xb40000
    3a44:	0200682e 	andeq	r6, r0, #3014656	@ 0x2e0000
    3a48:	05000000 	streq	r0, [r0, #-0]
    3a4c:	02050001 	andeq	r0, r5, #1
    3a50:	000020fc 	strdeq	r2, [r0], -ip
    3a54:	0101c603 	tsteq	r1, r3, lsl #12
    3a58:	05130305 	ldreq	r0, [r3, #-773]	@ 0xfffffcfb
    3a5c:	05010612 	streq	r0, [r1, #-1554]	@ 0xfffff9ee
    3a60:	2105200d 	tstcs	r5, sp
    3a64:	2e19052e 	cfmul64cs	mvdx0, mvdx9, mvdx14
    3a68:	06210105 	strteq	r0, [r1], -r5, lsl #2
    3a6c:	1303053f 	movwne	r0, #13631	@ 0x353f
    3a70:	01060905 	tsteq	r6, r5, lsl #18
    3a74:	052e0405 	streq	r0, [lr, #-1029]!	@ 0xfffffbfb
    3a78:	18052e20 	stmdane	r5, {r5, r9, sl, fp, sp}
    3a7c:	2e10052e 	cfmul64cs	mvdx0, mvdx0, mvdx14
    3a80:	064b0105 	strbeq	r0, [fp], -r5, lsl #2
    3a84:	13030523 	movwne	r0, #13603	@ 0x3523
    3a88:	060a0513 			@ <UNDEFINED> instruction: 0x060a0513
    3a8c:	20030501 	andcs	r0, r3, r1, lsl #10
    3a90:	02000505 	andeq	r0, r0, #20971520	@ 0x1400000
    3a94:	22060304 	andcs	r0, r6, #4, 6	@ 0x10000000
    3a98:	02000d05 	andeq	r0, r0, #320	@ 0x140
    3a9c:	01060304 	tsteq	r6, r4, lsl #6
    3aa0:	02000a05 	andeq	r0, r0, #20480	@ 0x5000
    3aa4:	052e0304 	streq	r0, [lr, #-772]!	@ 0xfffffcfc
    3aa8:	04020022 	streq	r0, [r2], #-34	@ 0xffffffde
    3aac:	052c0603 	streq	r0, [ip, #-1539]!	@ 0xfffff9fd
    3ab0:	04020011 	streq	r0, [r2], #-17	@ 0xffffffef
    3ab4:	01052001 	tsteq	r5, r1
    3ab8:	23063206 	movwcs	r3, #25094	@ 0x6206
    3abc:	03050106 	movweq	r0, #20742	@ 0x5106
    3ac0:	06134b06 	ldreq	r4, [r3], -r6, lsl #22
    3ac4:	2f062020 	svccs	0x00062020
    3ac8:	0601054b 	streq	r0, [r1], -fp, asr #10
    3acc:	00062e4b 	andeq	r2, r6, fp, asr #28
    3ad0:	21600205 	cmncs	r0, r5, lsl #4
    3ad4:	05170000 	ldreq	r0, [r7, #-0]
    3ad8:	05131303 	ldreq	r1, [r3, #-771]	@ 0xfffffcfd
    3adc:	0501060a 	streq	r0, [r1, #-1546]	@ 0xfffff9f6
    3ae0:	04020011 	streq	r0, [r2], #-17	@ 0xffffffef
    3ae4:	05200601 	streq	r0, [r0, #-1537]!	@ 0xfffff9ff
    3ae8:	12053005 	andne	r3, r5, #5
    3aec:	08050106 	stmdaeq	r5, {r1, r2, r8}
    3af0:	0022052e 	eoreq	r0, r2, lr, lsr #10
    3af4:	06020402 	streq	r0, [r2], -r2, lsl #8
    3af8:	04020048 	streq	r0, [r2], #-72	@ 0xffffffb8
    3afc:	05200602 	streq	r0, [r0, #-1538]!	@ 0xfffff9fe
    3b00:	0520270a 	streq	r2, [r0, #-1802]!	@ 0xfffff8f6
    3b04:	01051d0e 	tsteq	r5, lr, lsl #26
    3b08:	10030624 	andne	r0, r3, r4, lsr #12
    3b0c:	13030520 	movwne	r0, #13600	@ 0x3520
    3b10:	060a0513 			@ <UNDEFINED> instruction: 0x060a0513
    3b14:	20030501 	andcs	r0, r3, r1, lsl #10
    3b18:	02000505 	andeq	r0, r0, #20971520	@ 0x1400000
    3b1c:	22060304 	andcs	r0, r6, #4, 6	@ 0x10000000
    3b20:	02000a05 	andeq	r0, r0, #20480	@ 0x5000
    3b24:	01060304 	tsteq	r6, r4, lsl #6
    3b28:	02002205 	andeq	r2, r0, #1342177280	@ 0x50000000
    3b2c:	3a060304 	bcc	184744 <__ROM_SIZE__+0x144744>
    3b30:	02001105 	andeq	r1, r0, #1073741825	@ 0x40000001
    3b34:	05200104 	streq	r0, [r0, #-260]!	@ 0xfffffefc
    3b38:	06320601 	ldrteq	r0, [r2], -r1, lsl #12
    3b3c:	13030525 	movwne	r0, #13605	@ 0x3525
    3b40:	060c0513 			@ <UNDEFINED> instruction: 0x060c0513
    3b44:	05210611 	streq	r0, [r1, #-1553]!	@ 0xfffff9ef
    3b48:	0a053005 	beq	14fb64 <__ROM_SIZE__+0x10fb64>
    3b4c:	08050106 	stmdaeq	r5, {r1, r2, r8}
    3b50:	0605052e 	streq	r0, [r5], -lr, lsr #10
    3b54:	06070524 	streq	r0, [r7], -r4, lsr #10
    3b58:	03052001 	movweq	r2, #20481	@ 0x5001
    3b5c:	01052206 	tsteq	r5, r6, lsl #4
    3b60:	063c1306 	ldrteq	r1, [ip], -r6, lsl #6
    3b64:	aa020500 	bge	84f6c <__ROM_SIZE__+0x44f6c>
    3b68:	03000021 	movweq	r0, #33	@ 0x21
    3b6c:	03050111 	movweq	r0, #20753	@ 0x5111
    3b70:	05051513 	streq	r1, [r5, #-1299]	@ 0xfffffaed
    3b74:	03050106 	movweq	r0, #20742	@ 0x5106
    3b78:	07053106 	streq	r3, [r5, -r6, lsl #2]
    3b7c:	017a0306 	cmneq	sl, r6, lsl #6
    3b80:	27060b05 	strcs	r0, [r6, -r5, lsl #22]
    3b84:	02000f05 	andeq	r0, r0, #5, 30
    3b88:	2e060104 	adfcss	f0, f6, f4
    3b8c:	02000b05 	andeq	r0, r0, #5120	@ 0x1400
    3b90:	052e0104 	streq	r0, [lr, #-260]!	@ 0xfffffefc
    3b94:	05220605 	streq	r0, [r2, #-1541]!	@ 0xfffff9fb
    3b98:	20010607 	andcs	r0, r1, r7, lsl #12
    3b9c:	23060305 	movwcs	r0, #25349	@ 0x6305
    3ba0:	01060605 	tsteq	r6, r5, lsl #12
    3ba4:	06070520 	streq	r0, [r7], -r0, lsr #10
    3ba8:	060f0525 	streq	r0, [pc], -r5, lsr #10
    3bac:	06070501 	streq	r0, [r7], -r1, lsl #10
    3bb0:	06090521 	streq	r0, [r9], -r1, lsr #10
    3bb4:	061d0501 	ldreq	r0, [sp], -r1, lsl #10
    3bb8:	060e051d 			@ <UNDEFINED> instruction: 0x060e051d
    3bbc:	201d0501 	andscs	r0, sp, r1, lsl #10
    3bc0:	1901052e 	stmdbne	r1, {r1, r2, r3, r5, r8, sl}
    3bc4:	78030e05 	stmdavc	r3, {r0, r2, r9, sl, fp}
    3bc8:	06010520 	streq	r0, [r1], -r0, lsr #10
    3bcc:	063c0c03 	ldrteq	r0, [ip], -r3, lsl #24
    3bd0:	06030501 	streq	r0, [r3], -r1, lsl #10
    3bd4:	06070521 	streq	r0, [r7], -r1, lsr #10
    3bd8:	03053c01 	movweq	r3, #23553	@ 0x5c01
    3bdc:	05133106 	ldreq	r3, [r3, #-262]	@ 0xfffffefa
    3be0:	0501060a 	streq	r0, [r1, #-1546]	@ 0xfffff9f6
    3be4:	07052003 	streq	r2, [r5, -r3]
    3be8:	0005051c 	andeq	r0, r5, ip, lsl r5
    3bec:	06030402 	streq	r0, [r3], -r2, lsl #8
    3bf0:	000a0543 	andeq	r0, sl, r3, asr #10
    3bf4:	06030402 	streq	r0, [r3], -r2, lsl #8
    3bf8:	001b0501 	andseq	r0, fp, r1, lsl #10
    3bfc:	06030402 	streq	r0, [r3], -r2, lsl #8
    3c00:	00110539 	andseq	r0, r1, r9, lsr r5
    3c04:	20010402 	andcs	r0, r1, r2, lsl #8
    3c08:	33060505 	movwcc	r0, #25861	@ 0x6505
    3c0c:	0524062e 	streq	r0, [r4, #-1582]!	@ 0xfffff9d2
    3c10:	0501060a 	streq	r0, [r1, #-1546]	@ 0xfffff9f6
    3c14:	054b0605 	strbeq	r0, [fp, #-1541]	@ 0xfffff9fb
    3c18:	05010607 	streq	r0, [r1, #-1543]	@ 0xfffff9f9
    3c1c:	05210605 	streq	r0, [r1, #-1541]!	@ 0xfffff9fb
    3c20:	05010607 	streq	r0, [r1, #-1543]	@ 0xfffff9f9
    3c24:	052a060c 	streq	r0, [sl, #-1548]!	@ 0xfffff9f4
    3c28:	05133603 	ldreq	r3, [r3, #-1539]	@ 0xfffff9fd
    3c2c:	2e010606 	cfmadd32cs	mvax0, mvfx0, mvfx1, mvfx6
    3c30:	0a030105 	beq	c404c <__ROM_SIZE__+0x8404c>
    3c34:	00070520 	andeq	r0, r7, r0, lsr #10
    3c38:	06030402 	streq	r0, [r3], -r2, lsl #8
    3c3c:	0011052a 	andseq	r0, r1, sl, lsr #10
    3c40:	06030402 	streq	r0, [r3], -r2, lsl #8
    3c44:	00150501 	andseq	r0, r5, r1, lsl #10
    3c48:	2e030402 	cdpcs	4, 0, cr0, cr3, cr2, {0}
    3c4c:	02002305 	andeq	r2, r0, #335544320	@ 0x14000000
    3c50:	05200304 	streq	r0, [r0, #-772]!	@ 0xfffffcfc
    3c54:	04020032 	streq	r0, [r2], #-50	@ 0xffffffce
    3c58:	2b055803 	blcs	159c6c <__ROM_SIZE__+0x119c6c>
    3c5c:	03040200 	movweq	r0, #16896	@ 0x4200
    3c60:	001f052e 	andseq	r0, pc, lr, lsr #10
    3c64:	2e030402 	cdpcs	4, 0, cr0, cr3, cr2, {0}
    3c68:	02000d05 	andeq	r0, r0, #320	@ 0x140
    3c6c:	05200304 	streq	r0, [r0, #-772]!	@ 0xfffffcfc
    3c70:	0402002a 	streq	r0, [r2], #-42	@ 0xffffffd6
    3c74:	052c0603 	streq	r0, [ip, #-1539]!	@ 0xfffff9fd
    3c78:	04020025 	streq	r0, [r2], #-37	@ 0xffffffdb
    3c7c:	05052001 	streq	r2, [r5, #-1]
    3c80:	06060532 			@ <UNDEFINED> instruction: 0x06060532
    3c84:	200a0501 	andcs	r0, sl, r1, lsl #10
    3c88:	05300105 	ldreq	r0, [r0, #-261]!	@ 0xfffffefb
    3c8c:	207a030c 	rsbscs	r0, sl, ip, lsl #6
    3c90:	06010520 	streq	r0, [r1], -r0, lsr #10
    3c94:	48020500 	stmdami	r2, {r8, sl}
    3c98:	03000022 	movweq	r0, #34	@ 0x22
    3c9c:	03050111 	movweq	r0, #20753	@ 0x5111
    3ca0:	06080514 			@ <UNDEFINED> instruction: 0x06080514
    3ca4:	06030501 	streq	r0, [r3], -r1, lsl #10
    3ca8:	01061330 	tsteq	r6, r0, lsr r3
    3cac:	02000505 	andeq	r0, r0, #20971520	@ 0x1400000
    3cb0:	22060304 	andcs	r0, r6, #4, 6	@ 0x10000000
    3cb4:	02000a05 	andeq	r0, r0, #20480	@ 0x5000
    3cb8:	01060304 	tsteq	r6, r4, lsl #6
    3cbc:	02002205 	andeq	r2, r0, #1342177280	@ 0x50000000
    3cc0:	3a060304 	bcc	1848d8 <__ROM_SIZE__+0x1448d8>
    3cc4:	02001105 	andeq	r1, r0, #1073741825	@ 0x40000001
    3cc8:	05200104 	streq	r0, [r0, #-260]!	@ 0xfffffefc
    3ccc:	06320601 	ldrteq	r0, [r2], -r1, lsl #12
    3cd0:	14030525 	strne	r0, [r3], #-1317	@ 0xfffffadb
    3cd4:	01060805 	tsteq	r6, r5, lsl #16
    3cd8:	05200605 	streq	r0, [r0, #-1541]!	@ 0xfffff9fb
    3cdc:	04020011 	streq	r0, [r2], #-17	@ 0xffffffef
    3ce0:	05340601 	ldreq	r0, [r4, #-1537]!	@ 0xfffff9ff
    3ce4:	0a053005 	beq	14fd00 <__ROM_SIZE__+0x10fd00>
    3ce8:	08050106 	stmdaeq	r5, {r1, r2, r8}
    3cec:	0022052e 	eoreq	r0, r2, lr, lsr #10
    3cf0:	06020402 	streq	r0, [r2], -r2, lsl #8
    3cf4:	0402001e 	streq	r0, [r2], #-30	@ 0xffffffe2
    3cf8:	05200602 	streq	r0, [r0, #-1538]!	@ 0xfffff9fe
    3cfc:	05270603 	streq	r0, [r7, #-1539]!	@ 0xfffff9fd
    3d00:	3c01060d 	stccc	6, cr0, [r1], {13}
    3d04:	75030c05 	strvc	r0, [r3, #-3077]	@ 0xfffff3fb
    3d08:	0301052e 	movweq	r0, #5422	@ 0x152e
    3d0c:	0306200c 	movweq	r2, #24588	@ 0x600c
    3d10:	03052018 	movweq	r2, #20504	@ 0x5018
    3d14:	0a051313 	beq	148968 <__ROM_SIZE__+0x108968>
    3d18:	11050106 	tstne	r5, r6, lsl #2
    3d1c:	01052006 	tsteq	r5, r6
    3d20:	05052c06 	streq	r2, [r5, #-3078]	@ 0xfffff3fa
    3d24:	03040200 	movweq	r0, #16896	@ 0x4200
    3d28:	15052406 	strne	r2, [r5, #-1030]	@ 0xfffffbfa
    3d2c:	03040200 	movweq	r0, #16896	@ 0x4200
    3d30:	12050106 	andne	r0, r5, #-2147483647	@ 0x80000001
    3d34:	03040200 	movweq	r0, #16896	@ 0x4200
    3d38:	000a052e 	andeq	r0, sl, lr, lsr #10
    3d3c:	3c030402 	cfstrscc	mvf0, [r3], {2}
    3d40:	02002205 	andeq	r2, r0, #1342177280	@ 0x50000000
    3d44:	2c060304 	stccs	3, cr0, [r6], {4}
    3d48:	02001105 	andeq	r1, r0, #1073741825	@ 0x40000001
    3d4c:	05200304 	streq	r0, [r0, #-772]!	@ 0xfffffcfc
    3d50:	2e320601 	cfmsuba32cs	mvax0, mvax0, mvfx2, mvfx1
    3d54:	03052406 	movweq	r2, #21510	@ 0x5406
    3d58:	06040513 			@ <UNDEFINED> instruction: 0x06040513
    3d5c:	20080501 	andcs	r0, r8, r1, lsl #10
    3d60:	063d0105 	ldrteq	r0, [sp], -r5, lsl #2
    3d64:	05010625 	streq	r0, [r1, #-1573]	@ 0xfffff9db
    3d68:	13590603 	cmpne	r9, #3145728	@ 0x300000
    3d6c:	06200618 			@ <UNDEFINED> instruction: 0x06200618
    3d70:	06070531 			@ <UNDEFINED> instruction: 0x06070531
    3d74:	4a060501 	bmi	185180 <__ROM_SIZE__+0x145180>
    3d78:	22060505 	andcs	r0, r6, #20971520	@ 0x1400000
    3d7c:	02000105 	andeq	r0, r0, #1073741825	@ 0x40000001
    3d80:	03060104 	movweq	r0, #24836	@ 0x6104
    3d84:	02004a73 	andeq	r4, r0, #471040	@ 0x73000
    3d88:	05200104 	streq	r0, [r0, #-260]!	@ 0xfffffefc
    3d8c:	11030605 	tstne	r3, r5, lsl #12
    3d90:	03070520 	movweq	r0, #29984	@ 0x7520
    3d94:	21054a0c 	tstcs	r5, ip, lsl #20
    3d98:	02040200 	andeq	r0, r4, #0, 4
    3d9c:	05667803 	strbeq	r7, [r6, #-2051]!	@ 0xfffff7fd
    3da0:	04020011 	streq	r0, [r2], #-17	@ 0xffffffef
    3da4:	05052001 	streq	r2, [r5, #-1]
    3da8:	09055b31 	stmdbeq	r5, {r0, r4, r5, r8, r9, fp, ip, lr}
    3dac:	08050106 	stmdaeq	r5, {r1, r2, r8}
    3db0:	0605054a 	streq	r0, [r5], -sl, asr #10
    3db4:	052e0c03 	streq	r0, [lr, #-3075]!	@ 0xfffff3fd
    3db8:	05010609 	streq	r0, [r1, #-1545]	@ 0xfffff9f7
    3dbc:	07054a08 	streq	r4, [r5, -r8, lsl #20]
    3dc0:	01053006 	tsteq	r5, r6
    3dc4:	66090306 	strvs	r0, [r9], -r6, lsl #6
    3dc8:	0500062e 	streq	r0, [r0, #-1582]	@ 0xfffff9d2
    3dcc:	00232002 	eoreq	r2, r3, r2
    3dd0:	01061600 	tsteq	r6, r0, lsl #12
    3dd4:	3d060305 	stccc	3, cr0, [r6, #-20]	@ 0xffffffec
    3dd8:	20061413 	andcs	r1, r6, r3, lsl r4
    3ddc:	3d4b2f06 	stclcc	15, cr2, [fp, #-24]	@ 0xffffffe8
    3de0:	0609053e 			@ <UNDEFINED> instruction: 0x0609053e
    3de4:	06050501 	streq	r0, [r5], -r1, lsl #10
    3de8:	59201103 	stmdbpl	r0!, {r0, r1, r8, ip}
    3dec:	0a055959 	beq	15a358 <__ROM_SIZE__+0x11a358>
    3df0:	05586c03 	ldrbeq	r6, [r8, #-3075]	@ 0xfffff3fd
    3df4:	0501060b 	streq	r0, [r1, #-1547]	@ 0xfffff9f5
    3df8:	05053c0a 	streq	r3, [r5, #-3082]	@ 0xfffff3f6
    3dfc:	0a052206 	beq	14c61c <__ROM_SIZE__+0x10c61c>
    3e00:	1d050106 	stfnes	f0, [r5, #-24]	@ 0xffffffe8
    3e04:	0605054a 	streq	r0, [r5], -sl, asr #10
    3e08:	0608054c 	streq	r0, [r8], -ip, asr #10
    3e0c:	07052001 	streq	r2, [r5, -r1]
    3e10:	4b4b2206 	blmi	12cc630 <__ROM_SIZE__+0x128c630>
    3e14:	01060905 	tsteq	r6, r5, lsl #18
    3e18:	03010520 	movweq	r0, #5408	@ 0x1520
    3e1c:	062e200e 	strteq	r2, [lr], -lr
    3e20:	a4020500 	strge	r0, [r2], #-1280	@ 0xfffffb00
    3e24:	03000023 	movweq	r0, #35	@ 0x23
    3e28:	0106010f 	tsteq	r6, pc, lsl #2
    3e2c:	3d060305 	stccc	3, cr0, [r6, #-20]	@ 0xffffffec
    3e30:	2f062006 	svccs	0x00062006
    3e34:	4b060105 	blmi	184250 <__ROM_SIZE__+0x144250>
    3e38:	05000620 	streq	r0, [r0, #-1568]	@ 0xfffff9e0
    3e3c:	0023ba02 	eoreq	fp, r3, r2, lsl #20
    3e40:	01061500 	tsteq	r6, r0, lsl #10
    3e44:	2f060305 	svccs	0x00060305
    3e48:	0601052f 	streq	r0, [r1], -pc, lsr #10
    3e4c:	0006203d 	andeq	r2, r6, sp, lsr r0
    3e50:	23ca0205 	biccs	r0, sl, #1342177280	@ 0x50000000
    3e54:	06150000 	ldreq	r0, [r5], -r0
    3e58:	06030501 	streq	r0, [r3], -r1, lsl #10
    3e5c:	060f052f 	streq	r0, [pc], -pc, lsr #10
    3e60:	2f0c0501 	svccs	0x000c0501
    3e64:	02000f05 	andeq	r0, r0, #5, 30
    3e68:	05200104 	streq	r0, [r0, #-260]!	@ 0xfffffefc
    3e6c:	0402000c 	streq	r0, [r2], #-12
    3e70:	05203c01 	streq	r3, [r0, #-3073]!	@ 0xfffff3ff
    3e74:	06202101 	strteq	r2, [r0], -r1, lsl #2
    3e78:	e0020500 	and	r0, r2, r0, lsl #10
    3e7c:	16000023 	strne	r0, [r0], -r3, lsr #32
    3e80:	03050106 	movweq	r0, #20742	@ 0x5106
    3e84:	07054c06 	streq	r4, [r5, -r6, lsl #24]
    3e88:	06050106 	streq	r0, [r5], -r6, lsl #2
    3e8c:	0605052e 	streq	r0, [r5], -lr, lsr #10
    3e90:	06010522 	streq	r0, [r1], -r2, lsr #10
    3e94:	053c1203 	ldreq	r1, [ip, #-515]!	@ 0xfffffdfd
    3e98:	72030605 	andvc	r0, r3, #5242880	@ 0x500000
    3e9c:	594b142e 	stmdbpl	fp, {r1, r2, r3, r5, sl, ip}^
    3ea0:	3e5a5959 			@ <UNDEFINED> instruction: 0x3e5a5959
    3ea4:	01055959 	tsteq	r5, r9, asr r9
    3ea8:	00065a06 	andeq	r5, r6, r6, lsl #20
    3eac:	244e0205 	strbcs	r0, [lr], #-517	@ 0xfffffdfb
    3eb0:	06170000 	ldreq	r0, [r7], -r0
    3eb4:	06030501 	streq	r0, [r3], -r1, lsl #10
    3eb8:	06080567 	streq	r0, [r8], -r7, ror #10
    3ebc:	05202001 	streq	r2, [r0, #-1]!
    3ec0:	05052e06 	streq	r2, [r5, #-3590]	@ 0xfffff1fa
    3ec4:	09052206 	stmdbeq	r5, {r1, r2, r9, sp}
    3ec8:	08050106 	stmdaeq	r5, {r1, r2, r8}
    3ecc:	0607054a 	streq	r0, [r7], -sl, asr #10
    3ed0:	060b0526 	streq	r0, [fp], -r6, lsr #10
    3ed4:	4a0a0501 	bmi	2852e0 <__ROM_SIZE__+0x2452e0>
    3ed8:	22060905 	andcs	r0, r6, #81920	@ 0x14000
    3edc:	01060d05 	tsteq	r6, r5, lsl #26
    3ee0:	054a0c05 	strbeq	r0, [sl, #-3077]	@ 0xfffff3fb
    3ee4:	0522060b 	streq	r0, [r2, #-1547]!	@ 0xfffff9f5
    3ee8:	58780307 	ldmdapl	r8!, {r0, r1, r2, r8, r9}^
    3eec:	03060105 	movweq	r0, #24837	@ 0x6105
    3ef0:	0b056626 	bleq	15d790 <__ROM_SIZE__+0x11d790>
    3ef4:	2e660306 	cdpcs	3, 6, cr0, cr6, cr6, {0}
    3ef8:	145e0905 	ldrbne	r0, [lr], #-2309	@ 0xfffff6fb
    3efc:	594b5959 	stmdbpl	fp, {r0, r3, r4, r6, r8, fp, ip, lr}^
    3f00:	3e5a5959 			@ <UNDEFINED> instruction: 0x3e5a5959
    3f04:	59595959 	ldmdbpl	r9, {r0, r3, r4, r6, r8, fp, ip, lr}^
    3f08:	4e060105 	adfmis	f0, f6, f5
    3f0c:	02050006 	andeq	r0, r5, #6
    3f10:	00002522 	andeq	r2, r0, r2, lsr #10
    3f14:	05010619 	streq	r0, [r1, #-1561]	@ 0xfffff9e7
    3f18:	13590603 	cmpne	r9, #3145728	@ 0x300000
    3f1c:	060f0513 			@ <UNDEFINED> instruction: 0x060f0513
    3f20:	052e2001 	streq	r2, [lr, #-1]!
    3f24:	06220603 	strteq	r0, [r2], -r3, lsl #12
    3f28:	0530062e 	ldreq	r0, [r0, #-1582]!	@ 0xfffff9d2
    3f2c:	0501060a 	streq	r0, [r1, #-1546]	@ 0xfffff9f6
    3f30:	21052003 	tstcs	r5, r3
    3f34:	02040200 	andeq	r0, r4, #0, 4
    3f38:	1b052006 	blne	14bf58 <__ROM_SIZE__+0x10bf58>
    3f3c:	01040200 	mrseq	r0, R12_usr
    3f40:	30050520 	andcc	r0, r5, r0, lsr #10
    3f44:	0609054b 	streq	r0, [r9], -fp, asr #10
    3f48:	4a080501 	bmi	205354 <__ROM_SIZE__+0x1c5354>
    3f4c:	30060705 	andcc	r0, r6, r5, lsl #14
    3f50:	05770305 	ldrbeq	r0, [r7, #-773]!	@ 0xfffffcfb
    3f54:	2e670601 	cdpcs	6, 6, cr0, cr7, cr1, {0}
    3f58:	02050006 	andeq	r0, r5, #6
    3f5c:	00002578 	andeq	r2, r0, r8, ror r5
    3f60:	06012403 	streq	r2, [r1], -r3, lsl #8
    3f64:	06030501 	streq	r0, [r3], -r1, lsl #10
    3f68:	0705144b 	streq	r1, [r5, -fp, asr #8]
    3f6c:	06050106 	streq	r0, [r5], -r6, lsl #2
    3f70:	220c052e 	andcs	r0, ip, #192937984	@ 0xb800000
    3f74:	12030105 	andne	r0, r3, #1073741825	@ 0x40000001
    3f78:	06050520 	streq	r0, [r5], -r0, lsr #10
    3f7c:	5c2e7203 	sfmpl	f7, 4, [lr], #-12
    3f80:	59595a59 	ldmdbpl	r9, {r0, r3, r4, r6, r9, fp, ip, lr}^
    3f84:	0c055a59 			@ <UNDEFINED> instruction: 0x0c055a59
    3f88:	01050106 	tsteq	r5, r6, lsl #2
    3f8c:	740f0306 	strvc	r0, [pc], #-774	@ 3f94 <base_order+0x97c>
    3f90:	03050106 	movweq	r0, #20742	@ 0x5106
    3f94:	3f053e06 	svccc	0x00053e06
    3f98:	03050106 	movweq	r0, #20742	@ 0x5106
    3f9c:	3106582e 	tstcc	r6, lr, lsr #16
    3fa0:	01060705 	tsteq	r6, r5, lsl #14
    3fa4:	053c0605 	ldreq	r0, [ip, #-1541]!	@ 0xfffff9fb
    3fa8:	05350605 	ldreq	r0, [r5, #-1541]!	@ 0xfffff9fb
    3fac:	05010611 	streq	r0, [r1, #-1553]	@ 0xfffff9ef
    3fb0:	143d0605 	ldrtne	r0, [sp], #-1541	@ 0xfffff9fb
    3fb4:	01060c05 	tsteq	r6, r5, lsl #24
    3fb8:	05200505 	streq	r0, [r0, #-1285]!	@ 0xfffffafb
    3fbc:	04020007 	streq	r0, [r2], #-7
    3fc0:	05220603 	streq	r0, [r2, #-1539]!	@ 0xfffff9fd
    3fc4:	04020035 	streq	r0, [r2], #-53	@ 0xffffffcb
    3fc8:	1d054803 	stcne	8, cr4, [r5, #-12]
    3fcc:	01040200 	mrseq	r0, R12_usr
    3fd0:	34050520 	strcc	r0, [r5], #-1312	@ 0xfffffae0
    3fd4:	060c055a 			@ <UNDEFINED> instruction: 0x060c055a
    3fd8:	01052001 	tsteq	r5, r1
    3fdc:	030c0514 	movweq	r0, #50452	@ 0xc514
    3fe0:	0105206e 	tsteq	r5, lr, rrx
    3fe4:	02050006 	andeq	r0, r5, #6
    3fe8:	00002634 	andeq	r2, r0, r4, lsr r6
    3fec:	06011703 	streq	r1, [r1], -r3, lsl #14
    3ff0:	06030501 	streq	r0, [r3], -r1, lsl #10
    3ff4:	064c054c 	strbeq	r0, [ip], -ip, asr #10
    3ff8:	2e0c0501 	cfsh32cs	mvfx0, mvfx12, #1
    3ffc:	06052020 	streq	r2, [r5], -r0, lsr #32
    4000:	0605052e 	streq	r0, [r5], -lr, lsr #10
    4004:	05201b03 	streq	r1, [r0, #-2819]!	@ 0xfffff4fd
    4008:	0501060c 	streq	r0, [r1, #-1548]	@ 0xfffff9f4
    400c:	0c052201 	sfmeq	f2, 4, [r5], {1}
    4010:	05206403 	streq	r6, [r0, #-1027]!	@ 0xfffffbfd
    4014:	0c054a08 			@ <UNDEFINED> instruction: 0x0c054a08
    4018:	00070532 	andeq	r0, r7, r2, lsr r5
    401c:	06030402 	streq	r0, [r3], -r2, lsl #8
    4020:	001d0530 	andseq	r0, sp, r0, lsr r5
    4024:	06030402 	streq	r0, [r3], -r2, lsl #8
    4028:	00110501 	andseq	r0, r1, r1, lsl #10
    402c:	2e030402 	cdpcs	4, 0, cr0, cr3, cr2, {0}
    4030:	02002a05 	andeq	r2, r0, #20480	@ 0x5000
    4034:	2c060304 	stccs	3, cr0, [r6], {4}
    4038:	02001305 	andeq	r1, r0, #335544320	@ 0x14000000
    403c:	05200104 	streq	r0, [r0, #-260]!	@ 0xfffffefc
    4040:	0c033405 	cfstrseq	mvf3, [r3], {5}
    4044:	060c0566 	streq	r0, [ip], -r6, ror #10
    4048:	00020201 	andeq	r0, r2, r1, lsl #4
    404c:	01850101 	orreq	r0, r5, r1, lsl #2
    4050:	00030000 	andeq	r0, r3, r0
    4054:	0000008e 	andeq	r0, r0, lr, lsl #1
    4058:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
    405c:	0101000d 	tsteq	r1, sp
    4060:	00000101 	andeq	r0, r0, r1, lsl #2
    4064:	00000100 	andeq	r0, r0, r0, lsl #2
    4068:	6f682f01 	svcvs	0x00682f01
    406c:	652f656d 	strvs	r6, [pc, #-1389]!	@ 3b07 <base_order+0x4ef>
    4070:	2f667463 	svccs	0x00667463
    4074:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    4078:	6172742d 	cmnvs	r2, sp, lsr #8
    407c:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
    4080:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
    4084:	6c2f6c6c 	stcvs	12, cr6, [pc], #-432	@ 3edc <base_order+0x8c4>
    4088:	612f6269 			@ <UNDEFINED> instruction: 0x612f6269
    408c:	2f006932 	svccs	0x00006932
    4090:	2f74706f 	svccs	0x0074706f
    4094:	2d636367 	stclcs	3, cr6, [r3, #-412]!	@ 0xfffffe64
    4098:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	@ 0xfffffe7c
    409c:	656e6f6e 	strbvs	r6, [lr, #-3950]!	@ 0xfffff092
    40a0:	6261652d 	rsbvs	r6, r1, #188743680	@ 0xb400000
    40a4:	696c2f69 	stmdbvs	ip!, {r0, r3, r5, r6, r8, r9, sl, fp, sp}^
    40a8:	63672f62 	cmnvs	r7, #392	@ 0x188
    40ac:	72612f63 	rsbvc	r2, r1, #396	@ 0x18c
    40b0:	6f6e2d6d 	svcvs	0x006e2d6d
    40b4:	652d656e 	strvs	r6, [sp, #-1390]!	@ 0xfffffa92
    40b8:	2f696261 	svccs	0x00696261
    40bc:	322e3231 	eorcc	r3, lr, #268435459	@ 0x10000003
    40c0:	692f312e 	stmdbvs	pc!, {r1, r2, r3, r5, r8, ip, sp}	@ <UNPREDICTABLE>
    40c4:	756c636e 	strbvc	r6, [ip, #-878]!	@ 0xfffffc92
    40c8:	00006564 	andeq	r6, r0, r4, ror #10
    40cc:	2e693261 	cdpcs	2, 6, cr3, cr9, cr1, {3}
    40d0:	00010063 	andeq	r0, r1, r3, rrx
    40d4:	64747300 	ldrbtvs	r7, [r4], #-768	@ 0xfffffd00
    40d8:	2d746e69 	ldclcs	14, cr6, [r4, #-420]!	@ 0xfffffe5c
    40dc:	2e636367 	cdpcs	3, 6, cr6, cr3, cr7, {3}
    40e0:	00020068 	andeq	r0, r2, r8, rrx
    40e4:	1b050000 	blne	1440ec <__ROM_SIZE__+0x1040ec>
    40e8:	7c020500 	cfstr32vc	mvfx0, [r2], {-0}
    40ec:	03000026 	movweq	r0, #38	@ 0x26
    40f0:	01060112 	tsteq	r6, r2, lsl r1
    40f4:	21060305 	tstcs	r6, r5, lsl #6
    40f8:	01080513 	tsteq	r8, r3, lsl r5
    40fc:	01060c05 	tsteq	r6, r5, lsl #24
    4100:	051f0705 	ldreq	r0, [pc, #-1797]	@ 3a03 <base_order+0x3eb>
    4104:	05052103 	streq	r2, [r5, #-259]	@ 0xfffffefd
    4108:	03040200 	movweq	r0, #16896	@ 0x4200
    410c:	0f052106 	svceq	0x00052106
    4110:	03040200 	movweq	r0, #16896	@ 0x4200
    4114:	14050106 	strne	r0, [r5], #-262	@ 0xfffffefa
    4118:	03040200 	movweq	r0, #16896	@ 0x4200
    411c:	0009052e 	andeq	r0, r9, lr, lsr #10
    4120:	2e030402 	cdpcs	4, 0, cr0, cr3, cr2, {0}
    4124:	02002305 	andeq	r2, r0, #335544320	@ 0x14000000
    4128:	2d060304 	stccs	3, cr0, [r6, #-16]
    412c:	02001a05 	andeq	r1, r0, #20480	@ 0x5000
    4130:	05200104 	streq	r0, [r0, #-260]!	@ 0xfffffefc
    4134:	04020016 	streq	r0, [r2], #-22	@ 0xffffffea
    4138:	05010601 	streq	r0, [r1, #-1537]	@ 0xfffff9ff
    413c:	0402001a 	streq	r0, [r2], #-26	@ 0xffffffe6
    4140:	03052001 	movweq	r2, #20481	@ 0x5001
    4144:	01053106 	tsteq	r5, r6, lsl #2
    4148:	20051306 	andcs	r1, r5, r6, lsl #6
    414c:	01062206 	tsteq	r6, r6, lsl #4
    4150:	21060305 	tstcs	r6, r5, lsl #6
    4154:	08051413 	stmdaeq	r5, {r0, r1, r4, sl, ip}
    4158:	06110501 	ldreq	r0, [r1], -r1, lsl #10
    415c:	1d0c0501 	cfstr32ne	mvfx0, [ip, #-4]
    4160:	05230305 	streq	r0, [r3, #-773]!	@ 0xfffffcfb
    4164:	0523060c 	streq	r0, [r3, #-1548]!	@ 0xfffff9f4
    4168:	0501061e 	streq	r0, [r1, #-1566]	@ 0xfffff9e2
    416c:	07053c0f 	streq	r3, [r5, -pc, lsl #24]
    4170:	1c052f06 	stcne	15, cr2, [r5], {6}
    4174:	05050106 	streq	r0, [r5, #-262]	@ 0xfffffefa
    4178:	05132806 	ldreq	r2, [r3, #-2054]	@ 0xfffff7fa
    417c:	05010609 	streq	r0, [r1, #-1545]	@ 0xfffff9f7
    4180:	04020029 	streq	r0, [r2], #-41	@ 0xffffffd7
    4184:	73030602 	movwvc	r0, #13826	@ 0x3602
    4188:	001f052e 	andseq	r0, pc, lr, lsr #10
    418c:	20010402 	andcs	r0, r1, r2, lsl #8
    4190:	02001b05 	andeq	r1, r0, #5120	@ 0x1400
    4194:	01060104 	tsteq	r6, r4, lsl #2
    4198:	02001f05 	andeq	r1, r0, #5, 30
    419c:	052e0104 	streq	r0, [lr, #-260]!	@ 0xfffffefc
    41a0:	05210605 	streq	r0, [r1, #-1541]!	@ 0xfffff9fb
    41a4:	05010617 	streq	r0, [r1, #-1559]	@ 0xfffff9e9
    41a8:	07053c08 	streq	r3, [r5, -r8, lsl #24]
    41ac:	16052f06 	strne	r2, [r5], -r6, lsl #30
    41b0:	05200106 	streq	r0, [r0, #-262]!	@ 0xfffffefa
    41b4:	0523060c 	streq	r0, [r3, #-1548]!	@ 0xfffff9f4
    41b8:	0501061e 	streq	r0, [r1, #-1566]	@ 0xfffff9e2
    41bc:	07053c0f 	streq	r3, [r5, -pc, lsl #24]
    41c0:	1c052f06 	stcne	15, cr2, [r5], {6}
    41c4:	20200106 	eorcs	r0, r0, r6, lsl #2
    41c8:	03060305 	movweq	r0, #25349	@ 0x6305
    41cc:	0105010a 	tsteq	r5, sl, lsl #2
    41d0:	01021306 	tsteq	r2, r6, lsl #6
    41d4:	0b010100 	bleq	445dc <__ROM_SIZE__+0x45dc>
    41d8:	03000002 	movweq	r0, #2
    41dc:	0000e100 	andeq	lr, r0, r0, lsl #2
    41e0:	fb010200 	blx	449ea <__ROM_SIZE__+0x49ea>
    41e4:	01000d0e 	tsteq	r0, lr, lsl #26
    41e8:	00010101 	andeq	r0, r1, r1, lsl #2
    41ec:	00010000 	andeq	r0, r1, r0
    41f0:	682f0100 	stmdavs	pc!, {r8}	@ <UNPREDICTABLE>
    41f4:	2f656d6f 	svccs	0x00656d6f
    41f8:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    41fc:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
    4200:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
    4204:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
    4208:	68732f72 	ldmdavs	r3!, {r1, r4, r5, r6, r8, r9, sl, fp, sp}^
    420c:	2f6c6c65 	svccs	0x006c6c65
    4210:	2f62696c 	svccs	0x0062696c
    4214:	6c6d656d 	cfstr64vs	mvdx6, [sp], #-436	@ 0xfffffe4c
    4218:	2f00676f 	svccs	0x0000676f
    421c:	2f74706f 	svccs	0x0074706f
    4220:	2d636367 	stclcs	3, cr6, [r3, #-412]!	@ 0xfffffe64
    4224:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	@ 0xfffffe7c
    4228:	656e6f6e 	strbvs	r6, [lr, #-3950]!	@ 0xfffff092
    422c:	6261652d 	rsbvs	r6, r1, #188743680	@ 0xb400000
    4230:	696c2f69 	stmdbvs	ip!, {r0, r3, r5, r6, r8, r9, sl, fp, sp}^
    4234:	63672f62 	cmnvs	r7, #392	@ 0x188
    4238:	72612f63 	rsbvc	r2, r1, #396	@ 0x18c
    423c:	6f6e2d6d 	svcvs	0x006e2d6d
    4240:	652d656e 	strvs	r6, [sp, #-1390]!	@ 0xfffffa92
    4244:	2f696261 	svccs	0x00696261
    4248:	322e3231 	eorcc	r3, lr, #268435459	@ 0x10000003
    424c:	692f312e 	stmdbvs	pc!, {r1, r2, r3, r5, r8, ip, sp}	@ <UNPREDICTABLE>
    4250:	756c636e 	strbvc	r6, [ip, #-878]!	@ 0xfffffc92
    4254:	2f006564 	svccs	0x00006564
    4258:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
    425c:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
    4260:	63652f66 	cmnvs	r5, #408	@ 0x198
    4264:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
    4268:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
    426c:	732f7265 			@ <UNDEFINED> instruction: 0x732f7265
    4270:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
    4274:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
    4278:	7274732f 	rsbsvc	r7, r4, #-1140850688	@ 0xbc000000
    427c:	00676e69 	rsbeq	r6, r7, r9, ror #28
    4280:	6d656d00 	stclvs	13, cr6, [r5, #-0]
    4284:	2e676f6c 	cdpcs	15, 6, cr6, cr7, cr12, {3}
    4288:	00010063 	andeq	r0, r1, r3, rrx
    428c:	64747300 	ldrbtvs	r7, [r4], #-768	@ 0xfffffd00
    4290:	2d746e69 	ldclcs	14, cr6, [r4, #-420]!	@ 0xfffffe5c
    4294:	2e636367 	cdpcs	3, 6, cr6, cr3, cr7, {3}
    4298:	00020068 	andeq	r0, r2, r8, rrx
    429c:	6d656d00 	stclvs	13, cr6, [r5, #-0]
    42a0:	2e676f6c 	cdpcs	15, 6, cr6, cr7, cr12, {3}
    42a4:	00010068 	andeq	r0, r1, r8, rrx
    42a8:	64747300 	ldrbtvs	r7, [r4], #-768	@ 0xfffffd00
    42ac:	2e666564 	cdpcs	5, 6, cr6, cr6, cr4, {3}
    42b0:	00020068 	andeq	r0, r2, r8, rrx
    42b4:	72747300 	rsbsvc	r7, r4, #0, 6
    42b8:	2e676e69 	cdpcs	14, 6, cr6, cr7, cr9, {3}
    42bc:	00030068 	andeq	r0, r3, r8, rrx
    42c0:	3d050000 	stccc	0, cr0, [r5, #-0]
    42c4:	d8020500 	stmdale	r2, {r8, sl}
    42c8:	03000026 	movweq	r0, #38	@ 0x26
    42cc:	03050116 	movweq	r0, #20758	@ 0x5116
    42d0:	06110513 			@ <UNDEFINED> instruction: 0x06110513
    42d4:	06030501 	streq	r0, [r3], -r1, lsl #10
    42d8:	06060530 			@ <UNDEFINED> instruction: 0x06060530
    42dc:	1d3d0501 	cfldr32ne	mvfx0, [sp, #-4]!
    42e0:	27060305 	strcs	r0, [r6, -r5, lsl #6]
    42e4:	01061405 	tsteq	r6, r5, lsl #8
    42e8:	21060305 	tstcs	r6, r5, lsl #6
    42ec:	01061b05 	tsteq	r6, r5, lsl #22
    42f0:	05201405 	streq	r1, [r0, #-1029]!	@ 0xfffffbfb
    42f4:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
    42f8:	0501061a 	streq	r0, [r1, #-1562]	@ 0xfffff9e6
    42fc:	05300603 	ldreq	r0, [r0, #-1539]!	@ 0xfffff9fd
    4300:	0501061b 	streq	r0, [r1, #-1563]	@ 0xfffff9e5
    4304:	03052014 	movweq	r2, #20500	@ 0x5014
    4308:	14052106 	strne	r2, [r5], #-262	@ 0xfffffefa
    430c:	03050106 	movweq	r0, #20742	@ 0x5106
    4310:	1a052106 	bne	14c730 <__ROM_SIZE__+0x10c730>
    4314:	03050106 	movweq	r0, #20742	@ 0x5106
    4318:	06052206 	streq	r2, [r5], -r6, lsl #4
    431c:	05050106 	streq	r0, [r5, #-262]	@ 0xfffffefa
    4320:	16053f06 	strne	r3, [r5], -r6, lsl #30
    4324:	03050106 	movweq	r0, #20742	@ 0x5106
    4328:	20062806 	andcs	r2, r6, r6, lsl #16
    432c:	2f010520 	svccs	0x00010520
    4330:	03060a05 	movweq	r0, #27141	@ 0x6a05
    4334:	0d052078 	stceq	0, cr2, [r5, #-480]	@ 0xfffffe20
    4338:	05050106 	streq	r0, [r5, #-262]	@ 0xfffffefa
    433c:	16053f06 	strne	r3, [r5], -r6, lsl #30
    4340:	05050106 	streq	r0, [r5, #-262]	@ 0xfffffefa
    4344:	16052f06 	strne	r2, [r5], -r6, lsl #30
    4348:	052e0106 	streq	r0, [lr, #-262]!	@ 0xfffffefa
    434c:	05420613 	strbeq	r0, [r2, #-1555]	@ 0xfffff9ed
    4350:	17051303 	strne	r1, [r5, -r3, lsl #6]
    4354:	06050106 	streq	r0, [r5], -r6, lsl #2
    4358:	0603052e 	streq	r0, [r3], -lr, lsr #10
    435c:	06120540 	ldreq	r0, [r2], -r0, asr #10
    4360:	2e230501 	cfsh64cs	mvdx0, mvdx3, #1
    4364:	05201705 	streq	r1, [r0, #-1797]!	@ 0xfffff8fb
    4368:	03052006 	movweq	r2, #20486	@ 0x5006
    436c:	1d052406 	cfstrsne	mvf2, [r5, #-24]	@ 0xffffffe8
    4370:	03050106 	movweq	r0, #20742	@ 0x5106
    4374:	2c052f06 	stccs	15, cr2, [r5], {6}
    4378:	03050106 	movweq	r0, #20742	@ 0x5106
    437c:	19052f06 	stmdbne	r5, {r1, r2, r8, r9, sl, fp, sp}
    4380:	03050106 	movweq	r0, #20742	@ 0x5106
    4384:	2c053e06 	stccs	14, cr3, [r5], {6}
    4388:	06050106 	streq	r0, [r5], -r6, lsl #2
    438c:	33010520 	movwcc	r0, #5408	@ 0x1520
    4390:	1c060505 	cfstr32ne	mvfx0, [r6], {5}
    4394:	01061c05 	tsteq	r6, r5, lsl #24
    4398:	74030c05 	strvc	r0, [r3], #-3077	@ 0xfffff3fb
    439c:	1a05403c 	bne	154494 <__ROM_SIZE__+0x114494>
    43a0:	580e0306 	stmdapl	lr, {r1, r2, r8, r9}
    43a4:	05130305 	ldreq	r0, [r3, #-773]	@ 0xfffffcfb
    43a8:	05010617 	streq	r0, [r1, #-1559]	@ 0xfffff9e9
    43ac:	1e052e06 	cdpne	14, 0, cr2, cr5, cr6, {0}
    43b0:	01040200 	mrseq	r0, R12_usr
    43b4:	0603053c 			@ <UNDEFINED> instruction: 0x0603053c
    43b8:	060e0524 	streq	r0, [lr], -r4, lsr #10
    43bc:	2e1f0501 	cfmul32cs	mvfx0, mvfx15, mvfx1
    43c0:	05202c05 	streq	r2, [r0, #-3077]!	@ 0xfffff3fb
    43c4:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
    43c8:	05010619 	streq	r0, [r1, #-1561]	@ 0xfffff9e7
    43cc:	05300603 	ldreq	r0, [r0, #-1539]!	@ 0xfffff9fd
    43d0:	0501062c 	streq	r0, [r1, #-1580]	@ 0xfffff9d4
    43d4:	01052006 	tsteq	r5, r6
    43d8:	06050531 			@ <UNDEFINED> instruction: 0x06050531
    43dc:	061c051e 			@ <UNDEFINED> instruction: 0x061c051e
    43e0:	00060201 	andeq	r0, r6, r1, lsl #4
    43e4:	01af0101 			@ <UNDEFINED> instruction: 0x01af0101
    43e8:	00030000 	andeq	r0, r3, r0
    43ec:	00000090 	muleq	r0, r0, r0
    43f0:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
    43f4:	0101000d 	tsteq	r1, sp
    43f8:	00000101 	andeq	r0, r0, r1, lsl #2
    43fc:	00000100 	andeq	r0, r0, r0, lsl #2
    4400:	6f682f01 	svcvs	0x00682f01
    4404:	652f656d 	strvs	r6, [pc, #-1389]!	@ 3e9f <base_order+0x887>
    4408:	2f667463 	svccs	0x00667463
    440c:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    4410:	6172742d 	cmnvs	r2, sp, lsr #8
    4414:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
    4418:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
    441c:	6c2f6c6c 	stcvs	12, cr6, [pc], #-432	@ 4274 <base_order+0xc5c>
    4420:	732f6269 			@ <UNDEFINED> instruction: 0x732f6269
    4424:	6e697274 	mcrvs	2, 3, r7, cr9, cr4, {3}
    4428:	6f2f0067 	svcvs	0x002f0067
    442c:	672f7470 			@ <UNDEFINED> instruction: 0x672f7470
    4430:	612d6363 			@ <UNDEFINED> instruction: 0x612d6363
    4434:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
    4438:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	@ 0xfffffe44
    443c:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
    4440:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
    4444:	6363672f 	cmnvs	r3, #12320768	@ 0xbc0000
    4448:	6d72612f 	ldfvse	f6, [r2, #-188]!	@ 0xffffff44
    444c:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
    4450:	61652d65 	cmnvs	r5, r5, ror #26
    4454:	312f6962 			@ <UNDEFINED> instruction: 0x312f6962
    4458:	2e322e32 	mrccs	14, 1, r2, cr2, cr2, {1}
    445c:	6e692f31 	mcrvs	15, 3, r2, cr9, cr1, {1}
    4460:	64756c63 	ldrbtvs	r6, [r5], #-3171	@ 0xfffff39d
    4464:	73000065 	movwvc	r0, #101	@ 0x65
    4468:	6e697274 	mcrvs	2, 3, r7, cr9, cr4, {3}
    446c:	00632e67 	rsbeq	r2, r3, r7, ror #28
    4470:	73000001 	movwvc	r0, #1
    4474:	65646474 	strbvs	r6, [r4, #-1140]!	@ 0xfffffb8c
    4478:	00682e66 	rsbeq	r2, r8, r6, ror #28
    447c:	00000002 	andeq	r0, r0, r2
    4480:	05002005 	streq	r2, [r0, #-5]
    4484:	00278402 	eoreq	r8, r7, r2, lsl #8
    4488:	01120300 	tsteq	r2, r0, lsl #6
    448c:	03050106 	movweq	r0, #20742	@ 0x5106
    4490:	05132106 	ldreq	r2, [r3, #-262]	@ 0xfffffefa
    4494:	0511060a 	ldreq	r0, [r1, #-1546]	@ 0xfffff9f6
    4498:	05052109 	streq	r2, [r5, #-265]	@ 0xfffffef7
    449c:	08052106 	stmdaeq	r5, {r1, r2, r8, sp}
    44a0:	0a050106 	beq	1448c0 <__ROM_SIZE__+0x1048c0>
    44a4:	0d051f06 	stceq	15, cr1, [r5, #-24]	@ 0xffffffe8
    44a8:	0a050106 	beq	1448c8 <__ROM_SIZE__+0x1048c8>
    44ac:	06030520 	streq	r0, [r3], -r0, lsr #10
    44b0:	06010531 			@ <UNDEFINED> instruction: 0x06010531
    44b4:	06300513 			@ <UNDEFINED> instruction: 0x06300513
    44b8:	13030522 	movwne	r0, #13602	@ 0x3522
    44bc:	01060905 	tsteq	r6, r5, lsl #18
    44c0:	21060505 	tstcs	r6, r5, lsl #10
    44c4:	01060905 	tsteq	r6, r5, lsl #18
    44c8:	21060505 	tstcs	r6, r5, lsl #10
    44cc:	01060905 	tsteq	r6, r5, lsl #18
    44d0:	1e061005 	cdpne	0, 0, cr1, cr6, cr5, {0}
    44d4:	01060a05 	tsteq	r6, r5, lsl #20
    44d8:	05201005 	streq	r1, [r0, #-5]!
    44dc:	0402001d 	streq	r0, [r2], #-29	@ 0xffffffe3
    44e0:	10052001 	andne	r2, r5, r1
    44e4:	01040200 	mrseq	r0, R12_usr
    44e8:	06030520 	streq	r0, [r3], -r0, lsr #10
    44ec:	06120532 			@ <UNDEFINED> instruction: 0x06120532
    44f0:	21010501 	tstcs	r1, r1, lsl #10
    44f4:	30062c05 	andcc	r2, r6, r5, lsl #24
    44f8:	05130305 	ldreq	r0, [r3, #-773]	@ 0xfffffcfb
    44fc:	05010609 	streq	r0, [r1, #-1545]	@ 0xfffff9f7
    4500:	05210605 	streq	r0, [r1, #-1541]!	@ 0xfffff9fb
    4504:	05010617 	streq	r0, [r1, #-1559]	@ 0xfffff9e9
    4508:	0a05200f 	beq	14c54c <__ROM_SIZE__+0x10c54c>
    450c:	03052d06 	movweq	r2, #23814	@ 0x5d06
    4510:	0609053f 			@ <UNDEFINED> instruction: 0x0609053f
    4514:	06030501 	streq	r0, [r3], -r1, lsl #10
    4518:	06010521 	streq	r0, [r1], -r1, lsr #10
    451c:	38052013 	stmdacc	r5, {r0, r1, r4, sp}
    4520:	03052206 	movweq	r2, #20998	@ 0x5206
    4524:	13131313 	tstne	r3, #1275068416	@ 0x4c000000
    4528:	01060a05 	tsteq	r6, r5, lsl #20
    452c:	05200305 	streq	r0, [r0, #-773]!	@ 0xfffffcfb
    4530:	04020005 	streq	r0, [r2], #-5
    4534:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
    4538:	0402001c 	streq	r0, [r2], #-28	@ 0xffffffe4
    453c:	05010603 	streq	r0, [r1, #-1539]	@ 0xfffff9fd
    4540:	04020012 	streq	r0, [r2], #-18	@ 0xffffffee
    4544:	1a052e03 	bne	14fd58 <__ROM_SIZE__+0x10fd58>
    4548:	03040200 	movweq	r0, #16896	@ 0x4200
    454c:	11052d06 	tstne	r5, r6, lsl #26
    4550:	01040200 	mrseq	r0, R12_usr
    4554:	31030520 	tstcc	r3, r0, lsr #10
    4558:	13060105 	movwne	r0, #24837	@ 0x6105
    455c:	06300520 	ldrteq	r0, [r0], -r0, lsr #10
    4560:	13030522 	movwne	r0, #13602	@ 0x3522
    4564:	0a051313 	beq	1491b8 <__ROM_SIZE__+0x1091b8>
    4568:	03050106 	movweq	r0, #20742	@ 0x5106
    456c:	00050520 	andeq	r0, r5, r0, lsr #10
    4570:	06030402 	streq	r0, [r3], -r2, lsl #8
    4574:	00120521 	andseq	r0, r2, r1, lsr #10
    4578:	06030402 	streq	r0, [r3], -r2, lsl #8
    457c:	001a0501 	andseq	r0, sl, r1, lsl #10
    4580:	06030402 	streq	r0, [r3], -r2, lsl #8
    4584:	0011051f 	andseq	r0, r1, pc, lsl r5
    4588:	20010402 	andcs	r0, r1, r2, lsl #8
    458c:	05320305 	ldreq	r0, [r2, #-773]!	@ 0xfffffcfb
    4590:	20130601 	andscs	r0, r3, r1, lsl #12
    4594:	01000102 	tsteq	r0, r2, lsl #2
    4598:	Address 0x4598 is out of bounds.


Disassembly of section .debug_str:

00000000 <.debug_str>:
   0:	6d6d6f63 	stclvs	15, cr6, [sp, #-396]!	@ 0xfffffe74
   4:	5f646e61 	svcpl	0x00646e61
   8:	706c6568 	rsbvc	r6, ip, r8, ror #10
   c:	7a697300 	bvc	1a5cc14 <__ROM_SIZE__+0x1a1cc14>
  10:	00745f65 	rsbseq	r5, r4, r5, ror #30
  14:	20554e47 	subscs	r4, r5, r7, asr #28
  18:	20373143 	eorscs	r3, r7, r3, asr #2
  1c:	322e3231 	eorcc	r3, lr, #268435459	@ 0x10000003
  20:	3220312e 	eorcc	r3, r0, #-2147483637	@ 0x8000000b
  24:	30333230 	eorscc	r3, r3, r0, lsr r2
  28:	20343132 	eorscs	r3, r4, r2, lsr r1
  2c:	70636d2d 	rsbvc	r6, r3, sp, lsr #26
  30:	6f633d75 	svcvs	0x00633d75
  34:	78657472 	stmdavc	r5!, {r1, r4, r5, r6, sl, ip, sp, lr}^
  38:	20346d2d 	eorscs	r6, r4, sp, lsr #26
  3c:	68746d2d 	ldmdavs	r4!, {r0, r2, r3, r5, r8, sl, fp, sp, lr}^
  40:	20626d75 	rsbcs	r6, r2, r5, ror sp
  44:	75746d2d 	ldrbvc	r6, [r4, #-3373]!	@ 0xfffff2d3
  48:	633d656e 	teqvs	sp, #461373440	@ 0x1b800000
  4c:	6574726f 	ldrbvs	r7, [r4, #-623]!	@ 0xfffffd91
  50:	346d2d78 	strbtcc	r2, [sp], #-3448	@ 0xfffff288
  54:	666d2d20 	strbtvs	r2, [sp], -r0, lsr #26
  58:	74616f6c 	strbtvc	r6, [r1], #-3948	@ 0xfffff094
  5c:	6962612d 	stmdbvs	r2!, {r0, r2, r3, r5, r8, sp, lr}^
  60:	666f733d 			@ <UNDEFINED> instruction: 0x666f733d
  64:	6d2d2074 	stcvs	0, cr2, [sp, #-464]!	@ 0xfffffe30
  68:	68637261 	stmdavs	r3!, {r0, r5, r6, r9, ip, sp, lr}^
  6c:	6d72613d 	ldfvse	f6, [r2, #-244]!	@ 0xffffff0c
  70:	2d653776 	stclcs	7, cr3, [r5, #-472]!	@ 0xfffffe28
  74:	672d206d 	strvs	r2, [sp, -sp, rrx]!
  78:	20626467 	rsbcs	r6, r2, r7, ror #8
  7c:	20674f2d 	rsbcs	r4, r7, sp, lsr #30
  80:	7266662d 	rsbvc	r6, r6, #47185920	@ 0x2d00000
  84:	74736565 	ldrbtvc	r6, [r3], #-1381	@ 0xfffffa9b
  88:	69646e61 	stmdbvs	r4!, {r0, r5, r6, r9, sl, fp, sp, lr}^
  8c:	2f00676e 	svccs	0x0000676e
  90:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
  94:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
  98:	63652f66 	cmnvs	r5, #408	@ 0x198
  9c:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
  a0:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
  a4:	652f7265 	strvs	r7, [pc, #-613]!	@ fffffe47 <_STACK_TOP_+0xdfff7e4b>
  a8:	2f667463 	svccs	0x00667463
  ac:	2f626f66 	svccs	0x00626f66
  b0:	6773656d 	ldrbvs	r6, [r3, -sp, ror #10]!
  b4:	6100632e 	tstvs	r0, lr, lsr #6
  b8:	00766772 	rsbseq	r6, r6, r2, ror r7
  bc:	6d6d6f63 	stclvs	15, cr6, [sp, #-396]!	@ 0xfffffe74
  c0:	00646e61 	rsbeq	r6, r4, r1, ror #28
  c4:	6d6d6f63 	stclvs	15, cr6, [sp, #-396]!	@ 0xfffffe74
  c8:	5f646e61 	svcpl	0x00646e61
  cc:	656d616e 	strbvs	r6, [sp, #-366]!	@ 0xfffffe92
  d0:	63656400 	cmnvs	r5, #0, 8
  d4:	5f65646f 	svcpl	0x0065646f
  d8:	65736162 	ldrbvs	r6, [r3, #-354]!	@ 0xfffffe9e
  dc:	41003436 	tstmi	r0, r6, lsr r4
  e0:	455f5345 	ldrbmi	r5, [pc, #-837]	@ fffffda3 <_STACK_TOP_+0xdfff7da7>
  e4:	645f4243 	ldrbvs	r4, [pc], #-579	@ ec <vector_table+0xec>
  e8:	79726365 	ldmdbvc	r2!, {r0, r2, r5, r6, r8, r9, sp, lr}^
  ec:	5f007470 	svcpl	0x00007470
  f0:	63726176 	cmnvs	r2, #-2147483619	@ 0x8000001d
  f4:	6d5f7261 	lfmvs	f7, 2, [pc, #-388]	@ ffffff78 <_STACK_TOP_+0xdfff7f7c>
  f8:	00677365 	rsbeq	r7, r7, r5, ror #6
  fc:	69736e75 	ldmdbvs	r3!, {r0, r2, r4, r5, r6, r9, sl, fp, sp, lr}^
 100:	64656e67 	strbtvs	r6, [r5], #-3687	@ 0xfffff199
 104:	61686320 	cmnvs	r8, r0, lsr #6
 108:	68730072 	ldmdavs	r3!, {r1, r4, r5, r6}^
 10c:	2074726f 	rsbscs	r7, r4, pc, ror #4
 110:	69736e75 	ldmdbvs	r3!, {r0, r2, r4, r5, r6, r9, sl, fp, sp, lr}^
 114:	64656e67 	strbtvs	r6, [r5], #-3687	@ 0xfffff199
 118:	746e6920 	strbtvc	r6, [lr], #-2336	@ 0xfffff6e0
 11c:	6e6f6c00 	cdpvs	12, 6, cr6, cr15, cr0, {0}
 120:	6f6c2067 	svcvs	0x006c2067
 124:	7520676e 	strvc	r6, [r0, #-1902]!	@ 0xfffff892
 128:	6769736e 	strbvs	r7, [r9, -lr, ror #6]!
 12c:	2064656e 	rsbcs	r6, r4, lr, ror #10
 130:	00746e69 	rsbseq	r6, r4, r9, ror #28
 134:	746e6975 	strbtvc	r6, [lr], #-2421	@ 0xfffff68b
 138:	00745f38 	rsbseq	r5, r4, r8, lsr pc
 13c:	5f534541 	svcpl	0x00534541
 140:	00787463 	rsbseq	r7, r8, r3, ror #8
 144:	6f636564 	svcvs	0x00636564
 148:	00646564 	rsbeq	r6, r4, r4, ror #10
 14c:	63727473 	cmnvs	r2, #1929379840	@ 0x73000000
 150:	6c00706d 	stcvs	0, cr7, [r0], {109}	@ 0x6d
 154:	20676e6f 	rsbcs	r6, r7, pc, ror #28
 158:	676e6f6c 	strbvs	r6, [lr, -ip, ror #30]!
 15c:	746e6920 	strbtvc	r6, [lr], #-2336	@ 0xfffff6e0
 160:	69727000 	ldmdbvs	r2!, {ip, sp, lr}^
 164:	0066746e 	rsbeq	r7, r6, lr, ror #8
 168:	726f6873 	rsbvc	r6, pc, #7536640	@ 0x730000
 16c:	6e692074 	mcrvs	0, 3, r2, cr9, cr4, {3}
 170:	72610074 	rsbvc	r0, r1, #116	@ 0x74
 174:	2f006367 	svccs	0x00006367
 178:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
 17c:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
 180:	63652f66 	cmnvs	r5, #408	@ 0x198
 184:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
 188:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
 18c:	652f7265 	strvs	r7, [pc, #-613]!	@ ffffff2f <_STACK_TOP_+0xdfff7f33>
 190:	2f667463 	svccs	0x00667463
 194:	00626f66 	rsbeq	r6, r2, r6, ror #30
 198:	5f646d63 	svcpl	0x00646d63
 19c:	6f6c0074 	svcvs	0x006c0074
 1a0:	6420676e 	strtvs	r6, [r0], #-1902	@ 0xfffff892
 1a4:	6c62756f 	cfstr64vs	mvdx7, [r2], #-444	@ 0xfffffe44
 1a8:	74730065 	ldrbtvc	r0, [r3], #-101	@ 0xffffff9b
 1ac:	6e656c72 	mcrvs	12, 3, r6, cr5, cr2, {3}
 1b0:	6e697500 	cdpvs	5, 6, cr7, cr9, cr0, {0}
 1b4:	5f323374 	svcpl	0x00323374
 1b8:	65720074 	ldrbvs	r0, [r2, #-116]!	@ 0xffffff8c
 1bc:	5f746573 	svcpl	0x00746573
 1c0:	646e6168 	strbtvs	r6, [lr], #-360	@ 0xfffffe98
 1c4:	0072656c 	rsbseq	r6, r2, ip, ror #10
 1c8:	61666564 	cmnvs	r6, r4, ror #10
 1cc:	5f746c75 	svcpl	0x00746c75
 1d0:	646e6168 	strbtvs	r6, [lr], #-360	@ 0xfffffe98
 1d4:	0072656c 	rsbseq	r6, r2, ip, ror #10
 1d8:	4154535f 	cmpmi	r4, pc, asr r3
 1dc:	545f4b43 	ldrbpl	r4, [pc], #-2883	@ 1e4 <vector_table+0x1e4>
 1e0:	005f504f 	subseq	r5, pc, pc, asr #32
 1e4:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 130 <vector_table+0x130>
 1e8:	63652f65 	cmnvs	r5, #404	@ 0x194
 1ec:	652f6674 	strvs	r6, [pc, #-1652]!	@ fffffb80 <_STACK_TOP_+0xdfff7b84>
 1f0:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
 1f4:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
 1f8:	2f72656e 	svccs	0x0072656e
 1fc:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
 200:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
 204:	616c702f 	cmnvs	ip, pc, lsr #32
 208:	726f6674 	rsbvc	r6, pc, #116, 12	@ 0x7400000
 20c:	65762f6d 	ldrbvs	r2, [r6, #-3949]!	@ 0xfffff093
 210:	726f7463 	rsbvc	r7, pc, #1660944384	@ 0x63000000
 214:	6261745f 	rsbvs	r7, r1, #1593835520	@ 0x5f000000
 218:	632e656c 			@ <UNDEFINED> instruction: 0x632e656c
 21c:	63657600 	cmnvs	r5, #0, 12
 220:	5f726f74 	svcpl	0x00726f74
 224:	6c626174 	stfvse	f6, [r2], #-464	@ 0xfffffe30
 228:	61750065 	cmnvs	r5, r5, rrx
 22c:	695f7472 	ldmdbvs	pc, {r1, r4, r5, r6, sl, ip, sp, lr}^	@ <UNPREDICTABLE>
 230:	0074696e 	rsbseq	r6, r4, lr, ror #18
 234:	74656775 	strbtvc	r6, [r5], #-1909	@ 0xfffff88b
 238:	70750063 	rsbsvc	r0, r5, r3, rrx
 23c:	00637475 	rsbeq	r7, r3, r5, ror r4
 240:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 18c <vector_table+0x18c>
 244:	63652f65 	cmnvs	r5, #404	@ 0x194
 248:	652f6674 	strvs	r6, [pc, #-1652]!	@ fffffbdc <_STACK_TOP_+0xdfff7be0>
 24c:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
 250:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
 254:	2f72656e 	svccs	0x0072656e
 258:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
 25c:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
 260:	616c702f 	cmnvs	ip, pc, lsr #32
 264:	726f6674 	rsbvc	r6, pc, #116, 12	@ 0x7400000
 268:	61752f6d 	cmnvs	r5, sp, ror #30
 26c:	752f7472 	strvc	r7, [pc, #-1138]!	@ fffffe02 <_STACK_TOP_+0xdfff7e06>
 270:	2e747261 	cdpcs	2, 7, cr7, cr4, cr1, {3}
 274:	61750063 	cmnvs	r5, r3, rrx
 278:	5f327472 	svcpl	0x00327472
 27c:	74696e69 	strbtvc	r6, [r9], #-3689	@ 0xfffff197
 280:	70327500 	eorsvc	r7, r2, r0, lsl #10
 284:	00637475 	rsbeq	r7, r3, r5, ror r4
 288:	65673275 	strbvs	r3, [r7, #-629]!	@ 0xfffffd8b
 28c:	2f006374 	svccs	0x00006374
 290:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
 294:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
 298:	63652f66 	cmnvs	r5, #408	@ 0x198
 29c:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
 2a0:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
 2a4:	652f7265 	strvs	r7, [pc, #-613]!	@ 47 <vector_table+0x47>
 2a8:	2f667463 	svccs	0x00667463
 2ac:	2f626f66 	svccs	0x00626f66
 2b0:	74616c70 	strbtvc	r6, [r1], #-3184	@ 0xfffff390
 2b4:	6d726f66 	ldclvs	15, cr6, [r2, #-408]!	@ 0xfffffe68
 2b8:	7261752f 	rsbvc	r7, r1, #197132288	@ 0xbc00000
 2bc:	61752f74 	cmnvs	r5, r4, ror pc
 2c0:	2e327472 	mrccs	4, 1, r7, cr2, cr2, {3}
 2c4:	682f0063 	stmdavs	pc!, {r0, r1, r5, r6}	@ <UNPREDICTABLE>
 2c8:	2f656d6f 	svccs	0x00656d6f
 2cc:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
 2d0:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
 2d4:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
 2d8:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
 2dc:	63652f72 	cmnvs	r5, #456	@ 0x1c8
 2e0:	662f6674 			@ <UNDEFINED> instruction: 0x662f6674
 2e4:	702f626f 	eorvc	r6, pc, pc, ror #4
 2e8:	6674616c 	ldrbtvs	r6, [r4], -ip, ror #2
 2ec:	2f6d726f 	svccs	0x006d726f
 2f0:	74616c70 	strbtvc	r6, [r1], #-3184	@ 0xfffff390
 2f4:	6d726f66 	ldclvs	15, cr6, [r2, #-408]!	@ 0xfffffe68
 2f8:	7000632e 	andvc	r6, r0, lr, lsr #6
 2fc:	735f6e69 	cmpvc	pc, #1680	@ 0x690
 300:	70757465 	rsbsvc	r7, r5, r5, ror #8
 304:	74657300 	strbtvc	r7, [r5], #-768	@ 0xfffffd00
 308:	6165725f 	cmnvs	r5, pc, asr r2
 30c:	68635f64 	stmdavs	r3!, {r2, r5, r6, r8, r9, sl, fp, ip, lr}^
 310:	00327261 	eorseq	r7, r2, r1, ror #4
 314:	5f746573 	svcpl	0x00746573
 318:	74697277 	strbtvc	r7, [r9], #-631	@ 0xfffffd89
 31c:	68635f65 	stmdavs	r3!, {r0, r2, r5, r6, r8, r9, sl, fp, ip, lr}^
 320:	73007261 	movwvc	r7, #609	@ 0x261
 324:	775f7465 	ldrbvc	r7, [pc, -r5, ror #8]
 328:	65746972 	ldrbvs	r6, [r4, #-2418]!	@ 0xfffff68e
 32c:	6168635f 	cmnvs	r8, pc, asr r3
 330:	73003272 	movwvc	r3, #626	@ 0x272
 334:	725f7465 	subsvc	r7, pc, #1694498816	@ 0x65000000
 338:	5f646165 	svcpl	0x00646165
 33c:	72616863 	rsbvc	r6, r1, #6488064	@ 0x630000
 340:	616c7000 	cmnvs	ip, r0
 344:	726f6674 	rsbvc	r6, pc, #116, 12	@ 0x7400000
 348:	6e695f6d 	cdpvs	15, 6, cr5, cr9, cr13, {3}
 34c:	70007469 	andvc	r7, r0, r9, ror #8
 350:	746e6972 	strbtvc	r6, [lr], #-2418	@ 0xfffff68e
 354:	41003266 	tstmi	r0, r6, ror #4
 358:	455f5345 	ldrbmi	r5, [pc, #-837]	@ 1b <vector_table+0x1b>
 35c:	655f4243 	ldrbvs	r4, [pc, #-579]	@ 121 <vector_table+0x121>
 360:	7972636e 	ldmdbvc	r2!, {r1, r2, r3, r5, r6, r8, r9, sp, lr}^
 364:	62007470 	andvs	r7, r0, #112, 8	@ 0x70000000
 368:	65743436 	ldrbvs	r3, [r4, #-1078]!	@ 0xfffffbca
 36c:	2f007478 	svccs	0x00007478
 370:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
 374:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
 378:	63652f66 	cmnvs	r5, #408	@ 0x198
 37c:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
 380:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
 384:	652f7265 	strvs	r7, [pc, #-613]!	@ 127 <vector_table+0x127>
 388:	2f667463 	svccs	0x00667463
 38c:	2f626f66 	svccs	0x00626f66
 390:	5f736561 	svcpl	0x00736561
 394:	74736574 	ldrbtvc	r6, [r3], #-1396	@ 0xfffffa8c
 398:	6500632e 	strvs	r6, [r0, #-814]	@ 0xfffffcd2
 39c:	646f636e 	strbtvs	r6, [pc], #-878	@ 3a4 <vector_table+0x3a4>
 3a0:	61625f65 	cmnvs	r2, r5, ror #30
 3a4:	34366573 	ldrtcc	r6, [r6], #-1395	@ 0xfffffa8d
 3a8:	61765f00 	cmnvs	r6, r0, lsl #30
 3ac:	73656172 	cmnvc	r5, #-2147483620	@ 0x8000001c
 3b0:	7365745f 	cmnvc	r5, #1593835520	@ 0x5f000000
 3b4:	765f0074 			@ <UNDEFINED> instruction: 0x765f0074
 3b8:	61707261 	cmnvs	r0, r1, ror #4
 3bc:	2f007269 	svccs	0x00007269
int car_mesg(int argc, char** argv) {
 3c0:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
 3c4:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
    printf("Received a message from the car:");
 3c8:	63652f66 	cmnvs	r5, #408	@ 0x198
 3cc:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
    for (ctr = 1; ctr < argc; ctr++) {
 3d0:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
        printf(" %s", argv[ctr]);
 3d4:	652f7265 	strvs	r7, [pc, #-613]!	@ 177 <vector_table+0x177>
 3d8:	2f667463 	svccs	0x00667463
    for (ctr = 1; ctr < argc; ctr++) {
 3dc:	2f626f66 	svccs	0x00626f66
 3e0:	72696170 	rsbvc	r6, r9, #112, 2
    printf("\n");
 3e4:	5f00632e 	svcpl	0x0000632e
    if (argc > 1) {
 3e8:	64726176 	ldrbtvs	r6, [r2], #-374	@ 0xfffffe8a
}
 3ec:	646f6365 	strbtvs	r6, [pc], #-869	@ 3f4 <car_mesg+0x34>
 3f0:	00343665 	eorseq	r3, r4, r5, ror #12
        if (strcmp(argv[1], "PING_REPLY") == 0) {
 3f4:	69616c70 	stmdbvs	r1!, {r4, r5, r6, sl, fp, sp, lr}^
 3f8:	7865746e 	stmdavc	r5!, {r1, r2, r3, r5, r6, sl, ip, sp, lr}^
            printf("Got a ping reply.\n");
 3fc:	6e650074 	mcrvs	0, 3, r0, cr5, cr4, {3}
 400:	65646f63 	strbvs	r6, [r4, #-3939]!	@ 0xfffff09d
        else if (strcmp(argv[1], "AESB64") == 0) {
 404:	682f0064 	stmdavs	pc!, {r2, r5, r6}	@ <UNPREDICTABLE>
 408:	2f656d6f 	svccs	0x00656d6f
 40c:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
            if (argc == 3) { 
 410:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
                printf("Missing AESB64 encoded message\n");
 414:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
 418:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
                len = decode_base64((uint8_t *) argv[2], strlen(argv[2]), decoded);
 41c:	63652f72 	cmnvs	r5, #456	@ 0x1c8
 420:	662f6674 			@ <UNDEFINED> instruction: 0x662f6674
 424:	622f626f 	eorvs	r6, pc, #-268435450	@ 0xf0000006
 428:	36657361 	strbtcc	r7, [r5], -r1, ror #6
 42c:	00632e34 	rsbeq	r2, r3, r4, lsr lr
                AES_ECB_decrypt(&ctx, decoded);
 430:	7261765f 	rsbvc	r7, r1, #99614720	@ 0x5f00000
 434:	6f636e65 	svcvs	0x00636e65
                decoded[len] = '\0';
 438:	34366564 	ldrtcc	r6, [r6], #-1380	@ 0xfffffa9c
 43c:	61687300 	cmnvs	r8, r0, lsl #6
 440:	00787463 	rsbseq	r7, r8, r3, ror #8
                printf("Decoded/decrypted as %s\n", decoded);
 444:	48444345 	stmdami	r4, {r0, r2, r6, r8, r9, lr}^
 448:	6972705f 	ldmdbvs	r2!, {r0, r1, r2, r3, r4, r6, ip, sp, lr}^
 44c:	79656b76 	stmdbvc	r5!, {r1, r2, r4, r5, r6, r8, r9, fp, sp, lr}^
        else if (strcmp(argv[1], "B64") == 0) {
 450:	74616400 	strbtvc	r6, [r1], #-1024	@ 0xfffffc00
 454:	6e656c61 	cdpvs	12, 6, cr6, cr5, cr1, {3}
            if (argc == 3) { 
 458:	524f5700 	subpl	r5, pc, #0, 14
                printf("Missing Base64 encoded message\n");
 45c:	68730044 	ldmdavs	r3!, {r2, r6}^
 460:	64657261 	strbtvs	r7, [r5], #-609	@ 0xfffffd9f
                printf("Decoding Base64\n");
 464:	72636573 	rsbvc	r6, r3, #482344960	@ 0x1cc00000
 468:	00327465 	eorseq	r7, r2, r5, ror #8
                len = decode_base64((uint8_t *) argv[2], strlen(argv[2]), decoded);
 46c:	48444345 	stmdami	r4, {r0, r2, r6, r8, r9, lr}^
 470:	5345415f 	movtpl	r4, #20831	@ 0x515f
 474:	0079656b 	rsbseq	r6, r9, fp, ror #10
 478:	45545942 	ldrbmi	r5, [r4, #-2370]	@ 0xfffff6be
                decoded[len] = '\0';
 47c:	61687300 	cmnvs	r8, r0, lsl #6
 480:	5f363532 	svcpl	0x00363532
 484:	616e6966 	cmnvs	lr, r6, ror #18
                printf("Decoded as %s", decoded);
 488:	765f006c 	ldrbvc	r0, [pc], -ip, rrx
 48c:	63657261 	cmnvs	r5, #268435462	@ 0x10000006
 490:	745f6864 	ldrbvc	r6, [pc], #-2148	@ 498 <car_mesg+0xd8>
            printf("Didn't know how to handle %s\n", argv[1]);
 494:	00747365 	rsbseq	r7, r4, r5, ror #6
 498:	32616873 	rsbcc	r6, r1, #7536640	@ 0x730000
 49c:	695f3635 	ldmdbvs	pc, {r0, r2, r4, r5, r9, sl, ip, sp}^	@ <UNPREDICTABLE>
 4a0:	0074696e 	rsbseq	r6, r4, lr, ror #18
 4a4:	68646365 	stmdavs	r4!, {r0, r2, r5, r6, r8, r9, sp, lr}^
 4a8:	6e65675f 	mcrvs	7, 3, r6, cr5, cr15, {2}
 4ac:	74617265 	strbtvc	r7, [r1], #-613	@ 0xfffffd9b
 4b0:	656b5f65 	strbvs	r5, [fp, #-3941]!	@ 0xfffff09b
 4b4:	6b007379 	blvs	1d2a0 <__RAM_SIZE__+0x152a0>
 4b8:	65747965 	ldrbvs	r7, [r4, #-2405]!	@ 0xfffff69b
 4bc:	62007473 	andvs	r7, r0, #1929379840	@ 0x73000000
 4c0:	72703436 	rsbsvc	r3, r0, #905969664	@ 0x36000000
 4c4:	656b7669 	strbvs	r7, [fp, #-1641]!	@ 0xfffff997
 4c8:	2f003279 	svccs	0x00003279
 4cc:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
 4d0:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
 4d4:	63652f66 	cmnvs	r5, #408	@ 0x198
void uputc(char c) {
 4d8:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
  while ((UARTFR >> 5) & 1)
 4dc:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
 4e0:	652f7265 	strvs	r7, [pc, #-613]!	@ 283 <vector_table+0x283>
  UART_DR = c;
 4e4:	2f667463 	svccs	0x00667463
  if (c == '\n')
 4e8:	2f626f66 	svccs	0x00626f66
}
 4ec:	68646365 	stmdavs	r4!, {r0, r2, r5, r6, r8, r9, sp, lr}^
    uputc('\r');
 4f0:	7365745f 	cmnvc	r5, #1593835520	@ 0x5f000000
}
 4f4:	00632e74 	rsbeq	r2, r3, r4, ror lr
 4f8:	48444345 	stmdami	r4, {r0, r2, r6, r8, r9, lr}^
  if (!((UARTFR >> 4) & 1)) return UART_DR;
 4fc:	6972705f 	ldmdbvs	r2!, {r0, r1, r2, r3, r4, r6, ip, sp, lr}^
 500:	79656b76 	stmdbvc	r5!, {r1, r2, r4, r5, r6, r8, r9, fp, sp, lr}^
 504:	3436625f 	ldrtcc	r6, [r6], #-607	@ 0xfffffda1
 508:	74696200 	strbtvc	r6, [r9], #-512	@ 0xfffffe00
  return -1;
 50c:	006e656c 	rsbeq	r6, lr, ip, ror #10
}
 510:	32414853 	subcc	r4, r1, #5439488	@ 0x530000
 514:	435f3635 	cmpmi	pc, #55574528	@ 0x3500000
  UARTCTL = 0;
 518:	73005854 	movwvc	r5, #2132	@ 0x854
 51c:	35326168 	ldrcc	r6, [r2, #-360]!	@ 0xfffffe98
  UARTIBRD = 8;
 520:	70755f36 	rsbsvc	r5, r5, r6, lsr pc
  UARTFBRD = 44;
 524:	65746164 	ldrbvs	r6, [r4, #-356]!	@ 0xfffffe9c
  UARTCC = 0;
 528:	53454100 	movtpl	r4, #20736	@ 0x5100
  UARTLCRH = 0x60;
 52c:	696e695f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, sp, lr}^
  UARTCTL = 0x301;
 530:	74635f74 	strbtvc	r5, [r3], #-3956	@ 0xfffff08c
}
 534:	75700078 	ldrbvc	r0, [r0, #-120]!	@ 0xffffff88
 538:	79656b62 	stmdbvc	r5!, {r1, r5, r6, r8, r9, fp, sp, lr}^
void u2putc(char c) {
 53c:	36620032 			@ <UNDEFINED> instruction: 0x36620032
  while ((UART2FR >> 5) & 1)
 540:	73657434 	cmnvc	r5, #52, 8	@ 0x34000000
 544:	63650074 	cmnvs	r5, #116	@ 0x74
  UART2_DR = c;
 548:	735f6864 	cmpvc	pc, #100, 16	@ 0x640000
  if (c == '\n')
 54c:	65726168 	ldrbvs	r6, [r2, #-360]!	@ 0xfffffe98
}
 550:	65735f64 	ldrbvs	r5, [r3, #-3940]!	@ 0xfffff09c
    u2putc('\r');
 554:	74657263 	strbtvc	r7, [r5], #-611	@ 0xfffffd9d
}
 558:	44434500 	strbmi	r4, [r3], #-1280	@ 0xfffffb00
 55c:	75705f48 	ldrbvc	r5, [r0, #-3912]!	@ 0xfffff0b8
  if (!((UART2FR >> 4) & 1)) return UART2_DR;
 560:	79656b62 	stmdbvc	r5!, {r1, r5, r6, r8, r9, fp, sp, lr}^
 564:	44434500 	strbmi	r4, [r3], #-1280	@ 0xfffffb00
 568:	68735f48 	ldmdavs	r3!, {r3, r6, r8, r9, sl, fp, ip, lr}^
 56c:	64657261 	strbtvs	r7, [r5], #-609	@ 0xfffffd9f
  return -1;
 570:	61765f00 	cmnvs	r6, r0, lsl #30
}
 574:	6e657372 	mcrvs	3, 3, r7, cr5, cr2, {3}
 578:	69705f64 	ldmdbvs	r0!, {r2, r5, r6, r8, r9, sl, fp, ip, lr}^
  UART2CTL = 0;
 57c:	2f00676e 	svccs	0x0000676e
 580:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
  UART2IBRD = 8;
 584:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
  UART2FBRD = 44;
 588:	63652f66 	cmnvs	r5, #408	@ 0x198
  UART2CC = 0;
 58c:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
  UART2LCRH = 0x60;
 590:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
  UART2CTL = 0x301;
 594:	652f7265 	strvs	r7, [pc, #-613]!	@ 337 <vector_table+0x337>
}
 598:	2f667463 	svccs	0x00667463
 59c:	2f626f66 	svccs	0x00626f66
  RCGCUART |= 3;
 5a0:	676e6970 			@ <UNDEFINED> instruction: 0x676e6970
 5a4:	2f00632e 	svccs	0x0000632e
 5a8:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
 5ac:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
  RCGCGPIO |= 3;
 5b0:	63652f66 	cmnvs	r5, #408	@ 0x198
 5b4:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
 5b8:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
  GPIODEN = 0x03;
 5bc:	652f7265 	strvs	r7, [pc, #-613]!	@ 35f <vector_table+0x35f>
 5c0:	2f667463 	svccs	0x00667463
  GPIOAFSEL = 0x03;
 5c4:	2f626f66 	svccs	0x00626f66
  GPIOPCTL |= 0x00000011;
 5c8:	32616873 	rsbcc	r6, r1, #7536640	@ 0x730000
 5cc:	745f3635 	ldrbvc	r3, [pc], #-1589	@ 5d4 <pin_setup+0x34>
 5d0:	2e747365 	cdpcs	3, 7, cr7, cr4, cr5, {3}
  GPIODEN2 = 0x03;
 5d4:	36620063 	strbtcc	r0, [r2], -r3, rrx
 5d8:	75625f34 	strbvc	r5, [r2, #-3892]!	@ 0xfffff0cc
  GPIOAFSEL2 = 0x03;
 5dc:	36620066 	strbtcc	r0, [r2], -r6, rrx
  GPIOPCTL2 |= 0x00000011;
 5e0:	61685f34 	cmnvs	r8, r4, lsr pc
 5e4:	00316873 	eorseq	r6, r1, r3, ror r8
 5e8:	74786574 	ldrbtvc	r6, [r8], #-1396	@ 0xfffffa8c
}
 5ec:	765f0031 			@ <UNDEFINED> instruction: 0x765f0031
 5f0:	68737261 	ldmdavs	r3!, {r0, r5, r6, r9, ip, sp, lr}^
void platform_init() {
 5f4:	36353261 	ldrtcc	r3, [r5], -r1, ror #4
    pin_setup();
 5f8:	7365745f 	cmnvc	r5, #1593835520	@ 0x5f000000
    uart_init();
 5fc:	61700074 	cmnvs	r0, r4, ror r0
    uart2_init();
 600:	5f657372 	svcpl	0x00657372
    set_read_char(ugetc);
 604:	656e696c 	strbvs	r6, [lr, #-2412]!	@ 0xfffff694
    set_read_char2(u2getc);
 608:	61686300 	cmnvs	r8, r0, lsl #6
 60c:	6f635f72 	svcvs	0x00635f72
    set_write_char(uputc);
 610:	00746e75 	rsbseq	r6, r4, r5, ror lr
    set_write_char2(u2putc);
 614:	72775f5f 	rsbsvc	r5, r7, #380	@ 0x17c
 618:	5f657469 	svcpl	0x00657469
}
 61c:	72616863 	rsbvc	r6, r1, #6488064	@ 0x630000
 620:	005f5f32 	subseq	r5, pc, r2, lsr pc	@ <UNPREDICTABLE>
 624:	6164655f 	cmnvs	r4, pc, asr r5
 628:	5f006174 	svcpl	0x00006174
int aes_test(int argc, char** argv) {
 62c:	73726176 	cmnvc	r2, #-2147483619	@ 0x8000001d
    uint8_t text[17] = "0123456789abcdef";
 630:	5f776f68 	svcpl	0x00776f68
 634:	74736968 	ldrbtvc	r6, [r3], #-2408	@ 0xfffff698
 638:	0079726f 	rsbseq	r7, r9, pc, ror #4
 63c:	69746361 	ldmdbvs	r4!, {r0, r5, r6, r8, r9, sp, lr}^
 640:	705f6576 	subsvc	r6, pc, r6, ror r5	@ <UNPREDICTABLE>
    printf("Plaintext is %s\n", text);
 644:	706d6f72 	rsbvc	r6, sp, r2, ror pc
 648:	45410074 	strbmi	r0, [r1, #-116]	@ 0xffffff8c
    AES_ECB_encrypt(&ctx, text);
 64c:	656b5f53 	strbvs	r5, [fp, #-3923]!	@ 0xfffff0ad
 650:	65760079 	ldrbvs	r0, [r6, #-121]!	@ 0xffffff87
    len = encode_base64(text, 16, b64text);
 654:	736f6272 	cmnvc	pc, #536870919	@ 0x20000007
 658:	765f0065 	ldrbvc	r0, [pc], -r5, rrx
 65c:	6d637261 	sfmvs	f7, 2, [r3, #-388]!	@ 0xfffffe7c
    b64text[len] = '\0';
 660:	78655f64 	stmdavc	r5!, {r2, r5, r6, r8, r9, sl, fp, ip, lr}^
 664:	735f6365 	cmpvc	pc, #-1811939327	@ 0x94000001
 668:	75746174 	ldrbvc	r6, [r4, #-372]!	@ 0xfffffe8c
    printf("Encrypted/encoded is %s\n", b64text);
 66c:	5f5f0073 	svcpl	0x005f0073
 670:	64616572 	strbtvs	r6, [r1], #-1394	@ 0xfffffa8e
    printf2("FOB_MESG AESB64 %s\n", b64text);
 674:	6168635f 	cmnvs	r8, pc, asr r3
 678:	005f5f72 	subseq	r5, pc, r2, ror pc	@ <UNPREDICTABLE>
    printf("Test the mesg handler with CAR_MESG AESB64 %s\n", b64text);
 67c:	74696e69 	strbtvc	r6, [r9], #-3689	@ 0xfffff197
 680:	5f6c6169 	svcpl	0x006c6169
    len = decode_base64(b64text, len, decoded);
 684:	75746573 	ldrbvc	r6, [r4, #-1395]!	@ 0xfffffa8d
 688:	656d0070 	strbvs	r0, [sp, #-112]!	@ 0xffffff90
 68c:	7970636d 	ldmdbvc	r0!, {r0, r2, r3, r5, r6, r8, r9, sp, lr}^
    AES_ECB_decrypt(&ctx, decoded);
 690:	61765f00 	cmnvs	r6, r0, lsl #30
 694:	6c656872 	stclvs	8, cr6, [r5], #-456	@ 0xfffffe38
    decoded[len] = '\0';
 698:	61680070 	smcvs	32768	@ 0x8000
 69c:	656c646e 	strbvs	r6, [ip, #-1134]!	@ 0xfffffb92
 6a0:	6261745f 	rsbvs	r7, r1, #1593835520	@ 0x5f000000
    printf("After encrypting->encoding->decoding->decrypting we recover %s\n", decoded);
 6a4:	656c6300 	strbvs	r6, [ip, #-768]!	@ 0xfffffd00
 6a8:	705f7261 	subsvc	r7, pc, r1, ror #4
}
 6ac:	706d6f72 	rsbvc	r6, sp, r2, ror pc
 6b0:	6d630074 	stclvs	0, cr0, [r3, #-464]!	@ 0xfffffe30
 6b4:	69685f64 	stmdbvs	r8!, {r2, r5, r6, r8, r9, sl, fp, ip, lr}^
 6b8:	726f7473 	rsbvc	r7, pc, #1929379840	@ 0x73000000
 6bc:	682f0079 	stmdavs	pc!, {r0, r3, r4, r5, r6}	@ <UNPREDICTABLE>
 6c0:	2f656d6f 	svccs	0x00656d6f
 6c4:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
 6c8:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
 6cc:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
int pair(int argc, char** argv) {
 6d0:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
    printf("Sending a pair request.\n");
 6d4:	68732f72 	ldmdavs	r3!, {r1, r4, r5, r6, r8, r9, sl, fp, sp}^
    printf2("FOB_MESG PAIR\n");
 6d8:	2f6c6c65 	svccs	0x006c6c65
 6dc:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
}
 6e0:	68732f6c 	ldmdavs	r3!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
 6e4:	2e6c6c65 	cdpcs	12, 6, cr6, cr12, cr5, {3}
 6e8:	6d630063 	stclvs	0, cr0, [r3, #-396]!	@ 0xfffffe74
int encode64(int argc, char** argv) {
 6ec:	74735f64 	ldrbtvc	r5, [r3], #-3940	@ 0xfffff09c
    if (argc > 1) {
 6f0:	61680072 	smcvs	32770	@ 0x8002
 6f4:	656c646e 	strbvs	r6, [ip, #-1134]!	@ 0xfffffb92
        len = strlen(argv[1]);
 6f8:	5f70755f 	svcpl	0x0070755f
 6fc:	6f727261 	svcvs	0x00727261
        if (len < MAXARRAYLEN) {
 700:	78650077 	stmdavc	r5!, {r0, r1, r2, r4, r5, r6}^
            len = encode_base64((uint8_t *) argv[1], len, encoded);
 704:	66006365 	strvs	r6, [r0], -r5, ror #6
 708:	00636e75 	rsbeq	r6, r3, r5, ror lr
            printf("Encoded %s as %s with %d characters\n", argv[1], encoded, len);
 70c:	7362655f 	cmnvc	r2, #398458880	@ 0x17c00000
 710:	656d0073 	strbvs	r0, [sp, #-115]!	@ 0xffffff8d
 714:	7465736d 	strbtvc	r7, [r5], #-877	@ 0xfffffc93
            printf("String exceeds max length of %d characters", MAXARRAYLEN);
 718:	435f5f00 	cmpmi	pc, #0, 30
 71c:	545f444d 	ldrbpl	r4, [pc], #-1101	@ 724 <encode64+0x38>
 720:	454c4241 	strbmi	r4, [ip, #-577]	@ 0xfffffdbf
        printf("Usage is 'encode64 string'\n");
 724:	4154535f 	cmpmi	r4, pc, asr r3
}
 728:	5f5f5452 	svcpl	0x005f5452
 72c:	6e696c00 	cdpvs	12, 6, cr6, cr9, cr0, {0}
 730:	75625f65 	strbvc	r5, [r2, #-3941]!	@ 0xfffff09b
 734:	5f006666 	svcpl	0x00006666
 738:	61746164 	cmnvs	r4, r4, ror #2
int decode64(int argc, char** argv) {
 73c:	65687300 	strbvs	r7, [r8, #-768]!	@ 0xfffffd00
    if (argc > 1) {
 740:	41006c6c 	tstmi	r0, ip, ror #24
 744:	6b5f5345 	blvs	17d5460 <__ROM_SIZE__+0x1795460>
        int len = strlen(argv[1]);
 748:	625f7965 	subsvs	r7, pc, #1654784	@ 0x194000
 74c:	61003436 	tstvs	r0, r6, lsr r4
        if (len < MAXBASE64LEN) {
 750:	635f6464 	cmpvs	pc, #100, 8	@ 0x64000000
                len = decode_base64((uint8_t *) argv[1], len, plaintext);
 754:	616d6d6f 	cmnvs	sp, pc, ror #26
 758:	745f646e 	ldrbvc	r6, [pc], #-1134	@ 760 <decode64+0x24>
                plaintext[len] = '\0';
 75c:	69685f6f 	stmdbvs	r8!, {r0, r1, r2, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
 760:	726f7473 	rsbvc	r7, pc, #1929379840	@ 0x73000000
 764:	616d0079 	smcvs	53257	@ 0xd009
                printf("Decoded %s as: %s\n", argv[1], plaintext);
 768:	5f686374 	svcpl	0x00686374
 76c:	6e756f66 	cdpvs	15, 7, cr6, cr5, cr6, {3}
 770:	6d630064 	stclvs	0, cr0, [r3, #-400]!	@ 0xfffffe70
            printf("String exceeds max base64 string length of %d characters", MAXBASE64LEN);
 774:	6e655f64 	cdpvs	15, 6, cr5, cr5, cr4, {3}
 778:	74005f64 	strvc	r5, [r0], #-3940	@ 0xfffff09c
 77c:	6c61746f 	cfstrdvs	mvd7, [r1], #-444	@ 0xfffffe44
        printf("Usage is 'decode64 string'\n");
 780:	6d756e5f 	ldclvs	14, cr6, [r5, #-380]!	@ 0xfffffe84
}
 784:	6d6f635f 	stclvs	3, cr6, [pc, #-380]!	@ 610 <platform_init+0x1c>
 788:	646e616d 	strbtvs	r6, [lr], #-365	@ 0xfffffe93
 78c:	5f5f0073 	svcpl	0x005f0073
 790:	4f545541 	svcmi	0x00545541
 794:	4241545f 	submi	r5, r1, #1593835520	@ 0x5f000000
int ecdh_test(int argc, char** argv) {
 798:	535f454c 	cmppl	pc, #76, 10	@ 0x13000000
    uint8_t b64privkey2[32] = "wP/uwP/uwP/uwP/uwP/uwP/uwP/uwP/u";
 79c:	54524154 	ldrbpl	r4, [r2], #-340	@ 0xfffffeac
 7a0:	6c005f5f 	stcvs	15, cr5, [r0], {95}	@ 0x5f
 7a4:	00706f6f 	rsbseq	r6, r0, pc, ror #30
 7a8:	63657073 	cmnvs	r5, #115	@ 0x73
 7ac:	5f6c6169 	svcpl	0x006c6169
    printf("Testing the ecdh key exchange\n");
 7b0:	0079656b 	rsbseq	r6, r9, fp, ror #10
 7b4:	5f646d63 	svcpl	0x00646d63
    decode_base64(ECDH_privkey_b64, 32, ECDH_privkey);
 7b8:	66667562 	strbtvs	r7, [r6], -r2, ror #10
 7bc:	61765f00 	cmnvs	r6, r0, lsl #30
 7c0:	69756272 	ldmdbvs	r5!, {r1, r4, r5, r6, r9, sp, lr}^
    decode_base64(b64privkey2, 32, privkey2);
 7c4:	695f646c 	ldmdbvs	pc, {r2, r3, r5, r6, sl, sp, lr}^	@ <UNPREDICTABLE>
 7c8:	006f666e 	rsbeq	r6, pc, lr, ror #12
    ecdh_generate_keys(ECDH_pubkey, ECDH_privkey);
 7cc:	66657270 			@ <UNDEFINED> instruction: 0x66657270
 7d0:	6d5f7869 	ldclvs	8, cr7, [pc, #-420]	@ 634 <aes_test+0x8>
 7d4:	68637461 	stmdavs	r3!, {r0, r5, r6, sl, ip, sp, lr}^
    ecdh_generate_keys(pubkey2, privkey2);
 7d8:	6f425f00 	svcvs	0x00425f00
 7dc:	6c006c6f 	stcvs	12, cr6, [r0], {111}	@ 0x6f
    ecdh_shared_secret(ECDH_privkey, pubkey2, ECDH_shared);
 7e0:	5f747361 	svcpl	0x00747361
 7e4:	6374616d 	cmnvs	r4, #1073741851	@ 0x4000001b
 7e8:	72700068 	rsbsvc	r0, r0, #104	@ 0x68
    ecdh_shared_secret(privkey2, ECDH_pubkey, sharedsecret2);
 7ec:	6e657065 	cdpvs	0, 6, cr7, cr5, cr5, {3}
 7f0:	72705f64 	rsbsvc	r5, r0, #100, 30	@ 0x190
    sha256_init(&shactx);
 7f4:	74706d6f 	ldrbtvc	r6, [r0], #-3439	@ 0xfffff291
 7f8:	6c656400 	cfstrdvs	mvd6, [r5], #-0
	sha256_update(&shactx, ECDH_shared, ECC_PUB_KEY_SIZE);
 7fc:	00657465 	rsbeq	r7, r5, r5, ror #8
 800:	72775f5f 	rsbsvc	r5, r7, #380	@ 0x17c
	sha256_final(&shactx, ECDH_AESkey);
 804:	5f657469 	svcpl	0x00657469
 808:	72616863 	rsbvc	r6, r1, #6488064	@ 0x630000
 80c:	68005f5f 	stmdavs	r0, {r0, r1, r2, r3, r4, r6, r8, r9, sl, fp, ip, lr}
    len = encode_base64(ECDH_AESkey, AES_KEYLEN, b64test);
 810:	6c646e61 	stclvs	14, cr6, [r4], #-388	@ 0xfffffe7c
 814:	6f645f65 	svcvs	0x00645f65
    b64test[len] = '\0';
 818:	615f6e77 	cmpvs	pc, r7, ror lr	@ <UNPREDICTABLE>
 81c:	776f7272 			@ <UNDEFINED> instruction: 0x776f7272
 820:	635f5f00 	cmpvs	pc, #0, 30
 824:	655f646d 	ldrbvs	r6, [pc, #-1133]	@ 3bf <vector_table+0x3bf>
    printf("First shared key is %s\n", b64test);
 828:	5f636578 	svcpl	0x00636578
 82c:	74617473 	strbtvc	r7, [r1], #-1139	@ 0xfffffb8d
    sha256_init(&shactx);
 830:	67007375 	smlsdxvs	r0, r5, r3, r7
    sha256_update(&shactx, sharedsecret2, ECC_PUB_KEY_SIZE);
 834:	665f7465 	ldrbvs	r7, [pc], -r5, ror #8
 838:	74636e75 	strbtvc	r6, [r3], #-3701	@ 0xfffff18b
 83c:	5f6e6f69 	svcpl	0x006e6f69
	sha256_final(&shactx, keytest);
 840:	72646461 	rsbvc	r6, r4, #1627389952	@ 0x61000000
 844:	74616d00 	strbtvc	r6, [r1], #-3328	@ 0xfffff300
    len = encode_base64(keytest, AES_KEYLEN, b64test);
 848:	635f6863 	cmpvs	pc, #6488064	@ 0x630000
 84c:	746e756f 	strbtvc	r7, [lr], #-1391	@ 0xfffffa91
    b64test[len] = '\0';
 850:	65786500 	ldrbvs	r6, [r8, #-1280]!	@ 0xfffffb00
 854:	75615f63 	strbvc	r5, [r1, #-3939]!	@ 0xfffff09d
 858:	635f6f74 	cmpvs	pc, #116, 30	@ 0x1d0
    printf("Should be same as %s\n", b64test);
 85c:	0073646d 	rsbseq	r6, r3, sp, ror #8
 860:	72727563 	rsbsvc	r7, r2, #415236096	@ 0x18c00000
    printf("Switching fob AES key to new value. Try AES tests now.\n");
 864:	6d6f635f 	stclvs	3, cr6, [pc, #-380]!	@ 6f0 <encode64+0x4>
 868:	646e616d 	strbtvs	r6, [lr], #-365	@ 0xfffffe93
    AES_init_ctx(&ctx, ECDH_AESkey);
 86c:	7274705f 	rsbsvc	r7, r4, #95	@ 0x5f
 870:	646e6500 	strbtvs	r6, [lr], #-1280	@ 0xfffffb00
}
 874:	646e695f 	strbtvs	r6, [lr], #-2399	@ 0xfffff6a1
 878:	65007865 	strvs	r7, [r0, #-2149]	@ 0xfffff79b
 87c:	75636578 	strbvc	r6, [r3, #-1400]!	@ 0xfffffa88
 880:	61006574 	tstvs	r0, r4, ror r5
 884:	6d756772 	ldclvs	7, cr6, [r5, #-456]!	@ 0xfffffe38
 888:	5f746e65 	svcpl	0x00746e65
 88c:	657a6973 	ldrbvs	r6, [sl, #-2419]!	@ 0xfffff68d
 890:	655f5f00 	ldrbvs	r5, [pc, #-3840]	@ fffff998 <_STACK_TOP_+0xdfff799c>
 894:	006f6863 	rsbeq	r6, pc, r3, ror #16
 898:	5f676562 	svcpl	0x00676562
 89c:	65646e69 	strbvs	r6, [r4, #-3689]!	@ 0xfffff197
 8a0:	75610078 	strbvc	r0, [r1, #-120]!	@ 0xffffff88
int send_ping(int argc, char** argv) {
 8a4:	6c5f6f74 	mrrcvs	15, 7, r6, pc, cr4	@ <UNPREDICTABLE>
    printf("Pinging the car.\n");
 8a8:	0064616f 	rsbeq	r6, r4, pc, ror #2
    printf2("FOB_MESG PING\n");
 8ac:	65725f5f 	ldrbvs	r5, [r2, #-3935]!	@ 0xfffff0a1
 8b0:	635f6461 	cmpvs	pc, #1627389952	@ 0x61000000
}
 8b4:	32726168 	rsbscc	r6, r2, #104, 2
 8b8:	5f005f5f 	svcpl	0x00005f5f
 8bc:	78657465 	stmdavc	r5!, {r0, r2, r5, r6, sl, ip, sp, lr}^
int sha256_test(int argc, char** argv) {
 8c0:	625f0074 	subsvs	r0, pc, #116	@ 0x74
    printf("Starting sha256 test\n");
 8c4:	66007373 			@ <UNDEFINED> instruction: 0x66007373
 8c8:	5f6c6c75 	svcpl	0x006c6c75
    BYTE text1[] = {"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"};
 8cc:	73746573 	cmnvc	r4, #482344960	@ 0x1cc00000
 8d0:	73616200 	cmnvc	r1, #0, 4
 8d4:	5f343665 	svcpl	0x00343665
 8d8:	625f6f74 	subsvs	r6, pc, #116, 30	@ 0x1d0
 8dc:	72616e69 	rsbvc	r6, r1, #1680	@ 0x690
 8e0:	756f0079 	strbvc	r0, [pc, #-121]!	@ 86f <ecdh_test+0xd7>
 8e4:	74757074 	ldrbtvc	r7, [r5], #-116	@ 0xffffff8c
 8e8:	706e6900 	rsbvc	r6, lr, r0, lsl #18
 8ec:	6c5f7475 	cfldrdvs	mvd7, [pc], {117}	@ 0x75
    BYTE hash1[SHA256_BLOCK_SIZE] = {0x24,0x8d,0x6a,0x61,0xd2,0x06,0x38,0xb8,0xe5,0xc0,0x26,0x93,0x0c,0x3e,0x60,0x39,
 8f0:	74676e65 	strbtvc	r6, [r7], #-3685	@ 0xfffff19b
 8f4:	6e650068 	cdpvs	0, 6, cr0, cr5, cr8, {3}
 8f8:	65646f63 	strbvs	r6, [r4, #-3939]!	@ 0xfffff09d
 8fc:	7361625f 	cmnvc	r1, #-268435451	@ 0xf0000005
    sha256_init(&shactx);
 900:	5f343665 	svcpl	0x00343665
	sha256_update(&shactx, text1, strlen((char *)text1));
 904:	676e656c 	strbvs	r6, [lr, -ip, ror #10]!
 908:	6f006874 	svcvs	0x00006874
 90c:	75707475 	ldrbvc	r7, [r0, #-1141]!	@ 0xfffffb8b
 910:	656c5f74 	strbvs	r5, [ip, #-3956]!	@ 0xfffff08c
	sha256_final(&shactx, buf);
 914:	6874676e 	ldmdavs	r4!, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}^
 918:	706e6900 	rsbvc	r6, lr, r0, lsl #18
    len = encode_base64(hash1, SHA256_BLOCK_SIZE, b64_hash1);
 91c:	2f007475 	svccs	0x00007475
 920:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
 924:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
    b64_hash1[len] = '\0';
 928:	63652f66 	cmnvs	r5, #408	@ 0x198
    len = encode_base64(buf, SHA256_BLOCK_SIZE, b64_buf);
 92c:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
 930:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
 934:	732f7265 			@ <UNDEFINED> instruction: 0x732f7265
    b64_buf[len] = '\0';
 938:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
    printf("Base64 of SHA-256 test is %s\n", b64_buf);
 93c:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
 940:	7361622f 	cmnvc	r1, #-268435454	@ 0xf0000002
    printf("Should be %s\n", b64_hash1);
 944:	2f343665 	svccs	0x00343665
 948:	65736162 	ldrbvs	r6, [r3, #-354]!	@ 0xfffffe9e
}
 94c:	632e3436 			@ <UNDEFINED> instruction: 0x632e3436
 950:	6e696200 	cdpvs	2, 6, cr6, cr9, cr0, {0}
 954:	5f797261 	svcpl	0x00797261
 958:	625f6f74 	subsvs	r6, pc, #116, 30	@ 0x1d0
 95c:	36657361 	strbtcc	r7, [r5], -r1, ror #6
 960:	74730034 	ldrbtvc	r0, [r3], #-52	@ 0xffffffcc
void __attribute__((optimize("O0"), weak)) initial_setup(void) {
 964:	00747261 	rsbseq	r7, r4, r1, ror #4
 968:	6f636564 	svcvs	0x00636564
  char *src = &_etext, *dst = &_data;
 96c:	625f6564 	subsvs	r6, pc, #100, 10	@ 0x19000000
 970:	36657361 	strbtcc	r7, [r5], -r1, ror #6
  if (dst != src)
 974:	656c5f34 	strbvs	r5, [ip, #-3892]!	@ 0xfffff0cc
 978:	6874676e 	ldmdavs	r4!, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}^
    while (dst < &_edata) *(dst++) = *(src++);
 97c:	73616800 	cmnvc	r1, #0, 16
 980:	68730068 	ldmdavs	r3!, {r3, r5, r6}^
 984:	36353261 	ldrtcc	r3, [r5], -r1, ror #4
 988:	6172745f 	cmnvs	r2, pc, asr r4
 98c:	6f66736e 	svcvs	0x0066736e
 990:	2f006d72 	svccs	0x00006d72
  for (dst = &_bss; dst < &_ebss; dst++) *dst = 0;
 994:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
 998:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
 99c:	63652f66 	cmnvs	r5, #408	@ 0x198
 9a0:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
 9a4:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
 9a8:	732f7265 			@ <UNDEFINED> instruction: 0x732f7265
 9ac:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
  platform_init();
 9b0:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
}
 9b4:	6168732f 	cmnvs	r8, pc, lsr #6
 9b8:	2f363532 	svccs	0x00363532
 9bc:	32616873 	rsbcc	r6, r1, #7536640	@ 0x730000
 9c0:	632e3635 			@ <UNDEFINED> instruction: 0x632e3635
 9c4:	675f5f00 	ldrbvs	r5, [pc, -r0, lsl #30]
 9c8:	5f63756e 	svcpl	0x0063756e
 9cc:	6c5f6176 	ldfvse	f6, [pc], {118}	@ 0x76
static void delete(void) {
 9d0:	00747369 	rsbseq	r7, r4, r9, ror #6
  __write_char__(BACK_SPACE);
 9d4:	7374756f 	cmnvc	r4, #465567744	@ 0x1bc00000
 9d8:	6c007274 	sfmvs	f7, 4, [r0], {116}	@ 0x74
  __write_char__(SPACE);
 9dc:	69646165 	stmdbvs	r4!, {r0, r2, r5, r6, r8, sp, lr}^
  __write_char__(BACK_SPACE);
 9e0:	7a5f676e 	bvc	17da7a0 <__ROM_SIZE__+0x179a7a0>
 9e4:	5f6f7265 	svcpl	0x006f7265
}
 9e8:	6f6e6769 	svcvs	0x006e6769
static void clear_prompt(int char_count) {
 9ec:	00646572 	rsbeq	r6, r4, r2, ror r5
  while (char_count) {
 9f0:	53524150 	cmppl	r2, #80, 2
    delete ();
 9f4:	4d465f45 	stclmi	15, cr5, [r6, #-276]	@ 0xfffffeec
  while (char_count) {
 9f8:	54535f54 	ldrbpl	r5, [r3], #-3924	@ 0xfffff0ac
}
 9fc:	65680052 	strbvs	r0, [r8, #-82]!	@ 0xffffffae
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
 a00:	62617478 	rsbvs	r7, r1, #120, 8	@ 0x78000000
    auto_load[i].command(0, NULL);
 a04:	6e00656c 	cfsh32vs	mvfx6, mvfx0, #60
 a08:	6c5f6d75 	mrrcvs	13, 7, r6, pc, cr5	@ <UNPREDICTABLE>
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
 a0c:	6c006e65 	stcvs	14, cr6, [r0], {101}	@ 0x65
 a10:	756f635f 	strbvc	r6, [pc, #-863]!	@ 6b9 <aes_test+0x8d>
 a14:	5f00746e 	svcpl	0x0000746e
 a18:	5f61765f 	svcpl	0x0061765f
 a1c:	7473696c 	ldrbtvc	r6, [r3], #-2412	@ 0xfffff694
}
 a20:	69727000 	ldmdbvs	r2!, {ip, sp, lr}^
static int show_history(int argc, char **argv) {
 a24:	5f66746e 	svcpl	0x0066746e
  uint32_t end_index = total_num_commands-1;
 a28:	74617473 	strbtvc	r7, [r1], #-1139	@ 0xfffffb8d
  if (total_num_commands > NUM_HISTORY_ENTRIES) {
 a2c:	74730065 	ldrbtvc	r0, [r3], #-101	@ 0xffffff9b
 a30:	5f747261 	svcpl	0x00747261
    beg_index = total_num_commands - NUM_HISTORY_ENTRIES;
 a34:	00746962 	rsbseq	r6, r4, r2, ror #18
 a38:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 984 <initial_setup+0x20>
  uint32_t beg_index = 0;
 a3c:	63652f65 	cmnvs	r5, #404	@ 0x194
    printf("%s\n", cmd_history[index % NUM_HISTORY_ENTRIES]);
 a40:	652f6674 	strvs	r6, [pc, #-1652]!	@ 3d4 <car_mesg+0x14>
 a44:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
 a48:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
 a4c:	2f72656e 	svccs	0x0072656e
  for (uint32_t index = beg_index; index <= end_index; ++index) {
 a50:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
}
 a54:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
 a58:	72702f62 	rsbsvc	r2, r0, #392	@ 0x188
 a5c:	66746e69 	ldrbtvs	r6, [r4], -r9, ror #28
 a60:	6972702f 	ldmdbvs	r2!, {r0, r1, r2, r3, r5, ip, sp, lr}^
int cmd_exec_status(int argc, char **argv) {
 a64:	2e66746e 	cdpcs	4, 6, cr7, cr6, cr14, {3}
  printf("%d\n", __cmd_exec_status);
 a68:	61760063 	cmnvs	r6, r3, rrx
 a6c:	0065756c 	rsbeq	r7, r5, ip, ror #10
 a70:	6e697270 	mcrvs	2, 3, r7, cr9, cr0, {3}
}
 a74:	6e5f6674 	mrcvs	6, 2, r6, cr15, cr4, {3}
 a78:	65626d75 	strbvs	r6, [r2, #-3445]!	@ 0xfffff28b
 a7c:	43007372 	movwmi	r7, #882	@ 0x372
static int build_info(int argc, char **argv) {
 a80:	4b434548 	blmi	10d1fa8 <__ROM_SIZE__+0x1091fa8>
  printf("Build: [" SHELL_VERSION ":" USER_REPO_VERSION "] - [" BUILD_USER
 a84:	0048435f 	subeq	r4, r8, pc, asr r3
}
 a88:	73677261 	cmnvc	r7, #268435462	@ 0x10000006
 a8c:	615f5f00 	cmpvs	pc, r0, lsl #30
static void execute(int argc, char **argv) {
 a90:	72700070 	rsbsvc	r0, r0, #112	@ 0x70
 a94:	66746e69 	ldrbtvs	r6, [r4], -r9, ror #28
  for (int i = 0; table[i].command_name != NULL; i++) {
 a98:	74735f32 	ldrbtvc	r5, [r3], #-3890	@ 0xfffff0ce
 a9c:	00657461 	rsbeq	r7, r5, r1, ror #8
 aa0:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 9ec <clear_prompt>
 aa4:	63652f65 	cmnvs	r5, #404	@ 0x194
 aa8:	652f6674 	strvs	r6, [pc, #-1652]!	@ 43c <car_mesg+0x7c>
    if (strcmp(argv[0], table[i].command_name) == 0) {
 aac:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
 ab0:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
      __cmd_exec_status = table[i].command(argc, &argv[0]);
 ab4:	2f72656e 	svccs	0x0072656e
 ab8:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
 abc:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
 ac0:	72702f62 	rsbsvc	r2, r0, #392	@ 0x188
 ac4:	66746e69 	ldrbtvs	r6, [r4], -r9, ror #28
    printf("\"%s\": command not found. Use \"help\" to list all command.\n",
 ac8:	6972702f 	ldmdbvs	r2!, {r0, r1, r2, r3, r5, ip, sp, lr}^
 acc:	3266746e 	rsbcc	r7, r6, #1845493760	@ 0x6e000000
    __cmd_exec_status = -1;
 ad0:	7000632e 	andvc	r6, r0, lr, lsr #6
 ad4:	746e6972 	strbtvc	r6, [lr], #-2418	@ 0xfffff68e
 ad8:	6e5f3266 	cdpvs	2, 5, cr3, cr15, cr6, {3}
}
 adc:	65626d75 	strbvs	r6, [r2, #-3445]!	@ 0xfffff28b
 ae0:	68007372 	stmdavs	r0, {r1, r4, r5, r6, r8, r9, ip, sp, lr}
 ae4:	61747865 	cmnvs	r4, r5, ror #16
 ae8:	32656c62 	rsbcc	r6, r5, #25088	@ 0x6200
int help(int argc, char **argv) {
 aec:	74756f00 	ldrbtvc	r6, [r5], #-3840	@ 0xfffff100
  if (argc > 1 && (strcmp(argv[1], "-l")==0)) {
 af0:	32727473 	rsbscc	r7, r2, #1929379840	@ 0x73000000
 af4:	61765f00 	cmnvs	r6, r0, lsl #30
 af8:	32337772 	eorscc	r7, r3, #29884416	@ 0x1c80000
 afc:	7469625f 	strbtvc	r6, [r9], #-607	@ 0xfffffda1
    printf("use: help -l for list only.\n\n");
 b00:	6f682f00 	svcvs	0x00682f00
  bool verbose = true;
 b04:	652f656d 	strvs	r6, [pc, #-1389]!	@ 59f <uart2_init+0x23>
    verbose = false;
 b08:	2f667463 	svccs	0x00667463
    printf("\n");
 b0c:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    i++;
 b10:	6172742d 	cmnvs	r2, sp, lsr #8
  while (table[i].command_name != NULL) {
 b14:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
 b18:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
 b1c:	6c2f6c6c 	stcvs	12, cr6, [pc], #-432	@ 974 <initial_setup+0x10>
    printf(table[i].command_name);
 b20:	752f6269 	strvc	r6, [pc, #-617]!	@ 8bf <send_ping+0x1b>
    if (verbose) {
 b24:	736c6974 	cmnvc	ip, #116, 18	@ 0x1d0000
      printf("\n\t");
 b28:	6974752f 	ldmdbvs	r4!, {r0, r1, r2, r3, r5, r8, sl, ip, sp, lr}^
      printf(table[i].command_help);
 b2c:	632e736c 			@ <UNDEFINED> instruction: 0x632e736c
 b30:	6e697500 	cdpvs	5, 6, cr7, cr9, cr0, {0}
 b34:	72747074 	rsbsvc	r7, r4, #116	@ 0x74
    verbose = false;
 b38:	5f00745f 	svcpl	0x0000745f
}
 b3c:	72726176 	rsbsvc	r6, r2, #-2147483619	@ 0x8000001d
 b40:	5f646165 	svcpl	0x00646165
 b44:	006d656d 	rsbeq	r6, sp, sp, ror #10
 b48:	7261765f 	rsbvc	r7, r1, #99614720	@ 0x5f00000
 b4c:	00323377 	eorseq	r3, r2, r7, ror r3
 b50:	5f746962 	svcpl	0x00746962
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
 b54:	00636f6c 	rsbeq	r6, r3, ip, ror #30
static void add_command_to_history(const char *cmd_str) {
 b58:	5f746962 	svcpl	0x00746962
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
 b5c:	006c6176 	rsbeq	r6, ip, r6, ror r1
 b60:	67617375 			@ <UNDEFINED> instruction: 0x67617375
  int index = total_num_commands % NUM_HISTORY_ENTRIES;
 b64:	765f0065 	ldrbvc	r0, [pc], -r5, rrx
 b68:	33727261 	cmncc	r2, #268435462	@ 0x10000006
 b6c:	765f0032 			@ <UNDEFINED> instruction: 0x765f0032
 b70:	33727261 	cmncc	r2, #268435462	@ 0x10000006
  memcpy(&cmd_history[index], cmd_str, LINE_BUFF_SIZE);
 b74:	69625f32 	stmdbvs	r2!, {r1, r4, r5, r8, r9, sl, fp, ip, lr}^
 b78:	74610074 	strbtvc	r0, [r1], #-116	@ 0xffffff8c
 b7c:	6100686f 	tstvs	r0, pc, ror #16
 b80:	00696f74 	rsbeq	r6, r9, r4, ror pc
  total_num_commands++;
 b84:	5f534541 	svcpl	0x00534541
  curr_command_ptr = total_num_commands;
 b88:	74696e69 	strbtvc	r6, [r9], #-3689	@ 0xfffff197
 b8c:	7874635f 	ldmdavc	r4!, {r0, r1, r2, r3, r4, r6, r8, r9, sp, lr}^
 b90:	0076695f 	rsbseq	r6, r6, pc, asr r9
 b94:	6d697478 	cfstrdvs	mvd7, [r9, #-480]!	@ 0xfffffe20
 b98:	65740065 	ldrbvs	r0, [r4, #-101]!	@ 0xffffff9b
static int parse_line(char **argv, char *line_buff, int argument_size) {
 b9c:	0061706d 	rsbeq	r7, r1, sp, rrx
 ba0:	706d6574 	rsbvc	r6, sp, r4, ror r5
  int length = strlen(line_buff);
 ba4:	6f747300 	svcvs	0x00747300
 ba8:	654e6572 	strbvs	r6, [lr, #-1394]	@ 0xfffffa8e
  int argc = 0;
 bac:	76497478 			@ <UNDEFINED> instruction: 0x76497478
         pos++)
 bb0:	62737200 	rsbsvs	r7, r3, #0, 4
    for (; line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
 bb4:	4100786f 	tstmi	r0, pc, ror #16
 bb8:	435f5345 	cmpmi	pc, #335544321	@ 0x14000001
 bbc:	655f4342 	ldrbvs	r4, [pc, #-834]	@ 882 <ecdh_test+0xea>
 bc0:	7972636e 	ldmdbvc	r2!, {r1, r2, r3, r5, r6, r8, r9, sp, lr}^
    if (line_buff[pos] == '\t' || line_buff[pos] == SPACE)
 bc4:	625f7470 	subsvs	r7, pc, #112, 8	@ 0x70000000
 bc8:	65666675 	strbvs	r6, [r6, #-1653]!	@ 0xfffff98b
      line_buff[pos] = END_OF_LINE;
 bcc:	682f0072 	stmdavs	pc!, {r1, r4, r5, r6}	@ <UNPREDICTABLE>
  while (pos <= length) {
 bd0:	2f656d6f 	svccs	0x00656d6f
    if (line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
 bd4:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
 bd8:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
 bdc:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
 be0:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
      argv[argc++] = &line_buff[pos];
 be4:	68732f72 	ldmdavs	r3!, {r1, r4, r5, r6, r8, r9, sl, fp, sp}^
 be8:	2f6c6c65 	svccs	0x006c6c65
}
 bec:	2f62696c 	svccs	0x0062696c
static int prefix_match(char *sub, int len, const char *str) {
 bf0:	796e6974 	stmdbvc	lr!, {r2, r4, r5, r6, r8, fp, sp, lr}^
 bf4:	7365612d 	cmnvc	r5, #1073741835	@ 0x4000000b
  if (sub == NULL || str == NULL || len <= 0 || len > strlen(str)) {
 bf8:	7365612f 	cmnvc	r5, #-1073741813	@ 0xc000000b
 bfc:	4900632e 	stmdbmi	r0, {r1, r2, r3, r5, r8, r9, sp, lr}
 c00:	6943766e 	stmdbvs	r3, {r1, r2, r3, r5, r6, r9, sl, ip, sp, lr}^
 c04:	72656870 	rsbvc	r6, r5, #112, 16	@ 0x700000
  for (int i = 0; i<len; ++i) {
 c08:	74387500 	ldrtvc	r7, [r8], #-1280	@ 0xfffffb00
 c0c:	7300706d 	movwvc	r7, #109	@ 0x6d
    if (sub[i] != str[i]) {
 c10:	65746174 	ldrbvs	r6, [r4, #-372]!	@ 0xfffffe8c
 c14:	4100745f 	tstmi	r0, pc, asr r4
  for (int i = 0; i<len; ++i) {
 c18:	435f5345 	cmpmi	pc, #335544321	@ 0x14000001
}
 c1c:	645f4342 	ldrbvs	r4, [pc], #-834	@ c24 <prefix_match+0x36>
  return TRUE;
 c20:	79726365 	ldmdbvc	r2!, {r0, r2, r5, r6, r8, r9, sp, lr}^
      return FALSE;
 c24:	625f7470 	subsvs	r7, pc, #112, 8	@ 0x70000000
}
 c28:	65666675 	strbvs	r6, [r6, #-1653]!	@ 0xfffff98b
static void handle_up_arrow(char *cmd_buff, int *char_count) {
 c2c:	6e490072 	mcrvs	0, 2, r0, cr9, cr2, {3}
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
 c30:	78694d76 	stmdavc	r9!, {r1, r2, r4, r5, r6, r8, sl, fp, lr}^
 c34:	756c6f43 	strbvc	r6, [ip, #-3907]!	@ 0xfffff0bd
 c38:	00736e6d 	rsbseq	r6, r3, sp, ror #28
 c3c:	52646441 	rsbpl	r6, r4, #1090519040	@ 0x41000000
      curr_command_ptr == 0) {
 c40:	646e756f 	strbtvs	r7, [lr], #-1391	@ 0xfffffa91
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
 c44:	0079654b 	rsbseq	r6, r9, fp, asr #10
    printf("%s", cmd_buff);
 c48:	5f534541 	svcpl	0x00534541
 c4c:	5f525443 	svcpl	0x00525443
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
 c50:	79726378 	ldmdbvc	r2!, {r3, r4, r5, r6, r8, r9, sp, lr}^
 c54:	625f7470 	subsvs	r7, pc, #112, 8	@ 0x70000000
  curr_command_ptr--;
 c58:	65666675 	strbvs	r6, [r6, #-1653]!	@ 0xfffff98b
 c5c:	6f720072 	svcvs	0x00720072
 c60:	00646e75 	rsbeq	r6, r4, r5, ror lr
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
 c64:	6e6f6352 	mcrvs	3, 3, r6, cr15, cr2, {2}
 c68:	53454100 	movtpl	r4, #20736	@ 0x5100
 c6c:	7874635f 	ldmdavc	r4!, {r0, r1, r2, r3, r4, r6, r8, r9, sp, lr}^
 c70:	7465735f 	strbtvc	r7, [r5], #-863	@ 0xfffffca1
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
 c74:	0076695f 	rsbseq	r6, r6, pc, asr r9
 c78:	53766e49 	cmnpl	r6, #1168	@ 0x490
 c7c:	74666968 	strbtvc	r6, [r6], #-2408	@ 0xfffff698
  *char_count = strlen(cmd_buff);
 c80:	73776f52 	cmnvc	r7, #328	@ 0x148
 c84:	79654b00 	stmdbvc	r5!, {r8, r9, fp, lr}^
  printf("%s", cmd_buff);
 c88:	61707845 	cmnvs	r0, r5, asr #16
 c8c:	6f69736e 	svcvs	0x0069736e
 c90:	6e49006e 	cdpvs	0, 4, cr0, cr9, cr14, {3}
 c94:	62755376 	rsbsvs	r5, r5, #-671088639	@ 0xd8000001
 c98:	65747942 	ldrbvs	r7, [r4, #-2370]!	@ 0xfffff6be
static void handle_down_arrow(char *cmd_buff, int *char_count) {
 c9c:	6f580073 	svcvs	0x00580073
 ca0:	74695772 	strbtvc	r5, [r9], #-1906	@ 0xfffff88e
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
 ca4:	00764968 	rsbseq	r4, r6, r8, ror #18
 ca8:	78706d74 	ldmdavc	r0!, {r2, r4, r5, r6, r8, sl, fp, sp, lr}^
  *char_count = 0;
 cac:	706d7400 	rsbvc	r7, sp, r0, lsl #8
  if (curr_command_ptr == total_num_commands) return;
 cb0:	66670079 			@ <UNDEFINED> instruction: 0x66670079
 cb4:	696f7032 	stmdbvs	pc!, {r1, r4, r5, ip, sp, lr}^	@ <UNPREDICTABLE>
 cb8:	735f746e 	cmpvc	pc, #1845493760	@ 0x6e000000
  curr_command_ptr++;
 cbc:	7a5f7465 	bvc	17dde58 <__ROM_SIZE__+0x179de58>
 cc0:	006f7265 	rsbeq	r7, pc, r5, ror #4
 cc4:	796c6f70 	stmdbvc	ip!, {r4, r5, r6, r8, r9, sl, fp, sp, lr}^
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
 cc8:	696d6f6e 	stmdbvs	sp!, {r1, r2, r3, r5, r6, r8, r9, sl, fp, sp, lr}^
 ccc:	6e006c61 	cdpvs	12, 0, cr6, cr0, cr1, {3}
 cd0:	64726f77 	ldrbtvs	r6, [r2], #-3959	@ 0xfffff089
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
 cd4:	66670073 			@ <UNDEFINED> instruction: 0x66670073
 cd8:	656c6532 	strbvs	r6, [ip, #-1330]!	@ 0xffffface
 cdc:	00745f6d 	rsbseq	r5, r4, sp, ror #30
 ce0:	76746962 	ldrbtvc	r6, [r4], -r2, ror #18
  *char_count = strlen(cmd_buff);
 ce4:	655f6365 	ldrbvs	r6, [pc, #-869]	@ 987 <initial_setup+0x23>
 ce8:	6c617571 	cfstr64vs	mvdx7, [r1], #-452	@ 0xfffffe3c
  printf("%s", cmd_buff);
 cec:	32666700 	rsbcc	r6, r6, #0, 14
 cf0:	6e696f70 	mcrvs	15, 3, r6, cr9, cr0, {3}
}
 cf4:	6f645f74 	svcvs	0x00645f74
 cf8:	656c6275 	strbvs	r6, [ip, #-629]!	@ 0xfffffd8b
void set_read_char(int (*func)(void)) { __read_char__ = func; }
 cfc:	32666700 	rsbcc	r6, r6, #0, 14
 d00:	6c656966 			@ <UNDEFINED> instruction: 0x6c656966
 d04:	6e695f64 	cdpvs	15, 6, cr5, cr9, cr4, {3}
void set_read_char2(int (*func)(void)) { __read_char2__ = func; }
 d08:	61620063 	cmnvs	r2, r3, rrx
 d0c:	6f5f6573 	svcvs	0x005f6573
 d10:	72656472 	rsbvc	r6, r5, #1912602624	@ 0x72000000
void set_write_char(void (*func)(char)) { __write_char__ = func; }
 d14:	74696200 	strbtvc	r6, [r9], #-512	@ 0xfffffe00
 d18:	5f636576 	svcpl	0x00636576
 d1c:	79706f63 	ldmdbvc	r0!, {r0, r1, r5, r6, r8, r9, sl, fp, sp, lr}^
void set_write_char2(void (*func)(char)) { __write_char2__ = func; }
 d20:	74696200 	strbtvc	r6, [r9], #-512	@ 0xfffffe00
 d24:	5f636576 	svcpl	0x00636576
 d28:	7a5f7369 	bvc	17ddad4 <__ROM_SIZE__+0x179dad4>
}
 d2c:	006f7265 	rsbeq	r7, pc, r5, ror #4
}
 d30:	66326667 	ldrtvs	r6, [r2], -r7, ror #12
  if (cmd_buff == NULL || char_count <= 0) {
 d34:	646c6569 	strbtvs	r6, [ip], #-1385	@ 0xfffffa97
static void handle_tab(char *cmd_buff, int *char_count) {
 d38:	766e695f 			@ <UNDEFINED> instruction: 0x766e695f
 d3c:	32666700 	rsbcc	r6, r6, #0, 14
  int last_match = -1;
 d40:	6e696f70 	mcrvs	15, 3, r6, cr9, cr0, {3}
  int match_count = 0;
 d44:	6e6f5f74 	mcrvs	15, 3, r5, cr15, cr4, {3}
  int i = 0;
 d48:	7275635f 	rsbsvc	r6, r5, #2080374785	@ 0x7c000001
    i++;
 d4c:	6e006576 	cfrshl64vs	mvdx0, mvdx6, r6
  while (table[i].command_name != NULL) { //loop over all commands
 d50:	73746962 	cmnvc	r4, #1605632	@ 0x188000
 d54:	74696200 	strbtvc	r6, [r9], #-512	@ 0xfffffe00
 d58:	5f636576 	svcpl	0x00636576
    if (prefix_match(cmd_buff, *char_count, table[i].command_name)) {
 d5c:	5f746567 	svcpl	0x00746567
 d60:	00746962 	rsbseq	r6, r4, r2, ror #18
 d64:	76746962 	ldrbtvc	r6, [r4], -r2, ror #18
      match_count++;
 d68:	6c5f6365 	mrrcvs	3, 6, r6, pc, cr5	@ <UNPREDICTABLE>
      printf("\n%s", table[i].command_name);
 d6c:	66696873 			@ <UNDEFINED> instruction: 0x66696873
 d70:	746f0074 	strbtvc	r0, [pc], #-116	@ d78 <handle_tab+0x46>
      last_match = i;
 d74:	73726568 	cmnvc	r2, #104, 10	@ 0x1a000000
  if (match_count == 1) {
 d78:	6275705f 	rsbsvs	r7, r5, #95	@ 0x5f
 d7c:	74696200 	strbtvc	r6, [r9], #-512	@ 0xfffffe00
  if (match_count) {
 d80:	5f636576 	svcpl	0x00636576
}
 d84:	72676564 	rsbvc	r6, r7, #100, 10	@ 0x19000000
    memcpy(cmd_buff, table[last_match].command_name, LINE_BUFF_SIZE);
 d88:	70006565 	andvc	r6, r0, r5, ror #10
 d8c:	696c6275 	stmdbvs	ip!, {r0, r2, r4, r5, r6, r9, sp, lr}^
 d90:	656b5f63 	strbvs	r5, [fp, #-3939]!	@ 0xfffff09d
 d94:	72700079 	rsbsvc	r0, r0, #121	@ 0x79
    *char_count = strlen(cmd_buff);
 d98:	74617669 	strbtvc	r7, [r1], #-1641	@ 0xfffff997
 d9c:	656b5f65 	strbvs	r5, [fp, #-3941]!	@ 0xfffff09b
 da0:	66670079 			@ <UNDEFINED> instruction: 0x66670079
    printf("\n");
 da4:	65696632 	strbvs	r6, [r9, #-1586]!	@ 0xfffff9ce
 da8:	695f646c 	ldmdbvs	pc, {r2, r3, r5, r6, sl, sp, lr}^	@ <UNPREDICTABLE>
    prepend_prompt();
 dac:	6e6f5f73 	mcrvs	15, 3, r5, cr15, cr3, {3}
    printf(PROMPT);
 db0:	66670065 	strbtvs	r0, [r7], -r5, rrx
 db4:	65696632 	strbvs	r6, [r9, #-1586]!	@ 0xfffff9ce
    printf("%s", cmd_buff);
 db8:	615f646c 	cmpvs	pc, ip, ror #8
 dbc:	67006464 	strvs	r6, [r0, -r4, ror #8]
 dc0:	6f703266 	svcvs	0x00703266
 dc4:	5f746e69 	svcpl	0x00746e69
 dc8:	7a5f7369 	bvc	17ddb74 <__ROM_SIZE__+0x179db74>
 dcc:	006f7265 	rsbeq	r7, pc, r5, ror #4
 dd0:	76746962 	ldrbtvc	r6, [r4], -r2, ror #18
__attribute__((weak)) int active_prompt() { return TRUE; }
 dd4:	735f6365 	cmpvc	pc, #-1811939327	@ 0x94000001
static void shell(void) {
 dd8:	00706177 	rsbseq	r6, r0, r7, ror r1
  int count = 0;
 ddc:	76746962 	ldrbtvc	r6, [r4], -r2, ror #18
  for (int i = 0; i < LINE_BUFF_SIZE; i++) line_buff[i] = 0;
 de0:	745f6365 	ldrbvc	r6, [pc], #-869	@ de8 <shell+0x10>
 de4:	74696200 	strbtvc	r6, [r9], #-512	@ 0xfffffe00
 de8:	5f636576 	svcpl	0x00636576
 dec:	5f746573 	svcpl	0x00746573
 df0:	6f72657a 	svcvs	0x0072657a
  for (int i = 0; i < MAX_ARG_COUNT; i++) argv[i] = NULL;
 df4:	32666700 	rsbcc	r6, r6, #0, 14
 df8:	6c656966 			@ <UNDEFINED> instruction: 0x6c656966
 dfc:	756d5f64 	strbvc	r5, [sp, #-3940]!	@ 0xfffff09c
 e00:	6667006c 	strbtvs	r0, [r7], -ip, rrx
 e04:	696f7032 	stmdbvs	pc!, {r1, r4, r5, ip, sp, lr}^	@ <UNPREDICTABLE>
  prepend_prompt();
 e08:	615f746e 	cmpvs	pc, lr, ror #8
  printf(PROMPT);
 e0c:	62006464 	andvs	r6, r0, #100, 8	@ 0x64000000
  int special_key = 0;
 e10:	5f657361 	svcpl	0x00657361
        special_key = 1;
 e14:	61620078 	smcvs	8200	@ 0x2008
    if (s == -1) { s = __read_char2__();}
 e18:	795f6573 	ldmdbvc	pc, {r0, r1, r4, r5, r6, r8, sl, sp, lr}^	@ <UNPREDICTABLE>
 e1c:	32666700 	rsbcc	r6, r6, #0, 14
    if (s != -1) {
 e20:	6c656966 			@ <UNDEFINED> instruction: 0x6c656966
 e24:	65735f64 	ldrbvs	r5, [r3, #-3940]!	@ 0xfffff09c
      loop();
 e28:	6e6f5f74 	mcrvs	15, 3, r5, cr15, cr4, {3}
        line_buff[count] = END_OF_LINE;
 e2c:	66670065 	strbtvs	r0, [r7], -r5, rrx
 e30:	696f7032 	stmdbvs	pc!, {r1, r4, r5, ip, sp, lr}^	@ <UNPREDICTABLE>
 e34:	635f746e 	cmpvs	pc, #1845493760	@ 0x6e000000
 e38:	0079706f 	rsbseq	r7, r9, pc, rrx
        __write_char__(NEW_LINE);
 e3c:	66656f63 	strbtvs	r6, [r5], -r3, ror #30
 e40:	00625f66 	rsbeq	r5, r2, r6, ror #30
  add_command_to_history(line_buff);
 e44:	70326667 	eorsvc	r6, r2, r7, ror #12
  argc = parse_line(argv, line_buff, MAX_ARG_COUNT);
 e48:	746e696f 	strbtvc	r6, [lr], #-2415	@ 0xfffff691
 e4c:	6c756d5f 	ldclvs	13, cr6, [r5], #-380	@ 0xfffffe84
 e50:	32337500 	eorscc	r7, r3, #0, 10
  if (argc > 0) execute(argc, argv);
 e54:	6b73616d 	blvs	1cd9410 <__ROM_SIZE__+0x1c99410>
}
 e58:	6f682f00 	svcvs	0x00682f00
        if (!__echo) {
 e5c:	652f656d 	strvs	r6, [pc, #-1389]!	@ 8f7 <sha256_test+0x37>
 e60:	2f667463 	svccs	0x00667463
        if (count == 0) continue;
 e64:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
        count--;
 e68:	6172742d 	cmnvs	r2, sp, lsr #8
        line_buff[count] = END_OF_LINE;
 e6c:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
 e70:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
 e74:	6c2f6c6c 	stcvs	12, cr6, [pc], #-432	@ ccc <handle_down_arrow+0x30>
        delete ();
 e78:	742f6269 	strtvc	r6, [pc], #-617	@ e80 <shell+0xa8>
      if (__echo) {
 e7c:	2d796e69 	ldclcs	14, cr6, [r9, #-420]!	@ 0xfffffe5c
        __write_char__(c);
 e80:	68646365 	stmdavs	r4!, {r0, r2, r5, r6, r8, r9, sp, lr}^
 e84:	6463652f 	strbtvs	r6, [r3], #-1327	@ 0xfffffad1
    if (!active_prompt()) {
 e88:	00632e68 	rsbeq	r2, r3, r8, ror #28
 e8c:	76746962 	ldrbtvc	r6, [r4], -r2, ror #18
    s = __read_char__();
 e90:	635f6365 	cmpvs	pc, #-1811939327	@ 0x94000001
 e94:	625f726c 	subsvs	r7, pc, #108, 4	@ 0xc0000006
    if (s == -1) { s = __read_char2__();}
 e98:	2f007469 	svccs	0x00007469
 e9c:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
      if (c == CARRIAGE_RETURN || c == NEW_LINE) {
 ea0:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
 ea4:	63652f66 	cmnvs	r5, #408	@ 0x198
      if (c == DELETE || c == BACK_SPACE) {
 ea8:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
 eac:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
      } else if (c == ESCAPE) {
 eb0:	732f7265 			@ <UNDEFINED> instruction: 0x732f7265
      } else if (c == SQUARE_BRACKET_OPEN && special_key == 1) {
 eb4:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
      } else if ((c == 'C' || c == 'D') && special_key != 0) {
 eb8:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
 ebc:	6932612f 	ldmdbvs	r2!, {r0, r1, r2, r3, r5, r8, sp, lr}
 ec0:	6932612f 	ldmdbvs	r2!, {r0, r1, r2, r3, r5, r8, sp, lr}
      } else if ((c == 'A' || c == 'B') && special_key == 2) {
 ec4:	7200632e 	andvc	r6, r0, #-1207959552	@ 0xb8000000
 ec8:	695f6e67 	ldmdbvs	pc, {r0, r1, r2, r5, r6, r9, sl, fp, sp, lr}^	@ <UNPREDICTABLE>
      else if (c == TAB) {
 ecc:	5f6f666e 	svcpl	0x006f666e
        line_buff[count] = c;
 ed0:	67720074 			@ <UNDEFINED> instruction: 0x67720074
 ed4:	6e695f6e 	cdpvs	15, 6, cr5, cr9, cr14, {3}
 ed8:	6f006f66 	svcvs	0x00006f66
        count++;
 edc:	625f7475 	subsvs	r7, pc, #1962934272	@ 0x75000000
 ee0:	725f6675 	subsvc	r6, pc, #122683392	@ 0x7500000
          delete ();
 ee4:	73006e67 	movwvc	r6, #3687	@ 0xe67
          delete ();
 ee8:	63656c65 	cmnvs	r5, #25856	@ 0x6500
      } else if (c == SQUARE_BRACKET_OPEN && special_key == 1) {
 eec:	5f646574 	svcpl	0x00646574
        special_key = 2;
 ef0:	65646f6d 	strbvs	r6, [r4, #-3949]!	@ 0xfffff093
      } else if ((c == 'C' || c == 'D') && special_key != 0) {
 ef4:	6d656d00 	stclvs	13, cr6, [r5, #-0]
        special_key = 0;
 ef8:	5f676f6c 	svcpl	0x00676f6c
      } else if ((c == 'A' || c == 'B') && special_key == 2) {
 efc:	63747570 	cmnvs	r4, #112, 10	@ 0x1c000000
        if (!__echo) {
 f00:	72756300 	rsbsvc	r6, r5, #0, 6
 f04:	6e695f72 	mcrvs	15, 3, r5, cr9, cr2, {3}
          clear_prompt(count + 4);
 f08:	00786564 	rsbseq	r6, r8, r4, ror #10
 f0c:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ e58 <shell+0x80>
        if (c == 'A') {
 f10:	63652f65 	cmnvs	r5, #404	@ 0x194
          handle_down_arrow(line_buff, &count);
 f14:	652f6674 	strvs	r6, [pc, #-1652]!	@ 8a8 <send_ping+0x4>
 f18:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
        continue;
 f1c:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
          clear_prompt(count);
 f20:	2f72656e 	svccs	0x0072656e
 f24:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
          handle_up_arrow(line_buff, &count);
 f28:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
 f2c:	656d2f62 	strbvs	r2, [sp, #-3938]!	@ 0xfffff09e
        handle_tab(line_buff, &count);
 f30:	676f6c6d 	strbvs	r6, [pc, -sp, ror #24]!
 f34:	6d656d2f 	stclvs	13, cr6, [r5, #-188]!	@ 0xffffff44
        continue;
 f38:	2e676f6c 	cdpcs	15, 6, cr6, cr7, cr12, {3}
  if (argc > 0) execute(argc, argv);
 f3c:	6e690063 	cdpvs	0, 6, cr0, cr9, cr3, {3}
}
 f40:	75625f70 	strbvc	r5, [r2, #-3952]!	@ 0xfffff090
 f44:	67725f66 	ldrbvs	r5, [r2, -r6, ror #30]!
 f48:	4f4e006e 	svcmi	0x004e006e
 f4c:	6d00454e 	cfstr32vs	mvfx4, [r0, #-312]	@ 0xfffffec8
void prompt() {
 f50:	6f6c6d65 	svcvs	0x006c6d65
  initial_setup();
 f54:	6e695f67 	cdpvs	15, 6, cr5, cr9, cr7, {3}
  exec_auto_cmds();
 f58:	6d007469 	cfstrsvs	mvf7, [r0, #-420]	@ 0xfffffe5c
  setup();
 f5c:	6f6c6d65 	svcvs	0x006c6d65
  decode_base64(AES_key_b64, 44, AES_key);
 f60:	65675f67 	strbvs	r5, [r7, #-3943]!	@ 0xfffff099
 f64:	49006374 	stmdbmi	r0, {r2, r4, r5, r6, r8, r9, sp, lr}
 f68:	4f5f504e 	svcmi	0x005f504e
 f6c:	6d005455 	cfstrsvs	mvf5, [r0, #-340]	@ 0xfffffeac
  AES_init_ctx(&ctx, AES_key);
 f70:	5f65646f 	svcpl	0x0065646f
 f74:	65640074 	strbvs	r0, [r4, #-116]!	@ 0xffffff8c
    shell();
 f78:	73007473 	movwvc	r7, #1139	@ 0x473
  while (TRUE) {
 f7c:	70637274 	rsbvc	r7, r3, r4, ror r2
 f80:	74730079 	ldrbtvc	r0, [r3], #-121	@ 0xffffff87
 f84:	64003172 	strvs	r3, [r0], #-370	@ 0xfffffe8e
int exec(char *cmd_str) {
 f88:	5f747365 	svcpl	0x00747365
 f8c:	72616863 	rsbvc	r6, r1, #6488064	@ 0x630000
  argc = parse_line(argv, cmd_str, MAX_ARG_COUNT);
 f90:	63727300 	cmnvs	r2, #0, 6
 f94:	6168635f 	cmnvs	r8, pc, asr r3
  if (argc > 0) execute(argc, argv);
 f98:	682f0072 	stmdavs	pc!, {r1, r4, r5, r6}	@ <UNPREDICTABLE>
  return __cmd_exec_status;
 f9c:	2f656d6f 	svccs	0x00656d6f
}
 fa0:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
 fa4:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
  if (argc > 0) execute(argc, argv);
 fa8:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
 fac:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
 fb0:	68732f72 	ldmdavs	r3!, {r1, r4, r5, r6, r8, r9, sl, fp, sp}^
cmd get_function_addr(char *cmd_str) {
 fb4:	2f6c6c65 	svccs	0x006c6c65
  for (int i = 0; table[i].command_name != NULL; i++) {
 fb8:	2f62696c 	svccs	0x0062696c
 fbc:	69727473 	ldmdbvs	r2!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
 fc0:	732f676e 			@ <UNDEFINED> instruction: 0x732f676e
 fc4:	6e697274 	mcrvs	2, 3, r7, cr9, cr4, {3}
 fc8:	00632e67 	rsbeq	r2, r3, r7, ror #28

Disassembly of section .comment:

00000000 <.comment>:
   0:	3a434347 	bcc	10d0d24 <__ROM_SIZE__+0x1090d24>
   4:	72412820 	subvc	r2, r1, #32, 16	@ 0x200000
   8:	4e47206d 	cdpmi	0, 4, cr2, cr7, cr13, {3}
   c:	6f542055 	svcvs	0x00542055
  10:	68636c6f 	stmdavs	r3!, {r0, r1, r2, r3, r5, r6, sl, fp, sp, lr}^
  14:	206e6961 	rsbcs	r6, lr, r1, ror #18
  18:	322e3231 	eorcc	r3, lr, #268435459	@ 0x10000003
  1c:	41504d2e 	cmpmi	r0, lr, lsr #26
  20:	49544243 	ldmdbmi	r4, {r0, r1, r6, r9, lr}^
  24:	6c65522d 	sfmvs	f5, 2, [r5], #-180	@ 0xffffff4c
  28:	42282031 	eormi	r2, r8, #49	@ 0x31
  2c:	646c6975 	strbtvs	r6, [ip], #-2421	@ 0xfffff68b
  30:	6d726120 	ldfvse	f6, [r2, #-128]!	@ 0xffffff80
  34:	2d32312d 	ldfcss	f3, [r2, #-180]!	@ 0xffffff4c
  38:	6361706d 	cmnvs	r1, #109	@ 0x6d
  3c:	2e697462 	cdpcs	4, 6, cr7, cr9, cr2, {3}
  40:	29293433 	stmdbcs	r9!, {r0, r1, r4, r5, sl, ip, sp}
  44:	2e323120 	rsfcssp	f3, f2, f0
  48:	20312e32 	eorscs	r2, r1, r2, lsr lr
  4c:	33323032 	teqcc	r2, #50	@ 0x32
  50:	34313230 	ldrtcc	r3, [r1], #-560	@ 0xfffffdd0
	...

Disassembly of section .ARM.attributes:

00000000 <.ARM.attributes>:
   0:	00002b41 	andeq	r2, r0, r1, asr #22
   4:	61656100 	cmnvs	r5, r0, lsl #2
   8:	01006962 	tsteq	r0, r2, ror #18
   c:	00000021 	andeq	r0, r0, r1, lsr #32
  10:	2d453705 	stclcs	7, cr3, [r5, #-20]	@ 0xffffffec
  14:	0d06004d 	stceq	0, cr0, [r6, #-308]	@ 0xfffffecc
  18:	02094d07 	andeq	r4, r9, #448	@ 0x1c0
  1c:	01140412 	tsteq	r4, r2, lsl r4
  20:	03170115 	tsteq	r7, #1073741829	@ 0x40000005
  24:	011a0118 	tsteq	sl, r8, lsl r1
  28:	0122011e 			@ <UNDEFINED> instruction: 0x0122011e

Disassembly of section .debug_frame:

00000000 <.debug_frame>:
   0:	0000000c 	andeq	r0, r0, ip
   4:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
   8:	7c020001 	stcvc	0, cr0, [r2], {1}
   c:	000d0c0e 	andeq	r0, sp, lr, lsl #24
  10:	00000020 	andeq	r0, r0, r0, lsr #32
  14:	00000000 	andeq	r0, r0, r0
  18:	000003c0 	andeq	r0, r0, r0, asr #7
  1c:	00000114 	andeq	r0, r0, r4, lsl r1
  20:	84100e41 	ldrhi	r0, [r0], #-3649	@ 0xfffff1bf
  24:	86038504 	strhi	r8, [r3], -r4, lsl #10
  28:	41018e02 	tstmi	r1, r2, lsl #28
  2c:	0a56780e 	beq	159e06c <__ROM_SIZE__+0x155e06c>
  30:	0b41100e 	bleq	1044070 <__ROM_SIZE__+0x1004070>
  34:	0000000c 	andeq	r0, r0, ip
  38:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
  3c:	7c020001 	stcvc	0, cr0, [r2], {1}
  40:	000d0c0e 	andeq	r0, sp, lr, lsl #24
  44:	0000000c 	andeq	r0, r0, ip
  48:	00000034 	andeq	r0, r0, r4, lsr r0
  4c:	000004d4 	ldrdeq	r0, [r0], -r4
  50:	00000002 	andeq	r0, r0, r2
  54:	0000000c 	andeq	r0, r0, ip
  58:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
  5c:	7c020001 	stcvc	0, cr0, [r2], {1}
  60:	000d0c0e 	andeq	r0, sp, lr, lsl #24
  64:	00000014 	andeq	r0, r0, r4, lsl r0
  68:	00000054 	andeq	r0, r0, r4, asr r0
  6c:	000004d8 	ldrdeq	r0, [r0], -r8
  70:	00000024 	andeq	r0, r0, r4, lsr #32
  74:	83080e41 	movwhi	r0, #36417	@ 0x8e41
  78:	00018e02 	andeq	r8, r1, r2, lsl #28
  7c:	0000000c 	andeq	r0, r0, ip
  80:	00000054 	andeq	r0, r0, r4, asr r0
  84:	000004fc 	strdeq	r0, [r0], -ip
  88:	0000001c 	andeq	r0, r0, ip, lsl r0
  8c:	0000000c 	andeq	r0, r0, ip
  90:	00000054 	andeq	r0, r0, r4, asr r0
  94:	00000518 	andeq	r0, r0, r8, lsl r5
  98:	00000024 	andeq	r0, r0, r4, lsr #32
  9c:	0000000c 	andeq	r0, r0, ip
  a0:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
  a4:	7c020001 	stcvc	0, cr0, [r2], {1}
  a8:	000d0c0e 	andeq	r0, sp, lr, lsl #24
  ac:	00000014 	andeq	r0, r0, r4, lsl r0
  b0:	0000009c 	muleq	r0, ip, r0
  b4:	0000053c 	andeq	r0, r0, ip, lsr r5
  b8:	00000024 	andeq	r0, r0, r4, lsr #32
  bc:	83080e41 	movwhi	r0, #36417	@ 0x8e41
  c0:	00018e02 	andeq	r8, r1, r2, lsl #28
  c4:	0000000c 	andeq	r0, r0, ip
  c8:	0000009c 	muleq	r0, ip, r0
  cc:	00000560 	andeq	r0, r0, r0, ror #10
  d0:	0000001c 	andeq	r0, r0, ip, lsl r0
  d4:	0000000c 	andeq	r0, r0, ip
  d8:	0000009c 	muleq	r0, ip, r0
  dc:	0000057c 	andeq	r0, r0, ip, ror r5
  e0:	00000024 	andeq	r0, r0, r4, lsr #32
  e4:	0000000c 	andeq	r0, r0, ip
  e8:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
  ec:	7c020001 	stcvc	0, cr0, [r2], {1}
  f0:	000d0c0e 	andeq	r0, sp, lr, lsl #24
  f4:	0000000c 	andeq	r0, r0, ip
  f8:	000000e4 	andeq	r0, r0, r4, ror #1
  fc:	000005a0 	andeq	r0, r0, r0, lsr #11
 100:	00000054 	andeq	r0, r0, r4, asr r0
 104:	00000014 	andeq	r0, r0, r4, lsl r0
 108:	000000e4 	andeq	r0, r0, r4, ror #1
 10c:	000005f4 	strdeq	r0, [r0], -r4
 110:	00000038 	andeq	r0, r0, r8, lsr r0
 114:	83080e41 	movwhi	r0, #36417	@ 0x8e41
 118:	00018e02 	andeq	r8, r1, r2, lsl #28
 11c:	0000000c 	andeq	r0, r0, ip
 120:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 124:	7c020001 	stcvc	0, cr0, [r2], {1}
 128:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 12c:	00000020 	andeq	r0, r0, r0, lsr #32
 130:	0000011c 	andeq	r0, r0, ip, lsl r1
 134:	0000062c 	andeq	r0, r0, ip, lsr #12
 138:	000000a4 	andeq	r0, r0, r4, lsr #1
 13c:	84100e41 	ldrhi	r0, [r0], #-3649	@ 0xfffff1bf
 140:	86038504 	strhi	r8, [r3], -r4, lsl #10
 144:	41018e02 	tstmi	r1, r2, lsl #28
 148:	4002580e 	andmi	r5, r2, lr, lsl #16
 14c:	0000100e 	andeq	r1, r0, lr
 150:	0000000c 	andeq	r0, r0, ip
 154:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 158:	7c020001 	stcvc	0, cr0, [r2], {1}
 15c:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 160:	00000014 	andeq	r0, r0, r4, lsl r0
 164:	00000150 	andeq	r0, r0, r0, asr r1
 168:	000006d0 	ldrdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
 16c:	0000001c 	andeq	r0, r0, ip, lsl r0
 170:	83080e41 	movwhi	r0, #36417	@ 0x8e41
 174:	00018e02 	andeq	r8, r1, r2, lsl #28
 178:	0000000c 	andeq	r0, r0, ip
 17c:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 180:	7c020001 	stcvc	0, cr0, [r2], {1}
 184:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 188:	0000001c 	andeq	r0, r0, ip, lsl r0
 18c:	00000178 	andeq	r0, r0, r8, ror r1
 190:	000006ec 	andeq	r0, r0, ip, ror #13
 194:	00000050 	andeq	r0, r0, r0, asr r0
 198:	84080e41 	strhi	r0, [r8], #-3649	@ 0xfffff1bf
 19c:	41018e02 	tstmi	r1, r2, lsl #28
 1a0:	5e01880e 	cdppl	8, 0, cr8, cr1, cr14, {0}
 1a4:	0000080e 	andeq	r0, r0, lr, lsl #16
 1a8:	0000001c 	andeq	r0, r0, ip, lsl r0
 1ac:	00000178 	andeq	r0, r0, r8, ror r1
 1b0:	0000073c 	andeq	r0, r0, ip, lsr r7
 1b4:	0000005c 	andeq	r0, r0, ip, asr r0
 1b8:	84080e41 	strhi	r0, [r8], #-3649	@ 0xfffff1bf
 1bc:	41018e02 	tstmi	r1, r2, lsl #28
 1c0:	0e64700e 	cdpeq	0, 6, cr7, cr4, cr14, {0}
 1c4:	00000008 	andeq	r0, r0, r8
 1c8:	0000000c 	andeq	r0, r0, ip
 1cc:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 1d0:	7c020001 	stcvc	0, cr0, [r2], {1}
 1d4:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 1d8:	00000020 	andeq	r0, r0, r0, lsr #32
 1dc:	000001c8 	andeq	r0, r0, r8, asr #3
 1e0:	00000798 	muleq	r0, r8, r7
 1e4:	0000010c 	andeq	r0, r0, ip, lsl #2
 1e8:	84100e41 	ldrhi	r0, [r0], #-3649	@ 0xfffff1bf
 1ec:	86038504 	strhi	r8, [r3], -r4, lsl #10
 1f0:	41018e02 	tstmi	r1, r2, lsl #28
 1f4:	0202d00e 	andeq	sp, r2, #14
 1f8:	00100e6d 	andseq	r0, r0, sp, ror #28
 1fc:	0000000c 	andeq	r0, r0, ip
 200:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 204:	7c020001 	stcvc	0, cr0, [r2], {1}
 208:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 20c:	00000014 	andeq	r0, r0, r4, lsl r0
 210:	000001fc 	strdeq	r0, [r0], -ip
 214:	000008a4 	andeq	r0, r0, r4, lsr #17
 218:	0000001c 	andeq	r0, r0, ip, lsl r0
 21c:	83080e41 	movwhi	r0, #36417	@ 0x8e41
 220:	00018e02 	andeq	r8, r1, r2, lsl #28
 224:	0000000c 	andeq	r0, r0, ip
 228:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 22c:	7c020001 	stcvc	0, cr0, [r2], {1}
 230:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 234:	00000020 	andeq	r0, r0, r0, lsr #32
 238:	00000224 	andeq	r0, r0, r4, lsr #4
 23c:	000008c0 	andeq	r0, r0, r0, asr #17
 240:	000000a4 	andeq	r0, r0, r4, lsr #1
 244:	84100e41 	ldrhi	r0, [r0], #-3649	@ 0xfffff1bf
 248:	86038504 	strhi	r8, [r3], -r4, lsl #10
 24c:	41018e02 	tstmi	r1, r2, lsl #28
 250:	0202e00e 	andeq	lr, r2, #14
 254:	00100e45 	andseq	r0, r0, r5, asr #28
 258:	0000000c 	andeq	r0, r0, ip
 25c:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 260:	7c020001 	stcvc	0, cr0, [r2], {1}
 264:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 268:	00000020 	andeq	r0, r0, r0, lsr #32
 26c:	00000258 	andeq	r0, r0, r8, asr r2
 270:	00000964 	andeq	r0, r0, r4, ror #18
 274:	0000006c 	andeq	r0, r0, ip, rrx
 278:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 27c:	41018e02 	tstmi	r1, r2, lsl #28
 280:	0d41100e 	stcleq	0, cr1, [r1, #-56]	@ 0xffffffc8
 284:	080e6607 	stmdaeq	lr, {r0, r1, r2, r9, sl, sp, lr}
 288:	000d0d41 	andeq	r0, sp, r1, asr #26
 28c:	00000014 	andeq	r0, r0, r4, lsl r0
 290:	00000258 	andeq	r0, r0, r8, asr r2
 294:	000009d0 	ldrdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
 298:	0000001c 	andeq	r0, r0, ip, lsl r0
 29c:	84080e41 	strhi	r0, [r8], #-3649	@ 0xfffff1bf
 2a0:	00018e02 	andeq	r8, r1, r2, lsl #28
 2a4:	00000014 	andeq	r0, r0, r4, lsl r0
 2a8:	00000258 	andeq	r0, r0, r8, asr r2
 2ac:	000009ec 	andeq	r0, r0, ip, ror #19
 2b0:	00000012 	andeq	r0, r0, r2, lsl r0
 2b4:	84080e41 	strhi	r0, [r8], #-3649	@ 0xfffff1bf
 2b8:	00018e02 	andeq	r8, r1, r2, lsl #28
 2bc:	00000014 	andeq	r0, r0, r4, lsl r0
 2c0:	00000258 	andeq	r0, r0, r8, asr r2
 2c4:	000009fe 	strdeq	r0, [r0], -lr
 2c8:	00000026 	andeq	r0, r0, r6, lsr #32
 2cc:	84080e41 	strhi	r0, [r8], #-3649	@ 0xfffff1bf
 2d0:	00018e02 	andeq	r8, r1, r2, lsl #28
 2d4:	00000018 	andeq	r0, r0, r8, lsl r0
 2d8:	00000258 	andeq	r0, r0, r8, asr r2
 2dc:	00000a24 	andeq	r0, r0, r4, lsr #20
 2e0:	00000040 	andeq	r0, r0, r0, asr #32
 2e4:	83100e41 	tsthi	r0, #1040	@ 0x410
 2e8:	85038404 	strhi	r8, [r3, #-1028]	@ 0xfffffbfc
 2ec:	00018e02 	andeq	r8, r1, r2, lsl #28
 2f0:	00000014 	andeq	r0, r0, r4, lsl r0
 2f4:	00000258 	andeq	r0, r0, r8, asr r2
 2f8:	00000a64 	andeq	r0, r0, r4, ror #20
 2fc:	0000001c 	andeq	r0, r0, ip, lsl r0
 300:	83080e41 	movwhi	r0, #36417	@ 0x8e41
 304:	00018e02 	andeq	r8, r1, r2, lsl #28
 308:	00000014 	andeq	r0, r0, r4, lsl r0
 30c:	00000258 	andeq	r0, r0, r8, asr r2
 310:	00000a80 	andeq	r0, r0, r0, lsl #21
 314:	00000010 	andeq	r0, r0, r0, lsl r0
 318:	83080e41 	movwhi	r0, #36417	@ 0x8e41
 31c:	00018e02 	andeq	r8, r1, r2, lsl #28
 320:	0000001c 	andeq	r0, r0, ip, lsl r0
 324:	00000258 	andeq	r0, r0, r8, asr r2
 328:	00000a90 	muleq	r0, r0, sl
 32c:	0000005c 	andeq	r0, r0, ip, asr r0
 330:	83180e42 	tsthi	r8, #1056	@ 0x420
 334:	85058406 	strhi	r8, [r5, #-1030]	@ 0xfffffbfa
 338:	88038604 	stmdahi	r3, {r2, r9, sl, pc}
 33c:	00018e02 	andeq	r8, r1, r2, lsl #28
 340:	00000018 	andeq	r0, r0, r8, lsl r0
 344:	00000258 	andeq	r0, r0, r8, asr r2
 348:	00000aec 	andeq	r0, r0, ip, ror #21
 34c:	00000068 	andeq	r0, r0, r8, rrx
 350:	84100e41 	ldrhi	r0, [r0], #-3649	@ 0xfffff1bf
 354:	86038504 	strhi	r8, [r3], -r4, lsl #10
 358:	00018e02 	andeq	r8, r1, r2, lsl #28
 35c:	00000020 	andeq	r0, r0, r0, lsr #32
 360:	00000258 	andeq	r0, r0, r8, asr r2
 364:	00000b54 	andeq	r0, r0, r4, asr fp
 368:	00000048 	andeq	r0, r0, r8, asr #32
 36c:	83100e42 	tsthi	r0, #1056	@ 0x420
 370:	85038404 	strhi	r8, [r3, #-1028]	@ 0xfffffbfc
 374:	5c018e02 	stcpl	14, cr8, [r1], {2}
 378:	c4c3000e 	strbgt	r0, [r3], #14
 37c:	0000cec5 	andeq	ip, r0, r5, asr #29
 380:	00000018 	andeq	r0, r0, r8, lsl r0
 384:	00000258 	andeq	r0, r0, r8, asr r2
 388:	00000b9c 	muleq	r0, ip, fp
 38c:	00000052 	andeq	r0, r0, r2, asr r0
 390:	83100e41 	tsthi	r0, #1040	@ 0x410
 394:	85038404 	strhi	r8, [r3, #-1028]	@ 0xfffffbfc
 398:	00018e02 	andeq	r8, r1, r2, lsl #28
 39c:	00000020 	andeq	r0, r0, r0, lsr #32
 3a0:	00000258 	andeq	r0, r0, r8, asr r2
 3a4:	00000bee 	andeq	r0, r0, lr, ror #23
 3a8:	0000003c 	andeq	r0, r0, ip, lsr r0
 3ac:	84100e42 	ldrhi	r0, [r0], #-3650	@ 0xfffff1be
 3b0:	86038504 	strhi	r8, [r3], -r4, lsl #10
 3b4:	5a018e02 	bpl	63bc4 <__ROM_SIZE__+0x23bc4>
 3b8:	c5c4000e 	strbgt	r0, [r4, #14]
 3bc:	0000cec6 	andeq	ip, r0, r6, asr #29
int car_mesg(int argc, char** argv) {
 3c0:	00000018 	andeq	r0, r0, r8, lsl r0
 3c4:	00000258 	andeq	r0, r0, r8, asr r2
    printf("Received a message from the car:");
 3c8:	00000c2a 	andeq	r0, r0, sl, lsr #24
 3cc:	00000072 	andeq	r0, r0, r2, ror r0
    for (ctr = 1; ctr < argc; ctr++) {
 3d0:	83100e41 	tsthi	r0, #1040	@ 0x410
        printf(" %s", argv[ctr]);
 3d4:	85038404 	strhi	r8, [r3, #-1028]	@ 0xfffffbfc
 3d8:	00018e02 	andeq	r8, r1, r2, lsl #28
    for (ctr = 1; ctr < argc; ctr++) {
 3dc:	00000018 	andeq	r0, r0, r8, lsl r0
 3e0:	00000258 	andeq	r0, r0, r8, asr r2
    printf("\n");
 3e4:	00000c9c 	muleq	r0, ip, ip
    if (argc > 1) {
 3e8:	00000060 	andeq	r0, r0, r0, rrx
}
 3ec:	83100e41 	tsthi	r0, #1040	@ 0x410
 3f0:	85038404 	strhi	r8, [r3, #-1028]	@ 0xfffffbfc
        if (strcmp(argv[1], "PING_REPLY") == 0) {
 3f4:	00018e02 	andeq	r8, r1, r2, lsl #28
 3f8:	0000000c 	andeq	r0, r0, ip
            printf("Got a ping reply.\n");
 3fc:	00000258 	andeq	r0, r0, r8, asr r2
 400:	00000cfc 	strdeq	r0, [r0], -ip
        else if (strcmp(argv[1], "AESB64") == 0) {
 404:	0000000c 	andeq	r0, r0, ip
 408:	0000000c 	andeq	r0, r0, ip
 40c:	00000258 	andeq	r0, r0, r8, asr r2
            if (argc == 3) { 
 410:	00000d08 	andeq	r0, r0, r8, lsl #26
                printf("Missing AESB64 encoded message\n");
 414:	0000000c 	andeq	r0, r0, ip
 418:	0000000c 	andeq	r0, r0, ip
                len = decode_base64((uint8_t *) argv[2], strlen(argv[2]), decoded);
 41c:	00000258 	andeq	r0, r0, r8, asr r2
 420:	00000d14 	andeq	r0, r0, r4, lsl sp
 424:	0000000c 	andeq	r0, r0, ip
 428:	0000000c 	andeq	r0, r0, ip
 42c:	00000258 	andeq	r0, r0, r8, asr r2
                AES_ECB_decrypt(&ctx, decoded);
 430:	00000d20 	andeq	r0, r0, r0, lsr #26
 434:	0000000c 	andeq	r0, r0, ip
                decoded[len] = '\0';
 438:	0000000c 	andeq	r0, r0, ip
 43c:	00000258 	andeq	r0, r0, r8, asr r2
 440:	00000d2c 	andeq	r0, r0, ip, lsr #26
                printf("Decoded/decrypted as %s\n", decoded);
 444:	00000002 	andeq	r0, r0, r2
 448:	0000000c 	andeq	r0, r0, ip
 44c:	00000258 	andeq	r0, r0, r8, asr r2
        else if (strcmp(argv[1], "B64") == 0) {
 450:	00000d2e 	andeq	r0, r0, lr, lsr #26
 454:	00000002 	andeq	r0, r0, r2
            if (argc == 3) { 
 458:	0000000c 	andeq	r0, r0, ip
                printf("Missing Base64 encoded message\n");
 45c:	00000258 	andeq	r0, r0, r8, asr r2
 460:	00000d30 	andeq	r0, r0, r0, lsr sp
                printf("Decoding Base64\n");
 464:	00000002 	andeq	r0, r0, r2
 468:	0000002c 	andeq	r0, r0, ip, lsr #32
                len = decode_base64((uint8_t *) argv[2], strlen(argv[2]), decoded);
 46c:	00000258 	andeq	r0, r0, r8, asr r2
 470:	00000d32 	andeq	r0, r0, r2, lsr sp
 474:	000000a2 	andeq	r0, r0, r2, lsr #1
 478:	83200e44 			@ <UNDEFINED> instruction: 0x83200e44
                decoded[len] = '\0';
 47c:	85078408 	strhi	r8, [r7, #-1032]	@ 0xfffffbf8
 480:	88058606 	stmdahi	r5, {r1, r2, r9, sl, pc}
 484:	8a038904 	bhi	e289c <__ROM_SIZE__+0xa289c>
                printf("Decoded as %s", decoded);
 488:	02018e02 	andeq	r8, r1, #2, 28
 48c:	c3000e45 	movwgt	r0, #3653	@ 0xe45
 490:	c8c6c5c4 	stmiagt	r6, {r2, r6, r7, r8, sl, lr, pc}^
            printf("Didn't know how to handle %s\n", argv[1]);
 494:	00cecac9 	sbceq	ip, lr, r9, asr #21
 498:	0000000c 	andeq	r0, r0, ip
 49c:	00000258 	andeq	r0, r0, r8, asr r2
 4a0:	00000dd4 	ldrdeq	r0, [r0], -r4
 4a4:	00000004 	andeq	r0, r0, r4
 4a8:	00000020 	andeq	r0, r0, r0, lsr #32
 4ac:	00000258 	andeq	r0, r0, r8, asr r2
 4b0:	00000dd8 	ldrdeq	r0, [r0], -r8
 4b4:	00000178 	andeq	r0, r0, r8, ror r1
 4b8:	840c0e41 	strhi	r0, [ip], #-3649	@ 0xfffff1bf
 4bc:	8e028503 	cfsh32hi	mvfx8, mvfx2, #3
 4c0:	980e4101 	stmdals	lr, {r0, r8, lr}
 4c4:	0e0a7e03 	cdpeq	14, 0, cr7, cr10, cr3, {0}
 4c8:	000b410c 	andeq	r4, fp, ip, lsl #2
 4cc:	00000014 	andeq	r0, r0, r4, lsl r0
 4d0:	00000258 	andeq	r0, r0, r8, asr r2
 4d4:	00000f50 	andeq	r0, r0, r0, asr pc
void uputc(char c) {
 4d8:	00000038 	andeq	r0, r0, r8, lsr r0
  while ((UARTFR >> 5) & 1)
 4dc:	83080e41 	movwhi	r0, #36417	@ 0x8e41
 4e0:	00018e02 	andeq	r8, r1, r2, lsl #28
  UART_DR = c;
 4e4:	0000001c 	andeq	r0, r0, ip, lsl r0
  if (c == '\n')
 4e8:	00000258 	andeq	r0, r0, r8, asr r2
}
 4ec:	00000f88 	andeq	r0, r0, r8, lsl #31
    uputc('\r');
 4f0:	0000002c 	andeq	r0, r0, ip, lsr #32
}
 4f4:	8e040e41 	cdphi	14, 0, cr0, cr4, cr1, {2}
 4f8:	880e4101 	stmdahi	lr, {r0, r8, lr}
  if (!((UARTFR >> 4) & 1)) return UART_DR;
 4fc:	0e0a4b02 	vmlaeq.f64	d4, d10, d2
 500:	000b4204 	andeq	r4, fp, r4, lsl #4
 504:	00000018 	andeq	r0, r0, r8, lsl r0
 508:	00000258 	andeq	r0, r0, r8, asr r2
  return -1;
 50c:	00000fb4 			@ <UNDEFINED> instruction: 0x00000fb4
}
 510:	00000030 	andeq	r0, r0, r0, lsr r0
 514:	84100e41 	ldrhi	r0, [r0], #-3649	@ 0xfffff1bf
  UARTCTL = 0;
 518:	86038504 	strhi	r8, [r3], -r4, lsl #10
 51c:	00018e02 	andeq	r8, r1, r2, lsl #28
  UARTIBRD = 8;
 520:	0000000c 	andeq	r0, r0, ip
  UARTFBRD = 44;
 524:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
  UARTCC = 0;
 528:	7c020001 	stcvc	0, cr0, [r2], {1}
  UARTLCRH = 0x60;
 52c:	000d0c0e 	andeq	r0, sp, lr, lsl #24
  UARTCTL = 0x301;
 530:	0000000c 	andeq	r0, r0, ip
}
 534:	00000520 	andeq	r0, r0, r0, lsr #10
 538:	00000fe4 	andeq	r0, r0, r4, ror #31
void u2putc(char c) {
 53c:	00000032 	andeq	r0, r0, r2, lsr r0
  while ((UART2FR >> 5) & 1)
 540:	0000000c 	andeq	r0, r0, ip
 544:	00000520 	andeq	r0, r0, r0, lsr #10
  UART2_DR = c;
 548:	00001016 	andeq	r1, r0, r6, lsl r0
  if (c == '\n')
 54c:	0000003e 	andeq	r0, r0, lr, lsr r0
}
 550:	0000000c 	andeq	r0, r0, ip
    u2putc('\r');
 554:	00000520 	andeq	r0, r0, r0, lsr #10
}
 558:	00001054 	andeq	r1, r0, r4, asr r0
 55c:	00000014 	andeq	r0, r0, r4, lsl r0
  if (!((UART2FR >> 4) & 1)) return UART2_DR;
 560:	00000018 	andeq	r0, r0, r8, lsl r0
 564:	00000520 	andeq	r0, r0, r0, lsr #10
 568:	00001068 	andeq	r1, r0, r8, rrx
 56c:	00000034 	andeq	r0, r0, r4, lsr r0
  return -1;
 570:	84100e41 	ldrhi	r0, [r0], #-3649	@ 0xfffff1bf
}
 574:	86038504 	strhi	r8, [r3], -r4, lsl #10
 578:	00018e02 	andeq	r8, r1, r2, lsl #28
  UART2CTL = 0;
 57c:	0000001c 	andeq	r0, r0, ip, lsl r0
 580:	00000520 	andeq	r0, r0, r0, lsr #10
  UART2IBRD = 8;
 584:	0000109c 	muleq	r0, ip, r0
  UART2FBRD = 44;
 588:	000000e8 	andeq	r0, r0, r8, ror #1
  UART2CC = 0;
 58c:	84180e42 	ldrhi	r0, [r8], #-3650	@ 0xfffff1be
  UART2LCRH = 0x60;
 590:	86058506 	strhi	r8, [r5], -r6, lsl #10
  UART2CTL = 0x301;
 594:	88038704 	stmdahi	r3, {r2, r8, r9, sl, pc}
}
 598:	00018e02 	andeq	r8, r1, r2, lsl #28
 59c:	0000001c 	andeq	r0, r0, ip, lsl r0
  RCGCUART |= 3;
 5a0:	00000520 	andeq	r0, r0, r0, lsr #10
 5a4:	00001184 	andeq	r1, r0, r4, lsl #3
 5a8:	000000bc 	strheq	r0, [r0], -ip
 5ac:	84180e42 	ldrhi	r0, [r8], #-3650	@ 0xfffff1be
  RCGCGPIO |= 3;
 5b0:	86058506 	strhi	r8, [r5], -r6, lsl #10
 5b4:	88038704 	stmdahi	r3, {r2, r8, r9, sl, pc}
 5b8:	00018e02 	andeq	r8, r1, r2, lsl #28
  GPIODEN = 0x03;
 5bc:	0000000c 	andeq	r0, r0, ip
 5c0:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
  GPIOAFSEL = 0x03;
 5c4:	7c020001 	stcvc	0, cr0, [r2], {1}
  GPIOPCTL |= 0x00000011;
 5c8:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 5cc:	0000002c 	andeq	r0, r0, ip, lsr #32
 5d0:	000005bc 			@ <UNDEFINED> instruction: 0x000005bc
  GPIODEN2 = 0x03;
 5d4:	00001240 	andeq	r1, r0, r0, asr #4
 5d8:	00000174 	andeq	r0, r0, r4, ror r1
  GPIOAFSEL2 = 0x03;
 5dc:	84240e42 	strthi	r0, [r4], #-3650	@ 0xfffff1be
  GPIOPCTL2 |= 0x00000011;
 5e0:	86088509 	strhi	r8, [r8], -r9, lsl #10
 5e4:	88068707 	stmdahi	r6, {r0, r1, r2, r8, r9, sl, pc}
 5e8:	8a048905 	bhi	122a04 <__ROM_SIZE__+0xe2a04>
}
 5ec:	8e028b03 	vmlahi.f64	d8, d2, d3
 5f0:	c80e4101 	stmdagt	lr, {r0, r8, lr}
void platform_init() {
 5f4:	0eb20202 	cdpeq	2, 11, cr0, cr2, cr2, {0}
    pin_setup();
 5f8:	00000024 	andeq	r0, r0, r4, lsr #32
    uart_init();
 5fc:	0000000c 	andeq	r0, r0, ip
    uart2_init();
 600:	000005bc 			@ <UNDEFINED> instruction: 0x000005bc
    set_read_char(ugetc);
 604:	000013b4 			@ <UNDEFINED> instruction: 0x000013b4
    set_read_char2(u2getc);
 608:	00000054 	andeq	r0, r0, r4, asr r0
 60c:	0000001c 	andeq	r0, r0, ip, lsl r0
    set_write_char(uputc);
 610:	000005bc 			@ <UNDEFINED> instruction: 0x000005bc
    set_write_char2(u2putc);
 614:	00001408 	andeq	r1, r0, r8, lsl #8
 618:	00000040 	andeq	r0, r0, r0, asr #32
}
 61c:	83180e41 	tsthi	r8, #1040	@ 0x410
 620:	85058406 	strhi	r8, [r5, #-1030]	@ 0xfffffbfa
 624:	87038604 	strhi	r8, [r3, -r4, lsl #12]
 628:	00018e02 	andeq	r8, r1, r2, lsl #28
int aes_test(int argc, char** argv) {
 62c:	00000018 	andeq	r0, r0, r8, lsl r0
    uint8_t text[17] = "0123456789abcdef";
 630:	000005bc 			@ <UNDEFINED> instruction: 0x000005bc
 634:	00001448 	andeq	r1, r0, r8, asr #8
 638:	000000e6 	andeq	r0, r0, r6, ror #1
 63c:	83100e41 	tsthi	r0, #1040	@ 0x410
 640:	85038404 	strhi	r8, [r3, #-1028]	@ 0xfffffbfc
    printf("Plaintext is %s\n", text);
 644:	00018e02 	andeq	r8, r1, r2, lsl #28
 648:	0000000c 	andeq	r0, r0, ip
    AES_ECB_encrypt(&ctx, text);
 64c:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 650:	7c020001 	stcvc	0, cr0, [r2], {1}
    len = encode_base64(text, 16, b64text);
 654:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 658:	00000014 	andeq	r0, r0, r4, lsl r0
 65c:	00000648 	andeq	r0, r0, r8, asr #12
    b64text[len] = '\0';
 660:	00001530 	andeq	r1, r0, r0, lsr r5
 664:	0000001c 	andeq	r0, r0, ip, lsl r0
 668:	84080e41 	strhi	r0, [r8], #-3649	@ 0xfffff1bf
    printf("Encrypted/encoded is %s\n", b64text);
 66c:	00018e02 	andeq	r8, r1, r2, lsl #28
 670:	00000020 	andeq	r0, r0, r0, lsr #32
    printf2("FOB_MESG AESB64 %s\n", b64text);
 674:	00000648 	andeq	r0, r0, r8, asr #12
 678:	0000154c 	andeq	r1, r0, ip, asr #10
    printf("Test the mesg handler with CAR_MESG AESB64 %s\n", b64text);
 67c:	00000140 	andeq	r0, r0, r0, asr #2
 680:	840c0e41 	strhi	r0, [ip], #-3649	@ 0xfffff1bf
    len = decode_base64(b64text, len, decoded);
 684:	8e028503 	cfsh32hi	mvfx8, mvfx2, #3
 688:	200e4101 	andcs	r4, lr, r1, lsl #2
 68c:	0c0e0a60 			@ <UNDEFINED> instruction: 0x0c0e0a60
    AES_ECB_decrypt(&ctx, decoded);
 690:	00000b41 	andeq	r0, r0, r1, asr #22
 694:	00000038 	andeq	r0, r0, r8, lsr r0
    decoded[len] = '\0';
 698:	00000648 	andeq	r0, r0, r8, asr #12
 69c:	0000168c 	andeq	r1, r0, ip, lsl #13
 6a0:	000000dc 	ldrdeq	r0, [r0], -ip
    printf("After encrypting->encoding->decoding->decrypting we recover %s\n", decoded);
 6a4:	80100e41 	andshi	r0, r0, r1, asr #28
 6a8:	82038104 	andhi	r8, r3, #4, 2
}
 6ac:	41018302 	tstmi	r1, r2, lsl #6
 6b0:	07841c0e 	streq	r1, [r4, lr, lsl #24]
 6b4:	058e0685 	streq	r0, [lr, #1669]	@ 0x685
 6b8:	02280e41 	eoreq	r0, r8, #1040	@ 0x410
 6bc:	1c0e0a61 			@ <UNDEFINED> instruction: 0x1c0e0a61
 6c0:	c4c5ce42 	strbgt	ip, [r5], #3650	@ 0xe42
 6c4:	c341100e 	movtgt	r1, #4110	@ 0x100e
 6c8:	0ec0c1c2 	acseqdm	f4, f2
 6cc:	000b4100 	andeq	r4, fp, r0, lsl #2
int pair(int argc, char** argv) {
 6d0:	0000000c 	andeq	r0, r0, ip
    printf("Sending a pair request.\n");
 6d4:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
    printf2("FOB_MESG PAIR\n");
 6d8:	7c020001 	stcvc	0, cr0, [r2], {1}
 6dc:	000d0c0e 	andeq	r0, sp, lr, lsl #24
}
 6e0:	00000014 	andeq	r0, r0, r4, lsl r0
 6e4:	000006d0 	ldrdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
 6e8:	00001768 	andeq	r1, r0, r8, ror #14
int encode64(int argc, char** argv) {
 6ec:	0000001c 	andeq	r0, r0, ip, lsl r0
    if (argc > 1) {
 6f0:	84080e41 	strhi	r0, [r8], #-3649	@ 0xfffff1bf
 6f4:	00018e02 	andeq	r8, r1, r2, lsl #28
        len = strlen(argv[1]);
 6f8:	00000020 	andeq	r0, r0, r0, lsr #32
 6fc:	000006d0 	ldrdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
        if (len < MAXARRAYLEN) {
 700:	00001784 	andeq	r1, r0, r4, lsl #15
            len = encode_base64((uint8_t *) argv[1], len, encoded);
 704:	00000140 	andeq	r0, r0, r0, asr #2
 708:	840c0e41 	strhi	r0, [ip], #-3649	@ 0xfffff1bf
            printf("Encoded %s as %s with %d characters\n", argv[1], encoded, len);
 70c:	8e028503 	cfsh32hi	mvfx8, mvfx2, #3
 710:	200e4101 	andcs	r4, lr, r1, lsl #2
 714:	0c0e0a60 			@ <UNDEFINED> instruction: 0x0c0e0a60
            printf("String exceeds max length of %d characters", MAXARRAYLEN);
 718:	00000b41 	andeq	r0, r0, r1, asr #22
 71c:	00000038 	andeq	r0, r0, r8, lsr r0
 720:	000006d0 	ldrdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
        printf("Usage is 'encode64 string'\n");
 724:	000018c4 	andeq	r1, r0, r4, asr #17
}
 728:	000000dc 	ldrdeq	r0, [r0], -ip
 72c:	80100e41 	andshi	r0, r0, r1, asr #28
 730:	82038104 	andhi	r8, r3, #4, 2
 734:	41018302 	tstmi	r1, r2, lsl #6
 738:	07841c0e 	streq	r1, [r4, lr, lsl #24]
int decode64(int argc, char** argv) {
 73c:	058e0685 	streq	r0, [lr, #1669]	@ 0x685
    if (argc > 1) {
 740:	02280e41 	eoreq	r0, r8, #1040	@ 0x410
 744:	1c0e0a61 			@ <UNDEFINED> instruction: 0x1c0e0a61
        int len = strlen(argv[1]);
 748:	c4c5ce42 	strbgt	ip, [r5], #3650	@ 0xe42
 74c:	c341100e 	movtgt	r1, #4110	@ 0x100e
        if (len < MAXBASE64LEN) {
 750:	0ec0c1c2 	acseqdm	f4, f2
                len = decode_base64((uint8_t *) argv[1], len, plaintext);
 754:	000b4100 	andeq	r4, fp, r0, lsl #2
 758:	0000000c 	andeq	r0, r0, ip
                plaintext[len] = '\0';
 75c:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 760:	7c020001 	stcvc	0, cr0, [r2], {1}
 764:	000d0c0e 	andeq	r0, sp, lr, lsl #24
                printf("Decoded %s as: %s\n", argv[1], plaintext);
 768:	00000014 	andeq	r0, r0, r4, lsl r0
 76c:	00000758 	andeq	r0, r0, r8, asr r7
 770:	000019a0 	andeq	r1, r0, r0, lsr #19
            printf("String exceeds max base64 string length of %d characters", MAXBASE64LEN);
 774:	00000030 	andeq	r0, r0, r0, lsr r0
 778:	83080e41 	movwhi	r0, #36417	@ 0x8e41
 77c:	00018e02 	andeq	r8, r1, r2, lsl #28
        printf("Usage is 'decode64 string'\n");
 780:	00000018 	andeq	r0, r0, r8, lsl r0
}
 784:	00000758 	andeq	r0, r0, r8, asr r7
 788:	000019d0 	ldrdeq	r1, [r0], -r0
 78c:	00000030 	andeq	r0, r0, r0, lsr r0
 790:	83100e41 	tsthi	r0, #1040	@ 0x410
 794:	85038404 	strhi	r8, [r3, #-1028]	@ 0xfffffbfc
int ecdh_test(int argc, char** argv) {
 798:	00018e02 	andeq	r8, r1, r2, lsl #28
    uint8_t b64privkey2[32] = "wP/uwP/uwP/uwP/uwP/uwP/uwP/uwP/u";
 79c:	00000018 	andeq	r0, r0, r8, lsl r0
 7a0:	00000758 	andeq	r0, r0, r8, asr r7
 7a4:	00001a00 	andeq	r1, r0, r0, lsl #20
 7a8:	00000048 	andeq	r0, r0, r8, asr #32
 7ac:	84100e41 	ldrhi	r0, [r0], #-3649	@ 0xfffff1bf
    printf("Testing the ecdh key exchange\n");
 7b0:	86038504 	strhi	r8, [r3], -r4, lsl #10
 7b4:	00018e02 	andeq	r8, r1, r2, lsl #28
    decode_base64(ECDH_privkey_b64, 32, ECDH_privkey);
 7b8:	00000018 	andeq	r0, r0, r8, lsl r0
 7bc:	00000758 	andeq	r0, r0, r8, asr r7
 7c0:	00001a48 	andeq	r1, r0, r8, asr #20
    decode_base64(b64privkey2, 32, privkey2);
 7c4:	00000068 	andeq	r0, r0, r8, rrx
 7c8:	84100e41 	ldrhi	r0, [r0], #-3649	@ 0xfffff1bf
    ecdh_generate_keys(ECDH_pubkey, ECDH_privkey);
 7cc:	86038504 	strhi	r8, [r3], -r4, lsl #10
 7d0:	00018e02 	andeq	r8, r1, r2, lsl #28
 7d4:	00000018 	andeq	r0, r0, r8, lsl r0
    ecdh_generate_keys(pubkey2, privkey2);
 7d8:	00000758 	andeq	r0, r0, r8, asr r7
 7dc:	00001ab0 			@ <UNDEFINED> instruction: 0x00001ab0
    ecdh_shared_secret(ECDH_privkey, pubkey2, ECDH_shared);
 7e0:	00000050 	andeq	r0, r0, r0, asr r0
 7e4:	83100e41 	tsthi	r0, #1040	@ 0x410
 7e8:	85038404 	strhi	r8, [r3, #-1028]	@ 0xfffffbfc
    ecdh_shared_secret(privkey2, ECDH_pubkey, sharedsecret2);
 7ec:	00018e02 	andeq	r8, r1, r2, lsl #28
 7f0:	0000000c 	andeq	r0, r0, ip
    sha256_init(&shactx);
 7f4:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 7f8:	7c020001 	stcvc	0, cr0, [r2], {1}
	sha256_update(&shactx, ECDH_shared, ECC_PUB_KEY_SIZE);
 7fc:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 800:	0000001c 	andeq	r0, r0, ip, lsl r0
	sha256_final(&shactx, ECDH_AESkey);
 804:	000007f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
 808:	00001b00 	andeq	r1, r0, r0, lsl #22
 80c:	00000120 	andeq	r0, r0, r0, lsr #2
    len = encode_base64(ECDH_AESkey, AES_KEYLEN, b64test);
 810:	840c0e41 	strhi	r0, [ip], #-3649	@ 0xfffff1bf
 814:	8e028503 	cfsh32hi	mvfx8, mvfx2, #3
    b64test[len] = '\0';
 818:	180e4101 	stmdane	lr, {r0, r8, lr}
 81c:	0c0e8a02 			@ <UNDEFINED> instruction: 0x0c0e8a02
 820:	00000018 	andeq	r0, r0, r8, lsl r0
 824:	000007f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
    printf("First shared key is %s\n", b64test);
 828:	00001c20 	andeq	r1, r0, r0, lsr #24
 82c:	00000038 	andeq	r0, r0, r8, lsr r0
    sha256_init(&shactx);
 830:	840c0e41 	strhi	r0, [ip], #-3649	@ 0xfffff1bf
    sha256_update(&shactx, sharedsecret2, ECC_PUB_KEY_SIZE);
 834:	8e028503 	cfsh32hi	mvfx8, mvfx2, #3
 838:	00000001 	andeq	r0, r0, r1
 83c:	00000018 	andeq	r0, r0, r8, lsl r0
	sha256_final(&shactx, keytest);
 840:	000007f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
 844:	00001c58 	andeq	r1, r0, r8, asr ip
    len = encode_base64(keytest, AES_KEYLEN, b64test);
 848:	00000044 	andeq	r0, r0, r4, asr #32
 84c:	84040e47 	strhi	r0, [r4], #-3655	@ 0xfffff1b9
    b64test[len] = '\0';
 850:	0ec45401 	cdpeq	4, 12, cr5, cr4, cr1, {0}
 854:	00000000 	andeq	r0, r0, r0
 858:	0000000c 	andeq	r0, r0, ip
    printf("Should be same as %s\n", b64test);
 85c:	000007f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
 860:	00001c9c 	muleq	r0, ip, ip
    printf("Switching fob AES key to new value. Try AES tests now.\n");
 864:	00000032 	andeq	r0, r0, r2, lsr r0
 868:	0000000c 	andeq	r0, r0, ip
    AES_init_ctx(&ctx, ECDH_AESkey);
 86c:	000007f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
 870:	00001cce 	andeq	r1, r0, lr, asr #25
}
 874:	00000012 	andeq	r0, r0, r2, lsl r0
 878:	00000024 	andeq	r0, r0, r4, lsr #32
 87c:	000007f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
 880:	00001ce0 	andeq	r1, r0, r0, ror #25
 884:	00000076 	andeq	r0, r0, r6, ror r0
 888:	83280e42 			@ <UNDEFINED> instruction: 0x83280e42
 88c:	8509840a 	strhi	r8, [r9, #-1034]	@ 0xfffffbf6
 890:	87078608 	strhi	r8, [r7, -r8, lsl #12]
 894:	89058806 	stmdbhi	r5, {r1, r2, fp, pc}
 898:	8b038a04 	blhi	e30b0 <__ROM_SIZE__+0xa30b0>
 89c:	00018e02 	andeq	r8, r1, r2, lsl #28
 8a0:	00000028 	andeq	r0, r0, r8, lsr #32
int send_ping(int argc, char** argv) {
 8a4:	000007f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
    printf("Pinging the car.\n");
 8a8:	00001d56 	andeq	r1, r0, r6, asr sp
    printf2("FOB_MESG PING\n");
 8ac:	0000015a 	andeq	r0, r0, sl, asr r1
 8b0:	84240e42 	strthi	r0, [r4], #-3650	@ 0xfffff1be
}
 8b4:	86088509 	strhi	r8, [r8], -r9, lsl #10
 8b8:	88068707 	stmdahi	r6, {r0, r1, r2, r8, r9, sl, pc}
 8bc:	8a048905 	bhi	122cd8 <__ROM_SIZE__+0xe2cd8>
int sha256_test(int argc, char** argv) {
 8c0:	8e028b03 	vmlahi.f64	d8, d2, d3
    printf("Starting sha256 test\n");
 8c4:	500e4101 	andpl	r4, lr, r1, lsl #2
 8c8:	240ea802 	strcs	sl, [lr], #-2050	@ 0xfffff7fe
    BYTE text1[] = {"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"};
 8cc:	00000018 	andeq	r0, r0, r8, lsl r0
 8d0:	000007f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
 8d4:	00001eb0 			@ <UNDEFINED> instruction: 0x00001eb0
 8d8:	00000048 	andeq	r0, r0, r8, asr #32
 8dc:	8e040e47 	cdphi	14, 0, cr0, cr4, cr7, {2}
 8e0:	000e5601 	andeq	r5, lr, r1, lsl #12
 8e4:	000000ce 	andeq	r0, r0, lr, asr #1
 8e8:	0000000c 	andeq	r0, r0, ip
 8ec:	000007f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
    BYTE hash1[SHA256_BLOCK_SIZE] = {0x24,0x8d,0x6a,0x61,0xd2,0x06,0x38,0xb8,0xe5,0xc0,0x26,0x93,0x0c,0x3e,0x60,0x39,
 8f0:	00001ef8 	strdeq	r1, [r0], -r8
 8f4:	00000032 	andeq	r0, r0, r2, lsr r0
 8f8:	00000018 	andeq	r0, r0, r8, lsl r0
 8fc:	000007f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
    sha256_init(&shactx);
 900:	00001f2a 	andeq	r1, r0, sl, lsr #30
	sha256_update(&shactx, text1, strlen((char *)text1));
 904:	00000044 	andeq	r0, r0, r4, asr #32
 908:	84100e41 	ldrhi	r0, [r0], #-3649	@ 0xfffff1bf
 90c:	86038504 	strhi	r8, [r3], -r4, lsl #10
 910:	00018e02 	andeq	r8, r1, r2, lsl #28
	sha256_final(&shactx, buf);
 914:	00000018 	andeq	r0, r0, r8, lsl r0
 918:	000007f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
    len = encode_base64(hash1, SHA256_BLOCK_SIZE, b64_hash1);
 91c:	00001f6e 	andeq	r1, r0, lr, ror #30
 920:	0000003a 	andeq	r0, r0, sl, lsr r0
 924:	84100e41 	ldrhi	r0, [r0], #-3649	@ 0xfffff1bf
    b64_hash1[len] = '\0';
 928:	86038504 	strhi	r8, [r3], -r4, lsl #10
    len = encode_base64(buf, SHA256_BLOCK_SIZE, b64_buf);
 92c:	00018e02 	andeq	r8, r1, r2, lsl #28
 930:	0000000c 	andeq	r0, r0, ip
 934:	000007f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
    b64_buf[len] = '\0';
 938:	00001fa8 	andeq	r1, r0, r8, lsr #31
    printf("Base64 of SHA-256 test is %s\n", b64_buf);
 93c:	0000001a 	andeq	r0, r0, sl, lsl r0
 940:	00000014 	andeq	r0, r0, r4, lsl r0
    printf("Should be %s\n", b64_hash1);
 944:	000007f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
 948:	00001fc2 	andeq	r1, r0, r2, asr #31
}
 94c:	00000008 	andeq	r0, r0, r8
 950:	83080e41 	movwhi	r0, #36417	@ 0x8e41
 954:	00018e02 	andeq	r8, r1, r2, lsl #28
 958:	00000018 	andeq	r0, r0, r8, lsl r0
 95c:	000007f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
 960:	00001fca 	andeq	r1, r0, sl, asr #31
void __attribute__((optimize("O0"), weak)) initial_setup(void) {
 964:	00000018 	andeq	r0, r0, r8, lsl r0
 968:	83100e41 	tsthi	r0, #1040	@ 0x410
  char *src = &_etext, *dst = &_data;
 96c:	85038404 	strhi	r8, [r3, #-1028]	@ 0xfffffbfc
 970:	00018e02 	andeq	r8, r1, r2, lsl #28
  if (dst != src)
 974:	00000014 	andeq	r0, r0, r4, lsl r0
 978:	000007f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
    while (dst < &_edata) *(dst++) = *(src++);
 97c:	00001fe2 	andeq	r1, r0, r2, ror #31
 980:	0000000c 	andeq	r0, r0, ip
 984:	83080e41 	movwhi	r0, #36417	@ 0x8e41
 988:	00018e02 	andeq	r8, r1, r2, lsl #28
 98c:	00000014 	andeq	r0, r0, r4, lsl r0
 990:	000007f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
  for (dst = &_bss; dst < &_ebss; dst++) *dst = 0;
 994:	00001fee 	andeq	r1, r0, lr, ror #31
 998:	0000000e 	andeq	r0, r0, lr
 99c:	83080e41 	movwhi	r0, #36417	@ 0x8e41
 9a0:	00018e02 	andeq	r8, r1, r2, lsl #28
 9a4:	00000014 	andeq	r0, r0, r4, lsl r0
 9a8:	000007f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
 9ac:	00001ffc 	strdeq	r1, [r0], -ip
  platform_init();
 9b0:	0000000e 	andeq	r0, r0, lr
}
 9b4:	83080e41 	movwhi	r0, #36417	@ 0x8e41
 9b8:	00018e02 	andeq	r8, r1, r2, lsl #28
 9bc:	0000001c 	andeq	r0, r0, ip, lsl r0
 9c0:	000007f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
 9c4:	0000200a 	andeq	r2, r0, sl
 9c8:	00000038 	andeq	r0, r0, r8, lsr r0
 9cc:	84180e42 	ldrhi	r0, [r8], #-3650	@ 0xfffff1be
static void delete(void) {
 9d0:	86058506 	strhi	r8, [r5], -r6, lsl #10
  __write_char__(BACK_SPACE);
 9d4:	88038704 	stmdahi	r3, {r2, r8, r9, sl, pc}
 9d8:	00018e02 	andeq	r8, r1, r2, lsl #28
  __write_char__(SPACE);
 9dc:	00000024 	andeq	r0, r0, r4, lsr #32
  __write_char__(BACK_SPACE);
 9e0:	000007f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
 9e4:	00002042 	andeq	r2, r0, r2, asr #32
}
 9e8:	00000046 	andeq	r0, r0, r6, asr #32
static void clear_prompt(int char_count) {
 9ec:	84180e42 	ldrhi	r0, [r8], #-3650	@ 0xfffff1be
  while (char_count) {
 9f0:	86058506 	strhi	r8, [r5], -r6, lsl #10
    delete ();
 9f4:	88038704 	stmdahi	r3, {r2, r8, r9, sl, pc}
  while (char_count) {
 9f8:	41018e02 	tstmi	r1, r2, lsl #28
}
 9fc:	0e5e280e 	cdpeq	8, 5, cr2, cr14, cr14, {0}
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
 a00:	00000018 	andeq	r0, r0, r8, lsl r0
    auto_load[i].command(0, NULL);
 a04:	00000020 	andeq	r0, r0, r0, lsr #32
 a08:	000007f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
 a0c:	00002088 	andeq	r2, r0, r8, lsl #1
 a10:	00000074 	andeq	r0, r0, r4, ror r0
 a14:	84140e41 	ldrhi	r0, [r4], #-3649	@ 0xfffff1bf
 a18:	86048505 	strhi	r8, [r4], -r5, lsl #10
 a1c:	8e028703 	cdphi	7, 0, cr8, cr2, cr3, {0}
}
 a20:	280e4101 	stmdacs	lr, {r0, r8, lr}
static int show_history(int argc, char **argv) {
 a24:	00140e77 	andseq	r0, r4, r7, ror lr
  uint32_t end_index = total_num_commands-1;
 a28:	0000000c 	andeq	r0, r0, ip
  if (total_num_commands > NUM_HISTORY_ENTRIES) {
 a2c:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 a30:	7c020001 	stcvc	0, cr0, [r2], {1}
    beg_index = total_num_commands - NUM_HISTORY_ENTRIES;
 a34:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 a38:	0000000c 	andeq	r0, r0, ip
  uint32_t beg_index = 0;
 a3c:	00000a28 	andeq	r0, r0, r8, lsr #20
    printf("%s\n", cmd_history[index % NUM_HISTORY_ENTRIES]);
 a40:	000020fc 	strdeq	r2, [r0], -ip
 a44:	00000012 	andeq	r0, r0, r2, lsl r0
 a48:	0000000c 	andeq	r0, r0, ip
 a4c:	00000a28 	andeq	r0, r0, r8, lsr #20
  for (uint32_t index = beg_index; index <= end_index; ++index) {
 a50:	0000210e 	andeq	r2, r0, lr, lsl #2
}
 a54:	0000001a 	andeq	r0, r0, sl, lsl r0
 a58:	0000000c 	andeq	r0, r0, ip
 a5c:	00000a28 	andeq	r0, r0, r8, lsr #20
 a60:	00002128 	andeq	r2, r0, r8, lsr #2
int cmd_exec_status(int argc, char **argv) {
 a64:	00000014 	andeq	r0, r0, r4, lsl r0
  printf("%d\n", __cmd_exec_status);
 a68:	0000001c 	andeq	r0, r0, ip, lsl r0
 a6c:	00000a28 	andeq	r0, r0, r8, lsr #20
 a70:	0000213c 	andeq	r2, r0, ip, lsr r1
}
 a74:	00000024 	andeq	r0, r0, r4, lsr #32
 a78:	840c0e41 	strhi	r0, [ip], #-3649	@ 0xfffff1bf
 a7c:	8e028503 	cfsh32hi	mvfx8, mvfx2, #3
static int build_info(int argc, char **argv) {
 a80:	280e4101 	stmdacs	lr, {r0, r8, lr}
  printf("Build: [" SHELL_VERSION ":" USER_REPO_VERSION "] - [" BUILD_USER
 a84:	000c0e4f 	andeq	r0, ip, pc, asr #28
}
 a88:	0000000c 	andeq	r0, r0, ip
 a8c:	00000a28 	andeq	r0, r0, r8, lsr #20
static void execute(int argc, char **argv) {
 a90:	00002160 	andeq	r2, r0, r0, ror #2
 a94:	0000001e 	andeq	r0, r0, lr, lsl r0
  for (int i = 0; table[i].command_name != NULL; i++) {
 a98:	0000000c 	andeq	r0, r0, ip
 a9c:	00000a28 	andeq	r0, r0, r8, lsr #20
 aa0:	0000217e 	andeq	r2, r0, lr, ror r1
 aa4:	00000012 	andeq	r0, r0, r2, lsl r0
 aa8:	0000000c 	andeq	r0, r0, ip
    if (strcmp(argv[0], table[i].command_name) == 0) {
 aac:	00000a28 	andeq	r0, r0, r8, lsr #20
 ab0:	00002190 	muleq	r0, r0, r1
      __cmd_exec_status = table[i].command(argc, &argv[0]);
 ab4:	0000001a 	andeq	r0, r0, sl, lsl r0
 ab8:	0000000c 	andeq	r0, r0, ip
 abc:	00000a28 	andeq	r0, r0, r8, lsr #20
 ac0:	000021aa 	andeq	r2, r0, sl, lsr #3
 ac4:	0000002a 	andeq	r0, r0, sl, lsr #32
    printf("\"%s\": command not found. Use \"help\" to list all command.\n",
 ac8:	00000018 	andeq	r0, r0, r8, lsl r0
 acc:	00000a28 	andeq	r0, r0, r8, lsr #20
    __cmd_exec_status = -1;
 ad0:	000021d4 	ldrdeq	r2, [r0], -r4
 ad4:	00000074 	andeq	r0, r0, r4, ror r0
 ad8:	84040e41 	strhi	r0, [r4], #-3649	@ 0xfffff1bf
}
 adc:	c40a6001 	strgt	r6, [sl], #-1
 ae0:	0b41000e 	bleq	1040b20 <__ROM_SIZE__+0x1000b20>
 ae4:	0000000c 	andeq	r0, r0, ip
 ae8:	00000a28 	andeq	r0, r0, r8, lsr #20
int help(int argc, char **argv) {
 aec:	00002248 	andeq	r2, r0, r8, asr #4
  if (argc > 1 && (strcmp(argv[1], "-l")==0)) {
 af0:	00000014 	andeq	r0, r0, r4, lsl r0
 af4:	0000000c 	andeq	r0, r0, ip
 af8:	00000a28 	andeq	r0, r0, r8, lsr #20
 afc:	0000225c 	andeq	r2, r0, ip, asr r2
    printf("use: help -l for list only.\n\n");
 b00:	00000022 	andeq	r0, r0, r2, lsr #32
  bool verbose = true;
 b04:	00000018 	andeq	r0, r0, r8, lsl r0
    verbose = false;
 b08:	00000a28 	andeq	r0, r0, r8, lsr #20
    printf("\n");
 b0c:	0000227e 	andeq	r2, r0, lr, ror r2
    i++;
 b10:	00000022 	andeq	r0, r0, r2, lsr #32
  while (table[i].command_name != NULL) {
 b14:	84080e44 	strhi	r0, [r8], #-3652	@ 0xfffff1bc
 b18:	4b018502 	blmi	61f28 <__ROM_SIZE__+0x21f28>
 b1c:	000ec4c5 	andeq	ip, lr, r5, asr #9
    printf(table[i].command_name);
 b20:	0000000c 	andeq	r0, r0, ip
    if (verbose) {
 b24:	00000a28 	andeq	r0, r0, r8, lsr #20
      printf("\n\t");
 b28:	000022a0 	andeq	r2, r0, r0, lsr #5
      printf(table[i].command_help);
 b2c:	0000000a 	andeq	r0, r0, sl
 b30:	00000020 	andeq	r0, r0, r0, lsr #32
 b34:	00000a28 	andeq	r0, r0, r8, lsr #20
    verbose = false;
 b38:	000022aa 	andeq	r2, r0, sl, lsr #5
}
 b3c:	00000076 	andeq	r0, r0, r6, ror r0
 b40:	84100e41 	ldrhi	r0, [r0], #-3649	@ 0xfffff1bf
 b44:	86038504 	strhi	r8, [r3], -r4, lsl #10
 b48:	41018e02 	tstmi	r1, r2, lsl #28
 b4c:	0e76280e 	cdpeq	8, 7, cr2, cr6, cr14, {0}
 b50:	00000010 	andeq	r0, r0, r0, lsl r0
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
 b54:	00000020 	andeq	r0, r0, r0, lsr #32
static void add_command_to_history(const char *cmd_str) {
 b58:	00000a28 	andeq	r0, r0, r8, lsr #20
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
 b5c:	00002320 	andeq	r2, r0, r0, lsr #6
 b60:	00000084 	andeq	r0, r0, r4, lsl #1
  int index = total_num_commands % NUM_HISTORY_ENTRIES;
 b64:	84140e41 	ldrhi	r0, [r4], #-3649	@ 0xfffff1bf
 b68:	86048505 	strhi	r8, [r4], -r5, lsl #10
 b6c:	8e028703 	cdphi	7, 0, cr8, cr2, cr3, {0}
 b70:	780e4101 	stmdavc	lr, {r0, r8, lr}
  memcpy(&cmd_history[index], cmd_str, LINE_BUFF_SIZE);
 b74:	00140e7c 	andseq	r0, r4, ip, ror lr
 b78:	00000018 	andeq	r0, r0, r8, lsl r0
 b7c:	00000a28 	andeq	r0, r0, r8, lsr #20
 b80:	000023a4 	andeq	r2, r0, r4, lsr #7
  total_num_commands++;
 b84:	00000016 	andeq	r0, r0, r6, lsl r0
  curr_command_ptr = total_num_commands;
 b88:	83100e41 	tsthi	r0, #1040	@ 0x410
 b8c:	85038404 	strhi	r8, [r3, #-1028]	@ 0xfffffbfc
 b90:	00018e02 	andeq	r8, r1, r2, lsl #28
 b94:	00000014 	andeq	r0, r0, r4, lsl r0
 b98:	00000a28 	andeq	r0, r0, r8, lsr #20
static int parse_line(char **argv, char *line_buff, int argument_size) {
 b9c:	000023ba 			@ <UNDEFINED> instruction: 0x000023ba
 ba0:	00000010 	andeq	r0, r0, r0, lsl r0
  int length = strlen(line_buff);
 ba4:	84080e41 	strhi	r0, [r8], #-3649	@ 0xfffff1bf
 ba8:	00018e02 	andeq	r8, r1, r2, lsl #28
  int argc = 0;
 bac:	00000014 	andeq	r0, r0, r4, lsl r0
         pos++)
 bb0:	00000a28 	andeq	r0, r0, r8, lsr #20
    for (; line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
 bb4:	000023ca 	andeq	r2, r0, sl, asr #7
 bb8:	00000016 	andeq	r0, r0, r6, lsl r0
 bbc:	84080e41 	strhi	r0, [r8], #-3649	@ 0xfffff1bf
 bc0:	00018e02 	andeq	r8, r1, r2, lsl #28
    if (line_buff[pos] == '\t' || line_buff[pos] == SPACE)
 bc4:	00000020 	andeq	r0, r0, r0, lsr #32
 bc8:	00000a28 	andeq	r0, r0, r8, lsr #20
      line_buff[pos] = END_OF_LINE;
 bcc:	000023e0 	andeq	r2, r0, r0, ror #7
  while (pos <= length) {
 bd0:	0000006e 	andeq	r0, r0, lr, rrx
    if (line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
 bd4:	840c0e41 	strhi	r0, [ip], #-3649	@ 0xfffff1bf
 bd8:	8e028503 	cfsh32hi	mvfx8, mvfx2, #3
 bdc:	280e4101 	stmdacs	lr, {r0, r8, lr}
 be0:	0c0e0a49 			@ <UNDEFINED> instruction: 0x0c0e0a49
      argv[argc++] = &line_buff[pos];
 be4:	00000b41 	andeq	r0, r0, r1, asr #22
 be8:	00000024 	andeq	r0, r0, r4, lsr #32
}
 bec:	00000a28 	andeq	r0, r0, r8, lsr #20
static int prefix_match(char *sub, int len, const char *str) {
 bf0:	0000244e 	andeq	r2, r0, lr, asr #8
 bf4:	000000d4 	ldrdeq	r0, [r0], -r4
  if (sub == NULL || str == NULL || len <= 0 || len > strlen(str)) {
 bf8:	84140e41 	ldrhi	r0, [r4], #-3649	@ 0xfffff1bf
 bfc:	86048505 	strhi	r8, [r4], -r5, lsl #10
 c00:	8e028703 	cdphi	7, 0, cr8, cr2, cr3, {0}
 c04:	780e4101 	stmdavc	lr, {r0, r8, lr}
  for (int i = 0; i<len; ++i) {
 c08:	140e0a64 	strne	r0, [lr], #-2660	@ 0xfffff59c
 c0c:	00000b41 	andeq	r0, r0, r1, asr #22
    if (sub[i] != str[i]) {
 c10:	00000020 	andeq	r0, r0, r0, lsr #32
 c14:	00000a28 	andeq	r0, r0, r8, lsr #20
  for (int i = 0; i<len; ++i) {
 c18:	00002522 	andeq	r2, r0, r2, lsr #10
}
 c1c:	00000056 	andeq	r0, r0, r6, asr r0
  return TRUE;
 c20:	84140e41 	ldrhi	r0, [r4], #-3649	@ 0xfffff1bf
      return FALSE;
 c24:	86048505 	strhi	r8, [r4], -r5, lsl #10
}
 c28:	8e028703 	cdphi	7, 0, cr8, cr2, cr3, {0}
static void handle_up_arrow(char *cmd_buff, int *char_count) {
 c2c:	480e4101 	stmdami	lr, {r0, r8, lr}
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
 c30:	00140e68 	andseq	r0, r4, r8, ror #28
 c34:	00000020 	andeq	r0, r0, r0, lsr #32
 c38:	00000a28 	andeq	r0, r0, r8, lsr #20
 c3c:	00002578 	andeq	r2, r0, r8, ror r5
      curr_command_ptr == 0) {
 c40:	00000068 	andeq	r0, r0, r8, rrx
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
 c44:	840c0e41 	strhi	r0, [ip], #-3649	@ 0xfffff1bf
    printf("%s", cmd_buff);
 c48:	8e028503 	cfsh32hi	mvfx8, mvfx2, #3
 c4c:	400e4101 	andmi	r4, lr, r1, lsl #2
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
 c50:	0c0e0a47 			@ <UNDEFINED> instruction: 0x0c0e0a47
 c54:	00000b41 	andeq	r0, r0, r1, asr #22
  curr_command_ptr--;
 c58:	0000001c 	andeq	r0, r0, ip, lsl r0
 c5c:	00000a28 	andeq	r0, r0, r8, lsr #20
 c60:	000025e0 	andeq	r2, r0, r0, ror #11
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
 c64:	00000054 	andeq	r0, r0, r4, asr r0
 c68:	83180e41 	tsthi	r8, #1040	@ 0x410
 c6c:	85058406 	strhi	r8, [r5, #-1030]	@ 0xfffffbfa
 c70:	87038604 	strhi	r8, [r3, -r4, lsl #12]
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
 c74:	00018e02 	andeq	r8, r1, r2, lsl #28
 c78:	0000001c 	andeq	r0, r0, ip, lsl r0
 c7c:	00000a28 	andeq	r0, r0, r8, lsr #20
  *char_count = strlen(cmd_buff);
 c80:	00002634 	andeq	r2, r0, r4, lsr r6
 c84:	00000048 	andeq	r0, r0, r8, asr #32
  printf("%s", cmd_buff);
 c88:	83180e41 	tsthi	r8, #1040	@ 0x410
 c8c:	85058406 	strhi	r8, [r5, #-1030]	@ 0xfffffbfa
 c90:	87038604 	strhi	r8, [r3, -r4, lsl #12]
 c94:	00018e02 	andeq	r8, r1, r2, lsl #28
 c98:	0000000c 	andeq	r0, r0, ip
static void handle_down_arrow(char *cmd_buff, int *char_count) {
 c9c:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 ca0:	7c020001 	stcvc	0, cr0, [r2], {1}
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
 ca4:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 ca8:	0000000c 	andeq	r0, r0, ip
  *char_count = 0;
 cac:	00000c98 	muleq	r0, r8, ip
  if (curr_command_ptr == total_num_commands) return;
 cb0:	0000267c 	andeq	r2, r0, ip, ror r6
 cb4:	0000001e 	andeq	r0, r0, lr, lsl r0
 cb8:	0000000c 	andeq	r0, r0, ip
  curr_command_ptr++;
 cbc:	00000c98 	muleq	r0, r8, ip
 cc0:	0000269a 	muleq	r0, sl, r6
 cc4:	0000003e 	andeq	r0, r0, lr, lsr r0
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
 cc8:	0000000c 	andeq	r0, r0, ip
 ccc:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 cd0:	7c020001 	stcvc	0, cr0, [r2], {1}
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
 cd4:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 cd8:	00000020 	andeq	r0, r0, r0, lsr #32
 cdc:	00000cc8 	andeq	r0, r0, r8, asr #25
 ce0:	000026d8 	ldrdeq	r2, [r0], -r8
  *char_count = strlen(cmd_buff);
 ce4:	00000040 	andeq	r0, r0, r0, asr #32
 ce8:	84100e44 	ldrhi	r0, [r0], #-3652	@ 0xfffff1bc
  printf("%s", cmd_buff);
 cec:	86038504 	strhi	r8, [r3], -r4, lsl #10
 cf0:	59018e02 	stmdbpl	r1, {r1, r9, sl, fp, pc}
}
 cf4:	c5c4000e 	strbgt	r0, [r4, #14]
 cf8:	0000cec6 	andeq	ip, r0, r6, asr #29
void set_read_char(int (*func)(void)) { __read_char__ = func; }
 cfc:	0000000c 	andeq	r0, r0, ip
 d00:	00000cc8 	andeq	r0, r0, r8, asr #25
 d04:	00002718 	andeq	r2, r0, r8, lsl r7
void set_read_char2(int (*func)(void)) { __read_char2__ = func; }
 d08:	00000040 	andeq	r0, r0, r0, asr #32
 d0c:	0000000c 	andeq	r0, r0, ip
 d10:	00000cc8 	andeq	r0, r0, r8, asr #25
void set_write_char(void (*func)(char)) { __write_char__ = func; }
 d14:	00002758 	andeq	r2, r0, r8, asr r7
 d18:	0000002c 	andeq	r0, r0, ip, lsr #32
 d1c:	0000000c 	andeq	r0, r0, ip
void set_write_char2(void (*func)(char)) { __write_char2__ = func; }
 d20:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 d24:	7c020001 	stcvc	0, cr0, [r2], {1}
 d28:	000d0c0e 	andeq	r0, sp, lr, lsl #24
}
 d2c:	0000000c 	andeq	r0, r0, ip
}
 d30:	00000d1c 	andeq	r0, r0, ip, lsl sp
  if (cmd_buff == NULL || char_count <= 0) {
 d34:	00002784 	andeq	r2, r0, r4, lsl #15
static void handle_tab(char *cmd_buff, int *char_count) {
 d38:	00000010 	andeq	r0, r0, r0, lsl r0
 d3c:	0000000c 	andeq	r0, r0, ip
  int last_match = -1;
 d40:	00000d1c 	andeq	r0, r0, ip, lsl sp
  int match_count = 0;
 d44:	00002794 	muleq	r0, r4, r7
  int i = 0;
 d48:	00000016 	andeq	r0, r0, r6, lsl r0
    i++;
 d4c:	0000000c 	andeq	r0, r0, ip
  while (table[i].command_name != NULL) { //loop over all commands
 d50:	00000d1c 	andeq	r0, r0, ip, lsl sp
 d54:	000027aa 	andeq	r2, r0, sl, lsr #15
 d58:	00000014 	andeq	r0, r0, r4, lsl r0
    if (prefix_match(cmd_buff, *char_count, table[i].command_name)) {
 d5c:	0000000c 	andeq	r0, r0, ip
 d60:	00000d1c 	andeq	r0, r0, ip, lsl sp
 d64:	000027be 			@ <UNDEFINED> instruction: 0x000027be
      match_count++;
 d68:	00000016 	andeq	r0, r0, r6, lsl r0
      printf("\n%s", table[i].command_name);
 d6c:	0000000c 	andeq	r0, r0, ip
 d70:	00000d1c 	andeq	r0, r0, ip, lsl sp
      last_match = i;
 d74:	000027d4 	ldrdeq	r2, [r0], -r4
  if (match_count == 1) {
 d78:	00000010 	andeq	r0, r0, r0, lsl r0

Disassembly of section .debug_rnglists:

00000000 <.debug_rnglists>:
   0:	00000013 	andeq	r0, r0, r3, lsl r0
   4:	00040005 	andeq	r0, r4, r5
   8:	00000000 	andeq	r0, r0, r0
   c:	b605a404 	strlt	sl, [r5], -r4, lsl #8
  10:	05bc0405 	ldreq	r0, [ip, #1029]!	@ 0x405
  14:	3e0005c2 	cfsh32cc	mvfx0, mvfx0, #-30
  18:	05000000 	streq	r0, [r0, #-0]
  1c:	00000400 	andeq	r0, r0, r0, lsl #8
  20:	04000000 	streq	r0, [r0], #-0
  24:	50044e30 	andpl	r4, r4, r0, lsr lr
  28:	01ca0452 	biceq	r0, sl, r2, asr r4
  2c:	9204028e 	andls	r0, r4, #-536870904	@ 0xe0000008
  30:	0402ba02 	streq	fp, [r2], #-2562	@ 0xfffff5fe
  34:	02dc02c2 	sbcseq	r0, ip, #536870924	@ 0x2000000c
  38:	02920400 	addseq	r0, r2, #0, 8
  3c:	a40402a0 	strge	r0, [r4], #-672	@ 0xfffffd60
  40:	0002b402 	andeq	fp, r2, r2, lsl #8
  44:	01c66204 	biceq	r6, r6, r4, lsl #4
  48:	c202be04 	andgt	fp, r2, #4, 28	@ 0x40
  4c:	ee040002 	cdp	0, 0, cr0, cr4, cr2, {0}
  50:	04048e03 	streq	r8, [r4], #-3587	@ 0xfffff1fd
  54:	04a2049e 	strteq	r0, [r2], #1182	@ 0x49e
  58:	00003e00 	andeq	r3, r0, r0, lsl #28
  5c:	04000500 	streq	r0, [r0], #-1280	@ 0xfffffb00
  60:	00000000 	andeq	r0, r0, r0
  64:	4e300400 	cfabssmi	mvf0, mvf0
  68:	04525004 	ldrbeq	r5, [r2], #-4
  6c:	028e01ca 	addeq	r0, lr, #-2147483598	@ 0x80000032
  70:	ba029204 	blt	a4888 <__ROM_SIZE__+0x64888>
  74:	02c20402 	sbceq	r0, r2, #33554432	@ 0x2000000
  78:	040002dc 	streq	r0, [r0], #-732	@ 0xfffffd24
  7c:	02a00292 	adceq	r0, r0, #536870921	@ 0x20000009
  80:	b402a404 	strlt	sl, [r2], #-1028	@ 0xfffffbfc
  84:	62040002 	andvs	r0, r4, #2
  88:	be0401c6 	adfltdm	f0, f4, f6
  8c:	0002c202 	andeq	ip, r2, r2, lsl #4
  90:	8e03ee04 	cdphi	14, 0, cr14, cr3, cr4, {0}
  94:	049e0404 	ldreq	r0, [lr], #1028	@ 0x404
  98:	110004a2 	smlatbne	r0, r2, r4, r0
  9c:	05000000 	streq	r0, [r0, #-0]
  a0:	00000400 	andeq	r0, r0, r0, lsl #8
  a4:	04000000 	streq	r0, [r0], #-0
  a8:	8a047c78 	bhi	11f290 <__ROM_SIZE__+0xdf290>
  ac:	00019c01 	andeq	r9, r1, r1, lsl #24
  b0:	0000001e 	andeq	r0, r0, lr, lsl r0
  b4:	00040005 	andeq	r0, r4, r5
  b8:	00000000 	andeq	r0, r0, r0
  bc:	d001c404 	andle	ip, r1, r4, lsl #8
  c0:	01d20401 	bicseq	r0, r2, r1, lsl #8
  c4:	040001d8 	streq	r0, [r0], #-472	@ 0xfffffe28
  c8:	02c6029c 	sbceq	r0, r6, #156, 4	@ 0xc0000009
  cc:	cc02c804 	stcgt	8, cr12, [r2], {4}
  d0:	00160002 	andseq	r0, r6, r2
  d4:	00050000 	andeq	r0, r5, r0
  d8:	00000004 	andeq	r0, r0, r4
  dc:	02040000 	andeq	r0, r4, #0
  e0:	1c060404 	cfstrsne	mvf0, [r6], {4}
  e4:	22200400 	eorcs	r0, r0, #0, 8
  e8:	005a2404 	subseq	r2, sl, r4, lsl #8
