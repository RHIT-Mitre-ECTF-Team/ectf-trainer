
shell.elf:     file format elf32-littlearm


Disassembly of section .data:

20000000 <__echo>:
20000000:	Address 0x20000000 is out of bounds.


Disassembly of section .bss:

20000004 <_bss>:
20000004:	00000000 	andeq	r0, r0, r0

20000008 <__write_char__>:
#include "shell_config.h"
#include "string.h"

int (*__read_char__)(void);
int (*__read_char2__)(void);
void (*__write_char__)(char c);
20000008:	00000000 	andeq	r0, r0, r0

2000000c <total_num_commands>:
 * To reduce the shell size the history feature
 * is made optional. Skip history feature if
 * SHELL_NO_HISTORY is defined.
 */
#ifndef SHELL_NO_HISTORY
static volatile int total_num_commands = 0;
2000000c:	00000000 	andeq	r0, r0, r0

20000010 <cmd_history>:
	...

20000110 <__cmd_exec_status>:
static volatile int __cmd_exec_status;
20000110:	00000000 	andeq	r0, r0, r0

20000114 <curr_command_ptr>:
static volatile int curr_command_ptr = 0;
20000114:	00000000 	andeq	r0, r0, r0

20000118 <__read_char__>:
int (*__read_char__)(void);
20000118:	00000000 	andeq	r0, r0, r0

2000011c <__read_char2__>:
int (*__read_char2__)(void);
2000011c:	00000000 	andeq	r0, r0, r0

20000120 <__write_char2__>:
void (*__write_char2__)(char c);
20000120:	00000000 	andeq	r0, r0, r0

20000124 <selected_mode>:

#include "memlog.h"
#include "string.h"

static rgn_info_t inp_buf_rgn, out_buf_rgn;
static mode_t selected_mode = NONE;
20000124:	00000000 	andeq	r0, r0, r0

20000128 <out_buf_rgn>:
	...

20000134 <inp_buf_rgn>:
	...

Disassembly of section .text:

00000000 <vector_table>:
       0:	20007ffc 	strdcs	r7, [r0], -ip
       4:	00002259 	andeq	r2, r0, r9, asr r2
       8:	00000425 	andeq	r0, r0, r5, lsr #8
       c:	00000425 	andeq	r0, r0, r5, lsr #8
      10:	00000425 	andeq	r0, r0, r5, lsr #8
      14:	00000425 	andeq	r0, r0, r5, lsr #8
      18:	00000425 	andeq	r0, r0, r5, lsr #8
	...
      2c:	00000425 	andeq	r0, r0, r5, lsr #8
      30:	00000425 	andeq	r0, r0, r5, lsr #8
      34:	00000425 	andeq	r0, r0, r5, lsr #8
	...
      40:	00000425 	andeq	r0, r0, r5, lsr #8
      44:	00000425 	andeq	r0, r0, r5, lsr #8
      48:	00000425 	andeq	r0, r0, r5, lsr #8
      4c:	00000425 	andeq	r0, r0, r5, lsr #8
      50:	00000425 	andeq	r0, r0, r5, lsr #8
      54:	00000425 	andeq	r0, r0, r5, lsr #8
      58:	00000425 	andeq	r0, r0, r5, lsr #8
      5c:	00000425 	andeq	r0, r0, r5, lsr #8
      60:	00000425 	andeq	r0, r0, r5, lsr #8
      64:	00000425 	andeq	r0, r0, r5, lsr #8
      68:	00000425 	andeq	r0, r0, r5, lsr #8
      6c:	00000425 	andeq	r0, r0, r5, lsr #8
      70:	00000425 	andeq	r0, r0, r5, lsr #8
      74:	00000425 	andeq	r0, r0, r5, lsr #8
      78:	00000425 	andeq	r0, r0, r5, lsr #8
      7c:	00000425 	andeq	r0, r0, r5, lsr #8
      80:	00000425 	andeq	r0, r0, r5, lsr #8
      84:	00000425 	andeq	r0, r0, r5, lsr #8
      88:	00000425 	andeq	r0, r0, r5, lsr #8
      8c:	00000425 	andeq	r0, r0, r5, lsr #8
      90:	00000425 	andeq	r0, r0, r5, lsr #8
      94:	00000425 	andeq	r0, r0, r5, lsr #8
      98:	00000425 	andeq	r0, r0, r5, lsr #8
      9c:	00000425 	andeq	r0, r0, r5, lsr #8
      a0:	00000425 	andeq	r0, r0, r5, lsr #8
      a4:	00000425 	andeq	r0, r0, r5, lsr #8
      a8:	00000425 	andeq	r0, r0, r5, lsr #8
      ac:	00000425 	andeq	r0, r0, r5, lsr #8
      b0:	00000425 	andeq	r0, r0, r5, lsr #8
      b4:	00000425 	andeq	r0, r0, r5, lsr #8
      b8:	00000425 	andeq	r0, r0, r5, lsr #8
      bc:	00000425 	andeq	r0, r0, r5, lsr #8
      c0:	00000425 	andeq	r0, r0, r5, lsr #8
      c4:	00000425 	andeq	r0, r0, r5, lsr #8
      c8:	00000425 	andeq	r0, r0, r5, lsr #8
      cc:	00000425 	andeq	r0, r0, r5, lsr #8
      d0:	00000425 	andeq	r0, r0, r5, lsr #8
      d4:	00000425 	andeq	r0, r0, r5, lsr #8
      d8:	00000425 	andeq	r0, r0, r5, lsr #8
      dc:	00000425 	andeq	r0, r0, r5, lsr #8
      e0:	00000425 	andeq	r0, r0, r5, lsr #8
      e4:	00000425 	andeq	r0, r0, r5, lsr #8
      e8:	00000425 	andeq	r0, r0, r5, lsr #8
      ec:	00000425 	andeq	r0, r0, r5, lsr #8
      f0:	00000425 	andeq	r0, r0, r5, lsr #8
      f4:	00000425 	andeq	r0, r0, r5, lsr #8
      f8:	00000425 	andeq	r0, r0, r5, lsr #8
      fc:	00000425 	andeq	r0, r0, r5, lsr #8
     100:	00000425 	andeq	r0, r0, r5, lsr #8
     104:	00000425 	andeq	r0, r0, r5, lsr #8
     108:	00000425 	andeq	r0, r0, r5, lsr #8
     10c:	00000425 	andeq	r0, r0, r5, lsr #8
     110:	00000425 	andeq	r0, r0, r5, lsr #8
     114:	00000425 	andeq	r0, r0, r5, lsr #8
     118:	00000425 	andeq	r0, r0, r5, lsr #8
     11c:	00000425 	andeq	r0, r0, r5, lsr #8
     120:	00000425 	andeq	r0, r0, r5, lsr #8
     124:	00000425 	andeq	r0, r0, r5, lsr #8
     128:	00000425 	andeq	r0, r0, r5, lsr #8
     12c:	00000425 	andeq	r0, r0, r5, lsr #8
     130:	00000425 	andeq	r0, r0, r5, lsr #8
     134:	00000425 	andeq	r0, r0, r5, lsr #8
     138:	00000425 	andeq	r0, r0, r5, lsr #8
     13c:	00000425 	andeq	r0, r0, r5, lsr #8
     140:	00000425 	andeq	r0, r0, r5, lsr #8
     144:	00000425 	andeq	r0, r0, r5, lsr #8
     148:	00000425 	andeq	r0, r0, r5, lsr #8
     14c:	00000425 	andeq	r0, r0, r5, lsr #8
     150:	00000425 	andeq	r0, r0, r5, lsr #8
     154:	00000425 	andeq	r0, r0, r5, lsr #8
     158:	00000425 	andeq	r0, r0, r5, lsr #8
     15c:	00000425 	andeq	r0, r0, r5, lsr #8
     160:	00000425 	andeq	r0, r0, r5, lsr #8
     164:	00000425 	andeq	r0, r0, r5, lsr #8
     168:	00000425 	andeq	r0, r0, r5, lsr #8
     16c:	00000425 	andeq	r0, r0, r5, lsr #8
     170:	00000425 	andeq	r0, r0, r5, lsr #8
     174:	00000425 	andeq	r0, r0, r5, lsr #8
     178:	00000425 	andeq	r0, r0, r5, lsr #8
     17c:	00000425 	andeq	r0, r0, r5, lsr #8
     180:	00000425 	andeq	r0, r0, r5, lsr #8
     184:	00000425 	andeq	r0, r0, r5, lsr #8
     188:	00000425 	andeq	r0, r0, r5, lsr #8
     18c:	00000425 	andeq	r0, r0, r5, lsr #8
     190:	00000425 	andeq	r0, r0, r5, lsr #8
     194:	00000425 	andeq	r0, r0, r5, lsr #8
     198:	00000425 	andeq	r0, r0, r5, lsr #8
     19c:	00000425 	andeq	r0, r0, r5, lsr #8
     1a0:	00000425 	andeq	r0, r0, r5, lsr #8
     1a4:	00000425 	andeq	r0, r0, r5, lsr #8
     1a8:	00000425 	andeq	r0, r0, r5, lsr #8
     1ac:	00000425 	andeq	r0, r0, r5, lsr #8
     1b0:	00000425 	andeq	r0, r0, r5, lsr #8
     1b4:	00000425 	andeq	r0, r0, r5, lsr #8
     1b8:	00000425 	andeq	r0, r0, r5, lsr #8
     1bc:	00000425 	andeq	r0, r0, r5, lsr #8
     1c0:	00000425 	andeq	r0, r0, r5, lsr #8
     1c4:	00000425 	andeq	r0, r0, r5, lsr #8
     1c8:	00000425 	andeq	r0, r0, r5, lsr #8
     1cc:	00000425 	andeq	r0, r0, r5, lsr #8
     1d0:	00000425 	andeq	r0, r0, r5, lsr #8
     1d4:	00000425 	andeq	r0, r0, r5, lsr #8
     1d8:	00000425 	andeq	r0, r0, r5, lsr #8
     1dc:	00000425 	andeq	r0, r0, r5, lsr #8
     1e0:	00000425 	andeq	r0, r0, r5, lsr #8
     1e4:	00000425 	andeq	r0, r0, r5, lsr #8
     1e8:	00000425 	andeq	r0, r0, r5, lsr #8
     1ec:	00000425 	andeq	r0, r0, r5, lsr #8
     1f0:	00000425 	andeq	r0, r0, r5, lsr #8
     1f4:	00000425 	andeq	r0, r0, r5, lsr #8
     1f8:	00000425 	andeq	r0, r0, r5, lsr #8
     1fc:	00000425 	andeq	r0, r0, r5, lsr #8
     200:	00000425 	andeq	r0, r0, r5, lsr #8
     204:	00000425 	andeq	r0, r0, r5, lsr #8
     208:	00000425 	andeq	r0, r0, r5, lsr #8
     20c:	00000425 	andeq	r0, r0, r5, lsr #8
     210:	00000425 	andeq	r0, r0, r5, lsr #8
     214:	00000425 	andeq	r0, r0, r5, lsr #8
     218:	00000425 	andeq	r0, r0, r5, lsr #8
     21c:	00000425 	andeq	r0, r0, r5, lsr #8
     220:	00000425 	andeq	r0, r0, r5, lsr #8
     224:	00000425 	andeq	r0, r0, r5, lsr #8
     228:	00000425 	andeq	r0, r0, r5, lsr #8
     22c:	00000425 	andeq	r0, r0, r5, lsr #8
     230:	00000425 	andeq	r0, r0, r5, lsr #8
     234:	00000425 	andeq	r0, r0, r5, lsr #8
     238:	00000425 	andeq	r0, r0, r5, lsr #8
     23c:	00000425 	andeq	r0, r0, r5, lsr #8
     240:	00000425 	andeq	r0, r0, r5, lsr #8
     244:	00000425 	andeq	r0, r0, r5, lsr #8
     248:	00000425 	andeq	r0, r0, r5, lsr #8
     24c:	00000425 	andeq	r0, r0, r5, lsr #8
	...

000003c0 <car_mesg>:

#include "shell.h"


int car_mesg(int argc, char** argv) {
     3c0:	b570      	push	{r4, r5, r6, lr}
     3c2:	4605      	mov	r5, r0
     3c4:	460e      	mov	r6, r1
    int ctr;
    printf("Received the message:");
     3c6:	4811      	ldr	r0, [pc, #68]	@ (40c <car_mesg+0x4c>)
     3c8:	f000 feb0 	bl	112c <printf>
    for (ctr = 1; ctr < argc; ctr++) {
     3cc:	2401      	movs	r4, #1
     3ce:	e005      	b.n	3dc <car_mesg+0x1c>
        printf(" %s", argv[ctr]);
     3d0:	f856 1024 	ldr.w	r1, [r6, r4, lsl #2]
     3d4:	480e      	ldr	r0, [pc, #56]	@ (410 <car_mesg+0x50>)
     3d6:	f000 fea9 	bl	112c <printf>
    for (ctr = 1; ctr < argc; ctr++) {
     3da:	3401      	adds	r4, #1
     3dc:	42ac      	cmp	r4, r5
     3de:	dbf7      	blt.n	3d0 <car_mesg+0x10>
    }
    printf("\n");
     3e0:	480c      	ldr	r0, [pc, #48]	@ (414 <car_mesg+0x54>)
     3e2:	f000 fea3 	bl	112c <printf>

    if (argc > 0) {
     3e6:	2d00      	cmp	r5, #0
     3e8:	dc01      	bgt.n	3ee <car_mesg+0x2e>
            printf("Didn't know how to handle %s\n", argv[1]);
        }

    }
    return 0;
}
     3ea:	2000      	movs	r0, #0
     3ec:	bd70      	pop	{r4, r5, r6, pc}
        if (strcmp(argv[1], "PING_REPLY") == 0) {
     3ee:	490a      	ldr	r1, [pc, #40]	@ (418 <car_mesg+0x58>)
     3f0:	6870      	ldr	r0, [r6, #4]
     3f2:	f001 ff09 	bl	2208 <strcmp>
     3f6:	b918      	cbnz	r0, 400 <car_mesg+0x40>
            printf("Got a ping reply.\n");
     3f8:	4808      	ldr	r0, [pc, #32]	@ (41c <car_mesg+0x5c>)
     3fa:	f000 fe97 	bl	112c <printf>
     3fe:	e7f4      	b.n	3ea <car_mesg+0x2a>
            printf("Didn't know how to handle %s\n", argv[1]);
     400:	6871      	ldr	r1, [r6, #4]
     402:	4807      	ldr	r0, [pc, #28]	@ (420 <car_mesg+0x60>)
     404:	f000 fe92 	bl	112c <printf>
     408:	e7ef      	b.n	3ea <car_mesg+0x2a>
     40a:	bf00      	nop
     40c:	00002328 	andeq	r2, r0, r8, lsr #6
     410:	00002340 	andeq	r2, r0, r0, asr #6
     414:	0000286c 	andeq	r2, r0, ip, ror #16
     418:	00002344 	andeq	r2, r0, r4, asr #6
     41c:	00002350 	andeq	r2, r0, r0, asr r3
     420:	00002364 	andeq	r2, r0, r4, ror #6

00000424 <default_handler>:

extern int _STACK_TOP_;
extern void reset_handler(void);

void default_handler(void) {
  while (1)
     424:	e7fe      	b.n	424 <default_handler>
	...

00000428 <uputc>:
 * limitations under the License.
 **/

#include "uart.h"

void uputc(char c) {
     428:	b508      	push	{r3, lr}
  while ((UARTFR >> 5) & 1)
     42a:	4b07      	ldr	r3, [pc, #28]	@ (448 <uputc+0x20>)
     42c:	699b      	ldr	r3, [r3, #24]
     42e:	f013 0f20 	tst.w	r3, #32
     432:	d1fa      	bne.n	42a <uputc+0x2>
    ;

  UART_DR = c;
     434:	4b04      	ldr	r3, [pc, #16]	@ (448 <uputc+0x20>)
     436:	6018      	str	r0, [r3, #0]
  if (c == '\n')
     438:	280a      	cmp	r0, #10
     43a:	d000      	beq.n	43e <uputc+0x16>
    uputc('\r');
}
     43c:	bd08      	pop	{r3, pc}
    uputc('\r');
     43e:	200d      	movs	r0, #13
     440:	f7ff fff2 	bl	428 <uputc>
}
     444:	e7fa      	b.n	43c <uputc+0x14>
     446:	bf00      	nop
     448:	4000c000 	andmi	ip, r0, r0

0000044c <ugetc>:

int ugetc(void) {
  if (!((UARTFR >> 4) & 1)) return UART_DR;
     44c:	4b05      	ldr	r3, [pc, #20]	@ (464 <ugetc+0x18>)
     44e:	699b      	ldr	r3, [r3, #24]
     450:	f013 0f10 	tst.w	r3, #16
     454:	d102      	bne.n	45c <ugetc+0x10>
     456:	4b03      	ldr	r3, [pc, #12]	@ (464 <ugetc+0x18>)
     458:	6818      	ldr	r0, [r3, #0]
     45a:	4770      	bx	lr

  return -1;
     45c:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
}
     460:	4770      	bx	lr
     462:	bf00      	nop
     464:	4000c000 	andmi	ip, r0, r0

00000468 <uart_init>:

void uart_init(void) {
  /* Disable UART0 */
  UARTCTL = 0;
     468:	4b07      	ldr	r3, [pc, #28]	@ (488 <uart_init+0x20>)
     46a:	2200      	movs	r2, #0
     46c:	631a      	str	r2, [r3, #48]	@ 0x30

  /* Set the Baud to 115200 */
  UARTIBRD = 8;
     46e:	2108      	movs	r1, #8
     470:	6259      	str	r1, [r3, #36]	@ 0x24
  UARTFBRD = 44;
     472:	212c      	movs	r1, #44	@ 0x2c
     474:	6299      	str	r1, [r3, #40]	@ 0x28

  /* Use system clock for Uart */
  UARTCC = 0;
     476:	f8c3 2fc8 	str.w	r2, [r3, #4040]	@ 0xfc8

  /* 8n1 and no fifo */
  UARTLCRH = 0x60;
     47a:	2260      	movs	r2, #96	@ 0x60
     47c:	62da      	str	r2, [r3, #44]	@ 0x2c

  /* Enable UART0, TXE and RXE */
  UARTCTL = 0x301;
     47e:	f240 3201 	movw	r2, #769	@ 0x301
     482:	631a      	str	r2, [r3, #48]	@ 0x30
}
     484:	4770      	bx	lr
     486:	bf00      	nop
     488:	4000c000 	andmi	ip, r0, r0

0000048c <u2putc>:
 * limitations under the License.
 **/

#include "uart2.h"

void u2putc(char c) {
     48c:	b508      	push	{r3, lr}
  while ((UART2FR >> 5) & 1)
     48e:	4b07      	ldr	r3, [pc, #28]	@ (4ac <u2putc+0x20>)
     490:	699b      	ldr	r3, [r3, #24]
     492:	f013 0f20 	tst.w	r3, #32
     496:	d1fa      	bne.n	48e <u2putc+0x2>
    ;

  UART2_DR = c;
     498:	4b04      	ldr	r3, [pc, #16]	@ (4ac <u2putc+0x20>)
     49a:	6018      	str	r0, [r3, #0]
  if (c == '\n')
     49c:	280a      	cmp	r0, #10
     49e:	d000      	beq.n	4a2 <u2putc+0x16>
    u2putc('\r');
}
     4a0:	bd08      	pop	{r3, pc}
    u2putc('\r');
     4a2:	200d      	movs	r0, #13
     4a4:	f7ff fff2 	bl	48c <u2putc>
}
     4a8:	e7fa      	b.n	4a0 <u2putc+0x14>
     4aa:	bf00      	nop
     4ac:	4000d000 	andmi	sp, r0, r0

000004b0 <u2getc>:

int u2getc(void) {
  if (!((UART2FR >> 4) & 1)) return UART2_DR;
     4b0:	4b05      	ldr	r3, [pc, #20]	@ (4c8 <u2getc+0x18>)
     4b2:	699b      	ldr	r3, [r3, #24]
     4b4:	f013 0f10 	tst.w	r3, #16
     4b8:	d102      	bne.n	4c0 <u2getc+0x10>
     4ba:	4b03      	ldr	r3, [pc, #12]	@ (4c8 <u2getc+0x18>)
     4bc:	6818      	ldr	r0, [r3, #0]
     4be:	4770      	bx	lr

  return -1;
     4c0:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
}
     4c4:	4770      	bx	lr
     4c6:	bf00      	nop
     4c8:	4000d000 	andmi	sp, r0, r0

000004cc <uart2_init>:

void uart2_init(void) {
  /* Disable the UART */
  UART2CTL = 0;
     4cc:	4b07      	ldr	r3, [pc, #28]	@ (4ec <uart2_init+0x20>)
     4ce:	2200      	movs	r2, #0
     4d0:	631a      	str	r2, [r3, #48]	@ 0x30

  /* Set the Baud to 115200 */
  UART2IBRD = 8;
     4d2:	2108      	movs	r1, #8
     4d4:	6259      	str	r1, [r3, #36]	@ 0x24
  UART2FBRD = 44;
     4d6:	212c      	movs	r1, #44	@ 0x2c
     4d8:	6299      	str	r1, [r3, #40]	@ 0x28

  /* Use system clock for Uart */
  UART2CC = 0;
     4da:	f8c3 2fc8 	str.w	r2, [r3, #4040]	@ 0xfc8

  /* 8n1 and no fifo */
  UART2LCRH = 0x60;
     4de:	2260      	movs	r2, #96	@ 0x60
     4e0:	62da      	str	r2, [r3, #44]	@ 0x2c

  /* Enable UART with TXE and RXE */
  UART2CTL = 0x301;
     4e2:	f240 3201 	movw	r2, #769	@ 0x301
     4e6:	631a      	str	r2, [r3, #48]	@ 0x30
}
     4e8:	4770      	bx	lr
     4ea:	bf00      	nop
     4ec:	4000d000 	andmi	sp, r0, r0

000004f0 <pin_setup>:


void pin_setup() {
  /* Enable clock for UART0 and GPIO */
  // RCGCUART |= 1;
  RCGCUART |= 3;
     4f0:	4b13      	ldr	r3, [pc, #76]	@ (540 <pin_setup+0x50>)
     4f2:	f8d3 2618 	ldr.w	r2, [r3, #1560]	@ 0x618
     4f6:	f042 0203 	orr.w	r2, r2, #3
     4fa:	f8c3 2618 	str.w	r2, [r3, #1560]	@ 0x618
   // RCGCGPIO |= 1;
  RCGCGPIO |= 3;
     4fe:	f8d3 2608 	ldr.w	r2, [r3, #1544]	@ 0x608
     502:	f042 0203 	orr.w	r2, r2, #3
     506:	f8c3 2608 	str.w	r2, [r3, #1544]	@ 0x608

  /* Set PIN PA0 and PA1 as uart */
  GPIODEN = 0x03;
     50a:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
     50e:	2203      	movs	r2, #3
     510:	f8c3 251c 	str.w	r2, [r3, #1308]	@ 0x51c
  GPIOAFSEL = 0x03;
     514:	f8c3 2420 	str.w	r2, [r3, #1056]	@ 0x420
  GPIOPCTL |= 0x00000011;
     518:	f8d3 152c 	ldr.w	r1, [r3, #1324]	@ 0x52c
     51c:	f041 0111 	orr.w	r1, r1, #17
     520:	f8c3 152c 	str.w	r1, [r3, #1324]	@ 0x52c

    /* Set PIN PA0 and PA1 as uart */
  GPIODEN2 = 0x03;
     524:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
     528:	f8c3 251c 	str.w	r2, [r3, #1308]	@ 0x51c
  GPIOAFSEL2 = 0x03;
     52c:	f8c3 2420 	str.w	r2, [r3, #1056]	@ 0x420
  GPIOPCTL2 |= 0x00000011;
     530:	f8d3 252c 	ldr.w	r2, [r3, #1324]	@ 0x52c
     534:	f042 0211 	orr.w	r2, r2, #17
     538:	f8c3 252c 	str.w	r2, [r3, #1324]	@ 0x52c
}
     53c:	4770      	bx	lr
     53e:	bf00      	nop
     540:	400fe000 	andmi	lr, pc, r0

00000544 <platform_init>:

/**
 * @brief Inilialize the platform
 *
 */
void platform_init() {
     544:	b508      	push	{r3, lr}
    pin_setup();
     546:	f7ff ffd3 	bl	4f0 <pin_setup>
    uart_init();
     54a:	f7ff ff8d 	bl	468 <uart_init>
    uart2_init();
     54e:	f7ff ffbd 	bl	4cc <uart2_init>
    set_read_char(ugetc);
     552:	4806      	ldr	r0, [pc, #24]	@ (56c <platform_init+0x28>)
     554:	f000 faac 	bl	ab0 <set_read_char>
    set_read_char2(u2getc);
     558:	4805      	ldr	r0, [pc, #20]	@ (570 <platform_init+0x2c>)
     55a:	f000 faaf 	bl	abc <set_read_char2>
    set_write_char(uputc);
     55e:	4805      	ldr	r0, [pc, #20]	@ (574 <platform_init+0x30>)
     560:	f000 fab2 	bl	ac8 <set_write_char>
    set_write_char2(u2putc);
     564:	4804      	ldr	r0, [pc, #16]	@ (578 <platform_init+0x34>)
     566:	f000 fab5 	bl	ad4 <set_write_char2>
}
     56a:	bd08      	pop	{r3, pc}
     56c:	0000044d 	andeq	r0, r0, sp, asr #8
     570:	000004b1 			@ <UNDEFINED> instruction: 0x000004b1
     574:	00000429 	andeq	r0, r0, r9, lsr #8
     578:	0000048d 	andeq	r0, r0, sp, lsl #9

0000057c <pair>:

#include "shell.h"


int pair(int argc, char** argv) {
     57c:	b508      	push	{r3, lr}
    printf("Sending a pair request.\n");
     57e:	4804      	ldr	r0, [pc, #16]	@ (590 <pair+0x14>)
     580:	f000 fdd4 	bl	112c <printf>
    printf2("FOB_MESG PAIR\n");
     584:	4803      	ldr	r0, [pc, #12]	@ (594 <pair+0x18>)
     586:	f000 feed 	bl	1364 <printf2>
    return 0;
}
     58a:	2000      	movs	r0, #0
     58c:	bd08      	pop	{r3, pc}
     58e:	bf00      	nop
     590:	000023b4 			@ <UNDEFINED> instruction: 0x000023b4
     594:	000023d0 	ldrdeq	r2, [r0], -r0

00000598 <aes>:
#include "shell.h"

int aes(int argc, char** argv) {
     598:	b530      	push	{r4, r5, lr}
     59a:	b0bf      	sub	sp, #252	@ 0xfc

    struct AES_ctx ctx;
    uint8_t key[16] = {0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,
     59c:	4b1d      	ldr	r3, [pc, #116]	@ (614 <aes+0x7c>)
     59e:	f10d 0c28 	add.w	ip, sp, #40	@ 0x28
     5a2:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
     5a4:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
                     0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf};

    uint8_t text[16] = "0123456789abcdef";
     5a8:	4b1b      	ldr	r3, [pc, #108]	@ (618 <aes+0x80>)
     5aa:	ac06      	add	r4, sp, #24
     5ac:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
     5ae:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    AES_init_ctx(&ctx, key);
     5b2:	4661      	mov	r1, ip
     5b4:	a80e      	add	r0, sp, #56	@ 0x38
     5b6:	f001 fa3e 	bl	1a36 <AES_init_ctx>
    unsigned int len;

    printf("Encrypting %s using AES\n", text);
     5ba:	4621      	mov	r1, r4
     5bc:	4817      	ldr	r0, [pc, #92]	@ (61c <aes+0x84>)
     5be:	f000 fdb5 	bl	112c <printf>
    AES_ECB_encrypt(&ctx, text);
     5c2:	4621      	mov	r1, r4
     5c4:	a80e      	add	r0, sp, #56	@ 0x38
     5c6:	f001 fa4c 	bl	1a62 <AES_ECB_encrypt>
    printf("Encrypted is %s\n", text);
     5ca:	4d15      	ldr	r5, [pc, #84]	@ (620 <aes+0x88>)
     5cc:	4621      	mov	r1, r4
     5ce:	4628      	mov	r0, r5
     5d0:	f000 fdac 	bl	112c <printf>

    //Let's encode it in base64 so we can send it character-by-character over UART
    char b64text[16+8];
    len = encode_base64(text, 16, b64text);
     5d4:	466a      	mov	r2, sp
     5d6:	2110      	movs	r1, #16
     5d8:	4620      	mov	r0, r4
     5da:	f000 fc27 	bl	e2c <encode_base64>
    b64text[len] = '\n';
     5de:	f100 03f8 	add.w	r3, r0, #248	@ 0xf8
     5e2:	eb0d 0003 	add.w	r0, sp, r3
     5e6:	230a      	movs	r3, #10
     5e8:	f800 3cf8 	strb.w	r3, [r0, #-248]
    printf("Encrypted is %s\n", text);
     5ec:	4621      	mov	r1, r4
     5ee:	4628      	mov	r0, r5
     5f0:	f000 fd9c 	bl	112c <printf>
    printf2("FOB_MESG AESB64 %s\n", b64text);
     5f4:	4669      	mov	r1, sp
     5f6:	480b      	ldr	r0, [pc, #44]	@ (624 <aes+0x8c>)
     5f8:	f000 feb4 	bl	1364 <printf2>

    // And if you need to decrypt it:
    AES_ECB_decrypt(&ctx, text);
     5fc:	4621      	mov	r1, r4
     5fe:	a80e      	add	r0, sp, #56	@ 0x38
     600:	f001 fa36 	bl	1a70 <AES_ECB_decrypt>
    printf("Which should decrypt to %s \n", text);
     604:	4621      	mov	r1, r4
     606:	4808      	ldr	r0, [pc, #32]	@ (628 <aes+0x90>)
     608:	f000 fd90 	bl	112c <printf>

    return 0;
}
     60c:	2000      	movs	r0, #0
     60e:	b03f      	add	sp, #252	@ 0xfc
     610:	bd30      	pop	{r4, r5, pc}
     612:	bf00      	nop
     614:	000024c0 	andeq	r2, r0, r0, asr #9
     618:	00002474 	andeq	r2, r0, r4, ror r4
     61c:	00002410 	andeq	r2, r0, r0, lsl r4
     620:	0000242c 	andeq	r2, r0, ip, lsr #8
     624:	00002440 	andeq	r2, r0, r0, asr #8
     628:	00002454 	andeq	r2, r0, r4, asr r4

0000062c <encode64>:
#include "shell.h"
#define MAX64LENGTH 100

int encode64(int argc, char** argv) {
     62c:	b510      	push	{r4, lr}
     62e:	b09a      	sub	sp, #104	@ 0x68

    

    if (argc > 1) {
     630:	2801      	cmp	r0, #1
     632:	dd16      	ble.n	662 <encode64+0x36>
     634:	460c      	mov	r4, r1

        unsigned char encoded[MAX64LENGTH];
        int len;

        len = strlen(argv[1]);
     636:	6848      	ldr	r0, [r1, #4]
     638:	f001 fdde 	bl	21f8 <strlen>
     63c:	4601      	mov	r1, r0

        if (len < MAX64LENGTH) {
     63e:	2863      	cmp	r0, #99	@ 0x63
     640:	dc0a      	bgt.n	658 <encode64+0x2c>
            len = encode_base64(argv[1], len, encoded);
     642:	aa01      	add	r2, sp, #4
     644:	6860      	ldr	r0, [r4, #4]
     646:	f000 fbf1 	bl	e2c <encode_base64>
     64a:	4603      	mov	r3, r0
            printf("Encoded %s as %s with %d characters\n", argv[1], encoded, len);
     64c:	aa01      	add	r2, sp, #4
     64e:	6861      	ldr	r1, [r4, #4]
     650:	4807      	ldr	r0, [pc, #28]	@ (670 <encode64+0x44>)
     652:	f000 fd6b 	bl	112c <printf>
     656:	e007      	b.n	668 <encode64+0x3c>
        }
        else {
            printf("String exceeds max length of %d characters", MAX64LENGTH);
     658:	2164      	movs	r1, #100	@ 0x64
     65a:	4806      	ldr	r0, [pc, #24]	@ (674 <encode64+0x48>)
     65c:	f000 fd66 	bl	112c <printf>
     660:	e002      	b.n	668 <encode64+0x3c>
        }

    }
    else {
        printf("Usage is 'encode64 string'\n");
     662:	4805      	ldr	r0, [pc, #20]	@ (678 <encode64+0x4c>)
     664:	f000 fd62 	bl	112c <printf>
    }
        
    return 0;
}
     668:	2000      	movs	r0, #0
     66a:	b01a      	add	sp, #104	@ 0x68
     66c:	bd10      	pop	{r4, pc}
     66e:	bf00      	nop
     670:	000024d0 	ldrdeq	r2, [r0], -r0
     674:	000024f8 	strdeq	r2, [r0], -r8
     678:	00002524 	andeq	r2, r0, r4, lsr #10

0000067c <decode64>:

int decode64(int argc, char** argv) {
     67c:	b530      	push	{r4, r5, lr}
     67e:	b09b      	sub	sp, #108	@ 0x6c

    if (argc > 1) {
     680:	2801      	cmp	r0, #1
     682:	dd29      	ble.n	6d8 <decode64+0x5c>
     684:	460c      	mov	r4, r1

        int len = strlen(argv[1]);
     686:	6848      	ldr	r0, [r1, #4]
     688:	f001 fdb6 	bl	21f8 <strlen>
     68c:	4605      	mov	r5, r0

        if (len < MAX64LENGTH-1) {
     68e:	2862      	cmp	r0, #98	@ 0x62
     690:	dc1d      	bgt.n	6ce <decode64+0x52>
                
                char plaintext[MAX64LENGTH];

                printf("encoded string is %d characters\n", len);
     692:	4601      	mov	r1, r0
     694:	4813      	ldr	r0, [pc, #76]	@ (6e4 <decode64+0x68>)
     696:	f000 fd49 	bl	112c <printf>
                len = decode_base64(argv[1], len, plaintext);
     69a:	aa01      	add	r2, sp, #4
     69c:	4629      	mov	r1, r5
     69e:	6860      	ldr	r0, [r4, #4]
     6a0:	f000 fc38 	bl	f14 <decode_base64>
     6a4:	4605      	mov	r5, r0
                printf("decoded string is %d characters\n", len);
     6a6:	4601      	mov	r1, r0
     6a8:	480f      	ldr	r0, [pc, #60]	@ (6e8 <decode64+0x6c>)
     6aa:	f000 fd3f 	bl	112c <printf>
                printf("Adding NULL at the end of decoded string\n");
     6ae:	480f      	ldr	r0, [pc, #60]	@ (6ec <decode64+0x70>)
     6b0:	f000 fd3c 	bl	112c <printf>
                plaintext[len] = '\n';
     6b4:	f105 0368 	add.w	r3, r5, #104	@ 0x68
     6b8:	eb0d 0503 	add.w	r5, sp, r3
     6bc:	230a      	movs	r3, #10
     6be:	f805 3c64 	strb.w	r3, [r5, #-100]

                printf("Decoded %s as: %s\n", argv[1], plaintext);
     6c2:	aa01      	add	r2, sp, #4
     6c4:	6861      	ldr	r1, [r4, #4]
     6c6:	480a      	ldr	r0, [pc, #40]	@ (6f0 <decode64+0x74>)
     6c8:	f000 fd30 	bl	112c <printf>
     6cc:	e007      	b.n	6de <decode64+0x62>

        }
        else {
            printf("String exceeds max length of %d characters", MAX64LENGTH);
     6ce:	2164      	movs	r1, #100	@ 0x64
     6d0:	4808      	ldr	r0, [pc, #32]	@ (6f4 <decode64+0x78>)
     6d2:	f000 fd2b 	bl	112c <printf>
     6d6:	e002      	b.n	6de <decode64+0x62>
        }
    
    }
    else {
        printf("Usage is 'decode64 string'\n");
     6d8:	4807      	ldr	r0, [pc, #28]	@ (6f8 <decode64+0x7c>)
     6da:	f000 fd27 	bl	112c <printf>
    }
        
    return 0;
}
     6de:	2000      	movs	r0, #0
     6e0:	b01b      	add	sp, #108	@ 0x6c
     6e2:	bd30      	pop	{r4, r5, pc}
     6e4:	00002540 	andeq	r2, r0, r0, asr #10
     6e8:	00002564 	andeq	r2, r0, r4, ror #10
     6ec:	00002588 	andeq	r2, r0, r8, lsl #11
     6f0:	000025b4 			@ <UNDEFINED> instruction: 0x000025b4
     6f4:	000024f8 	strdeq	r2, [r0], -r8
     6f8:	000025c8 	andeq	r2, r0, r8, asr #11

000006fc <send_ping>:

#include "shell.h"


int send_ping(int argc, char** argv) {
     6fc:	b508      	push	{r3, lr}
    printf("Pinging the car.\n");
     6fe:	4804      	ldr	r0, [pc, #16]	@ (710 <send_ping+0x14>)
     700:	f000 fd14 	bl	112c <printf>
    printf2("FOB_MESG PING\n");
     704:	4803      	ldr	r0, [pc, #12]	@ (714 <send_ping+0x18>)
     706:	f000 fe2d 	bl	1364 <printf2>
    return 0;
}
     70a:	2000      	movs	r0, #0
     70c:	bd08      	pop	{r3, pc}
     70e:	bf00      	nop
     710:	0000265c 	andeq	r2, r0, ip, asr r6
     714:	00002670 	andeq	r2, r0, r0, ror r6

00000718 <initial_setup>:
         "@" BUILD_HOST "] - " __DATE__ " - " __TIME__ "\n");
  return 0;
}


void __attribute__((optimize("O0"), weak)) initial_setup(void) {
     718:	b580      	push	{r7, lr}
     71a:	b082      	sub	sp, #8
     71c:	af00      	add	r7, sp, #0
   * and zero the .bss section. This helps keep the user/custom
   * linker script and makefiles free from special variables to be declared.
   * Less burden on the user.
   */
  extern char _etext, _data, _edata, _bss, _ebss;
  char *src = &_etext, *dst = &_data;
     71e:	4b14      	ldr	r3, [pc, #80]	@ (770 <initial_setup+0x58>)
     720:	607b      	str	r3, [r7, #4]
     722:	4b14      	ldr	r3, [pc, #80]	@ (774 <initial_setup+0x5c>)
     724:	603b      	str	r3, [r7, #0]
  /**
   * Copy over the data section from ROM to RAM.
   * In case of RAM based target, we skip this since
   * src and dst would point to same location in RAM
   */
  if (dst != src)
     726:	683a      	ldr	r2, [r7, #0]
     728:	687b      	ldr	r3, [r7, #4]
     72a:	429a      	cmp	r2, r3
     72c:	d00c      	beq.n	748 <initial_setup+0x30>
    while (dst < &_edata) *(dst++) = *(src++);
     72e:	e007      	b.n	740 <initial_setup+0x28>
     730:	687a      	ldr	r2, [r7, #4]
     732:	1c53      	adds	r3, r2, #1
     734:	607b      	str	r3, [r7, #4]
     736:	683b      	ldr	r3, [r7, #0]
     738:	1c59      	adds	r1, r3, #1
     73a:	6039      	str	r1, [r7, #0]
     73c:	7812      	ldrb	r2, [r2, #0]
     73e:	701a      	strb	r2, [r3, #0]
     740:	683b      	ldr	r3, [r7, #0]
     742:	4a0d      	ldr	r2, [pc, #52]	@ (778 <initial_setup+0x60>)
     744:	4293      	cmp	r3, r2
     746:	d3f3      	bcc.n	730 <initial_setup+0x18>

  /* Clear .bss*/
  for (dst = &_bss; dst < &_ebss; dst++) *dst = 0;
     748:	4b0c      	ldr	r3, [pc, #48]	@ (77c <initial_setup+0x64>)
     74a:	603b      	str	r3, [r7, #0]
     74c:	e005      	b.n	75a <initial_setup+0x42>
     74e:	683b      	ldr	r3, [r7, #0]
     750:	2200      	movs	r2, #0
     752:	701a      	strb	r2, [r3, #0]
     754:	683b      	ldr	r3, [r7, #0]
     756:	3301      	adds	r3, #1
     758:	603b      	str	r3, [r7, #0]
     75a:	683b      	ldr	r3, [r7, #0]
     75c:	4a08      	ldr	r2, [pc, #32]	@ (780 <initial_setup+0x68>)
     75e:	4293      	cmp	r3, r2
     760:	d3f5      	bcc.n	74e <initial_setup+0x36>
   *   uart_init();
   *   set_read_char(uart_getchar);
   *   set_write_char(uart_putchar);
   * }
   */
  platform_init();
     762:	f7ff feef 	bl	544 <platform_init>
}
     766:	bf00      	nop
     768:	3708      	adds	r7, #8
     76a:	46bd      	mov	sp, r7
     76c:	bd80      	pop	{r7, pc}
     76e:	bf00      	nop
     770:	00002260 	andeq	r2, r0, r0, ror #4
     774:	20000000 	andcs	r0, r0, r0
     778:	20000001 	andcs	r0, r0, r1
     77c:	20000004 	andcs	r0, r0, r4
     780:	20000140 	andcs	r0, r0, r0, asr #2

00000784 <delete>:
static void delete(void) {
     784:	b510      	push	{r4, lr}
  __write_char__(BACK_SPACE);
     786:	4c05      	ldr	r4, [pc, #20]	@ (79c <delete+0x18>)
     788:	6823      	ldr	r3, [r4, #0]
     78a:	2008      	movs	r0, #8
     78c:	4798      	blx	r3
  __write_char__(SPACE);
     78e:	6823      	ldr	r3, [r4, #0]
     790:	2020      	movs	r0, #32
     792:	4798      	blx	r3
  __write_char__(BACK_SPACE);
     794:	6823      	ldr	r3, [r4, #0]
     796:	2008      	movs	r0, #8
     798:	4798      	blx	r3
}
     79a:	bd10      	pop	{r4, pc}
     79c:	20000008 	andcs	r0, r0, r8

000007a0 <clear_prompt>:
static void clear_prompt(int char_count) {
     7a0:	b510      	push	{r4, lr}
     7a2:	4604      	mov	r4, r0
  while (char_count) {
     7a4:	e002      	b.n	7ac <clear_prompt+0xc>
    delete ();
     7a6:	f7ff ffed 	bl	784 <delete>
    char_count--;
     7aa:	3c01      	subs	r4, #1
  while (char_count) {
     7ac:	2c00      	cmp	r4, #0
     7ae:	d1fa      	bne.n	7a6 <clear_prompt+0x6>
}
     7b0:	bd10      	pop	{r4, pc}

000007b2 <exec_auto_cmds>:
static void exec_auto_cmds(void) {
     7b2:	b510      	push	{r4, lr}
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
     7b4:	2400      	movs	r4, #0
     7b6:	e004      	b.n	7c2 <exec_auto_cmds+0x10>
    auto_load[i].command(0, NULL);
     7b8:	688b      	ldr	r3, [r1, #8]
     7ba:	2100      	movs	r1, #0
     7bc:	4608      	mov	r0, r1
     7be:	4798      	blx	r3
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
     7c0:	3401      	adds	r4, #1
     7c2:	eb04 0244 	add.w	r2, r4, r4, lsl #1
     7c6:	0093      	lsls	r3, r2, #2
     7c8:	4a02      	ldr	r2, [pc, #8]	@ (7d4 <exec_auto_cmds+0x22>)
     7ca:	1899      	adds	r1, r3, r2
     7cc:	58d3      	ldr	r3, [r2, r3]
     7ce:	2b00      	cmp	r3, #0
     7d0:	d1f2      	bne.n	7b8 <exec_auto_cmds+0x6>
}
     7d2:	bd10      	pop	{r4, pc}
     7d4:	00002310 	andeq	r2, r0, r0, lsl r3

000007d8 <show_history>:
static int show_history(int argc, char **argv) {
     7d8:	b538      	push	{r3, r4, r5, lr}
  uint32_t end_index = total_num_commands-1;
     7da:	4b0c      	ldr	r3, [pc, #48]	@ (80c <show_history+0x34>)
     7dc:	685d      	ldr	r5, [r3, #4]
     7de:	3d01      	subs	r5, #1
  if (total_num_commands > NUM_HISTORY_ENTRIES) {
     7e0:	685b      	ldr	r3, [r3, #4]
     7e2:	2b02      	cmp	r3, #2
     7e4:	dd03      	ble.n	7ee <show_history+0x16>
    beg_index = total_num_commands - NUM_HISTORY_ENTRIES;
     7e6:	4b09      	ldr	r3, [pc, #36]	@ (80c <show_history+0x34>)
     7e8:	685c      	ldr	r4, [r3, #4]
     7ea:	3c02      	subs	r4, #2
     7ec:	e00a      	b.n	804 <show_history+0x2c>
  uint32_t beg_index = 0;
     7ee:	2400      	movs	r4, #0
     7f0:	e008      	b.n	804 <show_history+0x2c>
    printf("%s\n", cmd_history[index % NUM_HISTORY_ENTRIES]);
     7f2:	f004 0101 	and.w	r1, r4, #1
     7f6:	4b06      	ldr	r3, [pc, #24]	@ (810 <show_history+0x38>)
     7f8:	eb03 11c1 	add.w	r1, r3, r1, lsl #7
     7fc:	4805      	ldr	r0, [pc, #20]	@ (814 <show_history+0x3c>)
     7fe:	f000 fc95 	bl	112c <printf>
  for (uint32_t index = beg_index; index <= end_index; ++index) {
     802:	3401      	adds	r4, #1
     804:	42ac      	cmp	r4, r5
     806:	d9f4      	bls.n	7f2 <show_history+0x1a>
}
     808:	2000      	movs	r0, #0
     80a:	bd38      	pop	{r3, r4, r5, pc}
     80c:	20000008 	andcs	r0, r0, r8
     810:	20000010 	andcs	r0, r0, r0, lsl r0
     814:	000026a0 	andeq	r2, r0, r0, lsr #13

00000818 <cmd_exec_status>:
  }

  return 0;
}

int cmd_exec_status(int argc, char **argv) {
     818:	b508      	push	{r3, lr}
  printf("%d\n", __cmd_exec_status);
     81a:	4b04      	ldr	r3, [pc, #16]	@ (82c <cmd_exec_status+0x14>)
     81c:	f8d3 1108 	ldr.w	r1, [r3, #264]	@ 0x108
     820:	4803      	ldr	r0, [pc, #12]	@ (830 <cmd_exec_status+0x18>)
     822:	f000 fc83 	bl	112c <printf>
  return 0;
}
     826:	2000      	movs	r0, #0
     828:	bd08      	pop	{r3, pc}
     82a:	bf00      	nop
     82c:	20000008 	andcs	r0, r0, r8
     830:	000026a4 	andeq	r2, r0, r4, lsr #13

00000834 <build_info>:
static int build_info(int argc, char **argv) {
     834:	b508      	push	{r3, lr}
  printf("Build: [" SHELL_VERSION ":" USER_REPO_VERSION "] - [" BUILD_USER
     836:	4802      	ldr	r0, [pc, #8]	@ (840 <build_info+0xc>)
     838:	f000 fc78 	bl	112c <printf>
}
     83c:	2000      	movs	r0, #0
     83e:	bd08      	pop	{r3, pc}
     840:	000026a8 	andeq	r2, r0, r8, lsr #13

00000844 <execute>:
static void execute(int argc, char **argv) {
     844:	e92d 4178 	stmdb	sp!, {r3, r4, r5, r6, r8, lr}
     848:	4680      	mov	r8, r0
     84a:	460e      	mov	r6, r1
  for (int i = 0; table[i].command_name != NULL; i++) {
     84c:	2500      	movs	r5, #0
     84e:	e000      	b.n	852 <execute+0xe>
     850:	3501      	adds	r5, #1
     852:	eb05 0445 	add.w	r4, r5, r5, lsl #1
     856:	00a4      	lsls	r4, r4, #2
     858:	4b0e      	ldr	r3, [pc, #56]	@ (894 <execute+0x50>)
     85a:	5919      	ldr	r1, [r3, r4]
     85c:	b171      	cbz	r1, 87c <execute+0x38>
    if (strcmp(argv[0], table[i].command_name) == 0) {
     85e:	6830      	ldr	r0, [r6, #0]
     860:	f001 fcd2 	bl	2208 <strcmp>
     864:	2800      	cmp	r0, #0
     866:	d1f3      	bne.n	850 <execute+0xc>
      __cmd_exec_status = table[i].command(argc, &argv[0]);
     868:	4b0a      	ldr	r3, [pc, #40]	@ (894 <execute+0x50>)
     86a:	4423      	add	r3, r4
     86c:	689b      	ldr	r3, [r3, #8]
     86e:	4631      	mov	r1, r6
     870:	4640      	mov	r0, r8
     872:	4798      	blx	r3
     874:	4b08      	ldr	r3, [pc, #32]	@ (898 <execute+0x54>)
     876:	f8c3 0108 	str.w	r0, [r3, #264]	@ 0x108
  if (match_found == FALSE) {
     87a:	e008      	b.n	88e <execute+0x4a>
    printf("\"%s\": command not found. Use \"help\" to list all command.\n",
     87c:	6831      	ldr	r1, [r6, #0]
     87e:	4807      	ldr	r0, [pc, #28]	@ (89c <execute+0x58>)
     880:	f000 fc54 	bl	112c <printf>
    __cmd_exec_status = -1;
     884:	4b04      	ldr	r3, [pc, #16]	@ (898 <execute+0x54>)
     886:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
     88a:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
}
     88e:	e8bd 8178 	ldmia.w	sp!, {r3, r4, r5, r6, r8, pc}
     892:	bf00      	nop
     894:	00002268 	andeq	r2, r0, r8, ror #4
     898:	20000008 	andcs	r0, r0, r8
     89c:	000026f4 	strdeq	r2, [r0], -r4

000008a0 <help>:
int help(int argc, char **argv) {
     8a0:	b570      	push	{r4, r5, r6, lr}
  if (argc > 1 && (strcmp(argv[1], "-l")==0)) {
     8a2:	2801      	cmp	r0, #1
     8a4:	dd05      	ble.n	8b2 <help+0x12>
     8a6:	460b      	mov	r3, r1
     8a8:	4912      	ldr	r1, [pc, #72]	@ (8f4 <help+0x54>)
     8aa:	6858      	ldr	r0, [r3, #4]
     8ac:	f001 fcac 	bl	2208 <strcmp>
     8b0:	b1e0      	cbz	r0, 8ec <help+0x4c>
    printf("use: help -l for list only.\n\n");
     8b2:	4811      	ldr	r0, [pc, #68]	@ (8f8 <help+0x58>)
     8b4:	f000 fc3a 	bl	112c <printf>
  bool verbose = true;
     8b8:	2601      	movs	r6, #1
    verbose = false;
     8ba:	2500      	movs	r5, #0
     8bc:	e003      	b.n	8c6 <help+0x26>
    printf("\n");
     8be:	480f      	ldr	r0, [pc, #60]	@ (8fc <help+0x5c>)
     8c0:	f000 fc34 	bl	112c <printf>
    i++;
     8c4:	3501      	adds	r5, #1
  while (table[i].command_name != NULL) {
     8c6:	eb05 0445 	add.w	r4, r5, r5, lsl #1
     8ca:	00a4      	lsls	r4, r4, #2
     8cc:	4b0c      	ldr	r3, [pc, #48]	@ (900 <help+0x60>)
     8ce:	5918      	ldr	r0, [r3, r4]
     8d0:	b170      	cbz	r0, 8f0 <help+0x50>
    printf(table[i].command_name);
     8d2:	f000 fc2b 	bl	112c <printf>
    if (verbose) {
     8d6:	2e00      	cmp	r6, #0
     8d8:	d0f1      	beq.n	8be <help+0x1e>
      printf("\n\t");
     8da:	480a      	ldr	r0, [pc, #40]	@ (904 <help+0x64>)
     8dc:	f000 fc26 	bl	112c <printf>
      printf(table[i].command_help);
     8e0:	4b07      	ldr	r3, [pc, #28]	@ (900 <help+0x60>)
     8e2:	4423      	add	r3, r4
     8e4:	6858      	ldr	r0, [r3, #4]
     8e6:	f000 fc21 	bl	112c <printf>
     8ea:	e7e8      	b.n	8be <help+0x1e>
    verbose = false;
     8ec:	2600      	movs	r6, #0
     8ee:	e7e4      	b.n	8ba <help+0x1a>
}
     8f0:	bd70      	pop	{r4, r5, r6, pc}
     8f2:	bf00      	nop
     8f4:	00002730 	andeq	r2, r0, r0, lsr r7
     8f8:	00002734 	andeq	r2, r0, r4, lsr r7
     8fc:	00002758 	andeq	r2, r0, r8, asr r7
     900:	00002268 	andeq	r2, r0, r8, ror #4
     904:	00002754 	andeq	r2, r0, r4, asr r7

00000908 <add_command_to_history>:
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
     908:	b1e0      	cbz	r0, 944 <add_command_to_history+0x3c>
static void add_command_to_history(const char *cmd_str) {
     90a:	b538      	push	{r3, r4, r5, lr}
     90c:	4605      	mov	r5, r0
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
     90e:	490e      	ldr	r1, [pc, #56]	@ (948 <add_command_to_history+0x40>)
     910:	f001 fc7a 	bl	2208 <strcmp>
     914:	b900      	cbnz	r0, 918 <add_command_to_history+0x10>
}
     916:	bd38      	pop	{r3, r4, r5, pc}
  int index = total_num_commands % NUM_HISTORY_ENTRIES;
     918:	4c0c      	ldr	r4, [pc, #48]	@ (94c <add_command_to_history+0x44>)
     91a:	6860      	ldr	r0, [r4, #4]
     91c:	2800      	cmp	r0, #0
     91e:	f000 0001 	and.w	r0, r0, #1
     922:	bfb8      	it	lt
     924:	4240      	neglt	r0, r0
  memcpy(&cmd_history[index], cmd_str, LINE_BUFF_SIZE);
     926:	f104 0308 	add.w	r3, r4, #8
     92a:	2280      	movs	r2, #128	@ 0x80
     92c:	4629      	mov	r1, r5
     92e:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
     932:	f001 fc7e 	bl	2232 <memcpy>
  total_num_commands++;
     936:	6863      	ldr	r3, [r4, #4]
     938:	3301      	adds	r3, #1
     93a:	6063      	str	r3, [r4, #4]
  curr_command_ptr = total_num_commands;
     93c:	6863      	ldr	r3, [r4, #4]
     93e:	f8c4 310c 	str.w	r3, [r4, #268]	@ 0x10c
     942:	e7e8      	b.n	916 <add_command_to_history+0xe>
     944:	4770      	bx	lr
     946:	bf00      	nop
     948:	0000275c 	andeq	r2, r0, ip, asr r7
     94c:	20000008 	andcs	r0, r0, r8

00000950 <parse_line>:
static int parse_line(char **argv, char *line_buff, int argument_size) {
     950:	b538      	push	{r3, r4, r5, lr}
     952:	4605      	mov	r5, r0
     954:	460c      	mov	r4, r1
  int length = strlen(line_buff);
     956:	4608      	mov	r0, r1
     958:	f001 fc4e 	bl	21f8 <strlen>
     95c:	4684      	mov	ip, r0
  int pos = 0;
     95e:	2300      	movs	r3, #0
  int argc = 0;
     960:	4618      	mov	r0, r3
  while (pos <= length) {
     962:	e00f      	b.n	984 <parse_line+0x34>
         pos++)
     964:	3301      	adds	r3, #1
    for (; line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
     966:	18e1      	adds	r1, r4, r3
     968:	5ce2      	ldrb	r2, [r4, r3]
     96a:	2a09      	cmp	r2, #9
     96c:	d003      	beq.n	976 <parse_line+0x26>
     96e:	2a20      	cmp	r2, #32
     970:	d001      	beq.n	976 <parse_line+0x26>
     972:	2a00      	cmp	r2, #0
     974:	d1f6      	bne.n	964 <parse_line+0x14>
    if (line_buff[pos] == '\t' || line_buff[pos] == SPACE)
     976:	2a09      	cmp	r2, #9
     978:	d001      	beq.n	97e <parse_line+0x2e>
     97a:	2a20      	cmp	r2, #32
     97c:	d101      	bne.n	982 <parse_line+0x32>
      line_buff[pos] = END_OF_LINE;
     97e:	2200      	movs	r2, #0
     980:	700a      	strb	r2, [r1, #0]
    pos++;
     982:	3301      	adds	r3, #1
  while (pos <= length) {
     984:	4563      	cmp	r3, ip
     986:	dc0b      	bgt.n	9a0 <parse_line+0x50>
    if (line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
     988:	18e1      	adds	r1, r4, r3
     98a:	5ce2      	ldrb	r2, [r4, r3]
     98c:	2a09      	cmp	r2, #9
     98e:	d0ea      	beq.n	966 <parse_line+0x16>
     990:	2a20      	cmp	r2, #32
     992:	d0e8      	beq.n	966 <parse_line+0x16>
     994:	2a00      	cmp	r2, #0
     996:	d0e6      	beq.n	966 <parse_line+0x16>
      argv[argc++] = &line_buff[pos];
     998:	f845 1020 	str.w	r1, [r5, r0, lsl #2]
     99c:	3001      	adds	r0, #1
     99e:	e7e2      	b.n	966 <parse_line+0x16>
}
     9a0:	bd38      	pop	{r3, r4, r5, pc}

000009a2 <prefix_match>:
  if (sub == NULL || str == NULL || len <= 0 || len > strlen(str)) {
     9a2:	b1d0      	cbz	r0, 9da <prefix_match+0x38>
static int prefix_match(char *sub, int len, const char *str) {
     9a4:	b570      	push	{r4, r5, r6, lr}
     9a6:	460d      	mov	r5, r1
     9a8:	4614      	mov	r4, r2
     9aa:	4606      	mov	r6, r0
  if (sub == NULL || str == NULL || len <= 0 || len > strlen(str)) {
     9ac:	b17a      	cbz	r2, 9ce <prefix_match+0x2c>
     9ae:	2900      	cmp	r1, #0
     9b0:	dd0d      	ble.n	9ce <prefix_match+0x2c>
     9b2:	4610      	mov	r0, r2
     9b4:	f001 fc20 	bl	21f8 <strlen>
     9b8:	42a8      	cmp	r0, r5
     9ba:	d308      	bcc.n	9ce <prefix_match+0x2c>
  for (int i = 0; i<len; ++i) {
     9bc:	2300      	movs	r3, #0
     9be:	42ab      	cmp	r3, r5
     9c0:	da07      	bge.n	9d2 <prefix_match+0x30>
    if (sub[i] != str[i]) {
     9c2:	5cf1      	ldrb	r1, [r6, r3]
     9c4:	5ce2      	ldrb	r2, [r4, r3]
     9c6:	4291      	cmp	r1, r2
     9c8:	d105      	bne.n	9d6 <prefix_match+0x34>
  for (int i = 0; i<len; ++i) {
     9ca:	3301      	adds	r3, #1
     9cc:	e7f7      	b.n	9be <prefix_match+0x1c>
    return FALSE;
     9ce:	2000      	movs	r0, #0
}
     9d0:	bd70      	pop	{r4, r5, r6, pc}
  return TRUE;
     9d2:	2001      	movs	r0, #1
     9d4:	e7fc      	b.n	9d0 <prefix_match+0x2e>
      return FALSE;
     9d6:	2000      	movs	r0, #0
     9d8:	e7fa      	b.n	9d0 <prefix_match+0x2e>
    return FALSE;
     9da:	2000      	movs	r0, #0
}
     9dc:	4770      	bx	lr

000009de <handle_up_arrow>:
static void handle_up_arrow(char *cmd_buff, int *char_count) {
     9de:	b538      	push	{r3, r4, r5, lr}
     9e0:	4604      	mov	r4, r0
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
     9e2:	4a19      	ldr	r2, [pc, #100]	@ (a48 <handle_up_arrow+0x6a>)
     9e4:	6853      	ldr	r3, [r2, #4]
     9e6:	3b02      	subs	r3, #2
     9e8:	f8d2 210c 	ldr.w	r2, [r2, #268]	@ 0x10c
     9ec:	4293      	cmp	r3, r2
     9ee:	dc04      	bgt.n	9fa <handle_up_arrow+0x1c>
     9f0:	460d      	mov	r5, r1
      curr_command_ptr == 0) {
     9f2:	4b15      	ldr	r3, [pc, #84]	@ (a48 <handle_up_arrow+0x6a>)
     9f4:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
     9f8:	b923      	cbnz	r3, a04 <handle_up_arrow+0x26>
    printf("%s", cmd_buff);
     9fa:	4621      	mov	r1, r4
     9fc:	4813      	ldr	r0, [pc, #76]	@ (a4c <handle_up_arrow+0x6e>)
     9fe:	f000 fb95 	bl	112c <printf>
}
     a02:	bd38      	pop	{r3, r4, r5, pc}
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
     a04:	2280      	movs	r2, #128	@ 0x80
     a06:	2100      	movs	r1, #0
     a08:	f001 fc1e 	bl	2248 <memset>
  curr_command_ptr--;
     a0c:	4b0e      	ldr	r3, [pc, #56]	@ (a48 <handle_up_arrow+0x6a>)
     a0e:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
     a12:	3a01      	subs	r2, #1
     a14:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
     a18:	f8d3 110c 	ldr.w	r1, [r3, #268]	@ 0x10c
     a1c:	2900      	cmp	r1, #0
     a1e:	f001 0101 	and.w	r1, r1, #1
     a22:	bfb8      	it	lt
     a24:	4249      	neglt	r1, r1
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
     a26:	3308      	adds	r3, #8
     a28:	2280      	movs	r2, #128	@ 0x80
     a2a:	eb03 11c1 	add.w	r1, r3, r1, lsl #7
     a2e:	4620      	mov	r0, r4
     a30:	f001 fbff 	bl	2232 <memcpy>
  *char_count = strlen(cmd_buff);
     a34:	4620      	mov	r0, r4
     a36:	f001 fbdf 	bl	21f8 <strlen>
     a3a:	6028      	str	r0, [r5, #0]
  printf("%s", cmd_buff);
     a3c:	4621      	mov	r1, r4
     a3e:	4803      	ldr	r0, [pc, #12]	@ (a4c <handle_up_arrow+0x6e>)
     a40:	f000 fb74 	bl	112c <printf>
     a44:	e7dd      	b.n	a02 <handle_up_arrow+0x24>
     a46:	bf00      	nop
     a48:	20000008 	andcs	r0, r0, r8
     a4c:	00002760 	andeq	r2, r0, r0, ror #14

00000a50 <handle_down_arrow>:
static void handle_down_arrow(char *cmd_buff, int *char_count) {
     a50:	b538      	push	{r3, r4, r5, lr}
     a52:	4604      	mov	r4, r0
     a54:	460d      	mov	r5, r1
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
     a56:	2280      	movs	r2, #128	@ 0x80
     a58:	2100      	movs	r1, #0
     a5a:	f001 fbf5 	bl	2248 <memset>
  *char_count = 0;
     a5e:	2300      	movs	r3, #0
     a60:	602b      	str	r3, [r5, #0]
  if (curr_command_ptr == total_num_commands) return;
     a62:	4b11      	ldr	r3, [pc, #68]	@ (aa8 <handle_down_arrow+0x58>)
     a64:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
     a68:	685b      	ldr	r3, [r3, #4]
     a6a:	429a      	cmp	r2, r3
     a6c:	d01b      	beq.n	aa6 <handle_down_arrow+0x56>
  curr_command_ptr++;
     a6e:	490e      	ldr	r1, [pc, #56]	@ (aa8 <handle_down_arrow+0x58>)
     a70:	f8d1 310c 	ldr.w	r3, [r1, #268]	@ 0x10c
     a74:	3301      	adds	r3, #1
     a76:	f8c1 310c 	str.w	r3, [r1, #268]	@ 0x10c
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
     a7a:	f8d1 310c 	ldr.w	r3, [r1, #268]	@ 0x10c
     a7e:	2b00      	cmp	r3, #0
     a80:	f003 0301 	and.w	r3, r3, #1
     a84:	bfb8      	it	lt
     a86:	425b      	neglt	r3, r3
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
     a88:	3108      	adds	r1, #8
     a8a:	2280      	movs	r2, #128	@ 0x80
     a8c:	eb01 11c3 	add.w	r1, r1, r3, lsl #7
     a90:	4620      	mov	r0, r4
     a92:	f001 fbce 	bl	2232 <memcpy>
  *char_count = strlen(cmd_buff);
     a96:	4620      	mov	r0, r4
     a98:	f001 fbae 	bl	21f8 <strlen>
     a9c:	6028      	str	r0, [r5, #0]
  printf("%s", cmd_buff);
     a9e:	4621      	mov	r1, r4
     aa0:	4802      	ldr	r0, [pc, #8]	@ (aac <handle_down_arrow+0x5c>)
     aa2:	f000 fb43 	bl	112c <printf>
}
     aa6:	bd38      	pop	{r3, r4, r5, pc}
     aa8:	20000008 	andcs	r0, r0, r8
     aac:	00002760 	andeq	r2, r0, r0, ror #14

00000ab0 <set_read_char>:
void set_read_char(int (*func)(void)) { __read_char__ = func; }
     ab0:	4b01      	ldr	r3, [pc, #4]	@ (ab8 <set_read_char+0x8>)
     ab2:	f8c3 0110 	str.w	r0, [r3, #272]	@ 0x110
     ab6:	4770      	bx	lr
     ab8:	20000008 	andcs	r0, r0, r8

00000abc <set_read_char2>:
void set_read_char2(int (*func)(void)) { __read_char2__ = func; }
     abc:	4b01      	ldr	r3, [pc, #4]	@ (ac4 <set_read_char2+0x8>)
     abe:	f8c3 0114 	str.w	r0, [r3, #276]	@ 0x114
     ac2:	4770      	bx	lr
     ac4:	20000008 	andcs	r0, r0, r8

00000ac8 <set_write_char>:
void set_write_char(void (*func)(char)) { __write_char__ = func; }
     ac8:	4b01      	ldr	r3, [pc, #4]	@ (ad0 <set_write_char+0x8>)
     aca:	6018      	str	r0, [r3, #0]
     acc:	4770      	bx	lr
     ace:	bf00      	nop
     ad0:	20000008 	andcs	r0, r0, r8

00000ad4 <set_write_char2>:
void set_write_char2(void (*func)(char)) { __write_char2__ = func; }
     ad4:	4b01      	ldr	r3, [pc, #4]	@ (adc <set_write_char2+0x8>)
     ad6:	f8c3 0118 	str.w	r0, [r3, #280]	@ 0x118
     ada:	4770      	bx	lr
     adc:	20000008 	andcs	r0, r0, r8

00000ae0 <setup>:
}
     ae0:	4770      	bx	lr

00000ae2 <loop>:
}
     ae2:	4770      	bx	lr

00000ae4 <prepend_prompt>:
}
     ae4:	4770      	bx	lr

00000ae6 <handle_tab>:
  if (cmd_buff == NULL || char_count <= 0) {
     ae6:	2800      	cmp	r0, #0
     ae8:	d046      	beq.n	b78 <handle_tab+0x92>
static void handle_tab(char *cmd_buff, int *char_count) {
     aea:	e92d 4778 	stmdb	sp!, {r3, r4, r5, r6, r8, r9, sl, lr}
     aee:	460e      	mov	r6, r1
     af0:	4680      	mov	r8, r0
  if (cmd_buff == NULL || char_count <= 0) {
     af2:	b309      	cbz	r1, b38 <handle_tab+0x52>
  int last_match = -1;
     af4:	f04f 3aff 	mov.w	sl, #4294967295	@ 0xffffffff
  int match_count = 0;
     af8:	f04f 0900 	mov.w	r9, #0
  int i = 0;
     afc:	464d      	mov	r5, r9
     afe:	e000      	b.n	b02 <handle_tab+0x1c>
    i++;
     b00:	3501      	adds	r5, #1
  while (table[i].command_name != NULL) { //loop over all commands
     b02:	eb05 0445 	add.w	r4, r5, r5, lsl #1
     b06:	00a4      	lsls	r4, r4, #2
     b08:	4b1c      	ldr	r3, [pc, #112]	@ (b7c <handle_tab+0x96>)
     b0a:	591a      	ldr	r2, [r3, r4]
     b0c:	b172      	cbz	r2, b2c <handle_tab+0x46>
    if (prefix_match(cmd_buff, *char_count, table[i].command_name)) {
     b0e:	6831      	ldr	r1, [r6, #0]
     b10:	4640      	mov	r0, r8
     b12:	f7ff ff46 	bl	9a2 <prefix_match>
     b16:	2800      	cmp	r0, #0
     b18:	d0f2      	beq.n	b00 <handle_tab+0x1a>
      match_count++;
     b1a:	f109 0901 	add.w	r9, r9, #1
      printf("\n%s", table[i].command_name);
     b1e:	4b17      	ldr	r3, [pc, #92]	@ (b7c <handle_tab+0x96>)
     b20:	5919      	ldr	r1, [r3, r4]
     b22:	4817      	ldr	r0, [pc, #92]	@ (b80 <handle_tab+0x9a>)
     b24:	f000 fb02 	bl	112c <printf>
      last_match = i;
     b28:	46aa      	mov	sl, r5
     b2a:	e7e9      	b.n	b00 <handle_tab+0x1a>
  if (match_count == 1) {
     b2c:	f1b9 0f01 	cmp.w	r9, #1
     b30:	d004      	beq.n	b3c <handle_tab+0x56>
  if (match_count) {
     b32:	f1b9 0f00 	cmp.w	r9, #0
     b36:	d10e      	bne.n	b56 <handle_tab+0x70>
}
     b38:	e8bd 8778 	ldmia.w	sp!, {r3, r4, r5, r6, r8, r9, sl, pc}
    memcpy(cmd_buff, table[last_match].command_name, LINE_BUFF_SIZE);
     b3c:	eb0a 0a4a 	add.w	sl, sl, sl, lsl #1
     b40:	2280      	movs	r2, #128	@ 0x80
     b42:	f853 102a 	ldr.w	r1, [r3, sl, lsl #2]
     b46:	4640      	mov	r0, r8
     b48:	f001 fb73 	bl	2232 <memcpy>
    *char_count = strlen(cmd_buff);
     b4c:	4640      	mov	r0, r8
     b4e:	f001 fb53 	bl	21f8 <strlen>
     b52:	6030      	str	r0, [r6, #0]
     b54:	e7ed      	b.n	b32 <handle_tab+0x4c>
    printf("\n");
     b56:	4c0b      	ldr	r4, [pc, #44]	@ (b84 <handle_tab+0x9e>)
     b58:	f104 00b8 	add.w	r0, r4, #184	@ 0xb8
     b5c:	f000 fae6 	bl	112c <printf>
    prepend_prompt();
     b60:	f7ff ffc0 	bl	ae4 <prepend_prompt>
    printf(PROMPT);
     b64:	f104 00c8 	add.w	r0, r4, #200	@ 0xc8
     b68:	f000 fae0 	bl	112c <printf>
    printf("%s", cmd_buff);
     b6c:	4641      	mov	r1, r8
     b6e:	f104 00c0 	add.w	r0, r4, #192	@ 0xc0
     b72:	f000 fadb 	bl	112c <printf>
     b76:	e7df      	b.n	b38 <handle_tab+0x52>
     b78:	4770      	bx	lr
     b7a:	bf00      	nop
     b7c:	00002268 	andeq	r2, r0, r8, ror #4
     b80:	00002764 	andeq	r2, r0, r4, ror #14
     b84:	000026a0 	andeq	r2, r0, r0, lsr #13

00000b88 <active_prompt>:
__attribute__((weak)) int active_prompt() { return TRUE; }
     b88:	2001      	movs	r0, #1
     b8a:	4770      	bx	lr

00000b8c <shell>:
static void shell(void) {
     b8c:	b530      	push	{r4, r5, lr}
     b8e:	b0e3      	sub	sp, #396	@ 0x18c
  int count = 0;
     b90:	2300      	movs	r3, #0
     b92:	9361      	str	r3, [sp, #388]	@ 0x184
  for (int i = 0; i < LINE_BUFF_SIZE; i++) line_buff[i] = 0;
     b94:	e006      	b.n	ba4 <shell+0x18>
     b96:	f503 72c4 	add.w	r2, r3, #392	@ 0x188
     b9a:	446a      	add	r2, sp
     b9c:	2100      	movs	r1, #0
     b9e:	f802 1c84 	strb.w	r1, [r2, #-132]
     ba2:	3301      	adds	r3, #1
     ba4:	2b7f      	cmp	r3, #127	@ 0x7f
     ba6:	ddf6      	ble.n	b96 <shell+0xa>
  for (int i = 0; i < MAX_ARG_COUNT; i++) argv[i] = NULL;
     ba8:	2300      	movs	r3, #0
     baa:	e004      	b.n	bb6 <shell+0x2a>
     bac:	aa01      	add	r2, sp, #4
     bae:	2100      	movs	r1, #0
     bb0:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
     bb4:	3301      	adds	r3, #1
     bb6:	2b3f      	cmp	r3, #63	@ 0x3f
     bb8:	ddf8      	ble.n	bac <shell+0x20>
  prepend_prompt();
     bba:	f7ff ff93 	bl	ae4 <prepend_prompt>
  printf(PROMPT);
     bbe:	484e      	ldr	r0, [pc, #312]	@ (cf8 <shell+0x16c>)
     bc0:	f000 fab4 	bl	112c <printf>
  int special_key = 0;
     bc4:	2500      	movs	r5, #0
     bc6:	e039      	b.n	c3c <shell+0xb0>
        special_key = 1;
     bc8:	2501      	movs	r5, #1
     bca:	e037      	b.n	c3c <shell+0xb0>
    if (s == -1) { s = __read_char2__();}
     bcc:	4b4b      	ldr	r3, [pc, #300]	@ (cfc <shell+0x170>)
     bce:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
     bd2:	4798      	blx	r3
    if (s != -1) {
     bd4:	f1b0 3fff 	cmp.w	r0, #4294967295	@ 0xffffffff
     bd8:	d13b      	bne.n	c52 <shell+0xc6>
      loop();
     bda:	f7ff ff82 	bl	ae2 <loop>
     bde:	e02d      	b.n	c3c <shell+0xb0>
        line_buff[count] = END_OF_LINE;
     be0:	9b61      	ldr	r3, [sp, #388]	@ 0x184
     be2:	f503 73c4 	add.w	r3, r3, #392	@ 0x188
     be6:	446b      	add	r3, sp
     be8:	2200      	movs	r2, #0
     bea:	f803 2c84 	strb.w	r2, [r3, #-132]
        __write_char__(NEW_LINE);
     bee:	4b43      	ldr	r3, [pc, #268]	@ (cfc <shell+0x170>)
     bf0:	681b      	ldr	r3, [r3, #0]
     bf2:	200a      	movs	r0, #10
     bf4:	4798      	blx	r3
  add_command_to_history(line_buff);
     bf6:	a841      	add	r0, sp, #260	@ 0x104
     bf8:	f7ff fe86 	bl	908 <add_command_to_history>
  argc = parse_line(argv, line_buff, MAX_ARG_COUNT);
     bfc:	2240      	movs	r2, #64	@ 0x40
     bfe:	a941      	add	r1, sp, #260	@ 0x104
     c00:	a801      	add	r0, sp, #4
     c02:	f7ff fea5 	bl	950 <parse_line>
  if (argc > 0) execute(argc, argv);
     c06:	2800      	cmp	r0, #0
     c08:	dc71      	bgt.n	cee <shell+0x162>
}
     c0a:	b063      	add	sp, #396	@ 0x18c
     c0c:	bd30      	pop	{r4, r5, pc}
        if (!__echo) {
     c0e:	4b3c      	ldr	r3, [pc, #240]	@ (d00 <shell+0x174>)
     c10:	781b      	ldrb	r3, [r3, #0]
     c12:	2b00      	cmp	r3, #0
     c14:	d03f      	beq.n	c96 <shell+0x10a>
        if (count == 0) continue;
     c16:	9b61      	ldr	r3, [sp, #388]	@ 0x184
     c18:	b183      	cbz	r3, c3c <shell+0xb0>
        count--;
     c1a:	3b01      	subs	r3, #1
     c1c:	9361      	str	r3, [sp, #388]	@ 0x184
        line_buff[count] = END_OF_LINE;
     c1e:	f503 73c4 	add.w	r3, r3, #392	@ 0x188
     c22:	446b      	add	r3, sp
     c24:	2200      	movs	r2, #0
     c26:	f803 2c84 	strb.w	r2, [r3, #-132]
        delete ();
     c2a:	f7ff fdab 	bl	784 <delete>
      if (__echo) {
     c2e:	4b34      	ldr	r3, [pc, #208]	@ (d00 <shell+0x174>)
     c30:	781b      	ldrb	r3, [r3, #0]
     c32:	b11b      	cbz	r3, c3c <shell+0xb0>
        __write_char__(c);
     c34:	4b31      	ldr	r3, [pc, #196]	@ (cfc <shell+0x170>)
     c36:	681b      	ldr	r3, [r3, #0]
     c38:	4620      	mov	r0, r4
     c3a:	4798      	blx	r3
    if (!active_prompt()) {
     c3c:	f7ff ffa4 	bl	b88 <active_prompt>
     c40:	2800      	cmp	r0, #0
     c42:	d0fb      	beq.n	c3c <shell+0xb0>
    s = __read_char__();
     c44:	4b2d      	ldr	r3, [pc, #180]	@ (cfc <shell+0x170>)
     c46:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
     c4a:	4798      	blx	r3
    if (s == -1) { s = __read_char2__();}
     c4c:	f1b0 3fff 	cmp.w	r0, #4294967295	@ 0xffffffff
     c50:	d0bc      	beq.n	bcc <shell+0x40>
      c = (char)s;
     c52:	b2c4      	uxtb	r4, r0
      if (c == CARRIAGE_RETURN || c == NEW_LINE) {
     c54:	2c0d      	cmp	r4, #13
     c56:	d0c3      	beq.n	be0 <shell+0x54>
     c58:	2c0a      	cmp	r4, #10
     c5a:	d0c1      	beq.n	be0 <shell+0x54>
      if (c == DELETE || c == BACK_SPACE) {
     c5c:	2c7f      	cmp	r4, #127	@ 0x7f
     c5e:	d0d6      	beq.n	c0e <shell+0x82>
     c60:	2c08      	cmp	r4, #8
     c62:	d0d4      	beq.n	c0e <shell+0x82>
      } else if (c == ESCAPE) {
     c64:	2c1b      	cmp	r4, #27
     c66:	d0af      	beq.n	bc8 <shell+0x3c>
      } else if (c == SQUARE_BRACKET_OPEN && special_key == 1) {
     c68:	2c5b      	cmp	r4, #91	@ 0x5b
     c6a:	d019      	beq.n	ca0 <shell+0x114>
      } else if ((c == 'C' || c == 'D') && special_key != 0) {
     c6c:	f1a4 0343 	sub.w	r3, r4, #67	@ 0x43
     c70:	b2db      	uxtb	r3, r3
     c72:	2b01      	cmp	r3, #1
     c74:	d918      	bls.n	ca8 <shell+0x11c>
      } else if ((c == 'A' || c == 'B') && special_key == 2) {
     c76:	f1a4 0341 	sub.w	r3, r4, #65	@ 0x41
     c7a:	b2db      	uxtb	r3, r3
     c7c:	2b01      	cmp	r3, #1
     c7e:	d917      	bls.n	cb0 <shell+0x124>
      else if (c == TAB) {
     c80:	2c09      	cmp	r4, #9
     c82:	d02f      	beq.n	ce4 <shell+0x158>
        line_buff[count] = c;
     c84:	9b61      	ldr	r3, [sp, #388]	@ 0x184
     c86:	f503 72c4 	add.w	r2, r3, #392	@ 0x188
     c8a:	446a      	add	r2, sp
     c8c:	f802 4c84 	strb.w	r4, [r2, #-132]
        count++;
     c90:	3301      	adds	r3, #1
     c92:	9361      	str	r3, [sp, #388]	@ 0x184
     c94:	e7cb      	b.n	c2e <shell+0xa2>
          delete ();
     c96:	f7ff fd75 	bl	784 <delete>
          delete ();
     c9a:	f7ff fd73 	bl	784 <delete>
     c9e:	e7ba      	b.n	c16 <shell+0x8a>
      } else if (c == SQUARE_BRACKET_OPEN && special_key == 1) {
     ca0:	2d01      	cmp	r5, #1
     ca2:	d1e3      	bne.n	c6c <shell+0xe0>
        special_key = 2;
     ca4:	2502      	movs	r5, #2
     ca6:	e7c9      	b.n	c3c <shell+0xb0>
      } else if ((c == 'C' || c == 'D') && special_key != 0) {
     ca8:	2d00      	cmp	r5, #0
     caa:	d0e4      	beq.n	c76 <shell+0xea>
        special_key = 0;
     cac:	2500      	movs	r5, #0
     cae:	e7c5      	b.n	c3c <shell+0xb0>
      } else if ((c == 'A' || c == 'B') && special_key == 2) {
     cb0:	2d02      	cmp	r5, #2
     cb2:	d1e5      	bne.n	c80 <shell+0xf4>
        if (!__echo) {
     cb4:	4b12      	ldr	r3, [pc, #72]	@ (d00 <shell+0x174>)
     cb6:	781b      	ldrb	r3, [r3, #0]
     cb8:	b95b      	cbnz	r3, cd2 <shell+0x146>
          clear_prompt(count + 4);
     cba:	9861      	ldr	r0, [sp, #388]	@ 0x184
     cbc:	3004      	adds	r0, #4
     cbe:	f7ff fd6f 	bl	7a0 <clear_prompt>
        if (c == 'A') {
     cc2:	2c41      	cmp	r4, #65	@ 0x41
     cc4:	d009      	beq.n	cda <shell+0x14e>
          handle_down_arrow(line_buff, &count);
     cc6:	a961      	add	r1, sp, #388	@ 0x184
     cc8:	a841      	add	r0, sp, #260	@ 0x104
     cca:	f7ff fec1 	bl	a50 <handle_down_arrow>
        special_key = 0;
     cce:	2500      	movs	r5, #0
        continue;
     cd0:	e7b4      	b.n	c3c <shell+0xb0>
          clear_prompt(count);
     cd2:	9861      	ldr	r0, [sp, #388]	@ 0x184
     cd4:	f7ff fd64 	bl	7a0 <clear_prompt>
     cd8:	e7f3      	b.n	cc2 <shell+0x136>
          handle_up_arrow(line_buff, &count);
     cda:	a961      	add	r1, sp, #388	@ 0x184
     cdc:	a841      	add	r0, sp, #260	@ 0x104
     cde:	f7ff fe7e 	bl	9de <handle_up_arrow>
     ce2:	e7f4      	b.n	cce <shell+0x142>
        handle_tab(line_buff, &count);
     ce4:	a961      	add	r1, sp, #388	@ 0x184
     ce6:	a841      	add	r0, sp, #260	@ 0x104
     ce8:	f7ff fefd 	bl	ae6 <handle_tab>
        continue;
     cec:	e7a6      	b.n	c3c <shell+0xb0>
  if (argc > 0) execute(argc, argv);
     cee:	a901      	add	r1, sp, #4
     cf0:	f7ff fda8 	bl	844 <execute>
}
     cf4:	e789      	b.n	c0a <shell+0x7e>
     cf6:	bf00      	nop
     cf8:	00002768 	andeq	r2, r0, r8, ror #14
     cfc:	20000008 	andcs	r0, r0, r8
     d00:	20000000 	andcs	r0, r0, r0

00000d04 <prompt>:
void prompt() {
     d04:	b508      	push	{r3, lr}
  initial_setup();
     d06:	f7ff fd07 	bl	718 <initial_setup>
  exec_auto_cmds();
     d0a:	f7ff fd52 	bl	7b2 <exec_auto_cmds>
  setup();
     d0e:	f7ff fee7 	bl	ae0 <setup>
    shell();
     d12:	f7ff ff3b 	bl	b8c <shell>
  while (TRUE) {
     d16:	e7fc      	b.n	d12 <prompt+0xe>

00000d18 <exec>:
int exec(char *cmd_str) {
     d18:	b500      	push	{lr}
     d1a:	b0c1      	sub	sp, #260	@ 0x104
     d1c:	4601      	mov	r1, r0
  argc = parse_line(argv, cmd_str, MAX_ARG_COUNT);
     d1e:	2240      	movs	r2, #64	@ 0x40
     d20:	4668      	mov	r0, sp
     d22:	f7ff fe15 	bl	950 <parse_line>
  if (argc > 0) execute(argc, argv);
     d26:	2800      	cmp	r0, #0
     d28:	dc05      	bgt.n	d36 <exec+0x1e>
  return __cmd_exec_status;
     d2a:	4b05      	ldr	r3, [pc, #20]	@ (d40 <exec+0x28>)
     d2c:	f8d3 0108 	ldr.w	r0, [r3, #264]	@ 0x108
}
     d30:	b041      	add	sp, #260	@ 0x104
     d32:	f85d fb04 	ldr.w	pc, [sp], #4
  if (argc > 0) execute(argc, argv);
     d36:	4669      	mov	r1, sp
     d38:	f7ff fd84 	bl	844 <execute>
     d3c:	e7f5      	b.n	d2a <exec+0x12>
     d3e:	bf00      	nop
     d40:	20000008 	andcs	r0, r0, r8

00000d44 <get_function_addr>:
cmd get_function_addr(char *cmd_str) {
     d44:	b570      	push	{r4, r5, r6, lr}
     d46:	4606      	mov	r6, r0
  for (int i = 0; table[i].command_name != NULL; i++) {
     d48:	2500      	movs	r5, #0
     d4a:	e000      	b.n	d4e <get_function_addr+0xa>
     d4c:	3501      	adds	r5, #1
     d4e:	eb05 0445 	add.w	r4, r5, r5, lsl #1
     d52:	00a4      	lsls	r4, r4, #2
     d54:	4b06      	ldr	r3, [pc, #24]	@ (d70 <get_function_addr+0x2c>)
     d56:	5919      	ldr	r1, [r3, r4]
     d58:	b141      	cbz	r1, d6c <get_function_addr+0x28>
    if (strcmp(cmd_str, table[i].command_name) == 0) {
     d5a:	4630      	mov	r0, r6
     d5c:	f001 fa54 	bl	2208 <strcmp>
     d60:	2800      	cmp	r0, #0
     d62:	d1f3      	bne.n	d4c <get_function_addr+0x8>
      return table[i].command;
     d64:	4b02      	ldr	r3, [pc, #8]	@ (d70 <get_function_addr+0x2c>)
     d66:	4423      	add	r3, r4
     d68:	6898      	ldr	r0, [r3, #8]
     d6a:	e000      	b.n	d6e <get_function_addr+0x2a>
  return NULL;
     d6c:	2000      	movs	r0, #0
}
     d6e:	bd70      	pop	{r4, r5, r6, pc}
     d70:	00002268 	andeq	r2, r0, r8, ror #4

00000d74 <binary_to_base64>:
#include "base64.h"

unsigned char binary_to_base64(unsigned char v) {
  // Capital letters - 'A' is ascii 65 and base64 0
  if(v < 26) return v + 'A';
     d74:	2819      	cmp	r0, #25
     d76:	d909      	bls.n	d8c <binary_to_base64+0x18>
  
  // Lowercase letters - 'a' is ascii 97 and base64 26
  if(v < 52) return v + 71;
     d78:	2833      	cmp	r0, #51	@ 0x33
     d7a:	d90a      	bls.n	d92 <binary_to_base64+0x1e>
  
  // Digits - '0' is ascii 48 and base64 52
  if(v < 62) return v - 4;
     d7c:	283d      	cmp	r0, #61	@ 0x3d
     d7e:	d90b      	bls.n	d98 <binary_to_base64+0x24>
  
  // '+' is ascii 43 and base64 62
  if(v == 62) return '+';
     d80:	283e      	cmp	r0, #62	@ 0x3e
     d82:	d00c      	beq.n	d9e <binary_to_base64+0x2a>
  
  // '/' is ascii 47 and base64 63
  if(v == 63) return '/';
     d84:	283f      	cmp	r0, #63	@ 0x3f
     d86:	d00c      	beq.n	da2 <binary_to_base64+0x2e>
  
  return 64;
     d88:	2040      	movs	r0, #64	@ 0x40
     d8a:	4770      	bx	lr
  if(v < 26) return v + 'A';
     d8c:	3041      	adds	r0, #65	@ 0x41
     d8e:	b2c0      	uxtb	r0, r0
     d90:	4770      	bx	lr
  if(v < 52) return v + 71;
     d92:	3047      	adds	r0, #71	@ 0x47
     d94:	b2c0      	uxtb	r0, r0
     d96:	4770      	bx	lr
  if(v < 62) return v - 4;
     d98:	3804      	subs	r0, #4
     d9a:	b2c0      	uxtb	r0, r0
     d9c:	4770      	bx	lr
  if(v == 62) return '+';
     d9e:	202b      	movs	r0, #43	@ 0x2b
     da0:	4770      	bx	lr
  if(v == 63) return '/';
     da2:	202f      	movs	r0, #47	@ 0x2f
}
     da4:	4770      	bx	lr

00000da6 <base64_to_binary>:

unsigned char base64_to_binary(unsigned char c) {
     da6:	4603      	mov	r3, r0
  // Capital letters - 'A' is ascii 65 and base64 0
  if('A' <= c && c <= 'Z') return c - 'A';
     da8:	3841      	subs	r0, #65	@ 0x41
     daa:	b2c0      	uxtb	r0, r0
     dac:	2819      	cmp	r0, #25
     dae:	d918      	bls.n	de2 <base64_to_binary+0x3c>
  
  // Lowercase letters - 'a' is ascii 97 and base64 26
  if('a' <= c && c <= 'z') return c - 71;
     db0:	f1a3 0261 	sub.w	r2, r3, #97	@ 0x61
     db4:	b2d2      	uxtb	r2, r2
     db6:	2a19      	cmp	r2, #25
     db8:	d90a      	bls.n	dd0 <base64_to_binary+0x2a>
  
  // Digits - '0' is ascii 48 and base64 52
  if('0' <= c && c <= '9') return c + 4;
     dba:	f1a3 0230 	sub.w	r2, r3, #48	@ 0x30
     dbe:	b2d2      	uxtb	r2, r2
     dc0:	2a09      	cmp	r2, #9
     dc2:	d908      	bls.n	dd6 <base64_to_binary+0x30>
  
  // '+' is ascii 43 and base64 62
  if(c == '+') return 62;
     dc4:	2b2b      	cmp	r3, #43	@ 0x2b
     dc6:	d009      	beq.n	ddc <base64_to_binary+0x36>
  
  // '/' is ascii 47 and base64 63
  if(c == '/') return 63;
     dc8:	2b2f      	cmp	r3, #47	@ 0x2f
     dca:	d009      	beq.n	de0 <base64_to_binary+0x3a>
  
  return 255;
     dcc:	20ff      	movs	r0, #255	@ 0xff
     dce:	4770      	bx	lr
  if('a' <= c && c <= 'z') return c - 71;
     dd0:	3b47      	subs	r3, #71	@ 0x47
     dd2:	b2d8      	uxtb	r0, r3
     dd4:	4770      	bx	lr
  if('0' <= c && c <= '9') return c + 4;
     dd6:	3304      	adds	r3, #4
     dd8:	b2d8      	uxtb	r0, r3
     dda:	4770      	bx	lr
  if(c == '+') return 62;
     ddc:	203e      	movs	r0, #62	@ 0x3e
     dde:	4770      	bx	lr
  if(c == '/') return 63;
     de0:	203f      	movs	r0, #63	@ 0x3f
}
     de2:	4770      	bx	lr

00000de4 <encode_base64_length>:

unsigned int encode_base64_length(unsigned int input_length) {
  return (input_length + 2)/3*4;
     de4:	3002      	adds	r0, #2
     de6:	4b03      	ldr	r3, [pc, #12]	@ (df4 <encode_base64_length+0x10>)
     de8:	fba3 3000 	umull	r3, r0, r3, r0
     dec:	0840      	lsrs	r0, r0, #1
}
     dee:	0080      	lsls	r0, r0, #2
     df0:	4770      	bx	lr
     df2:	bf00      	nop
     df4:	aaaaaaab 	bge	feaab8a8 <_STACK_TOP_+0xdeaa38ac>

00000df8 <decode_base64_length>:

unsigned int decode_base64_length(unsigned char input[], unsigned int input_length) {
     df8:	b570      	push	{r4, r5, r6, lr}
     dfa:	4605      	mov	r5, r0
     dfc:	460e      	mov	r6, r1
  unsigned char *start = input;
  
  while(base64_to_binary(input[0]) < 64 && (unsigned int) (input - start) < input_length) {
     dfe:	4604      	mov	r4, r0
     e00:	e000      	b.n	e04 <decode_base64_length+0xc>
    ++input;
     e02:	3401      	adds	r4, #1
  while(base64_to_binary(input[0]) < 64 && (unsigned int) (input - start) < input_length) {
     e04:	7820      	ldrb	r0, [r4, #0]
     e06:	f7ff ffce 	bl	da6 <base64_to_binary>
     e0a:	283f      	cmp	r0, #63	@ 0x3f
     e0c:	d802      	bhi.n	e14 <decode_base64_length+0x1c>
     e0e:	1b63      	subs	r3, r4, r5
     e10:	42b3      	cmp	r3, r6
     e12:	d3f6      	bcc.n	e02 <decode_base64_length+0xa>
  }
  
  input_length = input - start;
     e14:	1b64      	subs	r4, r4, r5
  return input_length/4*3 + (input_length % 4 ? input_length % 4 - 1 : 0);
     e16:	08a0      	lsrs	r0, r4, #2
     e18:	eb00 0040 	add.w	r0, r0, r0, lsl #1
     e1c:	f014 0403 	ands.w	r4, r4, #3
     e20:	d002      	beq.n	e28 <decode_base64_length+0x30>
     e22:	3c01      	subs	r4, #1
}
     e24:	4420      	add	r0, r4
     e26:	bd70      	pop	{r4, r5, r6, pc}
  return input_length/4*3 + (input_length % 4 ? input_length % 4 - 1 : 0);
     e28:	2400      	movs	r4, #0
     e2a:	e7fb      	b.n	e24 <decode_base64_length+0x2c>

00000e2c <encode_base64>:

unsigned int encode_base64(unsigned char input[], unsigned int input_length, unsigned char output[]) {
     e2c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     e30:	4604      	mov	r4, r0
     e32:	4688      	mov	r8, r1
     e34:	4615      	mov	r5, r2
  unsigned int full_sets = input_length/3;
     e36:	4f36      	ldr	r7, [pc, #216]	@ (f10 <encode_base64+0xe4>)
     e38:	fba7 3701 	umull	r3, r7, r7, r1
     e3c:	087f      	lsrs	r7, r7, #1
  
  // While there are still full sets of 24 bits...
  for(unsigned int i = 0; i < full_sets; ++i) {
     e3e:	2600      	movs	r6, #0
     e40:	e021      	b.n	e86 <encode_base64+0x5a>
    output[0] = binary_to_base64(                         input[0] >> 2);
     e42:	7820      	ldrb	r0, [r4, #0]
     e44:	0880      	lsrs	r0, r0, #2
     e46:	f7ff ff95 	bl	d74 <binary_to_base64>
     e4a:	7028      	strb	r0, [r5, #0]
    output[1] = binary_to_base64((input[0] & 0x03) << 4 | input[1] >> 4);
     e4c:	7823      	ldrb	r3, [r4, #0]
     e4e:	011b      	lsls	r3, r3, #4
     e50:	f003 0330 	and.w	r3, r3, #48	@ 0x30
     e54:	7860      	ldrb	r0, [r4, #1]
     e56:	ea43 1010 	orr.w	r0, r3, r0, lsr #4
     e5a:	f7ff ff8b 	bl	d74 <binary_to_base64>
     e5e:	7068      	strb	r0, [r5, #1]
    output[2] = binary_to_base64((input[1] & 0x0F) << 2 | input[2] >> 6);
     e60:	7863      	ldrb	r3, [r4, #1]
     e62:	009b      	lsls	r3, r3, #2
     e64:	f003 033c 	and.w	r3, r3, #60	@ 0x3c
     e68:	78a0      	ldrb	r0, [r4, #2]
     e6a:	ea43 1090 	orr.w	r0, r3, r0, lsr #6
     e6e:	f7ff ff81 	bl	d74 <binary_to_base64>
     e72:	70a8      	strb	r0, [r5, #2]
    output[3] = binary_to_base64( input[2] & 0x3F);
     e74:	78a0      	ldrb	r0, [r4, #2]
     e76:	f000 003f 	and.w	r0, r0, #63	@ 0x3f
     e7a:	f7ff ff7b 	bl	d74 <binary_to_base64>
     e7e:	70e8      	strb	r0, [r5, #3]
    
    input += 3;
     e80:	3403      	adds	r4, #3
    output += 4;
     e82:	3504      	adds	r5, #4
  for(unsigned int i = 0; i < full_sets; ++i) {
     e84:	3601      	adds	r6, #1
     e86:	42be      	cmp	r6, r7
     e88:	d3db      	bcc.n	e42 <encode_base64+0x16>
  }
  
  switch(input_length % 3) {
     e8a:	4a21      	ldr	r2, [pc, #132]	@ (f10 <encode_base64+0xe4>)
     e8c:	fba2 3208 	umull	r3, r2, r2, r8
     e90:	f022 0301 	bic.w	r3, r2, #1
     e94:	eb03 0352 	add.w	r3, r3, r2, lsr #1
     e98:	eba8 0303 	sub.w	r3, r8, r3
     e9c:	2b01      	cmp	r3, #1
     e9e:	d009      	beq.n	eb4 <encode_base64+0x88>
     ea0:	2b02      	cmp	r3, #2
     ea2:	d019      	beq.n	ed8 <encode_base64+0xac>
     ea4:	b123      	cbz	r3, eb0 <encode_base64+0x84>
      output[3] = '=';
      output[4] = '\0';
      break;
  }
  
  return encode_base64_length(input_length);
     ea6:	4640      	mov	r0, r8
     ea8:	f7ff ff9c 	bl	de4 <encode_base64_length>
}
     eac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      output[0] = '\0';
     eb0:	702b      	strb	r3, [r5, #0]
      break;
     eb2:	e7f8      	b.n	ea6 <encode_base64+0x7a>
      output[0] = binary_to_base64(                         input[0] >> 2);
     eb4:	7820      	ldrb	r0, [r4, #0]
     eb6:	0880      	lsrs	r0, r0, #2
     eb8:	f7ff ff5c 	bl	d74 <binary_to_base64>
     ebc:	7028      	strb	r0, [r5, #0]
      output[1] = binary_to_base64((input[0] & 0x03) << 4);
     ebe:	7820      	ldrb	r0, [r4, #0]
     ec0:	0100      	lsls	r0, r0, #4
     ec2:	f000 0030 	and.w	r0, r0, #48	@ 0x30
     ec6:	f7ff ff55 	bl	d74 <binary_to_base64>
     eca:	7068      	strb	r0, [r5, #1]
      output[2] = '=';
     ecc:	233d      	movs	r3, #61	@ 0x3d
     ece:	70ab      	strb	r3, [r5, #2]
      output[3] = '=';
     ed0:	70eb      	strb	r3, [r5, #3]
      output[4] = '\0';
     ed2:	2300      	movs	r3, #0
     ed4:	712b      	strb	r3, [r5, #4]
      break;
     ed6:	e7e6      	b.n	ea6 <encode_base64+0x7a>
      output[0] = binary_to_base64(                         input[0] >> 2);
     ed8:	7820      	ldrb	r0, [r4, #0]
     eda:	0880      	lsrs	r0, r0, #2
     edc:	f7ff ff4a 	bl	d74 <binary_to_base64>
     ee0:	7028      	strb	r0, [r5, #0]
      output[1] = binary_to_base64((input[0] & 0x03) << 4 | input[1] >> 4);
     ee2:	7823      	ldrb	r3, [r4, #0]
     ee4:	011b      	lsls	r3, r3, #4
     ee6:	f003 0330 	and.w	r3, r3, #48	@ 0x30
     eea:	7860      	ldrb	r0, [r4, #1]
     eec:	ea43 1010 	orr.w	r0, r3, r0, lsr #4
     ef0:	f7ff ff40 	bl	d74 <binary_to_base64>
     ef4:	7068      	strb	r0, [r5, #1]
      output[2] = binary_to_base64((input[1] & 0x0F) << 2);
     ef6:	7860      	ldrb	r0, [r4, #1]
     ef8:	0080      	lsls	r0, r0, #2
     efa:	f000 003c 	and.w	r0, r0, #60	@ 0x3c
     efe:	f7ff ff39 	bl	d74 <binary_to_base64>
     f02:	70a8      	strb	r0, [r5, #2]
      output[3] = '=';
     f04:	233d      	movs	r3, #61	@ 0x3d
     f06:	70eb      	strb	r3, [r5, #3]
      output[4] = '\0';
     f08:	2300      	movs	r3, #0
     f0a:	712b      	strb	r3, [r5, #4]
      break;
     f0c:	e7cb      	b.n	ea6 <encode_base64+0x7a>
     f0e:	bf00      	nop
     f10:	aaaaaaab 	bge	feaab9c4 <_STACK_TOP_+0xdeaa39c8>

00000f14 <decode_base64>:


unsigned int decode_base64(unsigned char input[], unsigned int input_length, unsigned char output[]) {
     f14:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     f18:	4604      	mov	r4, r0
     f1a:	4616      	mov	r6, r2
  unsigned int output_length = decode_base64_length(input, input_length);
     f1c:	f7ff ff6c 	bl	df8 <decode_base64_length>
     f20:	4680      	mov	r8, r0
  
  // While there are still full sets of 24 bits...
  for(unsigned int i = 2; i < output_length; i += 3) {
     f22:	2702      	movs	r7, #2
     f24:	e01f      	b.n	f66 <decode_base64+0x52>
    output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
     f26:	7820      	ldrb	r0, [r4, #0]
     f28:	f7ff ff3d 	bl	da6 <base64_to_binary>
     f2c:	0085      	lsls	r5, r0, #2
     f2e:	7860      	ldrb	r0, [r4, #1]
     f30:	f7ff ff39 	bl	da6 <base64_to_binary>
     f34:	ea45 1510 	orr.w	r5, r5, r0, lsr #4
     f38:	7035      	strb	r5, [r6, #0]
    output[1] = base64_to_binary(input[1]) << 4 | base64_to_binary(input[2]) >> 2;
     f3a:	7860      	ldrb	r0, [r4, #1]
     f3c:	f7ff ff33 	bl	da6 <base64_to_binary>
     f40:	0105      	lsls	r5, r0, #4
     f42:	78a0      	ldrb	r0, [r4, #2]
     f44:	f7ff ff2f 	bl	da6 <base64_to_binary>
     f48:	ea45 0590 	orr.w	r5, r5, r0, lsr #2
     f4c:	7075      	strb	r5, [r6, #1]
    output[2] = base64_to_binary(input[2]) << 6 | base64_to_binary(input[3]);
     f4e:	78a0      	ldrb	r0, [r4, #2]
     f50:	f7ff ff29 	bl	da6 <base64_to_binary>
     f54:	0185      	lsls	r5, r0, #6
     f56:	78e0      	ldrb	r0, [r4, #3]
     f58:	f7ff ff25 	bl	da6 <base64_to_binary>
     f5c:	4328      	orrs	r0, r5
     f5e:	70b0      	strb	r0, [r6, #2]
    
    input += 4;
     f60:	3404      	adds	r4, #4
    output += 3;
     f62:	3603      	adds	r6, #3
  for(unsigned int i = 2; i < output_length; i += 3) {
     f64:	3703      	adds	r7, #3
     f66:	4547      	cmp	r7, r8
     f68:	d3dd      	bcc.n	f26 <decode_base64+0x12>
  }
  
  switch(output_length % 3) {
     f6a:	4a18      	ldr	r2, [pc, #96]	@ (fcc <decode_base64+0xb8>)
     f6c:	fba2 3208 	umull	r3, r2, r2, r8
     f70:	f022 0301 	bic.w	r3, r2, #1
     f74:	eb03 0352 	add.w	r3, r3, r2, lsr #1
     f78:	eba8 0303 	sub.w	r3, r8, r3
     f7c:	2b01      	cmp	r3, #1
     f7e:	d004      	beq.n	f8a <decode_base64+0x76>
     f80:	2b02      	cmp	r3, #2
     f82:	d00d      	beq.n	fa0 <decode_base64+0x8c>
      output[1] = base64_to_binary(input[1]) << 4 | base64_to_binary(input[2]) >> 2;
      break;
  }
  
  return output_length;
     f84:	4640      	mov	r0, r8
     f86:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
     f8a:	7820      	ldrb	r0, [r4, #0]
     f8c:	f7ff ff0b 	bl	da6 <base64_to_binary>
     f90:	0085      	lsls	r5, r0, #2
     f92:	7860      	ldrb	r0, [r4, #1]
     f94:	f7ff ff07 	bl	da6 <base64_to_binary>
     f98:	ea45 1510 	orr.w	r5, r5, r0, lsr #4
     f9c:	7035      	strb	r5, [r6, #0]
      break;
     f9e:	e7f1      	b.n	f84 <decode_base64+0x70>
      output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
     fa0:	7820      	ldrb	r0, [r4, #0]
     fa2:	f7ff ff00 	bl	da6 <base64_to_binary>
     fa6:	0085      	lsls	r5, r0, #2
     fa8:	7860      	ldrb	r0, [r4, #1]
     faa:	f7ff fefc 	bl	da6 <base64_to_binary>
     fae:	ea45 1510 	orr.w	r5, r5, r0, lsr #4
     fb2:	7035      	strb	r5, [r6, #0]
      output[1] = base64_to_binary(input[1]) << 4 | base64_to_binary(input[2]) >> 2;
     fb4:	7860      	ldrb	r0, [r4, #1]
     fb6:	f7ff fef6 	bl	da6 <base64_to_binary>
     fba:	0105      	lsls	r5, r0, #4
     fbc:	78a0      	ldrb	r0, [r4, #2]
     fbe:	f7ff fef2 	bl	da6 <base64_to_binary>
     fc2:	ea45 0590 	orr.w	r5, r5, r0, lsr #2
     fc6:	7075      	strb	r5, [r6, #1]
  return output_length;
     fc8:	e7dc      	b.n	f84 <decode_base64+0x70>
     fca:	bf00      	nop
     fcc:	aaaaaaab 	bge	feaaba80 <_STACK_TOP_+0xdeaa3a84>

00000fd0 <outstr>:
} printf_state;

static char hextable[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                          '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

static void outstr(const char *str) {
     fd0:	b510      	push	{r4, lr}
     fd2:	4604      	mov	r4, r0
  while (*str != '\0') {
     fd4:	e003      	b.n	fde <outstr+0xe>
    __write_char__(*str);
     fd6:	4b04      	ldr	r3, [pc, #16]	@ (fe8 <outstr+0x18>)
     fd8:	681b      	ldr	r3, [r3, #0]
     fda:	4798      	blx	r3
    str++;
     fdc:	3401      	adds	r4, #1
  while (*str != '\0') {
     fde:	7820      	ldrb	r0, [r4, #0]
     fe0:	2800      	cmp	r0, #0
     fe2:	d1f8      	bne.n	fd6 <outstr+0x6>
  }
}
     fe4:	bd10      	pop	{r4, pc}
     fe6:	bf00      	nop
     fe8:	20000008 	andcs	r0, r0, r8

00000fec <printf_numbers>:

static bool printf_numbers(const char fmt, va_list *args, int l_count) {
     fec:	b530      	push	{r4, r5, lr}
     fee:	b085      	sub	sp, #20
     ff0:	4614      	mov	r4, r2
  char num[MAX_DIGITS];
  int num_len = 0;

  switch (fmt) {
     ff2:	2864      	cmp	r0, #100	@ 0x64
     ff4:	d01d      	beq.n	1032 <printf_numbers+0x46>
     ff6:	d914      	bls.n	1022 <printf_numbers+0x36>
     ff8:	2875      	cmp	r0, #117	@ 0x75
     ffa:	d001      	beq.n	1000 <printf_numbers+0x14>
     ffc:	2878      	cmp	r0, #120	@ 0x78
     ffe:	d112      	bne.n	1026 <printf_numbers+0x3a>
#ifndef SHELL_NO_PRINTF_LL
      long long unsigned int value = 0;
#else
      unsigned int value = 0;
#endif  // SHELL_NO_PRINTF_LL
      if (l_count == 0) {
    1000:	2c00      	cmp	r4, #0
    1002:	f040 8086 	bne.w	1112 <printf_numbers+0x126>
        value = va_arg(*args, unsigned int);
    1006:	680b      	ldr	r3, [r1, #0]
    1008:	1d1a      	adds	r2, r3, #4
    100a:	600a      	str	r2, [r1, #0]
    100c:	681d      	ldr	r5, [r3, #0]
#endif  // SHELL_NO_PRINTF_LL
      } else {
        return false;
      }

      if (fmt == 'u') {
    100e:	2875      	cmp	r0, #117	@ 0x75
    1010:	d043      	beq.n	109a <printf_numbers+0xae>

        while (num_len > 0) {
          __write_char__(num[--num_len]);
        };
      } else {
        if (value == 0) {
    1012:	2d00      	cmp	r5, #0
    1014:	d176      	bne.n	1104 <printf_numbers+0x118>
          __write_char__(hextable[0]);
    1016:	4b40      	ldr	r3, [pc, #256]	@ (1118 <printf_numbers+0x12c>)
    1018:	681b      	ldr	r3, [r3, #0]
    101a:	2030      	movs	r0, #48	@ 0x30
    101c:	4798      	blx	r3
    }
    default:
      outstr("\nprintf-error\n");
      return false;
  }
  return true;
    101e:	2001      	movs	r0, #1
    1020:	e005      	b.n	102e <printf_numbers+0x42>
  switch (fmt) {
    1022:	2858      	cmp	r0, #88	@ 0x58
    1024:	d0ec      	beq.n	1000 <printf_numbers+0x14>
      outstr("\nprintf-error\n");
    1026:	483d      	ldr	r0, [pc, #244]	@ (111c <printf_numbers+0x130>)
    1028:	f7ff ffd2 	bl	fd0 <outstr>
      return false;
    102c:	2000      	movs	r0, #0
}
    102e:	b005      	add	sp, #20
    1030:	bd30      	pop	{r4, r5, pc}
      if (l_count == 0) {
    1032:	2a00      	cmp	r2, #0
    1034:	d16b      	bne.n	110e <printf_numbers+0x122>
        value = va_arg(*args, int);
    1036:	680b      	ldr	r3, [r1, #0]
    1038:	1d1a      	adds	r2, r3, #4
    103a:	600a      	str	r2, [r1, #0]
    103c:	681d      	ldr	r5, [r3, #0]
      if (value < 0) {
    103e:	2d00      	cmp	r5, #0
    1040:	db17      	blt.n	1072 <printf_numbers+0x86>
        num[num_len++] = hextable[value % 10];
    1042:	4a37      	ldr	r2, [pc, #220]	@ (1120 <printf_numbers+0x134>)
    1044:	fb82 3205 	smull	r3, r2, r2, r5
    1048:	17eb      	asrs	r3, r5, #31
    104a:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
    104e:	4619      	mov	r1, r3
    1050:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    1054:	eba5 0343 	sub.w	r3, r5, r3, lsl #1
    1058:	4832      	ldr	r0, [pc, #200]	@ (1124 <printf_numbers+0x138>)
    105a:	5cc0      	ldrb	r0, [r0, r3]
    105c:	4623      	mov	r3, r4
    105e:	3310      	adds	r3, #16
    1060:	446b      	add	r3, sp
    1062:	3401      	adds	r4, #1
    1064:	f803 0c0c 	strb.w	r0, [r3, #-12]
        value = value / 10;
    1068:	462b      	mov	r3, r5
    106a:	460d      	mov	r5, r1
      } while (value > 0);
    106c:	2b09      	cmp	r3, #9
    106e:	dce8      	bgt.n	1042 <printf_numbers+0x56>
    1070:	e00f      	b.n	1092 <printf_numbers+0xa6>
        __write_char__('-');
    1072:	4b29      	ldr	r3, [pc, #164]	@ (1118 <printf_numbers+0x12c>)
    1074:	681b      	ldr	r3, [r3, #0]
    1076:	202d      	movs	r0, #45	@ 0x2d
    1078:	4798      	blx	r3
        value = -value;
    107a:	426d      	negs	r5, r5
    107c:	e7e1      	b.n	1042 <printf_numbers+0x56>
        __write_char__(num[--num_len]);
    107e:	3c01      	subs	r4, #1
    1080:	f104 0310 	add.w	r3, r4, #16
    1084:	eb0d 0203 	add.w	r2, sp, r3
    1088:	4b23      	ldr	r3, [pc, #140]	@ (1118 <printf_numbers+0x12c>)
    108a:	681b      	ldr	r3, [r3, #0]
    108c:	f812 0c0c 	ldrb.w	r0, [r2, #-12]
    1090:	4798      	blx	r3
      while (num_len > 0) {
    1092:	2c00      	cmp	r4, #0
    1094:	dcf3      	bgt.n	107e <printf_numbers+0x92>
  return true;
    1096:	2001      	movs	r0, #1
    1098:	e7c9      	b.n	102e <printf_numbers+0x42>
          num[num_len++] = hextable[value % 10];
    109a:	4b23      	ldr	r3, [pc, #140]	@ (1128 <printf_numbers+0x13c>)
    109c:	fba3 2305 	umull	r2, r3, r3, r5
    10a0:	08db      	lsrs	r3, r3, #3
    10a2:	4619      	mov	r1, r3
    10a4:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    10a8:	eba5 0343 	sub.w	r3, r5, r3, lsl #1
    10ac:	481d      	ldr	r0, [pc, #116]	@ (1124 <printf_numbers+0x138>)
    10ae:	5cc0      	ldrb	r0, [r0, r3]
    10b0:	4623      	mov	r3, r4
    10b2:	3310      	adds	r3, #16
    10b4:	446b      	add	r3, sp
    10b6:	3401      	adds	r4, #1
    10b8:	f803 0c0c 	strb.w	r0, [r3, #-12]
          value = value / 10;
    10bc:	462b      	mov	r3, r5
    10be:	460d      	mov	r5, r1
        } while (value > 0);
    10c0:	2b09      	cmp	r3, #9
    10c2:	d8ea      	bhi.n	109a <printf_numbers+0xae>
        while (num_len > 0) {
    10c4:	2c00      	cmp	r4, #0
    10c6:	dd0a      	ble.n	10de <printf_numbers+0xf2>
          __write_char__(num[--num_len]);
    10c8:	3c01      	subs	r4, #1
    10ca:	f104 0310 	add.w	r3, r4, #16
    10ce:	eb0d 0203 	add.w	r2, sp, r3
    10d2:	4b11      	ldr	r3, [pc, #68]	@ (1118 <printf_numbers+0x12c>)
    10d4:	681b      	ldr	r3, [r3, #0]
    10d6:	f812 0c0c 	ldrb.w	r0, [r2, #-12]
    10da:	4798      	blx	r3
    10dc:	e7f2      	b.n	10c4 <printf_numbers+0xd8>
  return true;
    10de:	2001      	movs	r0, #1
    10e0:	e7a5      	b.n	102e <printf_numbers+0x42>
              __write_char__(hextable[val]);
    10e2:	4a0d      	ldr	r2, [pc, #52]	@ (1118 <printf_numbers+0x12c>)
    10e4:	6812      	ldr	r2, [r2, #0]
    10e6:	490f      	ldr	r1, [pc, #60]	@ (1124 <printf_numbers+0x138>)
    10e8:	5cc8      	ldrb	r0, [r1, r3]
    10ea:	4790      	blx	r2
              leading_zero_ignored = true;
    10ec:	2201      	movs	r2, #1
            start_bit -= 4;
    10ee:	3c04      	subs	r4, #4
          while (start_bit >= 0) {
    10f0:	2c00      	cmp	r4, #0
    10f2:	db0a      	blt.n	110a <printf_numbers+0x11e>
            int val = (value >> start_bit) & 0xF;
    10f4:	fa25 f304 	lsr.w	r3, r5, r4
            if (val || leading_zero_ignored) {
    10f8:	f013 030f 	ands.w	r3, r3, #15
    10fc:	d1f1      	bne.n	10e2 <printf_numbers+0xf6>
    10fe:	2a00      	cmp	r2, #0
    1100:	d0f5      	beq.n	10ee <printf_numbers+0x102>
    1102:	e7ee      	b.n	10e2 <printf_numbers+0xf6>
          bool leading_zero_ignored = false;
    1104:	2200      	movs	r2, #0
          int start_bit = LAST_NIBBLE_FIRST_BIT;
    1106:	241c      	movs	r4, #28
    1108:	e7f2      	b.n	10f0 <printf_numbers+0x104>
  return true;
    110a:	2001      	movs	r0, #1
    110c:	e78f      	b.n	102e <printf_numbers+0x42>
        return false;
    110e:	2000      	movs	r0, #0
    1110:	e78d      	b.n	102e <printf_numbers+0x42>
        return false;
    1112:	2000      	movs	r0, #0
    1114:	e78b      	b.n	102e <printf_numbers+0x42>
    1116:	bf00      	nop
    1118:	20000008 	andcs	r0, r0, r8
    111c:	00002810 	andeq	r2, r0, r0, lsl r8
    1120:	66666667 	strbtvs	r6, [r6], -r7, ror #12
    1124:	00002820 	andeq	r2, r0, r0, lsr #16
    1128:	cccccccd 	stclgt	12, cr12, [ip], {205}	@ 0xcd

0000112c <printf>:

int printf(const char *fmt, ...) {
    112c:	b40f      	push	{r0, r1, r2, r3}
    112e:	b530      	push	{r4, r5, lr}
    1130:	b083      	sub	sp, #12
    1132:	ab06      	add	r3, sp, #24
    1134:	f853 4b04 	ldr.w	r4, [r3], #4
  printf_state state = CHECK_CH;
  va_list args;

  va_start(args, fmt);
    1138:	9301      	str	r3, [sp, #4]
  printf_state state = CHECK_CH;
    113a:	2500      	movs	r5, #0

  while (*fmt) {
    113c:	e005      	b.n	114a <printf+0x1e>
    switch (state) {
      case CHECK_CH: {
        if (*fmt == '%') {
    113e:	2825      	cmp	r0, #37	@ 0x25
    1140:	d00a      	beq.n	1158 <printf+0x2c>
          state = PARSE_FMT_STR;
          fmt++;
          continue;
        }
        __write_char__(*fmt);
    1142:	4b30      	ldr	r3, [pc, #192]	@ (1204 <printf+0xd8>)
    1144:	681b      	ldr	r3, [r3, #0]
    1146:	4798      	blx	r3
        fmt++;
    1148:	3401      	adds	r4, #1
  while (*fmt) {
    114a:	7820      	ldrb	r0, [r4, #0]
    114c:	2800      	cmp	r0, #0
    114e:	d050      	beq.n	11f2 <printf+0xc6>
    switch (state) {
    1150:	2d00      	cmp	r5, #0
    1152:	d0f4      	beq.n	113e <printf+0x12>
    1154:	b925      	cbnz	r5, 1160 <printf+0x34>
    1156:	e7f8      	b.n	114a <printf+0x1e>
          fmt++;
    1158:	3401      	adds	r4, #1
          state = PARSE_FMT_STR;
    115a:	2501      	movs	r5, #1
          continue;
    115c:	e7f5      	b.n	114a <printf+0x1e>
        break;
      }
      case PARSE_FMT_STR: {
        // Support only basic format specifiers
        while (*fmt && ((*fmt >= '0' && *fmt <= '9') || *fmt == '-')) {
          fmt++;
    115e:	3401      	adds	r4, #1
        while (*fmt && ((*fmt >= '0' && *fmt <= '9') || *fmt == '-')) {
    1160:	7820      	ldrb	r0, [r4, #0]
    1162:	b130      	cbz	r0, 1172 <printf+0x46>
    1164:	f1a0 0330 	sub.w	r3, r0, #48	@ 0x30
    1168:	b2db      	uxtb	r3, r3
    116a:	2b09      	cmp	r3, #9
    116c:	d9f7      	bls.n	115e <printf+0x32>
    116e:	282d      	cmp	r0, #45	@ 0x2d
    1170:	d0f5      	beq.n	115e <printf+0x32>
        }

        switch (*fmt) {
    1172:	2863      	cmp	r0, #99	@ 0x63
    1174:	d019      	beq.n	11aa <printf+0x7e>
    1176:	d80b      	bhi.n	1190 <printf+0x64>
    1178:	2843      	cmp	r0, #67	@ 0x43
    117a:	d016      	beq.n	11aa <printf+0x7e>
    117c:	2853      	cmp	r0, #83	@ 0x53
    117e:	d00b      	beq.n	1198 <printf+0x6c>
    1180:	2825      	cmp	r0, #37	@ 0x25
    1182:	d12c      	bne.n	11de <printf+0xb2>
          case '%':
            __write_char__(*fmt);
    1184:	4b1f      	ldr	r3, [pc, #124]	@ (1204 <printf+0xd8>)
    1186:	681b      	ldr	r3, [r3, #0]
    1188:	4798      	blx	r3
            fmt++;
    118a:	3401      	adds	r4, #1
            state = CHECK_CH;
    118c:	2500      	movs	r5, #0
            break;
    118e:	e7dc      	b.n	114a <printf+0x1e>
    1190:	286c      	cmp	r0, #108	@ 0x6c
    1192:	d014      	beq.n	11be <printf+0x92>
    1194:	2873      	cmp	r0, #115	@ 0x73
    1196:	d122      	bne.n	11de <printf+0xb2>
            fmt++;
            state = CHECK_CH;
            break;
          case 's':
          case 'S':
            outstr(va_arg(args, const char *));
    1198:	9b01      	ldr	r3, [sp, #4]
    119a:	1d1a      	adds	r2, r3, #4
    119c:	9201      	str	r2, [sp, #4]
    119e:	6818      	ldr	r0, [r3, #0]
    11a0:	f7ff ff16 	bl	fd0 <outstr>
            fmt++;
    11a4:	3401      	adds	r4, #1
            state = CHECK_CH;
    11a6:	2500      	movs	r5, #0
            break;
    11a8:	e7cf      	b.n	114a <printf+0x1e>
            __write_char__(va_arg(args, int));
    11aa:	4b16      	ldr	r3, [pc, #88]	@ (1204 <printf+0xd8>)
    11ac:	681a      	ldr	r2, [r3, #0]
    11ae:	9b01      	ldr	r3, [sp, #4]
    11b0:	1d19      	adds	r1, r3, #4
    11b2:	9101      	str	r1, [sp, #4]
    11b4:	7818      	ldrb	r0, [r3, #0]
    11b6:	4790      	blx	r2
            fmt++;
    11b8:	3401      	adds	r4, #1
            state = CHECK_CH;
    11ba:	2500      	movs	r5, #0
            break;
    11bc:	e7c5      	b.n	114a <printf+0x1e>
          case 'l': {
            int l_count = 1;
            fmt++;
    11be:	1c65      	adds	r5, r4, #1
            if (*fmt == 'l') {
    11c0:	7863      	ldrb	r3, [r4, #1]
    11c2:	2b6c      	cmp	r3, #108	@ 0x6c
    11c4:	d008      	beq.n	11d8 <printf+0xac>
            int l_count = 1;
    11c6:	2201      	movs	r2, #1
              l_count++;
              fmt++;
            }
            if (printf_numbers(*fmt, &args, l_count)) {
    11c8:	a901      	add	r1, sp, #4
    11ca:	7828      	ldrb	r0, [r5, #0]
    11cc:	f7ff ff0e 	bl	fec <printf_numbers>
    11d0:	b168      	cbz	r0, 11ee <printf+0xc2>
              state = CHECK_CH;
              fmt++;
    11d2:	1c6c      	adds	r4, r5, #1
              state = CHECK_CH;
    11d4:	2500      	movs	r5, #0
              break;
    11d6:	e7b8      	b.n	114a <printf+0x1e>
              fmt++;
    11d8:	1ca5      	adds	r5, r4, #2
              l_count++;
    11da:	2202      	movs	r2, #2
    11dc:	e7f4      	b.n	11c8 <printf+0x9c>
            }
            return -1;
          }
          default: {
            if (printf_numbers(*fmt, &args, 0)) {
    11de:	2200      	movs	r2, #0
    11e0:	a901      	add	r1, sp, #4
    11e2:	f7ff ff03 	bl	fec <printf_numbers>
    11e6:	b148      	cbz	r0, 11fc <printf+0xd0>
              state = CHECK_CH;
              fmt++;
    11e8:	3401      	adds	r4, #1
              state = CHECK_CH;
    11ea:	2500      	movs	r5, #0
              break;
    11ec:	e7ad      	b.n	114a <printf+0x1e>
            return -1;
    11ee:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    }
  }

  va_end(args);
  return 0;
}
    11f2:	b003      	add	sp, #12
    11f4:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    11f8:	b004      	add	sp, #16
    11fa:	4770      	bx	lr
            return -1;
    11fc:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    1200:	e7f7      	b.n	11f2 <printf+0xc6>
    1202:	bf00      	nop
    1204:	20000008 	andcs	r0, r0, r8

00001208 <outstr2>:
} printf2_state;

static char hextable2[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                          '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

static void outstr2(const char *str) {
    1208:	b510      	push	{r4, lr}
    120a:	4604      	mov	r4, r0
  while (*str != '\0') {
    120c:	e003      	b.n	1216 <outstr2+0xe>
    __write_char2__(*str);
    120e:	4b04      	ldr	r3, [pc, #16]	@ (1220 <outstr2+0x18>)
    1210:	681b      	ldr	r3, [r3, #0]
    1212:	4798      	blx	r3
    str++;
    1214:	3401      	adds	r4, #1
  while (*str != '\0') {
    1216:	7820      	ldrb	r0, [r4, #0]
    1218:	2800      	cmp	r0, #0
    121a:	d1f8      	bne.n	120e <outstr2+0x6>
  }
}
    121c:	bd10      	pop	{r4, pc}
    121e:	bf00      	nop
    1220:	20000120 	andcs	r0, r0, r0, lsr #2

00001224 <printf2_numbers>:

static bool printf2_numbers(const char fmt, va_list *args, int l_count) {
    1224:	b530      	push	{r4, r5, lr}
    1226:	b085      	sub	sp, #20
    1228:	4614      	mov	r4, r2
  char num[MAX_DIGITS];
  int num_len = 0;

  switch (fmt) {
    122a:	2864      	cmp	r0, #100	@ 0x64
    122c:	d01d      	beq.n	126a <printf2_numbers+0x46>
    122e:	d914      	bls.n	125a <printf2_numbers+0x36>
    1230:	2875      	cmp	r0, #117	@ 0x75
    1232:	d001      	beq.n	1238 <printf2_numbers+0x14>
    1234:	2878      	cmp	r0, #120	@ 0x78
    1236:	d112      	bne.n	125e <printf2_numbers+0x3a>
#ifndef SHELL_NO_PRINTF_LL
      long long unsigned int value = 0;
#else
      unsigned int value = 0;
#endif  // SHELL_NO_PRINTF_LL
      if (l_count == 0) {
    1238:	2c00      	cmp	r4, #0
    123a:	f040 8086 	bne.w	134a <printf2_numbers+0x126>
        value = va_arg(*args, unsigned int);
    123e:	680b      	ldr	r3, [r1, #0]
    1240:	1d1a      	adds	r2, r3, #4
    1242:	600a      	str	r2, [r1, #0]
    1244:	681d      	ldr	r5, [r3, #0]
#endif  // SHELL_NO_PRINTF_LL
      } else {
        return false;
      }

      if (fmt == 'u') {
    1246:	2875      	cmp	r0, #117	@ 0x75
    1248:	d043      	beq.n	12d2 <printf2_numbers+0xae>

        while (num_len > 0) {
          __write_char2__(num[--num_len]);
        };
      } else {
        if (value == 0) {
    124a:	2d00      	cmp	r5, #0
    124c:	d176      	bne.n	133c <printf2_numbers+0x118>
          __write_char2__(hextable2[0]);
    124e:	4b40      	ldr	r3, [pc, #256]	@ (1350 <printf2_numbers+0x12c>)
    1250:	681b      	ldr	r3, [r3, #0]
    1252:	2030      	movs	r0, #48	@ 0x30
    1254:	4798      	blx	r3
    }
    default:
      outstr2("\nprintf2-error\n");
      return false;
  }
  return true;
    1256:	2001      	movs	r0, #1
    1258:	e005      	b.n	1266 <printf2_numbers+0x42>
  switch (fmt) {
    125a:	2858      	cmp	r0, #88	@ 0x58
    125c:	d0ec      	beq.n	1238 <printf2_numbers+0x14>
      outstr2("\nprintf2-error\n");
    125e:	483d      	ldr	r0, [pc, #244]	@ (1354 <printf2_numbers+0x130>)
    1260:	f7ff ffd2 	bl	1208 <outstr2>
      return false;
    1264:	2000      	movs	r0, #0
}
    1266:	b005      	add	sp, #20
    1268:	bd30      	pop	{r4, r5, pc}
      if (l_count == 0) {
    126a:	2a00      	cmp	r2, #0
    126c:	d16b      	bne.n	1346 <printf2_numbers+0x122>
        value = va_arg(*args, int);
    126e:	680b      	ldr	r3, [r1, #0]
    1270:	1d1a      	adds	r2, r3, #4
    1272:	600a      	str	r2, [r1, #0]
    1274:	681d      	ldr	r5, [r3, #0]
      if (value < 0) {
    1276:	2d00      	cmp	r5, #0
    1278:	db17      	blt.n	12aa <printf2_numbers+0x86>
        num[num_len++] = hextable2[value % 10];
    127a:	4a37      	ldr	r2, [pc, #220]	@ (1358 <printf2_numbers+0x134>)
    127c:	fb82 3205 	smull	r3, r2, r2, r5
    1280:	17eb      	asrs	r3, r5, #31
    1282:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
    1286:	4619      	mov	r1, r3
    1288:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    128c:	eba5 0343 	sub.w	r3, r5, r3, lsl #1
    1290:	4832      	ldr	r0, [pc, #200]	@ (135c <printf2_numbers+0x138>)
    1292:	5cc0      	ldrb	r0, [r0, r3]
    1294:	4623      	mov	r3, r4
    1296:	3310      	adds	r3, #16
    1298:	446b      	add	r3, sp
    129a:	3401      	adds	r4, #1
    129c:	f803 0c0c 	strb.w	r0, [r3, #-12]
        value = value / 10;
    12a0:	462b      	mov	r3, r5
    12a2:	460d      	mov	r5, r1
      } while (value > 0);
    12a4:	2b09      	cmp	r3, #9
    12a6:	dce8      	bgt.n	127a <printf2_numbers+0x56>
    12a8:	e00f      	b.n	12ca <printf2_numbers+0xa6>
        __write_char2__('-');
    12aa:	4b29      	ldr	r3, [pc, #164]	@ (1350 <printf2_numbers+0x12c>)
    12ac:	681b      	ldr	r3, [r3, #0]
    12ae:	202d      	movs	r0, #45	@ 0x2d
    12b0:	4798      	blx	r3
        value = -value;
    12b2:	426d      	negs	r5, r5
    12b4:	e7e1      	b.n	127a <printf2_numbers+0x56>
        __write_char2__(num[--num_len]);
    12b6:	3c01      	subs	r4, #1
    12b8:	f104 0310 	add.w	r3, r4, #16
    12bc:	eb0d 0203 	add.w	r2, sp, r3
    12c0:	4b23      	ldr	r3, [pc, #140]	@ (1350 <printf2_numbers+0x12c>)
    12c2:	681b      	ldr	r3, [r3, #0]
    12c4:	f812 0c0c 	ldrb.w	r0, [r2, #-12]
    12c8:	4798      	blx	r3
      while (num_len > 0) {
    12ca:	2c00      	cmp	r4, #0
    12cc:	dcf3      	bgt.n	12b6 <printf2_numbers+0x92>
  return true;
    12ce:	2001      	movs	r0, #1
    12d0:	e7c9      	b.n	1266 <printf2_numbers+0x42>
          num[num_len++] = hextable2[value % 10];
    12d2:	4b23      	ldr	r3, [pc, #140]	@ (1360 <printf2_numbers+0x13c>)
    12d4:	fba3 2305 	umull	r2, r3, r3, r5
    12d8:	08db      	lsrs	r3, r3, #3
    12da:	4619      	mov	r1, r3
    12dc:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    12e0:	eba5 0343 	sub.w	r3, r5, r3, lsl #1
    12e4:	481d      	ldr	r0, [pc, #116]	@ (135c <printf2_numbers+0x138>)
    12e6:	5cc0      	ldrb	r0, [r0, r3]
    12e8:	4623      	mov	r3, r4
    12ea:	3310      	adds	r3, #16
    12ec:	446b      	add	r3, sp
    12ee:	3401      	adds	r4, #1
    12f0:	f803 0c0c 	strb.w	r0, [r3, #-12]
          value = value / 10;
    12f4:	462b      	mov	r3, r5
    12f6:	460d      	mov	r5, r1
        } while (value > 0);
    12f8:	2b09      	cmp	r3, #9
    12fa:	d8ea      	bhi.n	12d2 <printf2_numbers+0xae>
        while (num_len > 0) {
    12fc:	2c00      	cmp	r4, #0
    12fe:	dd0a      	ble.n	1316 <printf2_numbers+0xf2>
          __write_char2__(num[--num_len]);
    1300:	3c01      	subs	r4, #1
    1302:	f104 0310 	add.w	r3, r4, #16
    1306:	eb0d 0203 	add.w	r2, sp, r3
    130a:	4b11      	ldr	r3, [pc, #68]	@ (1350 <printf2_numbers+0x12c>)
    130c:	681b      	ldr	r3, [r3, #0]
    130e:	f812 0c0c 	ldrb.w	r0, [r2, #-12]
    1312:	4798      	blx	r3
    1314:	e7f2      	b.n	12fc <printf2_numbers+0xd8>
  return true;
    1316:	2001      	movs	r0, #1
    1318:	e7a5      	b.n	1266 <printf2_numbers+0x42>
              __write_char2__(hextable2[val]);
    131a:	4a0d      	ldr	r2, [pc, #52]	@ (1350 <printf2_numbers+0x12c>)
    131c:	6812      	ldr	r2, [r2, #0]
    131e:	490f      	ldr	r1, [pc, #60]	@ (135c <printf2_numbers+0x138>)
    1320:	5cc8      	ldrb	r0, [r1, r3]
    1322:	4790      	blx	r2
              leading_zero_ignored = true;
    1324:	2201      	movs	r2, #1
            start_bit -= 4;
    1326:	3c04      	subs	r4, #4
          while (start_bit >= 0) {
    1328:	2c00      	cmp	r4, #0
    132a:	db0a      	blt.n	1342 <printf2_numbers+0x11e>
            int val = (value >> start_bit) & 0xF;
    132c:	fa25 f304 	lsr.w	r3, r5, r4
            if (val || leading_zero_ignored) {
    1330:	f013 030f 	ands.w	r3, r3, #15
    1334:	d1f1      	bne.n	131a <printf2_numbers+0xf6>
    1336:	2a00      	cmp	r2, #0
    1338:	d0f5      	beq.n	1326 <printf2_numbers+0x102>
    133a:	e7ee      	b.n	131a <printf2_numbers+0xf6>
          bool leading_zero_ignored = false;
    133c:	2200      	movs	r2, #0
          int start_bit = LAST_NIBBLE_FIRST_BIT;
    133e:	241c      	movs	r4, #28
    1340:	e7f2      	b.n	1328 <printf2_numbers+0x104>
  return true;
    1342:	2001      	movs	r0, #1
    1344:	e78f      	b.n	1266 <printf2_numbers+0x42>
        return false;
    1346:	2000      	movs	r0, #0
    1348:	e78d      	b.n	1266 <printf2_numbers+0x42>
        return false;
    134a:	2000      	movs	r0, #0
    134c:	e78b      	b.n	1266 <printf2_numbers+0x42>
    134e:	bf00      	nop
    1350:	20000120 	andcs	r0, r0, r0, lsr #2
    1354:	00002830 	andeq	r2, r0, r0, lsr r8
    1358:	66666667 	strbtvs	r6, [r6], -r7, ror #12
    135c:	00002840 	andeq	r2, r0, r0, asr #16
    1360:	cccccccd 	stclgt	12, cr12, [ip], {205}	@ 0xcd

00001364 <printf2>:

int printf2(const char *fmt, ...) {
    1364:	b40f      	push	{r0, r1, r2, r3}
    1366:	b530      	push	{r4, r5, lr}
    1368:	b083      	sub	sp, #12
    136a:	ab06      	add	r3, sp, #24
    136c:	f853 4b04 	ldr.w	r4, [r3], #4
  printf2_state state = CHECK_CH;
  va_list args;

  va_start(args, fmt);
    1370:	9301      	str	r3, [sp, #4]
  printf2_state state = CHECK_CH;
    1372:	2500      	movs	r5, #0

  while (*fmt) {
    1374:	e005      	b.n	1382 <printf2+0x1e>
    switch (state) {
      case CHECK_CH: {
        if (*fmt == '%') {
    1376:	2825      	cmp	r0, #37	@ 0x25
    1378:	d00a      	beq.n	1390 <printf2+0x2c>
          state = PARSE_FMT_STR;
          fmt++;
          continue;
        }
        __write_char2__(*fmt);
    137a:	4b30      	ldr	r3, [pc, #192]	@ (143c <printf2+0xd8>)
    137c:	681b      	ldr	r3, [r3, #0]
    137e:	4798      	blx	r3
        fmt++;
    1380:	3401      	adds	r4, #1
  while (*fmt) {
    1382:	7820      	ldrb	r0, [r4, #0]
    1384:	2800      	cmp	r0, #0
    1386:	d050      	beq.n	142a <printf2+0xc6>
    switch (state) {
    1388:	2d00      	cmp	r5, #0
    138a:	d0f4      	beq.n	1376 <printf2+0x12>
    138c:	b925      	cbnz	r5, 1398 <printf2+0x34>
    138e:	e7f8      	b.n	1382 <printf2+0x1e>
          fmt++;
    1390:	3401      	adds	r4, #1
          state = PARSE_FMT_STR;
    1392:	2501      	movs	r5, #1
          continue;
    1394:	e7f5      	b.n	1382 <printf2+0x1e>
        break;
      }
      case PARSE_FMT_STR: {
        // Support only basic format specifiers
        while (*fmt && ((*fmt >= '0' && *fmt <= '9') || *fmt == '-')) {
          fmt++;
    1396:	3401      	adds	r4, #1
        while (*fmt && ((*fmt >= '0' && *fmt <= '9') || *fmt == '-')) {
    1398:	7820      	ldrb	r0, [r4, #0]
    139a:	b130      	cbz	r0, 13aa <printf2+0x46>
    139c:	f1a0 0330 	sub.w	r3, r0, #48	@ 0x30
    13a0:	b2db      	uxtb	r3, r3
    13a2:	2b09      	cmp	r3, #9
    13a4:	d9f7      	bls.n	1396 <printf2+0x32>
    13a6:	282d      	cmp	r0, #45	@ 0x2d
    13a8:	d0f5      	beq.n	1396 <printf2+0x32>
        }

        switch (*fmt) {
    13aa:	2863      	cmp	r0, #99	@ 0x63
    13ac:	d019      	beq.n	13e2 <printf2+0x7e>
    13ae:	d80b      	bhi.n	13c8 <printf2+0x64>
    13b0:	2843      	cmp	r0, #67	@ 0x43
    13b2:	d016      	beq.n	13e2 <printf2+0x7e>
    13b4:	2853      	cmp	r0, #83	@ 0x53
    13b6:	d00b      	beq.n	13d0 <printf2+0x6c>
    13b8:	2825      	cmp	r0, #37	@ 0x25
    13ba:	d12c      	bne.n	1416 <printf2+0xb2>
          case '%':
            __write_char2__(*fmt);
    13bc:	4b1f      	ldr	r3, [pc, #124]	@ (143c <printf2+0xd8>)
    13be:	681b      	ldr	r3, [r3, #0]
    13c0:	4798      	blx	r3
            fmt++;
    13c2:	3401      	adds	r4, #1
            state = CHECK_CH;
    13c4:	2500      	movs	r5, #0
            break;
    13c6:	e7dc      	b.n	1382 <printf2+0x1e>
    13c8:	286c      	cmp	r0, #108	@ 0x6c
    13ca:	d014      	beq.n	13f6 <printf2+0x92>
    13cc:	2873      	cmp	r0, #115	@ 0x73
    13ce:	d122      	bne.n	1416 <printf2+0xb2>
            fmt++;
            state = CHECK_CH;
            break;
          case 's':
          case 'S':
            outstr2(va_arg(args, const char *));
    13d0:	9b01      	ldr	r3, [sp, #4]
    13d2:	1d1a      	adds	r2, r3, #4
    13d4:	9201      	str	r2, [sp, #4]
    13d6:	6818      	ldr	r0, [r3, #0]
    13d8:	f7ff ff16 	bl	1208 <outstr2>
            fmt++;
    13dc:	3401      	adds	r4, #1
            state = CHECK_CH;
    13de:	2500      	movs	r5, #0
            break;
    13e0:	e7cf      	b.n	1382 <printf2+0x1e>
            __write_char2__(va_arg(args, int));
    13e2:	4b16      	ldr	r3, [pc, #88]	@ (143c <printf2+0xd8>)
    13e4:	681a      	ldr	r2, [r3, #0]
    13e6:	9b01      	ldr	r3, [sp, #4]
    13e8:	1d19      	adds	r1, r3, #4
    13ea:	9101      	str	r1, [sp, #4]
    13ec:	7818      	ldrb	r0, [r3, #0]
    13ee:	4790      	blx	r2
            fmt++;
    13f0:	3401      	adds	r4, #1
            state = CHECK_CH;
    13f2:	2500      	movs	r5, #0
            break;
    13f4:	e7c5      	b.n	1382 <printf2+0x1e>
          case 'l': {
            int l_count = 1;
            fmt++;
    13f6:	1c65      	adds	r5, r4, #1
            if (*fmt == 'l') {
    13f8:	7863      	ldrb	r3, [r4, #1]
    13fa:	2b6c      	cmp	r3, #108	@ 0x6c
    13fc:	d008      	beq.n	1410 <printf2+0xac>
            int l_count = 1;
    13fe:	2201      	movs	r2, #1
              l_count++;
              fmt++;
            }
            if (printf2_numbers(*fmt, &args, l_count)) {
    1400:	a901      	add	r1, sp, #4
    1402:	7828      	ldrb	r0, [r5, #0]
    1404:	f7ff ff0e 	bl	1224 <printf2_numbers>
    1408:	b168      	cbz	r0, 1426 <printf2+0xc2>
              state = CHECK_CH;
              fmt++;
    140a:	1c6c      	adds	r4, r5, #1
              state = CHECK_CH;
    140c:	2500      	movs	r5, #0
              break;
    140e:	e7b8      	b.n	1382 <printf2+0x1e>
              fmt++;
    1410:	1ca5      	adds	r5, r4, #2
              l_count++;
    1412:	2202      	movs	r2, #2
    1414:	e7f4      	b.n	1400 <printf2+0x9c>
            }
            return -1;
          }
          default: {
            if (printf2_numbers(*fmt, &args, 0)) {
    1416:	2200      	movs	r2, #0
    1418:	a901      	add	r1, sp, #4
    141a:	f7ff ff03 	bl	1224 <printf2_numbers>
    141e:	b148      	cbz	r0, 1434 <printf2+0xd0>
              state = CHECK_CH;
              fmt++;
    1420:	3401      	adds	r4, #1
              state = CHECK_CH;
    1422:	2500      	movs	r5, #0
              break;
    1424:	e7ad      	b.n	1382 <printf2+0x1e>
            return -1;
    1426:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    }
  }

  va_end(args);
  return 0;
}
    142a:	b003      	add	sp, #12
    142c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    1430:	b004      	add	sp, #16
    1432:	4770      	bx	lr
            return -1;
    1434:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    1438:	e7f7      	b.n	142a <printf2+0xc6>
    143a:	bf00      	nop
    143c:	20000120 	andcs	r0, r0, r0, lsr #2

00001440 <r32>:
/*
 * Memory manipulation utilities can be skipped to reduce
 * final binary size. Skip if SHELL_NO_UTILS is defined.
 */
#ifndef SHELL_NO_UTILS
int r32(int argc, char *argv[]) {
    1440:	b508      	push	{r3, lr}
  if (argc < 2) {
    1442:	2801      	cmp	r0, #1
    1444:	dd09      	ble.n	145a <r32+0x1a>
    printf("Usage: %s <address> (in hex)\n", argv[0]);
    return -1;
  }

  uint32_t addr = atoh(argv[1]);
    1446:	6848      	ldr	r0, [r1, #4]
    1448:	f000 fe61 	bl	210e <atoh>
    144c:	4601      	mov	r1, r0
  uint32_t data;

  data = reg32(addr);
    144e:	6802      	ldr	r2, [r0, #0]

  printf("0x%x: 0x%x\n", addr, data);
    1450:	4805      	ldr	r0, [pc, #20]	@ (1468 <r32+0x28>)
    1452:	f7ff fe6b 	bl	112c <printf>
  return 0;
    1456:	2000      	movs	r0, #0
}
    1458:	bd08      	pop	{r3, pc}
    printf("Usage: %s <address> (in hex)\n", argv[0]);
    145a:	6809      	ldr	r1, [r1, #0]
    145c:	4803      	ldr	r0, [pc, #12]	@ (146c <r32+0x2c>)
    145e:	f7ff fe65 	bl	112c <printf>
    return -1;
    1462:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    1466:	e7f7      	b.n	1458 <r32+0x18>
    1468:	00002870 	andeq	r2, r0, r0, ror r8
    146c:	00002850 	andeq	r2, r0, r0, asr r8

00001470 <w32>:

int w32(int argc, char *argv[]) {
    1470:	b538      	push	{r3, r4, r5, lr}
    1472:	460c      	mov	r4, r1
  if (argc < 3) {
    1474:	2802      	cmp	r0, #2
    1476:	dd09      	ble.n	148c <w32+0x1c>
    printf("Usage: %s <address> (in hex) <value> (in hex)\n", argv[0]);
    return -1;
  }
  uint32_t addr = atoh(argv[1]);
    1478:	6848      	ldr	r0, [r1, #4]
    147a:	f000 fe48 	bl	210e <atoh>
    147e:	4605      	mov	r5, r0
  uint32_t data = atoh(argv[2]);
    1480:	68a0      	ldr	r0, [r4, #8]
    1482:	f000 fe44 	bl	210e <atoh>
  reg32(addr) = data;
    1486:	6028      	str	r0, [r5, #0]

  return 0;
    1488:	2000      	movs	r0, #0
}
    148a:	bd38      	pop	{r3, r4, r5, pc}
    printf("Usage: %s <address> (in hex) <value> (in hex)\n", argv[0]);
    148c:	6809      	ldr	r1, [r1, #0]
    148e:	4803      	ldr	r0, [pc, #12]	@ (149c <w32+0x2c>)
    1490:	f7ff fe4c 	bl	112c <printf>
    return -1;
    1494:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    1498:	e7f7      	b.n	148a <w32+0x1a>
    149a:	bf00      	nop
    149c:	0000287c 	andeq	r2, r0, ip, ror r8

000014a0 <read_mem>:

int read_mem(int argc, char *argv[]) {
    14a0:	b570      	push	{r4, r5, r6, lr}
    14a2:	460d      	mov	r5, r1
  if (argc < 3) {
    14a4:	2802      	cmp	r0, #2
    14a6:	dd09      	ble.n	14bc <read_mem+0x1c>
    printf("Usage: %s <address> (in hex) <num_words> (in decimal)\n", argv[0]);
    return -1;
  }

  uint32_t addr = atoh(argv[1]);
    14a8:	6848      	ldr	r0, [r1, #4]
    14aa:	f000 fe30 	bl	210e <atoh>
    14ae:	4604      	mov	r4, r0
  uint32_t length = atoi(argv[2]);
    14b0:	68a8      	ldr	r0, [r5, #8]
    14b2:	f000 fe1d 	bl	20f0 <atoi>
    14b6:	4606      	mov	r6, r0

  for (uint32_t i = 0, data = 0; i < length; i++) {
    14b8:	2500      	movs	r5, #0
    14ba:	e00d      	b.n	14d8 <read_mem+0x38>
    printf("Usage: %s <address> (in hex) <num_words> (in decimal)\n", argv[0]);
    14bc:	6809      	ldr	r1, [r1, #0]
    14be:	4808      	ldr	r0, [pc, #32]	@ (14e0 <read_mem+0x40>)
    14c0:	f7ff fe34 	bl	112c <printf>
    return -1;
    14c4:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    14c8:	e009      	b.n	14de <read_mem+0x3e>
    data = reg32(addr);
    14ca:	6822      	ldr	r2, [r4, #0]
    printf("0x%x: 0x%x\n", addr, data);
    14cc:	4621      	mov	r1, r4
    14ce:	4805      	ldr	r0, [pc, #20]	@ (14e4 <read_mem+0x44>)
    14d0:	f7ff fe2c 	bl	112c <printf>

    addr += 4;
    14d4:	3404      	adds	r4, #4
  for (uint32_t i = 0, data = 0; i < length; i++) {
    14d6:	3501      	adds	r5, #1
    14d8:	42b5      	cmp	r5, r6
    14da:	d3f6      	bcc.n	14ca <read_mem+0x2a>
  }

  return 0;
    14dc:	2000      	movs	r0, #0
}
    14de:	bd70      	pop	{r4, r5, r6, pc}
    14e0:	000028ac 	andeq	r2, r0, ip, lsr #17
    14e4:	00002870 	andeq	r2, r0, r0, ror r8

000014e8 <w32_bit>:

#ifndef SHELL_NO_BIT_UTILS
int w32_bit(int argc, char *argv[])
{
    14e8:	b570      	push	{r4, r5, r6, lr}
    14ea:	460c      	mov	r4, r1
  if (argc < 4) {
    14ec:	2803      	cmp	r0, #3
    14ee:	dd22      	ble.n	1536 <w32_bit+0x4e>
    goto usage;
  }

  uint32_t addr = atoh(argv[1]);
    14f0:	6848      	ldr	r0, [r1, #4]
    14f2:	f000 fe0c 	bl	210e <atoh>
    14f6:	4606      	mov	r6, r0
  uint32_t bit_loc = atoi(argv[2]);
    14f8:	68a0      	ldr	r0, [r4, #8]
    14fa:	f000 fdf9 	bl	20f0 <atoi>
    14fe:	4605      	mov	r5, r0
  uint32_t bit_val = atoi(argv[3]);
    1500:	68e0      	ldr	r0, [r4, #12]
    1502:	f000 fdf5 	bl	20f0 <atoi>

  if (bit_loc > 31) {
    1506:	2d1f      	cmp	r5, #31
    1508:	d80e      	bhi.n	1528 <w32_bit+0x40>
    printf("Error: Invalid bit location argument\n");
    goto usage;
  }

  if (bit_val != 0 && bit_val != 1) {
    150a:	2801      	cmp	r0, #1
    150c:	d810      	bhi.n	1530 <w32_bit+0x48>
    printf("Error: Invalid bit value argument\n");
    goto usage;
  }

  uint32_t data = reg32(addr);
    150e:	6832      	ldr	r2, [r6, #0]
  data = data | (bit_val << bit_loc);
    1510:	fa00 f305 	lsl.w	r3, r0, r5
    1514:	431a      	orrs	r2, r3
  data = data & ~(!bit_val << bit_loc);
    1516:	fab0 f380 	clz	r3, r0
    151a:	095b      	lsrs	r3, r3, #5
    151c:	40ab      	lsls	r3, r5
    151e:	ea22 0303 	bic.w	r3, r2, r3
  reg32(addr) = data;
    1522:	6033      	str	r3, [r6, #0]

  return 0;
    1524:	2000      	movs	r0, #0
usage:
  printf("Usage: %s <address_in_hex(32-bits)> <bit_location_in_decimal(0 to 31)> <bit_value(0 or 1)>\n", argv[0]);
  return -1;
}
    1526:	bd70      	pop	{r4, r5, r6, pc}
    printf("Error: Invalid bit location argument\n");
    1528:	4806      	ldr	r0, [pc, #24]	@ (1544 <w32_bit+0x5c>)
    152a:	f7ff fdff 	bl	112c <printf>
    goto usage;
    152e:	e002      	b.n	1536 <w32_bit+0x4e>
    printf("Error: Invalid bit value argument\n");
    1530:	4805      	ldr	r0, [pc, #20]	@ (1548 <w32_bit+0x60>)
    1532:	f7ff fdfb 	bl	112c <printf>
  printf("Usage: %s <address_in_hex(32-bits)> <bit_location_in_decimal(0 to 31)> <bit_value(0 or 1)>\n", argv[0]);
    1536:	6821      	ldr	r1, [r4, #0]
    1538:	4804      	ldr	r0, [pc, #16]	@ (154c <w32_bit+0x64>)
    153a:	f7ff fdf7 	bl	112c <printf>
  return -1;
    153e:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    1542:	e7f0      	b.n	1526 <w32_bit+0x3e>
    1544:	000028e4 	andeq	r2, r0, r4, ror #17
    1548:	0000290c 	andeq	r2, r0, ip, lsl #18
    154c:	00002930 	andeq	r2, r0, r0, lsr r9

00001550 <r32_bit>:

int r32_bit(int argc, char *argv[])
{
    1550:	b538      	push	{r3, r4, r5, lr}
    1552:	460c      	mov	r4, r1
  if (argc < 3) {
    1554:	2802      	cmp	r0, #2
    1556:	dd16      	ble.n	1586 <r32_bit+0x36>
    goto usage;
  }

  uint32_t addr = atoh(argv[1]);
    1558:	6848      	ldr	r0, [r1, #4]
    155a:	f000 fdd8 	bl	210e <atoh>
    155e:	4605      	mov	r5, r0
  uint32_t bit_loc = atoi(argv[2]);
    1560:	68a0      	ldr	r0, [r4, #8]
    1562:	f000 fdc5 	bl	20f0 <atoi>
    1566:	4601      	mov	r1, r0

  if (bit_loc > 31) {
    1568:	281f      	cmp	r0, #31
    156a:	d809      	bhi.n	1580 <r32_bit+0x30>
    printf("Error: Invalid bit location argument\n");
    goto usage;
  }

  uint32_t data = reg32(addr);
    156c:	682b      	ldr	r3, [r5, #0]
  uint32_t bit_val = (data >> bit_loc) & 0x1;
    156e:	40c3      	lsrs	r3, r0
  printf("Bit %u @ 0x%08x: %u\n", bit_loc, addr, bit_val);
    1570:	f003 0301 	and.w	r3, r3, #1
    1574:	462a      	mov	r2, r5
    1576:	4807      	ldr	r0, [pc, #28]	@ (1594 <r32_bit+0x44>)
    1578:	f7ff fdd8 	bl	112c <printf>
  return 0;
    157c:	2000      	movs	r0, #0

usage:
  printf("Usage: %s <address_in_hex(32-bits)> <bit_location_in_decimal(0 to 31)\n", argv[0]);
  return -1;
}
    157e:	bd38      	pop	{r3, r4, r5, pc}
    printf("Error: Invalid bit location argument\n");
    1580:	4805      	ldr	r0, [pc, #20]	@ (1598 <r32_bit+0x48>)
    1582:	f7ff fdd3 	bl	112c <printf>
  printf("Usage: %s <address_in_hex(32-bits)> <bit_location_in_decimal(0 to 31)\n", argv[0]);
    1586:	6821      	ldr	r1, [r4, #0]
    1588:	4804      	ldr	r0, [pc, #16]	@ (159c <r32_bit+0x4c>)
    158a:	f7ff fdcf 	bl	112c <printf>
  return -1;
    158e:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    1592:	e7f4      	b.n	157e <r32_bit+0x2e>
    1594:	0000298c 	andeq	r2, r0, ip, lsl #19
    1598:	000028e4 	andeq	r2, r0, r4, ror #17
    159c:	000029a4 	andeq	r2, r0, r4, lsr #19

000015a0 <KeyExpansion>:
*/
#define getSBoxValue(num) (sbox[(num)])

// This function produces Nb(Nr+1) round keys. The round keys are used in each round to decrypt the states. 
static void KeyExpansion(uint8_t* RoundKey, const uint8_t* Key)
{
    15a0:	b510      	push	{r4, lr}
    15a2:	b082      	sub	sp, #8
  unsigned i, j, k;
  uint8_t tempa[4]; // Used for the column/row operations
  
  // The first round key is the key itself.
  for (i = 0; i < Nk; ++i)
    15a4:	2200      	movs	r2, #0
    15a6:	e012      	b.n	15ce <KeyExpansion+0x2e>
  {
    RoundKey[(i * 4) + 0] = Key[(i * 4) + 0];
    15a8:	0093      	lsls	r3, r2, #2
    15aa:	f811 4022 	ldrb.w	r4, [r1, r2, lsl #2]
    15ae:	f800 4022 	strb.w	r4, [r0, r2, lsl #2]
    RoundKey[(i * 4) + 1] = Key[(i * 4) + 1];
    15b2:	1c5c      	adds	r4, r3, #1
    15b4:	f811 c004 	ldrb.w	ip, [r1, r4]
    15b8:	f800 c004 	strb.w	ip, [r0, r4]
    RoundKey[(i * 4) + 2] = Key[(i * 4) + 2];
    15bc:	1c9c      	adds	r4, r3, #2
    15be:	f811 c004 	ldrb.w	ip, [r1, r4]
    15c2:	f800 c004 	strb.w	ip, [r0, r4]
    RoundKey[(i * 4) + 3] = Key[(i * 4) + 3];
    15c6:	3303      	adds	r3, #3
    15c8:	5ccc      	ldrb	r4, [r1, r3]
    15ca:	54c4      	strb	r4, [r0, r3]
  for (i = 0; i < Nk; ++i)
    15cc:	3201      	adds	r2, #1
    15ce:	2a03      	cmp	r2, #3
    15d0:	d9ea      	bls.n	15a8 <KeyExpansion+0x8>
  }

  // All other round keys are found from the previous round keys.
  for (i = Nk; i < Nb * (Nr + 1); ++i)
    15d2:	2304      	movs	r3, #4
    15d4:	e024      	b.n	1620 <KeyExpansion+0x80>
        tempa[2] = getSBoxValue(tempa[2]);
        tempa[3] = getSBoxValue(tempa[3]);
      }
    }
#endif
    j = i * 4; k=(i - Nk) * 4;
    15d6:	0099      	lsls	r1, r3, #2
    15d8:	1f1a      	subs	r2, r3, #4
    RoundKey[j + 0] = RoundKey[k + 0] ^ tempa[0];
    15da:	f810 c022 	ldrb.w	ip, [r0, r2, lsl #2]
    15de:	f89d 4004 	ldrb.w	r4, [sp, #4]
    15e2:	ea8c 0c04 	eor.w	ip, ip, r4
    15e6:	f800 c023 	strb.w	ip, [r0, r3, lsl #2]
    RoundKey[j + 1] = RoundKey[k + 1] ^ tempa[1];
    15ea:	eb00 0282 	add.w	r2, r0, r2, lsl #2
    15ee:	f892 c001 	ldrb.w	ip, [r2, #1]
    15f2:	f89d e005 	ldrb.w	lr, [sp, #5]
    15f6:	1c4c      	adds	r4, r1, #1
    15f8:	ea8c 0c0e 	eor.w	ip, ip, lr
    15fc:	f800 c004 	strb.w	ip, [r0, r4]
    RoundKey[j + 2] = RoundKey[k + 2] ^ tempa[2];
    1600:	f892 c002 	ldrb.w	ip, [r2, #2]
    1604:	f89d e006 	ldrb.w	lr, [sp, #6]
    1608:	1c8c      	adds	r4, r1, #2
    160a:	ea8c 0c0e 	eor.w	ip, ip, lr
    160e:	f800 c004 	strb.w	ip, [r0, r4]
    RoundKey[j + 3] = RoundKey[k + 3] ^ tempa[3];
    1612:	78d2      	ldrb	r2, [r2, #3]
    1614:	f89d 4007 	ldrb.w	r4, [sp, #7]
    1618:	3103      	adds	r1, #3
    161a:	4062      	eors	r2, r4
    161c:	5442      	strb	r2, [r0, r1]
  for (i = Nk; i < Nb * (Nr + 1); ++i)
    161e:	3301      	adds	r3, #1
    1620:	2b2b      	cmp	r3, #43	@ 0x2b
    1622:	d833      	bhi.n	168c <KeyExpansion+0xec>
      k = (i - 1) * 4;
    1624:	1e5a      	subs	r2, r3, #1
      tempa[0]=RoundKey[k + 0];
    1626:	f810 1022 	ldrb.w	r1, [r0, r2, lsl #2]
    162a:	f88d 1004 	strb.w	r1, [sp, #4]
      tempa[1]=RoundKey[k + 1];
    162e:	eb00 0282 	add.w	r2, r0, r2, lsl #2
    1632:	7854      	ldrb	r4, [r2, #1]
    1634:	f88d 4005 	strb.w	r4, [sp, #5]
      tempa[2]=RoundKey[k + 2];
    1638:	f892 e002 	ldrb.w	lr, [r2, #2]
    163c:	f88d e006 	strb.w	lr, [sp, #6]
      tempa[3]=RoundKey[k + 3];
    1640:	f892 c003 	ldrb.w	ip, [r2, #3]
    1644:	f88d c007 	strb.w	ip, [sp, #7]
    if (i % Nk == 0)
    1648:	f013 0f03 	tst.w	r3, #3
    164c:	d1c3      	bne.n	15d6 <KeyExpansion+0x36>
        tempa[0] = tempa[1];
    164e:	f88d 4004 	strb.w	r4, [sp, #4]
        tempa[1] = tempa[2];
    1652:	f88d e005 	strb.w	lr, [sp, #5]
        tempa[2] = tempa[3];
    1656:	f88d c006 	strb.w	ip, [sp, #6]
        tempa[3] = u8tmp;
    165a:	f88d 1007 	strb.w	r1, [sp, #7]
        tempa[0] = getSBoxValue(tempa[0]);
    165e:	4a0c      	ldr	r2, [pc, #48]	@ (1690 <KeyExpansion+0xf0>)
    1660:	5d14      	ldrb	r4, [r2, r4]
    1662:	f88d 4004 	strb.w	r4, [sp, #4]
        tempa[1] = getSBoxValue(tempa[1]);
    1666:	f812 e00e 	ldrb.w	lr, [r2, lr]
    166a:	f88d e005 	strb.w	lr, [sp, #5]
        tempa[2] = getSBoxValue(tempa[2]);
    166e:	f812 c00c 	ldrb.w	ip, [r2, ip]
    1672:	f88d c006 	strb.w	ip, [sp, #6]
        tempa[3] = getSBoxValue(tempa[3]);
    1676:	5c51      	ldrb	r1, [r2, r1]
    1678:	f88d 1007 	strb.w	r1, [sp, #7]
      tempa[0] = tempa[0] ^ Rcon[i/Nk];
    167c:	eb02 0293 	add.w	r2, r2, r3, lsr #2
    1680:	f892 2100 	ldrb.w	r2, [r2, #256]	@ 0x100
    1684:	4054      	eors	r4, r2
    1686:	f88d 4004 	strb.w	r4, [sp, #4]
    168a:	e7a4      	b.n	15d6 <KeyExpansion+0x36>
  }
}
    168c:	b002      	add	sp, #8
    168e:	bd10      	pop	{r4, pc}
    1690:	00002ab8 			@ <UNDEFINED> instruction: 0x00002ab8

00001694 <AddRoundKey>:
#endif

// This function adds the round key to state.
// The round key is added to the state by an XOR function.
static void AddRoundKey(uint8_t round, state_t* state, const uint8_t* RoundKey)
{
    1694:	b530      	push	{r4, r5, lr}
  uint8_t i,j;
  for (i = 0; i < 4; ++i)
    1696:	2400      	movs	r4, #0
    1698:	e013      	b.n	16c2 <AddRoundKey+0x2e>
  {
    for (j = 0; j < 4; ++j)
    {
      (*state)[i][j] ^= RoundKey[(round * Nb * 4) + (i * Nb) + j];
    169a:	eb01 0584 	add.w	r5, r1, r4, lsl #2
    169e:	f815 c003 	ldrb.w	ip, [r5, r3]
    16a2:	eb04 0e80 	add.w	lr, r4, r0, lsl #2
    16a6:	eb03 0e8e 	add.w	lr, r3, lr, lsl #2
    16aa:	f812 e00e 	ldrb.w	lr, [r2, lr]
    16ae:	ea8c 0c0e 	eor.w	ip, ip, lr
    16b2:	f805 c003 	strb.w	ip, [r5, r3]
    for (j = 0; j < 4; ++j)
    16b6:	3301      	adds	r3, #1
    16b8:	b2db      	uxtb	r3, r3
    16ba:	2b03      	cmp	r3, #3
    16bc:	d9ed      	bls.n	169a <AddRoundKey+0x6>
  for (i = 0; i < 4; ++i)
    16be:	3401      	adds	r4, #1
    16c0:	b2e4      	uxtb	r4, r4
    16c2:	2c03      	cmp	r4, #3
    16c4:	d801      	bhi.n	16ca <AddRoundKey+0x36>
    for (j = 0; j < 4; ++j)
    16c6:	2300      	movs	r3, #0
    16c8:	e7f7      	b.n	16ba <AddRoundKey+0x26>
    }
  }
}
    16ca:	bd30      	pop	{r4, r5, pc}

000016cc <SubBytes>:
// The SubBytes Function Substitutes the values in the
// state matrix with values in an S-box.
static void SubBytes(state_t* state)
{
  uint8_t i, j;
  for (i = 0; i < 4; ++i)
    16cc:	2200      	movs	r2, #0
    16ce:	2a03      	cmp	r2, #3
    16d0:	d81b      	bhi.n	170a <SubBytes+0x3e>
  {
    for (j = 0; j < 4; ++j)
    16d2:	2300      	movs	r3, #0
    16d4:	2b03      	cmp	r3, #3
    16d6:	d815      	bhi.n	1704 <SubBytes+0x38>
{
    16d8:	b410      	push	{r4}
    {
      (*state)[j][i] = getSBoxValue((*state)[j][i]);
    16da:	eb00 0183 	add.w	r1, r0, r3, lsl #2
    16de:	f811 c002 	ldrb.w	ip, [r1, r2]
    16e2:	4c0a      	ldr	r4, [pc, #40]	@ (170c <SubBytes+0x40>)
    16e4:	f814 c00c 	ldrb.w	ip, [r4, ip]
    16e8:	f801 c002 	strb.w	ip, [r1, r2]
    for (j = 0; j < 4; ++j)
    16ec:	3301      	adds	r3, #1
    16ee:	b2db      	uxtb	r3, r3
    16f0:	2b03      	cmp	r3, #3
    16f2:	d9f2      	bls.n	16da <SubBytes+0xe>
  for (i = 0; i < 4; ++i)
    16f4:	3201      	adds	r2, #1
    16f6:	b2d2      	uxtb	r2, r2
    16f8:	2a03      	cmp	r2, #3
    16fa:	d801      	bhi.n	1700 <SubBytes+0x34>
    for (j = 0; j < 4; ++j)
    16fc:	2300      	movs	r3, #0
    16fe:	e7f7      	b.n	16f0 <SubBytes+0x24>
    }
  }
}
    1700:	bc10      	pop	{r4}
    1702:	4770      	bx	lr
  for (i = 0; i < 4; ++i)
    1704:	3201      	adds	r2, #1
    1706:	b2d2      	uxtb	r2, r2
    1708:	e7e1      	b.n	16ce <SubBytes+0x2>
    170a:	4770      	bx	lr
    170c:	00002ab8 			@ <UNDEFINED> instruction: 0x00002ab8

00001710 <ShiftRows>:
static void ShiftRows(state_t* state)
{
  uint8_t temp;

  // Rotate first row 1 columns to left  
  temp           = (*state)[0][1];
    1710:	7843      	ldrb	r3, [r0, #1]
  (*state)[0][1] = (*state)[1][1];
    1712:	7942      	ldrb	r2, [r0, #5]
    1714:	7042      	strb	r2, [r0, #1]
  (*state)[1][1] = (*state)[2][1];
    1716:	7a42      	ldrb	r2, [r0, #9]
    1718:	7142      	strb	r2, [r0, #5]
  (*state)[2][1] = (*state)[3][1];
    171a:	7b42      	ldrb	r2, [r0, #13]
    171c:	7242      	strb	r2, [r0, #9]
  (*state)[3][1] = temp;
    171e:	7343      	strb	r3, [r0, #13]

  // Rotate second row 2 columns to left  
  temp           = (*state)[0][2];
    1720:	7883      	ldrb	r3, [r0, #2]
  (*state)[0][2] = (*state)[2][2];
    1722:	7a82      	ldrb	r2, [r0, #10]
    1724:	7082      	strb	r2, [r0, #2]
  (*state)[2][2] = temp;
    1726:	7283      	strb	r3, [r0, #10]

  temp           = (*state)[1][2];
    1728:	7983      	ldrb	r3, [r0, #6]
  (*state)[1][2] = (*state)[3][2];
    172a:	7b82      	ldrb	r2, [r0, #14]
    172c:	7182      	strb	r2, [r0, #6]
  (*state)[3][2] = temp;
    172e:	7383      	strb	r3, [r0, #14]

  // Rotate third row 3 columns to left
  temp           = (*state)[0][3];
    1730:	78c3      	ldrb	r3, [r0, #3]
  (*state)[0][3] = (*state)[3][3];
    1732:	7bc2      	ldrb	r2, [r0, #15]
    1734:	70c2      	strb	r2, [r0, #3]
  (*state)[3][3] = (*state)[2][3];
    1736:	7ac2      	ldrb	r2, [r0, #11]
    1738:	73c2      	strb	r2, [r0, #15]
  (*state)[2][3] = (*state)[1][3];
    173a:	79c2      	ldrb	r2, [r0, #7]
    173c:	72c2      	strb	r2, [r0, #11]
  (*state)[1][3] = temp;
    173e:	71c3      	strb	r3, [r0, #7]
}
    1740:	4770      	bx	lr

00001742 <xtime>:

static uint8_t xtime(uint8_t x)
{
  return ((x<<1) ^ (((x>>7) & 1) * 0x1b));
    1742:	09c3      	lsrs	r3, r0, #7
    1744:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    1748:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
    174c:	ea83 0040 	eor.w	r0, r3, r0, lsl #1
}
    1750:	b2c0      	uxtb	r0, r0
    1752:	4770      	bx	lr

00001754 <MixColumns>:

// MixColumns function mixes the columns of the state matrix
static void MixColumns(state_t* state)
{
    1754:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1758:	4681      	mov	r9, r0
  uint8_t i;
  uint8_t Tmp, Tm, t;
  for (i = 0; i < 4; ++i)
    175a:	2500      	movs	r5, #0
    175c:	e031      	b.n	17c2 <MixColumns+0x6e>
  {  
    t   = (*state)[i][0];
    175e:	f819 a025 	ldrb.w	sl, [r9, r5, lsl #2]
    Tmp = (*state)[i][0] ^ (*state)[i][1] ^ (*state)[i][2] ^ (*state)[i][3] ;
    1762:	eb09 0685 	add.w	r6, r9, r5, lsl #2
    1766:	f896 b001 	ldrb.w	fp, [r6, #1]
    176a:	ea8b 000a 	eor.w	r0, fp, sl
    176e:	f896 8002 	ldrb.w	r8, [r6, #2]
    1772:	78f7      	ldrb	r7, [r6, #3]
    1774:	ea80 0408 	eor.w	r4, r0, r8
    1778:	407c      	eors	r4, r7
    Tm  = (*state)[i][0] ^ (*state)[i][1] ; Tm = xtime(Tm);  (*state)[i][0] ^= Tm ^ Tmp ;
    177a:	f7ff ffe2 	bl	1742 <xtime>
    177e:	4060      	eors	r0, r4
    1780:	ea8a 0000 	eor.w	r0, sl, r0
    1784:	f809 0025 	strb.w	r0, [r9, r5, lsl #2]
    Tm  = (*state)[i][1] ^ (*state)[i][2] ; Tm = xtime(Tm);  (*state)[i][1] ^= Tm ^ Tmp ;
    1788:	ea8b 0008 	eor.w	r0, fp, r8
    178c:	f7ff ffd9 	bl	1742 <xtime>
    1790:	4060      	eors	r0, r4
    1792:	ea8b 0b00 	eor.w	fp, fp, r0
    1796:	f886 b001 	strb.w	fp, [r6, #1]
    Tm  = (*state)[i][2] ^ (*state)[i][3] ; Tm = xtime(Tm);  (*state)[i][2] ^= Tm ^ Tmp ;
    179a:	ea88 0007 	eor.w	r0, r8, r7
    179e:	f7ff ffd0 	bl	1742 <xtime>
    17a2:	4060      	eors	r0, r4
    17a4:	ea88 0800 	eor.w	r8, r8, r0
    17a8:	f886 8002 	strb.w	r8, [r6, #2]
    Tm  = (*state)[i][3] ^ t ;              Tm = xtime(Tm);  (*state)[i][3] ^= Tm ^ Tmp ;
    17ac:	ea87 000a 	eor.w	r0, r7, sl
    17b0:	f7ff ffc7 	bl	1742 <xtime>
    17b4:	ea84 0300 	eor.w	r3, r4, r0
    17b8:	ea87 0403 	eor.w	r4, r7, r3
    17bc:	70f4      	strb	r4, [r6, #3]
  for (i = 0; i < 4; ++i)
    17be:	3501      	adds	r5, #1
    17c0:	b2ed      	uxtb	r5, r5
    17c2:	2d03      	cmp	r5, #3
    17c4:	d9cb      	bls.n	175e <MixColumns+0xa>
  }
}
    17c6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

000017ca <InvMixColumns>:

// MixColumns function mixes the columns of the state matrix.
// The method used to multiply may be difficult to understand for the inexperienced.
// Please use the references to gain more information.
static void InvMixColumns(state_t* state)
{
    17ca:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    17ce:	b08b      	sub	sp, #44	@ 0x2c
    17d0:	9000      	str	r0, [sp, #0]
  int i;
  uint8_t a, b, c, d;
  for (i = 0; i < 4; ++i)
    17d2:	2400      	movs	r4, #0
    17d4:	e0a0      	b.n	1918 <InvMixColumns+0x14e>
  { 
    a = (*state)[i][0];
    17d6:	9b00      	ldr	r3, [sp, #0]
    17d8:	f813 b024 	ldrb.w	fp, [r3, r4, lsl #2]
    b = (*state)[i][1];
    17dc:	eb03 0884 	add.w	r8, r3, r4, lsl #2
    17e0:	f898 a001 	ldrb.w	sl, [r8, #1]
    c = (*state)[i][2];
    17e4:	f898 9002 	ldrb.w	r9, [r8, #2]
    d = (*state)[i][3];
    17e8:	f898 5003 	ldrb.w	r5, [r8, #3]

    (*state)[i][0] = Multiply(a, 0x0e) ^ Multiply(b, 0x0b) ^ Multiply(c, 0x0d) ^ Multiply(d, 0x09);
    17ec:	4658      	mov	r0, fp
    17ee:	f7ff ffa8 	bl	1742 <xtime>
    17f2:	9007      	str	r0, [sp, #28]
    17f4:	f7ff ffa5 	bl	1742 <xtime>
    17f8:	9001      	str	r0, [sp, #4]
    17fa:	f7ff ffa2 	bl	1742 <xtime>
    17fe:	9008      	str	r0, [sp, #32]
    1800:	4650      	mov	r0, sl
    1802:	f7ff ff9e 	bl	1742 <xtime>
    1806:	9002      	str	r0, [sp, #8]
    1808:	f7ff ff9b 	bl	1742 <xtime>
    180c:	9003      	str	r0, [sp, #12]
    180e:	f7ff ff98 	bl	1742 <xtime>
    1812:	4607      	mov	r7, r0
    1814:	4648      	mov	r0, r9
    1816:	f7ff ff94 	bl	1742 <xtime>
    181a:	9009      	str	r0, [sp, #36]	@ 0x24
    181c:	f7ff ff91 	bl	1742 <xtime>
    1820:	9004      	str	r0, [sp, #16]
    1822:	f7ff ff8e 	bl	1742 <xtime>
    1826:	4606      	mov	r6, r0
    1828:	4628      	mov	r0, r5
    182a:	f7ff ff8a 	bl	1742 <xtime>
    182e:	9005      	str	r0, [sp, #20]
    1830:	f7ff ff87 	bl	1742 <xtime>
    1834:	9006      	str	r0, [sp, #24]
    1836:	f7ff ff84 	bl	1742 <xtime>
    183a:	f8dd e01c 	ldr.w	lr, [sp, #28]
    183e:	9a01      	ldr	r2, [sp, #4]
    1840:	ea8e 0302 	eor.w	r3, lr, r2
    1844:	b2db      	uxtb	r3, r3
    1846:	9908      	ldr	r1, [sp, #32]
    1848:	404b      	eors	r3, r1
    184a:	b2db      	uxtb	r3, r3
    184c:	f8dd c008 	ldr.w	ip, [sp, #8]
    1850:	ea8c 020a 	eor.w	r2, ip, sl
    1854:	b2d2      	uxtb	r2, r2
    1856:	407a      	eors	r2, r7
    1858:	b2d2      	uxtb	r2, r2
    185a:	4053      	eors	r3, r2
    185c:	9a04      	ldr	r2, [sp, #16]
    185e:	ea82 0209 	eor.w	r2, r2, r9
    1862:	b2d2      	uxtb	r2, r2
    1864:	4072      	eors	r2, r6
    1866:	b2d2      	uxtb	r2, r2
    1868:	4053      	eors	r3, r2
    186a:	ea80 0205 	eor.w	r2, r0, r5
    186e:	b2d2      	uxtb	r2, r2
    1870:	4053      	eors	r3, r2
    1872:	f8dd c000 	ldr.w	ip, [sp]
    1876:	f80c 3024 	strb.w	r3, [ip, r4, lsl #2]
    (*state)[i][1] = Multiply(a, 0x09) ^ Multiply(b, 0x0e) ^ Multiply(c, 0x0b) ^ Multiply(d, 0x0d);
    187a:	ea81 030b 	eor.w	r3, r1, fp
    187e:	b2da      	uxtb	r2, r3
    1880:	f8dd c008 	ldr.w	ip, [sp, #8]
    1884:	9b03      	ldr	r3, [sp, #12]
    1886:	ea8c 0303 	eor.w	r3, ip, r3
    188a:	b2db      	uxtb	r3, r3
    188c:	407b      	eors	r3, r7
    188e:	b2db      	uxtb	r3, r3
    1890:	4053      	eors	r3, r2
    1892:	f8dd c024 	ldr.w	ip, [sp, #36]	@ 0x24
    1896:	ea8c 0209 	eor.w	r2, ip, r9
    189a:	b2d2      	uxtb	r2, r2
    189c:	4072      	eors	r2, r6
    189e:	b2d2      	uxtb	r2, r2
    18a0:	4053      	eors	r3, r2
    18a2:	9a06      	ldr	r2, [sp, #24]
    18a4:	406a      	eors	r2, r5
    18a6:	b2d2      	uxtb	r2, r2
    18a8:	4042      	eors	r2, r0
    18aa:	b2d2      	uxtb	r2, r2
    18ac:	4053      	eors	r3, r2
    18ae:	f888 3001 	strb.w	r3, [r8, #1]
    (*state)[i][2] = Multiply(a, 0x0d) ^ Multiply(b, 0x09) ^ Multiply(c, 0x0e) ^ Multiply(d, 0x0b);
    18b2:	9b01      	ldr	r3, [sp, #4]
    18b4:	ea83 030b 	eor.w	r3, r3, fp
    18b8:	b2db      	uxtb	r3, r3
    18ba:	404b      	eors	r3, r1
    18bc:	b2db      	uxtb	r3, r3
    18be:	ea87 020a 	eor.w	r2, r7, sl
    18c2:	b2d2      	uxtb	r2, r2
    18c4:	4053      	eors	r3, r2
    18c6:	9a04      	ldr	r2, [sp, #16]
    18c8:	ea8c 0202 	eor.w	r2, ip, r2
    18cc:	b2d2      	uxtb	r2, r2
    18ce:	4072      	eors	r2, r6
    18d0:	b2d2      	uxtb	r2, r2
    18d2:	4053      	eors	r3, r2
    18d4:	9a05      	ldr	r2, [sp, #20]
    18d6:	4055      	eors	r5, r2
    18d8:	b2ed      	uxtb	r5, r5
    18da:	4045      	eors	r5, r0
    18dc:	b2ed      	uxtb	r5, r5
    18de:	406b      	eors	r3, r5
    18e0:	f888 3002 	strb.w	r3, [r8, #2]
    (*state)[i][3] = Multiply(a, 0x0b) ^ Multiply(b, 0x0d) ^ Multiply(c, 0x09) ^ Multiply(d, 0x0e);
    18e4:	ea8e 030b 	eor.w	r3, lr, fp
    18e8:	b2db      	uxtb	r3, r3
    18ea:	404b      	eors	r3, r1
    18ec:	b2db      	uxtb	r3, r3
    18ee:	9903      	ldr	r1, [sp, #12]
    18f0:	ea81 020a 	eor.w	r2, r1, sl
    18f4:	b2d2      	uxtb	r2, r2
    18f6:	4057      	eors	r7, r2
    18f8:	b2ff      	uxtb	r7, r7
    18fa:	407b      	eors	r3, r7
    18fc:	ea86 0609 	eor.w	r6, r6, r9
    1900:	b2f6      	uxtb	r6, r6
    1902:	4073      	eors	r3, r6
    1904:	9905      	ldr	r1, [sp, #20]
    1906:	9a06      	ldr	r2, [sp, #24]
    1908:	404a      	eors	r2, r1
    190a:	b2d2      	uxtb	r2, r2
    190c:	4050      	eors	r0, r2
    190e:	b2c0      	uxtb	r0, r0
    1910:	4043      	eors	r3, r0
    1912:	f888 3003 	strb.w	r3, [r8, #3]
  for (i = 0; i < 4; ++i)
    1916:	3401      	adds	r4, #1
    1918:	2c03      	cmp	r4, #3
    191a:	f77f af5c 	ble.w	17d6 <InvMixColumns+0xc>
  }
}
    191e:	b00b      	add	sp, #44	@ 0x2c
    1920:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00001924 <InvSubBytes>:
// The SubBytes Function Substitutes the values in the
// state matrix with values in an S-box.
static void InvSubBytes(state_t* state)
{
  uint8_t i, j;
  for (i = 0; i < 4; ++i)
    1924:	2100      	movs	r1, #0
    1926:	2903      	cmp	r1, #3
    1928:	d81c      	bhi.n	1964 <InvSubBytes+0x40>
  {
    for (j = 0; j < 4; ++j)
    192a:	2300      	movs	r3, #0
    192c:	2b03      	cmp	r3, #3
    192e:	d816      	bhi.n	195e <InvSubBytes+0x3a>
{
    1930:	b500      	push	{lr}
    {
      (*state)[j][i] = getSBoxInvert((*state)[j][i]);
    1932:	eb00 0c83 	add.w	ip, r0, r3, lsl #2
    1936:	f81c e001 	ldrb.w	lr, [ip, r1]
    193a:	4a0b      	ldr	r2, [pc, #44]	@ (1968 <InvSubBytes+0x44>)
    193c:	4472      	add	r2, lr
    193e:	f892 210c 	ldrb.w	r2, [r2, #268]	@ 0x10c
    1942:	f80c 2001 	strb.w	r2, [ip, r1]
    for (j = 0; j < 4; ++j)
    1946:	3301      	adds	r3, #1
    1948:	b2db      	uxtb	r3, r3
    194a:	2b03      	cmp	r3, #3
    194c:	d9f1      	bls.n	1932 <InvSubBytes+0xe>
  for (i = 0; i < 4; ++i)
    194e:	3101      	adds	r1, #1
    1950:	b2c9      	uxtb	r1, r1
    1952:	2903      	cmp	r1, #3
    1954:	d801      	bhi.n	195a <InvSubBytes+0x36>
    for (j = 0; j < 4; ++j)
    1956:	2300      	movs	r3, #0
    1958:	e7f7      	b.n	194a <InvSubBytes+0x26>
    }
  }
}
    195a:	f85d fb04 	ldr.w	pc, [sp], #4
  for (i = 0; i < 4; ++i)
    195e:	3101      	adds	r1, #1
    1960:	b2c9      	uxtb	r1, r1
    1962:	e7e0      	b.n	1926 <InvSubBytes+0x2>
    1964:	4770      	bx	lr
    1966:	bf00      	nop
    1968:	00002ab8 			@ <UNDEFINED> instruction: 0x00002ab8

0000196c <InvShiftRows>:
static void InvShiftRows(state_t* state)
{
  uint8_t temp;

  // Rotate first row 1 columns to right  
  temp = (*state)[3][1];
    196c:	7b43      	ldrb	r3, [r0, #13]
  (*state)[3][1] = (*state)[2][1];
    196e:	7a42      	ldrb	r2, [r0, #9]
    1970:	7342      	strb	r2, [r0, #13]
  (*state)[2][1] = (*state)[1][1];
    1972:	7942      	ldrb	r2, [r0, #5]
    1974:	7242      	strb	r2, [r0, #9]
  (*state)[1][1] = (*state)[0][1];
    1976:	7842      	ldrb	r2, [r0, #1]
    1978:	7142      	strb	r2, [r0, #5]
  (*state)[0][1] = temp;
    197a:	7043      	strb	r3, [r0, #1]

  // Rotate second row 2 columns to right 
  temp = (*state)[0][2];
    197c:	7883      	ldrb	r3, [r0, #2]
  (*state)[0][2] = (*state)[2][2];
    197e:	7a82      	ldrb	r2, [r0, #10]
    1980:	7082      	strb	r2, [r0, #2]
  (*state)[2][2] = temp;
    1982:	7283      	strb	r3, [r0, #10]

  temp = (*state)[1][2];
    1984:	7983      	ldrb	r3, [r0, #6]
  (*state)[1][2] = (*state)[3][2];
    1986:	7b82      	ldrb	r2, [r0, #14]
    1988:	7182      	strb	r2, [r0, #6]
  (*state)[3][2] = temp;
    198a:	7383      	strb	r3, [r0, #14]

  // Rotate third row 3 columns to right
  temp = (*state)[0][3];
    198c:	78c3      	ldrb	r3, [r0, #3]
  (*state)[0][3] = (*state)[1][3];
    198e:	79c2      	ldrb	r2, [r0, #7]
    1990:	70c2      	strb	r2, [r0, #3]
  (*state)[1][3] = (*state)[2][3];
    1992:	7ac2      	ldrb	r2, [r0, #11]
    1994:	71c2      	strb	r2, [r0, #7]
  (*state)[2][3] = (*state)[3][3];
    1996:	7bc2      	ldrb	r2, [r0, #15]
    1998:	72c2      	strb	r2, [r0, #11]
  (*state)[3][3] = temp;
    199a:	73c3      	strb	r3, [r0, #15]
}
    199c:	4770      	bx	lr

0000199e <Cipher>:
#endif // #if (defined(CBC) && CBC == 1) || (defined(ECB) && ECB == 1)

// Cipher is the main function that encrypts the PlainText.
static void Cipher(state_t* state, const uint8_t* RoundKey)
{
    199e:	b570      	push	{r4, r5, r6, lr}
    19a0:	4605      	mov	r5, r0
    19a2:	460e      	mov	r6, r1
  uint8_t round = 0;

  // Add the First round key to the state before starting the rounds.
  AddRoundKey(0, state, RoundKey);
    19a4:	460a      	mov	r2, r1
    19a6:	4601      	mov	r1, r0
    19a8:	2000      	movs	r0, #0
    19aa:	f7ff fe73 	bl	1694 <AddRoundKey>

  // There will be Nr rounds.
  // The first Nr-1 rounds are identical.
  // These Nr rounds are executed in the loop below.
  // Last one without MixColumns()
  for (round = 1; ; ++round)
    19ae:	2401      	movs	r4, #1
    19b0:	e009      	b.n	19c6 <Cipher+0x28>
    SubBytes(state);
    ShiftRows(state);
    if (round == Nr) {
      break;
    }
    MixColumns(state);
    19b2:	4628      	mov	r0, r5
    19b4:	f7ff fece 	bl	1754 <MixColumns>
    AddRoundKey(round, state, RoundKey);
    19b8:	4632      	mov	r2, r6
    19ba:	4629      	mov	r1, r5
    19bc:	4620      	mov	r0, r4
    19be:	f7ff fe69 	bl	1694 <AddRoundKey>
  for (round = 1; ; ++round)
    19c2:	3401      	adds	r4, #1
    19c4:	b2e4      	uxtb	r4, r4
    SubBytes(state);
    19c6:	4628      	mov	r0, r5
    19c8:	f7ff fe80 	bl	16cc <SubBytes>
    ShiftRows(state);
    19cc:	4628      	mov	r0, r5
    19ce:	f7ff fe9f 	bl	1710 <ShiftRows>
    if (round == Nr) {
    19d2:	2c0a      	cmp	r4, #10
    19d4:	d1ed      	bne.n	19b2 <Cipher+0x14>
  }
  // Add round key to last round
  AddRoundKey(Nr, state, RoundKey);
    19d6:	4632      	mov	r2, r6
    19d8:	4629      	mov	r1, r5
    19da:	200a      	movs	r0, #10
    19dc:	f7ff fe5a 	bl	1694 <AddRoundKey>
}
    19e0:	bd70      	pop	{r4, r5, r6, pc}

000019e2 <InvCipher>:

#if (defined(CBC) && CBC == 1) || (defined(ECB) && ECB == 1)
static void InvCipher(state_t* state, const uint8_t* RoundKey)
{
    19e2:	b570      	push	{r4, r5, r6, lr}
    19e4:	4605      	mov	r5, r0
    19e6:	460e      	mov	r6, r1
  uint8_t round = 0;

  // Add the First round key to the state before starting the rounds.
  AddRoundKey(Nr, state, RoundKey);
    19e8:	460a      	mov	r2, r1
    19ea:	4601      	mov	r1, r0
    19ec:	200a      	movs	r0, #10
    19ee:	f7ff fe51 	bl	1694 <AddRoundKey>

  // There will be Nr rounds.
  // The first Nr-1 rounds are identical.
  // These Nr rounds are executed in the loop below.
  // Last one without InvMixColumn()
  for (round = (Nr - 1); ; --round)
    19f2:	2409      	movs	r4, #9
    19f4:	e004      	b.n	1a00 <InvCipher+0x1e>
    InvSubBytes(state);
    AddRoundKey(round, state, RoundKey);
    if (round == 0) {
      break;
    }
    InvMixColumns(state);
    19f6:	4628      	mov	r0, r5
    19f8:	f7ff fee7 	bl	17ca <InvMixColumns>
  for (round = (Nr - 1); ; --round)
    19fc:	3c01      	subs	r4, #1
    19fe:	b2e4      	uxtb	r4, r4
    InvShiftRows(state);
    1a00:	4628      	mov	r0, r5
    1a02:	f7ff ffb3 	bl	196c <InvShiftRows>
    InvSubBytes(state);
    1a06:	4628      	mov	r0, r5
    1a08:	f7ff ff8c 	bl	1924 <InvSubBytes>
    AddRoundKey(round, state, RoundKey);
    1a0c:	4632      	mov	r2, r6
    1a0e:	4629      	mov	r1, r5
    1a10:	4620      	mov	r0, r4
    1a12:	f7ff fe3f 	bl	1694 <AddRoundKey>
    if (round == 0) {
    1a16:	2c00      	cmp	r4, #0
    1a18:	d1ed      	bne.n	19f6 <InvCipher+0x14>
  }

}
    1a1a:	bd70      	pop	{r4, r5, r6, pc}

00001a1c <XorWithIv>:


static void XorWithIv(uint8_t* buf, const uint8_t* Iv)
{
  uint8_t i;
  for (i = 0; i < AES_BLOCKLEN; ++i) // The block in AES is always 128bit no matter the key size
    1a1c:	2300      	movs	r3, #0
    1a1e:	e007      	b.n	1a30 <XorWithIv+0x14>
  {
    buf[i] ^= Iv[i];
    1a20:	5cc2      	ldrb	r2, [r0, r3]
    1a22:	f811 c003 	ldrb.w	ip, [r1, r3]
    1a26:	ea82 020c 	eor.w	r2, r2, ip
    1a2a:	54c2      	strb	r2, [r0, r3]
  for (i = 0; i < AES_BLOCKLEN; ++i) // The block in AES is always 128bit no matter the key size
    1a2c:	3301      	adds	r3, #1
    1a2e:	b2db      	uxtb	r3, r3
    1a30:	2b0f      	cmp	r3, #15
    1a32:	d9f5      	bls.n	1a20 <XorWithIv+0x4>
  }
}
    1a34:	4770      	bx	lr

00001a36 <AES_init_ctx>:
{
    1a36:	b508      	push	{r3, lr}
  KeyExpansion(ctx->RoundKey, key);
    1a38:	f7ff fdb2 	bl	15a0 <KeyExpansion>
}
    1a3c:	bd08      	pop	{r3, pc}

00001a3e <AES_init_ctx_iv>:
{
    1a3e:	b538      	push	{r3, r4, r5, lr}
    1a40:	4604      	mov	r4, r0
    1a42:	4615      	mov	r5, r2
  KeyExpansion(ctx->RoundKey, key);
    1a44:	f7ff fdac 	bl	15a0 <KeyExpansion>
  memcpy (ctx->Iv, iv, AES_BLOCKLEN);
    1a48:	2210      	movs	r2, #16
    1a4a:	4629      	mov	r1, r5
    1a4c:	f104 00b0 	add.w	r0, r4, #176	@ 0xb0
    1a50:	f000 fbef 	bl	2232 <memcpy>
}
    1a54:	bd38      	pop	{r3, r4, r5, pc}

00001a56 <AES_ctx_set_iv>:
{
    1a56:	b508      	push	{r3, lr}
  memcpy (ctx->Iv, iv, AES_BLOCKLEN);
    1a58:	2210      	movs	r2, #16
    1a5a:	30b0      	adds	r0, #176	@ 0xb0
    1a5c:	f000 fbe9 	bl	2232 <memcpy>
}
    1a60:	bd08      	pop	{r3, pc}

00001a62 <AES_ECB_encrypt>:
{
    1a62:	b508      	push	{r3, lr}
    1a64:	460b      	mov	r3, r1
  Cipher((state_t*)buf, ctx->RoundKey);
    1a66:	4601      	mov	r1, r0
    1a68:	4618      	mov	r0, r3
    1a6a:	f7ff ff98 	bl	199e <Cipher>
}
    1a6e:	bd08      	pop	{r3, pc}

00001a70 <AES_ECB_decrypt>:
{
    1a70:	b508      	push	{r3, lr}
    1a72:	460b      	mov	r3, r1
  InvCipher((state_t*)buf, ctx->RoundKey);
    1a74:	4601      	mov	r1, r0
    1a76:	4618      	mov	r0, r3
    1a78:	f7ff ffb3 	bl	19e2 <InvCipher>
}
    1a7c:	bd08      	pop	{r3, pc}

00001a7e <AES_CBC_encrypt_buffer>:

void AES_CBC_encrypt_buffer(struct AES_ctx *ctx, uint8_t* buf, size_t length)
{
    1a7e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1a82:	4606      	mov	r6, r0
    1a84:	460c      	mov	r4, r1
    1a86:	4617      	mov	r7, r2
  size_t i;
  uint8_t *Iv = ctx->Iv;
    1a88:	f100 08b0 	add.w	r8, r0, #176	@ 0xb0
    1a8c:	4641      	mov	r1, r8
  for (i = 0; i < length; i += AES_BLOCKLEN)
    1a8e:	2500      	movs	r5, #0
    1a90:	e009      	b.n	1aa6 <AES_CBC_encrypt_buffer+0x28>
  {
    XorWithIv(buf, Iv);
    1a92:	4620      	mov	r0, r4
    1a94:	f7ff ffc2 	bl	1a1c <XorWithIv>
    Cipher((state_t*)buf, ctx->RoundKey);
    1a98:	4631      	mov	r1, r6
    1a9a:	4620      	mov	r0, r4
    1a9c:	f7ff ff7f 	bl	199e <Cipher>
  for (i = 0; i < length; i += AES_BLOCKLEN)
    1aa0:	3510      	adds	r5, #16
    Iv = buf;
    1aa2:	4621      	mov	r1, r4
    buf += AES_BLOCKLEN;
    1aa4:	3410      	adds	r4, #16
  for (i = 0; i < length; i += AES_BLOCKLEN)
    1aa6:	42bd      	cmp	r5, r7
    1aa8:	d3f3      	bcc.n	1a92 <AES_CBC_encrypt_buffer+0x14>
  }
  /* store Iv in ctx for next call */
  memcpy(ctx->Iv, Iv, AES_BLOCKLEN);
    1aaa:	2210      	movs	r2, #16
    1aac:	4640      	mov	r0, r8
    1aae:	f000 fbc0 	bl	2232 <memcpy>
}
    1ab2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00001ab6 <AES_CBC_decrypt_buffer>:

void AES_CBC_decrypt_buffer(struct AES_ctx* ctx, uint8_t* buf, size_t length)
{
    1ab6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1aba:	b084      	sub	sp, #16
    1abc:	4607      	mov	r7, r0
    1abe:	460c      	mov	r4, r1
    1ac0:	4690      	mov	r8, r2
  size_t i;
  uint8_t storeNextIv[AES_BLOCKLEN];
  for (i = 0; i < length; i += AES_BLOCKLEN)
    1ac2:	2500      	movs	r5, #0
    1ac4:	e015      	b.n	1af2 <AES_CBC_decrypt_buffer+0x3c>
  {
    memcpy(storeNextIv, buf, AES_BLOCKLEN);
    1ac6:	2210      	movs	r2, #16
    1ac8:	4621      	mov	r1, r4
    1aca:	4668      	mov	r0, sp
    1acc:	f000 fbb1 	bl	2232 <memcpy>
    InvCipher((state_t*)buf, ctx->RoundKey);
    1ad0:	4639      	mov	r1, r7
    1ad2:	4620      	mov	r0, r4
    1ad4:	f7ff ff85 	bl	19e2 <InvCipher>
    XorWithIv(buf, ctx->Iv);
    1ad8:	f107 06b0 	add.w	r6, r7, #176	@ 0xb0
    1adc:	4631      	mov	r1, r6
    1ade:	4620      	mov	r0, r4
    1ae0:	f7ff ff9c 	bl	1a1c <XorWithIv>
    memcpy(ctx->Iv, storeNextIv, AES_BLOCKLEN);
    1ae4:	2210      	movs	r2, #16
    1ae6:	4669      	mov	r1, sp
    1ae8:	4630      	mov	r0, r6
    1aea:	f000 fba2 	bl	2232 <memcpy>
    buf += AES_BLOCKLEN;
    1aee:	3410      	adds	r4, #16
  for (i = 0; i < length; i += AES_BLOCKLEN)
    1af0:	3510      	adds	r5, #16
    1af2:	4545      	cmp	r5, r8
    1af4:	d3e7      	bcc.n	1ac6 <AES_CBC_decrypt_buffer+0x10>
  }

}
    1af6:	b004      	add	sp, #16
    1af8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00001afc <AES_CTR_xcrypt_buffer>:

#if defined(CTR) && (CTR == 1)

/* Symmetrical operation: same function for encrypting as for decrypting. Note any IV/nonce should never be reused with the same key */
void AES_CTR_xcrypt_buffer(struct AES_ctx* ctx, uint8_t* buf, size_t length)
{
    1afc:	b5f0      	push	{r4, r5, r6, r7, lr}
    1afe:	b085      	sub	sp, #20
    1b00:	4607      	mov	r7, r0
    1b02:	460d      	mov	r5, r1
    1b04:	4616      	mov	r6, r2
  uint8_t buffer[AES_BLOCKLEN];
  
  size_t i;
  int bi;
  for (i = 0, bi = AES_BLOCKLEN; i < length; ++i, ++bi)
    1b06:	2310      	movs	r3, #16
    1b08:	2400      	movs	r4, #0
    1b0a:	e013      	b.n	1b34 <AES_CTR_xcrypt_buffer+0x38>
      for (bi = (AES_BLOCKLEN - 1); bi >= 0; --bi)
      {
	/* inc will overflow */
        if (ctx->Iv[bi] == 255)
	{
          ctx->Iv[bi] = 0;
    1b0c:	18fa      	adds	r2, r7, r3
    1b0e:	2100      	movs	r1, #0
    1b10:	f882 10b0 	strb.w	r1, [r2, #176]	@ 0xb0
      for (bi = (AES_BLOCKLEN - 1); bi >= 0; --bi)
    1b14:	3b01      	subs	r3, #1
    1b16:	e01c      	b.n	1b52 <AES_CTR_xcrypt_buffer+0x56>
          continue;
        } 
        ctx->Iv[bi] += 1;
        break;   
      }
      bi = 0;
    1b18:	2300      	movs	r3, #0
    }

    buf[i] = (buf[i] ^ buffer[bi]);
    1b1a:	f815 c004 	ldrb.w	ip, [r5, r4]
    1b1e:	f103 0210 	add.w	r2, r3, #16
    1b22:	446a      	add	r2, sp
    1b24:	f812 ec10 	ldrb.w	lr, [r2, #-16]
    1b28:	ea8c 0c0e 	eor.w	ip, ip, lr
    1b2c:	f805 c004 	strb.w	ip, [r5, r4]
  for (i = 0, bi = AES_BLOCKLEN; i < length; ++i, ++bi)
    1b30:	3401      	adds	r4, #1
    1b32:	3301      	adds	r3, #1
    1b34:	42b4      	cmp	r4, r6
    1b36:	d219      	bcs.n	1b6c <AES_CTR_xcrypt_buffer+0x70>
    if (bi == AES_BLOCKLEN) /* we need to regen xor compliment in buffer */
    1b38:	2b10      	cmp	r3, #16
    1b3a:	d1ee      	bne.n	1b1a <AES_CTR_xcrypt_buffer+0x1e>
      memcpy(buffer, ctx->Iv, AES_BLOCKLEN);
    1b3c:	2210      	movs	r2, #16
    1b3e:	f107 01b0 	add.w	r1, r7, #176	@ 0xb0
    1b42:	4668      	mov	r0, sp
    1b44:	f000 fb75 	bl	2232 <memcpy>
      Cipher((state_t*)buffer,ctx->RoundKey);
    1b48:	4639      	mov	r1, r7
    1b4a:	4668      	mov	r0, sp
    1b4c:	f7ff ff27 	bl	199e <Cipher>
      for (bi = (AES_BLOCKLEN - 1); bi >= 0; --bi)
    1b50:	230f      	movs	r3, #15
    1b52:	2b00      	cmp	r3, #0
    1b54:	dbe0      	blt.n	1b18 <AES_CTR_xcrypt_buffer+0x1c>
        if (ctx->Iv[bi] == 255)
    1b56:	18fa      	adds	r2, r7, r3
    1b58:	f892 20b0 	ldrb.w	r2, [r2, #176]	@ 0xb0
    1b5c:	2aff      	cmp	r2, #255	@ 0xff
    1b5e:	d0d5      	beq.n	1b0c <AES_CTR_xcrypt_buffer+0x10>
        ctx->Iv[bi] += 1;
    1b60:	443b      	add	r3, r7
    1b62:	3201      	adds	r2, #1
    1b64:	f883 20b0 	strb.w	r2, [r3, #176]	@ 0xb0
      bi = 0;
    1b68:	2300      	movs	r3, #0
        break;   
    1b6a:	e7d6      	b.n	1b1a <AES_CTR_xcrypt_buffer+0x1e>
  }
}
    1b6c:	b005      	add	sp, #20
    1b6e:	bdf0      	pop	{r4, r5, r6, r7, pc}

00001b70 <bitvec_get_bit>:


/* some basic bit-manipulation routines that act on bit-vectors follow */
static int bitvec_get_bit(const bitvec_t x, const uint32_t idx)
{
  return ((x[idx / 32U] >> (idx & 31U) & 1U));
    1b70:	094b      	lsrs	r3, r1, #5
    1b72:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
    1b76:	f001 011f 	and.w	r1, r1, #31
    1b7a:	40c8      	lsrs	r0, r1
}
    1b7c:	f000 0001 	and.w	r0, r0, #1
    1b80:	4770      	bx	lr

00001b82 <bitvec_clr_bit>:

static void bitvec_clr_bit(bitvec_t x, const uint32_t idx)
{
  x[idx / 32U] &= ~(1U << (idx & 31U));
    1b82:	ea4f 1c51 	mov.w	ip, r1, lsr #5
    1b86:	f850 302c 	ldr.w	r3, [r0, ip, lsl #2]
    1b8a:	f001 011f 	and.w	r1, r1, #31
    1b8e:	2201      	movs	r2, #1
    1b90:	408a      	lsls	r2, r1
    1b92:	ea23 0302 	bic.w	r3, r3, r2
    1b96:	f840 302c 	str.w	r3, [r0, ip, lsl #2]
}
    1b9a:	4770      	bx	lr

00001b9c <bitvec_copy>:

static void bitvec_copy(bitvec_t x, const bitvec_t y)
{
  int i;
  for (i = 0; i < BITVEC_NWORDS; ++i)
    1b9c:	2300      	movs	r3, #0
    1b9e:	e004      	b.n	1baa <bitvec_copy+0xe>
  {
    x[i] = y[i];
    1ba0:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
    1ba4:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
  for (i = 0; i < BITVEC_NWORDS; ++i)
    1ba8:	3301      	adds	r3, #1
    1baa:	2b05      	cmp	r3, #5
    1bac:	ddf8      	ble.n	1ba0 <bitvec_copy+0x4>
  }
}
    1bae:	4770      	bx	lr

00001bb0 <bitvec_swap>:

static void bitvec_swap(bitvec_t x, bitvec_t y)
{
    1bb0:	b530      	push	{r4, r5, lr}
    1bb2:	b087      	sub	sp, #28
    1bb4:	4605      	mov	r5, r0
    1bb6:	460c      	mov	r4, r1
  bitvec_t tmp;
  bitvec_copy(tmp, x);
    1bb8:	4601      	mov	r1, r0
    1bba:	4668      	mov	r0, sp
    1bbc:	f7ff ffee 	bl	1b9c <bitvec_copy>
  bitvec_copy(x, y);
    1bc0:	4621      	mov	r1, r4
    1bc2:	4628      	mov	r0, r5
    1bc4:	f7ff ffea 	bl	1b9c <bitvec_copy>
  bitvec_copy(y, tmp);
    1bc8:	4669      	mov	r1, sp
    1bca:	4620      	mov	r0, r4
    1bcc:	f7ff ffe6 	bl	1b9c <bitvec_copy>
}
    1bd0:	b007      	add	sp, #28
    1bd2:	bd30      	pop	{r4, r5, pc}

00001bd4 <bitvec_equal>:
#if defined(CONST_TIME) && (CONST_TIME == 0)
/* fast version of equality test */
static int bitvec_equal(const bitvec_t x, const bitvec_t y)
{
  int i;
  for (i = 0; i < BITVEC_NWORDS; ++i)
    1bd4:	2300      	movs	r3, #0
    1bd6:	2b05      	cmp	r3, #5
    1bd8:	dc07      	bgt.n	1bea <bitvec_equal+0x16>
  {
    if (x[i] != y[i])
    1bda:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
    1bde:	f850 c023 	ldr.w	ip, [r0, r3, lsl #2]
    1be2:	4594      	cmp	ip, r2
    1be4:	d103      	bne.n	1bee <bitvec_equal+0x1a>
  for (i = 0; i < BITVEC_NWORDS; ++i)
    1be6:	3301      	adds	r3, #1
    1be8:	e7f5      	b.n	1bd6 <bitvec_equal+0x2>
    {
      return 0;
    }
  }
  return 1;
    1bea:	2001      	movs	r0, #1
    1bec:	4770      	bx	lr
      return 0;
    1bee:	2000      	movs	r0, #0
}
    1bf0:	4770      	bx	lr

00001bf2 <bitvec_set_zero>:
#endif

static void bitvec_set_zero(bitvec_t x)
{
  int i;
  for (i = 0; i < BITVEC_NWORDS; ++i)
    1bf2:	2300      	movs	r3, #0
    1bf4:	e003      	b.n	1bfe <bitvec_set_zero+0xc>
  {
    x[i] = 0;
    1bf6:	2200      	movs	r2, #0
    1bf8:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
  for (i = 0; i < BITVEC_NWORDS; ++i)
    1bfc:	3301      	adds	r3, #1
    1bfe:	2b05      	cmp	r3, #5
    1c00:	ddf9      	ble.n	1bf6 <bitvec_set_zero+0x4>
  }
}
    1c02:	4770      	bx	lr

00001c04 <bitvec_is_zero>:

#if defined(CONST_TIME) && (CONST_TIME == 0)
/* fast implementation */
static int bitvec_is_zero(const bitvec_t x)
{
  uint32_t i = 0;
    1c04:	2300      	movs	r3, #0
  while (i < BITVEC_NWORDS)
    1c06:	2b05      	cmp	r3, #5
    1c08:	d804      	bhi.n	1c14 <bitvec_is_zero+0x10>
  {
    if (x[i] != 0)
    1c0a:	f850 2023 	ldr.w	r2, [r0, r3, lsl #2]
    1c0e:	b90a      	cbnz	r2, 1c14 <bitvec_is_zero+0x10>
    {
      break;
    }
    i += 1;
    1c10:	3301      	adds	r3, #1
    1c12:	e7f8      	b.n	1c06 <bitvec_is_zero+0x2>
  }
  return (i == BITVEC_NWORDS);
}
    1c14:	2b06      	cmp	r3, #6
    1c16:	bf14      	ite	ne
    1c18:	2000      	movne	r0, #0
    1c1a:	2001      	moveq	r0, #1
    1c1c:	4770      	bx	lr

00001c1e <bitvec_degree>:
static int bitvec_degree(const bitvec_t x)
{
  int i = BITVEC_NWORDS * 32;

  /* Start at the back of the vector (MSB) */
  x += BITVEC_NWORDS;
    1c1e:	f100 0318 	add.w	r3, r0, #24
  int i = BITVEC_NWORDS * 32;
    1c22:	20c0      	movs	r0, #192	@ 0xc0

  /* Skip empty / zero words */
  while (    (i > 0)
          && (*(--x)) == 0)
    1c24:	2800      	cmp	r0, #0
    1c26:	dd04      	ble.n	1c32 <bitvec_degree+0x14>
    1c28:	f853 2d04 	ldr.w	r2, [r3, #-4]!
    1c2c:	b90a      	cbnz	r2, 1c32 <bitvec_degree+0x14>
  {
    i -= 32;
    1c2e:	3820      	subs	r0, #32
    1c30:	e7f8      	b.n	1c24 <bitvec_degree+0x6>
  }
  /* Run through rest if count is not multiple of bitsize of DTYPE */
  if (i != 0)
    1c32:	b930      	cbnz	r0, 1c42 <bitvec_degree+0x24>
    1c34:	4770      	bx	lr
  {
    uint32_t u32mask = ((uint32_t)1 << 31);
    while (((*x) & u32mask) == 0)
    {
      u32mask >>= 1;
    1c36:	0852      	lsrs	r2, r2, #1
      i -= 1;
    1c38:	3801      	subs	r0, #1
    while (((*x) & u32mask) == 0)
    1c3a:	6819      	ldr	r1, [r3, #0]
    1c3c:	4211      	tst	r1, r2
    1c3e:	d0fa      	beq.n	1c36 <bitvec_degree+0x18>
    }
  }
  return i;
}
    1c40:	4770      	bx	lr
    uint32_t u32mask = ((uint32_t)1 << 31);
    1c42:	f04f 4200 	mov.w	r2, #2147483648	@ 0x80000000
    1c46:	e7f8      	b.n	1c3a <bitvec_degree+0x1c>

00001c48 <bitvec_lshift>:

/* left-shift by 'count' digits */
static void bitvec_lshift(bitvec_t x, const bitvec_t y, int nbits)
{
    1c48:	b410      	push	{r4}
  int nwords = (nbits / 32);
    1c4a:	4694      	mov	ip, r2
    1c4c:	2a00      	cmp	r2, #0
    1c4e:	db03      	blt.n	1c58 <bitvec_lshift+0x10>
    1c50:	ea4f 1c6c 	mov.w	ip, ip, asr #5

  /* Shift whole words first if nwords > 0 */
  int i,j;
  for (i = 0; i < nwords; ++i)
    1c54:	2300      	movs	r3, #0
    1c56:	e006      	b.n	1c66 <bitvec_lshift+0x1e>
  int nwords = (nbits / 32);
    1c58:	f102 0c1f 	add.w	ip, r2, #31
    1c5c:	e7f8      	b.n	1c50 <bitvec_lshift+0x8>
  {
    /* Zero-initialize from least-significant word until offset reached */
    x[i] = 0;
    1c5e:	2400      	movs	r4, #0
    1c60:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
  for (i = 0; i < nwords; ++i)
    1c64:	3301      	adds	r3, #1
    1c66:	4563      	cmp	r3, ip
    1c68:	dbf9      	blt.n	1c5e <bitvec_lshift+0x16>
  }
  j = 0;
    1c6a:	f04f 0c00 	mov.w	ip, #0
    1c6e:	e006      	b.n	1c7e <bitvec_lshift+0x36>
  /* Copy to x output */
  while (i < BITVEC_NWORDS)
  {
    x[i] = y[j];
    1c70:	f851 402c 	ldr.w	r4, [r1, ip, lsl #2]
    1c74:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
    i += 1;
    1c78:	3301      	adds	r3, #1
    j += 1;
    1c7a:	f10c 0c01 	add.w	ip, ip, #1
  while (i < BITVEC_NWORDS)
    1c7e:	2b05      	cmp	r3, #5
    1c80:	ddf6      	ble.n	1c70 <bitvec_lshift+0x28>
  }

  /* Shift the rest if count was not multiple of bitsize of DTYPE */
  nbits &= 31;
  if (nbits != 0)
    1c82:	f012 021f 	ands.w	r2, r2, #31
    1c86:	d117      	bne.n	1cb8 <bitvec_lshift+0x70>
    {
      x[i]  = (x[i] << nbits) | (x[i - 1] >> (32 - nbits));
    }
    x[0] <<= nbits;
  }
}
    1c88:	bc10      	pop	{r4}
    1c8a:	4770      	bx	lr
      x[i]  = (x[i] << nbits) | (x[i - 1] >> (32 - nbits));
    1c8c:	f850 1023 	ldr.w	r1, [r0, r3, lsl #2]
    1c90:	4091      	lsls	r1, r2
    1c92:	f103 4480 	add.w	r4, r3, #1073741824	@ 0x40000000
    1c96:	3c01      	subs	r4, #1
    1c98:	f850 4024 	ldr.w	r4, [r0, r4, lsl #2]
    1c9c:	f1c2 0c20 	rsb	ip, r2, #32
    1ca0:	fa24 f40c 	lsr.w	r4, r4, ip
    1ca4:	4321      	orrs	r1, r4
    1ca6:	f840 1023 	str.w	r1, [r0, r3, lsl #2]
    for (i = (BITVEC_NWORDS - 1); i > 0; --i)
    1caa:	3b01      	subs	r3, #1
    1cac:	2b00      	cmp	r3, #0
    1cae:	dced      	bgt.n	1c8c <bitvec_lshift+0x44>
    x[0] <<= nbits;
    1cb0:	6803      	ldr	r3, [r0, #0]
    1cb2:	4093      	lsls	r3, r2
    1cb4:	6003      	str	r3, [r0, #0]
}
    1cb6:	e7e7      	b.n	1c88 <bitvec_lshift+0x40>
    for (i = (BITVEC_NWORDS - 1); i > 0; --i)
    1cb8:	2305      	movs	r3, #5
    1cba:	e7f7      	b.n	1cac <bitvec_lshift+0x64>

00001cbc <gf2field_set_one>:


static void gf2field_set_one(gf2elem_t x)
{
  /* Set first word to one */
  x[0] = 1;
    1cbc:	2301      	movs	r3, #1
    1cbe:	6003      	str	r3, [r0, #0]
  /* .. and the rest to zero */
  int i;
  for (i = 1; i < BITVEC_NWORDS; ++i)
    1cc0:	e003      	b.n	1cca <gf2field_set_one+0xe>
  {
    x[i] = 0;
    1cc2:	2200      	movs	r2, #0
    1cc4:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
  for (i = 1; i < BITVEC_NWORDS; ++i)
    1cc8:	3301      	adds	r3, #1
    1cca:	2b05      	cmp	r3, #5
    1ccc:	ddf9      	ble.n	1cc2 <gf2field_set_one+0x6>
  }
}
    1cce:	4770      	bx	lr

00001cd0 <gf2field_is_one>:
#if defined(CONST_TIME) && (CONST_TIME == 0)
/* fastest check if x == 1 */
static int gf2field_is_one(const gf2elem_t x) 
{
  /* Check if first word == 1 */
  if (x[0] != 1)
    1cd0:	6803      	ldr	r3, [r0, #0]
    1cd2:	2b01      	cmp	r3, #1
    1cd4:	d10b      	bne.n	1cee <gf2field_is_one+0x1e>
  {
    return 0;
  }
  /* ...and if rest of words == 0 */
  int i;
  for (i = 1; i < BITVEC_NWORDS; ++i)
    1cd6:	2b05      	cmp	r3, #5
    1cd8:	dc04      	bgt.n	1ce4 <gf2field_is_one+0x14>
  {
    if (x[i] != 0)
    1cda:	f850 2023 	ldr.w	r2, [r0, r3, lsl #2]
    1cde:	b90a      	cbnz	r2, 1ce4 <gf2field_is_one+0x14>
  for (i = 1; i < BITVEC_NWORDS; ++i)
    1ce0:	3301      	adds	r3, #1
    1ce2:	e7f8      	b.n	1cd6 <gf2field_is_one+0x6>
    {
      break;
    }
  }
  return (i == BITVEC_NWORDS);
    1ce4:	2b06      	cmp	r3, #6
    1ce6:	bf14      	ite	ne
    1ce8:	2000      	movne	r0, #0
    1cea:	2001      	moveq	r0, #1
    1cec:	4770      	bx	lr
    return 0;
    1cee:	2000      	movs	r0, #0
}
    1cf0:	4770      	bx	lr

00001cf2 <gf2field_add>:

/* galois field(2^m) addition is modulo 2, so XOR is used instead - 'z := a + b' */
static void gf2field_add(gf2elem_t z, const gf2elem_t x, const gf2elem_t y)
{
  int i;
  for (i = 0; i < BITVEC_NWORDS; ++i)
    1cf2:	2300      	movs	r3, #0
    1cf4:	2b05      	cmp	r3, #5
    1cf6:	dc0c      	bgt.n	1d12 <gf2field_add+0x20>
{
    1cf8:	b430      	push	{r4, r5}
  {
    z[i] = (x[i] ^ y[i]);
    1cfa:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
    1cfe:	f851 5023 	ldr.w	r5, [r1, r3, lsl #2]
    1d02:	406c      	eors	r4, r5
    1d04:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
  for (i = 0; i < BITVEC_NWORDS; ++i)
    1d08:	3301      	adds	r3, #1
    1d0a:	2b05      	cmp	r3, #5
    1d0c:	ddf5      	ble.n	1cfa <gf2field_add+0x8>
  }
}
    1d0e:	bc30      	pop	{r4, r5}
    1d10:	4770      	bx	lr
    1d12:	4770      	bx	lr

00001d14 <gf2field_inc>:

/* increment element */
static void gf2field_inc(gf2elem_t x)
{
  x[0] ^= 1;
    1d14:	6803      	ldr	r3, [r0, #0]
    1d16:	f083 0301 	eor.w	r3, r3, #1
    1d1a:	6003      	str	r3, [r0, #0]
}
    1d1c:	4770      	bx	lr

00001d1e <gf2field_mul>:


/* field multiplication 'z := (x * y)' */
static void gf2field_mul(gf2elem_t z, const gf2elem_t x, const gf2elem_t y)
{
    1d1e:	b570      	push	{r4, r5, r6, lr}
    1d20:	b086      	sub	sp, #24
    1d22:	4606      	mov	r6, r0
    1d24:	460c      	mov	r4, r1
    1d26:	4615      	mov	r5, r2
#if defined(CONST_TIME) && (CONST_TIME == 1)
  gf2elem_t blind;
  bitvec_set_zero(blind);
#endif

  bitvec_copy(tmp, x);
    1d28:	4668      	mov	r0, sp
    1d2a:	f7ff ff37 	bl	1b9c <bitvec_copy>

  /* LSB set? Then start with x */
  if (bitvec_get_bit(y, 0) != 0)
    1d2e:	2100      	movs	r1, #0
    1d30:	4628      	mov	r0, r5
    1d32:	f7ff ff1d 	bl	1b70 <bitvec_get_bit>
    1d36:	b128      	cbz	r0, 1d44 <gf2field_mul+0x26>
  {
    bitvec_copy(z, x);
    1d38:	4621      	mov	r1, r4
    1d3a:	4630      	mov	r0, r6
    1d3c:	f7ff ff2e 	bl	1b9c <bitvec_copy>
{
    1d40:	2401      	movs	r4, #1
    1d42:	e00a      	b.n	1d5a <gf2field_mul+0x3c>
  }
  else /* .. or else start with zero */
  {
    bitvec_set_zero(z);
    1d44:	4630      	mov	r0, r6
    1d46:	f7ff ff54 	bl	1bf2 <bitvec_set_zero>
    1d4a:	e7f9      	b.n	1d40 <gf2field_mul+0x22>
    bitvec_lshift(tmp, tmp, 1);

    /* Modulo reduction polynomial if degree(tmp) > CURVE_DEGREE */
    if (bitvec_get_bit(tmp, CURVE_DEGREE))
    {
      gf2field_add(tmp, tmp, polynomial);
    1d4c:	4a10      	ldr	r2, [pc, #64]	@ (1d90 <gf2field_mul+0x72>)
    1d4e:	4669      	mov	r1, sp
    1d50:	4668      	mov	r0, sp
    1d52:	f7ff ffce 	bl	1cf2 <gf2field_add>
    1d56:	e00d      	b.n	1d74 <gf2field_mul+0x56>
  for (i = 1; i < CURVE_DEGREE; ++i)
    1d58:	3401      	adds	r4, #1
    1d5a:	2ca2      	cmp	r4, #162	@ 0xa2
    1d5c:	dc16      	bgt.n	1d8c <gf2field_mul+0x6e>
    bitvec_lshift(tmp, tmp, 1);
    1d5e:	2201      	movs	r2, #1
    1d60:	4669      	mov	r1, sp
    1d62:	4668      	mov	r0, sp
    1d64:	f7ff ff70 	bl	1c48 <bitvec_lshift>
    if (bitvec_get_bit(tmp, CURVE_DEGREE))
    1d68:	21a3      	movs	r1, #163	@ 0xa3
    1d6a:	4668      	mov	r0, sp
    1d6c:	f7ff ff00 	bl	1b70 <bitvec_get_bit>
    1d70:	2800      	cmp	r0, #0
    1d72:	d1eb      	bne.n	1d4c <gf2field_mul+0x2e>
      gf2field_add(tmp, tmp, blind);
    }
#endif

    /* Add 2^i * tmp if this factor in y is non-zero */
    if (bitvec_get_bit(y, i))
    1d74:	4621      	mov	r1, r4
    1d76:	4628      	mov	r0, r5
    1d78:	f7ff fefa 	bl	1b70 <bitvec_get_bit>
    1d7c:	2800      	cmp	r0, #0
    1d7e:	d0eb      	beq.n	1d58 <gf2field_mul+0x3a>
    {
      gf2field_add(z, z, tmp);
    1d80:	466a      	mov	r2, sp
    1d82:	4631      	mov	r1, r6
    1d84:	4630      	mov	r0, r6
    1d86:	f7ff ffb4 	bl	1cf2 <gf2field_add>
    1d8a:	e7e5      	b.n	1d58 <gf2field_mul+0x3a>
    {
      gf2field_add(z, z, blind);
    }
#endif
  }
}
    1d8c:	b006      	add	sp, #24
    1d8e:	bd70      	pop	{r4, r5, r6, pc}
    1d90:	00002cc4 	andeq	r2, r0, r4, asr #25

00001d94 <gf2field_inv>:

/* field inversion 'z := 1/x' */
static void gf2field_inv(gf2elem_t z, const gf2elem_t x)
{
    1d94:	b5f0      	push	{r4, r5, r6, r7, lr}
    1d96:	b099      	sub	sp, #100	@ 0x64
    1d98:	4607      	mov	r7, r0
  gf2elem_t u, v, g, h;
  int i;

  bitvec_copy(u, x);
    1d9a:	a812      	add	r0, sp, #72	@ 0x48
    1d9c:	f7ff fefe 	bl	1b9c <bitvec_copy>
  bitvec_copy(v, polynomial);
    1da0:	491c      	ldr	r1, [pc, #112]	@ (1e14 <gf2field_inv+0x80>)
    1da2:	a80c      	add	r0, sp, #48	@ 0x30
    1da4:	f7ff fefa 	bl	1b9c <bitvec_copy>
  bitvec_set_zero(g);
    1da8:	a806      	add	r0, sp, #24
    1daa:	f7ff ff22 	bl	1bf2 <bitvec_set_zero>
  gf2field_set_one(z);
    1dae:	4638      	mov	r0, r7
    1db0:	f7ff ff84 	bl	1cbc <gf2field_set_one>
  
  while (!gf2field_is_one(u))
    1db4:	e013      	b.n	1dde <gf2field_inv+0x4a>
    {
      bitvec_swap(u, v);
      bitvec_swap(v, u);
    }
#endif
    bitvec_lshift(h, v, i);
    1db6:	4632      	mov	r2, r6
    1db8:	a90c      	add	r1, sp, #48	@ 0x30
    1dba:	4668      	mov	r0, sp
    1dbc:	f7ff ff44 	bl	1c48 <bitvec_lshift>
    gf2field_add(u, u, h);
    1dc0:	466a      	mov	r2, sp
    1dc2:	a912      	add	r1, sp, #72	@ 0x48
    1dc4:	4608      	mov	r0, r1
    1dc6:	f7ff ff94 	bl	1cf2 <gf2field_add>
    bitvec_lshift(h, g, i);
    1dca:	4632      	mov	r2, r6
    1dcc:	a906      	add	r1, sp, #24
    1dce:	4668      	mov	r0, sp
    1dd0:	f7ff ff3a 	bl	1c48 <bitvec_lshift>
    gf2field_add(z, z, h);
    1dd4:	466a      	mov	r2, sp
    1dd6:	4639      	mov	r1, r7
    1dd8:	4638      	mov	r0, r7
    1dda:	f7ff ff8a 	bl	1cf2 <gf2field_add>
  while (!gf2field_is_one(u))
    1dde:	a812      	add	r0, sp, #72	@ 0x48
    1de0:	f7ff ff76 	bl	1cd0 <gf2field_is_one>
    1de4:	b998      	cbnz	r0, 1e0e <gf2field_inv+0x7a>
    i = (bitvec_degree(u) - bitvec_degree(v));
    1de6:	a812      	add	r0, sp, #72	@ 0x48
    1de8:	f7ff ff19 	bl	1c1e <bitvec_degree>
    1dec:	4604      	mov	r4, r0
    1dee:	a80c      	add	r0, sp, #48	@ 0x30
    1df0:	f7ff ff15 	bl	1c1e <bitvec_degree>
    1df4:	4605      	mov	r5, r0
    if (i < 0)
    1df6:	1a26      	subs	r6, r4, r0
    1df8:	d5dd      	bpl.n	1db6 <gf2field_inv+0x22>
      bitvec_swap(u, v);
    1dfa:	a90c      	add	r1, sp, #48	@ 0x30
    1dfc:	a812      	add	r0, sp, #72	@ 0x48
    1dfe:	f7ff fed7 	bl	1bb0 <bitvec_swap>
      bitvec_swap(g, z);
    1e02:	4639      	mov	r1, r7
    1e04:	a806      	add	r0, sp, #24
    1e06:	f7ff fed3 	bl	1bb0 <bitvec_swap>
      i = -i;
    1e0a:	1b2e      	subs	r6, r5, r4
    1e0c:	e7d3      	b.n	1db6 <gf2field_inv+0x22>
  }
}
    1e0e:	b019      	add	sp, #100	@ 0x64
    1e10:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1e12:	bf00      	nop
    1e14:	00002cc4 	andeq	r2, r0, r4, asr #25

00001e18 <gf2point_copy>:
*/
/*************************************************************************************************/


static void gf2point_copy(gf2elem_t x1, gf2elem_t y1, const gf2elem_t x2, const gf2elem_t y2)
{
    1e18:	b538      	push	{r3, r4, r5, lr}
    1e1a:	460c      	mov	r4, r1
    1e1c:	461d      	mov	r5, r3
  bitvec_copy(x1, x2);
    1e1e:	4611      	mov	r1, r2
    1e20:	f7ff febc 	bl	1b9c <bitvec_copy>
  bitvec_copy(y1, y2);
    1e24:	4629      	mov	r1, r5
    1e26:	4620      	mov	r0, r4
    1e28:	f7ff feb8 	bl	1b9c <bitvec_copy>
}
    1e2c:	bd38      	pop	{r3, r4, r5, pc}

00001e2e <gf2point_set_zero>:

static void gf2point_set_zero(gf2elem_t x, gf2elem_t y)
{
    1e2e:	b510      	push	{r4, lr}
    1e30:	460c      	mov	r4, r1
  bitvec_set_zero(x);
    1e32:	f7ff fede 	bl	1bf2 <bitvec_set_zero>
  bitvec_set_zero(y);
    1e36:	4620      	mov	r0, r4
    1e38:	f7ff fedb 	bl	1bf2 <bitvec_set_zero>
}
    1e3c:	bd10      	pop	{r4, pc}

00001e3e <gf2point_is_zero>:

static int gf2point_is_zero(const gf2elem_t x, const gf2elem_t y)
{
    1e3e:	b510      	push	{r4, lr}
    1e40:	460c      	mov	r4, r1
  return (    bitvec_is_zero(x)
    1e42:	f7ff fedf 	bl	1c04 <bitvec_is_zero>
           && bitvec_is_zero(y));
    1e46:	b120      	cbz	r0, 1e52 <gf2point_is_zero+0x14>
    1e48:	4620      	mov	r0, r4
    1e4a:	f7ff fedb 	bl	1c04 <bitvec_is_zero>
    1e4e:	b100      	cbz	r0, 1e52 <gf2point_is_zero+0x14>
    1e50:	2001      	movs	r0, #1
}
    1e52:	bd10      	pop	{r4, pc}

00001e54 <gf2point_double>:

/* double the point (x,y) */
static void gf2point_double(gf2elem_t x, gf2elem_t y)
{
    1e54:	b530      	push	{r4, r5, lr}
    1e56:	b087      	sub	sp, #28
    1e58:	4604      	mov	r4, r0
    1e5a:	460d      	mov	r5, r1
  /* iff P = O (zero or infinity): 2 * P = P */
  if (bitvec_is_zero(x))
    1e5c:	f7ff fed2 	bl	1c04 <bitvec_is_zero>
    1e60:	b120      	cbz	r0, 1e6c <gf2point_double+0x18>
  {
    bitvec_set_zero(y);
    1e62:	4628      	mov	r0, r5
    1e64:	f7ff fec5 	bl	1bf2 <bitvec_set_zero>
#endif
    gf2field_add(x, x, l);
    gf2field_mul(l, l, x);
    gf2field_add(y, y, l);
  }
}
    1e68:	b007      	add	sp, #28
    1e6a:	bd30      	pop	{r4, r5, pc}
    gf2field_inv(l, x);
    1e6c:	4621      	mov	r1, r4
    1e6e:	4668      	mov	r0, sp
    1e70:	f7ff ff90 	bl	1d94 <gf2field_inv>
    gf2field_mul(l, l, y);
    1e74:	462a      	mov	r2, r5
    1e76:	4669      	mov	r1, sp
    1e78:	4668      	mov	r0, sp
    1e7a:	f7ff ff50 	bl	1d1e <gf2field_mul>
    gf2field_add(l, l, x);
    1e7e:	4622      	mov	r2, r4
    1e80:	4669      	mov	r1, sp
    1e82:	4668      	mov	r0, sp
    1e84:	f7ff ff35 	bl	1cf2 <gf2field_add>
    gf2field_mul(y, x, x);
    1e88:	4622      	mov	r2, r4
    1e8a:	4621      	mov	r1, r4
    1e8c:	4628      	mov	r0, r5
    1e8e:	f7ff ff46 	bl	1d1e <gf2field_mul>
    gf2field_mul(x, l, l);
    1e92:	466a      	mov	r2, sp
    1e94:	4669      	mov	r1, sp
    1e96:	4620      	mov	r0, r4
    1e98:	f7ff ff41 	bl	1d1e <gf2field_mul>
    gf2field_inc(l);
    1e9c:	4668      	mov	r0, sp
    1e9e:	f7ff ff39 	bl	1d14 <gf2field_inc>
    gf2field_add(x, x, l);
    1ea2:	466a      	mov	r2, sp
    1ea4:	4621      	mov	r1, r4
    1ea6:	4620      	mov	r0, r4
    1ea8:	f7ff ff23 	bl	1cf2 <gf2field_add>
    gf2field_mul(l, l, x);
    1eac:	4622      	mov	r2, r4
    1eae:	4669      	mov	r1, sp
    1eb0:	4668      	mov	r0, sp
    1eb2:	f7ff ff34 	bl	1d1e <gf2field_mul>
    gf2field_add(y, y, l);
    1eb6:	466a      	mov	r2, sp
    1eb8:	4629      	mov	r1, r5
    1eba:	4628      	mov	r0, r5
    1ebc:	f7ff ff19 	bl	1cf2 <gf2field_add>
}
    1ec0:	e7d2      	b.n	1e68 <gf2point_double+0x14>

00001ec2 <gf2point_add>:


/* add two points together (x1, y1) := (x1, y1) + (x2, y2) */
static void gf2point_add(gf2elem_t x1, gf2elem_t y1, const gf2elem_t x2, const gf2elem_t y2)
{
    1ec2:	b5f0      	push	{r4, r5, r6, r7, lr}
    1ec4:	b099      	sub	sp, #100	@ 0x64
    1ec6:	4604      	mov	r4, r0
    1ec8:	460f      	mov	r7, r1
    1eca:	4615      	mov	r5, r2
    1ecc:	461e      	mov	r6, r3
  if (!gf2point_is_zero(x2, y2))
    1ece:	4619      	mov	r1, r3
    1ed0:	4610      	mov	r0, r2
    1ed2:	f7ff ffb4 	bl	1e3e <gf2point_is_zero>
    1ed6:	b9c8      	cbnz	r0, 1f0c <gf2point_add+0x4a>
  {
    if (gf2point_is_zero(x1, y1))
    1ed8:	4639      	mov	r1, r7
    1eda:	4620      	mov	r0, r4
    1edc:	f7ff ffaf 	bl	1e3e <gf2point_is_zero>
    1ee0:	b970      	cbnz	r0, 1f00 <gf2point_add+0x3e>
    {
      gf2point_copy(x1, y1, x2, y2);
    }
    else
    {
      if (bitvec_equal(x1, x2))
    1ee2:	4629      	mov	r1, r5
    1ee4:	4620      	mov	r0, r4
    1ee6:	f7ff fe75 	bl	1bd4 <bitvec_equal>
    1eea:	b1b0      	cbz	r0, 1f1a <gf2point_add+0x58>
      {
        if (bitvec_equal(y1, y2))
    1eec:	4631      	mov	r1, r6
    1eee:	4638      	mov	r0, r7
    1ef0:	f7ff fe70 	bl	1bd4 <bitvec_equal>
    1ef4:	b160      	cbz	r0, 1f10 <gf2point_add+0x4e>
        {
          gf2point_double(x1, y1);
    1ef6:	4639      	mov	r1, r7
    1ef8:	4620      	mov	r0, r4
    1efa:	f7ff ffab 	bl	1e54 <gf2point_double>
    1efe:	e005      	b.n	1f0c <gf2point_add+0x4a>
      gf2point_copy(x1, y1, x2, y2);
    1f00:	4633      	mov	r3, r6
    1f02:	462a      	mov	r2, r5
    1f04:	4639      	mov	r1, r7
    1f06:	4620      	mov	r0, r4
    1f08:	f7ff ff86 	bl	1e18 <gf2point_copy>
        gf2field_add(y1, y1, a);
        bitvec_copy(x1, d);
      }
    }
  }
}
    1f0c:	b019      	add	sp, #100	@ 0x64
    1f0e:	bdf0      	pop	{r4, r5, r6, r7, pc}
          gf2point_set_zero(x1, y1);
    1f10:	4639      	mov	r1, r7
    1f12:	4620      	mov	r0, r4
    1f14:	f7ff ff8b 	bl	1e2e <gf2point_set_zero>
    1f18:	e7f8      	b.n	1f0c <gf2point_add+0x4a>
        gf2field_add(a, y1, y2);
    1f1a:	4632      	mov	r2, r6
    1f1c:	4639      	mov	r1, r7
    1f1e:	4668      	mov	r0, sp
    1f20:	f7ff fee7 	bl	1cf2 <gf2field_add>
        gf2field_add(b, x1, x2);
    1f24:	462a      	mov	r2, r5
    1f26:	4621      	mov	r1, r4
    1f28:	a806      	add	r0, sp, #24
    1f2a:	f7ff fee2 	bl	1cf2 <gf2field_add>
        gf2field_inv(c, b);
    1f2e:	a906      	add	r1, sp, #24
    1f30:	a80c      	add	r0, sp, #48	@ 0x30
    1f32:	f7ff ff2f 	bl	1d94 <gf2field_inv>
        gf2field_mul(c, c, a);
    1f36:	466a      	mov	r2, sp
    1f38:	a90c      	add	r1, sp, #48	@ 0x30
    1f3a:	4608      	mov	r0, r1
    1f3c:	f7ff feef 	bl	1d1e <gf2field_mul>
        gf2field_mul(d, c, c);
    1f40:	aa0c      	add	r2, sp, #48	@ 0x30
    1f42:	4611      	mov	r1, r2
    1f44:	a812      	add	r0, sp, #72	@ 0x48
    1f46:	f7ff feea 	bl	1d1e <gf2field_mul>
        gf2field_add(d, d, c);
    1f4a:	aa0c      	add	r2, sp, #48	@ 0x30
    1f4c:	a912      	add	r1, sp, #72	@ 0x48
    1f4e:	4608      	mov	r0, r1
    1f50:	f7ff fecf 	bl	1cf2 <gf2field_add>
        gf2field_add(d, d, b);
    1f54:	aa06      	add	r2, sp, #24
    1f56:	a912      	add	r1, sp, #72	@ 0x48
    1f58:	4608      	mov	r0, r1
    1f5a:	f7ff feca 	bl	1cf2 <gf2field_add>
        gf2field_inc(d);
    1f5e:	a812      	add	r0, sp, #72	@ 0x48
    1f60:	f7ff fed8 	bl	1d14 <gf2field_inc>
        gf2field_add(x1, x1, d);
    1f64:	aa12      	add	r2, sp, #72	@ 0x48
    1f66:	4621      	mov	r1, r4
    1f68:	4620      	mov	r0, r4
    1f6a:	f7ff fec2 	bl	1cf2 <gf2field_add>
        gf2field_mul(a, x1, c);
    1f6e:	aa0c      	add	r2, sp, #48	@ 0x30
    1f70:	4621      	mov	r1, r4
    1f72:	4668      	mov	r0, sp
    1f74:	f7ff fed3 	bl	1d1e <gf2field_mul>
        gf2field_add(a, a, d);
    1f78:	aa12      	add	r2, sp, #72	@ 0x48
    1f7a:	4669      	mov	r1, sp
    1f7c:	4668      	mov	r0, sp
    1f7e:	f7ff feb8 	bl	1cf2 <gf2field_add>
        gf2field_add(y1, y1, a);
    1f82:	466a      	mov	r2, sp
    1f84:	4639      	mov	r1, r7
    1f86:	4638      	mov	r0, r7
    1f88:	f7ff feb3 	bl	1cf2 <gf2field_add>
        bitvec_copy(x1, d);
    1f8c:	a912      	add	r1, sp, #72	@ 0x48
    1f8e:	4620      	mov	r0, r4
    1f90:	f7ff fe04 	bl	1b9c <bitvec_copy>
}
    1f94:	e7ba      	b.n	1f0c <gf2point_add+0x4a>

00001f96 <gf2point_mul>:


#if defined(CONST_TIME) && (CONST_TIME == 0)
/* point multiplication via double-and-add algorithm */
static void gf2point_mul(gf2elem_t x, gf2elem_t y, const scalar_t exp)
{
    1f96:	b5f0      	push	{r4, r5, r6, r7, lr}
    1f98:	b08d      	sub	sp, #52	@ 0x34
    1f9a:	4606      	mov	r6, r0
    1f9c:	460f      	mov	r7, r1
    1f9e:	4615      	mov	r5, r2
  gf2elem_t tmpx, tmpy;
  int i;
  int nbits = bitvec_degree(exp);
    1fa0:	4610      	mov	r0, r2
    1fa2:	f7ff fe3c 	bl	1c1e <bitvec_degree>
    1fa6:	4604      	mov	r4, r0

  gf2point_set_zero(tmpx, tmpy);
    1fa8:	4669      	mov	r1, sp
    1faa:	a806      	add	r0, sp, #24
    1fac:	f7ff ff3f 	bl	1e2e <gf2point_set_zero>

  for (i = (nbits - 1); i >= 0; --i)
    1fb0:	3c01      	subs	r4, #1
    1fb2:	e000      	b.n	1fb6 <gf2point_mul+0x20>
    1fb4:	3c01      	subs	r4, #1
    1fb6:	2c00      	cmp	r4, #0
    1fb8:	db10      	blt.n	1fdc <gf2point_mul+0x46>
  {
    gf2point_double(tmpx, tmpy);
    1fba:	4669      	mov	r1, sp
    1fbc:	a806      	add	r0, sp, #24
    1fbe:	f7ff ff49 	bl	1e54 <gf2point_double>
    if (bitvec_get_bit(exp, i))
    1fc2:	4621      	mov	r1, r4
    1fc4:	4628      	mov	r0, r5
    1fc6:	f7ff fdd3 	bl	1b70 <bitvec_get_bit>
    1fca:	2800      	cmp	r0, #0
    1fcc:	d0f2      	beq.n	1fb4 <gf2point_mul+0x1e>
    {
      gf2point_add(tmpx, tmpy, x, y);
    1fce:	463b      	mov	r3, r7
    1fd0:	4632      	mov	r2, r6
    1fd2:	4669      	mov	r1, sp
    1fd4:	a806      	add	r0, sp, #24
    1fd6:	f7ff ff74 	bl	1ec2 <gf2point_add>
    1fda:	e7eb      	b.n	1fb4 <gf2point_mul+0x1e>
    }
  }
  gf2point_copy(x, y, tmpx, tmpy);
    1fdc:	466b      	mov	r3, sp
    1fde:	aa06      	add	r2, sp, #24
    1fe0:	4639      	mov	r1, r7
    1fe2:	4630      	mov	r0, r6
    1fe4:	f7ff ff18 	bl	1e18 <gf2point_copy>
}
    1fe8:	b00d      	add	sp, #52	@ 0x34
    1fea:	bdf0      	pop	{r4, r5, r6, r7, pc}

00001fec <gf2point_on_curve>:



/* check if y^2 + x*y = x^3 + a*x^2 + coeff_b holds */
static int gf2point_on_curve(const gf2elem_t x, const gf2elem_t y)
{
    1fec:	b530      	push	{r4, r5, lr}
    1fee:	b08d      	sub	sp, #52	@ 0x34
    1ff0:	4604      	mov	r4, r0
    1ff2:	460d      	mov	r5, r1
  gf2elem_t a, b;

  if (gf2point_is_zero(x, y))
    1ff4:	f7ff ff23 	bl	1e3e <gf2point_is_zero>
    1ff8:	b110      	cbz	r0, 2000 <gf2point_on_curve+0x14>
  {
    return 1;
    1ffa:	2001      	movs	r0, #1
    gf2field_add(a, a, b);
    gf2field_mul(b, x, y);

    return bitvec_equal(a, b);
  }
}
    1ffc:	b00d      	add	sp, #52	@ 0x34
    1ffe:	bd30      	pop	{r4, r5, pc}
    gf2field_mul(a, x, x);
    2000:	4622      	mov	r2, r4
    2002:	4621      	mov	r1, r4
    2004:	a806      	add	r0, sp, #24
    2006:	f7ff fe8a 	bl	1d1e <gf2field_mul>
    gf2field_mul(b, a, x);
    200a:	4622      	mov	r2, r4
    200c:	a906      	add	r1, sp, #24
    200e:	4668      	mov	r0, sp
    2010:	f7ff fe85 	bl	1d1e <gf2field_mul>
    gf2field_add(a, a, b);
    2014:	466a      	mov	r2, sp
    2016:	a906      	add	r1, sp, #24
    2018:	4608      	mov	r0, r1
    201a:	f7ff fe6a 	bl	1cf2 <gf2field_add>
    gf2field_add(a, a, coeff_b);
    201e:	4a0c      	ldr	r2, [pc, #48]	@ (2050 <gf2point_on_curve+0x64>)
    2020:	a906      	add	r1, sp, #24
    2022:	4608      	mov	r0, r1
    2024:	f7ff fe65 	bl	1cf2 <gf2field_add>
    gf2field_mul(b, y, y);
    2028:	462a      	mov	r2, r5
    202a:	4629      	mov	r1, r5
    202c:	4668      	mov	r0, sp
    202e:	f7ff fe76 	bl	1d1e <gf2field_mul>
    gf2field_add(a, a, b);
    2032:	466a      	mov	r2, sp
    2034:	a906      	add	r1, sp, #24
    2036:	4608      	mov	r0, r1
    2038:	f7ff fe5b 	bl	1cf2 <gf2field_add>
    gf2field_mul(b, x, y);
    203c:	462a      	mov	r2, r5
    203e:	4621      	mov	r1, r4
    2040:	4668      	mov	r0, sp
    2042:	f7ff fe6c 	bl	1d1e <gf2field_mul>
    return bitvec_equal(a, b);
    2046:	4669      	mov	r1, sp
    2048:	a806      	add	r0, sp, #24
    204a:	f7ff fdc3 	bl	1bd4 <bitvec_equal>
    204e:	e7d5      	b.n	1ffc <gf2point_on_curve+0x10>
    2050:	00002cdc 	ldrdeq	r2, [r0], -ip

00002054 <ecdh_generate_keys>:



/* NOTE: private should contain random data a-priori! */
int ecdh_generate_keys(uint8_t* public_key, uint8_t* private_key)
{
    2054:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2056:	4606      	mov	r6, r0
    2058:	460d      	mov	r5, r1
  /* Get copy of "base" point 'G' */
  gf2point_copy((uint32_t*)public_key, (uint32_t*)(public_key + BITVEC_NBYTES), base_x, base_y);
    205a:	f100 0718 	add.w	r7, r0, #24
    205e:	4a10      	ldr	r2, [pc, #64]	@ (20a0 <ecdh_generate_keys+0x4c>)
    2060:	f102 0330 	add.w	r3, r2, #48	@ 0x30
    2064:	3248      	adds	r2, #72	@ 0x48
    2066:	4639      	mov	r1, r7
    2068:	f7ff fed6 	bl	1e18 <gf2point_copy>

  /* Abort key generation if random number is too small */
  if (bitvec_degree((uint32_t*)private_key) < (CURVE_DEGREE / 2))
    206c:	4628      	mov	r0, r5
    206e:	f7ff fdd6 	bl	1c1e <bitvec_degree>
    2072:	2850      	cmp	r0, #80	@ 0x50
    2074:	dd12      	ble.n	209c <ecdh_generate_keys+0x48>
    return 0;
  }
  else
  {
    /* Clear bits > CURVE_DEGREE in highest word to satisfy constraint 1 <= exp < n. */
    int nbits = bitvec_degree(base_order);
    2076:	480b      	ldr	r0, [pc, #44]	@ (20a4 <ecdh_generate_keys+0x50>)
    2078:	f7ff fdd1 	bl	1c1e <bitvec_degree>
    int i;

    for (i = (nbits - 1); i < (BITVEC_NWORDS * 32); ++i)
    207c:	1e44      	subs	r4, r0, #1
    207e:	e004      	b.n	208a <ecdh_generate_keys+0x36>
    {
      bitvec_clr_bit((uint32_t*)private_key, i);
    2080:	4621      	mov	r1, r4
    2082:	4628      	mov	r0, r5
    2084:	f7ff fd7d 	bl	1b82 <bitvec_clr_bit>
    for (i = (nbits - 1); i < (BITVEC_NWORDS * 32); ++i)
    2088:	3401      	adds	r4, #1
    208a:	2cbf      	cmp	r4, #191	@ 0xbf
    208c:	ddf8      	ble.n	2080 <ecdh_generate_keys+0x2c>
    }

    /* Multiply base-point with scalar (private-key) */
    gf2point_mul((uint32_t*)public_key, (uint32_t*)(public_key + BITVEC_NBYTES), (uint32_t*)private_key);
    208e:	462a      	mov	r2, r5
    2090:	4639      	mov	r1, r7
    2092:	4630      	mov	r0, r6
    2094:	f7ff ff7f 	bl	1f96 <gf2point_mul>

    return 1;
    2098:	2001      	movs	r0, #1
  }
}
    209a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return 0;
    209c:	2000      	movs	r0, #0
    209e:	e7fc      	b.n	209a <ecdh_generate_keys+0x46>
    20a0:	00002cc4 	andeq	r2, r0, r4, asr #25
    20a4:	00002d24 	andeq	r2, r0, r4, lsr #26

000020a8 <ecdh_shared_secret>:



int ecdh_shared_secret(const uint8_t* private_key, const uint8_t* others_pub, uint8_t* output)
{
    20a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    20aa:	4606      	mov	r6, r0
    20ac:	460c      	mov	r4, r1
    20ae:	4615      	mov	r5, r2
  /* Do some basic validation of other party's public key */
  if (    !gf2point_is_zero ((uint32_t*)others_pub, (uint32_t*)(others_pub + BITVEC_NBYTES))
    20b0:	f101 0718 	add.w	r7, r1, #24
    20b4:	4639      	mov	r1, r7
    20b6:	4620      	mov	r0, r4
    20b8:	f7ff fec1 	bl	1e3e <gf2point_is_zero>
    20bc:	b108      	cbz	r0, 20c2 <ecdh_shared_secret+0x1a>
    
    return 1;
  }
  else
  {
    return 0;
    20be:	2000      	movs	r0, #0
  }
}
    20c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
       &&  gf2point_on_curve((uint32_t*)others_pub, (uint32_t*)(others_pub + BITVEC_NBYTES)) )
    20c2:	4639      	mov	r1, r7
    20c4:	4620      	mov	r0, r4
    20c6:	f7ff ff91 	bl	1fec <gf2point_on_curve>
    20ca:	2800      	cmp	r0, #0
    20cc:	d0f7      	beq.n	20be <ecdh_shared_secret+0x16>
    for (i = 0; i < (BITVEC_NBYTES * 2); ++i)
    20ce:	2300      	movs	r3, #0
    20d0:	e004      	b.n	20dc <ecdh_shared_secret+0x34>
      output[i] = others_pub[i];
    20d2:	f814 c003 	ldrb.w	ip, [r4, r3]
    20d6:	f805 c003 	strb.w	ip, [r5, r3]
    for (i = 0; i < (BITVEC_NBYTES * 2); ++i)
    20da:	3301      	adds	r3, #1
    20dc:	2b2f      	cmp	r3, #47	@ 0x2f
    20de:	d9f8      	bls.n	20d2 <ecdh_shared_secret+0x2a>
    gf2point_mul((uint32_t*)output,(uint32_t*)(output + BITVEC_NBYTES), (const uint32_t*)private_key);
    20e0:	4632      	mov	r2, r6
    20e2:	f105 0118 	add.w	r1, r5, #24
    20e6:	4628      	mov	r0, r5
    20e8:	f7ff ff55 	bl	1f96 <gf2point_mul>
    return 1;
    20ec:	2001      	movs	r0, #1
    20ee:	e7e7      	b.n	20c0 <ecdh_shared_secret+0x18>

000020f0 <atoi>:
 * limitations under the License.
 **/

#include "a2i.h"

int atoi(const char* str) {
    20f0:	4601      	mov	r1, r0
  int res = 0;
  for (int i = 0; str[i] != '\0'; ++i) {
    20f2:	2200      	movs	r2, #0
  int res = 0;
    20f4:	4610      	mov	r0, r2
  for (int i = 0; str[i] != '\0'; ++i) {
    20f6:	e006      	b.n	2106 <atoi+0x16>
    res = res * 10 + str[i] - '0';
    20f8:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    20fc:	eb03 0340 	add.w	r3, r3, r0, lsl #1
    2100:	f1a3 0030 	sub.w	r0, r3, #48	@ 0x30
  for (int i = 0; str[i] != '\0'; ++i) {
    2104:	3201      	adds	r2, #1
    2106:	5c8b      	ldrb	r3, [r1, r2]
    2108:	2b00      	cmp	r3, #0
    210a:	d1f5      	bne.n	20f8 <atoi+0x8>
  }
  return res;
}
    210c:	4770      	bx	lr

0000210e <atoh>:

uint32_t atoh(const char* str) {
    210e:	4684      	mov	ip, r0
  uint32_t hex = 0;
  uint32_t value = 0;

  for (uint32_t i = 0; str[i] != '\0'; i++) {
    2110:	2100      	movs	r1, #0
  uint32_t hex = 0;
    2112:	4608      	mov	r0, r1
  for (uint32_t i = 0; str[i] != '\0'; i++) {
    2114:	e008      	b.n	2128 <atoh+0x1a>
    if (str[i] >= '0' && str[i] <= '9') {
      value = str[i] - '0';
    } else if (str[i] >= 'a' && str[i] <= 'f') {
    2116:	f1a3 0261 	sub.w	r2, r3, #97	@ 0x61
    211a:	b2d2      	uxtb	r2, r2
    211c:	2a05      	cmp	r2, #5
    211e:	d80d      	bhi.n	213c <atoh+0x2e>
      value = str[i] - 'a' + 10;
    2120:	3b57      	subs	r3, #87	@ 0x57
      continue;
    }

    // make space for the new nibble on the right
    hex = hex << 4;
    hex |= value;
    2122:	ea43 1000 	orr.w	r0, r3, r0, lsl #4
  for (uint32_t i = 0; str[i] != '\0'; i++) {
    2126:	3101      	adds	r1, #1
    2128:	f81c 3001 	ldrb.w	r3, [ip, r1]
    212c:	b16b      	cbz	r3, 214a <atoh+0x3c>
    if (str[i] >= '0' && str[i] <= '9') {
    212e:	f1a3 0230 	sub.w	r2, r3, #48	@ 0x30
    2132:	b2d2      	uxtb	r2, r2
    2134:	2a09      	cmp	r2, #9
    2136:	d8ee      	bhi.n	2116 <atoh+0x8>
      value = str[i] - '0';
    2138:	3b30      	subs	r3, #48	@ 0x30
    213a:	e7f2      	b.n	2122 <atoh+0x14>
    } else if (str[i] >= 'A' && str[i] <= 'F') {
    213c:	f1a3 0241 	sub.w	r2, r3, #65	@ 0x41
    2140:	b2d2      	uxtb	r2, r2
    2142:	2a05      	cmp	r2, #5
    2144:	d8ef      	bhi.n	2126 <atoh+0x18>
      value = str[i] - 'A' + 10;
    2146:	3b37      	subs	r3, #55	@ 0x37
    2148:	e7eb      	b.n	2122 <atoh+0x14>
  }

  return hex;
}
    214a:	4770      	bx	lr

0000214c <memlog_init>:

void memlog_init(uint8_t *addr, uint32_t size, mode_t mode) {
  selected_mode = mode;
    214c:	4b0e      	ldr	r3, [pc, #56]	@ (2188 <memlog_init+0x3c>)
    214e:	701a      	strb	r2, [r3, #0]

  if (selected_mode == NONE) {
    2150:	b1ca      	cbz	r2, 2186 <memlog_init+0x3a>
void memlog_init(uint8_t *addr, uint32_t size, mode_t mode) {
    2152:	b570      	push	{r4, r5, r6, lr}
    return;
  }

  out_buf_rgn.addr = addr;
    2154:	6058      	str	r0, [r3, #4]
  out_buf_rgn.size = size / 2;
    2156:	084c      	lsrs	r4, r1, #1
    2158:	609c      	str	r4, [r3, #8]
  out_buf_rgn.curr_index = 0;
    215a:	2500      	movs	r5, #0
    215c:	60dd      	str	r5, [r3, #12]

  inp_buf_rgn.addr = addr + size / 2;
    215e:	1906      	adds	r6, r0, r4
    2160:	611e      	str	r6, [r3, #16]
  inp_buf_rgn.size = size / 2;
    2162:	615c      	str	r4, [r3, #20]
  inp_buf_rgn.curr_index = 0;
    2164:	619d      	str	r5, [r3, #24]

  if (!(selected_mode & INP)) {
    2166:	f012 0f01 	tst.w	r2, #1
    216a:	d105      	bne.n	2178 <memlog_init+0x2c>
    // No input, use the extra memory for output.

    out_buf_rgn.size = size;
    216c:	6099      	str	r1, [r3, #8]

    inp_buf_rgn.addr = addr;
    inp_buf_rgn.size = size;
  }

  memset(addr, 0, size);
    216e:	460a      	mov	r2, r1
    2170:	2100      	movs	r1, #0
    2172:	f000 f869 	bl	2248 <memset>
}
    2176:	bd70      	pop	{r4, r5, r6, pc}
  } else if (!(selected_mode & OUT)) {
    2178:	f012 0f02 	tst.w	r2, #2
    217c:	d1f7      	bne.n	216e <memlog_init+0x22>
    inp_buf_rgn.addr = addr;
    217e:	4b02      	ldr	r3, [pc, #8]	@ (2188 <memlog_init+0x3c>)
    2180:	6118      	str	r0, [r3, #16]
    inp_buf_rgn.size = size;
    2182:	6159      	str	r1, [r3, #20]
    2184:	e7f3      	b.n	216e <memlog_init+0x22>
    2186:	4770      	bx	lr
    2188:	20000124 	andcs	r0, r0, r4, lsr #2

0000218c <memlog_getc>:

int memlog_getc() {
  if (!(selected_mode & INP)) {
    218c:	4b0e      	ldr	r3, [pc, #56]	@ (21c8 <memlog_getc+0x3c>)
    218e:	781b      	ldrb	r3, [r3, #0]
    2190:	f013 0f01 	tst.w	r3, #1
    2194:	d012      	beq.n	21bc <memlog_getc+0x30>
    return -1;
  }

  if (inp_buf_rgn.addr[inp_buf_rgn.curr_index] == 0) {
    2196:	4b0c      	ldr	r3, [pc, #48]	@ (21c8 <memlog_getc+0x3c>)
    2198:	691a      	ldr	r2, [r3, #16]
    219a:	699b      	ldr	r3, [r3, #24]
    219c:	5cd1      	ldrb	r1, [r2, r3]
    219e:	b181      	cbz	r1, 21c2 <memlog_getc+0x36>
    return -1;
  }

  int val = inp_buf_rgn.addr[inp_buf_rgn.curr_index];
    21a0:	5cd0      	ldrb	r0, [r2, r3]
    21a2:	b2c0      	uxtb	r0, r0
  inp_buf_rgn.addr[inp_buf_rgn.curr_index] = 0;
    21a4:	2100      	movs	r1, #0
    21a6:	54d1      	strb	r1, [r2, r3]
  inp_buf_rgn.curr_index++;
    21a8:	3301      	adds	r3, #1
    21aa:	4a07      	ldr	r2, [pc, #28]	@ (21c8 <memlog_getc+0x3c>)
    21ac:	6193      	str	r3, [r2, #24]

  if (inp_buf_rgn.curr_index == inp_buf_rgn.size) {
    21ae:	6952      	ldr	r2, [r2, #20]
    21b0:	4293      	cmp	r3, r2
    21b2:	d000      	beq.n	21b6 <memlog_getc+0x2a>
    inp_buf_rgn.curr_index = 0;
  }

  return val;
}
    21b4:	4770      	bx	lr
    inp_buf_rgn.curr_index = 0;
    21b6:	4b04      	ldr	r3, [pc, #16]	@ (21c8 <memlog_getc+0x3c>)
    21b8:	6199      	str	r1, [r3, #24]
    21ba:	4770      	bx	lr
    return -1;
    21bc:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    21c0:	4770      	bx	lr
    return -1;
    21c2:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    21c6:	e7f5      	b.n	21b4 <memlog_getc+0x28>
    21c8:	20000124 	andcs	r0, r0, r4, lsr #2

000021cc <memlog_putc>:

void memlog_putc(char c) {
  if (!(selected_mode & OUT) || c == 0) {
    21cc:	4b09      	ldr	r3, [pc, #36]	@ (21f4 <memlog_putc+0x28>)
    21ce:	781b      	ldrb	r3, [r3, #0]
    21d0:	f013 0f02 	tst.w	r3, #2
    21d4:	d009      	beq.n	21ea <memlog_putc+0x1e>
    21d6:	b140      	cbz	r0, 21ea <memlog_putc+0x1e>
    return;
  }

  out_buf_rgn.addr[out_buf_rgn.curr_index] = (uint8_t) c;
    21d8:	4a06      	ldr	r2, [pc, #24]	@ (21f4 <memlog_putc+0x28>)
    21da:	6851      	ldr	r1, [r2, #4]
    21dc:	68d3      	ldr	r3, [r2, #12]
    21de:	54c8      	strb	r0, [r1, r3]
  out_buf_rgn.curr_index++;
    21e0:	3301      	adds	r3, #1
    21e2:	60d3      	str	r3, [r2, #12]

  if (out_buf_rgn.curr_index == out_buf_rgn.size) {
    21e4:	6892      	ldr	r2, [r2, #8]
    21e6:	4293      	cmp	r3, r2
    21e8:	d000      	beq.n	21ec <memlog_putc+0x20>
    out_buf_rgn.curr_index = 0;
  }
}
    21ea:	4770      	bx	lr
    out_buf_rgn.curr_index = 0;
    21ec:	4b01      	ldr	r3, [pc, #4]	@ (21f4 <memlog_putc+0x28>)
    21ee:	2200      	movs	r2, #0
    21f0:	60da      	str	r2, [r3, #12]
    21f2:	e7fa      	b.n	21ea <memlog_putc+0x1e>
    21f4:	20000124 	andcs	r0, r0, r4, lsr #2

000021f8 <strlen>:
 * limitations under the License.
 **/

#include "string.h"

size_t strlen(const char *str) {
    21f8:	4602      	mov	r2, r0
  size_t len = 0;
    21fa:	2000      	movs	r0, #0
  while (str[len]) {
    21fc:	e000      	b.n	2200 <strlen+0x8>
    len++;
    21fe:	3001      	adds	r0, #1
  while (str[len]) {
    2200:	5c13      	ldrb	r3, [r2, r0]
    2202:	2b00      	cmp	r3, #0
    2204:	d1fb      	bne.n	21fe <strlen+0x6>
  }
  return len;
}
    2206:	4770      	bx	lr

00002208 <strcmp>:

int strcmp(const char *str1, const char *str2) {
  while (*str1 && (*str1 == *str2)) {
    2208:	e001      	b.n	220e <strcmp+0x6>
    str1++;
    220a:	3001      	adds	r0, #1
    str2++;
    220c:	3101      	adds	r1, #1
  while (*str1 && (*str1 == *str2)) {
    220e:	7803      	ldrb	r3, [r0, #0]
    2210:	b113      	cbz	r3, 2218 <strcmp+0x10>
    2212:	780a      	ldrb	r2, [r1, #0]
    2214:	4293      	cmp	r3, r2
    2216:	d0f8      	beq.n	220a <strcmp+0x2>
  }
  return *str1 - *str2;
    2218:	7808      	ldrb	r0, [r1, #0]
}
    221a:	1a18      	subs	r0, r3, r0
    221c:	4770      	bx	lr

0000221e <strcpy>:

char *strcpy(char *str1, const char *str2) {
  while (*str2) {
    221e:	e002      	b.n	2226 <strcpy+0x8>
    *(str1++) = *(str2++);
    2220:	3101      	adds	r1, #1
    2222:	f800 3b01 	strb.w	r3, [r0], #1
  while (*str2) {
    2226:	780b      	ldrb	r3, [r1, #0]
    2228:	2b00      	cmp	r3, #0
    222a:	d1f9      	bne.n	2220 <strcpy+0x2>
  }
  *str1 = '\0';
    222c:	7003      	strb	r3, [r0, #0]
  return 0;
}
    222e:	4618      	mov	r0, r3
    2230:	4770      	bx	lr

00002232 <memcpy>:

void *memcpy(void *dest, const void *src, size_t size) {
  size_t i;
  char *src_char = (char *)src;
  char *dest_char = (char *)dest;
  for (i = 0; i < size; i++) {
    2232:	2300      	movs	r3, #0
    2234:	e004      	b.n	2240 <memcpy+0xe>
    dest_char[i] = src_char[i];
    2236:	f811 c003 	ldrb.w	ip, [r1, r3]
    223a:	f800 c003 	strb.w	ip, [r0, r3]
  for (i = 0; i < size; i++) {
    223e:	3301      	adds	r3, #1
    2240:	4293      	cmp	r3, r2
    2242:	d3f8      	bcc.n	2236 <memcpy+0x4>
  }
  return 0;
}
    2244:	2000      	movs	r0, #0
    2246:	4770      	bx	lr

00002248 <memset>:

void *memset(void *dest, int val, size_t size) {
  size_t i;
  char *dest_char = (char *)dest;
  for (i = 0; i < size; i++) {
    2248:	2300      	movs	r3, #0
    224a:	e001      	b.n	2250 <memset+0x8>
    dest_char[i] = val;
    224c:	54c1      	strb	r1, [r0, r3]
  for (i = 0; i < size; i++) {
    224e:	3301      	adds	r3, #1
    2250:	4293      	cmp	r3, r2
    2252:	d3fb      	bcc.n	224c <memset+0x4>
  }

  return 0;
}
    2254:	2000      	movs	r0, #0
    2256:	4770      	bx	lr

00002258 <reset_handler>:
    2258:	f7fe fd54 	bl	d04 <prompt>
    225c:	f7ff fffe 	bl	225c <reset_handler+0x4>

Disassembly of section .rodata:

00002264 <_varcar_mesg-0x4>:
    2264:	00000000 	andeq	r0, r0, r0

00002268 <_varcar_mesg>:
    2268:	00002384 	andeq	r2, r0, r4, lsl #7
    226c:	00002390 	muleq	r0, r0, r3
    2270:	000003c1 	andeq	r0, r0, r1, asr #7

00002274 <_varpair>:

// ADD_CMD(keyword, description, function name);
ADD_CMD(pair, "Starts the pairing process with a car.", pair);
    2274:	000023e0 	andeq	r2, r0, r0, ror #7
    2278:	000023e8 	andeq	r2, r0, r8, ror #7
    227c:	0000057d 	andeq	r0, r0, sp, ror r5

00002280 <_varaes>:

// ADD_CMD(command, description, function name);
    2280:	00002488 	andeq	r2, r0, r8, lsl #9
    2284:	0000248c 	andeq	r2, r0, ip, lsl #9
    2288:	00000599 	muleq	r0, r9, r5

0000228c <_vardecode64>:

// ADD_CMD(command, description, function name);
ADD_CMD(encode64, "Base64 encodes a string and sends it on UART2", encode64);
    228c:	000025e4 	andeq	r2, r0, r4, ror #11
    2290:	000025f0 	strdeq	r2, [r0], -r0
    2294:	0000067d 	andeq	r0, r0, sp, ror r6

00002298 <_varencode64>:
ADD_CMD(encode64, "Base64 encodes a string and sends it on UART2", encode64);
    2298:	00002620 	andeq	r2, r0, r0, lsr #12
    229c:	0000262c 	andeq	r2, r0, ip, lsr #12
    22a0:	0000062d 	andeq	r0, r0, sp, lsr #12

000022a4 <_varsend_ping>:

// ADD_CMD(command, description, function name);
ADD_CMD(ping, "Pings the other board", send_ping);
    22a4:	00002680 	andeq	r2, r0, r0, lsl #13
    22a8:	00002688 	andeq	r2, r0, r8, lsl #13
    22ac:	000006fd 	strdeq	r0, [r0], -sp

000022b0 <_varcmd_exec_status>:

// DO NOT REMOVE THESE
AUTO_CMD(version, "Prints details of the build", build_info);
ADD_CMD(help, "Prints all available commands", help);
ADD_CMD(status, "Returns exit status of last executed command",
    22b0:	0000276c 	andeq	r2, r0, ip, ror #14
    22b4:	00002774 	andeq	r2, r0, r4, ror r7
    22b8:	00000819 	andeq	r0, r0, r9, lsl r8

000022bc <_varhelp>:
ADD_CMD(help, "Prints all available commands", help);
    22bc:	000027a4 	andeq	r2, r0, r4, lsr #15
    22c0:	000027ac 	andeq	r2, r0, ip, lsr #15
    22c4:	000008a1 	andeq	r0, r0, r1, lsr #17

000022c8 <_varshow_history>:
ADD_CMD(history, "Show command history", show_history);
    22c8:	000027f0 	strdeq	r2, [r0], -r0
    22cc:	000027f8 	strdeq	r2, [r0], -r8
    22d0:	000007d9 	ldrdeq	r0, [r0], -r9

000022d4 <_varread_mem>:
ADD_CMD(rb, "reads a bit from memory location", r32_bit);
#endif //SHELL_NO_BIT_UTILS

ADD_CMD(r32, "reads a 32 bit memory location", r32);
ADD_CMD(w32, "writes a 32 bit value to a memory location", w32);
ADD_CMD(read, "Reads number of bytes from memory", read_mem);
    22d4:	000029ec 	andeq	r2, r0, ip, ror #19
    22d8:	000029f4 	strdeq	r2, [r0], -r4
    22dc:	000014a1 	andeq	r1, r0, r1, lsr #9

000022e0 <_varw32>:
ADD_CMD(w32, "writes a 32 bit value to a memory location", w32);
    22e0:	00002a18 	andeq	r2, r0, r8, lsl sl
    22e4:	00002a1c 	andeq	r2, r0, ip, lsl sl
    22e8:	00001471 	andeq	r1, r0, r1, ror r4

000022ec <_varr32>:
ADD_CMD(r32, "reads a 32 bit memory location", r32);
    22ec:	00002a48 	andeq	r2, r0, r8, asr #20
    22f0:	00002a4c 	andeq	r2, r0, ip, asr #20
    22f4:	00001441 	andeq	r1, r0, r1, asr #8

000022f8 <_varr32_bit>:
ADD_CMD(rb, "reads a bit from memory location", r32_bit);
    22f8:	00002a6c 	andeq	r2, r0, ip, ror #20
    22fc:	00002a70 	andeq	r2, r0, r0, ror sl
    2300:	00001551 	andeq	r1, r0, r1, asr r5

00002304 <_varw32_bit>:
ADD_CMD(wb, "write a bit to memory location", w32_bit);
    2304:	00002a94 	muleq	r0, r4, sl
    2308:	00002a98 	muleq	r0, r8, sl
    230c:	000014e9 	andeq	r1, r0, r9, ror #9

00002310 <_varbuild_info>:
AUTO_CMD(version, "Prints details of the build", build_info);
    2310:	000027cc 	andeq	r2, r0, ip, asr #15
    2314:	000027d4 	ldrdeq	r2, [r0], -r4
    2318:	00000835 	andeq	r0, r0, r5, lsr r8

0000231c <cmd_end_>:
	...
    2328:	65636552 	strbvs	r6, [r3, #-1362]!	@ 0xfffffaae
    232c:	64657669 	strbtvs	r7, [r5], #-1641	@ 0xfffff997
    2330:	65687420 	strbvs	r7, [r8, #-1056]!	@ 0xfffffbe0
    2334:	73656d20 	cmnvc	r5, #32, 26	@ 0x800
    2338:	65676173 	strbvs	r6, [r7, #-371]!	@ 0xfffffe8d
    233c:	0000003a 	andeq	r0, r0, sl, lsr r0
    2340:	00732520 	rsbseq	r2, r3, r0, lsr #10
    2344:	474e4950 	smlsldmi	r4, lr, r0, r9
    2348:	5045525f 	subpl	r5, r5, pc, asr r2
    234c:	0000594c 	andeq	r5, r0, ip, asr #18
    2350:	20746f47 	rsbscs	r6, r4, r7, asr #30
    2354:	69702061 	ldmdbvs	r0!, {r0, r5, r6, sp}^
    2358:	7220676e 	eorvc	r6, r0, #28835840	@ 0x1b80000
    235c:	796c7065 	stmdbvc	ip!, {r0, r2, r5, r6, ip, sp, lr}^
    2360:	00000a2e 	andeq	r0, r0, lr, lsr #20
    2364:	6e646944 	vnmulvs.f16	s13, s8, s8	@ <UNPREDICTABLE>
    2368:	6b207427 	blvs	81f40c <__ROM_SIZE__+0x7df40c>
    236c:	20776f6e 	rsbscs	r6, r7, lr, ror #30
    2370:	20776f68 	rsbscs	r6, r7, r8, ror #30
    2374:	68206f74 	stmdavs	r0!, {r2, r4, r5, r6, r8, r9, sl, fp, sp, lr}
    2378:	6c646e61 	stclvs	14, cr6, [r4], #-388	@ 0xfffffe7c
    237c:	73252065 			@ <UNDEFINED> instruction: 0x73252065
    2380:	0000000a 	andeq	r0, r0, sl
    2384:	5f524143 	svcpl	0x00524143
    2388:	4753454d 	ldrbmi	r4, [r3, -sp, asr #10]
    238c:	00000000 	andeq	r0, r0, r0
    2390:	636f7250 	cmnvs	pc, #80, 4
    2394:	65737365 	ldrbvs	r7, [r3, #-869]!	@ 0xfffffc9b
    2398:	20612073 	rsbcs	r2, r1, r3, ror r0
    239c:	7373656d 	cmnvc	r3, #457179136	@ 0x1b400000
    23a0:	20656761 	rsbcs	r6, r5, r1, ror #14
    23a4:	6d6f7266 	sfmvs	f7, 2, [pc, #-408]!	@ 2214 <strcmp+0xc>
    23a8:	65687420 	strbvs	r7, [r8, #-1056]!	@ 0xfffffbe0
    23ac:	72616320 	rsbvc	r6, r1, #32, 6	@ 0x80000000
    23b0:	00000000 	andeq	r0, r0, r0
    23b4:	646e6553 	strbtvs	r6, [lr], #-1363	@ 0xfffffaad
    23b8:	20676e69 	rsbcs	r6, r7, r9, ror #28
    23bc:	61702061 	cmnvs	r0, r1, rrx
    23c0:	72207269 	eorvc	r7, r0, #-1879048186	@ 0x90000006
    23c4:	65757165 	ldrbvs	r7, [r5, #-357]!	@ 0xfffffe9b
    23c8:	0a2e7473 	beq	b9f59c <__ROM_SIZE__+0xb5f59c>
    23cc:	00000000 	andeq	r0, r0, r0
    23d0:	5f424f46 	svcpl	0x00424f46
    23d4:	4753454d 	ldrbmi	r4, [r3, -sp, asr #10]
    23d8:	49415020 	stmdbmi	r1, {r5, ip, lr}^
    23dc:	00000a52 	andeq	r0, r0, r2, asr sl
    23e0:	72696170 	rsbvc	r6, r9, #112, 2
    23e4:	00000000 	andeq	r0, r0, r0
    23e8:	72617453 	rsbvc	r7, r1, #1392508928	@ 0x53000000
    23ec:	74207374 	strtvc	r7, [r0], #-884	@ 0xfffffc8c
    23f0:	70206568 	eorvc	r6, r0, r8, ror #10
    23f4:	69726961 	ldmdbvs	r2!, {r0, r5, r6, r8, fp, sp, lr}^
    23f8:	7020676e 	eorvc	r6, r0, lr, ror #14
    23fc:	65636f72 	strbvs	r6, [r3, #-3954]!	@ 0xfffff08e
    2400:	77207373 			@ <UNDEFINED> instruction: 0x77207373
    2404:	20687469 	rsbcs	r7, r8, r9, ror #8
    2408:	61632061 	cmnvs	r3, r1, rrx
    240c:	00002e72 	andeq	r2, r0, r2, ror lr
    2410:	72636e45 	rsbvc	r6, r3, #1104	@ 0x450
    2414:	69747079 	ldmdbvs	r4!, {r0, r3, r4, r5, r6, ip, sp, lr}^
    2418:	2520676e 	strcs	r6, [r0, #-1902]!	@ 0xfffff892
    241c:	73752073 	cmnvc	r5, #115	@ 0x73
    2420:	20676e69 	rsbcs	r6, r7, r9, ror #28
    2424:	0a534541 	beq	14d3930 <__ROM_SIZE__+0x1493930>
    2428:	00000000 	andeq	r0, r0, r0
    242c:	72636e45 	rsbvc	r6, r3, #1104	@ 0x450
    2430:	65747079 	ldrbvs	r7, [r4, #-121]!	@ 0xffffff87
    2434:	73692064 	cmnvc	r9, #100	@ 0x64
    2438:	0a732520 	beq	1ccb8c0 <__ROM_SIZE__+0x1c8b8c0>
    243c:	00000000 	andeq	r0, r0, r0
    2440:	5f424f46 	svcpl	0x00424f46
    2444:	4753454d 	ldrbmi	r4, [r3, -sp, asr #10]
    2448:	53454120 	movtpl	r4, #20768	@ 0x5120
    244c:	20343642 	eorscs	r3, r4, r2, asr #12
    2450:	000a7325 	andeq	r7, sl, r5, lsr #6
    2454:	63696857 	cmnvs	r9, #5701632	@ 0x570000
    2458:	68732068 	ldmdavs	r3!, {r3, r5, r6, sp}^
    245c:	646c756f 	strbtvs	r7, [ip], #-1391	@ 0xfffffa91
    2460:	63656420 	cmnvs	r5, #32, 8	@ 0x20000000
    2464:	74707972 	ldrbtvc	r7, [r0], #-2418	@ 0xfffff68e
    2468:	206f7420 	rsbcs	r7, pc, r0, lsr #8
    246c:	0a207325 	beq	81f108 <__ROM_SIZE__+0x7df108>
    2470:	00000000 	andeq	r0, r0, r0
    2474:	33323130 	teqcc	r2, #48, 2
    2478:	37363534 			@ <UNDEFINED> instruction: 0x37363534
    247c:	62613938 	rsbvs	r3, r1, #56, 18	@ 0xe0000
    2480:	66656463 	strbtvs	r6, [r5], -r3, ror #8
    2484:	00000000 	andeq	r0, r0, r0
    2488:	00736561 	rsbseq	r6, r3, r1, ror #10
    248c:	72636e45 	rsbvc	r6, r3, #1104	@ 0x450
    2490:	73747079 	cmnvc	r4, #121	@ 0x79
    2494:	6d206120 	stfvss	f6, [r0, #-128]!	@ 0xffffff80
    2498:	61737365 	cmnvs	r3, r5, ror #6
    249c:	75206567 	strvc	r6, [r0, #-1383]!	@ 0xfffffa99
    24a0:	676e6973 			@ <UNDEFINED> instruction: 0x676e6973
    24a4:	53454120 	movtpl	r4, #20768	@ 0x5120
    24a8:	646e6120 	strbtvs	r6, [lr], #-288	@ 0xfffffee0
    24ac:	6e657320 	cdpvs	3, 6, cr7, cr5, cr0, {1}
    24b0:	69207364 	stmdbvs	r0!, {r2, r5, r6, r8, r9, ip, sp, lr}
    24b4:	6e6f2074 	mcrvs	0, 3, r2, cr15, cr4, {3}
    24b8:	52415520 	subpl	r5, r1, #32, 10	@ 0x8000000
    24bc:	00003254 	andeq	r3, r0, r4, asr r2
    24c0:	03020100 	movweq	r0, #8448	@ 0x2100
    24c4:	07060504 	streq	r0, [r6, -r4, lsl #10]
    24c8:	0b0a0908 	bleq	2848f0 <__ROM_SIZE__+0x2448f0>
    24cc:	0f0e0d0c 	svceq	0x000e0d0c
    24d0:	6f636e45 	svcvs	0x00636e45
    24d4:	20646564 	rsbcs	r6, r4, r4, ror #10
    24d8:	61207325 			@ <UNDEFINED> instruction: 0x61207325
    24dc:	73252073 			@ <UNDEFINED> instruction: 0x73252073
    24e0:	74697720 	strbtvc	r7, [r9], #-1824	@ 0xfffff8e0
    24e4:	64252068 	strtvs	r2, [r5], #-104	@ 0xffffff98
    24e8:	61686320 	cmnvs	r8, r0, lsr #6
    24ec:	74636172 	strbtvc	r6, [r3], #-370	@ 0xfffffe8e
    24f0:	0a737265 	beq	1cdee8c <__ROM_SIZE__+0x1c9ee8c>
    24f4:	00000000 	andeq	r0, r0, r0
    24f8:	69727453 	ldmdbvs	r2!, {r0, r1, r4, r6, sl, ip, sp, lr}^
    24fc:	6520676e 	strvs	r6, [r0, #-1902]!	@ 0xfffff892
    2500:	65656378 	strbvs	r6, [r5, #-888]!	@ 0xfffffc88
    2504:	6d207364 	stcvs	3, cr7, [r0, #-400]!	@ 0xfffffe70
    2508:	6c207861 	stcvs	8, cr7, [r0], #-388	@ 0xfffffe7c
    250c:	74676e65 	strbtvc	r6, [r7], #-3685	@ 0xfffff19b
    2510:	666f2068 	strbtvs	r2, [pc], -r8, rrx
    2514:	20642520 	rsbcs	r2, r4, r0, lsr #10
    2518:	72616863 	rsbvc	r6, r1, #6488064	@ 0x630000
    251c:	65746361 	ldrbvs	r6, [r4, #-865]!	@ 0xfffffc9f
    2520:	00007372 	andeq	r7, r0, r2, ror r3
    2524:	67617355 			@ <UNDEFINED> instruction: 0x67617355
    2528:	73692065 	cmnvc	r9, #101	@ 0x65
    252c:	6e652720 	cdpvs	7, 6, cr2, cr5, cr0, {1}
    2530:	65646f63 	strbvs	r6, [r4, #-3939]!	@ 0xfffff09d
    2534:	73203436 			@ <UNDEFINED> instruction: 0x73203436
    2538:	6e697274 	mcrvs	2, 3, r7, cr9, cr4, {3}
    253c:	000a2767 	andeq	r2, sl, r7, ror #14
    2540:	6f636e65 	svcvs	0x00636e65
    2544:	20646564 	rsbcs	r6, r4, r4, ror #10
    2548:	69727473 	ldmdbvs	r2!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
    254c:	6920676e 	stmdbvs	r0!, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}
    2550:	64252073 	strtvs	r2, [r5], #-115	@ 0xffffff8d
    2554:	61686320 	cmnvs	r8, r0, lsr #6
    2558:	74636172 	strbtvc	r6, [r3], #-370	@ 0xfffffe8e
    255c:	0a737265 	beq	1cdeef8 <__ROM_SIZE__+0x1c9eef8>
    2560:	00000000 	andeq	r0, r0, r0
    2564:	6f636564 	svcvs	0x00636564
    2568:	20646564 	rsbcs	r6, r4, r4, ror #10
    256c:	69727473 	ldmdbvs	r2!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
    2570:	6920676e 	stmdbvs	r0!, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}
    2574:	64252073 	strtvs	r2, [r5], #-115	@ 0xffffff8d
    2578:	61686320 	cmnvs	r8, r0, lsr #6
    257c:	74636172 	strbtvc	r6, [r3], #-370	@ 0xfffffe8e
    2580:	0a737265 	beq	1cdef1c <__ROM_SIZE__+0x1c9ef1c>
    2584:	00000000 	andeq	r0, r0, r0
    2588:	69646441 	stmdbvs	r4!, {r0, r6, sl, sp, lr}^
    258c:	4e20676e 	cdpmi	7, 2, cr6, cr0, cr14, {3}
    2590:	204c4c55 	subcs	r4, ip, r5, asr ip
    2594:	74207461 	strtvc	r7, [r0], #-1121	@ 0xfffffb9f
    2598:	65206568 	strvs	r6, [r0, #-1384]!	@ 0xfffffa98
    259c:	6f20646e 	svcvs	0x0020646e
    25a0:	65642066 	strbvs	r2, [r4, #-102]!	@ 0xffffff9a
    25a4:	65646f63 	strbvs	r6, [r4, #-3939]!	@ 0xfffff09d
    25a8:	74732064 	ldrbtvc	r2, [r3], #-100	@ 0xffffff9c
    25ac:	676e6972 			@ <UNDEFINED> instruction: 0x676e6972
    25b0:	0000000a 	andeq	r0, r0, sl
    25b4:	6f636544 	svcvs	0x00636544
    25b8:	20646564 	rsbcs	r6, r4, r4, ror #10
    25bc:	61207325 			@ <UNDEFINED> instruction: 0x61207325
    25c0:	25203a73 	strcs	r3, [r0, #-2675]!	@ 0xfffff58d
    25c4:	00000a73 	andeq	r0, r0, r3, ror sl
    25c8:	67617355 			@ <UNDEFINED> instruction: 0x67617355
    25cc:	73692065 	cmnvc	r9, #101	@ 0x65
    25d0:	65642720 	strbvs	r2, [r4, #-1824]!	@ 0xfffff8e0
    25d4:	65646f63 	strbvs	r6, [r4, #-3939]!	@ 0xfffff09d
    25d8:	73203436 			@ <UNDEFINED> instruction: 0x73203436
    25dc:	6e697274 	mcrvs	2, 3, r7, cr9, cr4, {3}
    25e0:	000a2767 	andeq	r2, sl, r7, ror #14
    25e4:	6f636564 	svcvs	0x00636564
    25e8:	34366564 	ldrtcc	r6, [r6], #-1380	@ 0xfffffa9c
    25ec:	00000000 	andeq	r0, r0, r0
    25f0:	65736142 	ldrbvs	r6, [r3, #-322]!	@ 0xfffffebe
    25f4:	64203436 	strtvs	r3, [r0], #-1078	@ 0xfffffbca
    25f8:	646f6365 	strbtvs	r6, [pc], #-869	@ 2600 <cmd_end_+0x2e4>
    25fc:	61207365 			@ <UNDEFINED> instruction: 0x61207365
    2600:	72747320 	rsbsvc	r7, r4, #32, 6	@ 0x80000000
    2604:	20676e69 	rsbcs	r6, r7, r9, ror #28
    2608:	20646e61 	rsbcs	r6, r4, r1, ror #28
    260c:	646e6573 	strbtvs	r6, [lr], #-1395	@ 0xfffffa8d
    2610:	74692073 	strbtvc	r2, [r9], #-115	@ 0xffffff8d
    2614:	206e6f20 	rsbcs	r6, lr, r0, lsr #30
    2618:	54524155 	ldrbpl	r4, [r2], #-341	@ 0xfffffeab
    261c:	00000032 	andeq	r0, r0, r2, lsr r0
    2620:	6f636e65 	svcvs	0x00636e65
    2624:	34366564 	ldrtcc	r6, [r6], #-1380	@ 0xfffffa9c
    2628:	00000000 	andeq	r0, r0, r0
    262c:	65736142 	ldrbvs	r6, [r3, #-322]!	@ 0xfffffebe
    2630:	65203436 	strvs	r3, [r0, #-1078]!	@ 0xfffffbca
    2634:	646f636e 	strbtvs	r6, [pc], #-878	@ 263c <cmd_end_+0x320>
    2638:	61207365 			@ <UNDEFINED> instruction: 0x61207365
    263c:	72747320 	rsbsvc	r7, r4, #32, 6	@ 0x80000000
    2640:	20676e69 	rsbcs	r6, r7, r9, ror #28
    2644:	20646e61 	rsbcs	r6, r4, r1, ror #28
    2648:	646e6573 	strbtvs	r6, [lr], #-1395	@ 0xfffffa8d
    264c:	74692073 	strbtvc	r2, [r9], #-115	@ 0xffffff8d
    2650:	206e6f20 	rsbcs	r6, lr, r0, lsr #30
    2654:	54524155 	ldrbpl	r4, [r2], #-341	@ 0xfffffeab
    2658:	00000032 	andeq	r0, r0, r2, lsr r0
    265c:	676e6950 			@ <UNDEFINED> instruction: 0x676e6950
    2660:	20676e69 	rsbcs	r6, r7, r9, ror #28
    2664:	20656874 	rsbcs	r6, r5, r4, ror r8
    2668:	2e726163 	rpwcssz	f6, f2, f3
    266c:	0000000a 	andeq	r0, r0, sl
    2670:	5f424f46 	svcpl	0x00424f46
    2674:	4753454d 	ldrbmi	r4, [r3, -sp, asr #10]
    2678:	4e495020 	cdpmi	0, 4, cr5, cr9, cr0, {1}
    267c:	00000a47 	andeq	r0, r0, r7, asr #20
    2680:	676e6970 			@ <UNDEFINED> instruction: 0x676e6970
    2684:	00000000 	andeq	r0, r0, r0
    2688:	676e6950 			@ <UNDEFINED> instruction: 0x676e6950
    268c:	68742073 	ldmdavs	r4!, {r0, r1, r4, r5, r6, sp}^
    2690:	746f2065 	strbtvc	r2, [pc], #-101	@ 2698 <cmd_end_+0x37c>
    2694:	20726568 	rsbscs	r6, r2, r8, ror #10
    2698:	72616f62 	rsbvc	r6, r1, #392	@ 0x188
    269c:	00000064 	andeq	r0, r0, r4, rrx
    26a0:	000a7325 	andeq	r7, sl, r5, lsr #6
    26a4:	000a6425 	andeq	r6, sl, r5, lsr #8
    26a8:	6c697542 	cfstr64vs	mvdx7, [r9], #-264	@ 0xfffffef8
    26ac:	5b203a64 	blpl	811044 <__ROM_SIZE__+0x7d1044>
    26b0:	62343939 	eorsvs	r3, r4, #933888	@ 0xe4000
    26b4:	3a306136 	bcc	c1ab94 <__ROM_SIZE__+0xbdab94>
    26b8:	62343939 	eorsvs	r3, r4, #933888	@ 0xe4000
    26bc:	5d306136 	ldfpls	f6, [r0, #-216]!	@ 0xffffff28
    26c0:	5b202d20 	blpl	80db48 <__ROM_SIZE__+0x7cdb48>
    26c4:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    26c8:	49485240 	stmdbmi	r8, {r6, r9, ip, lr}^
    26cc:	39522d54 	ldmdbcc	r2, {r2, r4, r6, r8, sl, fp, sp}^
    26d0:	325a5830 	subscc	r5, sl, #48, 16	@ 0x300000
    26d4:	205d4450 	subscs	r4, sp, r0, asr r4
    26d8:	7041202d 	subvc	r2, r1, sp, lsr #32
    26dc:	31322072 	teqcc	r2, r2, ror r0
    26e0:	32303220 	eorscc	r3, r0, #32, 4
    26e4:	202d2033 	eorcs	r2, sp, r3, lsr r0
    26e8:	323a3331 	eorscc	r3, sl, #-1006632960	@ 0xc4000000
    26ec:	30313a37 	eorscc	r3, r1, r7, lsr sl
    26f0:	0000000a 	andeq	r0, r0, sl
    26f4:	22732522 	rsbscs	r2, r3, #142606336	@ 0x8800000
    26f8:	6f63203a 	svcvs	0x0063203a
    26fc:	6e616d6d 	cdpvs	13, 6, cr6, cr1, cr13, {3}
    2700:	6f6e2064 	svcvs	0x006e2064
    2704:	6f662074 	svcvs	0x00662074
    2708:	2e646e75 	mcrcs	14, 3, r6, cr4, cr5, {3}
    270c:	65735520 	ldrbvs	r5, [r3, #-1312]!	@ 0xfffffae0
    2710:	65682220 	strbvs	r2, [r8, #-544]!	@ 0xfffffde0
    2714:	2022706c 	eorcs	r7, r2, ip, rrx
    2718:	6c206f74 	stcvs	15, cr6, [r0], #-464	@ 0xfffffe30
    271c:	20747369 	rsbscs	r7, r4, r9, ror #6
    2720:	206c6c61 	rsbcs	r6, ip, r1, ror #24
    2724:	6d6d6f63 	stclvs	15, cr6, [sp, #-396]!	@ 0xfffffe74
    2728:	2e646e61 	cdpcs	14, 6, cr6, cr4, cr1, {3}
    272c:	0000000a 	andeq	r0, r0, sl
    2730:	00006c2d 	andeq	r6, r0, sp, lsr #24
    2734:	3a657375 	bcc	195f510 <__ROM_SIZE__+0x191f510>
    2738:	6c656820 	stclvs	8, cr6, [r5], #-128	@ 0xffffff80
    273c:	6c2d2070 	stcvs	0, cr2, [sp], #-448	@ 0xfffffe40
    2740:	726f6620 	rsbvc	r6, pc, #32, 12	@ 0x2000000
    2744:	73696c20 	cmnvc	r9, #32, 24	@ 0x2000
    2748:	6e6f2074 	mcrvs	0, 3, r2, cr15, cr4, {3}
    274c:	0a2e796c 	beq	ba0d04 <__ROM_SIZE__+0xb60d04>
    2750:	0000000a 	andeq	r0, r0, sl
    2754:	0000090a 	andeq	r0, r0, sl, lsl #18
    2758:	0000000a 	andeq	r0, r0, sl
    275c:	00000000 	andeq	r0, r0, r0
    2760:	00007325 	andeq	r7, r0, r5, lsr #6
    2764:	0073250a 	rsbseq	r2, r3, sl, lsl #10
    2768:	00002023 	andeq	r2, r0, r3, lsr #32
    276c:	74617473 	strbtvc	r7, [r1], #-1139	@ 0xfffffb8d
    2770:	00007375 	andeq	r7, r0, r5, ror r3
    2774:	75746552 	ldrbvc	r6, [r4, #-1362]!	@ 0xfffffaae
    2778:	20736e72 	rsbscs	r6, r3, r2, ror lr
    277c:	74697865 	strbtvc	r7, [r9], #-2149	@ 0xfffff79b
    2780:	61747320 	cmnvs	r4, r0, lsr #6
    2784:	20737574 	rsbscs	r7, r3, r4, ror r5
    2788:	6c20666f 	stcvs	6, cr6, [r0], #-444	@ 0xfffffe44
    278c:	20747361 	rsbscs	r7, r4, r1, ror #6
    2790:	63657865 	cmnvs	r5, #6619136	@ 0x650000
    2794:	64657475 	strbtvs	r7, [r5], #-1141	@ 0xfffffb8b
    2798:	6d6f6320 	stclvs	3, cr6, [pc, #-128]!	@ 2720 <cmd_end_+0x404>
    279c:	646e616d 	strbtvs	r6, [lr], #-365	@ 0xfffffe93
    27a0:	00000000 	andeq	r0, r0, r0
    27a4:	706c6568 	rsbvc	r6, ip, r8, ror #10
    27a8:	00000000 	andeq	r0, r0, r0
    27ac:	6e697250 	mcrvs	2, 3, r7, cr9, cr0, {2}
    27b0:	61207374 			@ <UNDEFINED> instruction: 0x61207374
    27b4:	61206c6c 			@ <UNDEFINED> instruction: 0x61206c6c
    27b8:	6c696176 	stfvse	f6, [r9], #-472	@ 0xfffffe28
    27bc:	656c6261 	strbvs	r6, [ip, #-609]!	@ 0xfffffd9f
    27c0:	6d6f6320 	stclvs	3, cr6, [pc, #-128]!	@ 2748 <cmd_end_+0x42c>
    27c4:	646e616d 	strbtvs	r6, [lr], #-365	@ 0xfffffe93
    27c8:	00000073 	andeq	r0, r0, r3, ror r0
    27cc:	73726576 	cmnvc	r2, #494927872	@ 0x1d800000
    27d0:	006e6f69 	rsbeq	r6, lr, r9, ror #30
    27d4:	6e697250 	mcrvs	2, 3, r7, cr9, cr0, {2}
    27d8:	64207374 	strtvs	r7, [r0], #-884	@ 0xfffffc8c
    27dc:	69617465 	stmdbvs	r1!, {r0, r2, r5, r6, sl, ip, sp, lr}^
    27e0:	6f20736c 	svcvs	0x0020736c
    27e4:	68742066 	ldmdavs	r4!, {r1, r2, r5, r6, sp}^
    27e8:	75622065 	strbvc	r2, [r2, #-101]!	@ 0xffffff9b
    27ec:	00646c69 	rsbeq	r6, r4, r9, ror #24
    27f0:	74736968 	ldrbtvc	r6, [r3], #-2408	@ 0xfffff698
    27f4:	0079726f 	rsbseq	r7, r9, pc, ror #4
    27f8:	776f6853 			@ <UNDEFINED> instruction: 0x776f6853
    27fc:	6d6f6320 	stclvs	3, cr6, [pc, #-128]!	@ 2784 <cmd_end_+0x468>
    2800:	646e616d 	strbtvs	r6, [lr], #-365	@ 0xfffffe93
    2804:	73696820 	cmnvc	r9, #32, 16	@ 0x200000
    2808:	79726f74 	ldmdbvc	r2!, {r2, r4, r5, r6, r8, r9, sl, fp, sp, lr}^
    280c:	00000000 	andeq	r0, r0, r0
    2810:	6972700a 	ldmdbvs	r2!, {r1, r3, ip, sp, lr}^
    2814:	2d66746e 	cfstrdcs	mvd7, [r6, #-440]!	@ 0xfffffe48
    2818:	6f727265 	svcvs	0x00727265
    281c:	00000a72 	andeq	r0, r0, r2, ror sl

00002820 <hextable>:
static char hextable[] = {'0', '1', '2', '3', '4', '5', '6', '7',
    2820:	33323130 	teqcc	r2, #48, 2
    2824:	37363534 			@ <UNDEFINED> instruction: 0x37363534
    2828:	42413938 	submi	r3, r1, #56, 18	@ 0xe0000
    282c:	46454443 	strbmi	r4, [r5], -r3, asr #8
    2830:	6972700a 	ldmdbvs	r2!, {r1, r3, ip, sp, lr}^
    2834:	3266746e 	rsbcc	r7, r6, #1845493760	@ 0x6e000000
    2838:	7272652d 	rsbsvc	r6, r2, #188743680	@ 0xb400000
    283c:	000a726f 	andeq	r7, sl, pc, ror #4

00002840 <hextable2>:
static char hextable2[] = {'0', '1', '2', '3', '4', '5', '6', '7',
    2840:	33323130 	teqcc	r2, #48, 2
    2844:	37363534 			@ <UNDEFINED> instruction: 0x37363534
    2848:	42413938 	submi	r3, r1, #56, 18	@ 0xe0000
    284c:	46454443 	strbmi	r4, [r5], -r3, asr #8
    2850:	67617355 			@ <UNDEFINED> instruction: 0x67617355
    2854:	25203a65 	strcs	r3, [r0, #-2661]!	@ 0xfffff59b
    2858:	613c2073 	teqvs	ip, r3, ror r0
    285c:	65726464 	ldrbvs	r6, [r2, #-1124]!	@ 0xfffffb9c
    2860:	203e7373 	eorscs	r7, lr, r3, ror r3
    2864:	206e6928 	rsbcs	r6, lr, r8, lsr #18
    2868:	29786568 	ldmdbcs	r8!, {r3, r5, r6, r8, sl, sp, lr}^
    286c:	0000000a 	andeq	r0, r0, sl
    2870:	78257830 	stmdavc	r5!, {r4, r5, fp, ip, sp, lr}
    2874:	7830203a 	ldmdavc	r0!, {r1, r3, r4, r5, sp}
    2878:	000a7825 	andeq	r7, sl, r5, lsr #16
    287c:	67617355 			@ <UNDEFINED> instruction: 0x67617355
    2880:	25203a65 	strcs	r3, [r0, #-2661]!	@ 0xfffff59b
    2884:	613c2073 	teqvs	ip, r3, ror r0
    2888:	65726464 	ldrbvs	r6, [r2, #-1124]!	@ 0xfffffb9c
    288c:	203e7373 	eorscs	r7, lr, r3, ror r3
    2890:	206e6928 	rsbcs	r6, lr, r8, lsr #18
    2894:	29786568 	ldmdbcs	r8!, {r3, r5, r6, r8, sl, sp, lr}^
    2898:	61763c20 	cmnvs	r6, r0, lsr #24
    289c:	3e65756c 	cdpcc	5, 6, cr7, cr5, cr12, {3}
    28a0:	6e692820 	cdpvs	8, 6, cr2, cr9, cr0, {1}
    28a4:	78656820 	stmdavc	r5!, {r5, fp, sp, lr}^
    28a8:	00000a29 	andeq	r0, r0, r9, lsr #20
    28ac:	67617355 			@ <UNDEFINED> instruction: 0x67617355
    28b0:	25203a65 	strcs	r3, [r0, #-2661]!	@ 0xfffff59b
    28b4:	613c2073 	teqvs	ip, r3, ror r0
    28b8:	65726464 	ldrbvs	r6, [r2, #-1124]!	@ 0xfffffb9c
    28bc:	203e7373 	eorscs	r7, lr, r3, ror r3
    28c0:	206e6928 	rsbcs	r6, lr, r8, lsr #18
    28c4:	29786568 	ldmdbcs	r8!, {r3, r5, r6, r8, sl, sp, lr}^
    28c8:	756e3c20 	strbvc	r3, [lr, #-3104]!	@ 0xfffff3e0
    28cc:	6f775f6d 	svcvs	0x00775f6d
    28d0:	3e736472 	mrccc	4, 3, r6, cr3, cr2, {3}
    28d4:	6e692820 	cdpvs	8, 6, cr2, cr9, cr0, {1}
    28d8:	63656420 	cmnvs	r5, #32, 8	@ 0x20000000
    28dc:	6c616d69 	stclvs	13, cr6, [r1], #-420	@ 0xfffffe5c
    28e0:	00000a29 	andeq	r0, r0, r9, lsr #20
    28e4:	6f727245 	svcvs	0x00727245
    28e8:	49203a72 	stmdbmi	r0!, {r1, r4, r5, r6, r9, fp, ip, sp}
    28ec:	6c61766e 	stclvs	6, cr7, [r1], #-440	@ 0xfffffe48
    28f0:	62206469 	eorvs	r6, r0, #1761607680	@ 0x69000000
    28f4:	6c207469 	cfstrsvs	mvf7, [r0], #-420	@ 0xfffffe5c
    28f8:	7461636f 	strbtvc	r6, [r1], #-879	@ 0xfffffc91
    28fc:	206e6f69 	rsbcs	r6, lr, r9, ror #30
    2900:	75677261 	strbvc	r7, [r7, #-609]!	@ 0xfffffd9f
    2904:	746e656d 	strbtvc	r6, [lr], #-1389	@ 0xfffffa93
    2908:	0000000a 	andeq	r0, r0, sl
    290c:	6f727245 	svcvs	0x00727245
    2910:	49203a72 	stmdbmi	r0!, {r1, r4, r5, r6, r9, fp, ip, sp}
    2914:	6c61766e 	stclvs	6, cr7, [r1], #-440	@ 0xfffffe48
    2918:	62206469 	eorvs	r6, r0, #1761607680	@ 0x69000000
    291c:	76207469 	strtvc	r7, [r0], -r9, ror #8
    2920:	65756c61 	ldrbvs	r6, [r5, #-3169]!	@ 0xfffff39f
    2924:	67726120 	ldrbvs	r6, [r2, -r0, lsr #2]!
    2928:	6e656d75 	mcrvs	13, 3, r6, cr5, cr5, {3}
    292c:	00000a74 	andeq	r0, r0, r4, ror sl
    2930:	67617355 			@ <UNDEFINED> instruction: 0x67617355
    2934:	25203a65 	strcs	r3, [r0, #-2661]!	@ 0xfffff59b
    2938:	613c2073 	teqvs	ip, r3, ror r0
    293c:	65726464 	ldrbvs	r6, [r2, #-1124]!	@ 0xfffffb9c
    2940:	695f7373 	ldmdbvs	pc, {r0, r1, r4, r5, r6, r8, r9, ip, sp, lr}^	@ <UNPREDICTABLE>
    2944:	65685f6e 	strbvs	r5, [r8, #-3950]!	@ 0xfffff092
    2948:	32332878 	eorscc	r2, r3, #120, 16	@ 0x780000
    294c:	7469622d 	strbtvc	r6, [r9], #-557	@ 0xfffffdd3
    2950:	203e2973 	eorscs	r2, lr, r3, ror r9
    2954:	7469623c 	strbtvc	r6, [r9], #-572	@ 0xfffffdc4
    2958:	636f6c5f 	cmnvs	pc, #24320	@ 0x5f00
    295c:	6f697461 	svcvs	0x00697461
    2960:	6e695f6e 	cdpvs	15, 6, cr5, cr9, cr14, {3}
    2964:	6365645f 	cmnvs	r5, #1593835520	@ 0x5f000000
    2968:	6c616d69 	stclvs	13, cr6, [r1], #-420	@ 0xfffffe5c
    296c:	74203028 	strtvc	r3, [r0], #-40	@ 0xffffffd8
    2970:	3133206f 	teqcc	r3, pc, rrx
    2974:	3c203e29 	stccc	14, cr3, [r0], #-164	@ 0xffffff5c
    2978:	5f746962 	svcpl	0x00746962
    297c:	756c6176 	strbvc	r6, [ip, #-374]!	@ 0xfffffe8a
    2980:	20302865 	eorscs	r2, r0, r5, ror #16
    2984:	3120726f 			@ <UNDEFINED> instruction: 0x3120726f
    2988:	000a3e29 	andeq	r3, sl, r9, lsr #28
    298c:	20746942 	rsbscs	r6, r4, r2, asr #18
    2990:	40207525 	eormi	r7, r0, r5, lsr #10
    2994:	25783020 	ldrbcs	r3, [r8, #-32]!	@ 0xffffffe0
    2998:	3a783830 	bcc	1e10a60 <__ROM_SIZE__+0x1dd0a60>
    299c:	0a752520 	beq	1d4be24 <__ROM_SIZE__+0x1d0be24>
    29a0:	00000000 	andeq	r0, r0, r0
    29a4:	67617355 			@ <UNDEFINED> instruction: 0x67617355
    29a8:	25203a65 	strcs	r3, [r0, #-2661]!	@ 0xfffff59b
    29ac:	613c2073 	teqvs	ip, r3, ror r0
    29b0:	65726464 	ldrbvs	r6, [r2, #-1124]!	@ 0xfffffb9c
    29b4:	695f7373 	ldmdbvs	pc, {r0, r1, r4, r5, r6, r8, r9, ip, sp, lr}^	@ <UNPREDICTABLE>
    29b8:	65685f6e 	strbvs	r5, [r8, #-3950]!	@ 0xfffff092
    29bc:	32332878 	eorscc	r2, r3, #120, 16	@ 0x780000
    29c0:	7469622d 	strbtvc	r6, [r9], #-557	@ 0xfffffdd3
    29c4:	203e2973 	eorscs	r2, lr, r3, ror r9
    29c8:	7469623c 	strbtvc	r6, [r9], #-572	@ 0xfffffdc4
    29cc:	636f6c5f 	cmnvs	pc, #24320	@ 0x5f00
    29d0:	6f697461 	svcvs	0x00697461
    29d4:	6e695f6e 	cdpvs	15, 6, cr5, cr9, cr14, {3}
    29d8:	6365645f 	cmnvs	r5, #1593835520	@ 0x5f000000
    29dc:	6c616d69 	stclvs	13, cr6, [r1], #-420	@ 0xfffffe5c
    29e0:	74203028 	strtvc	r3, [r0], #-40	@ 0xffffffd8
    29e4:	3133206f 	teqcc	r3, pc, rrx
    29e8:	00000a29 	andeq	r0, r0, r9, lsr #20
    29ec:	64616572 	strbtvs	r6, [r1], #-1394	@ 0xfffffa8e
    29f0:	00000000 	andeq	r0, r0, r0
    29f4:	64616552 	strbtvs	r6, [r1], #-1362	@ 0xfffffaae
    29f8:	756e2073 	strbvc	r2, [lr, #-115]!	@ 0xffffff8d
    29fc:	7265626d 	rsbvc	r6, r5, #-805306362	@ 0xd0000006
    2a00:	20666f20 	rsbcs	r6, r6, r0, lsr #30
    2a04:	65747962 	ldrbvs	r7, [r4, #-2402]!	@ 0xfffff69e
    2a08:	72662073 	rsbvc	r2, r6, #115	@ 0x73
    2a0c:	6d206d6f 	stcvs	13, cr6, [r0, #-444]!	@ 0xfffffe44
    2a10:	726f6d65 	rsbvc	r6, pc, #6464	@ 0x1940
    2a14:	00000079 	andeq	r0, r0, r9, ror r0
    2a18:	00323377 	eorseq	r3, r2, r7, ror r3
    2a1c:	74697277 	strbtvc	r7, [r9], #-631	@ 0xfffffd89
    2a20:	61207365 			@ <UNDEFINED> instruction: 0x61207365
    2a24:	20323320 	eorscs	r3, r2, r0, lsr #6
    2a28:	20746962 	rsbscs	r6, r4, r2, ror #18
    2a2c:	756c6176 	strbvc	r6, [ip, #-374]!	@ 0xfffffe8a
    2a30:	6f742065 	svcvs	0x00742065
    2a34:	6d206120 	stfvss	f6, [r0, #-128]!	@ 0xffffff80
    2a38:	726f6d65 	rsbvc	r6, pc, #6464	@ 0x1940
    2a3c:	6f6c2079 	svcvs	0x006c2079
    2a40:	69746163 	ldmdbvs	r4!, {r0, r1, r5, r6, r8, sp, lr}^
    2a44:	00006e6f 	andeq	r6, r0, pc, ror #28
    2a48:	00323372 	eorseq	r3, r2, r2, ror r3
    2a4c:	64616572 	strbtvs	r6, [r1], #-1394	@ 0xfffffa8e
    2a50:	20612073 	rsbcs	r2, r1, r3, ror r0
    2a54:	62203233 	eorvs	r3, r0, #805306371	@ 0x30000003
    2a58:	6d207469 	cfstrsvs	mvf7, [r0, #-420]!	@ 0xfffffe5c
    2a5c:	726f6d65 	rsbvc	r6, pc, #6464	@ 0x1940
    2a60:	6f6c2079 	svcvs	0x006c2079
    2a64:	69746163 	ldmdbvs	r4!, {r0, r1, r5, r6, r8, sp, lr}^
    2a68:	00006e6f 	andeq	r6, r0, pc, ror #28
    2a6c:	00006272 	andeq	r6, r0, r2, ror r2
    2a70:	64616572 	strbtvs	r6, [r1], #-1394	@ 0xfffffa8e
    2a74:	20612073 	rsbcs	r2, r1, r3, ror r0
    2a78:	20746962 	rsbscs	r6, r4, r2, ror #18
    2a7c:	6d6f7266 	sfmvs	f7, 2, [pc, #-408]!	@ 28ec <hextable2+0xac>
    2a80:	6d656d20 	stclvs	13, cr6, [r5, #-128]!	@ 0xffffff80
    2a84:	2079726f 	rsbscs	r7, r9, pc, ror #4
    2a88:	61636f6c 	cmnvs	r3, ip, ror #30
    2a8c:	6e6f6974 			@ <UNDEFINED> instruction: 0x6e6f6974
    2a90:	00000000 	andeq	r0, r0, r0
    2a94:	00006277 	andeq	r6, r0, r7, ror r2
    2a98:	74697277 	strbtvc	r7, [r9], #-631	@ 0xfffffd89
    2a9c:	20612065 	rsbcs	r2, r1, r5, rrx
    2aa0:	20746962 	rsbscs	r6, r4, r2, ror #18
    2aa4:	6d206f74 	stcvs	15, cr6, [r0, #-464]!	@ 0xfffffe30
    2aa8:	726f6d65 	rsbvc	r6, pc, #6464	@ 0x1940
    2aac:	6f6c2079 	svcvs	0x006c2079
    2ab0:	69746163 	ldmdbvs	r4!, {r0, r1, r5, r6, r8, sp, lr}^
    2ab4:	00006e6f 	andeq	r6, r0, pc, ror #28

00002ab8 <sbox>:
static const uint8_t sbox[256] = {
    2ab8:	7b777c63 	blvc	1de1c4c <__ROM_SIZE__+0x1da1c4c>
    2abc:	c56f6bf2 	strbgt	r6, [pc, #-3058]!	@ 1ed2 <gf2point_add+0x10>
    2ac0:	2b670130 	blcs	19c2f88 <__ROM_SIZE__+0x1982f88>
    2ac4:	76abd7fe 			@ <UNDEFINED> instruction: 0x76abd7fe
    2ac8:	7dc982ca 	sfmvc	f0, 3, [r9, #808]	@ 0x328
    2acc:	f04759fa 			@ <UNDEFINED> instruction: 0xf04759fa
    2ad0:	afa2d4ad 	svcge	0x00a2d4ad
    2ad4:	c072a49c 			@ <UNDEFINED> instruction: 0xc072a49c
    2ad8:	2693fdb7 			@ <UNDEFINED> instruction: 0x2693fdb7
    2adc:	ccf73f36 	ldclgt	15, cr3, [r7], #216	@ 0xd8
    2ae0:	f1e5a534 			@ <UNDEFINED> instruction: 0xf1e5a534
    2ae4:	1531d871 	ldrne	sp, [r1, #-2161]!	@ 0xfffff78f
    2ae8:	c323c704 			@ <UNDEFINED> instruction: 0xc323c704
    2aec:	9a059618 	bls	168354 <__ROM_SIZE__+0x128354>
    2af0:	e2801207 	add	r1, r0, #1879048192	@ 0x70000000
    2af4:	75b227eb 	ldrvc	r2, [r2, #2027]!	@ 0x7eb
    2af8:	1a2c8309 	bne	b23724 <__ROM_SIZE__+0xae3724>
    2afc:	a05a6e1b 	subsge	r6, sl, fp, lsl lr
    2b00:	b3d63b52 	bicslt	r3, r6, #83968	@ 0x14800
    2b04:	842fe329 	strthi	lr, [pc], #-809	@ 2b0c <sbox+0x54>
    2b08:	ed00d153 	stfd	f5, [r0, #-332]	@ 0xfffffeb4
    2b0c:	5bb1fc20 	blpl	fec81b94 <_STACK_TOP_+0xdec79b98>
    2b10:	39becb6a 	ldmibcc	lr!, {r1, r3, r5, r6, r8, r9, fp, lr, pc}
    2b14:	cf584c4a 	svcgt	0x00584c4a
    2b18:	fbaaefd0 	blx	feabea62 <_STACK_TOP_+0xdeab6a66>
    2b1c:	85334d43 	ldrhi	r4, [r3, #-3395]!	@ 0xfffff2bd
    2b20:	7f02f945 	svcvc	0x0002f945
    2b24:	a89f3c50 	ldmge	pc, {r4, r6, sl, fp, ip, sp}	@ <UNPREDICTABLE>
    2b28:	8f40a351 	svchi	0x0040a351
    2b2c:	f5389d92 			@ <UNDEFINED> instruction: 0xf5389d92
    2b30:	21dab6bc 	ldrhcs	fp, [sl, #108]	@ 0x6c
    2b34:	d2f3ff10 	rscsle	pc, r3, #16, 30	@ 0x40
    2b38:	ec130ccd 	ldc	12, cr0, [r3], {205}	@ 0xcd
    2b3c:	1744975f 	smlsldne	r9, r4, pc, r7	@ <UNPREDICTABLE>
    2b40:	3d7ea7c4 	ldclcc	7, cr10, [lr, #-784]!	@ 0xfffffcf0
    2b44:	73195d64 	tstvc	r9, #100, 26	@ 0x1900
    2b48:	dc4f8160 	stflep	f0, [pc], {96}	@ 0x60
    2b4c:	88902a22 	ldmhi	r0, {r1, r5, r9, fp, sp}
    2b50:	14b8ee46 	ldrtne	lr, [r8], #3654	@ 0xe46
    2b54:	db0b5ede 	blle	2da6d4 <__ROM_SIZE__+0x29a6d4>
    2b58:	0a3a32e0 	beq	e8f6e0 <__ROM_SIZE__+0xe4f6e0>
    2b5c:	5c240649 	stcpl	6, cr0, [r4], #-292	@ 0xfffffedc
    2b60:	62acd3c2 	adcvs	sp, ip, #134217731	@ 0x8000003
    2b64:	79e49591 	stmibvc	r4!, {r0, r4, r7, r8, sl, ip, pc}^
    2b68:	6d37c8e7 	ldcvs	8, cr12, [r7, #-924]!	@ 0xfffffc64
    2b6c:	a94ed58d 	stmdbge	lr, {r0, r2, r3, r7, r8, sl, ip, lr, pc}^
    2b70:	eaf4566c 	b	ffd18528 <_STACK_TOP_+0xdfd1052c>
    2b74:	08ae7a65 	stmiaeq	lr!, {r0, r2, r5, r6, r9, fp, ip, sp, lr}
    2b78:	2e2578ba 	mcrcs	8, 1, r7, cr5, cr10, {5}
    2b7c:	c6b4a61c 	ssatgt	sl, #21, ip, lsl #12
    2b80:	1f74dde8 	svcne	0x0074dde8
    2b84:	8a8bbd4b 	bhi	fe2f20b8 <_STACK_TOP_+0xde2ea0bc>
    2b88:	66b53e70 			@ <UNDEFINED> instruction: 0x66b53e70
    2b8c:	0ef60348 	cdpeq	3, 15, cr0, cr6, cr8, {2}
    2b90:	b9573561 	ldmdblt	r7, {r0, r5, r6, r8, sl, ip, sp}^
    2b94:	9e1dc186 	mnfls<illegal precision>	f4, f6
    2b98:	1198f8e1 	orrsne	pc, r8, r1, ror #17
    2b9c:	948ed969 	strls	sp, [lr], #2409	@ 0x969
    2ba0:	e9871e9b 	stmib	r7, {r0, r1, r3, r4, r7, r9, sl, fp, ip}
    2ba4:	df2855ce 	svcle	0x002855ce
    2ba8:	0d89a18c 	stfeqd	f2, [r9, #560]	@ 0x230
    2bac:	6842e6bf 	stmdavs	r2, {r0, r1, r2, r3, r4, r5, r7, r9, sl, sp, lr, pc}^
    2bb0:	0f2d9941 	svceq	0x002d9941
    2bb4:	16bb54b0 			@ <UNDEFINED> instruction: 0x16bb54b0

00002bb8 <Rcon>:
static const uint8_t Rcon[11] = {
    2bb8:	0402018d 	streq	r0, [r2], #-397	@ 0xfffffe73
    2bbc:	40201008 	eormi	r1, r0, r8
    2bc0:	00361b80 	eorseq	r1, r6, r0, lsl #23

00002bc4 <rsbox>:
static const uint8_t rsbox[256] = {
    2bc4:	d56a0952 	strble	r0, [sl, #-2386]!	@ 0xfffff6ae
    2bc8:	38a53630 	stmiacc	r5!, {r4, r5, r9, sl, ip, sp}
    2bcc:	9ea340bf 	mcrls	0, 5, r4, cr3, cr15, {5}
    2bd0:	fbd7f381 	blx	ff5ff9de <_STACK_TOP_+0xdf5f79e2>
    2bd4:	8239e37c 	eorshi	lr, r9, #124, 6	@ 0xf0000001
    2bd8:	87ff2f9b 			@ <UNDEFINED> instruction: 0x87ff2f9b
    2bdc:	44438e34 	strbmi	r8, [r3], #-3636	@ 0xfffff1cc
    2be0:	cbe9dec4 	blgt	ffa7a6f8 <_STACK_TOP_+0xdfa726fc>
    2be4:	32947b54 	addscc	r7, r4, #84, 22	@ 0x15000
    2be8:	3d23c2a6 	sfmcc	f4, 1, [r3, #-664]!	@ 0xfffffd68
    2bec:	0b954cee 	bleq	fe555fac <_STACK_TOP_+0xde54dfb0>
    2bf0:	4ec3fa42 			@ <UNDEFINED> instruction: 0x4ec3fa42
    2bf4:	66a12e08 	strtvs	r2, [r1], r8, lsl #28
    2bf8:	b224d928 	eorlt	sp, r4, #40, 18	@ 0xa0000
    2bfc:	49a25b76 	stmibmi	r2!, {r1, r2, r4, r5, r6, r8, r9, fp, ip, lr}
    2c00:	25d18b6d 	ldrbcs	r8, [r1, #2925]	@ 0xb6d
    2c04:	64f6f872 	ldrbtvs	pc, [r6], #2162	@ 0x872	@ <UNPREDICTABLE>
    2c08:	16986886 	ldrne	r6, [r8], r6, lsl #17
    2c0c:	cc5ca4d4 	cfldrdgt	mvd10, [ip], {212}	@ 0xd4
    2c10:	92b6655d 	adcsls	r6, r6, #390070272	@ 0x17400000
    2c14:	5048706c 	subpl	r7, r8, ip, rrx
    2c18:	dab9edfd 	ble	fee7e414 <_STACK_TOP_+0xdee76418>
    2c1c:	5746155e 	smlsldpl	r1, r6, lr, r5
    2c20:	849d8da7 	ldrhi	r8, [sp], #3495	@ 0xda7
    2c24:	00abd890 	umlaleq	sp, fp, r0, r8
    2c28:	0ad3bc8c 	beq	ff4f1e60 <_STACK_TOP_+0xdf4e9e64>
    2c2c:	0558e4f7 	ldrbeq	lr, [r8, #-1271]	@ 0xfffffb09
    2c30:	0645b3b8 			@ <UNDEFINED> instruction: 0x0645b3b8
    2c34:	8f1e2cd0 	svchi	0x001e2cd0
    2c38:	020f3fca 	andeq	r3, pc, #808	@ 0x328
    2c3c:	03bdafc1 			@ <UNDEFINED> instruction: 0x03bdafc1
    2c40:	6b8a1301 	blvs	fe28784c <_STACK_TOP_+0xde27f850>
    2c44:	4111913a 	tstmi	r1, sl, lsr r1
    2c48:	eadc674f 	b	ff71c98c <_STACK_TOP_+0xdf714990>
    2c4c:	cecff297 	mcrgt	2, 6, pc, cr15, cr7, {4}	@ <UNPREDICTABLE>
    2c50:	73e6b4f0 	mvnvc	fp, #240, 8	@ 0xf0000000
    2c54:	2274ac96 	rsbscs	sl, r4, #38400	@ 0x9600
    2c58:	8535ade7 	ldrhi	sl, [r5, #-3559]!	@ 0xfffff219
    2c5c:	e837f9e2 	ldmda	r7!, {r1, r5, r6, r7, r8, fp, ip, sp, lr, pc}
    2c60:	6edf751c 	mrcvs	5, 6, r7, cr15, cr12, {0}
    2c64:	711af147 	tstvc	sl, r7, asr #2	@ <UNPREDICTABLE>
    2c68:	89c5291d 	stmibhi	r5, {r0, r2, r3, r4, r8, fp, sp}^
    2c6c:	0e62b76f 	cdpeq	7, 6, cr11, cr2, cr15, {3}
    2c70:	1bbe18aa 	blne	fef88f20 <_STACK_TOP_+0xdef80f24>
    2c74:	4b3e56fc 	blmi	f9886c <__ROM_SIZE__+0xf5886c>
    2c78:	2079d2c6 	rsbscs	sp, r9, r6, asr #5
    2c7c:	fec0db9a 	mcr2	11, 6, sp, cr0, cr10, {4}	@ <UNPREDICTABLE>
    2c80:	f45acd78 			@ <UNDEFINED> instruction: 0xf45acd78
    2c84:	33a8dd1f 			@ <UNDEFINED> instruction: 0x33a8dd1f
    2c88:	31c70788 	biccc	r0, r7, r8, lsl #15
    2c8c:	591012b1 	ldmdbpl	r0, {r0, r4, r5, r7, r9, ip}
    2c90:	5fec8027 	svcpl	0x00ec8027
    2c94:	a97f5160 	ldmdbge	pc!, {r5, r6, r8, ip, lr}^	@ <UNPREDICTABLE>
    2c98:	0d4ab519 	cfstr64eq	mvdx11, [sl, #-100]	@ 0xffffff9c
    2c9c:	9f7ae52d 	svcls	0x007ae52d
    2ca0:	ef9cc993 	svc	0x009cc993
    2ca4:	4d3be0a0 	ldcmi	0, cr14, [fp, #-640]!	@ 0xfffffd80
    2ca8:	b0f52aae 	rscslt	r2, r5, lr, lsr #21
    2cac:	3cbbebc8 	vldmiacc	fp!, {d14-<overflow reg d49>}
    2cb0:	61995383 	orrsvs	r5, r9, r3, lsl #7
    2cb4:	7e042b17 	vmovvc.32	d4[0], r2
    2cb8:	26d677ba 			@ <UNDEFINED> instruction: 0x26d677ba
    2cbc:	631469e1 	tstvs	r4, #3686400	@ 0x384000
    2cc0:	7d0c2155 	stfvcs	f2, [ip, #-340]	@ 0xfffffeac

00002cc4 <polynomial>:
const gf2elem_t polynomial = { 0x000000c9, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000008 }; 
    2cc4:	000000c9 	andeq	r0, r0, r9, asr #1
	...
    2cd8:	00000008 	andeq	r0, r0, r8

00002cdc <coeff_b>:
const gf2elem_t coeff_b    = { 0x4a3205fd, 0x512f7874, 0x1481eb10, 0xb8c953ca, 0x0a601907, 0x00000002 }; 
    2cdc:	4a3205fd 	bmi	c844d8 <__ROM_SIZE__+0xc444d8>
    2ce0:	512f7874 			@ <UNDEFINED> instruction: 0x512f7874
    2ce4:	1481eb10 	strne	lr, [r1], #2832	@ 0xb10
    2ce8:	b8c953ca 	stmialt	r9, {r1, r3, r6, r7, r8, r9, ip, lr}^
    2cec:	0a601907 	beq	1809110 <__ROM_SIZE__+0x17c9110>
    2cf0:	00000002 	andeq	r0, r0, r2

00002cf4 <base_y>:
const gf2elem_t base_y     = { 0x797324f1, 0xb11c5c0c, 0xa2cdd545, 0x71a0094f, 0xd51fbc6c, 0x00000000 }; 
    2cf4:	797324f1 	ldmdbvc	r3!, {r0, r4, r5, r6, r7, sl, sp}^
    2cf8:	b11c5c0c 	tstlt	ip, ip, lsl #24
    2cfc:	a2cdd545 	sbcge	sp, sp, #289406976	@ 0x11400000
    2d00:	71a0094f 	asrvc	r0, pc, #18
    2d04:	d51fbc6c 	ldrle	fp, [pc, #-3180]	@ 20a0 <ecdh_generate_keys+0x4c>
    2d08:	00000000 	andeq	r0, r0, r0

00002d0c <base_x>:
const gf2elem_t base_x     = { 0xe8343e36, 0xd4994637, 0xa0991168, 0x86a2d57e, 0xf0eba162, 0x00000003 }; 
    2d0c:	e8343e36 	ldmda	r4!, {r1, r2, r4, r5, r9, sl, fp, ip, sp}
    2d10:	d4994637 	ldrle	r4, [r9], #1591	@ 0x637
    2d14:	a0991168 	addsge	r1, r9, r8, ror #2
    2d18:	86a2d57e 			@ <UNDEFINED> instruction: 0x86a2d57e
    2d1c:	f0eba162 			@ <UNDEFINED> instruction: 0xf0eba162
    2d20:	00000003 	andeq	r0, r0, r3

00002d24 <base_order>:
const scalar_t  base_order = { 0xa4234c33, 0x77e70c12, 0x000292fe, 0x00000000, 0x00000000, 0x00000004 }; 
    2d24:	a4234c33 	strtge	r4, [r3], #-3123	@ 0xfffff3cd
    2d28:	77e70c12 			@ <UNDEFINED> instruction: 0x77e70c12
    2d2c:	000292fe 	strdeq	r9, [r2], -lr
	...
    2d38:	00000004 	andeq	r0, r0, r4

Disassembly of section .debug_info:

00000000 <.debug_info>:
       0:	00000201 	andeq	r0, r0, r1, lsl #4
       4:	04010005 	streq	r0, [r1], #-5
       8:	00000000 	andeq	r0, r0, r0
       c:	00000d09 	andeq	r0, r0, r9, lsl #26
      10:	00881d00 	addeq	r1, r8, r0, lsl #26
      14:	013a0000 	teqeq	sl, r0
      18:	03c00000 	biceq	r0, r0, #0
      1c:	00640000 	rsbeq	r0, r4, r0
      20:	00000000 	andeq	r0, r0, r0
      24:	01010000 	mrseq	r0, (UNDEF: 1)
      28:	0000d906 	andeq	sp, r0, r6, lsl #18
      2c:	05020100 	streq	r0, [r2, #-256]	@ 0xffffff00
      30:	0000012b 	andeq	r0, r0, fp, lsr #2
      34:	1b050401 	blne	141040 <__ROM_SIZE__+0x101040>
      38:	01000001 	tsteq	r0, r1
      3c:	01160508 	tsteq	r6, r8, lsl #10
      40:	01010000 	mrseq	r0, (UNDEF: 1)
      44:	0000d708 	andeq	sp, r0, r8, lsl #14
      48:	07020100 	streq	r0, [r2, -r0, lsl #2]
      4c:	000000e5 	andeq	r0, r0, r5, ror #1
      50:	fd070401 	stc2	4, cr0, [r7, #-4]
      54:	01000000 	mrseq	r0, (UNDEF: 0)
      58:	00f80708 	rscseq	r0, r8, r8, lsl #14
      5c:	040a0000 	streq	r0, [sl], #-0
      60:	746e6905 	strbtvc	r6, [lr], #-2309	@ 0xfffff6fb
      64:	07040100 	streq	r0, [r4, -r0, lsl #2]
      68:	00000102 	andeq	r0, r0, r2, lsl #2
      6c:	61040801 	tstvs	r4, r1, lsl #16
      70:	0b000001 	bleq	7c <vector_table+0x7c>
      74:	00646d63 	rsbeq	r6, r4, r3, ror #26
      78:	7f0f2d02 	svcvc	0x000f2d02
      7c:	05000000 	streq	r0, [r0, #-0]
      80:	00000084 	andeq	r0, r0, r4, lsl #1
      84:	00005e0c 	andeq	r5, r0, ip, lsl #28
      88:	00009800 	andeq	r9, r0, r0, lsl #16
      8c:	005e0300 	subseq	r0, lr, r0, lsl #6
      90:	98030000 	stmdals	r3, {}	@ <UNPREDICTABLE>
      94:	00000000 	andeq	r0, r0, r0
      98:	00009d05 	andeq	r9, r0, r5, lsl #26
      9c:	00a20500 	adceq	r0, r2, r0, lsl #10
      a0:	01010000 	mrseq	r0, (UNDEF: 1)
      a4:	0000e008 	andeq	lr, r0, r8
      a8:	00a20d00 	adceq	r0, r2, r0, lsl #26
      ac:	0c0e0000 	stceq	0, cr0, [lr], {-0}
      b0:	dc093602 	stcle	6, cr3, [r9], {2}
      b4:	06000000 	streq	r0, [r0], -r0
      b8:	000000bd 	strheq	r0, [r0], -sp
      bc:	00dc0f37 	sbcseq	r0, ip, r7, lsr pc
      c0:	06000000 	streq	r0, [r0], -r0
      c4:	00000000 	andeq	r0, r0, r0
      c8:	00dc0f38 	sbcseq	r0, ip, r8, lsr pc
      cc:	06040000 	streq	r0, [r4], -r0
      d0:	000000b5 	strheq	r0, [r0], -r5
      d4:	00730739 	rsbseq	r0, r3, r9, lsr r7
      d8:	00080000 	andeq	r0, r8, r0
      dc:	0000a905 	andeq	sl, r0, r5, lsl #18
      e0:	015b0f00 	cmpeq	fp, r0, lsl #30
      e4:	3a020000 	bcc	800ec <__ROM_SIZE__+0x400ec>
      e8:	0000ae03 	andeq	sl, r0, r3, lsl #28
      ec:	00ca1000 	sbceq	r1, sl, r0
      f0:	1b010000 	blne	400f8 <__ROM_SIZE__+0xf8>
      f4:	0000e101 	andeq	lr, r0, r1, lsl #2
      f8:	68030500 	stmdavs	r3, {r8, sl}
      fc:	07000022 	streq	r0, [r0, -r2, lsr #32]
     100:	0000010f 	andeq	r0, r0, pc, lsl #2
     104:	005e2703 	subseq	r2, lr, r3, lsl #14
     108:	01190000 	tsteq	r9, r0
     10c:	dc030000 	stcle	0, cr0, [r3], {-0}
     110:	03000000 	movweq	r0, #0
     114:	000000dc 	ldrdeq	r0, [r0], -ip
     118:	01240700 			@ <UNDEFINED> instruction: 0x01240700
     11c:	2c040000 	stccs	0, cr0, [r4], {-0}
     120:	0000005e 	andeq	r0, r0, lr, asr r0
     124:	0000012f 	andeq	r0, r0, pc, lsr #2
     128:	0000dc03 	andeq	sp, r0, r3, lsl #24
     12c:	12001100 	andne	r1, r0, #0, 2
     130:	000000ce 	andeq	r0, r0, lr, asr #1
     134:	5e050501 	cfsh32pl	mvfx0, mvfx5, #1
     138:	c0000000 	andgt	r0, r0, r0
     13c:	64000003 	strvs	r0, [r0], #-3
     140:	01000000 	mrseq	r0, (UNDEF: 0)
     144:	0135089c 	teqeq	r5, ip	@ <illegal shifter operand>
     148:	5e120000 	cdppl	0, 1, cr0, cr2, cr0, {0}
     14c:	10000000 	andne	r0, r0, r0
     150:	0c000000 	stceq	0, cr0, [r0], {-0}
     154:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
     158:	000000b0 	strheq	r0, [r0], -r0	@ <UNPREDICTABLE>
     15c:	0000981f 	andeq	r9, r0, pc, lsl r8
     160:	00001f00 	andeq	r1, r0, r0, lsl #30
     164:	00001b00 	andeq	r1, r0, r0, lsl #22
     168:	74631300 	strbtvc	r1, [r3], #-768	@ 0xfffffd00
     16c:	06010072 			@ <UNDEFINED> instruction: 0x06010072
     170:	00005e09 	andeq	r5, r0, r9, lsl #28
     174:	00002e00 	andeq	r2, r0, r0, lsl #28
     178:	00002a00 	andeq	r2, r0, r0, lsl #20
     17c:	03cc0400 	biceq	r0, ip, #0, 8
     180:	01190000 	tsteq	r9, r0
     184:	01940000 	orrseq	r0, r4, r0
     188:	01020000 	mrseq	r0, (UNDEF: 2)
     18c:	28030550 	stmdacs	r3, {r4, r6, r8, sl}
     190:	00000023 	andeq	r0, r0, r3, lsr #32
     194:	0003da04 	andeq	sp, r3, r4, lsl #20
     198:	00011900 	andeq	r1, r1, r0, lsl #18
     19c:	0001ab00 	andeq	sl, r1, r0, lsl #22
     1a0:	50010200 	andpl	r0, r1, r0, lsl #4
     1a4:	23400305 	movtcs	r0, #773	@ 0x305
     1a8:	04000000 	streq	r0, [r0], #-0
     1ac:	000003e6 	andeq	r0, r0, r6, ror #7
     1b0:	00000119 	andeq	r0, r0, r9, lsl r1
     1b4:	000001c2 	andeq	r0, r0, r2, asr #3
     1b8:	05500102 	ldrbeq	r0, [r0, #-258]	@ 0xfffffefe
     1bc:	00286c03 	eoreq	r6, r8, r3, lsl #24
     1c0:	f6040000 			@ <UNDEFINED> instruction: 0xf6040000
     1c4:	ff000003 			@ <UNDEFINED> instruction: 0xff000003
     1c8:	d9000000 	stmdble	r0, {}	@ <UNPREDICTABLE>
     1cc:	02000001 	andeq	r0, r0, #1
     1d0:	03055101 	movweq	r5, #20737	@ 0x5101
     1d4:	00002344 	andeq	r2, r0, r4, asr #6
     1d8:	03fe0400 	mvnseq	r0, #0, 8
     1dc:	01190000 	tsteq	r9, r0
     1e0:	01f00000 	mvnseq	r0, r0
     1e4:	01020000 	mrseq	r0, (UNDEF: 2)
     1e8:	50030550 	andpl	r0, r3, r0, asr r5
     1ec:	00000023 	andeq	r0, r0, r3, lsr #32
     1f0:	00040814 	andeq	r0, r4, r4, lsl r8
     1f4:	00011900 	andeq	r1, r1, r0, lsl #18
     1f8:	50010200 	andpl	r0, r1, r0, lsl #4
     1fc:	23640305 	cmncs	r4, #335544320	@ 0x14000000
     200:	00000000 	andeq	r0, r0, r0
     204:	0000bd00 	andeq	fp, r0, r0, lsl #26
     208:	01000500 	tsteq	r0, r0, lsl #10
     20c:	00011e04 	andeq	r1, r1, r4, lsl #28
     210:	000d0200 	andeq	r0, sp, r0, lsl #4
     214:	a01d0000 	andsge	r0, sp, r0
     218:	3a000001 	bcc	224 <vector_table+0x224>
     21c:	24000001 	strcs	r0, [r0], #-1
     220:	02000004 	andeq	r0, r0, #4
     224:	3c000000 	stccc	0, cr0, [r0], {-0}
     228:	01000001 	tsteq	r0, r1
     22c:	00d90601 	sbcseq	r0, r9, r1, lsl #12
     230:	02010000 	andeq	r0, r1, #0
     234:	00012b05 	andeq	r2, r1, r5, lsl #22
     238:	05040100 	streq	r0, [r4, #-256]	@ 0xffffff00
     23c:	0000011b 	andeq	r0, r0, fp, lsl r1
     240:	16050801 	strne	r0, [r5], -r1, lsl #16
     244:	01000001 	tsteq	r0, r1
     248:	00d70801 	sbcseq	r0, r7, r1, lsl #16
     24c:	02010000 	andeq	r0, r1, #0
     250:	0000e507 	andeq	lr, r0, r7, lsl #10
     254:	016d0300 	cmneq	sp, r0, lsl #6
     258:	34020000 	strcc	r0, [r2], #-0
     25c:	00005c19 	andeq	r5, r0, r9, lsl ip
     260:	07040100 	streq	r0, [r4, -r0, lsl #2]
     264:	000000fd 	strdeq	r0, [r0], -sp
     268:	f8070801 			@ <UNDEFINED> instruction: 0xf8070801
     26c:	04000000 	streq	r0, [r0], #-0
     270:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
     274:	04010074 	streq	r0, [r1], #-116	@ 0xffffff8c
     278:	00010207 	andeq	r0, r1, r7, lsl #4
     27c:	01940500 	orrseq	r0, r4, r0, lsl #10
     280:	14010000 	strne	r0, [r1], #-0
     284:	00006a0c 	andeq	r6, r0, ip, lsl #20
     288:	00500600 	subseq	r0, r0, r0, lsl #12
     28c:	00940000 	addseq	r0, r4, r0
     290:	71070000 	mrsvc	r0, (UNDEF: 7)
     294:	ef000000 	svc	0x00000000
     298:	01d90800 	bicseq	r0, r9, r0, lsl #16
     29c:	1c010000 	stcne	0, cr0, [r1], {-0}
     2a0:	0000840a 	andeq	r8, r0, sl, lsl #8
     2a4:	00030500 	andeq	r0, r3, r0, lsl #10
     2a8:	09000000 	stmdbeq	r0, {}	@ <UNPREDICTABLE>
     2ac:	00000176 	andeq	r0, r0, r6, ror r1
     2b0:	0a0d1501 	beq	3456bc <__ROM_SIZE__+0x3056bc>
     2b4:	00000184 	andeq	r0, r0, r4, lsl #3
     2b8:	24061701 	strcs	r1, [r6], #-1793	@ 0xfffff8ff
     2bc:	02000004 	andeq	r0, r0, #4
     2c0:	01000000 	mrseq	r0, (UNDEF: 0)
     2c4:	0091009c 	umullseq	r0, r1, ip, r0
     2c8:	00050000 	andeq	r0, r5, r0
     2cc:	01bb0401 			@ <UNDEFINED> instruction: 0x01bb0401
     2d0:	0d010000 	stceq	0, cr0, [r1, #-0]
     2d4:	1d000000 	stcne	0, cr0, [r0, #-0]
     2d8:	000001fc 	strdeq	r0, [r0], -ip
     2dc:	0000013a 	andeq	r0, r0, sl, lsr r1
     2e0:	00000428 	andeq	r0, r0, r8, lsr #8
     2e4:	00000064 	andeq	r0, r0, r4, rrx
     2e8:	00000200 	andeq	r0, r0, r0, lsl #4
     2ec:	0001e602 	andeq	lr, r1, r2, lsl #12
     2f0:	06220100 	strteq	r0, [r2], -r0, lsl #2
     2f4:	00000468 	andeq	r0, r0, r8, ror #8
     2f8:	00000024 	andeq	r0, r0, r4, lsr #32
     2fc:	f0039c01 			@ <UNDEFINED> instruction: 0xf0039c01
     300:	01000001 	tsteq	r0, r1
     304:	004e051c 	subeq	r0, lr, ip, lsl r5
     308:	044c0000 	strbeq	r0, [ip], #-0
     30c:	001c0000 	andseq	r0, ip, r0
     310:	9c010000 	stcls	0, cr0, [r1], {-0}
     314:	69050404 	stmdbvs	r5, {r2, sl}
     318:	0500746e 	streq	r7, [r0, #-1134]	@ 0xfffffb92
     31c:	000001f6 	strdeq	r0, [r0], -r6
     320:	28061301 	stmdacs	r6, {r0, r8, r9, ip}
     324:	24000004 	strcs	r0, [r0], #-4
     328:	01000000 	mrseq	r0, (UNDEF: 0)
     32c:	00008d9c 	muleq	r0, ip, sp
     330:	00630600 	rsbeq	r0, r3, r0, lsl #12
     334:	8d111301 	ldchi	3, cr1, [r1, #-4]
     338:	4e000000 	cdpmi	0, 0, cr0, cr0, cr0, {0}
     33c:	46000000 	strmi	r0, [r0], -r0
     340:	07000000 	streq	r0, [r0, -r0]
     344:	00000444 	andeq	r0, r0, r4, asr #8
     348:	00000055 	andeq	r0, r0, r5, asr r0
     34c:	01500108 	cmpeq	r0, r8, lsl #2
     350:	0900003d 	stmdbeq	r0, {r0, r2, r3, r4, r5}
     354:	00e00801 	rsceq	r0, r0, r1, lsl #16
     358:	91000000 	mrsls	r0, (UNDEF: 0)
     35c:	05000000 	streq	r0, [r0, #-0]
     360:	5a040100 	bpl	100768 <__ROM_SIZE__+0xc0768>
     364:	01000002 	tsteq	r0, r2
     368:	0000000d 	andeq	r0, r0, sp
     36c:	00024b1d 	andeq	r4, r2, sp, lsl fp
     370:	00013a00 	andeq	r3, r1, r0, lsl #20
     374:	00048c00 	andeq	r8, r4, r0, lsl #24
     378:	00006400 	andeq	r6, r0, r0, lsl #8
     37c:	0002fd00 	andeq	pc, r2, r0, lsl #26
     380:	02320200 	eorseq	r0, r2, #0, 4
     384:	22010000 	andcs	r0, r1, #0
     388:	0004cc06 	andeq	ip, r4, r6, lsl #24
     38c:	00002400 	andeq	r2, r0, r0, lsl #8
     390:	039c0100 	orrseq	r0, ip, #0, 2
     394:	00000244 	andeq	r0, r0, r4, asr #4
     398:	4e051c01 	cdpmi	12, 0, cr1, cr5, cr1, {0}
     39c:	b0000000 	andlt	r0, r0, r0
     3a0:	1c000004 	stcne	0, cr0, [r0], {4}
     3a4:	01000000 	mrseq	r0, (UNDEF: 0)
     3a8:	0504049c 	streq	r0, [r4, #-1180]	@ 0xfffffb64
     3ac:	00746e69 	rsbseq	r6, r4, r9, ror #28
     3b0:	00023d05 	andeq	r3, r2, r5, lsl #26
     3b4:	06130100 	ldreq	r0, [r3], -r0, lsl #2
     3b8:	0000048c 	andeq	r0, r0, ip, lsl #9
     3bc:	00000024 	andeq	r0, r0, r4, lsr #32
int car_mesg(int argc, char** argv) {
     3c0:	008d9c01 	addeq	r9, sp, r1, lsl #24
     3c4:	63060000 	movwvs	r0, #24576	@ 0x6000
    printf("Received the message:");
     3c8:	12130100 	andsne	r0, r3, #0, 2
    for (ctr = 1; ctr < argc; ctr++) {
     3cc:	0000008d 	andeq	r0, r0, sp, lsl #1
        printf(" %s", argv[ctr]);
     3d0:	0000007d 	andeq	r0, r0, sp, ror r0
     3d4:	00000075 	andeq	r0, r0, r5, ror r0
     3d8:	0004a807 	andeq	sl, r4, r7, lsl #16
    for (ctr = 1; ctr < argc; ctr++) {
     3dc:	00005500 	andeq	r5, r0, r0, lsl #10
    printf("\n");
     3e0:	50010800 	andpl	r0, r1, r0, lsl #16
     3e4:	00003d01 	andeq	r3, r0, r1, lsl #26
    if (argc > 0) {
     3e8:	e0080109 	and	r0, r8, r9, lsl #2
}
     3ec:	00000000 	andeq	r0, r0, r0
        if (strcmp(argv[1], "PING_REPLY") == 0) {
     3f0:	0000017f 	andeq	r0, r0, pc, ror r1
     3f4:	04010005 	streq	r0, [r1], #-5
            printf("Got a ping reply.\n");
     3f8:	000002f9 	strdeq	r0, [r0], -r9
     3fc:	00000d08 	andeq	r0, r0, r8, lsl #26
            printf("Didn't know how to handle %s\n", argv[1]);
     400:	02821d00 	addeq	r1, r2, #0, 26
     404:	013a0000 	teqeq	sl, r0
     408:	04f00000 	ldrbteq	r0, [r0], #0
     40c:	008c0000 	addeq	r0, ip, r0
     410:	03fb0000 	mvnseq	r0, #0
     414:	01010000 	mrseq	r0, (UNDEF: 1)
     418:	0000d906 	andeq	sp, r0, r6, lsl #18
     41c:	05020100 	streq	r0, [r2, #-256]	@ 0xffffff00
     420:	0000012b 	andeq	r0, r0, fp, lsr #2
     424:	1b050401 	blne	141430 <__ROM_SIZE__+0x101430>
void uputc(char c) {
     428:	01000001 	tsteq	r0, r1
  while ((UARTFR >> 5) & 1)
     42c:	01160508 	tsteq	r6, r8, lsl #10
     430:	01010000 	mrseq	r0, (UNDEF: 1)
  UART_DR = c;
     434:	0000d708 	andeq	sp, r0, r8, lsl #14
  if (c == '\n')
     438:	07020100 	streq	r0, [r2, -r0, lsl #2]
}
     43c:	000000e5 	andeq	r0, r0, r5, ror #1
    uputc('\r');
     440:	fd070401 	stc2	4, cr0, [r7, #-4]
}
     444:	01000000 	mrseq	r0, (UNDEF: 0)
     448:	00f80708 	rscseq	r0, r8, r8, lsl #14
  if (!((UARTFR >> 4) & 1)) return UART_DR;
     44c:	04090000 	streq	r0, [r9], #-0
     450:	746e6905 	strbtvc	r6, [lr], #-2309	@ 0xfffff6fb
     454:	07040100 	streq	r0, [r4, -r0, lsl #2]
     458:	00000102 	andeq	r0, r0, r2, lsl #2
  return -1;
     45c:	61040801 	tstvs	r4, r1, lsl #16
}
     460:	01000001 	tsteq	r0, r1
     464:	00e00801 	rsceq	r0, r0, r1, lsl #16
  UARTCTL = 0;
     468:	3d040000 	stccc	0, cr0, [r4, #-0]
     46c:	02000002 	andeq	r0, r0, #2
  UARTIBRD = 8;
     470:	00008b22 	andeq	r8, r0, r2, lsr #22
  UARTFBRD = 44;
     474:	00730200 	rsbseq	r0, r3, r0, lsl #4
  UARTCC = 0;
     478:	04000000 	streq	r0, [r0], #-0
  UARTLCRH = 0x60;
     47c:	000002df 	ldrdeq	r0, [r0], -pc	@ <UNPREDICTABLE>
  UARTCTL = 0x301;
     480:	009c7603 	addseq	r7, ip, r3, lsl #12
}
     484:	9c020000 	stcls	0, cr0, [r2], {-0}
     488:	00000000 	andeq	r0, r0, r0
void u2putc(char c) {
     48c:	0000a105 	andeq	sl, r0, r5, lsl #2
  while ((UART2FR >> 5) & 1)
     490:	00ac0a00 	adceq	r0, ip, r0, lsl #20
     494:	73020000 	movwvc	r0, #8192	@ 0x2000
  UART2_DR = c;
     498:	00000000 	andeq	r0, r0, r0
  if (c == '\n')
     49c:	0001f604 	andeq	pc, r1, r4, lsl #12
}
     4a0:	bd220400 	cfstrslt	mvf0, [r2, #-0]
    u2putc('\r');
     4a4:	02000000 	andeq	r0, r0, #0
}
     4a8:	00000073 	andeq	r0, r0, r3, ror r0
     4ac:	02d00400 	sbcseq	r0, r0, #0, 8
  if (!((UART2FR >> 4) & 1)) return UART2_DR;
     4b0:	75030000 	strvc	r0, [r3, #-0]
     4b4:	000000ce 	andeq	r0, r0, lr, asr #1
     4b8:	00009c02 	andeq	r9, r0, r2, lsl #24
     4bc:	44060000 	strmi	r0, [r6], #-0
  return -1;
     4c0:	02000002 	andeq	r0, r0, #2
}
     4c4:	0000005e 	andeq	r0, r0, lr, asr r0
     4c8:	0002c104 	andeq	ip, r2, r4, lsl #2
  UART2CTL = 0;
     4cc:	e9690300 	stmdb	r9!, {r8, r9}^
     4d0:	02000000 	andeq	r0, r0, #0
  UART2IBRD = 8;
     4d4:	000000e9 	andeq	r0, r0, r9, ror #1
  UART2FBRD = 44;
     4d8:	00ee0500 	rsceq	r0, lr, r0, lsl #10
  UART2CC = 0;
     4dc:	5e0b0000 	cdppl	0, 0, cr0, cr11, cr0, {0}
  UART2LCRH = 0x60;
     4e0:	06000000 	streq	r0, [r0], -r0
  UART2CTL = 0x301;
     4e4:	000001f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
}
     4e8:	00005e04 	andeq	r5, r0, r4, lsl #28
     4ec:	02ef0400 	rsceq	r0, pc, #0, 8
  RCGCUART |= 3;
     4f0:	68030000 	stmdavs	r3, {}	@ <UNPREDICTABLE>
     4f4:	0000010e 	andeq	r0, r0, lr, lsl #2
     4f8:	0000e902 	andeq	lr, r0, r2, lsl #18
     4fc:	32070000 	andcc	r0, r7, #0
  RCGCGPIO |= 3;
     500:	02000002 	andeq	r0, r0, #2
     504:	0001e607 	andeq	lr, r1, r7, lsl #12
     508:	fd0c0400 	stc2	4, cr0, [ip, #-0]
  GPIODEN = 0x03;
     50c:	01000002 	tsteq	r0, r2
     510:	05440638 	strbeq	r0, [r4, #-1592]	@ 0xfffff9c8
  GPIOAFSEL = 0x03;
     514:	00380000 	eorseq	r0, r8, r0
  GPIOPCTL |= 0x00000011;
     518:	9c010000 	stcls	0, cr0, [r1], {-0}
     51c:	00000170 	andeq	r0, r0, r0, ror r1
     520:	00054a03 	andeq	r4, r5, r3, lsl #20
  GPIODEN2 = 0x03;
     524:	00017000 	andeq	r7, r1, r0
     528:	054e0300 	strbeq	r0, [lr, #-768]	@ 0xfffffd00
  GPIOAFSEL2 = 0x03;
     52c:	01140000 	tsteq	r4, r0
  GPIOPCTL2 |= 0x00000011;
     530:	52030000 	andpl	r0, r3, #0
     534:	0e000005 	cdpeq	0, 0, cr0, cr0, cr5, {0}
     538:	03000001 	movweq	r0, #1
}
     53c:	00000558 	andeq	r0, r0, r8, asr r5
     540:	000000fd 	strdeq	r0, [r0], -sp
void platform_init() {
     544:	00055e03 	andeq	r5, r5, r3, lsl #28
    pin_setup();
     548:	0000d800 	andeq	sp, r0, r0, lsl #16
    uart_init();
     54c:	05640300 	strbeq	r0, [r4, #-768]!	@ 0xfffffd00
    uart2_init();
     550:	00bd0000 	adcseq	r0, sp, r0
    set_read_char(ugetc);
     554:	6a030000 	bvs	c055c <__ROM_SIZE__+0x8055c>
    set_read_char2(u2getc);
     558:	8b000005 	blhi	574 <platform_init+0x30>
     55c:	00000000 	andeq	r0, r0, r0
    set_write_char(uputc);
     560:	0002b70d 	andeq	fp, r2, sp, lsl #14
    set_write_char2(u2putc);
     564:	06220100 	strteq	r0, [r2], -r0, lsl #2
     568:	000004f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
}
     56c:	00000054 	andeq	r0, r0, r4, asr r0
     570:	8b009c01 	blhi	2757c <__RAM_SIZE__+0x1f57c>
     574:	05000001 	streq	r0, [r0, #-1]
     578:	c3040100 	movwgt	r0, #16640	@ 0x4100
int pair(int argc, char** argv) {
     57c:	09000003 	stmdbeq	r0, {r0, r1}
    printf("Sending a pair request.\n");
     580:	0000000d 	andeq	r0, r0, sp
    printf2("FOB_MESG PAIR\n");
     584:	00031c1d 	andeq	r1, r3, sp, lsl ip
     588:	00013a00 	andeq	r3, r1, r0, lsl #20
}
     58c:	00057c00 	andeq	r7, r5, r0, lsl #24
     590:	00001c00 	andeq	r1, r0, r0, lsl #24
     594:	00052700 	andeq	r2, r5, r0, lsl #14
int aes(int argc, char** argv) {
     598:	06010100 	streq	r0, [r1], -r0, lsl #2
    uint8_t key[16] = {0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,
     59c:	000000d9 	ldrdeq	r0, [r0], -r9
     5a0:	2b050201 	blcs	140dac <__ROM_SIZE__+0x100dac>
     5a4:	01000001 	tsteq	r0, r1
    uint8_t text[16] = "0123456789abcdef";
     5a8:	011b0504 	tsteq	fp, r4, lsl #10
     5ac:	08010000 	stmdaeq	r1, {}	@ <UNPREDICTABLE>
     5b0:	00011605 	andeq	r1, r1, r5, lsl #12
    AES_init_ctx(&ctx, key);
     5b4:	08010100 	stmdaeq	r1, {r8}
     5b8:	000000d7 	ldrdeq	r0, [r0], -r7
    printf("Encrypting %s using AES\n", text);
     5bc:	e5070201 	str	r0, [r7, #-513]	@ 0xfffffdff
     5c0:	01000000 	mrseq	r0, (UNDEF: 0)
    AES_ECB_encrypt(&ctx, text);
     5c4:	00fd0704 	rscseq	r0, sp, r4, lsl #14
     5c8:	08010000 	stmdaeq	r1, {}	@ <UNPREDICTABLE>
    printf("Encrypted is %s\n", text);
     5cc:	0000f807 	andeq	pc, r0, r7, lsl #16
     5d0:	05040a00 	streq	r0, [r4, #-2560]	@ 0xfffff600
    len = encode_base64(text, 16, b64text);
     5d4:	00746e69 	rsbseq	r6, r4, r9, ror #28
     5d8:	02070401 	andeq	r0, r7, #16777216	@ 0x1000000
     5dc:	01000001 	tsteq	r0, r1
    b64text[len] = '\n';
     5e0:	01610408 	cmneq	r1, r8, lsl #8
     5e4:	630b0000 	movwvs	r0, #45056	@ 0xb000
     5e8:	0200646d 	andeq	r6, r0, #1828716544	@ 0x6d000000
    printf("Encrypted is %s\n", text);
     5ec:	007f0f2d 	rsbseq	r0, pc, sp, lsr #30
     5f0:	84020000 	strhi	r0, [r2], #-0
    printf2("FOB_MESG AESB64 %s\n", b64text);
     5f4:	0c000000 	stceq	0, cr0, [r0], {-0}
     5f8:	0000005e 	andeq	r0, r0, lr, asr r0
    AES_ECB_decrypt(&ctx, text);
     5fc:	00000098 	muleq	r0, r8, r0
     600:	00005e03 	andeq	r5, r0, r3, lsl #28
    printf("Which should decrypt to %s \n", text);
     604:	00980300 	addseq	r0, r8, r0, lsl #6
     608:	02000000 	andeq	r0, r0, #0
}
     60c:	0000009d 	muleq	r0, sp, r0
     610:	0000a202 	andeq	sl, r0, r2, lsl #4
     614:	08010100 	stmdaeq	r1, {r8}
     618:	000000e0 	andeq	r0, r0, r0, ror #1
     61c:	0000a20d 	andeq	sl, r0, sp, lsl #4
     620:	020c0e00 	andeq	r0, ip, #0, 28
     624:	00dc0936 	sbcseq	r0, ip, r6, lsr r9
     628:	bd040000 	stclt	0, cr0, [r4, #-0]
int encode64(int argc, char** argv) {
     62c:	37000000 	strcc	r0, [r0, -r0]
    if (argc > 1) {
     630:	0000dc0f 	andeq	sp, r0, pc, lsl #24
     634:	00040000 	andeq	r0, r4, r0
        len = strlen(argv[1]);
     638:	38000000 	stmdacc	r0, {}	@ <UNPREDICTABLE>
     63c:	0000dc0f 	andeq	sp, r0, pc, lsl #24
        if (len < MAX64LENGTH) {
     640:	b5040400 	strlt	r0, [r4, #-1024]	@ 0xfffffc00
            len = encode_base64(argv[1], len, encoded);
     644:	39000000 	stmdbcc	r0, {}	@ <UNPREDICTABLE>
     648:	00007307 	andeq	r7, r0, r7, lsl #6
            printf("Encoded %s as %s with %d characters\n", argv[1], encoded, len);
     64c:	02000800 	andeq	r0, r0, #0, 16
     650:	000000a9 	andeq	r0, r0, r9, lsr #1
     654:	00015b0f 	andeq	r5, r1, pc, lsl #22
            printf("String exceeds max length of %d characters", MAX64LENGTH);
     658:	033a0200 	teqeq	sl, #0, 4
     65c:	000000ae 	andeq	r0, r0, lr, lsr #1
     660:	00030b10 	andeq	r0, r3, r0, lsl fp
        printf("Usage is 'encode64 string'\n");
     664:	010c0100 	mrseq	r0, (UNDEF: 28)
}
     668:	000000e1 	andeq	r0, r0, r1, ror #1
     66c:	22740305 	rsbscs	r0, r4, #335544320	@ 0x14000000
     670:	14050000 	strne	r0, [r5], #-0
     674:	2d000003 	stccs	0, cr0, [r0, #-12]
     678:	0000005e 	andeq	r0, r0, lr, asr r0
int decode64(int argc, char** argv) {
     67c:	00000114 	andeq	r0, r0, r4, lsl r1
    if (argc > 1) {
     680:	0000dc03 	andeq	sp, r0, r3, lsl #24
     684:	05000600 	streq	r0, [r0, #-1536]	@ 0xfffffa00
        int len = strlen(argv[1]);
     688:	00000124 	andeq	r0, r0, r4, lsr #2
     68c:	00005e2c 	andeq	r5, r0, ip, lsr #28
        if (len < MAX64LENGTH-1) {
     690:	00012900 	andeq	r2, r1, r0, lsl #18
                printf("encoded string is %d characters\n", len);
     694:	00dc0300 	sbcseq	r0, ip, r0, lsl #6
     698:	00060000 	andeq	r0, r6, r0
                len = decode_base64(argv[1], len, plaintext);
     69c:	00030f11 	andeq	r0, r3, r1, lsl pc
     6a0:	05050100 	streq	r0, [r5, #-256]	@ 0xffffff00
     6a4:	0000005e 	andeq	r0, r0, lr, asr r0
                printf("decoded string is %d characters\n", len);
     6a8:	0000057c 	andeq	r0, r0, ip, ror r5
     6ac:	0000001c 	andeq	r0, r0, ip, lsl r0
                printf("Adding NULL at the end of decoded string\n");
     6b0:	35079c01 	strcc	r9, [r7, #-3073]	@ 0xfffff3ff
                plaintext[len] = '\n';
     6b4:	0e000001 	cdpeq	0, 0, cr0, cr0, cr1, {0}
     6b8:	0000005e 	andeq	r0, r0, lr, asr r0
     6bc:	000000a8 	andeq	r0, r0, r8, lsr #1
     6c0:	000000a4 	andeq	r0, r0, r4, lsr #1
                printf("Decoded %s as: %s\n", argv[1], plaintext);
     6c4:	0000b007 	andeq	fp, r0, r7
     6c8:	00981b00 	addseq	r1, r8, r0, lsl #22
     6cc:	00ba0000 	adcseq	r0, sl, r0
            printf("String exceeds max length of %d characters", MAX64LENGTH);
     6d0:	00b60000 	adcseq	r0, r6, r0
     6d4:	84120000 	ldrhi	r0, [r2], #-0
        printf("Usage is 'decode64 string'\n");
     6d8:	14000005 	strne	r0, [r0], #-5
     6dc:	7a000001 	bvc	6e8 <decode64+0x6c>
}
     6e0:	08000001 	stmdaeq	r0, {r0}
     6e4:	03055001 	movweq	r5, #20481	@ 0x5001
     6e8:	000023b4 			@ <UNDEFINED> instruction: 0x000023b4
     6ec:	058a1300 	streq	r1, [sl, #768]	@ 0x300
     6f0:	00ff0000 	rscseq	r0, pc, r0
     6f4:	01080000 	mrseq	r0, (UNDEF: 8)
     6f8:	d0030550 	andle	r0, r3, r0, asr r5
int send_ping(int argc, char** argv) {
     6fc:	00000023 	andeq	r0, r0, r3, lsr #32
    printf("Pinging the car.\n");
     700:	03950000 	orrseq	r0, r5, #0
    printf2("FOB_MESG PING\n");
     704:	00050000 	andeq	r0, r5, r0
     708:	04ce0401 	strbeq	r0, [lr], #1025	@ 0x401
}
     70c:	0d110000 	ldceq	0, cr0, [r1, #-0]
     710:	1d000000 	stcne	0, cr0, [r0, #-0]
     714:	00000364 	andeq	r0, r0, r4, ror #6
void __attribute__((optimize("O0"), weak)) initial_setup(void) {
     718:	0000013a 	andeq	r0, r0, sl, lsr r1
     71c:	00000598 	muleq	r0, r8, r5
  char *src = &_etext, *dst = &_data;
     720:	00000094 	muleq	r0, r4, r0
     724:	000005f1 	strdeq	r0, [r0], -r1
  if (dst != src)
     728:	d9060103 	stmdble	r6, {r0, r1, r8}
     72c:	03000000 	movweq	r0, #0
    while (dst < &_edata) *(dst++) = *(src++);
     730:	012b0502 			@ <UNDEFINED> instruction: 0x012b0502
     734:	04030000 	streq	r0, [r3], #-0
     738:	00011b05 	andeq	r1, r1, r5, lsl #22
     73c:	05080300 	streq	r0, [r8, #-768]	@ 0xfffffd00
     740:	00000116 	andeq	r0, r0, r6, lsl r1
     744:	00039b0b 	andeq	r9, r3, fp, lsl #22
  for (dst = &_bss; dst < &_ebss; dst++) *dst = 0;
     748:	182e0400 	stmdane	lr!, {sl}
     74c:	00000053 	andeq	r0, r0, r3, asr r0
     750:	00004207 	andeq	r4, r0, r7, lsl #4
     754:	08010300 	stmdaeq	r1, {r8, r9}
     758:	000000d7 	ldrdeq	r0, [r0], -r7
     75c:	e5070203 	str	r0, [r7, #-515]	@ 0xfffffdfd
     760:	03000000 	movweq	r0, #0
  platform_init();
     764:	00fd0704 	rscseq	r0, sp, r4, lsl #14
}
     768:	08030000 	stmdaeq	r3, {}	@ <UNPREDICTABLE>
     76c:	0000f807 	andeq	pc, r0, r7, lsl #16
     770:	05041200 	streq	r1, [r4, #-512]	@ 0xfffffe00
     774:	00746e69 	rsbseq	r6, r4, r9, ror #28
     778:	02070403 	andeq	r0, r7, #50331648	@ 0x3000000
     77c:	03000001 	movweq	r0, #1
     780:	01610408 	cmneq	r1, r8, lsl #8
static void delete(void) {
     784:	a3130000 	tstge	r3, #0
  __write_char__(BACK_SPACE);
     788:	c0000003 	andgt	r0, r0, r3
     78c:	ab082c02 	blge	20b79c <__ROM_SIZE__+0x1cb79c>
  __write_char__(SPACE);
     790:	06000000 	streq	r0, [r0], -r0
  __write_char__(BACK_SPACE);
     794:	00000a53 	andeq	r0, r0, r3, asr sl
     798:	b00b2e02 	andlt	r2, fp, r2, lsl #28
}
     79c:	00000000 	andeq	r0, r0, r0
static void clear_prompt(int char_count) {
     7a0:	00764914 	rsbseq	r4, r6, r4, lsl r9
  while (char_count) {
     7a4:	c00b3002 	andgt	r3, fp, r2
    delete ();
     7a8:	b0000000 	andlt	r0, r0, r0
  while (char_count) {
     7ac:	00840700 	addeq	r0, r4, r0, lsl #14
}
     7b0:	420c0000 	andmi	r0, ip, #0
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
     7b4:	c0000000 	andgt	r0, r0, r0
    auto_load[i].command(0, NULL);
     7b8:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
     7bc:	00000076 	andeq	r0, r0, r6, ror r0
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
     7c0:	420c00af 	andmi	r0, ip, #175	@ 0xaf
     7c4:	d0000000 	andle	r0, r0, r0
     7c8:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
     7cc:	00000076 	andeq	r0, r0, r6, ror r0
     7d0:	6315000f 	tstvs	r5, #15
}
     7d4:	0300646d 	movweq	r6, #1133	@ 0x46d
static int show_history(int argc, char **argv) {
     7d8:	00dc0f2d 	sbcseq	r0, ip, sp, lsr #30
  uint32_t end_index = total_num_commands-1;
     7dc:	e1040000 	mrs	r0, (UNDEF: 4)
  if (total_num_commands > NUM_HISTORY_ENTRIES) {
     7e0:	16000000 	strne	r0, [r0], -r0
     7e4:	0000006f 	andeq	r0, r0, pc, rrx
    beg_index = total_num_commands - NUM_HISTORY_ENTRIES;
     7e8:	000000f5 	strdeq	r0, [r0], -r5
     7ec:	00006f02 	andeq	r6, r0, r2, lsl #30
  uint32_t beg_index = 0;
     7f0:	00f50200 	rscseq	r0, r5, r0, lsl #4
    printf("%s\n", cmd_history[index % NUM_HISTORY_ENTRIES]);
     7f4:	04000000 	streq	r0, [r0], #-0
     7f8:	000000fa 	strdeq	r0, [r0], -sl
     7fc:	0000ff04 	andeq	pc, r0, r4, lsl #30
     800:	08010300 	stmdaeq	r1, {r8, r9}
  for (uint32_t index = beg_index; index <= end_index; ++index) {
     804:	000000e0 	andeq	r0, r0, r0, ror #1
}
     808:	0000ff07 	andeq	pc, r0, r7, lsl #30
     80c:	030c1700 	movweq	r1, #50944	@ 0xc700
     810:	013c0936 	teqeq	ip, r6, lsr r9
     814:	bd060000 	stclt	0, cr0, [r6, #-0]
int cmd_exec_status(int argc, char **argv) {
     818:	03000000 	movweq	r0, #0
  printf("%d\n", __cmd_exec_status);
     81c:	013c0f37 	teqeq	ip, r7, lsr pc
     820:	06000000 	streq	r0, [r0], -r0
     824:	00000000 	andeq	r0, r0, r0
}
     828:	3c0f3803 	stccc	8, cr3, [pc], {3}
     82c:	04000001 	streq	r0, [r0], #-1
     830:	0000b506 	andeq	fp, r0, r6, lsl #10
static int build_info(int argc, char **argv) {
     834:	07390300 	ldreq	r0, [r9, -r0, lsl #6]!
  printf("Build: [" SHELL_VERSION ":" USER_REPO_VERSION "] - [" BUILD_USER
     838:	000000d0 	ldrdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
}
     83c:	06040008 	streq	r0, [r4], -r8
     840:	0b000001 	bleq	84c <execute+0x8>
static void execute(int argc, char **argv) {
     844:	0000015b 	andeq	r0, r0, fp, asr r1
     848:	0b033a03 	bleq	cf05c <__ROM_SIZE__+0x8f05c>
  for (int i = 0; table[i].command_name != NULL; i++) {
     84c:	18000001 	stmdane	r0, {r0}
     850:	00000393 	muleq	r0, r3, r3
     854:	41012001 	tstmi	r1, r1
     858:	05000001 	streq	r0, [r0, #-1]
     85c:	00228003 	eoreq	r8, r2, r3
    if (strcmp(argv[0], table[i].command_name) == 0) {
     860:	03540900 	cmpeq	r4, #0, 18
     864:	743f0000 	ldrtvc	r0, [pc], #-0	@ 86c <execute+0x28>
      __cmd_exec_status = table[i].command(argc, &argv[0]);
     868:	02000001 	andeq	r0, r0, #1
     86c:	00000174 	andeq	r0, r0, r4, ror r1
     870:	00017902 	andeq	r7, r1, r2, lsl #18
     874:	ab040000 	blge	10087c <__ROM_SIZE__+0xc087c>
     878:	04000000 	streq	r0, [r0], #-0
    printf("\"%s\": command not found. Use \"help\" to list all command.\n",
     87c:	00000042 	andeq	r0, r0, r2, asr #32
     880:	0003140a 	andeq	r1, r3, sl, lsl #8
    __cmd_exec_status = -1;
     884:	052d0500 	streq	r0, [sp, #-1280]!	@ 0xfffffb00
     888:	0000006f 	andeq	r0, r0, pc, rrx
     88c:	00000195 	muleq	r0, r5, r1
}
     890:	00013c02 	andeq	r3, r1, r2, lsl #24
     894:	0a000d00 	beq	3c9c <base_order+0xf78>
     898:	000003b8 			@ <UNDEFINED> instruction: 0x000003b8
     89c:	760e3d06 	strvc	r3, [lr], -r6, lsl #26
int help(int argc, char **argv) {
     8a0:	b5000000 	strlt	r0, [r0, #-0]
  if (argc > 1 && (strcmp(argv[1], "-l")==0)) {
     8a4:	02000001 	andeq	r0, r0, #1
     8a8:	000001b5 			@ <UNDEFINED> instruction: 0x000001b5
     8ac:	00007602 	andeq	r7, r0, r2, lsl #12
     8b0:	01b50200 			@ <UNDEFINED> instruction: 0x01b50200
    printf("use: help -l for list only.\n\n");
     8b4:	04000000 	streq	r0, [r0], #-0
  bool verbose = true;
     8b8:	00000053 	andeq	r0, r0, r3, asr r0
    verbose = false;
     8bc:	00034409 	andeq	r4, r3, r9, lsl #8
    printf("\n");
     8c0:	01cf3e00 	biceq	r3, pc, r0, lsl #28
    i++;
     8c4:	74020000 	strvc	r0, [r2], #-0
  while (table[i].command_name != NULL) {
     8c8:	02000001 	andeq	r0, r0, #1
     8cc:	00000179 	andeq	r0, r0, r9, ror r1
     8d0:	01240a00 			@ <UNDEFINED> instruction: 0x01240a00
    printf(table[i].command_name);
     8d4:	2c050000 	stccs	0, cr0, [r5], {-0}
    if (verbose) {
     8d8:	00006f05 	andeq	r6, r0, r5, lsl #30
      printf("\n\t");
     8dc:	0001e600 	andeq	lr, r1, r0, lsl #12
      printf(table[i].command_help);
     8e0:	013c0200 	teqeq	ip, r0, lsl #4
     8e4:	000d0000 	andeq	r0, sp, r0
     8e8:	0003ab09 	andeq	sl, r3, r9, lsl #22
    verbose = false;
     8ec:	01fb3400 	mvnseq	r3, r0, lsl #8
}
     8f0:	fb020000 	blx	808fa <__ROM_SIZE__+0x408fa>
     8f4:	02000001 	andeq	r0, r0, #1
     8f8:	00000200 	andeq	r0, r0, r0, lsl #4
     8fc:	00840400 	addeq	r0, r4, r0, lsl #8
     900:	4e040000 	cdpmi	0, 0, cr0, cr4, cr0, {0}
     904:	19000000 	stmdbne	r0, {}	@ <UNPREDICTABLE>
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
     908:	00736561 	rsbseq	r6, r3, r1, ror #10
static void add_command_to_history(const char *cmd_str) {
     90c:	6f050301 	svcvs	0x00050301
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
     910:	98000000 	stmdals	r0, {}	@ <UNPREDICTABLE>
     914:	94000005 	strls	r0, [r0], #-5
  int index = total_num_commands % NUM_HISTORY_ENTRIES;
     918:	01000000 	mrseq	r0, (UNDEF: 0)
     91c:	00038c9c 	muleq	r3, ip, ip
     920:	01350e00 	teqeq	r5, r0, lsl #28
     924:	6f0d0000 	svcvs	0x000d0000
  memcpy(&cmd_history[index], cmd_str, LINE_BUFF_SIZE);
     928:	d8000000 	stmdale	r0, {}	@ <UNPREDICTABLE>
     92c:	d4000000 	strle	r0, [r0], #-0
     930:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
     934:	000000b0 	strheq	r0, [r0], -r0	@ <UNPREDICTABLE>
  total_num_commands++;
     938:	0000f51a 	andeq	pc, r0, sl, lsl r5	@ <UNPREDICTABLE>
  curr_command_ptr = total_num_commands;
     93c:	0000eb00 	andeq	lr, r0, r0, lsl #22
     940:	0000e700 	andeq	lr, r0, r0, lsl #14
     944:	74630f00 	strbtvc	r0, [r3], #-3840	@ 0xfffff100
     948:	14050078 	strne	r0, [r5], #-120	@ 0xffffff88
     94c:	00000084 	andeq	r0, r0, r4, lsl #1
static int parse_line(char **argv, char *line_buff, int argument_size) {
     950:	7eb09103 	asnvcs	f1, f3
     954:	79656b0f 	stmdbvc	r5!, {r0, r1, r2, r3, r8, r9, fp, sp, lr}^
  int length = strlen(line_buff);
     958:	c00d0600 	andgt	r0, sp, r0, lsl #12
     95c:	03000000 	movweq	r0, #0
  int argc = 0;
     960:	107ea091 			@ <UNDEFINED> instruction: 0x107ea091
         pos++)
     964:	0000038e 	andeq	r0, r0, lr, lsl #7
    for (; line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
     968:	00c00d09 	sbceq	r0, r0, r9, lsl #26
     96c:	91030000 	mrsls	r0, (UNDEF: 3)
     970:	6c1a7e90 	ldcvs	14, cr7, [sl], {144}	@ 0x90
     974:	01006e65 	tsteq	r0, r5, ror #28
    if (line_buff[pos] == '\t' || line_buff[pos] == SPACE)
     978:	0076120b 	rsbseq	r1, r6, fp, lsl #4
     97c:	00fe0000 	rscseq	r0, lr, r0
      line_buff[pos] = END_OF_LINE;
     980:	00fa0000 	rscseq	r0, sl, r0
  while (pos <= length) {
     984:	8b100000 	blhi	40098c <__ROM_SIZE__+0x3c098c>
    if (line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
     988:	12000003 	andne	r0, r0, #3
     98c:	00038c0a 	andeq	r8, r3, sl, lsl #24
     990:	f8910300 			@ <UNDEFINED> instruction: 0xf8910300
     994:	05ba057d 	ldreq	r0, [sl, #1405]!	@ 0x57d
      argv[argc++] = &line_buff[pos];
     998:	01e60000 	mvneq	r0, r0
     99c:	02af0000 	adceq	r0, pc, #0
}
     9a0:	01010000 	mrseq	r0, (UNDEF: 1)
static int prefix_match(char *sub, int len, const char *str) {
     9a4:	b0910350 	addslt	r0, r1, r0, asr r3
     9a8:	5101017e 	tstpl	r1, lr, ror r1
  if (sub == NULL || str == NULL || len <= 0 || len > strlen(str)) {
     9ac:	7ea09103 	tanvcs	f1, f3
     9b0:	05c20500 	strbeq	r0, [r2, #1280]	@ 0x500
     9b4:	01cf0000 	biceq	r0, pc, r0
     9b8:	02cc0000 	sbceq	r0, ip, #0
  for (int i = 0; i<len; ++i) {
     9bc:	01010000 	mrseq	r0, (UNDEF: 1)
     9c0:	10030550 	andne	r0, r3, r0, asr r5
    if (sub[i] != str[i]) {
     9c4:	01000024 	tsteq	r0, r4, lsr #32
     9c8:	74025101 	strvc	r5, [r2], #-257	@ 0xfffffeff
  for (int i = 0; i<len; ++i) {
     9cc:	ca050000 	bgt	1409d4 <__ROM_SIZE__+0x1009d4>
}
     9d0:	ba000005 	blt	9ec <handle_up_arrow+0xe>
  return TRUE;
     9d4:	e7000001 	str	r0, [r0, -r1]
      return FALSE;
     9d8:	01000002 	tsteq	r0, r2
}
     9dc:	91035001 	tstls	r3, r1
static void handle_up_arrow(char *cmd_buff, int *char_count) {
     9e0:	01017eb0 			@ <UNDEFINED> instruction: 0x01017eb0
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
     9e4:	00740251 	rsbseq	r0, r4, r1, asr r2
     9e8:	05d40500 	ldrbeq	r0, [r4, #1280]	@ 0x500
     9ec:	01cf0000 	biceq	r0, pc, r0
     9f0:	03010000 	movweq	r0, #4096	@ 0x1000
      curr_command_ptr == 0) {
     9f4:	01010000 	mrseq	r0, (UNDEF: 1)
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
     9f8:	00750250 	rsbseq	r0, r5, r0, asr r2
    printf("%s", cmd_buff);
     9fc:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
     a00:	05000074 	streq	r0, [r0, #-116]	@ 0xffffff8c
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
     a04:	000005de 	ldrdeq	r0, [r0], -lr
     a08:	00000195 	muleq	r0, r5, r1
  curr_command_ptr--;
     a0c:	00000320 	andeq	r0, r0, r0, lsr #6
     a10:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
     a14:	01010074 	tsteq	r1, r4, ror r0
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
     a18:	01400151 	cmpeq	r0, r1, asr r1
     a1c:	7d025201 	sfmvc	f5, 4, [r2, #-4]
     a20:	f4050000 	vst4.8	{d0-d3}, [r5], r0
     a24:	cf000005 	svcgt	0x00000005
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
     a28:	3a000001 	bcc	a34 <handle_up_arrow+0x56>
     a2c:	01000003 	tsteq	r0, r3
     a30:	75025001 	strvc	r5, [r2, #-1]
  *char_count = strlen(cmd_buff);
     a34:	51010100 	mrspl	r0, (UNDEF: 17)
     a38:	00007402 	andeq	r7, r0, r2, lsl #8
  printf("%s", cmd_buff);
     a3c:	0005fc05 	andeq	pc, r5, r5, lsl #24
     a40:	00017e00 	andeq	r7, r1, r0, lsl #28
     a44:	00035700 	andeq	r5, r3, r0, lsl #14
     a48:	50010100 	andpl	r0, r1, r0, lsl #2
     a4c:	24400305 	strbcs	r0, [r0], #-773	@ 0xfffffcfb
static void handle_down_arrow(char *cmd_buff, int *char_count) {
     a50:	01010000 	mrseq	r0, (UNDEF: 1)
     a54:	007d0251 	rsbseq	r0, sp, r1, asr r2
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
     a58:	06040500 	streq	r0, [r4], -r0, lsl #10
     a5c:	015f0000 	cmpeq	pc, r0
  *char_count = 0;
     a60:	03720000 	cmneq	r2, #0
  if (curr_command_ptr == total_num_commands) return;
     a64:	01010000 	mrseq	r0, (UNDEF: 1)
     a68:	b0910350 	addslt	r0, r1, r0, asr r3
     a6c:	5101017e 	tstpl	r1, lr, ror r1
  curr_command_ptr++;
     a70:	00007402 	andeq	r7, r0, r2, lsl #8
     a74:	00060c1b 	andeq	r0, r6, fp, lsl ip
     a78:	0001cf00 	andeq	ip, r1, r0, lsl #30
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
     a7c:	50010100 	andpl	r0, r1, r0, lsl #2
     a80:	24540305 	ldrbcs	r0, [r4], #-773	@ 0xfffffcfb
     a84:	01010000 	mrseq	r0, (UNDEF: 1)
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
     a88:	00740251 	rsbseq	r0, r4, r1, asr r2
     a8c:	ff1c0000 			@ <UNDEFINED> instruction: 0xff1c0000
     a90:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
     a94:	00000076 	andeq	r0, r0, r6, ror r0
  *char_count = strlen(cmd_buff);
     a98:	b1000017 	tstlt	r0, r7, lsl r0
     a9c:	05000003 	streq	r0, [r0, #-3]
  printf("%s", cmd_buff);
     aa0:	62040100 	andvs	r0, r4, #0, 2
     aa4:	12000006 	andne	r0, r0, #6
}
     aa8:	0000000d 	andeq	r0, r0, sp
     aac:	0004011d 	andeq	r0, r4, sp, lsl r1
void set_read_char(int (*func)(void)) { __read_char__ = func; }
     ab0:	00013a00 	andeq	r3, r1, r0, lsl #20
     ab4:	00062c00 	andeq	r2, r6, r0, lsl #24
     ab8:	0000d000 	andeq	sp, r0, r0
void set_read_char2(int (*func)(void)) { __read_char2__ = func; }
     abc:	00079800 	andeq	r9, r7, r0, lsl #16
     ac0:	06010200 	streq	r0, [r1], -r0, lsl #4
     ac4:	000000d9 	ldrdeq	r0, [r0], -r9
void set_write_char(void (*func)(char)) { __write_char__ = func; }
     ac8:	2b050202 	blcs	1412d8 <__ROM_SIZE__+0x1012d8>
     acc:	02000001 	andeq	r0, r0, #1
     ad0:	011b0504 	tsteq	fp, r4, lsl #10
void set_write_char2(void (*func)(char)) { __write_char2__ = func; }
     ad4:	08020000 	stmdaeq	r2, {}	@ <UNPREDICTABLE>
     ad8:	00011605 	andeq	r1, r1, r5, lsl #12
     adc:	08010200 	stmdaeq	r1, {r9}
}
     ae0:	000000d7 	ldrdeq	r0, [r0], -r7
}
     ae4:	e5070202 	str	r0, [r7, #-514]	@ 0xfffffdfe
  if (cmd_buff == NULL || char_count <= 0) {
     ae8:	02000000 	andeq	r0, r0, #0
static void handle_tab(char *cmd_buff, int *char_count) {
     aec:	00fd0704 	rscseq	r0, sp, r4, lsl #14
     af0:	08020000 	stmdaeq	r2, {}	@ <UNPREDICTABLE>
  int last_match = -1;
     af4:	0000f807 	andeq	pc, r0, r7, lsl #16
  int match_count = 0;
     af8:	05041300 	streq	r1, [r4, #-768]	@ 0xfffffd00
  int i = 0;
     afc:	00746e69 	rsbseq	r6, r4, r9, ror #28
    i++;
     b00:	02070402 	andeq	r0, r7, #33554432	@ 0x2000000
  while (table[i].command_name != NULL) { //loop over all commands
     b04:	0b000001 	bleq	b10 <handle_tab+0x2a>
     b08:	000003c6 	andeq	r0, r0, r6, asr #7
     b0c:	6517d603 	ldrvs	sp, [r7, #-1539]	@ 0xfffff9fd
    if (prefix_match(cmd_buff, *char_count, table[i].command_name)) {
     b10:	02000000 	andeq	r0, r0, #0
     b14:	01610408 	cmneq	r1, r8, lsl #8
     b18:	63140000 	tstvs	r4, #0
      match_count++;
     b1c:	0200646d 	andeq	r6, r0, #1828716544	@ 0x6d000000
      printf("\n%s", table[i].command_name);
     b20:	008b0f2d 	addeq	r0, fp, sp, lsr #30
     b24:	90050000 	andls	r0, r5, r0
      last_match = i;
     b28:	15000000 	strne	r0, [r0, #-0]
  if (match_count == 1) {
     b2c:	0000005e 	andeq	r0, r0, lr, asr r0
     b30:	000000a4 	andeq	r0, r0, r4, lsr #1
  if (match_count) {
     b34:	00005e03 	andeq	r5, r0, r3, lsl #28
}
     b38:	00a40300 	adceq	r0, r4, r0, lsl #6
    memcpy(cmd_buff, table[last_match].command_name, LINE_BUFF_SIZE);
     b3c:	05000000 	streq	r0, [r0, #-0]
     b40:	000000a9 	andeq	r0, r0, r9, lsr #1
     b44:	0000ae05 	andeq	sl, r0, r5, lsl #28
     b48:	08010200 	stmdaeq	r1, {r9}
    *char_count = strlen(cmd_buff);
     b4c:	000000e0 	andeq	r0, r0, r0, ror #1
     b50:	0000ae16 	andeq	sl, r0, r6, lsl lr
     b54:	020c1700 	andeq	r1, ip, #0, 14
    printf("\n");
     b58:	00e80936 	rsceq	r0, r8, r6, lsr r9
     b5c:	bd090000 	stclt	0, cr0, [r9, #-0]
    prepend_prompt();
     b60:	37000000 	strcc	r0, [r0, -r0]
    printf(PROMPT);
     b64:	0000e80f 	andeq	lr, r0, pc, lsl #16
     b68:	00090000 	andeq	r0, r9, r0
    printf("%s", cmd_buff);
     b6c:	38000000 	stmdacc	r0, {}	@ <UNPREDICTABLE>
     b70:	0000e80f 	andeq	lr, r0, pc, lsl #16
     b74:	b5090400 	strlt	r0, [r9, #-1024]	@ 0xfffffc00
     b78:	39000000 	stmdbcc	r0, {}	@ <UNPREDICTABLE>
     b7c:	00007f07 	andeq	r7, r0, r7, lsl #30
     b80:	05000800 	streq	r0, [r0, #-2048]	@ 0xfffff800
     b84:	000000b5 	strheq	r0, [r0], -r5
__attribute__((weak)) int active_prompt() { return TRUE; }
     b88:	00015b0b 	andeq	r5, r1, fp, lsl #22
static void shell(void) {
     b8c:	033a0200 	teqeq	sl, #0, 4
  int count = 0;
     b90:	000000ba 	strheq	r0, [r0], -sl
  for (int i = 0; i < LINE_BUFF_SIZE; i++) line_buff[i] = 0;
     b94:	00042b0c 	andeq	r2, r4, ip, lsl #22
     b98:	00ed3f00 	rsceq	r3, sp, r0, lsl #30
     b9c:	03050000 	movweq	r0, #20480	@ 0x5000
     ba0:	00002298 	muleq	r0, r8, r2
     ba4:	0003db0c 	andeq	sp, r3, ip, lsl #22
  for (int i = 0; i < MAX_ARG_COUNT; i++) argv[i] = NULL;
     ba8:	00ed4000 	rsceq	r4, sp, r0
     bac:	03050000 	movweq	r0, #20480	@ 0x5000
     bb0:	0000228c 	andeq	r2, r0, ip, lsl #5
     bb4:	0003cd07 	andeq	ip, r3, r7, lsl #26
     bb8:	0e4a0400 	cdpeq	4, 4, cr0, cr10, cr0, {0}
  prepend_prompt();
     bbc:	00000065 	andeq	r0, r0, r5, rrx
  printf(PROMPT);
     bc0:	00000139 	andeq	r0, r0, r9, lsr r1
  int special_key = 0;
     bc4:	00013903 	andeq	r3, r1, r3, lsl #18
        special_key = 1;
     bc8:	00650300 	rsbeq	r0, r5, r0, lsl #6
    if (s == -1) { s = __read_char2__();}
     bcc:	39030000 	stmdbcc	r3, {}	@ <UNPREDICTABLE>
     bd0:	00000001 	andeq	r0, r0, r1
    if (s != -1) {
     bd4:	00004205 	andeq	r4, r0, r5, lsl #4
     bd8:	01240700 			@ <UNDEFINED> instruction: 0x01240700
      loop();
     bdc:	2c050000 	stccs	0, cr0, [r5], {-0}
        line_buff[count] = END_OF_LINE;
     be0:	00005e05 	andeq	r5, r0, r5, lsl #28
     be4:	00015500 	andeq	r5, r1, r0, lsl #10
     be8:	00e80300 	rsceq	r0, r8, r0, lsl #6
     bec:	00180000 	andseq	r0, r8, r0
        __write_char__(NEW_LINE);
     bf0:	0003b807 	andeq	fp, r3, r7, lsl #16
     bf4:	0e3d0400 	cfabsseq	mvf0, mvf13
  add_command_to_history(line_buff);
     bf8:	00000065 	andeq	r0, r0, r5, rrx
  argc = parse_line(argv, line_buff, MAX_ARG_COUNT);
     bfc:	00000175 	andeq	r0, r0, r5, ror r1
     c00:	00013903 	andeq	r3, r1, r3, lsl #18
     c04:	00650300 	rsbeq	r0, r5, r0, lsl #6
  if (argc > 0) execute(argc, argv);
     c08:	39030000 	stmdbcc	r3, {}	@ <UNPREDICTABLE>
}
     c0c:	00000001 	andeq	r0, r0, r1
        if (!__echo) {
     c10:	0003f207 	andeq	pc, r3, r7, lsl #4
     c14:	081f0600 	ldmdaeq	pc, {r9, sl}	@ <UNPREDICTABLE>
        if (count == 0) continue;
     c18:	0000006c 	andeq	r0, r0, ip, rrx
        count--;
     c1c:	0000018b 	andeq	r0, r0, fp, lsl #3
        line_buff[count] = END_OF_LINE;
     c20:	0000e803 	andeq	lr, r0, r3, lsl #16
     c24:	df0d0000 	svcle	0x000d0000
     c28:	1f000003 	svcne	0x00000003
        delete ();
     c2c:	0000005e 	andeq	r0, r0, lr, asr r0
      if (__echo) {
     c30:	0000067c 	andeq	r0, r0, ip, ror r6
        __write_char__(c);
     c34:	00000080 	andeq	r0, r0, r0, lsl #1
     c38:	02c29c01 	sbceq	r9, r2, #256	@ 0x100
    if (!active_prompt()) {
     c3c:	35080000 	strcc	r0, [r8, #-0]
     c40:	1f000001 	svcne	0x00000001
    s = __read_char__();
     c44:	00005e12 	andeq	r5, r0, r2, lsl lr
     c48:	00012000 	andeq	r2, r1, r0
    if (s == -1) { s = __read_char2__();}
     c4c:	00011800 	andeq	r1, r1, r0, lsl #16
     c50:	00b00800 	adcseq	r0, r0, r0, lsl #16
      if (c == CARRIAGE_RETURN || c == NEW_LINE) {
     c54:	1f1f0000 	svcne	0x001f0000
     c58:	000000a4 	andeq	r0, r0, r4, lsr #1
      if (c == DELETE || c == BACK_SPACE) {
     c5c:	00000148 	andeq	r0, r0, r8, asr #2
     c60:	00000140 	andeq	r0, r0, r0, asr #2
      } else if (c == ESCAPE) {
     c64:	0006860a 	andeq	r8, r6, sl, lsl #12
      } else if (c == SQUARE_BRACKET_OPEN && special_key == 1) {
     c68:	00005200 	andeq	r5, r0, r0, lsl #4
      } else if ((c == 'C' || c == 'D') && special_key != 0) {
     c6c:	0002ae00 	andeq	sl, r2, r0, lsl #28
     c70:	656c0e00 	strbvs	r0, [ip, #-3584]!	@ 0xfffff200
     c74:	5e23006e 	cdppl	0, 2, cr0, cr3, cr14, {3}
      } else if ((c == 'A' || c == 'B') && special_key == 2) {
     c78:	77000000 	strvc	r0, [r0, -r0]
     c7c:	65000001 	strvs	r0, [r0, #-1]
      else if (c == TAB) {
     c80:	0a000001 	beq	c8c <shell+0x100>
        line_buff[count] = c;
     c84:	00000692 	muleq	r0, r2, r6
     c88:	0000003a 	andeq	r0, r0, sl, lsr r0
     c8c:	0000028b 	andeq	r0, r0, fp, lsl #5
        count++;
     c90:	0003e80f 	andeq	lr, r3, pc, lsl #16
     c94:	c2162700 	andsgt	r2, r6, #0, 14
          delete ();
     c98:	03000002 	movweq	r0, #2
          delete ();
     c9c:	047f8c91 	ldrbteq	r8, [pc], #-3217	@ ca4 <shell+0x118>
      } else if (c == SQUARE_BRACKET_OPEN && special_key == 1) {
     ca0:	0000069a 	muleq	r0, sl, r6
        special_key = 2;
     ca4:	0000013e 	andeq	r0, r0, lr, lsr r1
      } else if ((c == 'C' || c == 'D') && special_key != 0) {
     ca8:	00000221 	andeq	r0, r0, r1, lsr #4
        special_key = 0;
     cac:	05500101 	ldrbeq	r0, [r0, #-257]	@ 0xfffffeff
      } else if ((c == 'A' || c == 'B') && special_key == 2) {
     cb0:	00254003 	eoreq	r4, r5, r3
        if (!__echo) {
     cb4:	51010100 	mrspl	r0, (UNDEF: 17)
     cb8:	00007502 	andeq	r7, r0, r2, lsl #10
          clear_prompt(count + 4);
     cbc:	0006a404 	andeq	sl, r6, r4, lsl #8
     cc0:	00011900 	andeq	r1, r1, r0, lsl #18
        if (c == 'A') {
     cc4:	00023c00 	andeq	r3, r2, r0, lsl #24
          handle_down_arrow(line_buff, &count);
     cc8:	51010100 	mrspl	r0, (UNDEF: 17)
     ccc:	01007502 	tsteq	r0, r2, lsl #10
        continue;
     cd0:	91035201 	tstls	r3, r1, lsl #4
          clear_prompt(count);
     cd4:	04007f8c 	streq	r7, [r0], #-3980	@ 0xfffff074
     cd8:	000006ae 	andeq	r0, r0, lr, lsr #13
          handle_up_arrow(line_buff, &count);
     cdc:	0000013e 	andeq	r0, r0, lr, lsr r1
     ce0:	00000259 	andeq	r0, r0, r9, asr r2
        handle_tab(line_buff, &count);
     ce4:	05500101 	ldrbeq	r0, [r0, #-257]	@ 0xfffffeff
     ce8:	00256403 	eoreq	r6, r5, r3, lsl #8
        continue;
     cec:	51010100 	mrspl	r0, (UNDEF: 17)
  if (argc > 0) execute(argc, argv);
     cf0:	00007502 	andeq	r7, r0, r2, lsl #10
}
     cf4:	0006b404 	andeq	fp, r6, r4, lsl #8
     cf8:	00013e00 	andeq	r3, r1, r0, lsl #28
     cfc:	00027000 	andeq	r7, r2, r0
     d00:	50010100 	andpl	r0, r1, r0, lsl #2
void prompt() {
     d04:	25880305 	strcs	r0, [r8, #773]	@ 0x305
  initial_setup();
     d08:	06000000 	streq	r0, [r0], -r0
  exec_auto_cmds();
     d0c:	000006cc 	andeq	r0, r0, ip, asr #13
  setup();
     d10:	0000013e 	andeq	r0, r0, lr, lsr r1
    shell();
     d14:	05500101 	ldrbeq	r0, [r0, #-257]	@ 0xfffffeff
int exec(char *cmd_str) {
     d18:	0025b403 	eoreq	fp, r5, r3, lsl #8
     d1c:	52010100 	andpl	r0, r1, #0, 2
  argc = parse_line(argv, cmd_str, MAX_ARG_COUNT);
     d20:	7f8c9103 	svcvc	0x008c9103
     d24:	8c100000 	ldchi	0, cr0, [r0], {-0}
  if (argc > 0) execute(argc, argv);
     d28:	75000006 	strvc	r0, [r0, #-6]
  return __cmd_exec_status;
     d2c:	06000001 	streq	r0, [r0], -r1
}
     d30:	000006d6 	ldrdeq	r0, [r0], -r6
     d34:	0000013e 	andeq	r0, r0, lr, lsr r1
  if (argc > 0) execute(argc, argv);
     d38:	05500101 	ldrbeq	r0, [r0, #-257]	@ 0xfffffeff
     d3c:	0024f803 	eoreq	pc, r4, r3, lsl #16
     d40:	51010100 	mrspl	r0, (UNDEF: 17)
cmd get_function_addr(char *cmd_str) {
     d44:	00640802 	rsbeq	r0, r4, r2, lsl #16
  for (int i = 0; table[i].command_name != NULL; i++) {
     d48:	06de0600 	ldrbeq	r0, [lr], r0, lsl #12
     d4c:	013e0000 	teqeq	lr, r0
     d50:	01010000 	mrseq	r0, (UNDEF: 1)
     d54:	c8030550 	stmdagt	r3, {r4, r6, r8, sl}
     d58:	00000025 	andeq	r0, r0, r5, lsr #32
    if (strcmp(cmd_str, table[i].command_name) == 0) {
     d5c:	00ae1900 	adceq	r1, lr, r0, lsl #18
     d60:	02d20000 	sbcseq	r0, r2, #0
      return table[i].command;
     d64:	65110000 	ldrvs	r0, [r1, #-0]
     d68:	63000000 	movwvs	r0, #0
  return NULL;
     d6c:	042f0d00 	strteq	r0, [pc], #-3328	@ d74 <binary_to_base64>
}
     d70:	5e040000 	cdppl	0, 0, cr0, cr4, cr0, {0}
  if(v < 26) return v + 'A';
     d74:	2c000000 	stccs	0, cr0, [r0], {-0}
  if(v < 52) return v + 71;
     d78:	50000006 	andpl	r0, r0, r6
  if(v < 62) return v - 4;
     d7c:	01000000 	mrseq	r0, (UNDEF: 0)
  if(v == 62) return '+';
     d80:	0003a89c 	muleq	r3, ip, r8
  if(v == 63) return '/';
     d84:	01350800 	teqeq	r5, r0, lsl #16
  return 64;
     d88:	12040000 	andne	r0, r4, #0
  if(v < 26) return v + 'A';
     d8c:	0000005e 	andeq	r0, r0, lr, asr r0
     d90:	000001b9 			@ <UNDEFINED> instruction: 0x000001b9
  if(v < 52) return v + 71;
     d94:	000001b1 			@ <UNDEFINED> instruction: 0x000001b1
  if(v < 62) return v - 4;
     d98:	0000b008 	andeq	fp, r0, r8
     d9c:	a41f0400 	ldrge	r0, [pc], #-1024	@ da4 <binary_to_base64+0x30>
  if(v == 62) return '+';
     da0:	dc000000 	stcle	0, cr0, [r0], {-0}
}
     da4:	d4000001 	strle	r0, [r0], #-1
  if('A' <= c && c <= 'Z') return c - 'A';
     da8:	0a000001 	beq	db4 <base64_to_binary+0xe>
     dac:	00000636 	andeq	r0, r0, r6, lsr r6
  if('a' <= c && c <= 'z') return c - 71;
     db0:	0000002c 	andeq	r0, r0, ip, lsr #32
     db4:	00000394 	muleq	r0, r4, r3
     db8:	0003f90f 	andeq	pc, r3, pc, lsl #18
  if('0' <= c && c <= '9') return c + 4;
     dbc:	a8170a00 	ldmdage	r7, {r9, fp}
     dc0:	03000003 	movweq	r0, #3
  if(c == '+') return 62;
     dc4:	0e7f9491 	mrceq	4, 3, r9, cr15, cr1, {4}
  if(c == '/') return 63;
     dc8:	006e656c 	rsbeq	r6, lr, ip, ror #10
  return 255;
     dcc:	00005e0b 	andeq	r5, r0, fp, lsl #28
  if('a' <= c && c <= 'z') return c - 71;
     dd0:	0001fe00 	andeq	pc, r1, r0, lsl #28
     dd4:	0001f400 	andeq	pc, r1, r0, lsl #8
  if('0' <= c && c <= '9') return c + 4;
     dd8:	063c1000 	ldrteq	r1, [ip], -r0
  if(c == '+') return 62;
     ddc:	01750000 	cmneq	r5, r0
  if(c == '/') return 63;
     de0:	4a040000 	bmi	100de8 <__ROM_SIZE__+0xc0de8>
  return (input_length + 2)/3*4;
     de4:	55000006 	strpl	r0, [r0, #-6]
     de8:	5c000001 	stcpl	0, cr0, [r0], {1}
     dec:	01000003 	tsteq	r0, r3
}
     df0:	91035201 	tstls	r3, r1, lsl #4
     df4:	04007f94 	streq	r7, [r0], #-3988	@ 0xfffff06c
unsigned int decode_base64_length(unsigned char input[], unsigned int input_length) {
     df8:	00000656 	andeq	r0, r0, r6, asr r6
     dfc:	0000013e 	andeq	r0, r0, lr, lsr r1
  while(base64_to_binary(input[0]) < 64 && (unsigned int) (input - start) < input_length) {
     e00:	0000037a 	andeq	r0, r0, sl, ror r3
     e04:	05500101 	ldrbeq	r0, [r0, #-257]	@ 0xfffffeff
     e08:	0024d003 	eoreq	sp, r4, r3
     e0c:	52010100 	andpl	r0, r1, #0, 2
     e10:	7f949103 	svcvc	0x00949103
  input_length = input - start;
     e14:	06600600 	strbteq	r0, [r0], -r0, lsl #12
  return input_length/4*3 + (input_length % 4 ? input_length % 4 - 1 : 0);
     e18:	013e0000 	teqeq	lr, r0
     e1c:	01010000 	mrseq	r0, (UNDEF: 1)
     e20:	f8030550 			@ <UNDEFINED> instruction: 0xf8030550
}
     e24:	01000024 	tsteq	r0, r4, lsr #32
  return input_length/4*3 + (input_length % 4 ? input_length % 4 - 1 : 0);
     e28:	08025101 	stmdaeq	r2, {r0, r8, ip, lr}
unsigned int encode_base64(unsigned char input[], unsigned int input_length, unsigned char output[]) {
     e2c:	06000064 	streq	r0, [r0], -r4, rrx
     e30:	00000668 	andeq	r0, r0, r8, ror #12
     e34:	0000013e 	andeq	r0, r0, lr, lsr r1
  unsigned int full_sets = input_length/3;
     e38:	05500101 	ldrbeq	r0, [r0, #-257]	@ 0xfffffeff
     e3c:	00252403 	eoreq	r2, r5, r3, lsl #8
  for(unsigned int i = 0; i < full_sets; ++i) {
     e40:	1a000000 	bne	e48 <encode_base64+0x1c>
    output[0] = binary_to_base64(                         input[0] >> 2);
     e44:	00000042 	andeq	r0, r0, r2, asr #32
     e48:	00006511 	andeq	r6, r0, r1, lsl r5
    output[1] = binary_to_base64((input[0] & 0x03) << 4 | input[1] >> 4);
     e4c:	00006300 	andeq	r6, r0, r0, lsl #6
     e50:	0000018b 	andeq	r0, r0, fp, lsl #3
     e54:	04010005 	streq	r0, [r1], #-5
     e58:	000007c5 	andeq	r0, r0, r5, asr #15
     e5c:	00000d09 	andeq	r0, r0, r9, lsl #26
    output[2] = binary_to_base64((input[1] & 0x0F) << 2 | input[2] >> 6);
     e60:	04461d00 	strbeq	r1, [r6], #-3328	@ 0xfffff300
     e64:	013a0000 	teqeq	sl, r0
     e68:	06fc0000 	ldrbteq	r0, [ip], r0
     e6c:	001c0000 	andseq	r0, ip, r0
     e70:	09a40000 	stmibeq	r4!, {}	@ <UNPREDICTABLE>
    output[3] = binary_to_base64( input[2] & 0x3F);
     e74:	01010000 	mrseq	r0, (UNDEF: 1)
     e78:	0000d906 	andeq	sp, r0, r6, lsl #18
     e7c:	05020100 	streq	r0, [r2, #-256]	@ 0xffffff00
    input += 3;
     e80:	0000012b 	andeq	r0, r0, fp, lsr #2
  for(unsigned int i = 0; i < full_sets; ++i) {
     e84:	1b050401 	blne	141e90 <__ROM_SIZE__+0x101e90>
     e88:	01000001 	tsteq	r0, r1
  switch(input_length % 3) {
     e8c:	01160508 	tsteq	r6, r8, lsl #10
     e90:	01010000 	mrseq	r0, (UNDEF: 1)
     e94:	0000d708 	andeq	sp, r0, r8, lsl #14
     e98:	07020100 	streq	r0, [r2, -r0, lsl #2]
     e9c:	000000e5 	andeq	r0, r0, r5, ror #1
     ea0:	fd070401 	stc2	4, cr0, [r7, #-4]
     ea4:	01000000 	mrseq	r0, (UNDEF: 0)
  return encode_base64_length(input_length);
     ea8:	00f80708 	rscseq	r0, r8, r8, lsl #14
}
     eac:	040a0000 	streq	r0, [sl], #-0
      output[0] = '\0';
     eb0:	746e6905 	strbtvc	r6, [lr], #-2309	@ 0xfffff6fb
      output[0] = binary_to_base64(                         input[0] >> 2);
     eb4:	07040100 	streq	r0, [r4, -r0, lsl #2]
     eb8:	00000102 	andeq	r0, r0, r2, lsl #2
     ebc:	61040801 	tstvs	r4, r1, lsl #16
      output[1] = binary_to_base64((input[0] & 0x03) << 4);
     ec0:	0b000001 	bleq	ecc <encode_base64+0xa0>
     ec4:	00646d63 	rsbeq	r6, r4, r3, ror #26
     ec8:	7f0f2d02 	svcvc	0x000f2d02
      output[2] = '=';
     ecc:	02000000 	andeq	r0, r0, #0
      output[3] = '=';
     ed0:	00000084 	andeq	r0, r0, r4, lsl #1
      output[4] = '\0';
     ed4:	00005e0c 	andeq	r5, r0, ip, lsl #28
      output[0] = binary_to_base64(                         input[0] >> 2);
     ed8:	00009800 	andeq	r9, r0, r0, lsl #16
     edc:	005e0300 	subseq	r0, lr, r0, lsl #6
     ee0:	98030000 	stmdals	r3, {}	@ <UNPREDICTABLE>
      output[1] = binary_to_base64((input[0] & 0x03) << 4 | input[1] >> 4);
     ee4:	00000000 	andeq	r0, r0, r0
     ee8:	00009d02 	andeq	r9, r0, r2, lsl #26
     eec:	00a20200 	adceq	r0, r2, r0, lsl #4
     ef0:	01010000 	mrseq	r0, (UNDEF: 1)
     ef4:	0000e008 	andeq	lr, r0, r8
      output[2] = binary_to_base64((input[1] & 0x0F) << 2);
     ef8:	00a20d00 	adceq	r0, r2, r0, lsl #26
     efc:	0c0e0000 	stceq	0, cr0, [lr], {-0}
     f00:	dc093602 	stcle	6, cr3, [r9], {2}
      output[3] = '=';
     f04:	04000000 	streq	r0, [r0], #-0
      output[4] = '\0';
     f08:	000000bd 	strheq	r0, [r0], -sp
      break;
     f0c:	00dc0f37 	sbcseq	r0, ip, r7, lsr pc
     f10:	04000000 	streq	r0, [r0], #-0
unsigned int decode_base64(unsigned char input[], unsigned int input_length, unsigned char output[]) {
     f14:	00000000 	andeq	r0, r0, r0
     f18:	00dc0f38 	sbcseq	r0, ip, r8, lsr pc
  unsigned int output_length = decode_base64_length(input, input_length);
     f1c:	04040000 	streq	r0, [r4], #-0
     f20:	000000b5 	strheq	r0, [r0], -r5
  for(unsigned int i = 2; i < output_length; i += 3) {
     f24:	00730739 	rsbseq	r0, r3, r9, lsr r7
    output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
     f28:	00080000 	andeq	r0, r8, r0
     f2c:	0000a902 	andeq	sl, r0, r2, lsl #18
     f30:	015b0f00 	cmpeq	fp, r0, lsl #30
     f34:	3a020000 	bcc	80f3c <__ROM_SIZE__+0x40f3c>
     f38:	0000ae03 	andeq	sl, r0, r3, lsl #28
    output[1] = base64_to_binary(input[1]) << 4 | base64_to_binary(input[2]) >> 2;
     f3c:	04381000 	ldrteq	r1, [r8], #-0
     f40:	0c010000 	stceq	0, cr0, [r1], {-0}
     f44:	0000e101 	andeq	lr, r0, r1, lsl #2
     f48:	a4030500 	strge	r0, [r3], #-1280	@ 0xfffffb00
     f4c:	05000022 	streq	r0, [r0, #-34]	@ 0xffffffde
    output[2] = base64_to_binary(input[2]) << 6 | base64_to_binary(input[3]);
     f50:	00000314 	andeq	r0, r0, r4, lsl r3
     f54:	00005e2d 	andeq	r5, r0, sp, lsr #28
     f58:	00011400 	andeq	r1, r1, r0, lsl #8
     f5c:	00dc0300 	sbcseq	r0, ip, r0, lsl #6
    input += 4;
     f60:	00060000 	andeq	r0, r6, r0
  for(unsigned int i = 2; i < output_length; i += 3) {
     f64:	00012405 	andeq	r2, r1, r5, lsl #8
     f68:	005e2c00 	subseq	r2, lr, r0, lsl #24
  switch(output_length % 3) {
     f6c:	01290000 			@ <UNDEFINED> instruction: 0x01290000
     f70:	dc030000 	stcle	0, cr0, [r3], {-0}
     f74:	06000000 	streq	r0, [r0], -r0
     f78:	043c1100 	ldrteq	r1, [ip], #-256	@ 0xffffff00
     f7c:	05010000 	streq	r0, [r1, #-0]
     f80:	00005e05 	andeq	r5, r0, r5, lsl #28
     f84:	0006fc00 	andeq	pc, r6, r0, lsl #24
     f88:	00001c00 	andeq	r1, r0, r0, lsl #24
      output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
     f8c:	079c0100 	ldreq	r0, [ip, r0, lsl #2]
     f90:	00000135 	andeq	r0, r0, r5, lsr r1
     f94:	00005e13 	andeq	r5, r0, r3, lsl lr
     f98:	00022800 	andeq	r2, r2, r0, lsl #16
     f9c:	00022400 	andeq	r2, r2, r0, lsl #8
      output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
     fa0:	00b00700 	adcseq	r0, r0, r0, lsl #14
     fa4:	98200000 	stmdals	r0!, {}	@ <UNPREDICTABLE>
     fa8:	3a000000 	bcc	fb0 <decode_base64+0x9c>
     fac:	36000002 	strcc	r0, [r0], -r2
     fb0:	12000002 	andne	r0, r0, #2
      output[1] = base64_to_binary(input[1]) << 4 | base64_to_binary(input[2]) >> 2;
     fb4:	00000704 	andeq	r0, r0, r4, lsl #14
     fb8:	00000114 	andeq	r0, r0, r4, lsl r1
     fbc:	0000017a 	andeq	r0, r0, sl, ror r1
     fc0:	05500108 	ldrbeq	r0, [r0, #-264]	@ 0xfffffef8
     fc4:	00265c03 	eoreq	r5, r6, r3, lsl #24
  return output_length;
     fc8:	0a130000 	beq	4c0fd0 <__ROM_SIZE__+0x480fd0>
     fcc:	ff000007 			@ <UNDEFINED> instruction: 0xff000007
static void outstr(const char *str) {
     fd0:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
  while (*str != '\0') {
     fd4:	03055001 	movweq	r5, #20481	@ 0x5001
    __write_char__(*str);
     fd8:	00002670 	andeq	r2, r0, r0, ror r6
    str++;
     fdc:	df000000 	svcle	0x00000000
  while (*str != '\0') {
     fe0:	0500000e 	streq	r0, [r0, #-14]
}
     fe4:	d0040100 	andle	r0, r4, r0, lsl #2
     fe8:	28000008 	stmdacs	r0, {r3}
static bool printf_numbers(const char fmt, va_list *args, int l_count) {
     fec:	0000000d 	andeq	r0, r0, sp
     ff0:	0005421d 	andeq	r4, r5, sp, lsl r2
  switch (fmt) {
     ff4:	00013a00 	andeq	r3, r1, r0, lsl #20
     ff8:	00071800 	andeq	r1, r7, r0, lsl #16
     ffc:	00065c00 	andeq	r5, r6, r0, lsl #24
      if (l_count == 0) {
    1000:	000a6e00 	andeq	r6, sl, r0, lsl #28
    1004:	06010800 	streq	r0, [r1], -r0, lsl #16
        value = va_arg(*args, unsigned int);
    1008:	000000d9 	ldrdeq	r0, [r0], -r9
    100c:	2b050208 	blcs	141834 <__ROM_SIZE__+0x101834>
      if (fmt == 'u') {
    1010:	08000001 	stmdaeq	r0, {r0}
        if (value == 0) {
    1014:	011b0504 	tsteq	fp, r4, lsl #10
          __write_char__(hextable[0]);
    1018:	08080000 	stmdaeq	r8, {}	@ <UNPREDICTABLE>
    101c:	00011605 	andeq	r1, r1, r5, lsl #12
  return true;
    1020:	08010800 	stmdaeq	r1, {fp}
  switch (fmt) {
    1024:	000000d7 	ldrdeq	r0, [r0], -r7
      outstr("\nprintf-error\n");
    1028:	e5070208 	str	r0, [r7, #-520]	@ 0xfffffdf8
      return false;
    102c:	16000000 	strne	r0, [r0], -r0
}
    1030:	0000016d 	andeq	r0, r0, sp, ror #2
      if (l_count == 0) {
    1034:	5c193402 	cfldrspl	mvf3, [r9], {2}
        value = va_arg(*args, int);
    1038:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
    103c:	00fd0704 	rscseq	r0, sp, r4, lsl #14
      if (value < 0) {
    1040:	08080000 	stmdaeq	r8, {}	@ <UNPREDICTABLE>
        num[num_len++] = hextable[value % 10];
    1044:	0000f807 	andeq	pc, r0, r7, lsl #16
    1048:	05042900 	streq	r2, [r4, #-2304]	@ 0xfffff700
    104c:	00746e69 	rsbseq	r6, r4, r9, ror #28
    1050:	00006a17 	andeq	r6, r0, r7, lsl sl
    1054:	07040800 	streq	r0, [r4, -r0, lsl #16]
    1058:	00000102 	andeq	r0, r0, r2, lsl #2
    105c:	0003c616 	andeq	ip, r3, r6, lsl r6
    1060:	17d60300 	ldrbne	r0, [r6, r0, lsl #6]
    1064:	00000076 	andeq	r0, r0, r6, ror r0
        value = value / 10;
    1068:	61040808 	tstvs	r4, r8, lsl #16
      } while (value > 0);
    106c:	2a000001 	bcs	1078 <printf_numbers+0x8c>
    1070:	00646d63 	rsbeq	r6, r4, r3, ror #26
        __write_char__('-');
    1074:	9c0f2d04 	stcls	13, cr2, [pc], {4}
    1078:	09000000 	stmdbeq	r0, {}	@ <UNPREDICTABLE>
        value = -value;
    107c:	000000a1 	andeq	r0, r0, r1, lsr #1
        __write_char__(num[--num_len]);
    1080:	00006a2b 	andeq	r6, r0, fp, lsr #20
    1084:	0000b500 	andeq	fp, r0, r0, lsl #10
    1088:	006a0500 	rsbeq	r0, sl, r0, lsl #10
    108c:	b5050000 	strlt	r0, [r5, #-0]
    1090:	00000000 	andeq	r0, r0, r0
      while (num_len > 0) {
    1094:	0000ba09 	andeq	fp, r0, r9, lsl #20
  return true;
    1098:	00bf0900 	adcseq	r0, pc, r0, lsl #18
          num[num_len++] = hextable[value % 10];
    109c:	01080000 	mrseq	r0, (UNDEF: 8)
    10a0:	0000e008 	andeq	lr, r0, r8
    10a4:	00bf2100 	adcseq	r2, pc, r0, lsl #2
    10a8:	0c2c0000 	stceq	0, cr0, [ip], #-0
    10ac:	f9093604 			@ <UNDEFINED> instruction: 0xf9093604
    10b0:	18000000 	stmdane	r0, {}	@ <UNPREDICTABLE>
    10b4:	000000bd 	strheq	r0, [r0], -sp
    10b8:	00f90f37 	rscseq	r0, r9, r7, lsr pc
          value = value / 10;
    10bc:	18000000 	stmdane	r0, {}	@ <UNPREDICTABLE>
        } while (value > 0);
    10c0:	00000000 	andeq	r0, r0, r0
        while (num_len > 0) {
    10c4:	00f90f38 	rscseq	r0, r9, r8, lsr pc
          __write_char__(num[--num_len]);
    10c8:	18040000 	stmdane	r4, {}	@ <UNPREDICTABLE>
    10cc:	000000b5 	strheq	r0, [r0], -r5
    10d0:	00900739 	addseq	r0, r0, r9, lsr r7
    10d4:	00080000 	andeq	r0, r8, r0
    10d8:	0000c609 	andeq	ip, r0, r9, lsl #12
    10dc:	015b1600 	cmpeq	fp, r0, lsl #12
  return true;
    10e0:	3a040000 	bcc	1010e8 <__ROM_SIZE__+0xc10e8>
              __write_char__(hextable[val]);
    10e4:	0000cb03 	andeq	ip, r0, r3, lsl #22
    10e8:	00fe2100 	rscseq	r2, lr, r0, lsl #2
              leading_zero_ignored = true;
    10ec:	fe170000 	cdp2	0, 1, cr0, cr7, cr0, {0}
          while (start_bit >= 0) {
    10f0:	2d000000 	stccs	0, cr0, [r0, #-0]
            int val = (value >> start_bit) & 0xF;
    10f4:	0000006a 	andeq	r0, r0, sl, rrx
            if (val || leading_zero_ignored) {
    10f8:	0004e80e 	andeq	lr, r4, lr, lsl #16
    10fc:	2a071800 	bcs	1c7104 <__ROM_SIZE__+0x187104>
    1100:	05000001 	streq	r0, [r0, #-1]
          bool leading_zero_ignored = false;
    1104:	00011803 	andeq	r1, r1, r3, lsl #16
          int start_bit = LAST_NIBBLE_FIRST_BIT;
    1108:	01140920 	tsteq	r4, r0, lsr #18
  return true;
    110c:	080e0000 	stmdaeq	lr, {}	@ <UNPREDICTABLE>
        return false;
    1110:	19000007 	stmdbne	r0, {r0, r1, r2}
        return false;
    1114:	00012a07 	andeq	r2, r1, r7, lsl #20
    1118:	1c030500 	cfstr32ne	mvfx0, [r3], {-0}
    111c:	2e200001 	cdpcs	0, 2, cr0, cr0, cr1, {0}
    1120:	0000014b 	andeq	r0, r0, fp, asr #2
    1124:	0000bf05 	andeq	fp, r0, r5, lsl #30
    1128:	7e0e0000 	cdpvc	0, 0, cr0, cr14, cr0, {0}
int printf(const char *fmt, ...) {
    112c:	1a000006 	bne	114c <printf+0x20>
    1130:	00015c08 	andeq	r5, r1, r8, lsl #24
    1134:	08030500 	stmdaeq	r3, {r8, sl}
  va_start(args, fmt);
    1138:	09200000 	stmdbeq	r0!, {}	@ <UNPREDICTABLE>
  while (*fmt) {
    113c:	00000140 	andeq	r0, r0, r0, asr #2
        if (*fmt == '%') {
    1140:	0004840e 	andeq	r8, r4, lr, lsl #8
        __write_char__(*fmt);
    1144:	5c081b00 			@ <UNDEFINED> instruction: 0x5c081b00
        fmt++;
    1148:	05000001 	streq	r0, [r0, #-1]
  while (*fmt) {
    114c:	00012003 	andeq	r2, r1, r3
    switch (state) {
    1150:	059d2220 	ldreq	r2, [sp, #544]	@ 0x220
    1154:	5c1d0000 	ldcpl	0, cr0, [sp], {-0}
          fmt++;
    1158:	22000000 	andcs	r0, r0, #0
          continue;
    115c:	0000060c 	andeq	r0, r0, ip, lsl #12
        while (*fmt && ((*fmt >= '0' && *fmt <= '9') || *fmt == '-')) {
    1160:	00005c1e 	andeq	r5, r0, lr, lsl ip
    1164:	01e02300 	mvneq	r2, r0, lsl #6
    1168:	90200000 	eorls	r0, r0, r0
    116c:	09000001 	stmdbeq	r0, {r0}
    1170:	0000010a 	andeq	r0, r0, sl, lsl #2
        switch (*fmt) {
    1174:	00051f23 	andeq	r1, r5, r3, lsr #30
    1178:	01902100 	orrseq	r2, r0, r0, lsl #2
    117c:	ba0a0000 	blt	281184 <__ROM_SIZE__+0x241184>
    1180:	22000004 	andcs	r0, r0, #4
            __write_char__(*fmt);
    1184:	00007115 	andeq	r7, r0, r5, lsl r1
    1188:	10030500 	andne	r0, r3, r0, lsl #10
            state = CHECK_CH;
    118c:	0a200001 	beq	801198 <__ROM_SIZE__+0x7c1198>
            break;
    1190:	000005f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
    1194:	0071152a 	rsbseq	r1, r1, sl, lsr #10
            outstr(va_arg(args, const char *));
    1198:	03050000 	movweq	r0, #20480	@ 0x5000
    119c:	2000000c 	andcs	r0, r0, ip
    11a0:	0006c60a 	andeq	ip, r6, sl, lsl #12
            fmt++;
    11a4:	71152b00 	tstvc	r5, r0, lsl #22
            break;
    11a8:	05000000 	streq	r0, [r0, #-0]
            __write_char__(va_arg(args, int));
    11ac:	00011403 	andeq	r1, r1, r3, lsl #8
    11b0:	00bf1920 	adcseq	r1, pc, r0, lsr #18
    11b4:	01e80000 	mvneq	r0, r0
            fmt++;
    11b8:	76110000 	ldrvc	r0, [r1], -r0
            break;
    11bc:	01000000 	mrseq	r0, (UNDEF: 0)
            if (*fmt == 'l') {
    11c0:	00007611 	andeq	r7, r0, r1, lsl r6
    11c4:	0a007f00 	beq	20dcc <__RAM_SIZE__+0x18dcc>
            if (printf_numbers(*fmt, &args, l_count)) {
    11c8:	00000536 	andeq	r0, r0, r6, lsr r5
    11cc:	01d20d2c 	bicseq	r0, r2, ip, lsr #26
    11d0:	03050000 	movweq	r0, #20480	@ 0x5000
              state = CHECK_CH;
    11d4:	20000010 	andcs	r0, r0, r0, lsl r0
              fmt++;
    11d8:	0006f70a 	andeq	pc, r6, sl, lsl #14
              l_count++;
    11dc:	11162f00 	tstne	r6, r0, lsl #30
            if (printf_numbers(*fmt, &args, 0)) {
    11e0:	05000002 	streq	r0, [r0, #-2]
    11e4:	00000003 	andeq	r0, r0, r3
              fmt++;
    11e8:	02010820 	andeq	r0, r1, #32, 16	@ 0x200000
              break;
    11ec:	00000657 	andeq	r0, r0, r7, asr r6
            return -1;
    11f0:	00020a17 	andeq	r0, r2, r7, lsl sl
}
    11f4:	049b0e00 	ldreq	r0, [fp], #3584	@ 0xe00
    11f8:	01920000 	orrseq	r0, r2, r0
            return -1;
    11fc:	000000fe 	strdeq	r0, [r0], -lr
    1200:	22c80305 	sbccs	r0, r8, #335544320	@ 0x14000000
    1204:	3b1a0000 	blcc	68120c <__ROM_SIZE__+0x64120c>
static void outstr2(const char *str) {
    1208:	e5000006 	str	r0, [r0, #-6]
  while (*str != '\0') {
    120c:	0000fe01 	andeq	pc, r0, r1, lsl #28
    __write_char2__(*str);
    1210:	10030500 	andne	r0, r3, r0, lsl #10
    str++;
    1214:	1a000023 	bne	12a8 <printf2_numbers+0x84>
  while (*str != '\0') {
    1218:	0000050b 	andeq	r0, r0, fp, lsl #10
}
    121c:	00fe01e6 	rscseq	r0, lr, r6, ror #3
    1220:	03050000 	movweq	r0, #20480	@ 0x5000
static bool printf2_numbers(const char fmt, va_list *args, int l_count) {
    1224:	000022bc 			@ <UNDEFINED> instruction: 0x000022bc
    1228:	0004d41a 	andeq	sp, r4, sl, lsl r4
  switch (fmt) {
    122c:	fe01e700 	cdp2	7, 0, cr14, cr1, cr0, {0}
    1230:	05000000 	streq	r0, [r0, #-0]
    1234:	0022b003 	eoreq	fp, r2, r3
      if (l_count == 0) {
    1238:	06032400 	streq	r2, [r3], -r0, lsl #8
    123c:	01eb0000 	mvneq	r0, r0
        value = va_arg(*args, unsigned int);
    1240:	00010f3c 	andeq	r0, r1, ip, lsr pc
    1244:	1c030500 	cfstr32ne	mvfx0, [r3], {-0}
      if (fmt == 'u') {
    1248:	0f000023 	svceq	0x00000023
        if (value == 0) {
    124c:	00000596 	muleq	r0, r6, r5
          __write_char2__(hextable2[0]);
    1250:	8c074105 	stfhis	f4, [r7], {5}
    1254:	8c000002 	stchi	0, cr0, [r0], {2}
  return true;
    1258:	05000002 	streq	r0, [r0, #-2]
  switch (fmt) {
    125c:	0000028c 	andeq	r0, r0, ip, lsl #5
      outstr2("\nprintf2-error\n");
    1260:	00006a05 	andeq	r6, r0, r5, lsl #20
      return false;
    1264:	007d0500 	rsbseq	r0, sp, r0, lsl #10
}
    1268:	2f000000 	svccs	0x00000000
      if (l_count == 0) {
    126c:	03f20f04 	mvnseq	r0, #4, 30
        value = va_arg(*args, int);
    1270:	1f050000 	svcne	0x00050000
    1274:	00007d08 	andeq	r7, r0, r8, lsl #26
      if (value < 0) {
    1278:	0002a400 	andeq	sl, r2, r0, lsl #8
        num[num_len++] = hextable2[value % 10];
    127c:	00f90500 	rscseq	r0, r9, r0, lsl #10
    1280:	0f000000 	svceq	0x00000000
    1284:	00000504 	andeq	r0, r0, r4, lsl #10
    1288:	8c073805 	stchi	8, cr3, [r7], {5}
    128c:	c4000002 	strgt	r0, [r0], #-2
    1290:	05000002 	streq	r0, [r0, #-2]
    1294:	0000028c 	andeq	r0, r0, ip, lsl #5
    1298:	0002c405 	andeq	ip, r2, r5, lsl #8
    129c:	007d0500 	rsbseq	r0, sp, r0, lsl #10
        value = value / 10;
    12a0:	09000000 	stmdbeq	r0, {}	@ <UNPREDICTABLE>
      } while (value > 0);
    12a4:	000002c9 	andeq	r0, r0, r9, asr #5
    12a8:	010f0f30 	tsteq	pc, r0, lsr pc	@ <UNPREDICTABLE>
        __write_char2__('-');
    12ac:	27050000 	strcs	r0, [r5, -r0]
    12b0:	00006a05 	andeq	r6, r0, r5, lsl #20
        value = -value;
    12b4:	0002e500 	andeq	lr, r2, r0, lsl #10
        __write_char2__(num[--num_len]);
    12b8:	00f90500 	rscseq	r0, r9, r0, lsl #10
    12bc:	f9050000 			@ <UNDEFINED> instruction: 0xf9050000
    12c0:	00000000 	andeq	r0, r0, r0
    12c4:	0002fd31 	andeq	pc, r2, r1, lsr sp	@ <UNPREDICTABLE>
    12c8:	06880400 	streq	r0, [r8], r0, lsl #8
      while (num_len > 0) {
    12cc:	0001240f 	andeq	r2, r1, pc, lsl #8
  return true;
    12d0:	052c0600 	streq	r0, [ip, #-1536]!	@ 0xfffffa00
          num[num_len++] = hextable2[value % 10];
    12d4:	0000006a 	andeq	r0, r0, sl, rrx
    12d8:	00000304 	andeq	r0, r0, r4, lsl #6
    12dc:	0000f905 	andeq	pc, r0, r5, lsl #18
    12e0:	12003200 	andne	r3, r0, #0, 4
    12e4:	000004bc 			@ <UNDEFINED> instruction: 0x000004bc
    12e8:	006a01df 	ldrdeq	r0, [sl], #-31	@ 0xffffffe1	@ <UNPREDICTABLE>
    12ec:	08180000 	ldmdaeq	r8, {}	@ <UNPREDICTABLE>
    12f0:	001c0000 	andseq	r0, ip, r0
          value = value / 10;
    12f4:	9c010000 	stcls	0, cr0, [r1], {-0}
        } while (value > 0);
    12f8:	00000359 	andeq	r0, r0, r9, asr r3
        while (num_len > 0) {
    12fc:	0001350b 	andeq	r3, r1, fp, lsl #10
          __write_char2__(num[--num_len]);
    1300:	1901df00 	stmdbne	r1, {r8, r9, sl, fp, ip, lr, pc}
    1304:	0000006a 	andeq	r0, r0, sl, rrx
    1308:	00000258 	andeq	r0, r0, r8, asr r2
    130c:	00000254 	andeq	r0, r0, r4, asr r2
    1310:	0000b00b 	andeq	fp, r0, fp
    1314:	2601df00 	strcs	sp, [r1], -r0, lsl #30
  return true;
    1318:	000000b5 	strheq	r0, [r0], -r5
              __write_char2__(hextable2[val]);
    131c:	0000026e 	andeq	r0, r0, lr, ror #4
    1320:	0000026a 	andeq	r0, r0, sl, ror #4
              leading_zero_ignored = true;
    1324:	00082606 	andeq	r2, r8, r6, lsl #12
          while (start_bit >= 0) {
    1328:	0002ed00 	andeq	lr, r2, r0, lsl #26
            int val = (value >> start_bit) & 0xF;
    132c:	50010100 	andpl	r0, r1, r0, lsl #2
            if (val || leading_zero_ignored) {
    1330:	26a40305 	strtcs	r0, [r4], r5, lsl #6
    1334:	00000000 	andeq	r0, r0, r0
    1338:	00000812 	andeq	r0, r0, r2, lsl r8
          bool leading_zero_ignored = false;
    133c:	6a01c500 	bvs	72744 <__ROM_SIZE__+0x32744>
          int start_bit = LAST_NIBBLE_FIRST_BIT;
    1340:	a0000000 	andge	r0, r0, r0
  return true;
    1344:	68000008 	stmdavs	r0, {r3}
        return false;
    1348:	01000000 	mrseq	r0, (UNDEF: 0)
        return false;
    134c:	00042f9c 	muleq	r4, ip, pc	@ <UNPREDICTABLE>
    1350:	01350b00 	teqeq	r5, r0, lsl #22
    1354:	01c50000 	biceq	r0, r5, r0
    1358:	00006a0e 	andeq	r6, r0, lr, lsl #20
    135c:	00028400 	andeq	r8, r2, r0, lsl #8
    1360:	00028000 	andeq	r8, r2, r0
int printf2(const char *fmt, ...) {
    1364:	00b00b00 	adcseq	r0, r0, r0, lsl #22
    1368:	01c50000 	biceq	r0, r5, r0
    136c:	0000b51b 	andeq	fp, r0, fp, lsl r5
  va_start(args, fmt);
    1370:	00029c00 	andeq	r9, r2, r0, lsl #24
  while (*fmt) {
    1374:	00029600 	andeq	r9, r2, r0, lsl #12
        if (*fmt == '%') {
    1378:	00691300 	rsbeq	r1, r9, r0, lsl #6
        __write_char2__(*fmt);
    137c:	6a0701c6 	bvs	1c1a9c <__ROM_SIZE__+0x181a9c>
        fmt++;
    1380:	bd000000 	stclt	0, cr0, [r0, #-0]
  while (*fmt) {
    1384:	b5000002 	strlt	r0, [r0, #-2]
    switch (state) {
    1388:	25000002 	strcs	r0, [r0, #-2]
    138c:	000004cc 	andeq	r0, r0, ip, asr #9
          fmt++;
    1390:	0a0801c8 	beq	201ab8 <__ROM_SIZE__+0x1c1ab8>
          continue;
    1394:	e4000002 	str	r0, [r0], #-2
        while (*fmt && ((*fmt >= '0' && *fmt <= '9') || *fmt == '-')) {
    1398:	dc000002 	stcle	0, cr0, [r0], {2}
    139c:	02000002 	andeq	r0, r0, #2
    13a0:	000008b0 			@ <UNDEFINED> instruction: 0x000008b0
    13a4:	000002ca 	andeq	r0, r0, sl, asr #5
    13a8:	000003d7 	ldrdeq	r0, [r0], -r7
        switch (*fmt) {
    13ac:	05510101 	ldrbeq	r0, [r1, #-257]	@ 0xfffffeff
    13b0:	00273003 	eoreq	r3, r7, r3
    13b4:	b8020000 	stmdalt	r2, {}	@ <UNPREDICTABLE>
    13b8:	ed000008 	stc	0, cr0, [r0, #-32]	@ 0xffffffe0
            __write_char2__(*fmt);
    13bc:	ee000002 	cdp	0, 0, cr0, cr0, cr2, {0}
    13c0:	01000003 	tsteq	r0, r3
            state = CHECK_CH;
    13c4:	03055001 	movweq	r5, #20481	@ 0x5001
            break;
    13c8:	00002734 	andeq	r2, r0, r4, lsr r7
    13cc:	08c40200 	stmiaeq	r4, {r9}^
            outstr2(va_arg(args, const char *));
    13d0:	02ed0000 	rsceq	r0, sp, #0
    13d4:	04050000 	streq	r0, [r5], #-0
    13d8:	01010000 	mrseq	r0, (UNDEF: 1)
            fmt++;
    13dc:	58030550 	stmdapl	r3, {r4, r6, r8, sl}
            break;
    13e0:	00000027 	andeq	r0, r0, r7, lsr #32
            __write_char2__(va_arg(args, int));
    13e4:	0008d603 	andeq	sp, r8, r3, lsl #12
    13e8:	0002ed00 	andeq	lr, r2, r0, lsl #26
    13ec:	08e00200 	stmiaeq	r0!, {r9}^
            fmt++;
    13f0:	02ed0000 	rsceq	r0, sp, #0
            break;
    13f4:	04250000 	strteq	r0, [r5], #-0
            if (*fmt == 'l') {
    13f8:	01010000 	mrseq	r0, (UNDEF: 1)
    13fc:	54030550 	strpl	r0, [r3], #-1360	@ 0xfffffab0
            if (printf2_numbers(*fmt, &args, l_count)) {
    1400:	00000027 	andeq	r0, r0, r7, lsr #32
    1404:	0008ea03 	andeq	lr, r8, r3, lsl #20
    1408:	0002ed00 	andeq	lr, r2, r0, lsl #26
              state = CHECK_CH;
    140c:	de120000 	cdple	0, 1, cr0, cr2, cr0, {0}
              fmt++;
    1410:	bc000005 	stclt	0, cr0, [r0], {5}
              l_count++;
    1414:	00009001 	andeq	r9, r0, r1
            if (printf2_numbers(*fmt, &args, 0)) {
    1418:	000d4400 	andeq	r4, sp, r0, lsl #8
    141c:	00003000 	andeq	r3, r0, r0
              fmt++;
    1420:	899c0100 	ldmibhi	ip, {r8}
              break;
    1424:	0b000004 	bleq	143c <printf2+0xd8>
            return -1;
    1428:	0000056e 	andeq	r0, r0, lr, ror #10
}
    142c:	ba1d01bc 	blt	741b24 <__ROM_SIZE__+0x701b24>
    1430:	09000000 	stmdbeq	r0, {}	@ <UNPREDICTABLE>
            return -1;
    1434:	03000003 	movweq	r0, #3
    1438:	1b000003 	blne	144c <r32+0xc>
    143c:	00000d48 	andeq	r0, r0, r8, asr #26
int r32(int argc, char *argv[]) {
    1440:	00000024 	andeq	r0, r0, r4, lsr #32
  if (argc < 2) {
    1444:	bd006913 	vstrlt.16	s12, [r0, #-38]	@ 0xffffffda	@ <UNPREDICTABLE>
  uint32_t addr = atoh(argv[1]);
    1448:	006a0c01 	rsbeq	r0, sl, r1, lsl #24
    144c:	03260000 			@ <UNDEFINED> instruction: 0x03260000
  printf("0x%x: 0x%x\n", addr, data);
    1450:	03220000 			@ <UNDEFINED> instruction: 0x03220000
    1454:	60060000 	andvs	r0, r6, r0
}
    1458:	ca00000d 	bgt	1494 <w32+0x24>
    printf("Usage: %s <address> (in hex)\n", argv[0]);
    145c:	01000002 	tsteq	r0, r2
    1460:	76025001 	strvc	r5, [r2], -r1
    return -1;
    1464:	00000000 	andeq	r0, r0, r0
    1468:	00058612 	andeq	r8, r5, r2, lsl r6
    146c:	6a01ad00 	bvs	6c874 <__ROM_SIZE__+0x2c874>
int w32(int argc, char *argv[]) {
    1470:	18000000 	stmdane	r0, {}	@ <UNPREDICTABLE>
  if (argc < 3) {
    1474:	2c00000d 	stccs	0, cr0, [r0], {13}
  uint32_t addr = atoh(argv[1]);
    1478:	01000000 	mrseq	r0, (UNDEF: 0)
    147c:	00050c9c 	muleq	r5, ip, ip
  uint32_t data = atoh(argv[2]);
    1480:	056e0b00 	strbeq	r0, [lr, #-2816]!	@ 0xfffff500
    1484:	01ad0000 			@ <UNDEFINED> instruction: 0x01ad0000
  return 0;
    1488:	0000ba10 	andeq	fp, r0, r0, lsl sl
    printf("Usage: %s <address> (in hex) <value> (in hex)\n", argv[0]);
    148c:	00033c00 	andeq	r3, r3, r0, lsl #24
    1490:	00033600 	andeq	r3, r3, r0, lsl #12
    return -1;
    1494:	01352500 	teqeq	r5, r0, lsl #10
    1498:	01ae0000 			@ <UNDEFINED> instruction: 0x01ae0000
    149c:	00006a07 	andeq	r6, r0, r7, lsl #20
int read_mem(int argc, char *argv[]) {
    14a0:	00035900 	andeq	r5, r3, r0, lsl #18
  if (argc < 3) {
    14a4:	00035500 	andeq	r5, r3, r0, lsl #10
  uint32_t addr = atoh(argv[1]);
    14a8:	00b02400 	adcseq	r2, r0, r0, lsl #8
    14ac:	01b10000 			@ <UNDEFINED> instruction: 0x01b10000
  uint32_t length = atoi(argv[2]);
    14b0:	00050c09 	andeq	r0, r5, r9, lsl #24
    14b4:	f8910300 			@ <UNDEFINED> instruction: 0xf8910300
  for (uint32_t i = 0, data = 0; i < length; i++) {
    14b8:	0d26027d 	sfmeq	f0, 4, [r6, #-500]!	@ 0xfffffe0c
    printf("Usage: %s <address> (in hex) <num_words> (in decimal)\n", argv[0]);
    14bc:	08e30000 	stmiaeq	r3!, {}^	@ <UNPREDICTABLE>
    14c0:	04fb0000 	ldrbteq	r0, [fp], #0
    return -1;
    14c4:	01010000 	mrseq	r0, (UNDEF: 1)
    14c8:	007d0250 	rsbseq	r0, sp, r0, asr r2
    printf("0x%x: 0x%x\n", addr, data);
    14cc:	03510101 	cmpeq	r1, #1073741824	@ 0x40000000
    14d0:	015001a3 	cmpeq	r0, r3, lsr #3
    addr += 4;
    14d4:	08025201 	stmdaeq	r2, {r0, r9, ip, lr}
  for (uint32_t i = 0, data = 0; i < length; i++) {
    14d8:	3c060040 	stccc	0, cr0, [r6], {64}	@ 0x40
  return 0;
    14dc:	4800000d 	stmdami	r0, {r0, r2, r3}
}
    14e0:	01000008 	tsteq	r0, r8
    14e4:	7d025101 	stfvcs	f5, [r2, #-4]
{
    14e8:	19000000 	stmdbne	r0, {}	@ <UNPREDICTABLE>
  if (argc < 4) {
    14ec:	000000ba 	strheq	r0, [r0], -sl
  uint32_t addr = atoh(argv[1]);
    14f0:	0000051c 	andeq	r0, r0, ip, lsl r5
    14f4:	00007611 	andeq	r7, r0, r1, lsl r6
  uint32_t bit_loc = atoi(argv[2]);
    14f8:	33003f00 	movwcc	r3, #3840	@ 0xf00
    14fc:	00000670 	andeq	r0, r0, r0, ror r6
  uint32_t bit_val = atoi(argv[3]);
    1500:	0601a301 	streq	sl, [r1], -r1, lsl #6
    1504:	00000d04 	andeq	r0, r0, r4, lsl #26
  if (bit_loc > 31) {
    1508:	00000014 	andeq	r0, r0, r4, lsl r0
  if (bit_val != 0 && bit_val != 1) {
    150c:	05589c01 	ldrbeq	r9, [r8, #-3073]	@ 0xfffff3ff
  data = data | (bit_val << bit_loc);
    1510:	0a030000 	beq	c1518 <__ROM_SIZE__+0x81518>
    1514:	5800000d 	stmdapl	r0, {r0, r2, r3}
  data = data & ~(!bit_val << bit_loc);
    1518:	03000005 	movweq	r0, #5
    151c:	00000d0e 	andeq	r0, r0, lr, lsl #26
    1520:	00000613 	andeq	r0, r0, r3, lsl r6
  return 0;
    1524:	000d1203 	andeq	r1, sp, r3, lsl #4
    printf("Error: Invalid bit location argument\n");
    1528:	000e4c00 	andeq	r4, lr, r0, lsl #24
    152c:	0d160300 	ldceq	3, cr0, [r6, #-0]
    printf("Error: Invalid bit value argument\n");
    1530:	06570000 	ldrbeq	r0, [r7], -r0
    1534:	34000000 	strcc	r0, [r0], #-0
  printf("Usage: %s <address_in_hex(32-bits)> <bit_location_in_decimal(0 to 31)> <bit_value(0 or 1)>\n", argv[0]);
    1538:	000004f6 	strdeq	r0, [r0], -r6
    153c:	2c017501 	cfstr32cs	mvfx7, [r1], {1}
  return -1;
    1540:	00000718 	andeq	r0, r0, r8, lsl r7
    1544:	0000006c 	andeq	r0, r0, ip, rrx
    1548:	05bc9c01 	ldreq	r9, [ip, #3073]!	@ 0xc01
    154c:	17100000 	ldrne	r0, [r0, -r0]
{
    1550:	0f000007 	svceq	0x00000007
  if (argc < 3) {
    1554:	000000bf 	strheq	r0, [r0], -pc	@ <UNPREDICTABLE>
  uint32_t addr = atoh(argv[1]);
    1558:	0005bb10 	andeq	fp, r5, r0, lsl fp
    155c:	00bf1700 	adcseq	r1, pc, r0, lsl #14
  uint32_t bit_loc = atoi(argv[2]);
    1560:	94100000 	ldrls	r0, [r0], #-0
    1564:	1e000004 	cdpne	0, 0, cr0, cr0, cr4, {0}
  if (bit_loc > 31) {
    1568:	000000bf 	strheq	r0, [r0], -pc	@ <UNPREDICTABLE>
  uint32_t data = reg32(addr);
    156c:	00071e10 	andeq	r1, r7, r0, lsl lr
  printf("Bit %u @ 0x%08x: %u\n", bit_loc, addr, bit_val);
    1570:	00bf2600 	adcseq	r2, pc, r0, lsl #12
    1574:	90100000 	andsls	r0, r0, r0
    1578:	2c000005 	stccs	0, cr0, [r0], {5}
  return 0;
    157c:	000000bf 	strheq	r0, [r0], -pc	@ <UNPREDICTABLE>
    printf("Error: Invalid bit location argument\n");
    1580:	63727326 	cmnvs	r2, #-1744830464	@ 0x98000000
    1584:	00ba0900 	adcseq	r0, sl, r0, lsl #18
  printf("Usage: %s <address_in_hex(32-bits)> <bit_location_in_decimal(0 to 31)\n", argv[0]);
    1588:	91020000 	mrsls	r0, (UNDEF: 2)
    158c:	73642674 	cmnvc	r4, #116, 12	@ 0x7400000
  return -1;
    1590:	ba190074 	blt	641768 <__ROM_SIZE__+0x601768>
    1594:	02000000 	andeq	r0, r0, #0
    1598:	35007091 	strcc	r7, [r0, #-145]	@ 0xffffff6f
    159c:	0000063f 	andeq	r0, r0, pc, lsr r6
{
    15a0:	0c016e01 	stceq	14, cr6, [r1], {1}
  for (i = 0; i < Nk; ++i)
    15a4:	0000006a 	andeq	r0, r0, sl, rrx
    RoundKey[(i * 4) + 0] = Key[(i * 4) + 0];
    15a8:	00000834 	andeq	r0, r0, r4, lsr r8
    15ac:	00000010 	andeq	r0, r0, r0, lsl r0
    15b0:	06139c01 	ldreq	r9, [r3], -r1, lsl #24
    RoundKey[(i * 4) + 1] = Key[(i * 4) + 1];
    15b4:	350b0000 	strcc	r0, [fp, #-0]
    15b8:	6e000001 	cdpvs	0, 0, cr0, cr0, cr1, {0}
    RoundKey[(i * 4) + 2] = Key[(i * 4) + 2];
    15bc:	006a1b01 	rsbeq	r1, sl, r1, lsl #22
    15c0:	036c0000 	cmneq	ip, #0
    15c4:	03680000 	cmneq	r8, #0
    RoundKey[(i * 4) + 3] = Key[(i * 4) + 3];
    15c8:	b00b0000 	andlt	r0, fp, r0
  for (i = 0; i < Nk; ++i)
    15cc:	6e000000 	cdpvs	0, 0, cr0, cr0, cr0, {0}
    15d0:	00b52801 	adcseq	r2, r5, r1, lsl #16
  for (i = Nk; i < Nb * (Nr + 1); ++i)
    15d4:	03820000 	orreq	r0, r2, #0
    j = i * 4; k=(i - Nk) * 4;
    15d8:	037e0000 	cmneq	lr, #0
    RoundKey[j + 0] = RoundKey[k + 0] ^ tempa[0];
    15dc:	3c060000 	stccc	0, cr0, [r6], {-0}
    15e0:	ed000008 	stc	0, cr0, [r0, #-32]	@ 0xffffffe0
    15e4:	01000002 	tsteq	r0, r2
    15e8:	03055001 	movweq	r5, #20481	@ 0x5001
    RoundKey[j + 1] = RoundKey[k + 1] ^ tempa[1];
    15ec:	000026a8 	andeq	r2, r0, r8, lsr #13
    15f0:	b7360000 	ldrlt	r0, [r6, -r0]!
    15f4:	01000006 	tsteq	r0, r6
    15f8:	b20d0168 	andlt	r0, sp, #104, 2
    15fc:	26000007 	strcs	r0, [r0], -r7
    RoundKey[j + 2] = RoundKey[k + 2] ^ tempa[2];
    1600:	01000000 	mrseq	r0, (UNDEF: 0)
    1604:	0006579c 	muleq	r6, ip, r7
    1608:	07b41b00 	ldreq	r1, [r4, r0, lsl #22]!
    160c:	001e0000 	andseq	r0, lr, r0
    1610:	69130000 	ldmdbvs	r3, {}	@ <UNPREDICTABLE>
    RoundKey[j + 3] = RoundKey[k + 3] ^ tempa[3];
    1614:	0c016900 			@ <UNDEFINED> instruction: 0x0c016900
    1618:	0000006a 	andeq	r0, r0, sl, rrx
    161c:	00000398 	muleq	r0, r8, r3
  for (i = Nk; i < Nb * (Nr + 1); ++i)
    1620:	00000394 	muleq	r0, r4, r3
      k = (i - 1) * 4;
    1624:	0007c01c 	andeq	ip, r7, ip, lsl r0
      tempa[0]=RoundKey[k + 0];
    1628:	50010100 	andpl	r0, r1, r0, lsl #2
    162c:	01013001 	tsteq	r1, r1
      tempa[1]=RoundKey[k + 1];
    1630:	00300151 	eorseq	r0, r0, r1, asr r1
    1634:	c1370000 	teqgt	r7, r0
      tempa[2]=RoundKey[k + 2];
    1638:	01000005 	tsteq	r0, r5
    163c:	0b8c0df5 	bleq	fe304e18 <_STACK_TOP_+0xde2fce1c>
      tempa[3]=RoundKey[k + 3];
    1640:	01780000 	cmneq	r8, r0
    1644:	9c010000 	stcls	0, cr0, [r1], {-0}
    if (i % Nk == 0)
    1648:	00000838 	andeq	r0, r0, r8, lsr r8
    164c:	f600730c 			@ <UNDEFINED> instruction: 0xf600730c
        tempa[0] = tempa[1];
    1650:	00006a07 	andeq	r6, r0, r7, lsl #20
        tempa[1] = tempa[2];
    1654:	0003ae00 	andeq	sl, r3, r0, lsl #28
        tempa[2] = tempa[3];
    1658:	0003a800 	andeq	sl, r3, r0, lsl #16
        tempa[3] = u8tmp;
    165c:	01350700 	teqeq	r5, r0, lsl #14
        tempa[0] = getSBoxValue(tempa[0]);
    1660:	0af60000 	beq	ffd81668 <_STACK_TOP_+0xdfd7966c>
    1664:	0000006a 	andeq	r0, r0, sl, rrx
        tempa[1] = getSBoxValue(tempa[1]);
    1668:	000003c8 	andeq	r0, r0, r8, asr #7
    166c:	000003c4 	andeq	r0, r0, r4, asr #7
        tempa[2] = getSBoxValue(tempa[2]);
    1670:	0006b10a 	andeq	fp, r6, sl, lsl #2
    1674:	6a07f700 	bvs	1ff27c <__ROM_SIZE__+0x1bf27c>
        tempa[3] = getSBoxValue(tempa[3]);
    1678:	02000000 	andeq	r0, r0, #0
      tempa[0] = tempa[0] ^ Rcon[i/Nk];
    167c:	26076c91 			@ <UNDEFINED> instruction: 0x26076c91
    1680:	f8000006 			@ <UNDEFINED> instruction: 0xf8000006
    1684:	00006a07 	andeq	r6, r0, r7, lsl #20
    1688:	0003e700 	andeq	lr, r3, r0, lsl #14
}
    168c:	0003d700 	andeq	sp, r3, r0, lsl #14
    1690:	00630c00 	rsbeq	r0, r3, r0, lsl #24
{
    1694:	00bf08f9 	ldrshteq	r0, [pc], r9
  for (i = 0; i < 4; ++i)
    1698:	04280000 	strteq	r0, [r8], #-0
      (*state)[i][j] ^= RoundKey[(round * Nb * 4) + (i * Nb) + j];
    169c:	04220000 	strteq	r0, [r2], #-0
    16a0:	b10a0000 	mrslt	r0, (UNDEF: 10)
    16a4:	fb000005 	blx	16c2 <AddRoundKey+0x2e>
    16a8:	00083808 	andeq	r3, r8, r8, lsl #16
    16ac:	ec910300 	ldc	3, cr0, [r1], {0}
    16b0:	00b00a7e 	adcseq	r0, r0, lr, ror sl
    16b4:	09fc0000 	ldmibeq	ip!, {}^	@ <UNPREDICTABLE>
    for (j = 0; j < 4; ++j)
    16b8:	0000050c 	andeq	r0, r0, ip, lsl #10
    16bc:	7cec9103 	stfvcp	f1, [ip], #12
  for (i = 0; i < 4; ++i)
    16c0:	000b941d 	andeq	r9, fp, sp, lsl r4
    16c4:	00001400 	andeq	r1, r0, r0, lsl #8
    for (j = 0; j < 4; ++j)
    16c8:	00070000 	andeq	r0, r7, r0
  for (i = 0; i < 4; ++i)
    16cc:	00690c00 	rsbeq	r0, r9, r0, lsl #24
    16d0:	006a0cfe 	strdeq	r0, [sl], #-206	@ 0xffffff32	@ <UNPREDICTABLE>
    for (j = 0; j < 4; ++j)
    16d4:	04420000 	strbeq	r0, [r2], #-0
{
    16d8:	043e0000 	ldrteq	r0, [lr], #-0
      (*state)[j][i] = getSBoxValue((*state)[j][i]);
    16dc:	1d000000 	stcne	0, cr0, [r0, #-0]
    16e0:	00000ba8 	andeq	r0, r0, r8, lsr #23
    16e4:	00000012 	andeq	r0, r0, r2, lsl r0
    16e8:	00000720 	andeq	r0, r0, r0, lsr #14
    for (j = 0; j < 4; ++j)
    16ec:	00006913 	andeq	r6, r0, r3, lsl r9
    16f0:	006a0c01 	rsbeq	r0, sl, r1, lsl #24
  for (i = 0; i < 4; ++i)
    16f4:	04540000 	ldrbeq	r0, [r4], #-0
    16f8:	04520000 	ldrbeq	r0, [r2], #-0
    for (j = 0; j < 4; ++j)
    16fc:	03000000 	movweq	r0, #0
}
    1700:	00000bbe 			@ <UNDEFINED> instruction: 0x00000bbe
  for (i = 0; i < 4; ++i)
    1704:	00000e2a 	andeq	r0, r0, sl, lsr #28
    1708:	000bc402 	andeq	ip, fp, r2, lsl #8
    170c:	0002ed00 	andeq	lr, r2, r0, lsl #26
  temp           = (*state)[0][1];
    1710:	00074000 	andeq	r4, r7, r0
  (*state)[0][1] = (*state)[1][1];
    1714:	50010100 	andpl	r0, r1, r0, lsl #2
  (*state)[1][1] = (*state)[2][1];
    1718:	27680305 	strbcs	r0, [r8, -r5, lsl #6]!
  (*state)[2][1] = (*state)[3][1];
    171c:	03000000 	movweq	r0, #0
  temp           = (*state)[0][2];
    1720:	00000bde 	ldrdeq	r0, [r0], -lr
  (*state)[0][2] = (*state)[2][2];
    1724:	00000e3c 	andeq	r0, r0, ip, lsr lr
  temp           = (*state)[1][2];
    1728:	000bf614 	andeq	pc, fp, r4, lsl r6	@ <UNPREDICTABLE>
  (*state)[1][2] = (*state)[3][2];
    172c:	00075800 	andeq	r5, r7, r0, lsl #16
  temp           = (*state)[0][3];
    1730:	50010100 	andpl	r0, r1, r0, lsl #2
  (*state)[0][3] = (*state)[3][3];
    1734:	02003a01 	andeq	r3, r0, #4096	@ 0x1000
  (*state)[3][3] = (*state)[2][3];
    1738:	00000bfc 	strdeq	r0, [r0], -ip
  (*state)[2][3] = (*state)[1][3];
    173c:	00000bb7 			@ <UNDEFINED> instruction: 0x00000bb7
}
    1740:	0000076d 	andeq	r0, r0, sp, ror #14
  return ((x<<1) ^ (((x>>7) & 1) * 0x1b));
    1744:	03500101 	cmpeq	r0, #1073741824	@ 0x40000000
    1748:	007eec91 			@ <UNDEFINED> instruction: 0x007eec91
    174c:	000c0602 	andeq	r0, ip, r2, lsl #12
}
    1750:	0008e300 	andeq	lr, r8, r0, lsl #6
{
    1754:	00078f00 	andeq	r8, r7, r0, lsl #30
    1758:	50010100 	andpl	r0, r1, r0, lsl #2
  for (i = 0; i < 4; ++i)
    175c:	7cec9103 	stfvcp	f1, [ip], #12
    t   = (*state)[i][0];
    1760:	03510101 	cmpeq	r1, #1073741824	@ 0x40000000
    Tmp = (*state)[i][0] ^ (*state)[i][1] ^ (*state)[i][2] ^ (*state)[i][3] ;
    1764:	017eec91 			@ <UNDEFINED> instruction: 0x017eec91
    1768:	08025201 	stmdaeq	r2, {r0, r9, ip, lr}
    176c:	2e030040 	cdpcs	0, 0, cr0, cr3, cr0, {2}
    1770:	d500000c 	strle	r0, [r0, #-12]
    1774:	1400000d 	strne	r0, [r0], #-13
    1778:	00000c3c 	andeq	r0, r0, ip, lsr ip
    Tm  = (*state)[i][0] ^ (*state)[i][1] ; Tm = xtime(Tm);  (*state)[i][0] ^= Tm ^ Tmp ;
    177c:	000007a8 	andeq	r0, r0, r8, lsr #15
    1780:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    1784:	03000074 	movweq	r0, #116	@ 0x74
    Tm  = (*state)[i][1] ^ (*state)[i][2] ; Tm = xtime(Tm);  (*state)[i][1] ^= Tm ^ Tmp ;
    1788:	00000c40 	andeq	r0, r0, r0, asr #24
    178c:	00000e14 	andeq	r0, r0, r4, lsl lr
    1790:	000c9a03 	andeq	r9, ip, r3, lsl #20
    1794:	000dd500 	andeq	sp, sp, r0, lsl #10
    1798:	0c9e0300 	ldceq	3, cr0, [lr], {0}
    Tm  = (*state)[i][2] ^ (*state)[i][3] ; Tm = xtime(Tm);  (*state)[i][2] ^= Tm ^ Tmp ;
    179c:	0dd50000 	ldcleq	0, cr0, [r5]
    17a0:	c2030000 	andgt	r0, r3, #0
    17a4:	a400000c 	strge	r0, [r0], #-12
    17a8:	0200000d 	andeq	r0, r0, #13
    Tm  = (*state)[i][3] ^ t ;              Tm = xtime(Tm);  (*state)[i][3] ^= Tm ^ Tmp ;
    17ac:	00000cce 	andeq	r0, r0, lr, asr #25
    17b0:	00000c25 	andeq	r0, r0, r5, lsr #24
    17b4:	000007e7 	andeq	r0, r0, r7, ror #15
    17b8:	03500101 	cmpeq	r0, #1073741824	@ 0x40000000
    17bc:	017eec91 			@ <UNDEFINED> instruction: 0x017eec91
  for (i = 0; i < 4; ++i)
    17c0:	91025101 	tstls	r2, r1, lsl #2
    17c4:	d803006c 	stmdale	r3, {r2, r3, r5, r6}
}
    17c8:	a400000c 	strge	r0, [r0], #-12
{
    17cc:	0200000d 	andeq	r0, r0, #13
    17d0:	00000ce2 	andeq	r0, r0, r2, ror #25
  for (i = 0; i < 4; ++i)
    17d4:	00000cd9 	ldrdeq	r0, [r0], -r9
    a = (*state)[i][0];
    17d8:	0000080b 	andeq	r0, r0, fp, lsl #16
    b = (*state)[i][1];
    17dc:	03500101 	cmpeq	r0, #1073741824	@ 0x40000000
    17e0:	017eec91 			@ <UNDEFINED> instruction: 0x017eec91
    c = (*state)[i][2];
    17e4:	91025101 	tstls	r2, r1, lsl #2
    d = (*state)[i][3];
    17e8:	ec02006c 	stc	0, cr0, [r2], {108}	@ 0x6c
    (*state)[i][0] = Multiply(a, 0x0e) ^ Multiply(b, 0x0b) ^ Multiply(c, 0x0d) ^ Multiply(d, 0x09);
    17ec:	7e00000c 	cdpvc	0, 0, cr0, cr0, cr12, {0}
    17f0:	26000009 	strcs	r0, [r0], -r9
    17f4:	01000008 	tsteq	r0, r8
    17f8:	91035001 	tstls	r3, r1
    17fc:	01017eec 	smlatteq	r1, ip, lr, r7
    1800:	6c910251 	lfmvs	f0, 4, [r1], {81}	@ 0x51
    1804:	0cf40600 	ldcleq	6, cr0, [r4]
    1808:	08480000 	stmdaeq	r8, {}^	@ <UNPREDICTABLE>
    180c:	01010000 	mrseq	r0, (UNDEF: 1)
    1810:	ec910351 	ldc	3, cr0, [r1], {81}	@ 0x51
    1814:	1900007c 	stmdbne	r0, {r2, r3, r4, r5, r6}
    1818:	000000bf 	strheq	r0, [r0], -pc	@ <UNPREDICTABLE>
    181c:	00000848 	andeq	r0, r0, r8, asr #16
    1820:	00007611 	andeq	r7, r0, r1, lsl r6
    1824:	0d007f00 	stceq	15, cr7, [r0, #-0]
    1828:	000006e1 	andeq	r0, r0, r1, ror #13
    182c:	000844e3 	andeq	r4, r8, r3, ror #9
    1830:	00005c00 	andeq	r5, r0, r0, lsl #24
    1834:	e39c0100 	orrs	r0, ip, #0, 2
    1838:	04000008 	streq	r0, [r0], #-8
    183c:	00000135 	andeq	r0, r0, r5, lsr r1
    1840:	006a19e3 	rsbeq	r1, sl, r3, ror #19
    1844:	04620000 	strbteq	r0, [r2], #-0
    1848:	045c0000 	ldrbeq	r0, [ip], #-0
    184c:	b0040000 	andlt	r0, r4, r0
    1850:	e3000000 	movw	r0, #0
    1854:	0000b526 	andeq	fp, r0, r6, lsr #10
    1858:	00048100 	andeq	r8, r4, r0, lsl #2
    185c:	00047b00 	andeq	r7, r4, r0, lsl #22
    1860:	069f0700 	ldreq	r0, [pc], r0, lsl #14
    1864:	07e40000 	strbeq	r0, [r4, r0]!
    1868:	0000006a 	andeq	r0, r0, sl, rrx
    186c:	000004a0 	andeq	r0, r0, r0, lsr #9
    1870:	0000049a 	muleq	r0, sl, r4
    1874:	00084c1d 	andeq	r4, r8, sp, lsl ip
    1878:	00002e00 	andeq	r2, r0, r0, lsl #28
    (*state)[i][1] = Multiply(a, 0x09) ^ Multiply(b, 0x0e) ^ Multiply(c, 0x0b) ^ Multiply(d, 0x0d);
    187c:	0008cf00 	andeq	ip, r8, r0, lsl #30
    1880:	00690c00 	rsbeq	r0, r9, r0, lsl #24
    1884:	006a0ce6 	rsbeq	r0, sl, r6, ror #25
    1888:	04bd0000 	ldrteq	r0, [sp], #0
    188c:	04b90000 	ldrteq	r0, [r9], #0
    1890:	64030000 	strvs	r0, [r3], #-0
    1894:	ca000008 	bgt	18bc <InvMixColumns+0xf2>
    1898:	1c000002 	stcne	0, cr0, [r0], {2}
    189c:	00000874 	andeq	r0, r0, r4, ror r8
    18a0:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    18a4:	01010078 	tsteq	r1, r8, ror r0
    18a8:	00760251 	rsbseq	r0, r6, r1, asr r2
    18ac:	84060000 	strhi	r0, [r6], #-0
    18b0:	ed000008 	stc	0, cr0, [r0, #-32]	@ 0xffffffe0
    (*state)[i][2] = Multiply(a, 0x0d) ^ Multiply(b, 0x09) ^ Multiply(c, 0x0e) ^ Multiply(d, 0x0b);
    18b4:	01000002 	tsteq	r0, r2
    18b8:	03055001 	movweq	r5, #20481	@ 0x5001
    18bc:	000026f4 	strdeq	r2, [r0], -r4
    18c0:	6e1e0000 	cdpvs	0, 1, cr0, cr14, cr0, {0}
    18c4:	cb000004 	blgt	18dc <InvMixColumns+0x112>
    18c8:	0000006a 	andeq	r0, r0, sl, rrx
    18cc:	00000950 	andeq	r0, r0, r0, asr r9
    18d0:	00000052 	andeq	r0, r0, r2, asr r0
    18d4:	097e9c01 	ldmdbeq	lr!, {r0, sl, fp, ip, pc}^
    18d8:	b0040000 	andlt	r0, r4, r0
    18dc:	cb000000 	blgt	18e4 <InvMixColumns+0x11a>
    18e0:	0000b51e 	andeq	fp, r0, lr, lsl r5
    (*state)[i][3] = Multiply(a, 0x0b) ^ Multiply(b, 0x0d) ^ Multiply(c, 0x09) ^ Multiply(d, 0x0e);
    18e4:	0004d100 	andeq	sp, r4, r0, lsl #2
    18e8:	0004cd00 	andeq	ip, r4, r0, lsl #26
    18ec:	05b10400 	ldreq	r0, [r1, #1024]!	@ 0x400
    18f0:	2acb0000 	bcs	ff2c18f8 <_STACK_TOP_+0xdf2b98fc>
    18f4:	000000ba 	strheq	r0, [r0], -sl
    18f8:	000004e4 	andeq	r0, r0, r4, ror #9
    18fc:	000004e0 	andeq	r0, r0, r0, ror #9
    1900:	0006e904 	andeq	lr, r6, r4, lsl #18
    1904:	6a39cb00 	bvs	e7450c <__ROM_SIZE__+0xe3450c>
    1908:	f7000000 			@ <UNDEFINED> instruction: 0xf7000000
    190c:	f3000004 	vhadd.u8	d0, d0, d4
    1910:	07000004 	streq	r0, [r0, -r4]
    1914:	00000135 	andeq	r0, r0, r5, lsr r1
  for (i = 0; i < 4; ++i)
    1918:	006a07cc 	rsbeq	r0, sl, ip, asr #15
    191c:	05110000 	ldreq	r0, [r1, #-0]
}
    1920:	05090000 	streq	r0, [r9, #-0]
  for (i = 0; i < 4; ++i)
    1924:	700c0000 	andvc	r0, ip, r0
    1928:	cd00736f 	stcgt	3, cr7, [r0, #-444]	@ 0xfffffe44
    for (j = 0; j < 4; ++j)
    192c:	00006a07 	andeq	r6, r0, r7, lsl #20
{
    1930:	00053500 	andeq	r3, r5, r0, lsl #10
      (*state)[j][i] = getSBoxInvert((*state)[j][i]);
    1934:	00053100 	andeq	r3, r5, r0, lsl #2
    1938:	07d20700 	ldrbeq	r0, [r2, r0, lsl #14]
    193c:	07ce0000 	strbeq	r0, [lr, r0]
    1940:	0000006a 	andeq	r0, r0, sl, rrx
    1944:	00000549 	andeq	r0, r0, r9, asr #10
    for (j = 0; j < 4; ++j)
    1948:	00000545 	andeq	r0, r0, r5, asr #10
    194c:	00095c06 	andeq	r5, r9, r6, lsl #24
  for (i = 0; i < 4; ++i)
    1950:	00028e00 	andeq	r8, r2, r0, lsl #28
    1954:	50010100 	andpl	r0, r1, r0, lsl #2
    for (j = 0; j < 4; ++j)
    1958:	00007402 	andeq	r7, r0, r2, lsl #8
}
    195c:	05140d00 	ldreq	r0, [r4, #-3328]	@ 0xfffff300
  for (i = 0; i < 4; ++i)
    1960:	e6a60000 	strt	r0, [r6], r0
    1964:	a200000a 	andge	r0, r0, #10
    1968:	01000000 	mrseq	r0, (UNDEF: 0)
  temp = (*state)[3][1];
    196c:	000a939c 	muleq	sl, ip, r3
  (*state)[3][1] = (*state)[2][1];
    1970:	06320400 	ldrteq	r0, [r2], -r0, lsl #8
  (*state)[2][1] = (*state)[1][1];
    1974:	1ea60000 	cdpne	0, 10, cr0, cr6, cr0, {0}
  (*state)[1][1] = (*state)[0][1];
    1978:	000000ba 	strheq	r0, [r0], -sl
  temp = (*state)[0][2];
    197c:	0000055e 	andeq	r0, r0, lr, asr r5
  (*state)[0][2] = (*state)[2][2];
    1980:	00000558 	andeq	r0, r0, r8, asr r5
  temp = (*state)[1][2];
    1984:	00047904 	andeq	r7, r4, r4, lsl #18
  (*state)[1][2] = (*state)[3][2];
    1988:	932da600 			@ <UNDEFINED> instruction: 0x932da600
  temp = (*state)[0][3];
    198c:	7a00000a 	bvc	19bc <Cipher+0x1e>
  (*state)[0][3] = (*state)[1][3];
    1990:	74000005 	strvc	r0, [r0], #-5
  (*state)[1][3] = (*state)[2][3];
    1994:	0c000005 	stceq	0, cr0, [r0], {5}
  (*state)[2][3] = (*state)[3][3];
    1998:	07ab0069 	streq	r0, [fp, r9, rrx]!
}
    199c:	0000006a 	andeq	r0, r0, sl, rrx
{
    19a0:	00000594 	muleq	r0, r4, r5
  AddRoundKey(0, state, RoundKey);
    19a4:	00000590 	muleq	r0, r0, r5
    19a8:	0006ab07 	andeq	sl, r6, r7, lsl #22
    19ac:	6a07ac00 	bvs	1ec9b4 <__ROM_SIZE__+0x1ac9b4>
  for (round = 1; ; ++round)
    19b0:	a7000000 	strge	r0, [r0, -r0]
    MixColumns(state);
    19b4:	a3000005 	movwge	r0, #5
    AddRoundKey(round, state, RoundKey);
    19b8:	07000005 	streq	r0, [r0, -r5]
    19bc:	0000065d 	andeq	r0, r0, sp, asr r6
    19c0:	006a07ad 	rsbeq	r0, sl, sp, lsr #15
  for (round = 1; ; ++round)
    19c4:	05be0000 	ldreq	r0, [lr, #0]!
    SubBytes(state);
    19c8:	05b60000 	ldreq	r0, [r6, #0]!
    ShiftRows(state);
    19cc:	16020000 	strne	r0, [r2], -r0
    19d0:	9800000b 	stmdals	r0, {r0, r1, r3}
    if (round == Nr) {
    19d4:	0300000a 	movweq	r0, #10
  AddRoundKey(Nr, state, RoundKey);
    19d8:	0100000a 	tsteq	r0, sl
    19dc:	78025001 	stmdavc	r2, {r0, ip, lr}
}
    19e0:	28020000 	stmdacs	r2, {}	@ <UNPREDICTABLE>
{
    19e4:	ed00000b 	stc	0, cr0, [r0, #-44]	@ 0xffffffd4
  AddRoundKey(Nr, state, RoundKey);
    19e8:	1a000002 	bne	19f8 <InvCipher+0x16>
    19ec:	0100000a 	tsteq	r0, sl
    19f0:	03055001 	movweq	r5, #20481	@ 0x5001
  for (round = (Nr - 1); ; --round)
    19f4:	00002764 	andeq	r2, r0, r4, ror #14
    InvMixColumns(state);
    19f8:	0b4c0200 	bleq	1302200 <__ROM_SIZE__+0x12c2200>
  for (round = (Nr - 1); ; --round)
    19fc:	02a40000 	adceq	r0, r4, #0
    InvShiftRows(state);
    1a00:	0a340000 	beq	d01a08 <__ROM_SIZE__+0xcc1a08>
    1a04:	01010000 	mrseq	r0, (UNDEF: 1)
    InvSubBytes(state);
    1a08:	00780250 	rsbseq	r0, r8, r0, asr r2
    AddRoundKey(round, state, RoundKey);
    1a0c:	02520101 	subseq	r0, r2, #1073741824	@ 0x40000000
    1a10:	02008008 	andeq	r8, r0, #8
    1a14:	00000b52 	andeq	r0, r0, r2, asr fp
    if (round == 0) {
    1a18:	0000028e 	andeq	r0, r0, lr, lsl #5
  for (i = 0; i < AES_BLOCKLEN; ++i) // The block in AES is always 128bit no matter the key size
    1a1c:	00000a48 	andeq	r0, r0, r8, asr #20
    buf[i] ^= Iv[i];
    1a20:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    1a24:	02000078 	andeq	r0, r0, #120	@ 0x78
    1a28:	00000b60 	andeq	r0, r0, r0, ror #22
  for (i = 0; i < AES_BLOCKLEN; ++i) // The block in AES is always 128bit no matter the key size
    1a2c:	000002ed 	andeq	r0, r0, sp, ror #5
    1a30:	00000a5d 	andeq	r0, r0, sp, asr sl
}
    1a34:	03500101 	cmpeq	r0, #1073741824	@ 0x40000000
  KeyExpansion(ctx->RoundKey, key);
    1a38:	0001b874 	andeq	fp, r1, r4, ror r8
}
    1a3c:	000b6403 	andeq	r6, fp, r3, lsl #8
{
    1a40:	000e2a00 	andeq	r2, lr, r0, lsl #20
  KeyExpansion(ctx->RoundKey, key);
    1a44:	0b6c0200 	bleq	1b0224c <__ROM_SIZE__+0x1ac224c>
  memcpy (ctx->Iv, iv, AES_BLOCKLEN);
    1a48:	02ed0000 	rsceq	r0, sp, #0
    1a4c:	0a7b0000 	beq	1ec1a54 <__ROM_SIZE__+0x1e81a54>
    1a50:	01010000 	mrseq	r0, (UNDEF: 1)
}
    1a54:	c8740350 	ldmdagt	r4!, {r4, r6, r8, r9}^
  memcpy (ctx->Iv, iv, AES_BLOCKLEN);
    1a58:	76060001 	strvc	r0, [r6], -r1
    1a5c:	ed00000b 	stc	0, cr0, [r0, #-44]	@ 0xffffffd4
}
    1a60:	01000002 	tsteq	r0, r2
{
    1a64:	74035001 	strvc	r5, [r3], #-1
  Cipher((state_t*)buf, ctx->RoundKey);
    1a68:	010101c0 	smlabteq	r1, r0, r1, r0
    1a6c:	00780251 	rsbseq	r0, r8, r1, asr r2
{
    1a70:	6a090000 	bvs	241a78 <__ROM_SIZE__+0x201a78>
  InvCipher((state_t*)buf, ctx->RoundKey);
    1a74:	1e000000 	cdpne	0, 0, cr0, cr0, cr0, {0}
    1a78:	0000064a 	andeq	r0, r0, sl, asr #12
}
    1a7c:	00006a99 	muleq	r0, r9, sl
{
    1a80:	0009a200 	andeq	sl, r9, r0, lsl #4
    1a84:	00003c00 	andeq	r3, r0, r0, lsl #24
  uint8_t *Iv = ctx->Iv;
    1a88:	129c0100 	addsne	r0, ip, #0, 2
    1a8c:	1f00000b 	svcne	0x0000000b
  for (i = 0; i < length; i += AES_BLOCKLEN)
    1a90:	00627573 	rsbeq	r7, r2, r3, ror r5
    XorWithIv(buf, Iv);
    1a94:	0000ba1f 	andeq	fp, r0, pc, lsl sl
    Cipher((state_t*)buf, ctx->RoundKey);
    1a98:	0005e300 	andeq	lr, r5, r0, lsl #6
    1a9c:	0005db00 	andeq	sp, r5, r0, lsl #22
  for (i = 0; i < length; i += AES_BLOCKLEN)
    1aa0:	656c1f00 	strbvs	r1, [ip, #-3840]!	@ 0xfffff100
    buf += AES_BLOCKLEN;
    1aa4:	6a28006e 	bvs	a01c64 <__ROM_SIZE__+0x9c1c64>
  for (i = 0; i < length; i += AES_BLOCKLEN)
    1aa8:	09000000 	stmdbeq	r0, {}	@ <UNPREDICTABLE>
  memcpy(ctx->Iv, Iv, AES_BLOCKLEN);
    1aac:	03000006 	movweq	r0, #6
    1ab0:	1f000006 	svcne	0x00000006
}
    1ab4:	00727473 	rsbseq	r7, r2, r3, ror r4
{
    1ab8:	0000f939 	andeq	pc, r0, r9, lsr r9	@ <UNPREDICTABLE>
    1abc:	00062500 	andeq	r2, r6, r0, lsl #10
    1ac0:	00061f00 	andeq	r1, r6, r0, lsl #30
  for (i = 0; i < length; i += AES_BLOCKLEN)
    1ac4:	000c3800 	andeq	r3, ip, r0, lsl #16
    memcpy(storeNextIv, buf, AES_BLOCKLEN);
    1ac8:	0b010000 	bleq	41ad0 <__ROM_SIZE__+0x1ad0>
    1acc:	690c0000 	stmdbvs	ip, {}	@ <UNPREDICTABLE>
    InvCipher((state_t*)buf, ctx->RoundKey);
    1ad0:	6a0c9e00 	bvs	3292d8 <__ROM_SIZE__+0x2e92d8>
    1ad4:	3f000000 	svccc	0x00000000
    XorWithIv(buf, ctx->Iv);
    1ad8:	3b000006 	blcc	1af8 <AES_CBC_decrypt_buffer+0x42>
    1adc:	00000006 	andeq	r0, r0, r6
    1ae0:	0009b806 	andeq	fp, r9, r6, lsl #16
    memcpy(ctx->Iv, storeNextIv, AES_BLOCKLEN);
    1ae4:	00028e00 	andeq	r8, r2, r0, lsl #28
    1ae8:	50010100 	andpl	r0, r1, r0, lsl #2
    1aec:	00007402 	andeq	r7, r0, r2, lsl #8
  for (i = 0; i < length; i += AES_BLOCKLEN)
    1af0:	049f1e00 	ldreq	r1, [pc], #3584	@ 1af8 <AES_CBC_decrypt_buffer+0x42>
    1af4:	6a850000 	bvs	fe141afc <_STACK_TOP_+0xde139b00>
}
    1af8:	d8000000 	stmdale	r0, {}	@ <UNPREDICTABLE>
{
    1afc:	40000007 	andmi	r0, r0, r7
    1b00:	01000000 	mrseq	r0, (UNDEF: 0)
    1b04:	000bb79c 	muleq	fp, ip, r7
  for (i = 0, bi = AES_BLOCKLEN; i < length; ++i, ++bi)
    1b08:	01350400 	teqeq	r5, r0, lsl #8
          ctx->Iv[bi] = 0;
    1b0c:	1d850000 	stcne	0, cr0, [r5]
    1b10:	0000006a 	andeq	r0, r0, sl, rrx
      for (bi = (AES_BLOCKLEN - 1); bi >= 0; --bi)
    1b14:	00000652 	andeq	r0, r0, r2, asr r6
      bi = 0;
    1b18:	0000064e 	andeq	r0, r0, lr, asr #12
    buf[i] = (buf[i] ^ buffer[bi]);
    1b1c:	0000b004 	andeq	fp, r0, r4
    1b20:	b52a8500 	strlt	r8, [sl, #-1280]!	@ 0xfffffb00
    1b24:	68000000 	stmdavs	r0, {}	@ <UNPREDICTABLE>
    1b28:	64000006 	strvs	r0, [r0], #-6
    1b2c:	07000006 	streq	r0, [r0, -r6]
  for (i = 0, bi = AES_BLOCKLEN; i < length; ++i, ++bi)
    1b30:	000006d7 	ldrdeq	r0, [r0], -r7
    1b34:	00500c86 	subseq	r0, r0, r6, lsl #25
    if (bi == AES_BLOCKLEN) /* we need to regen xor compliment in buffer */
    1b38:	067c0000 	ldrbteq	r0, [ip], -r0
      memcpy(buffer, ctx->Iv, AES_BLOCKLEN);
    1b3c:	067a0000 	ldrbteq	r0, [sl], -r0
    1b40:	fe070000 	cdp2	0, 0, cr0, cr7, cr0, {0}
    1b44:	87000006 	strhi	r0, [r0, -r6]
      Cipher((state_t*)buffer,ctx->RoundKey);
    1b48:	0000500c 	andeq	r5, r0, ip
    1b4c:	00068a00 	andeq	r8, r6, r0, lsl #20
      for (bi = (AES_BLOCKLEN - 1); bi >= 0; --bi)
    1b50:	00068400 	andeq	r8, r6, r0, lsl #8
    1b54:	07f21b00 	ldrbeq	r1, [r2, r0, lsl #22]!
        if (ctx->Iv[bi] == 255)
    1b58:	00160000 	andseq	r0, r6, r0
    1b5c:	db070000 	blle	1c1b64 <__ROM_SIZE__+0x181b64>
        ctx->Iv[bi] += 1;
    1b60:	8b000006 	blhi	1b80 <bitvec_get_bit+0x10>
    1b64:	00005011 	andeq	r5, r0, r1, lsl r0
      bi = 0;
    1b68:	0006a400 	andeq	sl, r6, r0, lsl #8
}
    1b6c:	0006a200 	andeq	sl, r6, r0, lsl #4
  return ((x[idx / 32U] >> (idx & 31U) & 1U));
    1b70:	08020600 	stmdaeq	r2, {r9, sl}
    1b74:	02ed0000 	rsceq	r0, sp, #0
    1b78:	01010000 	mrseq	r0, (UNDEF: 1)
}
    1b7c:	a0030550 	andge	r0, r3, r0, asr r5
    1b80:	01000026 	tsteq	r0, r6, lsr #32
  x[idx / 32U] &= ~(1U << (idx & 31U));
    1b84:	740c5101 	strvc	r5, [ip], #-257	@ 0xfffffeff
    1b88:	371a3100 	ldrcc	r3, [sl, -r0, lsl #2]
    1b8c:	00100324 	andseq	r0, r0, r4, lsr #6
    1b90:	00222000 	eoreq	r2, r2, r0
    1b94:	c70d0000 	strgt	r0, [sp, -r0]
    1b98:	79000005 	stmdbvc	r0, {r0, r2}
  for (i = 0; i < BITVEC_NWORDS; ++i)
    1b9c:	00000908 	andeq	r0, r0, r8, lsl #18
    x[i] = y[i];
    1ba0:	00000048 	andeq	r0, r0, r8, asr #32
    1ba4:	0c259c01 	stceq	12, cr9, [r5], #-4
  for (i = 0; i < BITVEC_NWORDS; ++i)
    1ba8:	6e040000 	cdpvs	0, 0, cr0, cr4, cr0, {0}
    1bac:	79000005 	stmdbvc	r0, {r0, r2}
{
    1bb0:	0000f930 	andeq	pc, r0, r0, lsr r9	@ <UNPREDICTABLE>
    1bb4:	0006b200 	andeq	fp, r6, r0, lsl #4
  bitvec_copy(tmp, x);
    1bb8:	0006ac00 	andeq	sl, r6, r0, lsl #24
    1bbc:	06db0700 	ldrbeq	r0, [fp], r0, lsl #14
  bitvec_copy(x, y);
    1bc0:	077f0000 	ldrbeq	r0, [pc, -r0]!
    1bc4:	0000006a 	andeq	r0, r0, sl, rrx
  bitvec_copy(y, tmp);
    1bc8:	000006ca 	andeq	r0, r0, sl, asr #13
    1bcc:	000006c8 	andeq	r0, r0, r8, asr #13
}
    1bd0:	00091402 	andeq	r1, r9, r2, lsl #8
  for (i = 0; i < BITVEC_NWORDS; ++i)
    1bd4:	0002ca00 	andeq	ip, r2, r0, lsl #20
    1bd8:	000c0e00 	andeq	r0, ip, r0, lsl #28
    if (x[i] != y[i])
    1bdc:	50010100 	andpl	r0, r1, r0, lsl #2
    1be0:	01007502 	tsteq	r0, r2, lsl #10
    1be4:	03055101 	movweq	r5, #20737	@ 0x5101
  for (i = 0; i < BITVEC_NWORDS; ++i)
    1be8:	0000275c 	andeq	r2, r0, ip, asr r7
  return 1;
    1bec:	09360600 	ldmdbeq	r6!, {r9, sl}
}
    1bf0:	02a40000 	adceq	r0, r4, #0
  for (i = 0; i < BITVEC_NWORDS; ++i)
    1bf4:	01010000 	mrseq	r0, (UNDEF: 1)
    x[i] = 0;
    1bf8:	00750251 	rsbseq	r0, r5, r1, asr r2
  for (i = 0; i < BITVEC_NWORDS; ++i)
    1bfc:	02520101 	subseq	r0, r2, #1073741824	@ 0x40000000
    1c00:	00008008 	andeq	r8, r0, r8
  uint32_t i = 0;
    1c04:	00068d0d 	andeq	r8, r6, sp, lsl #26
  while (i < BITVEC_NWORDS)
    1c08:	0a506c00 	beq	141cc10 <__ROM_SIZE__+0x13dcc10>
    if (x[i] != 0)
    1c0c:	00600000 	rsbeq	r0, r0, r0
    i += 1;
    1c10:	9c010000 	stcls	0, cr0, [r1], {-0}
}
    1c14:	00000cd9 	ldrdeq	r0, [r0], -r9
    1c18:	00063204 	andeq	r3, r6, r4, lsl #4
    1c1c:	ba256c00 	blt	95cc24 <__ROM_SIZE__+0x91cc24>
  x += BITVEC_NWORDS;
    1c20:	d8000000 	stmdale	r0, {}	@ <UNPREDICTABLE>
          && (*(--x)) == 0)
    1c24:	d2000006 	andle	r0, r0, #6
    1c28:	04000006 	streq	r0, [r0], #-6
    1c2c:	00000479 	andeq	r0, r0, r9, ror r4
    i -= 32;
    1c30:	0a93346c 	beq	fe4cede8 <_STACK_TOP_+0xde4c6dec>
  if (i != 0)
    1c34:	06f70000 	ldrbteq	r0, [r7], r0
      i -= 1;
    1c38:	06f10000 	ldrbteq	r0, [r1], r0
    while (((*x) & u32mask) == 0)
    1c3c:	db070000 	blle	1c1c44 <__ROM_SIZE__+0x181c44>
}
    1c40:	72000006 	andvc	r0, r0, #6
    uint32_t u32mask = ((uint32_t)1 << 31);
    1c44:	00006a07 	andeq	r6, r0, r7, lsl #20
{
    1c48:	00071200 	andeq	r1, r7, r0, lsl #4
  int nwords = (nbits / 32);
    1c4c:	00071000 	andeq	r1, r7, r0
    1c50:	0a5e0200 	beq	1782458 <__ROM_SIZE__+0x1742458>
  for (i = 0; i < nwords; ++i)
    1c54:	026c0000 	rsbeq	r0, ip, #0
  int nwords = (nbits / 32);
    1c58:	0c910000 	ldceq	0, cr0, [r1], {0}
    1c5c:	01010000 	mrseq	r0, (UNDEF: 1)
    x[i] = 0;
    1c60:	00740250 	rsbseq	r0, r4, r0, asr r2
  for (i = 0; i < nwords; ++i)
    1c64:	01510101 	cmpeq	r1, r1, lsl #2
    1c68:	52010130 	andpl	r0, r1, #48, 2
  j = 0;
    1c6c:	00800802 	addeq	r0, r0, r2, lsl #16
    x[i] = y[j];
    1c70:	000a9602 	andeq	r9, sl, r2, lsl #12
    1c74:	0002a400 	andeq	sl, r2, r0, lsl #8
    i += 1;
    1c78:	000cab00 	andeq	sl, ip, r0, lsl #22
    j += 1;
    1c7c:	50010100 	andpl	r0, r1, r0, lsl #2
  while (i < BITVEC_NWORDS)
    1c80:	01007402 	tsteq	r0, r2, lsl #8
  if (nbits != 0)
    1c84:	08025201 	stmdaeq	r2, {r0, r9, ip, lr}
}
    1c88:	9c020080 	stcls	0, cr0, [r2], {128}	@ 0x80
      x[i]  = (x[i] << nbits) | (x[i - 1] >> (32 - nbits));
    1c8c:	8e00000a 	cdphi	0, 0, cr0, cr0, cr10, {0}
    1c90:	bf000002 	svclt	0x00000002
    1c94:	0100000c 	tsteq	r0, ip
    1c98:	74025001 	strvc	r5, [r2], #-1
    1c9c:	a6060000 	strge	r0, [r6], -r0
    1ca0:	ed00000a 	stc	0, cr0, [r0, #-40]	@ 0xffffffd8
    1ca4:	01000002 	tsteq	r0, r2
    1ca8:	03055001 	movweq	r5, #20481	@ 0x5001
    for (i = (BITVEC_NWORDS - 1); i > 0; --i)
    1cac:	00002760 	andeq	r2, r0, r0, ror #14
    x[0] <<= nbits;
    1cb0:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    1cb4:	00000074 	andeq	r0, r0, r4, ror r0
    for (i = (BITVEC_NWORDS - 1); i > 0; --i)
    1cb8:	0005760d 	andeq	r7, r5, sp, lsl #12
  x[0] = 1;
    1cbc:	09de5b00 	ldmibeq	lr, {r8, r9, fp, ip, lr}^
  for (i = 1; i < BITVEC_NWORDS; ++i)
    1cc0:	00720000 	rsbseq	r0, r2, r0
    x[i] = 0;
    1cc4:	9c010000 	stcls	0, cr0, [r1], {-0}
  for (i = 1; i < BITVEC_NWORDS; ++i)
    1cc8:	00000da4 	andeq	r0, r0, r4, lsr #27
    1ccc:	00063204 	andeq	r3, r6, r4, lsl #4
  if (x[0] != 1)
    1cd0:	ba235b00 	blt	8d88d8 <__ROM_SIZE__+0x8988d8>
    1cd4:	22000000 	andcs	r0, r0, #0
  for (i = 1; i < BITVEC_NWORDS; ++i)
    1cd8:	1a000007 	bne	1cfc <gf2field_add+0xa>
    if (x[i] != 0)
    1cdc:	04000007 	streq	r0, [r0], #-7
  for (i = 1; i < BITVEC_NWORDS; ++i)
    1ce0:	00000479 	andeq	r0, r0, r9, ror r4
  return (i == BITVEC_NWORDS);
    1ce4:	0a93325b 	beq	fe4ce658 <_STACK_TOP_+0xde4c665c>
    1ce8:	07470000 	strbeq	r0, [r7, -r0]
    1cec:	073f0000 	ldreq	r0, [pc, -r0]!
}
    1cf0:	db070000 	blle	1c1cf8 <__ROM_SIZE__+0x181cf8>
  for (i = 0; i < BITVEC_NWORDS; ++i)
    1cf4:	65000006 	strvs	r0, [r0, #-6]
{
    1cf8:	00006a07 	andeq	r6, r0, r7, lsl #20
    z[i] = (x[i] ^ y[i]);
    1cfc:	00076900 	andeq	r6, r7, r0, lsl #18
    1d00:	00076700 	andeq	r6, r7, r0, lsl #14
    1d04:	0a020200 	beq	8250c <__ROM_SIZE__+0x4250c>
  for (i = 0; i < BITVEC_NWORDS; ++i)
    1d08:	02ed0000 	rsceq	r0, sp, #0
    1d0c:	0d430000 	stcleq	0, cr0, [r3, #-0]
}
    1d10:	01010000 	mrseq	r0, (UNDEF: 1)
  x[0] ^= 1;
    1d14:	60030550 	andvs	r0, r3, r0, asr r5
    1d18:	01000027 	tsteq	r0, r7, lsr #32
}
    1d1c:	74025101 	strvc	r5, [r2], #-257	@ 0xfffffeff
{
    1d20:	0c020000 	stceq	0, cr0, [r2], {-0}
    1d24:	6c00000a 	stcvs	0, cr0, [r0], {10}
  bitvec_copy(tmp, x);
    1d28:	5c000002 	stcpl	0, cr0, [r0], {2}
    1d2c:	0100000d 	tsteq	r0, sp
  if (bitvec_get_bit(y, 0) != 0)
    1d30:	30015101 	andcc	r5, r1, r1, lsl #2
    1d34:	02520101 	subseq	r0, r2, #1073741824	@ 0x40000000
    bitvec_copy(z, x);
    1d38:	02008008 	andeq	r8, r0, #8
    1d3c:	00000a34 	andeq	r0, r0, r4, lsr sl
{
    1d40:	000002a4 	andeq	r0, r0, r4, lsr #5
    bitvec_set_zero(z);
    1d44:	00000d76 	andeq	r0, r0, r6, ror sp
    1d48:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
      gf2field_add(tmp, tmp, polynomial);
    1d4c:	01010074 	tsteq	r1, r4, ror r0
    1d50:	80080252 	andhi	r0, r8, r2, asr r2
    1d54:	0a3a0200 	beq	e8255c <__ROM_SIZE__+0xe4255c>
  for (i = 1; i < CURVE_DEGREE; ++i)
    1d58:	028e0000 	addeq	r0, lr, #0
    1d5c:	0d8a0000 	stceq	0, cr0, [sl]
    bitvec_lshift(tmp, tmp, 1);
    1d60:	01010000 	mrseq	r0, (UNDEF: 1)
    1d64:	00740250 	rsbseq	r0, r4, r0, asr r2
    if (bitvec_get_bit(tmp, CURVE_DEGREE))
    1d68:	0a440600 	beq	1103570 <__ROM_SIZE__+0x10c3570>
    1d6c:	02ed0000 	rsceq	r0, sp, #0
    1d70:	01010000 	mrseq	r0, (UNDEF: 1)
    if (bitvec_get_bit(y, i))
    1d74:	60030550 	andvs	r0, r3, r0, asr r5
    1d78:	01000027 	tsteq	r0, r7, lsr #32
    1d7c:	74025101 	strvc	r5, [r2], #-257	@ 0xfffffeff
      gf2field_add(z, z, tmp);
    1d80:	0d000000 	stceq	0, cr0, [r0, #-0]
    1d84:	00000529 	andeq	r0, r0, r9, lsr #10
    1d88:	0007a04e 	andeq	sl, r7, lr, asr #32
}
    1d8c:	00001200 	andeq	r1, r0, r0, lsl #4
    1d90:	d59c0100 	ldrle	r0, [ip, #256]	@ 0x100
{
    1d94:	0400000d 	streq	r0, [r0], #-13
    1d98:	00000479 	andeq	r0, r0, r9, ror r4
  bitvec_copy(u, x);
    1d9c:	006a1e4e 	rsbeq	r1, sl, lr, asr #28
  bitvec_copy(v, polynomial);
    1da0:	07750000 	ldrbeq	r0, [r5, -r0]!
    1da4:	07710000 	ldrbeq	r0, [r1, -r0]!
  bitvec_set_zero(g);
    1da8:	aa030000 	bge	c1db0 <__ROM_SIZE__+0x81db0>
    1dac:	d5000007 	strle	r0, [r0, #-7]
  gf2field_set_one(z);
    1db0:	0000000d 	andeq	r0, r0, sp
  while (!gf2field_is_one(u))
    1db4:	0006770d 	andeq	r7, r6, sp, lsl #14
    bitvec_lshift(h, v, i);
    1db8:	07844800 	streq	r4, [r4, r0, lsl #16]
    1dbc:	001c0000 	andseq	r0, ip, r0
    gf2field_add(u, u, h);
    1dc0:	9c010000 	stcls	0, cr0, [r1], {-0}
    1dc4:	00000e14 	andeq	r0, r0, r4, lsl lr
    1dc8:	00078e14 	andeq	r8, r7, r4, lsl lr
    bitvec_lshift(h, g, i);
    1dcc:	000df800 	andeq	pc, sp, r0, lsl #16
    1dd0:	50010100 	andpl	r0, r1, r0, lsl #2
    gf2field_add(z, z, h);
    1dd4:	14003801 	strne	r3, [r0], #-2049	@ 0xfffff7ff
    1dd8:	00000794 	muleq	r0, r4, r7
    1ddc:	00000e08 	andeq	r0, r0, r8, lsl #28
  while (!gf2field_is_one(u))
    1de0:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    1de4:	1c002008 	stcne	0, cr2, [r0], {8}
    i = (bitvec_degree(u) - bitvec_degree(v));
    1de8:	0000079a 	muleq	r0, sl, r7
    1dec:	01500101 	cmpeq	r0, r1, lsl #2
    1df0:	39000038 	stmdbcc	r0, {r3, r4, r5}
    1df4:	000004ac 	andeq	r0, r0, ip, lsr #9
    if (i < 0)
    1df8:	6a1b4601 	bvs	6d3604 <__ROM_SIZE__+0x693604>
      bitvec_swap(u, v);
    1dfc:	88000000 	stmdahi	r0, {}	@ <UNPREDICTABLE>
    1e00:	0400000b 	streq	r0, [r0], #-11
      bitvec_swap(g, z);
    1e04:	01000000 	mrseq	r0, (UNDEF: 0)
    1e08:	06683a9c 			@ <UNDEFINED> instruction: 0x06683a9c
      i = -i;
    1e0c:	40010000 	andmi	r0, r1, r0
}
    1e10:	000ae41c 	andeq	lr, sl, ip, lsl r4
    1e14:	00000200 	andeq	r0, r0, r0, lsl #4
{
    1e18:	279c0100 	ldrcs	r0, [ip, r0, lsl #2]
    1e1c:	00000621 	andeq	r0, r0, r1, lsr #12
  bitvec_copy(x1, x2);
    1e20:	000ae23b 	andeq	lr, sl, fp, lsr r2
  bitvec_copy(y1, y2);
    1e24:	00000200 	andeq	r0, r0, r0, lsl #4
    1e28:	279c0100 	ldrcs	r0, [ip, r0, lsl #2]
}
    1e2c:	000004fe 	strdeq	r0, [r0], -lr
{
    1e30:	000ae037 	andeq	lr, sl, r7, lsr r0
  bitvec_set_zero(x);
    1e34:	00000200 	andeq	r0, r0, r0, lsl #4
  bitvec_set_zero(y);
    1e38:	209c0100 	addscs	r0, ip, r0, lsl #2
}
    1e3c:	000002df 	ldrdeq	r0, [r0], -pc	@ <UNPREDICTABLE>
{
    1e40:	000ad435 	andeq	sp, sl, r5, lsr r4
  return (    bitvec_is_zero(x)
    1e44:	00000c00 	andeq	r0, r0, r0, lsl #24
           && bitvec_is_zero(y));
    1e48:	7e9c0100 	fmlvce	f0, f4, f0
    1e4c:	1500000e 	strne	r0, [r0, #-14]
    1e50:	0000058b 	andeq	r0, r0, fp, lsl #11
{
    1e54:	015c1d35 	cmpeq	ip, r5, lsr sp
    1e58:	50010000 	andpl	r0, r1, r0
  if (bitvec_is_zero(x))
    1e5c:	02d02000 	sbcseq	r2, r0, #0
    1e60:	c8340000 	ldmdagt	r4!, {}	@ <UNPREDICTABLE>
    bitvec_set_zero(y);
    1e64:	0c00000a 	stceq	0, cr0, [r0], {10}
}
    1e68:	01000000 	mrseq	r0, (UNDEF: 0)
    gf2field_inv(l, x);
    1e6c:	000ea09c 	muleq	lr, ip, r0
    1e70:	058b1500 	streq	r1, [fp, #1280]	@ 0x500
    gf2field_mul(l, l, y);
    1e74:	1c340000 	ldcne	0, cr0, [r4], #-0
    1e78:	0000015c 	andeq	r0, r0, ip, asr r1
    1e7c:	20005001 	andcs	r5, r0, r1
    gf2field_add(l, l, x);
    1e80:	000002c1 	andeq	r0, r0, r1, asr #5
    1e84:	000abc32 	andeq	fp, sl, r2, lsr ip
    gf2field_mul(y, x, x);
    1e88:	00000c00 	andeq	r0, r0, r0, lsl #24
    1e8c:	c29c0100 	addsgt	r0, ip, #0, 2
    1e90:	1500000e 	strne	r0, [r0, #-14]
    gf2field_mul(x, l, l);
    1e94:	0000058b 	andeq	r0, r0, fp, lsl #11
    1e98:	012a1b32 			@ <UNDEFINED> instruction: 0x012a1b32
    gf2field_inc(l);
    1e9c:	50010000 	andpl	r0, r1, r0
    1ea0:	02ef3b00 	rsceq	r3, pc, #0, 22
    gf2field_add(x, x, l);
    1ea4:	31010000 	mrscc	r0, (UNDEF: 1)
    1ea8:	000ab006 	andeq	fp, sl, r6
    gf2field_mul(l, l, x);
    1eac:	00000c00 	andeq	r0, r0, r0, lsl #24
    1eb0:	159c0100 	ldrne	r0, [ip, #256]	@ 0x100
    1eb4:	0000058b 	andeq	r0, r0, fp, lsl #11
    gf2field_add(y, y, l);
    1eb8:	012a1a31 			@ <UNDEFINED> instruction: 0x012a1a31
    1ebc:	50010000 	andpl	r0, r1, r0
}
    1ec0:	03050000 	movweq	r0, #20480	@ 0x5000
{
    1ec4:	00050000 	andeq	r0, r5, r0
    1ec8:	0cb20401 	cfldrseq	mvf0, [r2], #4
    1ecc:	0d0b0000 	stceq	0, cr0, [fp, #-0]
  if (!gf2point_is_zero(x2, y2))
    1ed0:	1d000000 	stcne	0, cr0, [r0, #-0]
    1ed4:	0000077b 	andeq	r0, r0, fp, ror r7
    if (gf2point_is_zero(x1, y1))
    1ed8:	0000013a 	andeq	r0, r0, sl, lsr r1
    1edc:	00000d74 	andeq	r0, r0, r4, ror sp
    1ee0:	0000025c 	andeq	r0, r0, ip, asr r2
      if (bitvec_equal(x1, x2))
    1ee4:	000013d8 	ldrdeq	r1, [r0], -r8
    1ee8:	0003cd03 	andeq	ip, r3, r3, lsl #26
        if (bitvec_equal(y1, y2))
    1eec:	310e5e00 	tstcc	lr, r0, lsl #28
    1ef0:	14000001 	strne	r0, [r0], #-1
    1ef4:	bc00000f 	stclt	0, cr0, [r0], {15}
          gf2point_double(x1, y1);
    1ef8:	01000000 	mrseq	r0, (UNDEF: 0)
    1efc:	0001319c 	muleq	r1, ip, r1
      gf2point_copy(x1, y1, x2, y2);
    1f00:	07750200 	ldrbeq	r0, [r5, -r0, lsl #4]!
    1f04:	2a5e0000 	bcs	1781f0c <__ROM_SIZE__+0x1741f0c>
    1f08:	00000138 	andeq	r0, r0, r8, lsr r1
}
    1f0c:	00000794 	muleq	r0, r4, r7
          gf2point_set_zero(x1, y1);
    1f10:	00000790 	muleq	r0, r0, r7
    1f14:	00074502 	andeq	r4, r7, r2, lsl #10
    1f18:	31405e00 	cmpcc	r0, r0, lsl #28
        gf2field_add(a, y1, y2);
    1f1c:	a7000001 	strge	r0, [r0, -r1]
    1f20:	a3000007 	movwge	r0, #7
        gf2field_add(b, x1, x2);
    1f24:	02000007 	andeq	r0, r0, #7
    1f28:	0000073e 	andeq	r0, r0, lr, lsr r7
    1f2c:	01385c5e 	teqeq	r8, lr, asr ip
        gf2field_inv(c, b);
    1f30:	07bd0000 	ldreq	r0, [sp, r0]!
    1f34:	07b90000 	ldreq	r0, [r9, r0]!
        gf2field_mul(c, c, a);
    1f38:	67040000 	strvs	r0, [r4, -r0]
    1f3c:	5f000007 	svcpl	0x00000007
        gf2field_mul(d, c, c);
    1f40:	00013110 	andeq	r3, r1, r0, lsl r1
    1f44:	0007d000 	andeq	sp, r7, r0
    1f48:	0007cc00 	andeq	ip, r7, r0, lsl #24
        gf2field_add(d, d, c);
    1f4c:	0f220600 	svceq	0x00220600
    1f50:	00480000 	subeq	r0, r8, r0
        gf2field_add(d, d, b);
    1f54:	00df0000 	sbcseq	r0, pc, r0
    1f58:	69070000 	stmdbvs	r7, {}	@ <UNPREDICTABLE>
    1f5c:	01316200 	teqeq	r1, r0, lsl #4
        gf2field_inc(d);
    1f60:	07e30000 	strbeq	r0, [r3, r0]!
        gf2field_add(x1, x1, d);
    1f64:	07df0000 	ldrbeq	r0, [pc, r0]
    1f68:	2c010000 	stccs	0, cr0, [r1], {-0}
    1f6c:	b700000f 	strlt	r0, [r0, -pc]
        gf2field_mul(a, x1, c);
    1f70:	01000002 	tsteq	r0, r2
    1f74:	00000f34 	andeq	r0, r0, r4, lsr pc
        gf2field_add(a, a, d);
    1f78:	000002b7 			@ <UNDEFINED> instruction: 0x000002b7
    1f7c:	000f4001 	andeq	r4, pc, r1
    1f80:	0002b700 	andeq	fp, r2, r0, lsl #14
        gf2field_add(y1, y1, a);
    1f84:	0f480100 	svceq	0x00480100
    1f88:	02b70000 	adcseq	r0, r7, #0
        bitvec_copy(x1, d);
    1f8c:	54010000 	strpl	r0, [r1], #-0
    1f90:	b700000f 	strlt	r0, [r0, -pc]
}
    1f94:	01000002 	tsteq	r0, r2
{
    1f98:	00000f5c 	andeq	r0, r0, ip, asr pc
    1f9c:	000002b7 			@ <UNDEFINED> instruction: 0x000002b7
  int nbits = bitvec_degree(exp);
    1fa0:	0f200800 	svceq	0x00200800
    1fa4:	022e0000 	eoreq	r0, lr, #0
  gf2point_set_zero(tmpx, tmpy);
    1fa8:	00fa0000 	rscseq	r0, sl, r0
    1fac:	01050000 	mrseq	r0, (UNDEF: 5)
  for (i = (nbits - 1); i >= 0; --i)
    1fb0:	00740250 	rsbseq	r0, r4, r0, asr r2
    1fb4:	03510105 	cmpeq	r1, #1073741825	@ 0x40000001
    1fb8:	005101a3 	subseq	r0, r1, r3, lsr #3
    gf2point_double(tmpx, tmpy);
    1fbc:	000f9001 	andeq	r9, pc, r1
    1fc0:	0002b700 	andeq	fp, r2, r0, lsl #14
    if (bitvec_get_bit(exp, i))
    1fc4:	0f980100 	svceq	0x00980100
    1fc8:	02b70000 	adcseq	r0, r7, #0
    1fcc:	a6010000 	strge	r0, [r1], -r0
      gf2point_add(tmpx, tmpy, x, y);
    1fd0:	b700000f 	strlt	r0, [r0, -pc]
    1fd4:	01000002 	tsteq	r0, r2
    1fd8:	00000fae 	andeq	r0, r0, lr, lsr #31
  gf2point_copy(x, y, tmpx, tmpy);
    1fdc:	000002b7 			@ <UNDEFINED> instruction: 0x000002b7
    1fe0:	000fba01 	andeq	fp, pc, r1, lsl #20
    1fe4:	0002b700 	andeq	fp, r2, r0, lsl #14
}
    1fe8:	0fc20100 	svceq	0x00c20100
{
    1fec:	02b70000 	adcseq	r0, r7, #0
    1ff0:	09000000 	stmdbeq	r0, {}	@ <UNPREDICTABLE>
  if (gf2point_is_zero(x, y))
    1ff4:	01020704 	tsteq	r2, r4, lsl #14
    1ff8:	040c0000 	streq	r0, [ip], #-0
}
    1ffc:	0000013e 	andeq	r0, r0, lr, lsr r1
    gf2field_mul(a, x, x);
    2000:	d7080109 	strle	r0, [r8, -r9, lsl #2]
    2004:	03000000 	movweq	r0, #0
    2008:	000003b8 			@ <UNDEFINED> instruction: 0x000003b8
    gf2field_mul(b, a, x);
    200c:	01310e38 	teqeq	r1, r8, lsr lr
    2010:	0e2c0000 	cdpeq	0, 2, cr0, cr12, cr0, {0}
    gf2field_add(a, a, b);
    2014:	00e80000 	rsceq	r0, r8, r0
    2018:	9c010000 	stcls	0, cr0, [r1], {-0}
    201c:	0000022e 	andeq	r0, r0, lr, lsr #4
    gf2field_add(a, a, coeff_b);
    2020:	00077502 	andeq	r7, r7, r2, lsl #10
    2024:	382a3800 	stmdacc	sl!, {fp, ip, sp}
    gf2field_mul(b, y, y);
    2028:	f7000001 			@ <UNDEFINED> instruction: 0xf7000001
    202c:	f3000007 	vhadd.u8	d0, d0, d7
    2030:	02000007 	andeq	r0, r0, #7
    gf2field_add(a, a, b);
    2034:	00000745 	andeq	r0, r0, r5, asr #14
    2038:	01314038 	teqeq	r1, r8, lsr r0
    gf2field_mul(b, x, y);
    203c:	080a0000 	stmdaeq	sl, {}	@ <UNPREDICTABLE>
    2040:	08060000 	stmdaeq	r6, {}	@ <UNPREDICTABLE>
    2044:	3e020000 	cdpcc	0, 0, cr0, cr2, cr0, {0}
    return bitvec_equal(a, b);
    2048:	38000007 	stmdacc	r0, {r0, r1, r2}
    204c:	0001385c 	andeq	r3, r1, ip, asr r8
    2050:	00081d00 	andeq	r1, r8, r0, lsl #26
{
    2054:	00081900 	andeq	r1, r8, r0, lsl #18
    2058:	07230400 	streq	r0, [r3, -r0, lsl #8]!
  gf2point_copy((uint32_t*)public_key, (uint32_t*)(public_key + BITVEC_NBYTES), base_x, base_y);
    205c:	10390000 	eorsne	r0, r9, r0
    2060:	00000131 	andeq	r0, r0, r1, lsr r1
    2064:	0000082e 	andeq	r0, r0, lr, lsr #16
    2068:	0000082c 	andeq	r0, r0, ip, lsr #16
  if (bitvec_degree((uint32_t*)private_key) < (CURVE_DEGREE / 2))
    206c:	000e3e06 	andeq	r3, lr, r6, lsl #28
    2070:	00004c00 	andeq	r4, r0, r0, lsl #24
    2074:	0001ec00 	andeq	lr, r1, r0, lsl #24
    int nbits = bitvec_degree(base_order);
    2078:	00690700 	rsbeq	r0, r9, r0, lsl #14
    for (i = (nbits - 1); i < (BITVEC_NWORDS * 32); ++i)
    207c:	0001313c 	andeq	r3, r1, ip, lsr r1
      bitvec_clr_bit((uint32_t*)private_key, i);
    2080:	00083a00 	andeq	r3, r8, r0, lsl #20
    2084:	00083600 	andeq	r3, r8, r0, lsl #12
    for (i = (nbits - 1); i < (BITVEC_NWORDS * 32); ++i)
    2088:	0e4a0100 	dvfeqe	f0, f2, f0
    208c:	02e10000 	rsceq	r0, r1, #0
    gf2point_mul((uint32_t*)public_key, (uint32_t*)(public_key + BITVEC_NBYTES), (uint32_t*)private_key);
    2090:	5e010000 	cdppl	0, 0, cr0, cr1, cr0, {0}
    2094:	e100000e 	tst	r0, lr
    return 1;
    2098:	01000002 	tsteq	r0, r2
    return 0;
    209c:	00000e72 	andeq	r0, r0, r2, ror lr
    20a0:	000002e1 	andeq	r0, r0, r1, ror #5
    20a4:	000e7e01 	andeq	r7, lr, r1, lsl #28
{
    20a8:	0002e100 	andeq	lr, r2, r0, lsl #2
    20ac:	ac080000 	stcge	0, cr0, [r8], {-0}
  if (    !gf2point_is_zero ((uint32_t*)others_pub, (uint32_t*)(others_pub + BITVEC_NBYTES))
    20b0:	8a00000e 	bhi	20f0 <atoi>
    20b4:	00000002 	andeq	r0, r0, r2
    20b8:	05000002 	streq	r0, [r0, #-2]
    20bc:	78025001 	stmdavc	r2, {r0, ip, lr}
}
    20c0:	bc010000 	stclt	0, cr0, [r1], {-0}
       &&  gf2point_on_curve((uint32_t*)others_pub, (uint32_t*)(others_pub + BITVEC_NBYTES)) )
    20c4:	e100000e 	tst	r0, lr
    20c8:	01000002 	tsteq	r0, r2
    20cc:	00000eca 	andeq	r0, r0, sl, asr #29
    for (i = 0; i < (BITVEC_NBYTES * 2); ++i)
    20d0:	000002e1 	andeq	r0, r0, r1, ror #5
      output[i] = others_pub[i];
    20d4:	000ee001 	andeq	lr, lr, r1
    20d8:	0002e100 	andeq	lr, r2, r0, lsl #2
    for (i = 0; i < (BITVEC_NBYTES * 2); ++i)
    20dc:	0ef40100 	cdpeq	1, 15, cr0, cr4, cr0, {0}
    gf2point_mul((uint32_t*)output,(uint32_t*)(output + BITVEC_NBYTES), (const uint32_t*)private_key);
    20e0:	02e10000 	rsceq	r0, r1, #0
    20e4:	02010000 	andeq	r0, r1, #0
    20e8:	e100000f 	tst	r0, pc
    return 1;
    20ec:	00000002 	andeq	r0, r0, r2
int atoi(const char* str) {
    20f0:	0007c403 	andeq	ip, r7, r3, lsl #8
  int res = 0;
    20f4:	310e2d00 	tstcc	lr, r0, lsl #26
    res = res * 10 + str[i] - '0';
    20f8:	f8000001 			@ <UNDEFINED> instruction: 0xf8000001
    20fc:	3400000d 	strcc	r0, [r0], #-13
    2100:	01000000 	mrseq	r0, (UNDEF: 0)
  for (int i = 0; str[i] != '\0'; ++i) {
    2104:	00028a9c 	muleq	r2, ip, sl
    2108:	07750200 	ldrbeq	r0, [r5, -r0, lsl #4]!
}
    210c:	312d0000 			@ <UNDEFINED> instruction: 0x312d0000
  for (uint32_t i = 0; str[i] != '\0'; i++) {
    2110:	00000138 	andeq	r0, r0, r8, lsr r1
    2114:	0000084e 	andeq	r0, r0, lr, asr #16
    } else if (str[i] >= 'a' && str[i] <= 'f') {
    2118:	0000084a 	andeq	r0, r0, sl, asr #16
    211c:	00074502 	andeq	r4, r7, r2, lsl #10
      value = str[i] - 'a' + 10;
    2120:	31472d00 	cmpcc	r7, r0, lsl #26
    hex |= value;
    2124:	63000001 	movwvs	r0, #1
  for (uint32_t i = 0; str[i] != '\0'; i++) {
    2128:	5d000008 	stcpl	0, cr0, [r0, #-32]	@ 0xffffffe0
    212c:	04000008 	streq	r0, [r0], #-8
    if (str[i] >= '0' && str[i] <= '9') {
    2130:	000007be 			@ <UNDEFINED> instruction: 0x000007be
    2134:	0138122e 	teqeq	r8, lr, lsr #4
      value = str[i] - '0';
    2138:	087d0000 	ldmdaeq	sp!, {}^	@ <UNPREDICTABLE>
    } else if (str[i] >= 'A' && str[i] <= 'F') {
    213c:	08790000 	ldmdaeq	r9!, {}^	@ <UNPREDICTABLE>
    2140:	0a010000 	beq	42148 <__ROM_SIZE__+0x2148>
    2144:	b700000e 	strlt	r0, [r0, -lr]
      value = str[i] - 'A' + 10;
    2148:	00000002 	andeq	r0, r0, r2
  selected_mode = mode;
    214c:	00075203 	andeq	r5, r7, r3, lsl #4
  if (selected_mode == NONE) {
    2150:	310e2900 	tstcc	lr, r0, lsl #18
  out_buf_rgn.addr = addr;
    2154:	e4000001 	str	r0, [r0], #-1
  out_buf_rgn.size = size / 2;
    2158:	1400000d 	strne	r0, [r0], #-13
  out_buf_rgn.curr_index = 0;
    215c:	01000000 	mrseq	r0, (UNDEF: 0)
  inp_buf_rgn.addr = addr + size / 2;
    2160:	0002b79c 	muleq	r2, ip, r7
  inp_buf_rgn.curr_index = 0;
    2164:	07450200 	strbeq	r0, [r5, -r0, lsl #4]
  if (!(selected_mode & INP)) {
    2168:	30290000 	eorcc	r0, r9, r0
    out_buf_rgn.size = size;
    216c:	00000131 	andeq	r0, r0, r1, lsr r1
  memset(addr, 0, size);
    2170:	00000892 	muleq	r0, r2, r8
    2174:	0000088c 	andeq	r0, r0, ip, lsl #17
  } else if (!(selected_mode & OUT)) {
    2178:	072d0300 	streq	r0, [sp, -r0, lsl #6]!
    217c:	0f160000 	svceq	0x00160000
    inp_buf_rgn.addr = addr;
    2180:	0000013e 	andeq	r0, r0, lr, lsr r1
    inp_buf_rgn.size = size;
    2184:	00000da6 	andeq	r0, r0, r6, lsr #27
    2188:	0000003e 	andeq	r0, r0, lr, lsr r0
  if (!(selected_mode & INP)) {
    218c:	02e19c01 	rsceq	r9, r1, #256	@ 0x100
    2190:	630a0000 	movwvs	r0, #40960	@ 0xa000
    2194:	013e1600 	teqeq	lr, r0, lsl #12
  if (inp_buf_rgn.addr[inp_buf_rgn.curr_index] == 0) {
    2198:	08ac0000 	stmiaeq	ip!, {}	@ <UNPREDICTABLE>
    219c:	08a80000 	stmiaeq	r8!, {}	@ <UNPREDICTABLE>
  int val = inp_buf_rgn.addr[inp_buf_rgn.curr_index];
    21a0:	0d000000 	stceq	0, cr0, [r0, #-0]
  inp_buf_rgn.addr[inp_buf_rgn.curr_index] = 0;
    21a4:	000007ad 	andeq	r0, r0, sp, lsr #15
  inp_buf_rgn.curr_index++;
    21a8:	3e0f0301 	cdpcc	3, 0, cr0, cr15, cr1, {0}
    21ac:	74000001 	strvc	r0, [r0], #-1
  if (inp_buf_rgn.curr_index == inp_buf_rgn.size) {
    21b0:	3200000d 	andcc	r0, r0, #13
}
    21b4:	01000000 	mrseq	r0, (UNDEF: 0)
    inp_buf_rgn.curr_index = 0;
    21b8:	00760a9c 			@ <UNDEFINED> instruction: 0x00760a9c
    return -1;
    21bc:	00013e03 	andeq	r3, r1, r3, lsl #28
    21c0:	0008d200 	andeq	sp, r8, r0, lsl #4
    return -1;
    21c4:	0008ba00 	andeq	fp, r8, r0, lsl #20
    21c8:	2b000000 	blcs	21d0 <memlog_putc+0x4>
  if (!(selected_mode & OUT) || c == 0) {
    21cc:	05000003 	streq	r0, [r0, #-3]
    21d0:	91040100 	mrsls	r0, (UNDEF: 20)
    21d4:	1000000d 	andne	r0, r0, sp
  out_buf_rgn.addr[out_buf_rgn.curr_index] = (uint8_t) c;
    21d8:	0000000d 	andeq	r0, r0, sp
    21dc:	00084c1d 	andeq	r4, r8, sp, lsl ip
  out_buf_rgn.curr_index++;
    21e0:	00013a00 	andeq	r3, r1, r0, lsl #20
  if (out_buf_rgn.curr_index == out_buf_rgn.size) {
    21e4:	000fd000 	andeq	sp, pc, r0
    21e8:	00023800 	andeq	r3, r2, r0, lsl #16
    out_buf_rgn.curr_index = 0;
    21ec:	00183e00 	andseq	r3, r8, r0, lsl #28
    21f0:	07d90400 	ldrbeq	r0, [r9, r0, lsl #8]
    21f4:	28020000 	stmdacs	r2, {}	@ <UNPREDICTABLE>
size_t strlen(const char *str) {
    21f8:	0000321b 	andeq	r3, r0, fp, lsl r2
  while (str[len]) {
    21fc:	082b1100 	stmdaeq	fp!, {r8, ip}
    2200:	03040000 	movweq	r0, #16384	@ 0x4000
    2204:	00004900 	andeq	r4, r0, r0, lsl #18
  while (*str1 && (*str1 == *str2)) {
    2208:	08a11200 	stmiaeq	r1!, {r9, ip}
    str2++;
    220c:	00490000 	subeq	r0, r9, r0
  while (*str1 && (*str1 == *str2)) {
    2210:	00000000 	andeq	r0, r0, r0
    2214:	2d040413 	cfstrscs	mvf0, [r4, #-76]	@ 0xffffffb4
  return *str1 - *str2;
    2218:	02000008 	andeq	r0, r0, #8
}
    221c:	00261863 	eoreq	r1, r6, r3, ror #16
    *(str1++) = *(str2++);
    2220:	04140000 	ldreq	r0, [r4], #-0
    2224:	746e6905 	strbtvc	r6, [lr], #-2309	@ 0xfffff6fb
  while (*str2) {
    2228:	00691500 	rsbeq	r1, r9, r0, lsl #10
  *str1 = '\0';
    222c:	69160000 	ldmdbvs	r6, {}	@ <UNPREDICTABLE>
}
    2230:	00000000 	andeq	r0, r0, r0
  for (i = 0; i < size; i++) {
    2234:	e0080103 	and	r0, r8, r3, lsl #2
    dest_char[i] = src_char[i];
    2238:	17000000 	strne	r0, [r0, -r0]
    223c:	00000069 	andeq	r0, r0, r9, rrx
  for (i = 0; i < size; i++) {
    2240:	00067e18 	andeq	r7, r6, r8, lsl lr
}
    2244:	0f180100 	svceq	0x00180100
  for (i = 0; i < size; i++) {
    2248:	00000081 	andeq	r0, r0, r1, lsl #1
    dest_char[i] = val;
    224c:	00005e05 	andeq	r5, r0, r5, lsl #28
  for (i = 0; i < size; i++) {
    2250:	01071900 	tsteq	r7, r0, lsl #18
}
    2254:	000000a1 	andeq	r0, r0, r1, lsr #1
    2258:	a10e2301 	tstge	lr, r1, lsl #6
    225c:	0a000000 	beq	2264 <_etext+0x4>
    2260:	00000893 	muleq	r0, r3, r8
    2264:	08040a00 	stmdaeq	r4, {r9, fp}
    2268:	00010000 	andeq	r0, r1, r0
    226c:	d7080103 	strle	r0, [r8, -r3, lsl #2]
    2270:	04000000 	streq	r0, [r0], #-0
    2274:	00000835 	andeq	r0, r0, r5, lsr r8
    2278:	86032601 	strhi	r2, [r3], -r1, lsl #12
    227c:	0b000000 	bleq	2284 <_varaes+0x4>
    2280:	00000069 	andeq	r0, r0, r9, rrx
    2284:	000000c4 	andeq	r0, r0, r4, asr #1
    2288:	0000c40c 	andeq	ip, r0, ip, lsl #8
    228c:	03000f00 	movweq	r0, #3840	@ 0xf00
    2290:	01020704 	tsteq	r2, r4, lsl #14
    2294:	120d0000 	andne	r0, sp, #0
    2298:	28000008 	stmdacs	r0, {r3}
    229c:	0000b40d 	andeq	fp, r0, sp, lsl #8
    22a0:	20030500 	andcs	r0, r3, r0, lsl #10
    22a4:	1a000028 	bne	234c <cmd_end_+0x30>
    22a8:	00000124 	andeq	r0, r0, r4, lsr #2
    22ac:	5705a901 	strpl	sl, [r5, -r1, lsl #18]
    22b0:	2c000000 	stccs	0, cr0, [r0], {-0}
    22b4:	dc000011 	stcle	0, cr0, [r0], {17}
    22b8:	01000000 	mrseq	r0, (UNDEF: 0)
    22bc:	0001799c 	muleq	r1, ip, r9
    22c0:	6d660600 	stclvs	6, cr0, [r6, #-0]
    22c4:	18a90074 	stmiane	r9!, {r2, r4, r5, r6}
    22c8:	00000179 	andeq	r0, r0, r9, ror r1
    22cc:	0000093d 	andeq	r0, r0, sp, lsr r9
    22d0:	0000092d 	andeq	r0, r0, sp, lsr #18
    22d4:	08ae021b 	stmiaeq	lr!, {r0, r1, r3, r4, r9}
    22d8:	10aa0000 	adcne	r0, sl, r0
    22dc:	000000a8 	andeq	r0, r0, r8, lsr #1
    22e0:	00000993 	muleq	r0, r3, r9
    22e4:	00000977 	andeq	r0, r0, r7, ror r9
    22e8:	00089c0d 	andeq	r9, r8, sp, lsl #24
    22ec:	4b0bab00 	blmi	2ecef4 <__ROM_SIZE__+0x2acef4>
    22f0:	02000000 	andeq	r0, r0, #0
    22f4:	4e075c91 	mcrmi	12, 0, r5, cr7, cr1, {4}
    22f8:	59000000 	stmdbpl	r0, {}	@ <UNPREDICTABLE>
    22fc:	02000001 	andeq	r0, r0, #1
    2300:	00000823 	andeq	r0, r0, r3, lsr #16
    2304:	005711d4 	ldrsbeq	r1, [r7], #-20	@ 0xffffffec
    2308:	0a050000 	beq	142310 <__ROM_SIZE__+0x102310>
    230c:	09fd0000 	ldmibeq	sp!, {}^	@ <UNPREDICTABLE>
    2310:	d0080000 	andle	r0, r8, r0
    2314:	7e000011 	mcrvc	0, 0, r0, cr0, cr1, {0}
    2318:	01000001 	tsteq	r0, r1
    231c:	91035101 	tstls	r3, r1, lsl #2
    2320:	00007fbc 			@ <UNDEFINED> instruction: 0x00007fbc
    2324:	0011a41c 	andseq	sl, r1, ip, lsl r4
    2328:	00030800 	andeq	r0, r3, r0, lsl #16
    232c:	11e60800 	mvnne	r0, r0, lsl #16
    2330:	017e0000 	cmneq	lr, r0
    2334:	01010000 	mrseq	r0, (UNDEF: 1)
    2338:	bc910351 	ldclt	3, cr0, [r1], {81}	@ 0x51
    233c:	5201017f 	andpl	r0, r1, #-1073741793	@ 0xc000001f
    2340:	00003001 	andeq	r3, r0, r1
    2344:	00007005 	andeq	r7, r0, r5
    2348:	08841d00 	stmeq	r4, {r8, sl, fp, ip}
    234c:	32010000 	andcc	r0, r1, #0
    2350:	0002ec0d 	andeq	lr, r2, sp, lsl #24
    2354:	000fec00 	andeq	lr, pc, r0, lsl #24
    2358:	00014000 	andeq	r4, r1, r0
    235c:	ec9c0100 	ldfs	f0, [ip], {0}
    2360:	06000002 	streq	r0, [r0], -r2
    2364:	00746d66 	rsbseq	r6, r4, r6, ror #26
    2368:	00702732 	rsbseq	r2, r0, r2, lsr r7
    236c:	0a410000 	beq	1042374 <__ROM_SIZE__+0x1002374>
    2370:	0a250000 	beq	942378 <__ROM_SIZE__+0x902378>
    2374:	9c0e0000 	stcls	0, cr0, [lr], {-0}
    2378:	35000008 	strcc	r0, [r0, #-8]
    237c:	000002f3 	strdeq	r0, [r0], -r3
    2380:	00000ac4 	andeq	r0, r0, r4, asr #21
    2384:	00000aae 	andeq	r0, r0, lr, lsr #21
    2388:	0008230e 	andeq	r2, r8, lr, lsl #6
    238c:	00573f00 	subseq	r3, r7, r0, lsl #30
    2390:	0b300000 	bleq	c02398 <__ROM_SIZE__+0xbc2398>
    2394:	0b160000 	bleq	58239c <__ROM_SIZE__+0x54239c>
    2398:	6e1e0000 	cdpvs	0, 1, cr0, cr14, cr0, {0}
    239c:	01006d75 	tsteq	r0, r5, ror sp
    23a0:	02f80833 	rscseq	r0, r8, #3342336	@ 0x330000
    23a4:	91020000 	mrsls	r0, (UNDEF: 2)
    23a8:	081b0264 	ldmdaeq	fp, {r2, r5, r6, r9}
    23ac:	07340000 	ldreq	r0, [r4, -r0]!
    23b0:	00000057 	andeq	r0, r0, r7, asr r0
    23b4:	00000b9b 	muleq	r0, fp, fp
    23b8:	00000b89 	andeq	r0, r0, r9, lsl #23
    23bc:	00004407 	andeq	r4, r0, r7, lsl #8
    23c0:	00023100 	andeq	r3, r2, r0, lsl #2
    23c4:	087e0200 	ldmdaeq	lr!, {r9}^
    23c8:	0b410000 	bleq	10423d0 <__ROM_SIZE__+0x10023d0>
    23cc:	00000057 	andeq	r0, r0, r7, asr r0
    23d0:	00000be8 	andeq	r0, r0, r8, ror #23
    23d4:	00000bde 	ldrdeq	r0, [r0], -lr
    23d8:	00107a0f 	andseq	r7, r0, pc, lsl #20
    23dc:	00021d00 	andeq	r1, r2, r0, lsl #26
    23e0:	50010100 	andpl	r0, r1, r0, lsl #2
    23e4:	002d0802 	eoreq	r0, sp, r2, lsl #16
    23e8:	00109209 	andseq	r9, r0, r9, lsl #4
    23ec:	50010100 	andpl	r0, r1, r0, lsl #2
    23f0:	74009109 	strvc	r9, [r0], #-265	@ 0xfffffef7
    23f4:	1c4c2200 	sfmne	f2, 2, [ip], {-0}
    23f8:	00000194 	muleq	r0, r4, r1
    23fc:	00002307 	andeq	r2, r0, r7, lsl #6
    2400:	0002d800 	andeq	sp, r2, r0, lsl #16
    2404:	087e0200 	ldmdaeq	lr!, {r9}^
    2408:	14710000 	ldrbtne	r0, [r1], #-0
    240c:	000000c4 	andeq	r0, r0, r4, asr #1
    2410:	00000c15 	andeq	r0, r0, r5, lsl ip
    2414:	00000c0b 	andeq	r0, r0, fp, lsl #24
    2418:	0010e21f 	andseq	lr, r0, pc, lsl r2
    241c:	00002800 	andeq	r2, r0, r0, lsl #16
    2420:	0002b400 	andeq	fp, r2, r0, lsl #8
    2424:	08420200 	stmdaeq	r2, {r9}^
    2428:	0f930000 	svceq	0x00930000
    242c:	00000057 	andeq	r0, r0, r7, asr r0
    2430:	00000c3d 	andeq	r0, r0, sp, lsr ip
    2434:	00000c39 	andeq	r0, r0, r9, lsr ip
    2438:	0007ef02 	andeq	lr, r7, r2, lsl #30
    243c:	ec109400 	cfldrs	mvf9, [r0], {-0}
    2440:	54000002 	strpl	r0, [r0], #-2
    2444:	4c00000c 	stcmi	0, cr0, [r0], {12}
    2448:	2000000c 	andcs	r0, r0, ip
    244c:	00000039 	andeq	r0, r0, r9, lsr r0
    2450:	6c617621 	stclvs	6, cr7, [r1], #-132	@ 0xffffff7c
    2454:	11970100 	orrsne	r0, r7, r0, lsl #2
    2458:	00000057 	andeq	r0, r0, r7, asr r0
    245c:	00000c7a 	andeq	r0, r0, sl, ror ip
    2460:	00000c72 	andeq	r0, r0, r2, ror ip
    2464:	0010ec09 	andseq	lr, r0, r9, lsl #24
    2468:	50010100 	andpl	r0, r1, r0, lsl #2
    246c:	7400750f 	strvc	r7, [r0], #-1295	@ 0xfffffaf1
    2470:	1a3f2500 	bne	fcb878 <__ROM_SIZE__+0xf8b878>
    2474:	00282003 	eoreq	r2, r8, r3
    2478:	01942200 	orrseq	r2, r4, r0, lsl #4
    247c:	0f000000 	svceq	0x00000000
    2480:	0000101e 	andeq	r1, r0, lr, lsl r0
    2484:	000002c4 	andeq	r0, r0, r4, asr #5
    2488:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    248c:	09003008 	stmdbeq	r0, {r3, ip, sp}
    2490:	000010dc 	ldrdeq	r1, [r0], -ip
    2494:	09500101 	ldmdbeq	r0, {r0, r8}^
    2498:	00740091 			@ <UNDEFINED> instruction: 0x00740091
    249c:	941c4c22 	ldrls	r4, [ip], #-3106	@ 0xfffff3de
    24a0:	08000001 	stmdaeq	r0, {r0}
    24a4:	0000102c 	andeq	r1, r0, ip, lsr #32
    24a8:	00000308 	andeq	r0, r0, r8, lsl #6
    24ac:	05500101 	ldrbeq	r0, [r0, #-257]	@ 0xfffffeff
    24b0:	00281003 	eoreq	r1, r8, r3
    24b4:	03000000 	movweq	r0, #0
    24b8:	06570201 	ldrbeq	r0, [r7], -r1, lsl #4
    24bc:	4b050000 	blmi	1424c4 <__ROM_SIZE__+0x1024c4>
    24c0:	0b000000 	bleq	24c8 <cmd_end_+0x1ac>
    24c4:	00000069 	andeq	r0, r0, r9, rrx
    24c8:	00000308 	andeq	r0, r0, r8, lsl #6
    24cc:	0000c40c 	andeq	ip, r0, ip, lsl #8
    24d0:	22000900 	andcs	r0, r0, #0, 18
    24d4:	000007e8 	andeq	r0, r0, r8, ror #15
    24d8:	d00d2b01 	andle	r2, sp, r1, lsl #22
    24dc:	1c00000f 	stcne	0, cr0, [r0], {15}
    24e0:	01000000 	mrseq	r0, (UNDEF: 0)
    24e4:	7473069c 	ldrbtvc	r0, [r3], #-1692	@ 0xfffff964
    24e8:	202b0072 	eorcs	r0, fp, r2, ror r0
    24ec:	00000179 	andeq	r0, r0, r9, ror r1
    24f0:	00000ca6 	andeq	r0, r0, r6, lsr #25
    24f4:	00000ca2 	andeq	r0, r0, r2, lsr #25
    24f8:	032b0000 			@ <UNDEFINED> instruction: 0x032b0000
    24fc:	00050000 	andeq	r0, r5, r0
    2500:	0f600401 	svceq	0x00600401
    2504:	0d100000 	ldceq	0, cr0, [r0, #-0]
    2508:	1d000000 	stcne	0, cr0, [r0, #-0]
    250c:	000008b4 			@ <UNDEFINED> instruction: 0x000008b4
    2510:	0000013a 	andeq	r0, r0, sl, lsr r1
    2514:	00001208 	andeq	r1, r0, r8, lsl #4
    2518:	00000238 	andeq	r0, r0, r8, lsr r2
    251c:	00001be1 	andeq	r1, r0, r1, ror #23
    2520:	0007d904 	andeq	sp, r7, r4, lsl #18
    2524:	1b280200 	blne	a02d2c <__ROM_SIZE__+0x9c2d2c>
    2528:	00000032 	andeq	r0, r0, r2, lsr r0
    252c:	00082b11 	andeq	r2, r8, r1, lsl fp
    2530:	00030400 	andeq	r0, r3, r0, lsl #8
    2534:	00000049 	andeq	r0, r0, r9, asr #32
    2538:	0008a112 	andeq	sl, r8, r2, lsl r1
    253c:	00004900 	andeq	r4, r0, r0, lsl #18
    2540:	13000000 	movwne	r0, #0
    2544:	082d0404 	stmdaeq	sp!, {r2, sl}
    2548:	63020000 	movwvs	r0, #8192	@ 0x2000
    254c:	00002618 	andeq	r2, r0, r8, lsl r6
    2550:	05041400 	streq	r1, [r4, #-1024]	@ 0xfffffc00
    2554:	00746e69 	rsbseq	r6, r4, r9, ror #28
    2558:	00006915 	andeq	r6, r0, r5, lsl r9
    255c:	00691600 	rsbeq	r1, r9, r0, lsl #12
    2560:	03000000 	movweq	r0, #0
    2564:	00e00801 	rsceq	r0, r0, r1, lsl #16
    2568:	69170000 	ldmdbvs	r7, {}	@ <UNPREDICTABLE>
    256c:	18000000 	stmdane	r0, {}	@ <UNPREDICTABLE>
    2570:	00000484 	andeq	r0, r0, r4, lsl #9
    2574:	810f1701 	tsthi	pc, r1, lsl #14
    2578:	05000000 	streq	r0, [r0, #-0]
    257c:	0000005e 	andeq	r0, r0, lr, asr r0
    2580:	a1010719 	tstge	r1, r9, lsl r7
    2584:	01000000 	mrseq	r0, (UNDEF: 0)
    2588:	00a10e21 	adceq	r0, r1, r1, lsr #28
    258c:	930a0000 	movwls	r0, #40960	@ 0xa000
    2590:	00000008 	andeq	r0, r0, r8
    2594:	0008040a 	andeq	r0, r8, sl, lsl #8
    2598:	03000100 	movweq	r0, #256	@ 0x100
    259c:	00d70801 	sbcseq	r0, r7, r1, lsl #16
    25a0:	a6040000 	strge	r0, [r4], -r0
    25a4:	01000008 	tsteq	r0, r8
    25a8:	00860324 	addeq	r0, r6, r4, lsr #6
    25ac:	690b0000 	stmdbvs	fp, {}	@ <UNPREDICTABLE>
    25b0:	c4000000 	strgt	r0, [r0], #-0
    25b4:	0c000000 	stceq	0, cr0, [r0], {-0}
    25b8:	000000c4 	andeq	r0, r0, r4, asr #1
    25bc:	0403000f 	streq	r0, [r3], #-15
    25c0:	00010207 	andeq	r0, r1, r7, lsl #4
    25c4:	08f70d00 	ldmeq	r7!, {r8, sl, fp}^
    25c8:	0d260000 	stceq	0, cr0, [r6, #-0]
    25cc:	000000b4 	strheq	r0, [r0], -r4
    25d0:	28400305 	stmdacs	r0, {r0, r2, r8, r9}^
    25d4:	141a0000 	ldrne	r0, [sl], #-0
    25d8:	01000003 	tsteq	r0, r3
    25dc:	005705a7 	subseq	r0, r7, r7, lsr #11
    25e0:	13640000 	cmnne	r4, #0
    25e4:	00dc0000 	sbcseq	r0, ip, r0
    25e8:	9c010000 	stcls	0, cr0, [r1], {-0}
    25ec:	00000179 	andeq	r0, r0, r9, ror r1
    25f0:	746d6606 	strbtvc	r6, [sp], #-1542	@ 0xfffff9fa
    25f4:	7919a700 	ldmdbvc	r9, {r8, r9, sl, sp, pc}
    25f8:	cd000001 	stcgt	0, cr0, [r0, #-4]
    25fc:	bd00000c 	stclt	0, cr0, [r0, #-48]	@ 0xffffffd0
    2600:	1b00000c 	blne	2638 <cmd_end_+0x31c>
    2604:	0008ae02 	andeq	sl, r8, r2, lsl #28
    2608:	a811a800 	ldmdage	r1, {fp, sp, pc}
    260c:	23000000 	movwcs	r0, #0
    2610:	0700000d 	streq	r0, [r0, -sp]
    2614:	0d00000d 	stceq	0, cr0, [r0, #-52]	@ 0xffffffcc
    2618:	0000089c 	muleq	r0, ip, r8
    261c:	004b0ba9 	subeq	r0, fp, r9, lsr #23
    2620:	91020000 	mrsls	r0, (UNDEF: 2)
    2624:	0090075c 	addseq	r0, r0, ip, asr r7
    2628:	01590000 	cmpeq	r9, r0
    262c:	23020000 	movwcs	r0, #8192	@ 0x2000
    2630:	d2000008 	andle	r0, r0, #8
    2634:	00005711 	andeq	r5, r0, r1, lsl r7
    2638:	000d9500 	andeq	r9, sp, r0, lsl #10
    263c:	000d8d00 	andeq	r8, sp, r0, lsl #26
    2640:	14080800 	strne	r0, [r8], #-2048	@ 0xfffff800
    2644:	017e0000 	cmneq	lr, r0
    2648:	01010000 	mrseq	r0, (UNDEF: 1)
    264c:	bc910351 	ldclt	3, cr0, [r1], {81}	@ 0x51
    2650:	1c00007f 	stcne	0, cr0, [r0], {127}	@ 0x7f
    2654:	000013dc 	ldrdeq	r1, [r0], -ip
    2658:	00000308 	andeq	r0, r0, r8, lsl #6
    265c:	00141e08 	andseq	r1, r4, r8, lsl #28
    2660:	00017e00 	andeq	r7, r1, r0, lsl #28
    2664:	51010100 	mrspl	r0, (UNDEF: 17)
    2668:	7fbc9103 	svcvc	0x00bc9103
    266c:	01520101 	cmpeq	r2, r1, lsl #2
    2670:	05000030 	streq	r0, [r0, #-48]	@ 0xffffffd0
    2674:	00000070 	andeq	r0, r0, r0, ror r0
    2678:	0008e71d 	andeq	lr, r8, sp, lsl r7
    267c:	0d300100 	ldfeqs	f0, [r0, #-0]
    2680:	000002ec 	andeq	r0, r0, ip, ror #5
    2684:	00001224 	andeq	r1, r0, r4, lsr #4
    2688:	00000140 	andeq	r0, r0, r0, asr #2
    268c:	02ec9c01 	rsceq	r9, ip, #256	@ 0x100
    2690:	66060000 	strvs	r0, [r6], -r0
    2694:	3000746d 	andcc	r7, r0, sp, ror #8
    2698:	00007028 	andeq	r7, r0, r8, lsr #32
    269c:	000dd100 	andeq	sp, sp, r0, lsl #2
    26a0:	000db500 	andeq	fp, sp, r0, lsl #10
    26a4:	089c0e00 	ldmeq	ip, {r9, sl, fp}
    26a8:	f3360000 	vhadd.u<illegal width 64>	d0, d6, d0
    26ac:	54000002 	strpl	r0, [r0], #-2
    26b0:	3e00000e 	cdpcc	0, 0, cr0, cr0, cr14, {0}
    26b4:	0e00000e 	cdpeq	0, 0, cr0, cr0, cr14, {0}
    26b8:	00000823 	andeq	r0, r0, r3, lsr #16
    26bc:	00005740 	andeq	r5, r0, r0, asr #14
    26c0:	000ec000 	andeq	ip, lr, r0
    26c4:	000ea600 	andeq	sl, lr, r0, lsl #12
    26c8:	756e1e00 	strbvc	r1, [lr, #-3584]!	@ 0xfffff200
    26cc:	3101006d 	tstcc	r1, sp, rrx
    26d0:	0002f808 	andeq	pc, r2, r8, lsl #16
    26d4:	64910200 	ldrvs	r0, [r1], #512	@ 0x200
    26d8:	00081b02 	andeq	r1, r8, r2, lsl #22
    26dc:	57073200 	strpl	r3, [r7, -r0, lsl #4]
    26e0:	2b000000 	blcs	26e8 <cmd_end_+0x3cc>
    26e4:	1900000f 	stmdbne	r0, {r0, r1, r2, r3}
    26e8:	0700000f 	streq	r0, [r0, -pc]
    26ec:	00000086 	andeq	r0, r0, r6, lsl #1
    26f0:	00000231 	andeq	r0, r0, r1, lsr r2
    26f4:	00087e02 	andeq	r7, r8, r2, lsl #28
    26f8:	570b3f00 	strpl	r3, [fp, -r0, lsl #30]
    26fc:	78000000 	stmdavc	r0, {}	@ <UNPREDICTABLE>
    2700:	6e00000f 	cdpvs	0, 0, cr0, cr0, cr15, {0}
    2704:	0f00000f 	svceq	0x0000000f
    2708:	000012b2 			@ <UNDEFINED> instruction: 0x000012b2
    270c:	0000021d 	andeq	r0, r0, sp, lsl r2
    2710:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    2714:	09002d08 	stmdbeq	r0, {r3, r8, sl, fp, sp}
    2718:	000012ca 	andeq	r1, r0, sl, asr #5
    271c:	09500101 	ldmdbeq	r0, {r0, r8}^
    2720:	00740091 			@ <UNDEFINED> instruction: 0x00740091
    2724:	941c4c22 	ldrls	r4, [ip], #-3106	@ 0xfffff3de
    2728:	07000001 	streq	r0, [r0, -r1]
    272c:	00000065 	andeq	r0, r0, r5, rrx
    2730:	000002d8 	ldrdeq	r0, [r0], -r8
    2734:	00087e02 	andeq	r7, r8, r2, lsl #28
    2738:	c4146f00 	ldrgt	r6, [r4], #-3840	@ 0xfffff100
    273c:	a5000000 	strge	r0, [r0, #-0]
    2740:	9b00000f 	blls	2784 <cmd_end_+0x468>
    2744:	1f00000f 	svcne	0x0000000f
    2748:	0000131a 	andeq	r1, r0, sl, lsl r3
    274c:	00000028 	andeq	r0, r0, r8, lsr #32
    2750:	000002b4 			@ <UNDEFINED> instruction: 0x000002b4
    2754:	00084202 	andeq	r4, r8, r2, lsl #4
    2758:	570f9100 	strpl	r9, [pc, -r0, lsl #2]
    275c:	cd000000 	stcgt	0, cr0, [r0, #-0]
    2760:	c900000f 	stmdbgt	r0, {r0, r1, r2, r3}
    2764:	0200000f 	andeq	r0, r0, #15
    2768:	000007ef 	andeq	r0, r0, pc, ror #15
    276c:	02ec1092 	rsceq	r1, ip, #146	@ 0x92
    2770:	0fe40000 	svceq	0x00e40000
    2774:	0fdc0000 	svceq	0x00dc0000
    2778:	7b200000 	blvc	802780 <__ROM_SIZE__+0x7c2780>
    277c:	21000000 	mrscs	r0, (UNDEF: 0)
    2780:	006c6176 	rsbeq	r6, ip, r6, ror r1
    2784:	57119501 	ldrpl	r9, [r1, -r1, lsl #10]
    2788:	0a000000 	beq	2790 <cmd_end_+0x474>
    278c:	02000010 	andeq	r0, r0, #16
    2790:	09000010 	stmdbeq	r0, {r4}
    2794:	00001324 	andeq	r1, r0, r4, lsr #6
    2798:	0f500101 	svceq	0x00500101
    279c:	00740075 	rsbseq	r0, r4, r5, ror r0
    27a0:	031a3f25 	tsteq	sl, #37, 30	@ 0x94
    27a4:	00002840 	andeq	r2, r0, r0, asr #16
    27a8:	00019422 	andeq	r9, r1, r2, lsr #8
    27ac:	560f0000 	strpl	r0, [pc], -r0
    27b0:	c4000012 	strgt	r0, [r0], #-18	@ 0xffffffee
    27b4:	01000002 	tsteq	r0, r2
    27b8:	08025001 	stmdaeq	r2, {r0, ip, lr}
    27bc:	14090030 	strne	r0, [r9], #-48	@ 0xffffffd0
    27c0:	01000013 	tsteq	r0, r3, lsl r0
    27c4:	91095001 	tstls	r9, r1
    27c8:	22007400 	andcs	r7, r0, #0, 8
    27cc:	01941c4c 	orrseq	r1, r4, ip, asr #24
    27d0:	64080000 	strvs	r0, [r8], #-0
    27d4:	08000012 	stmdaeq	r0, {r1, r4}
    27d8:	01000003 	tsteq	r0, r3
    27dc:	03055001 	movweq	r5, #20481	@ 0x5001
    27e0:	00002830 	andeq	r2, r0, r0, lsr r8
    27e4:	01030000 	mrseq	r0, (UNDEF: 3)
    27e8:	00065702 	andeq	r5, r6, r2, lsl #14
    27ec:	004b0500 	subeq	r0, fp, r0, lsl #10
    27f0:	690b0000 	stmdbvs	fp, {}	@ <UNPREDICTABLE>
    27f4:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
    27f8:	0c000003 	stceq	0, cr0, [r0], {3}
    27fc:	000000c4 	andeq	r0, r0, r4, asr #1
    2800:	01220009 			@ <UNDEFINED> instruction: 0x01220009
    2804:	01000009 	tsteq	r0, r9
    2808:	12080d29 	andne	r0, r8, #2624	@ 0xa40
    280c:	001c0000 	andseq	r0, ip, r0
    2810:	9c010000 	stcls	0, cr0, [r1], {-0}
    2814:	72747306 	rsbsvc	r7, r4, #402653184	@ 0x18000000
    2818:	79212900 	stmdbvc	r1!, {r8, fp, sp}
    281c:	36000001 	strcc	r0, [r0], -r1
    2820:	32000010 	andcc	r0, r0, #16
    2824:	00000010 	andeq	r0, r0, r0, lsl r0
    2828:	00056800 	andeq	r6, r5, r0, lsl #16
    282c:	01000500 	tsteq	r0, r0, lsl #10
    2830:	00112f04 	andseq	r2, r1, r4, lsl #30
    2834:	000d1000 	andeq	r1, sp, r0
    2838:	151d0000 	ldrne	r0, [sp, #-0]
    283c:	3a000009 	bcc	2868 <hextable2+0x28>
    2840:	40000001 	andmi	r0, r0, r1
    2844:	60000014 	andvs	r0, r0, r4, lsl r0
    2848:	85000001 	strhi	r0, [r0, #-1]
    284c:	0300001f 	movweq	r0, #31
    2850:	00d90601 	sbcseq	r0, r9, r1, lsl #12
    2854:	02030000 	andeq	r0, r3, #0
    2858:	00012b05 	andeq	r2, r1, r5, lsl #22
    285c:	05040300 	streq	r0, [r4, #-768]	@ 0xfffffd00
    2860:	0000011b 	andeq	r0, r0, fp, lsl r1
    2864:	16050803 	strne	r0, [r5], -r3, lsl #16
    2868:	03000001 	movweq	r0, #1
    286c:	00d70801 	sbcseq	r0, r7, r1, lsl #16
    2870:	02030000 	andeq	r0, r3, #0
    2874:	0000e507 	andeq	lr, r0, r7, lsl #10
    2878:	016d0b00 	cmneq	sp, r0, lsl #22
    287c:	34020000 	strcc	r0, [r2], #-0
    2880:	00005c19 	andeq	r5, r0, r9, lsl ip
    2884:	07040300 	streq	r0, [r4, -r0, lsl #6]
    2888:	000000fd 	strdeq	r0, [r0], -sp
    288c:	f8070803 			@ <UNDEFINED> instruction: 0xf8070803
    2890:	11000000 	mrsne	r0, (UNDEF: 0)
    2894:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
    2898:	04030074 	streq	r0, [r3], #-116	@ 0xffffff8c
    289c:	00010207 	andeq	r0, r1, r7, lsl #4
    28a0:	09450b00 	stmdbeq	r5, {r8, r9, fp}^
    28a4:	56020000 	strpl	r0, [r2], -r0
    28a8:	0000711a 	andeq	r7, r0, sl, lsl r1
    28ac:	04080300 	streq	r0, [r8], #-768	@ 0xfffffd00
    28b0:	00000161 	andeq	r0, r0, r1, ror #2
    28b4:	646d6312 	strbtvs	r6, [sp], #-786	@ 0xfffffcee
    28b8:	0f2d0300 	svceq	0x002d0300
    28bc:	00000097 	muleq	r0, r7, r0
    28c0:	00009c0a 	andeq	r9, r0, sl, lsl #24
    28c4:	006a1300 	rsbeq	r1, sl, r0, lsl #6
    28c8:	00b00000 	adcseq	r0, r0, r0
    28cc:	6a070000 	bvs	1c28d4 <__ROM_SIZE__+0x1828d4>
    28d0:	07000000 	streq	r0, [r0, -r0]
    28d4:	000000b0 	strheq	r0, [r0], -r0	@ <UNPREDICTABLE>
    28d8:	00b50a00 	adcseq	r0, r5, r0, lsl #20
    28dc:	ba0a0000 	blt	2828e4 <__ROM_SIZE__+0x2428e4>
    28e0:	03000000 	movweq	r0, #0
    28e4:	00e00801 	rsceq	r0, r0, r1, lsl #16
    28e8:	ba140000 	blt	5028f0 <__ROM_SIZE__+0x4c28f0>
    28ec:	15000000 	strne	r0, [r0, #-0]
    28f0:	0936030c 	ldmdbeq	r6!, {r2, r3, r8, r9}
    28f4:	000000f4 	strdeq	r0, [r0], -r4
    28f8:	0000bd0c 	andeq	fp, r0, ip, lsl #26
    28fc:	f40f3700 	vst1.8	{d3}, [pc], r0
    2900:	00000000 	andeq	r0, r0, r0
    2904:	0000000c 	andeq	r0, r0, ip
    2908:	f40f3800 	vst2.8	{d3-d4}, [pc], r0
    290c:	04000000 	streq	r0, [r0], #-0
    2910:	0000b50c 	andeq	fp, r0, ip, lsl #10
    2914:	8b073900 	blhi	1d0d1c <__ROM_SIZE__+0x190d1c>
    2918:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
    291c:	00c10a00 	sbceq	r0, r1, r0, lsl #20
    2920:	5b0b0000 	blpl	2c2928 <__ROM_SIZE__+0x282928>
    2924:	03000001 	movweq	r0, #1
    2928:	00c6033a 	sbceq	r0, r6, sl, lsr r3
    292c:	09080000 	stmdbeq	r8, {}	@ <UNPREDICTABLE>
    2930:	7f000009 	svcvc	0x00000009
    2934:	000000f9 	strdeq	r0, [r0], -r9
    2938:	23040305 	movwcs	r0, #17157	@ 0x4305
    293c:	82080000 	andhi	r0, r8, #0
    2940:	80000009 	andhi	r0, r0, r9
    2944:	000000f9 	strdeq	r0, [r0], -r9
    2948:	22f80305 	rscscs	r0, r8, #335544320	@ 0x14000000
    294c:	7a080000 	bvc	202954 <__ROM_SIZE__+0x1c2954>
    2950:	83000009 	movwhi	r0, #9
    2954:	000000f9 	strdeq	r0, [r0], -r9
    2958:	22ec0305 	rsccs	r0, ip, #335544320	@ 0x14000000
    295c:	5c080000 	stcpl	0, cr0, [r8], {-0}
    2960:	84000009 	strhi	r0, [r0], #-9
    2964:	000000f9 	strdeq	r0, [r0], -r9
    2968:	22e00305 	rsccs	r0, r0, #335544320	@ 0x14000000
    296c:	4f080000 	svcmi	0x00080000
    2970:	85000009 	strhi	r0, [r0, #-9]
    2974:	000000f9 	strdeq	r0, [r0], -r9
    2978:	22d40305 	sbcscs	r0, r4, #335544320	@ 0x14000000
    297c:	930d0000 	movwls	r0, #53248	@ 0xd000
    2980:	04000009 	streq	r0, [r0], #-9
    2984:	006a051f 	rsbeq	r0, sl, pc, lsl r5
    2988:	016b0000 	cmneq	fp, r0
    298c:	f4070000 	vst4.8	{d0-d3}, [r7], r0
    2990:	00000000 	andeq	r0, r0, r0
    2994:	00098e0d 	andeq	r8, r9, sp, lsl #28
    2998:	0a260400 	beq	9839a0 <__ROM_SIZE__+0x9439a0>
    299c:	00000050 	andeq	r0, r0, r0, asr r0
    29a0:	00000181 	andeq	r0, r0, r1, lsl #3
    29a4:	0000f407 	andeq	pc, r0, r7, lsl #8
    29a8:	240d0000 	strcs	r0, [sp], #-0
    29ac:	05000001 	streq	r0, [r0, #-1]
    29b0:	006a052c 	rsbeq	r0, sl, ip, lsr #10
    29b4:	01980000 	orrseq	r0, r8, r0
    29b8:	f4070000 	vst4.8	{d0-d3}, [r7], r0
    29bc:	16000000 	strne	r0, [r0], -r0
    29c0:	09860e00 	stmibeq	r6, {r9, sl, fp}
    29c4:	6a670000 	bvs	19c29cc <__ROM_SIZE__+0x19829cc>
    29c8:	50000000 	andpl	r0, r0, r0
    29cc:	50000015 	andpl	r0, r0, r5, lsl r0
    29d0:	01000000 	mrseq	r0, (UNDEF: 0)
    29d4:	0002869c 	muleq	r2, ip, r6
    29d8:	01350400 	teqeq	r5, r0, lsl #8
    29dc:	11670000 	cmnne	r7, r0
    29e0:	0000006a 	andeq	r0, r0, sl, rrx
    29e4:	00001051 	andeq	r1, r0, r1, asr r0
    29e8:	0000104d 	andeq	r1, r0, sp, asr #32
    29ec:	0000b004 	andeq	fp, r0, r4
    29f0:	b01d6700 	andslt	r6, sp, r0, lsl #14
    29f4:	67000000 	strvs	r0, [r0, -r0]
    29f8:	63000010 	movwvs	r0, #16
    29fc:	0f000010 	svceq	0x00000010
    2a00:	00000974 	andeq	r0, r0, r4, ror r9
    2a04:	0015867a 	andseq	r8, r5, sl, ror r6
    2a08:	05eb0100 	strbeq	r0, [fp, #256]!	@ 0x100
    2a0c:	0c6d0000 	stcleq	0, cr0, [sp], #-0
    2a10:	00000050 	andeq	r0, r0, r0, asr r0
    2a14:	0000107c 	andeq	r1, r0, ip, ror r0
    2a18:	00001076 	andeq	r1, r0, r6, ror r0
    2a1c:	00096401 	andeq	r6, r9, r1, lsl #8
    2a20:	500c6e00 	andpl	r6, ip, r0, lsl #28
    2a24:	9a000000 	bls	2a2c <hextable2+0x1ec>
    2a28:	92000010 	andls	r0, r0, #16
    2a2c:	01000010 	tsteq	r0, r0, lsl r0
    2a30:	000005bc 			@ <UNDEFINED> instruction: 0x000005bc
    2a34:	00500c75 	subseq	r0, r0, r5, ror ip
    2a38:	10b90000 	adcsne	r0, r9, r0
    2a3c:	10b70000 	adcsne	r0, r7, r0
    2a40:	6c010000 	stcvs	0, cr0, [r1], {-0}
    2a44:	76000009 	strvc	r0, [r0], -r9
    2a48:	0000500c 	andeq	r5, r0, ip
    2a4c:	0010c500 	andseq	ip, r0, r0, lsl #10
    2a50:	0010c100 	andseq	ip, r0, r0, lsl #2
    2a54:	155e0500 	ldrbne	r0, [lr, #-1280]	@ 0xfffffb00
    2a58:	016b0000 	cmneq	fp, r0
    2a5c:	66050000 	strvs	r0, [r5], -r0
    2a60:	55000015 	strpl	r0, [r0, #-21]	@ 0xffffffeb
    2a64:	09000001 	stmdbeq	r0, {r0}
    2a68:	0000157c 	andeq	r1, r0, ip, ror r5
    2a6c:	00000181 	andeq	r0, r0, r1, lsl #3
    2a70:	0000025b 	andeq	r0, r0, fp, asr r2
    2a74:	05500102 	ldrbeq	r0, [r0, #-258]	@ 0xfffffefe
    2a78:	00298c03 	eoreq	r8, r9, r3, lsl #24
    2a7c:	52010200 	andpl	r0, r1, #0, 4
    2a80:	00007502 	andeq	r7, r0, r2, lsl #10
    2a84:	00158609 	andseq	r8, r5, r9, lsl #12
    2a88:	00018100 	andeq	r8, r1, r0, lsl #2
    2a8c:	00027200 	andeq	r7, r2, r0, lsl #4
    2a90:	50010200 	andpl	r0, r1, r0, lsl #4
    2a94:	28e40305 	stmiacs	r4!, {r0, r2, r8, r9}^
    2a98:	06000000 	streq	r0, [r0], -r0
    2a9c:	0000158e 	andeq	r1, r0, lr, lsl #11
    2aa0:	00000181 	andeq	r0, r0, r1, lsl #3
    2aa4:	05500102 	ldrbeq	r0, [r0, #-258]	@ 0xfffffefe
    2aa8:	0029a403 	eoreq	sl, r9, r3, lsl #8
    2aac:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
    2ab0:	0000090d 	andeq	r0, r0, sp, lsl #18
    2ab4:	00006a48 	andeq	r6, r0, r8, asr #20
    2ab8:	0014e800 	andseq	lr, r4, r0, lsl #16
    2abc:	00006800 	andeq	r6, r0, r0, lsl #16
    2ac0:	779c0100 	ldrvc	r0, [ip, r0, lsl #2]
    2ac4:	04000003 	streq	r0, [r0], #-3
    2ac8:	00000135 	andeq	r0, r0, r5, lsr r1
    2acc:	006a1148 	rsbeq	r1, sl, r8, asr #2
    2ad0:	10dc0000 	sbcsne	r0, ip, r0
    2ad4:	10d80000 	sbcsne	r0, r8, r0
    2ad8:	b0040000 	andlt	r0, r4, r0
    2adc:	48000000 	stmdami	r0, {}	@ <UNPREDICTABLE>
    2ae0:	0000b01d 	andeq	fp, r0, sp, lsl r0
    2ae4:	0010f200 	andseq	pc, r0, r0, lsl #4
    2ae8:	0010ee00 	andseq	lr, r0, r0, lsl #28
    2aec:	09740f00 	ldmdbeq	r4!, {r8, r9, sl, fp}^
    2af0:	36620000 	strbtcc	r0, [r2], -r0
    2af4:	01000015 	tsteq	r0, r5, lsl r0
    2af8:	000005eb 	andeq	r0, r0, fp, ror #11
    2afc:	00500c4e 	subseq	r0, r0, lr, asr #24
    2b00:	11070000 	mrsne	r0, (UNDEF: 7)
    2b04:	11010000 	mrsne	r0, (UNDEF: 1)
    2b08:	64010000 	strvs	r0, [r1], #-0
    2b0c:	4f000009 	svcmi	0x00000009
    2b10:	0000500c 	andeq	r5, r0, ip
    2b14:	00112300 	andseq	r2, r1, r0, lsl #6
    2b18:	00111d00 	andseq	r1, r1, r0, lsl #26
    2b1c:	096c0100 	stmdbeq	ip!, {r8}^
    2b20:	0c500000 	mraeq	r0, r0, acc0
    2b24:	00000050 	andeq	r0, r0, r0, asr r0
    2b28:	0000113f 	andeq	r1, r0, pc, lsr r1
    2b2c:	00001139 	andeq	r1, r0, r9, lsr r1
    2b30:	0005bc01 	andeq	fp, r5, r1, lsl #24
    2b34:	500c5c00 	andpl	r5, ip, r0, lsl #24
    2b38:	59000000 	stmdbpl	r0, {}	@ <UNPREDICTABLE>
    2b3c:	55000011 	strpl	r0, [r0, #-17]	@ 0xffffffef
    2b40:	05000011 	streq	r0, [r0, #-17]	@ 0xffffffef
    2b44:	000014f6 	strdeq	r1, [r0], -r6
    2b48:	0000016b 	andeq	r0, r0, fp, ror #2
    2b4c:	0014fe05 	andseq	pc, r4, r5, lsl #28
    2b50:	00015500 	andeq	r5, r1, r0, lsl #10
    2b54:	15060500 	strne	r0, [r6, #-1280]	@ 0xfffffb00
    2b58:	01550000 	cmpeq	r5, r0
    2b5c:	2e090000 	cdpcs	0, 0, cr0, cr9, cr0, {0}
    2b60:	81000015 	tsthi	r0, r5, lsl r0
    2b64:	4c000001 	stcmi	0, cr0, [r0], {1}
    2b68:	02000003 	andeq	r0, r0, #3
    2b6c:	03055001 	movweq	r5, #20481	@ 0x5001
    2b70:	000028e4 	andeq	r2, r0, r4, ror #17
    2b74:	15360900 	ldrne	r0, [r6, #-2304]!	@ 0xfffff700
    2b78:	01810000 	orreq	r0, r1, r0
    2b7c:	03630000 	cmneq	r3, #0
    2b80:	01020000 	mrseq	r0, (UNDEF: 2)
    2b84:	0c030550 	cfstr32eq	mvfx0, [r3], {80}	@ 0x50
    2b88:	00000029 	andeq	r0, r0, r9, lsr #32
    2b8c:	00153e06 	andseq	r3, r5, r6, lsl #28
    2b90:	00018100 	andeq	r8, r1, r0, lsl #2
    2b94:	50010200 	andpl	r0, r1, r0, lsl #4
    2b98:	29300305 	ldmdbcs	r0!, {r0, r2, r8, r9}
    2b9c:	00000000 	andeq	r0, r0, r0
    2ba0:	0009530e 	andeq	r5, r9, lr, lsl #6
    2ba4:	006a3400 	rsbeq	r3, sl, r0, lsl #8
    2ba8:	14a00000 	strtne	r0, [r0], #0
    2bac:	00480000 	subeq	r0, r8, r0
    2bb0:	9c010000 	stcls	0, cr0, [r1], {-0}
    2bb4:	00000449 	andeq	r0, r0, r9, asr #8
    2bb8:	00013504 	andeq	r3, r1, r4, lsl #10
    2bbc:	6a123400 	bvs	48fbc4 <__ROM_SIZE__+0x44fbc4>
    2bc0:	70000000 	andvc	r0, r0, r0
    2bc4:	68000011 	stmdavs	r0, {r0, r4}
    2bc8:	04000011 	streq	r0, [r0], #-17	@ 0xffffffef
    2bcc:	000000b0 	strheq	r0, [r0], -r0	@ <UNPREDICTABLE>
    2bd0:	00b01e34 	adcseq	r1, r0, r4, lsr lr
    2bd4:	119a0000 	orrsne	r0, sl, r0
    2bd8:	118e0000 	orrne	r0, lr, r0
    2bdc:	eb010000 	bl	42be4 <__ROM_SIZE__+0x2be4>
    2be0:	3a000005 	bcc	2bfc <rsbox+0x38>
    2be4:	0000500c 	andeq	r5, r0, ip
    2be8:	0011c800 	andseq	ip, r1, r0, lsl #16
    2bec:	0011c200 	andseq	ip, r1, r0, lsl #4
    2bf0:	07d20100 	ldrbeq	r0, [r2, r0, lsl #2]
    2bf4:	0c3b0000 	ldceq	0, cr0, [fp], #-0
    2bf8:	00000050 	andeq	r0, r0, r0, asr r0
    2bfc:	000011de 	ldrdeq	r1, [r0], -lr
    2c00:	000011da 	ldrdeq	r1, [r0], -sl
    2c04:	0000a717 	andeq	sl, r0, r7, lsl r7
    2c08:	00042300 	andeq	r2, r4, r0, lsl #6
    2c0c:	00691800 	rsbeq	r1, r9, r0, lsl #16
    2c10:	50113d01 	andspl	r3, r1, r1, lsl #26
    2c14:	ef000000 	svc	0x00000000
    2c18:	eb000011 	bl	2c64 <rsbox+0xa0>
    2c1c:	01000011 	tsteq	r0, r1, lsl r0
    2c20:	000005bc 			@ <UNDEFINED> instruction: 0x000005bc
    2c24:	0050183d 	subseq	r1, r0, sp, lsr r8
    2c28:	12010000 	andne	r0, r1, #0
    2c2c:	11fd0000 	mvnsne	r0, r0
    2c30:	d4060000 	strle	r0, [r6], #-0
    2c34:	81000014 	tsthi	r0, r4, lsl r0
    2c38:	02000001 	andeq	r0, r0, #1
    2c3c:	03055001 	movweq	r5, #20481	@ 0x5001
    2c40:	00002870 	andeq	r2, r0, r0, ror r8
    2c44:	02510102 	subseq	r0, r1, #-2147483648	@ 0x80000000
    2c48:	00000074 	andeq	r0, r0, r4, ror r0
    2c4c:	0014ae05 	andseq	sl, r4, r5, lsl #28
    2c50:	00016b00 	andeq	r6, r1, r0, lsl #22
    2c54:	14b60500 	ldrtne	r0, [r6], #1280	@ 0x500
    2c58:	01550000 	cmpeq	r5, r0
    2c5c:	c4060000 	strgt	r0, [r6], #-0
    2c60:	81000014 	tsthi	r0, r4, lsl r0
    2c64:	02000001 	andeq	r0, r0, #1
    2c68:	03055001 	movweq	r5, #20481	@ 0x5001
    2c6c:	000028ac 	andeq	r2, r0, ip, lsr #17
    2c70:	77190000 	ldrvc	r0, [r9, -r0]
    2c74:	01003233 	tsteq	r0, r3, lsr r2
    2c78:	006a0528 	rsbeq	r0, sl, r8, lsr #10
    2c7c:	14700000 	ldrbtne	r0, [r0], #-0
    2c80:	00300000 	eorseq	r0, r0, r0
    2c84:	9c010000 	stcls	0, cr0, [r1], {-0}
    2c88:	000004d5 	ldrdeq	r0, [r0], -r5
    2c8c:	00013504 	andeq	r3, r1, r4, lsl #10
    2c90:	6a0d2800 	bvs	34cc98 <__ROM_SIZE__+0x30cc98>
    2c94:	17000000 	strne	r0, [r0, -r0]
    2c98:	0f000012 	svceq	0x00000012
    2c9c:	04000012 	streq	r0, [r0], #-18	@ 0xffffffee
    2ca0:	000000b0 	strheq	r0, [r0], -r0	@ <UNPREDICTABLE>
    2ca4:	00b01928 	adcseq	r1, r0, r8, lsr #18
    2ca8:	123a0000 	eorsne	r0, sl, #0
    2cac:	12320000 	eorsne	r0, r2, #0
    2cb0:	eb010000 	bl	42cb8 <__ROM_SIZE__+0x2cb8>
    2cb4:	2d000005 	stccs	0, cr0, [r0, #-20]	@ 0xffffffec
    2cb8:	0000500c 	andeq	r5, r0, ip
    2cbc:	00125300 	andseq	r5, r2, r0, lsl #6
    2cc0:	00124f00 	andseq	r4, r2, r0, lsl #30
    2cc4:	05bc0100 	ldreq	r0, [ip, #256]!	@ 0x100
    2cc8:	0c2e0000 	stceq	0, cr0, [lr], #-0
    2ccc:	00000050 	andeq	r0, r0, r0, asr r0
    2cd0:	00001260 	andeq	r1, r0, r0, ror #4
    2cd4:	0000125e 	andeq	r1, r0, lr, asr r2
    2cd8:	00147e05 	andseq	r7, r4, r5, lsl #28
    2cdc:	00016b00 	andeq	r6, r1, r0, lsl #22
    2ce0:	14860500 	strne	r0, [r6], #1280	@ 0x500
    2ce4:	016b0000 	cmneq	fp, r0
    2ce8:	94060000 	strls	r0, [r6], #-0
    2cec:	81000014 	tsthi	r0, r4, lsl r0
    2cf0:	02000001 	andeq	r0, r0, #1
    2cf4:	03055001 	movweq	r5, #20481	@ 0x5001
    2cf8:	0000287c 	andeq	r2, r0, ip, ror r8
    2cfc:	721a0000 	andsvc	r0, sl, #0
    2d00:	01003233 	tsteq	r0, r3, lsr r2
    2d04:	006a0519 	rsbeq	r0, sl, r9, lsl r5
    2d08:	14400000 	strbne	r0, [r0], #-0
    2d0c:	00300000 	eorseq	r0, r0, r0
    2d10:	9c010000 	stcls	0, cr0, [r1], {-0}
    2d14:	00013504 	andeq	r3, r1, r4, lsl #10
    2d18:	6a0d1900 	bvs	349120 <__ROM_SIZE__+0x309120>
    2d1c:	6e000000 	cdpvs	0, 0, cr0, cr0, cr0, {0}
    2d20:	66000012 			@ <UNDEFINED> instruction: 0x66000012
    2d24:	04000012 	streq	r0, [r0], #-18	@ 0xffffffee
    2d28:	000000b0 	strheq	r0, [r0], -r0	@ <UNPREDICTABLE>
    2d2c:	00b01919 	adcseq	r1, r0, r9, lsl r9
    2d30:	12910000 	addsne	r0, r1, #0
    2d34:	12890000 	addne	r0, r9, #0
    2d38:	eb010000 	bl	42d40 <__ROM_SIZE__+0x2d40>
    2d3c:	1f000005 	svcne	0x00000005
    2d40:	0000500c 	andeq	r5, r0, ip
    2d44:	0012b000 	andseq	fp, r2, r0
    2d48:	0012ac00 	andseq	sl, r2, r0, lsl #24
    2d4c:	05bc0100 	ldreq	r0, [ip, #256]!	@ 0x100
    2d50:	0c200000 	stceq	0, cr0, [r0], #-0
    2d54:	00000050 	andeq	r0, r0, r0, asr r0
    2d58:	000012bd 			@ <UNDEFINED> instruction: 0x000012bd
    2d5c:	000012bb 			@ <UNDEFINED> instruction: 0x000012bb
    2d60:	00144c05 	andseq	r4, r4, r5, lsl #24
    2d64:	00016b00 	andeq	r6, r1, r0, lsl #22
    2d68:	14560900 	ldrbne	r0, [r6], #-2304	@ 0xfffff700
    2d6c:	01810000 	orreq	r0, r1, r0
    2d70:	05570000 	ldrbeq	r0, [r7, #-0]
    2d74:	01020000 	mrseq	r0, (UNDEF: 2)
    2d78:	70030550 	andvc	r0, r3, r0, asr r5
    2d7c:	00000028 	andeq	r0, r0, r8, lsr #32
    2d80:	00146206 	andseq	r6, r4, r6, lsl #4
    2d84:	00018100 	andeq	r8, r1, r0, lsl #2
    2d88:	50010200 	andpl	r0, r1, r0, lsl #4
    2d8c:	28500305 	ldmdacs	r0, {r0, r2, r8, r9}^
    2d90:	00000000 	andeq	r0, r0, r0
    2d94:	000c2f00 	andeq	r2, ip, r0, lsl #30
    2d98:	01000500 	tsteq	r0, r0, lsl #10
    2d9c:	0012c104 	andseq	ip, r2, r4, lsl #2
    2da0:	000d1a00 	andeq	r1, sp, r0, lsl #20
    2da4:	e21d0000 	ands	r0, sp, #0
    2da8:	3a000009 	bcc	2dd4 <base_order+0xb0>
    2dac:	a0000001 	andge	r0, r0, r1
    2db0:	d0000015 	andle	r0, r0, r5, lsl r0
    2db4:	a8000005 	stmdage	r0, {r0, r2}
    2db8:	1b000022 	blne	2e48 <base_order+0x124>
    2dbc:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
    2dc0:	c6130074 			@ <UNDEFINED> instruction: 0xc6130074
    2dc4:	02000003 	andeq	r0, r0, #3
    2dc8:	003917d6 	ldrsbteq	r1, [r9], -r6
    2dcc:	04060000 	streq	r0, [r6], #-0
    2dd0:	00010207 	andeq	r0, r1, r7, lsl #4
    2dd4:	05080600 	streq	r0, [r8, #-1536]	@ 0xfffffa00
    2dd8:	00000116 	andeq	r0, r0, r6, lsl r1
    2ddc:	61040806 	tstvs	r4, r6, lsl #16
    2de0:	06000001 	streq	r0, [r0], -r1
    2de4:	00d90601 	sbcseq	r0, r9, r1, lsl #12
    2de8:	02060000 	andeq	r0, r6, #0
    2dec:	00012b05 	andeq	r2, r1, r5, lsl #22
    2df0:	05040600 	streq	r0, [r4, #-1536]	@ 0xfffffa00
    2df4:	0000011b 	andeq	r0, r0, fp, lsl r1
    2df8:	00039b13 	andeq	r9, r3, r3, lsl fp
    2dfc:	182e0300 	stmdane	lr!, {r8, r9}
    2e00:	00000074 	andeq	r0, r0, r4, ror r0
    2e04:	00006310 	andeq	r6, r0, r0, lsl r3
    2e08:	08010600 	stmdaeq	r1, {r9, sl}
    2e0c:	000000d7 	ldrdeq	r0, [r0], -r7
    2e10:	e5070206 	str	r0, [r7, #-518]	@ 0xfffffdfa
    2e14:	06000000 	streq	r0, [r0], -r0
    2e18:	00fd0704 	rscseq	r0, sp, r4, lsl #14
    2e1c:	08060000 	stmdaeq	r6, {}	@ <UNPREDICTABLE>
    2e20:	0000f807 	andeq	pc, r0, r7, lsl #16
    2e24:	03a31c00 			@ <UNDEFINED> instruction: 0x03a31c00
    2e28:	04c00000 	strbeq	r0, [r0], #0
    2e2c:	00b7082c 	adcseq	r0, r7, ip, lsr #16
    2e30:	531d0000 	tstpl	sp, #0
    2e34:	0400000a 	streq	r0, [r0], #-10
    2e38:	00bc0b2e 	adcseq	r0, ip, lr, lsr #22
    2e3c:	1e000000 	cdpne	0, 0, cr0, cr0, cr0, {0}
    2e40:	04007649 	streq	r7, [r0], #-1609	@ 0xfffff9b7
    2e44:	00cc0b30 	sbceq	r0, ip, r0, lsr fp
    2e48:	00b00000 	adcseq	r0, r0, r0
    2e4c:	00009010 	andeq	r9, r0, r0, lsl r0
    2e50:	00630d00 	rsbeq	r0, r3, r0, lsl #26
    2e54:	00cc0000 	sbceq	r0, ip, r0
    2e58:	390a0000 	stmdbcc	sl, {}	@ <UNPREDICTABLE>
    2e5c:	af000000 	svcge	0x00000000
    2e60:	00630d00 	rsbeq	r0, r3, r0, lsl #26
    2e64:	00dc0000 	sbcseq	r0, ip, r0
    2e68:	390a0000 	stmdbcc	sl, {}	@ <UNPREDICTABLE>
    2e6c:	0f000000 	svceq	0x00000000
    2e70:	0a231300 	beq	8c7a78 <__ROM_SIZE__+0x887a78>
    2e74:	48010000 	stmdami	r1, {}	@ <UNPREDICTABLE>
    2e78:	0000e811 	andeq	lr, r0, r1, lsl r8
    2e7c:	00630d00 	rsbeq	r0, r3, r0, lsl #26
    2e80:	00fe0000 	rscseq	r0, lr, r0
    2e84:	390a0000 	stmdbcc	sl, {}	@ <UNPREDICTABLE>
    2e88:	03000000 	movweq	r0, #0
    2e8c:	0000390a 	andeq	r3, r0, sl, lsl #18
    2e90:	0d000300 	stceq	3, cr0, [r0, #-0]
    2e94:	0000006f 	andeq	r0, r0, pc, rrx
    2e98:	0000010e 	andeq	r0, r0, lr, lsl #2
    2e9c:	0000390a 	andeq	r3, r0, sl, lsl #18
    2ea0:	1000ff00 	andne	pc, r0, r0, lsl #30
    2ea4:	000000fe 	strdeq	r0, [r0], -lr
    2ea8:	0009c611 	andeq	ip, r9, r1, lsl r6
    2eac:	0e164f00 	cdpeq	15, 1, cr4, cr6, cr0, {0}
    2eb0:	05000001 	streq	r0, [r0, #-1]
    2eb4:	002ab803 	eoreq	fp, sl, r3, lsl #16
    2eb8:	09c51100 	stmibeq	r5, {r8, ip}^
    2ebc:	16630000 	strbtne	r0, [r3], -r0
    2ec0:	0000010e 	andeq	r0, r0, lr, lsl #2
    2ec4:	2bc40305 	blcs	ff103ae0 <_STACK_TOP_+0xdf0fbae4>
    2ec8:	6f0d0000 	svcvs	0x000d0000
    2ecc:	45000000 	strmi	r0, [r0, #-0]
    2ed0:	0a000001 	beq	2edc <base_order+0x1b8>
    2ed4:	00000039 	andeq	r0, r0, r9, lsr r0
    2ed8:	3510000a 	ldrcc	r0, [r0, #-10]
    2edc:	11000001 	tstne	r0, r1
    2ee0:	00000a78 	andeq	r0, r0, r8, ror sl
    2ee4:	01451678 	hvceq	20840	@ 0x5168
    2ee8:	03050000 	movweq	r0, #20480	@ 0x5000
    2eec:	00002bb8 			@ <UNDEFINED> instruction: 0x00002bb8
    2ef0:	0005041f 	andeq	r0, r5, pc, lsl r4
    2ef4:	07380500 	ldreq	r0, [r8, -r0, lsl #10]!
    2ef8:	0000017b 	andeq	r0, r0, fp, ror r1
    2efc:	0000017b 	andeq	r0, r0, fp, ror r1
    2f00:	00017b14 	andeq	r7, r1, r4, lsl fp
    2f04:	017d1400 	cmneq	sp, r0, lsl #8
    2f08:	2d140000 	ldccs	0, cr0, [r4, #-0]
    2f0c:	00000000 	andeq	r0, r0, r0
    2f10:	820c0420 	andhi	r0, ip, #32, 8	@ 0x20000000
    2f14:	21000001 	tstcs	r0, r1
    2f18:	000a5c0e 	andeq	r5, sl, lr, lsl #24
    2f1c:	fc021a00 	stc2	10, cr1, [r2], {-0}	@ <UNPREDICTABLE>
    2f20:	7400001a 	strvc	r0, [r0], #-26	@ 0xffffffe6
    2f24:	01000000 	mrseq	r0, (UNDEF: 0)
    2f28:	00023e9c 	muleq	r2, ip, lr
    2f2c:	74630500 	strbtvc	r0, [r3], #-1280	@ 0xfffffb00
    2f30:	021a0078 	andseq	r0, sl, #120	@ 0x78
    2f34:	00023e2c 	andeq	r3, r2, ip, lsr #28
    2f38:	0012d300 	andseq	sp, r2, r0, lsl #6
    2f3c:	0012cf00 	andseq	ip, r2, r0, lsl #30
    2f40:	75620500 	strbvc	r0, [r2, #-1280]!	@ 0xfffffb00
    2f44:	021a0066 	andseq	r0, sl, #102	@ 0x66
    2f48:	0002433a 	andeq	r4, r2, sl, lsr r3
    2f4c:	0012e600 	andseq	lr, r2, r0, lsl #12
    2f50:	0012e200 	andseq	lr, r2, r0, lsl #4
    2f54:	07d20700 	ldrbeq	r0, [r2, r0, lsl #14]
    2f58:	021a0000 	andseq	r0, sl, #0
    2f5c:	00002d46 	andeq	r2, r0, r6, asr #26
    2f60:	0012f900 	andseq	pc, r2, r0, lsl #18
    2f64:	0012f500 	andseq	pc, r2, r0, lsl #10
    2f68:	0a3b1800 	beq	ec8f70 <__ROM_SIZE__+0xe88f70>
    2f6c:	021c0000 	andseq	r0, ip, #0
    2f70:	000000cc 	andeq	r0, r0, ip, asr #1
    2f74:	03589102 	cmpeq	r8, #-2147483648	@ 0x80000000
    2f78:	021e0069 	andseq	r0, lr, #105	@ 0x69
    2f7c:	00002d0a 	andeq	r2, r0, sl, lsl #26
    2f80:	00130c00 	andseq	r0, r3, r0, lsl #24
    2f84:	00130800 	andseq	r0, r3, r0, lsl #16
    2f88:	69620300 	stmdbvs	r2!, {r8, r9}^
    2f8c:	07021f00 	streq	r1, [r2, -r0, lsl #30]
    2f90:	00000026 	andeq	r0, r0, r6, lsr #32
    2f94:	00001326 	andeq	r1, r0, r6, lsr #6
    2f98:	0000131c 	andeq	r1, r0, ip, lsl r3
    2f9c:	001b4802 	andseq	r4, fp, r2, lsl #16
    2fa0:	00015b00 	andeq	r5, r1, r0, lsl #22
    2fa4:	00022700 	andeq	r2, r2, r0, lsl #14
    2fa8:	50010100 	andpl	r0, r1, r0, lsl #2
    2fac:	01007d02 	tsteq	r0, r2, lsl #26
    2fb0:	77035101 	strvc	r5, [r3, -r1, lsl #2]
    2fb4:	010101b0 			@ <UNDEFINED> instruction: 0x010101b0
    2fb8:	00400152 	subeq	r0, r0, r2, asr r1
    2fbc:	001b5004 	andseq	r5, fp, r4
    2fc0:	0005a400 	andeq	sl, r5, r0, lsl #8
    2fc4:	50010100 	andpl	r0, r1, r0, lsl #2
    2fc8:	01007d02 	tsteq	r0, r2, lsl #26
    2fcc:	77025101 	strvc	r5, [r2, -r1, lsl #2]
    2fd0:	0c000000 	stceq	0, cr0, [r0], {-0}
    2fd4:	00000090 	muleq	r0, r0, r0
    2fd8:	0000630c 	andeq	r6, r0, ip, lsl #6
    2fdc:	0a2b0e00 	beq	ac67e4 <__ROM_SIZE__+0xa867e4>
    2fe0:	02040000 	andeq	r0, r4, #0
    2fe4:	00001ab6 			@ <UNDEFINED> instruction: 0x00001ab6
    2fe8:	00000046 	andeq	r0, r0, r6, asr #32
    2fec:	03289c01 			@ <UNDEFINED> instruction: 0x03289c01
    2ff0:	63050000 	movwvs	r0, #20480	@ 0x5000
    2ff4:	04007874 	streq	r7, [r0], #-2164	@ 0xfffff78c
    2ff8:	023e2d02 	eorseq	r2, lr, #2, 26	@ 0x80
    2ffc:	13500000 	cmpne	r0, #0
    3000:	134c0000 	movtne	r0, #49152	@ 0xc000
    3004:	62050000 	andvs	r0, r5, #0
    3008:	04006675 	streq	r6, [r0], #-1653	@ 0xfffff98b
    300c:	02433b02 	subeq	r3, r3, #2048	@ 0x800
    3010:	13630000 	cmnne	r3, #0
    3014:	135f0000 	cmpne	pc, #0
    3018:	d2070000 	andle	r0, r7, #0
    301c:	04000007 	streq	r0, [r0], #-7
    3020:	002d4702 	eoreq	r4, sp, r2, lsl #14
    3024:	13760000 	cmnne	r6, #0
    3028:	13720000 	cmnne	r2, #0
    302c:	69030000 	stmdbvs	r3, {}	@ <UNPREDICTABLE>
    3030:	0a020600 	beq	84838 <__ROM_SIZE__+0x44838>
    3034:	0000002d 	andeq	r0, r0, sp, lsr #32
    3038:	00001389 	andeq	r1, r0, r9, lsl #7
    303c:	00001385 	andeq	r1, r0, r5, lsl #7
    3040:	0009b918 	andeq	fp, r9, r8, lsl r9
    3044:	cc020700 	stcgt	7, cr0, [r2], {-0}
    3048:	02000000 	andeq	r0, r0, #0
    304c:	d0025891 	mulle	r2, r1, r8
    3050:	5b00001a 	blpl	30c0 <base_order+0x39c>
    3054:	d8000001 	stmdale	r0, {r0}
    3058:	01000002 	tsteq	r0, r2
    305c:	7d025001 	stcvc	0, cr5, [r2, #-4]
    3060:	51010100 	mrspl	r0, (UNDEF: 17)
    3064:	01007402 	tsteq	r0, r2, lsl #8
    3068:	40015201 	andmi	r5, r1, r1, lsl #4
    306c:	1ad80200 	bne	ff603874 <_STACK_TOP_+0xdf5fb878>
    3070:	04d70000 	ldrbeq	r0, [r7], #0
    3074:	02f20000 	rscseq	r0, r2, #0
    3078:	01010000 	mrseq	r0, (UNDEF: 1)
    307c:	00740250 	rsbseq	r0, r4, r0, asr r2
    3080:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    3084:	02000077 	andeq	r0, r0, #119	@ 0x77
    3088:	00001ae4 	andeq	r1, r0, r4, ror #21
    308c:	000003e2 	andeq	r0, r0, r2, ror #7
    3090:	0000030c 	andeq	r0, r0, ip, lsl #6
    3094:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    3098:	01010074 	tsteq	r1, r4, ror r0
    309c:	00760251 	rsbseq	r0, r6, r1, asr r2
    30a0:	1aee0400 	bne	ffb840a8 <_STACK_TOP_+0xdfb7c0ac>
    30a4:	015b0000 	cmpeq	fp, r0
    30a8:	01010000 	mrseq	r0, (UNDEF: 1)
    30ac:	00760250 	rsbseq	r0, r6, r0, asr r2
    30b0:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    30b4:	0101007d 	tsteq	r1, sp, ror r0
    30b8:	00400152 	subeq	r0, r0, r2, asr r1
    30bc:	09cb0e00 	stmibeq	fp, {r9, sl, fp}^
    30c0:	01f50000 	mvnseq	r0, r0
    30c4:	00001a7e 	andeq	r1, r0, lr, ror sl
    30c8:	00000038 	andeq	r0, r0, r8, lsr r0
    30cc:	03e29c01 	mvneq	r9, #256	@ 0x100
    30d0:	63050000 	movwvs	r0, #20480	@ 0x5000
    30d4:	f5007874 			@ <UNDEFINED> instruction: 0xf5007874
    30d8:	023e2d01 	eorseq	r2, lr, #1, 26	@ 0x40
    30dc:	139d0000 	orrsne	r0, sp, #0
    30e0:	13990000 	orrsne	r0, r9, #0
    30e4:	62050000 	andvs	r0, r5, #0
    30e8:	f5006675 			@ <UNDEFINED> instruction: 0xf5006675
    30ec:	02433b01 	subeq	r3, r3, #1024	@ 0x400
    30f0:	13b40000 			@ <UNDEFINED> instruction: 0x13b40000
    30f4:	13ac0000 			@ <UNDEFINED> instruction: 0x13ac0000
    30f8:	d2070000 	andle	r0, r7, #0
    30fc:	f5000007 			@ <UNDEFINED> instruction: 0xf5000007
    3100:	002d4701 	eoreq	r4, sp, r1, lsl #14
    3104:	13d70000 	bicsne	r0, r7, #0
    3108:	13d30000 	bicsne	r0, r3, #0
    310c:	69030000 	stmdbvs	r3, {}	@ <UNPREDICTABLE>
    3110:	0a01f700 	beq	80d18 <__ROM_SIZE__+0x40d18>
    3114:	0000002d 	andeq	r0, r0, sp, lsr #32
    3118:	000013ea 	andeq	r1, r0, sl, ror #7
    311c:	000013e6 	andeq	r1, r0, r6, ror #7
    3120:	00764903 	rsbseq	r4, r6, r3, lsl #18
    3124:	430c01f8 	movwmi	r0, #49656	@ 0xc1f8
    3128:	02000002 	andeq	r0, r0, #2
    312c:	fa000014 	blx	3184 <base_order+0x460>
    3130:	02000013 	andeq	r0, r0, #19
    3134:	00001a98 	muleq	r0, r8, sl
    3138:	000003e2 	andeq	r0, r0, r2, ror #7
    313c:	000003b2 			@ <UNDEFINED> instruction: 0x000003b2
    3140:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    3144:	02000074 	andeq	r0, r0, #116	@ 0x74
    3148:	00001aa0 	andeq	r1, r0, r0, lsr #21
    314c:	000005a4 	andeq	r0, r0, r4, lsr #11
    3150:	000003cc 	andeq	r0, r0, ip, asr #7
    3154:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    3158:	01010074 	tsteq	r1, r4, ror r0
    315c:	00760251 	rsbseq	r0, r6, r1, asr r2
    3160:	1ab20400 	bne	fec84168 <_STACK_TOP_+0xdec7c16c>
    3164:	015b0000 	cmpeq	fp, r0
    3168:	01010000 	mrseq	r0, (UNDEF: 1)
    316c:	00780250 	rsbseq	r0, r8, r0, asr r2
    3170:	01520101 	cmpeq	r2, r1, lsl #2
    3174:	08000040 	stmdaeq	r0, {r6}
    3178:	00000ab2 			@ <UNDEFINED> instruction: 0x00000ab2
    317c:	1a1c01ec 	bne	703934 <__ROM_SIZE__+0x6c3934>
    3180:	001a0000 	andseq	r0, sl, r0
    3184:	9c010000 	stcls	0, cr0, [r1], {-0}
    3188:	00000421 	andeq	r0, r0, r1, lsr #8
    318c:	66756219 			@ <UNDEFINED> instruction: 0x66756219
    3190:	02432000 	subeq	r2, r3, #0
    3194:	50010000 	andpl	r0, r1, r0
    3198:	00764919 	rsbseq	r4, r6, r9, lsl r9
    319c:	00042134 	andeq	r2, r4, r4, lsr r1
    31a0:	03510100 	cmpeq	r1, #0, 2
    31a4:	01ee0069 	mvneq	r0, r9, rrx
    31a8:	0000630b 	andeq	r6, r0, fp, lsl #6
    31ac:	00142500 	andseq	r2, r4, r0, lsl #10
    31b0:	00141f00 	andseq	r1, r4, r0, lsl #30
    31b4:	6f0c0000 	svcvs	0x000c0000
    31b8:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
    31bc:	00000354 	andeq	r0, r0, r4, asr r3
    31c0:	1a7001dc 	bne	1c03938 <__ROM_SIZE__+0x1bc3938>
    31c4:	000e0000 	andeq	r0, lr, r0
    31c8:	9c010000 	stcls	0, cr0, [r1], {-0}
    31cc:	0000047c 	andeq	r0, r0, ip, ror r4
    31d0:	78746305 	ldmdavc	r4!, {r0, r2, r8, r9, sp, lr}^
    31d4:	2c01dc00 	stccs	12, cr13, [r1], {-0}
    31d8:	0000047c 	andeq	r0, r0, ip, ror r4
    31dc:	00001442 	andeq	r1, r0, r2, asr #8
    31e0:	0000143c 	andeq	r1, r0, ip, lsr r4
    31e4:	66756205 	ldrbtvs	r6, [r5], -r5, lsl #4
    31e8:	3a01dc00 	bcc	7a1f0 <__ROM_SIZE__+0x3a1f0>
    31ec:	00000243 	andeq	r0, r0, r3, asr #4
    31f0:	00001461 	andeq	r1, r0, r1, ror #8
    31f4:	0000145b 	andeq	r1, r0, fp, asr r4
    31f8:	001a7c04 	andseq	r7, sl, r4, lsl #24
    31fc:	0004d700 	andeq	sp, r4, r0, lsl #14
    3200:	50010100 	andpl	r0, r1, r0, lsl #2
    3204:	5101a303 	tstpl	r1, r3, lsl #6
    3208:	03510101 	cmpeq	r1, #1073741824	@ 0x40000000
    320c:	005001a3 	subseq	r0, r0, r3, lsr #3
    3210:	00b70c00 	adcseq	r0, r7, r0, lsl #24
    3214:	440e0000 	strmi	r0, [lr], #-0
    3218:	d6000003 	strle	r0, [r0], -r3
    321c:	001a6201 	andseq	r6, sl, r1, lsl #4
    3220:	00000e00 	andeq	r0, r0, r0, lsl #28
    3224:	d79c0100 	ldrle	r0, [ip, r0, lsl #2]
    3228:	05000004 	streq	r0, [r0, #-4]
    322c:	00787463 	rsbseq	r7, r8, r3, ror #8
    3230:	7c2c01d6 	stfvcs	f0, [ip], #-856	@ 0xfffffca8
    3234:	80000004 	andhi	r0, r0, r4
    3238:	7a000014 	bvc	3290 <base_order+0x56c>
    323c:	05000014 	streq	r0, [r0, #-20]	@ 0xffffffec
    3240:	00667562 	rsbeq	r7, r6, r2, ror #10
    3244:	433a01d6 	teqmi	sl, #-2147483595	@ 0x80000035
    3248:	9f000002 	svcls	0x00000002
    324c:	99000014 	stmdbls	r0, {r2, r4}
    3250:	04000014 	streq	r0, [r0], #-20	@ 0xffffffec
    3254:	00001a6e 	andeq	r1, r0, lr, ror #20
    3258:	000005a4 	andeq	r0, r0, r4, lsr #11
    325c:	03500101 	cmpeq	r0, #1073741824	@ 0x40000000
    3260:	015101a3 	cmpeq	r1, r3, lsr #3
    3264:	a3035101 	movwge	r5, #12545	@ 0x3101
    3268:	00005001 	andeq	r5, r0, r1
    326c:	000a1308 	andeq	r1, sl, r8, lsl #6
    3270:	e201b700 	and	fp, r1, #0, 14
    3274:	3a000019 	bcc	32e0 <base_order+0x5bc>
    3278:	01000000 	mrseq	r0, (UNDEF: 0)
    327c:	00059f9c 	muleq	r5, ip, pc	@ <UNPREDICTABLE>
    3280:	08ae0700 	stmiaeq	lr!, {r8, r9, sl}
    3284:	01b70000 			@ <UNDEFINED> instruction: 0x01b70000
    3288:	00059f20 	andeq	r9, r5, r0, lsr #30
    328c:	0014be00 	andseq	fp, r4, r0, lsl #28
    3290:	0014b800 	andseq	fp, r4, r0, lsl #16
    3294:	0a530700 	beq	14c4e9c <__ROM_SIZE__+0x1484e9c>
    3298:	01b70000 			@ <UNDEFINED> instruction: 0x01b70000
    329c:	00042136 	andeq	r2, r4, r6, lsr r1
    32a0:	0014da00 	andseq	sp, r4, r0, lsl #20
    32a4:	0014d400 	andseq	sp, r4, r0, lsl #8
    32a8:	0a721200 	beq	1c87ab0 <__ROM_SIZE__+0x1c47ab0>
    32ac:	01b90000 			@ <UNDEFINED> instruction: 0x01b90000
    32b0:	00000063 	andeq	r0, r0, r3, rrx
    32b4:	000014f8 	strdeq	r1, [r0], -r8
    32b8:	000014f0 	strdeq	r1, [r0], -r0
    32bc:	0019f202 	andseq	pc, r9, r2, lsl #4
    32c0:	000a0300 	andeq	r0, sl, r0, lsl #6
    32c4:	00054600 	andeq	r4, r5, r0, lsl #12
    32c8:	50010100 	andpl	r0, r1, r0, lsl #2
    32cc:	01013a01 	tsteq	r1, r1, lsl #20
    32d0:	00750251 	rsbseq	r0, r5, r1, asr r2
    32d4:	02520101 	subseq	r0, r2, #1073741824	@ 0x40000000
    32d8:	02000076 	andeq	r0, r0, #118	@ 0x76
    32dc:	000019fc 	strdeq	r1, [r0], -ip
    32e0:	0000070a 	andeq	r0, r0, sl, lsl #14
    32e4:	0000055a 	andeq	r0, r0, sl, asr r5
    32e8:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    32ec:	02000075 	andeq	r0, r0, #117	@ 0x75
    32f0:	00001a06 	andeq	r1, r0, r6, lsl #20
    32f4:	0000068b 	andeq	r0, r0, fp, lsl #13
    32f8:	0000056e 	andeq	r0, r0, lr, ror #10
    32fc:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    3300:	02000075 	andeq	r0, r0, #117	@ 0x75
    3304:	00001a0c 	andeq	r1, r0, ip, lsl #20
    3308:	000006c2 	andeq	r0, r0, r2, asr #13
    330c:	00000582 	andeq	r0, r0, r2, lsl #11
    3310:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    3314:	04000075 	streq	r0, [r0], #-117	@ 0xffffff8b
    3318:	00001a16 	andeq	r1, r0, r6, lsl sl
    331c:	00000a03 	andeq	r0, r0, r3, lsl #20
    3320:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    3324:	01010074 	tsteq	r1, r4, ror r0
    3328:	00750251 	rsbseq	r0, r5, r1, asr r2
    332c:	02520101 	subseq	r0, r2, #1073741824	@ 0x40000000
    3330:	00000076 	andeq	r0, r0, r6, ror r0
    3334:	0000dc0c 	andeq	sp, r0, ip, lsl #24
    3338:	0a160800 	beq	585340 <__ROM_SIZE__+0x545340>
    333c:	019d0000 	orrseq	r0, sp, r0
    3340:	0000199e 	muleq	r0, lr, r9
    3344:	00000044 	andeq	r0, r0, r4, asr #32
    3348:	068b9c01 	streq	r9, [fp], r1, lsl #24
    334c:	ae070000 	cdpge	0, 0, cr0, cr7, cr0, {0}
    3350:	9d000008 	stcls	0, cr0, [r0, #-32]	@ 0xffffffe0
    3354:	059f1d01 	ldreq	r1, [pc, #3329]	@ 405d <base_order+0x1339>
    3358:	151d0000 	ldrne	r0, [sp, #-0]
    335c:	15170000 	ldrne	r0, [r7, #-0]
    3360:	53070000 	movwpl	r0, #28672	@ 0x7000
    3364:	9d00000a 	stcls	0, cr0, [r0, #-40]	@ 0xffffffd8
    3368:	04213301 	strteq	r3, [r1], #-769	@ 0xfffffcff
    336c:	15390000 	ldrne	r0, [r9, #-0]!
    3370:	15330000 	ldrne	r0, [r3, #-0]!
    3374:	72120000 	andsvc	r0, r2, #0
    3378:	9f00000a 	svcls	0x0000000a
    337c:	00006301 	andeq	r6, r0, r1, lsl #6
    3380:	00155700 	andseq	r5, r5, r0, lsl #14
    3384:	00154f00 	andseq	r4, r5, r0, lsl #30
    3388:	19ae0200 	stmibne	lr!, {r9}
    338c:	0a030000 	beq	c3394 <__ROM_SIZE__+0x83394>
    3390:	06130000 	ldreq	r0, [r3], -r0
    3394:	01010000 	mrseq	r0, (UNDEF: 1)
    3398:	01300150 	teqeq	r0, r0, asr r1
    339c:	75025101 	strvc	r5, [r2, #-257]	@ 0xfffffeff
    33a0:	52010100 	andpl	r0, r1, #0, 2
    33a4:	00007602 	andeq	r7, r0, r2, lsl #12
    33a8:	0019b802 	andseq	fp, r9, r2, lsl #16
    33ac:	00088d00 	andeq	r8, r8, r0, lsl #26
    33b0:	00062700 	andeq	r2, r6, r0, lsl #14
    33b4:	50010100 	andpl	r0, r1, r0, lsl #2
    33b8:	00007502 	andeq	r7, r0, r2, lsl #10
    33bc:	0019c202 	andseq	ip, r9, r2, lsl #4
    33c0:	000a0300 	andeq	r0, sl, r0, lsl #6
    33c4:	00064700 	andeq	r4, r6, r0, lsl #14
    33c8:	50010100 	andpl	r0, r1, r0, lsl #2
    33cc:	01007402 	tsteq	r0, r2, lsl #8
    33d0:	75025101 	strvc	r5, [r2, #-257]	@ 0xfffffeff
    33d4:	52010100 	andpl	r0, r1, #0, 2
    33d8:	00007602 	andeq	r7, r0, r2, lsl #12
    33dc:	0019cc02 	andseq	ip, r9, r2, lsl #24
    33e0:	0009bf00 	andeq	fp, r9, r0, lsl #30
    33e4:	00065b00 	andeq	r5, r6, r0, lsl #22
    33e8:	50010100 	andpl	r0, r1, r0, lsl #2
    33ec:	00007502 	andeq	r7, r0, r2, lsl #10
    33f0:	0019d202 	andseq	sp, r9, r2, lsl #4
    33f4:	00098800 	andeq	r8, r9, r0, lsl #16
    33f8:	00066f00 	andeq	r6, r6, r0, lsl #30
    33fc:	50010100 	andpl	r0, r1, r0, lsl #2
    3400:	00007502 	andeq	r7, r0, r2, lsl #10
    3404:	0019e004 	andseq	lr, r9, r4
    3408:	000a0300 	andeq	r0, sl, r0, lsl #6
    340c:	50010100 	andpl	r0, r1, r0, lsl #2
    3410:	01013a01 	tsteq	r1, r1, lsl #20
    3414:	00750251 	rsbseq	r0, r5, r1, asr r2
    3418:	02520101 	subseq	r0, r2, #1073741824	@ 0x40000000
    341c:	00000076 	andeq	r0, r0, r6, ror r0
    3420:	000a8c08 	andeq	r8, sl, r8, lsl #24
    3424:	6c017f00 	stcvs	15, cr7, [r1], {-0}
    3428:	32000019 	andcc	r0, r0, #25
    342c:	01000000 	mrseq	r0, (UNDEF: 0)
    3430:	0006c29c 	muleq	r6, ip, r2
    3434:	08ae1500 	stmiaeq	lr!, {r8, sl, ip}
    3438:	017f0000 	cmneq	pc, r0
    343c:	00059f23 	andeq	r9, r5, r3, lsr #30
    3440:	12500100 	subsne	r0, r0, #0, 2
    3444:	000009b4 			@ <UNDEFINED> instruction: 0x000009b4
    3448:	00630181 	rsbeq	r0, r3, r1, lsl #3
    344c:	15780000 	ldrbne	r0, [r8, #-0]!
    3450:	15760000 	ldrbne	r0, [r6, #-0]!
    3454:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
    3458:	00000aa6 	andeq	r0, r0, r6, lsr #21
    345c:	19240173 	stmdbne	r4!, {r0, r1, r4, r5, r6, r8}
    3460:	00480000 	subeq	r0, r8, r0
    3464:	9c010000 	stcls	0, cr0, [r1], {-0}
    3468:	0000070a 	andeq	r0, r0, sl, lsl #14
    346c:	0008ae15 	andeq	sl, r8, r5, lsl lr
    3470:	22017300 	andcs	r7, r1, #0, 6
    3474:	0000059f 	muleq	r0, pc, r5	@ <UNPREDICTABLE>
    3478:	69035001 	stmdbvs	r3, {r0, ip, lr}
    347c:	0b017500 	bleq	60884 <__ROM_SIZE__+0x20884>
    3480:	00000063 	andeq	r0, r0, r3, rrx
    3484:	00001588 	andeq	r1, r0, r8, lsl #11
    3488:	00001580 	andeq	r1, r0, r0, lsl #11
    348c:	75006a03 	strvc	r6, [r0, #-2563]	@ 0xfffff5fd
    3490:	00630e01 	rsbeq	r0, r3, r1, lsl #28
    3494:	15ac0000 	strne	r0, [ip, #0]!
    3498:	15a60000 	strne	r0, [r6, #0]!
    349c:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
    34a0:	00000a42 	andeq	r0, r0, r2, asr #20
    34a4:	17ca015e 			@ <UNDEFINED> instruction: 0x17ca015e
    34a8:	015a0000 	cmpeq	sl, r0
    34ac:	9c010000 	stcls	0, cr0, [r1], {-0}
    34b0:	0000088d 	andeq	r0, r0, sp, lsl #17
    34b4:	0008ae07 	andeq	sl, r8, r7, lsl #28
    34b8:	24015e00 	strcs	r5, [r1], #-3584	@ 0xfffff200
    34bc:	0000059f 	muleq	r0, pc, r5	@ <UNPREDICTABLE>
    34c0:	000015c8 	andeq	r1, r0, r8, asr #11
    34c4:	000015c2 	andeq	r1, r0, r2, asr #11
    34c8:	60006903 	andvs	r6, r0, r3, lsl #18
    34cc:	00260701 	eoreq	r0, r6, r1, lsl #14
    34d0:	15e50000 	strbne	r0, [r5, #0]!
    34d4:	15e10000 	strbne	r0, [r1, #0]!
    34d8:	61030000 	mrsvs	r0, (UNDEF: 3)
    34dc:	0b016100 	bleq	5b8e4 <__ROM_SIZE__+0x1b8e4>
    34e0:	00000063 	andeq	r0, r0, r3, rrx
    34e4:	000015f7 	strdeq	r1, [r0], -r7
    34e8:	000015f5 	strdeq	r1, [r0], -r5
    34ec:	61006203 	tstvs	r0, r3, lsl #4
    34f0:	00630e01 	rsbeq	r0, r3, r1, lsl #28
    34f4:	16010000 	strne	r0, [r1], -r0
    34f8:	15ff0000 	ldrbne	r0, [pc, #0]!	@ 3500 <base_order+0x7dc>
    34fc:	63030000 	movwvs	r0, #12288	@ 0x3000
    3500:	11016100 	mrsne	r6, (UNDEF: 17)
    3504:	00000063 	andeq	r0, r0, r3, rrx
    3508:	0000160b 	andeq	r1, r0, fp, lsl #12
    350c:	00001609 	andeq	r1, r0, r9, lsl #12
    3510:	61006403 	tstvs	r0, r3, lsl #8
    3514:	00631401 	rsbeq	r1, r3, r1, lsl #8
    3518:	16150000 	ldrne	r0, [r5], -r0
    351c:	16130000 	ldrne	r0, [r3], -r0
    3520:	f2020000 	vhadd.s8	d0, d2, d0
    3524:	5a000017 	bpl	3588 <base_order+0x864>
    3528:	a1000009 	tstge	r0, r9
    352c:	01000007 	tsteq	r0, r7
    3530:	7b025001 	blvc	9753c <__ROM_SIZE__+0x5753c>
    3534:	f8020000 			@ <UNDEFINED> instruction: 0xf8020000
    3538:	5a000017 	bpl	359c <base_order+0x878>
    353c:	b7000009 	strlt	r0, [r0, -r9]
    3540:	01000007 	tsteq	r0, r7
    3544:	91045001 	tstls	r4, r1
    3548:	0001944c 	andeq	r9, r1, ip, asr #8
    354c:	0017fe02 	andseq	pc, r7, r2, lsl #28
    3550:	00095a00 	andeq	r5, r9, r0, lsl #20
    3554:	0007ce00 	andeq	ip, r7, r0, lsl #28
    3558:	50010100 	andpl	r0, r1, r0, lsl #2
    355c:	7fb49105 	svcvc	0x00b49105
    3560:	02000194 	andeq	r0, r0, #148, 2	@ 0x25
    3564:	00001806 	andeq	r1, r0, r6, lsl #16
    3568:	0000095a 	andeq	r0, r0, sl, asr r9
    356c:	000007e2 	andeq	r0, r0, r2, ror #15
    3570:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    3574:	0200007a 	andeq	r0, r0, #122	@ 0x7a
    3578:	0000180c 	andeq	r1, r0, ip, lsl #16
    357c:	0000095a 	andeq	r0, r0, sl, asr r9
    3580:	000007f9 	strdeq	r0, [r0], -r9
    3584:	05500101 	ldrbeq	r0, [r0, #-257]	@ 0xfffffeff
    3588:	947fb891 	ldrbtls	fp, [pc], #-2193	@ 3590 <base_order+0x86c>
    358c:	12020001 	andne	r0, r2, #1
    3590:	5a000018 	bpl	35f8 <base_order+0x8d4>
    3594:	10000009 	andne	r0, r0, r9
    3598:	01000008 	tsteq	r0, r8
    359c:	91055001 	tstls	r5, r1
    35a0:	01947fbc 			@ <UNDEFINED> instruction: 0x01947fbc
    35a4:	181a0200 	ldmdane	sl, {r9}
    35a8:	095a0000 	ldmdbeq	sl, {}^	@ <UNPREDICTABLE>
    35ac:	08240000 	stmdaeq	r4!, {}	@ <UNPREDICTABLE>
    35b0:	01010000 	mrseq	r0, (UNDEF: 1)
    35b4:	00790250 	rsbseq	r0, r9, r0, asr r2
    35b8:	18200200 	stmdane	r0!, {r9}
    35bc:	095a0000 	ldmdbeq	sl, {}^	@ <UNPREDICTABLE>
    35c0:	083a0000 	ldmdaeq	sl!, {}	@ <UNPREDICTABLE>
    35c4:	01010000 	mrseq	r0, (UNDEF: 1)
    35c8:	54910450 	ldrpl	r0, [r1], #1104	@ 0x450
    35cc:	02000194 	andeq	r0, r0, #148, 2	@ 0x25
    35d0:	00001826 	andeq	r1, r0, r6, lsr #16
    35d4:	0000095a 	andeq	r0, r0, sl, asr r9
    35d8:	00000850 	andeq	r0, r0, r0, asr r8
    35dc:	04500101 	ldrbeq	r0, [r0], #-257	@ 0xfffffeff
    35e0:	01944091 			@ <UNDEFINED> instruction: 0x01944091
    35e4:	182e0200 	stmdane	lr!, {r9}
    35e8:	095a0000 	ldmdbeq	sl, {}^	@ <UNPREDICTABLE>
    35ec:	08640000 	stmdaeq	r4!, {}^	@ <UNPREDICTABLE>
    35f0:	01010000 	mrseq	r0, (UNDEF: 1)
    35f4:	00750250 	rsbseq	r0, r5, r0, asr r2
    35f8:	18340200 	ldmdane	r4!, {r9}
    35fc:	095a0000 	ldmdbeq	sl, {}^	@ <UNPREDICTABLE>
    3600:	087a0000 	ldmdaeq	sl!, {}^	@ <UNPREDICTABLE>
    3604:	01010000 	mrseq	r0, (UNDEF: 1)
    3608:	44910450 	ldrmi	r0, [r1], #1104	@ 0x450
    360c:	04000194 	streq	r0, [r0], #-404	@ 0xfffffe6c
    3610:	0000183a 	andeq	r1, r0, sl, lsr r8
    3614:	0000095a 	andeq	r0, r0, sl, asr r9
    3618:	04500101 	ldrbeq	r0, [r0], #-257	@ 0xfffffeff
    361c:	01944891 			@ <UNDEFINED> instruction: 0x01944891
    3620:	45080000 	strmi	r0, [r8, #-0]
    3624:	2c00000a 	stccs	0, cr0, [r0], {10}
    3628:	00175401 	andseq	r5, r7, r1, lsl #8
    362c:	00007600 	andeq	r7, r0, r0, lsl #12
    3630:	5a9c0100 	bpl	fe703a38 <_STACK_TOP_+0xde6fba3c>
    3634:	07000009 	streq	r0, [r0, -r9]
    3638:	000008ae 	andeq	r0, r0, lr, lsr #17
    363c:	9f21012c 	svcls	0x0021012c
    3640:	21000005 	tstcs	r0, r5
    3644:	1d000016 	stcne	0, cr0, [r0, #-88]	@ 0xffffffa8
    3648:	03000016 	movweq	r0, #22
    364c:	012e0069 			@ <UNDEFINED> instruction: 0x012e0069
    3650:	0000630b 	andeq	r6, r0, fp, lsl #6
    3654:	00163600 	andseq	r3, r6, r0, lsl #12
    3658:	00163000 	andseq	r3, r6, r0
    365c:	6d540300 	ldclvs	3, cr0, [r4, #-0]
    3660:	012f0070 			@ <UNDEFINED> instruction: 0x012f0070
    3664:	0000630b 	andeq	r6, r0, fp, lsl #6
    3668:	00164f00 	andseq	r4, r6, r0, lsl #30
    366c:	00164d00 	andseq	r4, r6, r0, lsl #26
    3670:	6d540300 	ldclvs	3, cr0, [r4, #-0]
    3674:	10012f00 	andne	r2, r1, r0, lsl #30
    3678:	00000063 	andeq	r0, r0, r3, rrx
    367c:	00001675 	andeq	r1, r0, r5, ror r6
    3680:	00001657 	andeq	r1, r0, r7, asr r6
    3684:	2f007403 	svccs	0x00007403
    3688:	00631401 	rsbeq	r1, r3, r1, lsl #8
    368c:	17040000 	strne	r0, [r4, -r0]
    3690:	17020000 	strne	r0, [r2, -r0]
    3694:	7e020000 	cdpvc	0, 0, cr0, cr2, cr0, {0}
    3698:	5a000017 	bpl	36fc <base_order+0x9d8>
    369c:	18000009 	stmdane	r0, {r0, r3}
    36a0:	01000009 	tsteq	r0, r9
    36a4:	7b055001 	blvc	1576b0 <__ROM_SIZE__+0x1176b0>
    36a8:	27007a00 	strcs	r7, [r0, -r0, lsl #20]
    36ac:	17900200 	ldrne	r0, [r0, r0, lsl #4]
    36b0:	095a0000 	ldmdbeq	sl, {}^	@ <UNPREDICTABLE>
    36b4:	092f0000 	stmdbeq	pc!, {}	@ <UNPREDICTABLE>
    36b8:	01010000 	mrseq	r0, (UNDEF: 1)
    36bc:	007b0550 	rsbseq	r0, fp, r0, asr r5
    36c0:	00270078 	eoreq	r0, r7, r8, ror r0
    36c4:	0017a202 	andseq	sl, r7, r2, lsl #4
    36c8:	00095a00 	andeq	r5, r9, r0, lsl #20
    36cc:	00094600 	andeq	r4, r9, r0, lsl #12
    36d0:	50010100 	andpl	r0, r1, r0, lsl #2
    36d4:	77007805 	strvc	r7, [r0, -r5, lsl #16]
    36d8:	04002700 	streq	r2, [r0], #-1792	@ 0xfffff900
    36dc:	000017b4 			@ <UNDEFINED> instruction: 0x000017b4
    36e0:	0000095a 	andeq	r0, r0, sl, asr r9
    36e4:	05500101 	ldrbeq	r0, [r0, #-257]	@ 0xfffffeff
    36e8:	007a0077 	rsbseq	r0, sl, r7, ror r0
    36ec:	22000027 	andcs	r0, r0, #39	@ 0x27
    36f0:	000009a8 	andeq	r0, r0, r8, lsr #19
    36f4:	10012601 	andne	r2, r1, r1, lsl #12
    36f8:	00000063 	andeq	r0, r0, r3, rrx
    36fc:	00001742 	andeq	r1, r0, r2, asr #14
    3700:	00000012 	andeq	r0, r0, r2, lsl r0
    3704:	09889c01 	stmibeq	r8, {r0, sl, fp, ip, pc}
    3708:	78050000 	stmdavc	r5, {}	@ <UNPREDICTABLE>
    370c:	1e012600 	cfmadd32ne	mvax0, mvfx2, mvfx1, mvfx0
    3710:	00000063 	andeq	r0, r0, r3, rrx
    3714:	00001710 	andeq	r1, r0, r0, lsl r7
    3718:	0000170c 	andeq	r1, r0, ip, lsl #14
    371c:	0a8f0800 	beq	fe3c5724 <_STACK_TOP_+0xde3bd728>
    3720:	010a0000 	mrseq	r0, (UNDEF: 10)
    3724:	00001710 	andeq	r1, r0, r0, lsl r7
    3728:	00000032 	andeq	r0, r0, r2, lsr r0
    372c:	09bf9c01 	ldmibeq	pc!, {r0, sl, fp, ip, pc}	@ <UNPREDICTABLE>
    3730:	ae150000 	cdpge	0, 1, cr0, cr5, cr0, {0}
    3734:	0a000008 	beq	375c <base_order+0xa38>
    3738:	059f2001 	ldreq	r2, [pc, #1]	@ 3741 <base_order+0xa1d>
    373c:	50010000 	andpl	r0, r1, r0
    3740:	0009b412 	andeq	fp, r9, r2, lsl r4
    3744:	63010c00 	movwvs	r0, #7168	@ 0x1c00
    3748:	24000000 	strcs	r0, [r0], #-0
    374c:	22000017 	andcs	r0, r0, #23
    3750:	00000017 	andeq	r0, r0, r7, lsl r0
    3754:	000aa916 	andeq	sl, sl, r6, lsl r9
    3758:	16ccfb00 	strbne	pc, [ip], r0, lsl #22	@ <UNPREDICTABLE>
    375c:	00440000 	subeq	r0, r4, r0
    3760:	9c010000 	stcls	0, cr0, [r1], {-0}
    3764:	00000a03 	andeq	r0, r0, r3, lsl #20
    3768:	0008ae0f 	andeq	sl, r8, pc, lsl #28
    376c:	9f1ffb00 	svcls	0x001ffb00
    3770:	01000005 	tsteq	r0, r5
    3774:	00690b50 	rsbeq	r0, r9, r0, asr fp
    3778:	00630bfd 	strdeq	r0, [r3], #-189	@ 0xffffff43	@ <UNPREDICTABLE>
    377c:	17340000 	ldrne	r0, [r4, -r0]!
    3780:	172c0000 	strne	r0, [ip, -r0]!
    3784:	6a0b0000 	bvs	2c378c <__ROM_SIZE__+0x28378c>
    3788:	630efd00 	movwvs	pc, #60672	@ 0xed00	@ <UNPREDICTABLE>
    378c:	58000000 	stmdapl	r0, {}	@ <UNPREDICTABLE>
    3790:	52000017 	andpl	r0, r0, #23
    3794:	00000017 	andeq	r0, r0, r7, lsl r0
    3798:	000a5016 	andeq	r5, sl, r6, lsl r0
    379c:	1694ed00 	ldrne	lr, [r4], r0, lsl #26
    37a0:	00380000 	eorseq	r0, r8, r0
    37a4:	9c010000 	stcls	0, cr0, [r1], {-0}
    37a8:	00000a61 	andeq	r0, r0, r1, ror #20
    37ac:	000a720f 	andeq	r7, sl, pc, lsl #4
    37b0:	6321ed00 			@ <UNDEFINED> instruction: 0x6321ed00
    37b4:	01000000 	mrseq	r0, (UNDEF: 0)
    37b8:	08ae0f50 	stmiaeq	lr!, {r4, r6, r8, r9, sl, fp}
    37bc:	31ed0000 	mvncc	r0, r0
    37c0:	0000059f 	muleq	r0, pc, r5	@ <UNPREDICTABLE>
    37c4:	530f5101 	movwpl	r5, #61697	@ 0xf101
    37c8:	ed00000a 	stc	0, cr0, [r0, #-40]	@ 0xffffffd8
    37cc:	00042147 	andeq	r2, r4, r7, asr #2
    37d0:	0b520100 	bleq	1483bd8 <__ROM_SIZE__+0x1443bd8>
    37d4:	0bef0069 	bleq	ffbc3980 <_STACK_TOP_+0xdfbbb984>
    37d8:	00000063 	andeq	r0, r0, r3, rrx
    37dc:	00001774 	andeq	r1, r0, r4, ror r7
    37e0:	0000176e 	andeq	r1, r0, lr, ror #14
    37e4:	ef006a0b 	svc	0x00006a0b
    37e8:	0000630d 	andeq	r6, r0, sp, lsl #6
    37ec:	00178f00 	andseq	r8, r7, r0, lsl #30
    37f0:	00178b00 	andseq	r8, r7, r0, lsl #22
    37f4:	7d170000 	ldcvc	0, cr0, [r7, #-0]
    37f8:	e500000a 	str	r0, [r0, #-10]
    37fc:	00001a56 	andeq	r1, r0, r6, asr sl
    3800:	0000000c 	andeq	r0, r0, ip
    3804:	0abb9c01 	beq	feeea810 <_STACK_TOP_+0xdeee2814>
    3808:	63090000 	movwvs	r0, #36864	@ 0x9000
    380c:	e5007874 	str	r7, [r0, #-2164]	@ 0xfffff78c
    3810:	00023e25 	andeq	r3, r2, r5, lsr #28
    3814:	0017a400 	andseq	sl, r7, r0, lsl #8
    3818:	00179e00 	andseq	r9, r7, r0, lsl #28
    381c:	76690900 	strbtvc	r0, [r9], -r0, lsl #18
    3820:	2139e500 	teqcs	r9, r0, lsl #10
    3824:	c4000004 	strgt	r0, [r0], #-4
    3828:	c0000017 	andgt	r0, r0, r7, lsl r0
    382c:	04000017 	streq	r0, [r0], #-23	@ 0xffffffe9
    3830:	00001a60 	andeq	r1, r0, r0, ror #20
    3834:	0000015b 	andeq	r0, r0, fp, asr r1
    3838:	06500101 	ldrbeq	r0, [r0], -r1, lsl #2
    383c:	235001a3 	cmpcs	r0, #-1073741784	@ 0xc0000028
    3840:	010101b0 			@ <UNDEFINED> instruction: 0x010101b0
    3844:	01a30351 			@ <UNDEFINED> instruction: 0x01a30351
    3848:	52010151 	andpl	r0, r1, #1073741844	@ 0x40000014
    384c:	00004001 	andeq	r4, r0, r1
    3850:	00099817 	andeq	r9, r9, r7, lsl r8
    3854:	1a3ee000 	bne	fbb85c <__ROM_SIZE__+0xf7b85c>
    3858:	00180000 	andseq	r0, r8, r0
    385c:	9c010000 	stcls	0, cr0, [r1], {-0}
    3860:	00000b3f 	andeq	r0, r0, pc, lsr fp
    3864:	78746309 	ldmdavc	r4!, {r0, r3, r8, r9, sp, lr}^
    3868:	3e26e000 	cdpcc	0, 2, cr14, cr6, cr0, {0}
    386c:	da000002 	ble	387c <base_order+0xb58>
    3870:	d6000017 			@ <UNDEFINED> instruction: 0xd6000017
    3874:	09000017 	stmdbeq	r0, {r0, r1, r2, r4}
    3878:	0079656b 	rsbseq	r6, r9, fp, ror #10
    387c:	04213ae0 	strteq	r3, [r1], #-2784	@ 0xfffff520
    3880:	17ed0000 	strbne	r0, [sp, r0]!
    3884:	17e90000 	strbne	r0, [r9, r0]!
    3888:	69090000 	stmdbvs	r9, {}	@ <UNPREDICTABLE>
    388c:	4ee00076 	mcrmi	0, 7, r0, cr0, cr6, {3}
    3890:	00000421 	andeq	r0, r0, r1, lsr #8
    3894:	00001803 	andeq	r1, r0, r3, lsl #16
    3898:	000017ff 	strdeq	r1, [r0], -pc	@ <UNPREDICTABLE>
    389c:	001a4802 	andseq	r4, sl, r2, lsl #16
    38a0:	000b9200 	andeq	r9, fp, r0, lsl #4
    38a4:	000b2200 	andeq	r2, fp, r0, lsl #4
    38a8:	50010100 	andpl	r0, r1, r0, lsl #2
    38ac:	01007402 	tsteq	r0, r2, lsl #8
    38b0:	a3035101 	movwge	r5, #12545	@ 0x3101
    38b4:	04005101 	streq	r5, [r0], #-257	@ 0xfffffeff
    38b8:	00001a54 	andeq	r1, r0, r4, asr sl
    38bc:	0000015b 	andeq	r0, r0, fp, asr r1
    38c0:	03500101 	cmpeq	r0, #1073741824	@ 0x40000000
    38c4:	0101b074 	tsteq	r1, r4, ror r0
    38c8:	75025101 	strvc	r5, [r2, #-257]	@ 0xfffffeff
    38cc:	52010100 	andpl	r0, r1, #0, 2
    38d0:	00004001 	andeq	r4, r0, r1
    38d4:	0003ab17 	andeq	sl, r3, r7, lsl fp
    38d8:	1a36db00 	bne	dba4e0 <__ROM_SIZE__+0xd7a4e0>
    38dc:	00080000 	andeq	r0, r8, r0
    38e0:	9c010000 	stcls	0, cr0, [r1], {-0}
    38e4:	00000b92 	muleq	r0, r2, fp
    38e8:	78746309 	ldmdavc	r4!, {r0, r3, r8, r9, sp, lr}^
    38ec:	3e23db00 	vmulcc.f64	d13, d3, d0
    38f0:	16000002 	strne	r0, [r0], -r2
    38f4:	12000018 	andne	r0, r0, #24
    38f8:	09000018 	stmdbeq	r0, {r3, r4}
    38fc:	0079656b 	rsbseq	r6, r9, fp, ror #10
    3900:	042137db 	strteq	r3, [r1], #-2011	@ 0xfffff825
    3904:	182c0000 	stmdane	ip!, {}	@ <UNPREDICTABLE>
    3908:	18280000 	stmdane	r8!, {}	@ <UNPREDICTABLE>
    390c:	3c040000 	stccc	0, cr0, [r4], {-0}
    3910:	9200001a 	andls	r0, r0, #26
    3914:	0100000b 	tsteq	r0, fp
    3918:	a3035001 	movwge	r5, #12289	@ 0x3001
    391c:	01015001 	tsteq	r1, r1
    3920:	01a30351 			@ <UNDEFINED> instruction: 0x01a30351
    3924:	16000051 			@ <UNDEFINED> instruction: 0x16000051
    3928:	00000a99 	muleq	r0, r9, sl
    392c:	0015a092 	mulseq	r5, r2, r0
    3930:	0000f400 	andeq	pc, r0, r0, lsl #8
    3934:	269c0100 	ldrcs	r0, [ip], r0, lsl #2
    3938:	0f00000c 	svceq	0x0000000c
    393c:	00000a53 	andeq	r0, r0, r3, asr sl
    3940:	02432392 	subeq	r2, r3, #1207959554	@ 0x48000002
    3944:	50010000 	andpl	r0, r1, r0
    3948:	79654b09 	stmdbvc	r5!, {r0, r3, r8, r9, fp, lr}^
    394c:	213c9200 	teqcs	ip, r0, lsl #4
    3950:	42000004 	andmi	r0, r0, #4
    3954:	3e000018 	mcrcc	0, 0, r0, cr0, cr8, {0}
    3958:	0b000018 	bleq	39c0 <base_order+0xc9c>
    395c:	0c940069 	ldceq	0, cr0, [r4], {105}	@ 0x69
    3960:	00000039 	andeq	r0, r0, r9, lsr r0
    3964:	00001857 	andeq	r1, r0, r7, asr r8
    3968:	00001851 	andeq	r1, r0, r1, asr r8
    396c:	94006a0b 	strls	r6, [r0], #-2571	@ 0xfffff5f5
    3970:	0000390f 	andeq	r3, r0, pc, lsl #18
    3974:	00186d00 	andseq	r6, r8, r0, lsl #26
    3978:	00186900 	andseq	r6, r8, r0, lsl #18
    397c:	006b0b00 	rsbeq	r0, fp, r0, lsl #22
    3980:	00391294 	mlaseq	r9, r4, r2, r1
    3984:	18850000 	stmne	r5, {}	@ <UNPREDICTABLE>
    3988:	187b0000 	ldmdane	fp!, {}^	@ <UNPREDICTABLE>
    398c:	ae110000 	cdpge	0, 1, cr0, cr1, cr0, {0}
    3990:	95000009 	strls	r0, [r0, #-9]
    3994:	000c260b 	andeq	r2, ip, fp, lsl #12
    3998:	74910200 	ldrvc	r0, [r1], #512	@ 0x200
    399c:	00164e23 	andseq	r4, r6, r3, lsr #28
    39a0:	00001000 	andeq	r1, r0, r0
    39a4:	0a1d2400 	beq	74c9ac <__ROM_SIZE__+0x70c9ac>
    39a8:	b3010000 	movwlt	r0, #4096	@ 0x1000
    39ac:	00006f17 	andeq	r6, r0, r7, lsl pc
    39b0:	0018be00 	andseq	fp, r8, r0, lsl #28
    39b4:	0018b800 	andseq	fp, r8, r0, lsl #16
    39b8:	25000000 	strcs	r0, [r0, #-0]
    39bc:	00000063 	andeq	r0, r0, r3, rrx
    39c0:	0000390a 	andeq	r3, r0, sl, lsl #18
    39c4:	00000300 	andeq	r0, r0, r0, lsl #6
    39c8:	00001241 	andeq	r1, r0, r1, asr #4
    39cc:	04010005 	streq	r0, [r1], #-5
    39d0:	00001522 	andeq	r1, r0, r2, lsr #10
    39d4:	00000d19 	andeq	r0, r0, r9, lsl sp
    39d8:	0c6d1d00 	stcleq	13, cr1, [sp], #-0
    39dc:	013a0000 	teqeq	sl, r0
    39e0:	1b700000 	blne	1c039e8 <__ROM_SIZE__+0x1bc39e8>
    39e4:	05800000 	streq	r0, [r0]
    39e8:	2d830000 	stccs	0, cr0, [r3]
    39ec:	01080000 	mrseq	r0, (UNDEF: 8)
    39f0:	0000d906 	andeq	sp, r0, r6, lsl #18
    39f4:	05020800 	streq	r0, [r2, #-2048]	@ 0xfffff800
    39f8:	0000012b 	andeq	r0, r0, fp, lsr #2
    39fc:	1b050408 	blne	144a24 <__ROM_SIZE__+0x104a24>
    3a00:	08000001 	stmdaeq	r0, {r0}
    3a04:	01160508 	tsteq	r6, r8, lsl #10
    3a08:	9b0f0000 	blls	3c3a10 <__ROM_SIZE__+0x383a10>
    3a0c:	02000003 	andeq	r0, r0, #3
    3a10:	0053182e 	subseq	r1, r3, lr, lsr #16
    3a14:	42140000 	andsmi	r0, r4, #0
    3a18:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
    3a1c:	00d70801 	sbcseq	r0, r7, r1, lsl #16
    3a20:	02080000 	andeq	r0, r8, #0
    3a24:	0000e507 	andeq	lr, r0, r7, lsl #10
    3a28:	016d0f00 	cmneq	sp, r0, lsl #30
    3a2c:	34020000 	strcc	r0, [r2], #-0
    3a30:	00007219 	andeq	r7, r0, r9, lsl r2
    3a34:	00611400 	rsbeq	r1, r1, r0, lsl #8
    3a38:	04080000 	streq	r0, [r8], #-0
    3a3c:	0000fd07 	andeq	pc, r0, r7, lsl #26
    3a40:	07080800 	streq	r0, [r8, -r0, lsl #16]
    3a44:	000000f8 	strdeq	r0, [r0], -r8
    3a48:	6905041a 	stmdbvs	r5, {r1, r3, r4, sl}
    3a4c:	0800746e 	stmdaeq	r0, {r1, r2, r3, r5, r6, sl, ip, sp, lr}
    3a50:	01020704 	tsteq	r2, r4, lsl #14
    3a54:	f00f0000 			@ <UNDEFINED> instruction: 0xf00f0000
    3a58:	0100000b 	tsteq	r0, fp
    3a5c:	009f1245 	addseq	r1, pc, r5, asr #4
    3a60:	8e140000 	cdphi	0, 1, cr0, cr4, cr0, {0}
    3a64:	1b000000 	blne	3a6c <base_order+0xd48>
    3a68:	00000061 	andeq	r0, r0, r1, rrx
    3a6c:	000000af 	andeq	r0, r0, pc, lsr #1
    3a70:	0000871c 	andeq	r8, r0, ip, lsl r7
    3a74:	0f000500 	svceq	0x00000500
    3a78:	00000aea 	andeq	r0, r0, sl, ror #21
    3a7c:	8e124601 	cfmsub32hi	mvax0, mvfx4, mvfx2, mvfx1
    3a80:	0c000000 	stceq	0, cr0, [r0], {-0}
    3a84:	00000ad8 	ldrdeq	r0, [r0], -r8
    3a88:	00009a5e 	andeq	r9, r0, lr, asr sl
    3a8c:	c4030500 	strgt	r0, [r3], #-1280	@ 0xfffffb00
    3a90:	0c00002c 	stceq	0, cr0, [r0], {44}	@ 0x2c
    3a94:	00000c50 	andeq	r0, r0, r0, asr ip
    3a98:	00009a5f 	andeq	r9, r0, pc, asr sl
    3a9c:	dc030500 	cfstr32le	mvfx0, [r3], {-0}
    3aa0:	0c00002c 	stceq	0, cr0, [r0], {44}	@ 0x2c
    3aa4:	00000c23 	andeq	r0, r0, r3, lsr #24
    3aa8:	00009a60 	andeq	r9, r0, r0, ror #20
    3aac:	0c030500 	cfstr32eq	mvfx0, [r3], {-0}
    3ab0:	0c00002d 	stceq	0, cr0, [r0], {45}	@ 0x2d
    3ab4:	00000c2a 	andeq	r0, r0, sl, lsr #24
    3ab8:	00009a61 	andeq	r9, r0, r1, ror #20
    3abc:	f4030500 	vst3.8	{d0,d2,d4}, [r3], r0
    3ac0:	0c00002c 	stceq	0, cr0, [r0], {44}	@ 0x2c
    3ac4:	00000b1e 	andeq	r0, r0, lr, lsl fp
    3ac8:	00009a62 	andeq	r9, r0, r2, ror #20
    3acc:	24030500 	strcs	r0, [r3], #-1280	@ 0xfffffb00
    3ad0:	1600002d 	strne	r0, [r0], -sp, lsr #32
    3ad4:	00000cc2 	andeq	r0, r0, r2, asr #25
    3ad8:	008002ea 	addeq	r0, r0, sl, ror #5
    3adc:	20a80000 	adccs	r0, r8, r0
    3ae0:	00480000 	subeq	r0, r8, r0
    3ae4:	9c010000 	stcls	0, cr0, [r1], {-0}
    3ae8:	000001cd 	andeq	r0, r0, sp, asr #3
    3aec:	000baa09 	andeq	sl, fp, r9, lsl #20
    3af0:	2702ea00 	strcs	lr, [r2, -r0, lsl #20]
    3af4:	000001cd 	andeq	r0, r0, sp, asr #3
    3af8:	000018eb 	andeq	r1, r0, fp, ror #17
    3afc:	000018e7 	andeq	r1, r0, r7, ror #17
    3b00:	000b8609 	andeq	r8, fp, r9, lsl #12
    3b04:	4302ea00 	movwmi	lr, #10752	@ 0x2a00
    3b08:	000001cd 	andeq	r0, r0, sp, asr #3
    3b0c:	000018fe 	strdeq	r1, [r0], -lr
    3b10:	000018fa 	strdeq	r1, [r0], -sl
    3b14:	00073e09 	andeq	r3, r7, r9, lsl #28
    3b18:	5802ea00 	stmdapl	r2, {r9, fp, sp, lr, pc}
    3b1c:	000001d2 	ldrdeq	r0, [r0], -r2
    3b20:	00001911 	andeq	r1, r0, r1, lsl r9
    3b24:	0000190d 	andeq	r1, r0, sp, lsl #18
    3b28:	0020ce10 	eoreq	ip, r0, r0, lsl lr
    3b2c:	00002200 	andeq	r2, r0, r0, lsl #4
    3b30:	00019c00 	andeq	r9, r1, r0, lsl #24
    3b34:	00690500 	rsbeq	r0, r9, r0, lsl #10
    3b38:	871202f1 			@ <UNDEFINED> instruction: 0x871202f1
    3b3c:	22000000 	andcs	r0, r0, #0
    3b40:	20000019 	andcs	r0, r0, r9, lsl r0
    3b44:	04000019 	streq	r0, [r0], #-25	@ 0xffffffe7
    3b48:	000020ec 	andeq	r2, r0, ip, ror #1
    3b4c:	00000446 	andeq	r0, r0, r6, asr #8
    3b50:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    3b54:	01010075 	tsteq	r1, r5, ror r0
    3b58:	18750251 	ldmdane	r5!, {r0, r4, r6, r9}^
    3b5c:	02520101 	subseq	r0, r2, #1073741824	@ 0x40000000
    3b60:	00000076 	andeq	r0, r0, r6, ror r0
    3b64:	0020bc02 	eoreq	fp, r0, r2, lsl #24
    3b68:	0009fa00 	andeq	pc, r9, r0, lsl #20
    3b6c:	0001b600 	andeq	fp, r1, r0, lsl #12
    3b70:	50010100 	andpl	r0, r1, r0, lsl #2
    3b74:	01007402 	tsteq	r0, r2, lsl #8
    3b78:	77025101 	strvc	r5, [r2, -r1, lsl #2]
    3b7c:	ca040000 	bgt	103b84 <__ROM_SIZE__+0xc3b84>
    3b80:	d6000020 	strle	r0, [r0], -r0, lsr #32
    3b84:	01000002 	tsteq	r0, r2
    3b88:	74025001 	strvc	r5, [r2], #-1
    3b8c:	51010100 	mrspl	r0, (UNDEF: 17)
    3b90:	00007702 	andeq	r7, r0, r2, lsl #14
    3b94:	004e1100 	subeq	r1, lr, r0, lsl #2
    3b98:	42110000 	andsmi	r0, r1, #0
    3b9c:	16000000 	strne	r0, [r0], -r0
    3ba0:	00000caf 	andeq	r0, r0, pc, lsr #25
    3ba4:	008002cc 	addeq	r0, r0, ip, asr #5
    3ba8:	20540000 	subscs	r0, r4, r0
    3bac:	00540000 	subseq	r0, r4, r0
    3bb0:	9c010000 	stcls	0, cr0, [r1], {-0}
    3bb4:	000002d6 	ldrdeq	r0, [r0], -r6
    3bb8:	000b9f09 	andeq	r9, fp, r9, lsl #30
    3bbc:	2102cc00 	tstcs	r2, r0, lsl #24
    3bc0:	000001d2 	ldrdeq	r0, [r0], -r2
    3bc4:	0000192e 	andeq	r1, r0, lr, lsr #18
    3bc8:	0000192a 	andeq	r1, r0, sl, lsr #18
    3bcc:	000baa09 	andeq	sl, fp, r9, lsl #20
    3bd0:	3602cc00 	strcc	ip, [r2], -r0, lsl #24
    3bd4:	000001d2 	ldrdeq	r0, [r0], -r2
    3bd8:	00001941 	andeq	r1, r0, r1, asr #18
    3bdc:	0000193d 	andeq	r1, r0, sp, lsr r9
    3be0:	00207610 	eoreq	r7, r0, r0, lsl r6
    3be4:	00002400 	andeq	r2, r0, r0, lsl #8
    3be8:	00029900 	andeq	r9, r2, r0, lsl #18
    3bec:	0b631200 	bleq	18c83f4 <__ROM_SIZE__+0x18883f4>
    3bf0:	02d90000 	sbcseq	r0, r9, #0
    3bf4:	00008009 	andeq	r8, r0, r9
    3bf8:	00195200 	andseq	r5, r9, r0, lsl #4
    3bfc:	00195000 	andseq	r5, r9, r0
    3c00:	00690500 	rsbeq	r0, r9, r0, lsl #10
    3c04:	800902da 	ldrdhi	r0, [r9], -sl
    3c08:	5c000000 	stcpl	0, cr0, [r0], {-0}
    3c0c:	5a000019 	bpl	3c78 <base_order+0xf54>
    3c10:	02000019 	andeq	r0, r0, #25
    3c14:	0000207c 	andeq	r2, r0, ip, ror r0
    3c18:	00000ffe 	strdeq	r0, [r0], -lr
    3c1c:	00000262 	andeq	r0, r0, r2, ror #4
    3c20:	05500101 	ldrbeq	r0, [r0, #-257]	@ 0xfffffeff
    3c24:	002d2403 	eoreq	r2, sp, r3, lsl #8
    3c28:	88020000 	stmdahi	r2, {}	@ <UNPREDICTABLE>
    3c2c:	d6000020 	strle	r0, [r0], -r0, lsr #32
    3c30:	7c000011 	stcvc	0, cr0, [r0], {17}
    3c34:	01000002 	tsteq	r0, r2
    3c38:	75025001 	strvc	r5, [r2, #-1]
    3c3c:	51010100 	mrspl	r0, (UNDEF: 17)
    3c40:	00007402 	andeq	r7, r0, r2, lsl #8
    3c44:	00209804 	eoreq	r9, r0, r4, lsl #16
    3c48:	00044600 	andeq	r4, r4, r0, lsl #12
    3c4c:	50010100 	andpl	r0, r1, r0, lsl #2
    3c50:	01007602 	tsteq	r0, r2, lsl #12
    3c54:	77025101 	strvc	r5, [r2, -r1, lsl #2]
    3c58:	52010100 	andpl	r0, r1, #0, 2
    3c5c:	00007502 	andeq	r7, r0, r2, lsl #10
    3c60:	206c0200 	rsbcs	r0, ip, r0, lsl #4
    3c64:	0abc0000 	beq	fef03c6c <_STACK_TOP_+0xdeefbc70>
    3c68:	02c50000 	sbceq	r0, r5, #0
    3c6c:	01010000 	mrseq	r0, (UNDEF: 1)
    3c70:	00760250 	rsbseq	r0, r6, r0, asr r2
    3c74:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    3c78:	01010077 	tsteq	r1, r7, ror r0
    3c7c:	0c030552 	cfstr32eq	mvfx0, [r3], {82}	@ 0x52
    3c80:	0100002d 	tsteq	r0, sp, lsr #32
    3c84:	03055301 	movweq	r5, #21249	@ 0x5301
    3c88:	00002cf4 	strdeq	r2, [r0], -r4
    3c8c:	20720400 	rsbscs	r0, r2, r0, lsl #8
    3c90:	0ffe0000 	svceq	0x00fe0000
    3c94:	01010000 	mrseq	r0, (UNDEF: 1)
    3c98:	00750250 	rsbseq	r0, r5, r0, asr r2
    3c9c:	510d0000 	mrspl	r0, (UNDEF: 13)
    3ca0:	a800000b 	stmdage	r0, {r0, r1, r3}
    3ca4:	00008002 	andeq	r8, r0, r2
    3ca8:	001fec00 	andseq	lr, pc, r0, lsl #24
    3cac:	00006800 	andeq	r6, r0, r0, lsl #16
    3cb0:	419c0100 	orrsmi	r0, ip, r0, lsl #2
    3cb4:	03000004 	movweq	r0, #4
    3cb8:	02a80078 	adceq	r0, r8, #120	@ 0x78
    3cbc:	0004412e 	andeq	r4, r4, lr, lsr #2
    3cc0:	00196800 	andseq	r6, r9, r0, lsl #16
    3cc4:	00196400 	andseq	r6, r9, r0, lsl #8
    3cc8:	00790300 	rsbseq	r0, r9, r0, lsl #6
    3ccc:	414102a8 	smlaltbmi	r0, r1, r8, r2
    3cd0:	7b000004 	blvc	3ce8 <base_order+0xfc4>
    3cd4:	77000019 	smladvc	r0, r9, r0, r0
    3cd8:	06000019 			@ <UNDEFINED> instruction: 0x06000019
    3cdc:	02aa0061 	adceq	r0, sl, #97	@ 0x61
    3ce0:	0000af0d 	andeq	sl, r0, sp, lsl #30
    3ce4:	58910200 	ldmpl	r1, {r9}
    3ce8:	aa006206 	bge	1c508 <__RAM_SIZE__+0x14508>
    3cec:	00af1002 	adceq	r1, pc, r2
    3cf0:	91020000 	mrsls	r0, (UNDEF: 2)
    3cf4:	1ff80240 	svcne	0x00f80240
    3cf8:	09fa0000 	ldmibeq	sl!, {}^	@ <UNPREDICTABLE>
    3cfc:	03470000 	movteq	r0, #28672	@ 0x7000
    3d00:	01010000 	mrseq	r0, (UNDEF: 1)
    3d04:	00740250 	rsbseq	r0, r4, r0, asr r2
    3d08:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    3d0c:	02000075 	andeq	r0, r0, #117	@ 0x75
    3d10:	0000200a 	andeq	r2, r0, sl
    3d14:	00000d26 	andeq	r0, r0, r6, lsr #26
    3d18:	00000367 	andeq	r0, r0, r7, ror #6
    3d1c:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    3d20:	01015891 			@ <UNDEFINED> instruction: 0x01015891
    3d24:	00740251 	rsbseq	r0, r4, r1, asr r2
    3d28:	02520101 	subseq	r0, r2, #1073741824	@ 0x40000000
    3d2c:	02000074 	andeq	r0, r0, #116	@ 0x74
    3d30:	00002014 	andeq	r2, r0, r4, lsl r0
    3d34:	00000d26 	andeq	r0, r0, r6, lsr #26
    3d38:	00000387 	andeq	r0, r0, r7, lsl #7
    3d3c:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    3d40:	0101007d 	tsteq	r1, sp, ror r0
    3d44:	58910251 	ldmpl	r1, {r0, r4, r6, r9}
    3d48:	02520101 	subseq	r0, r2, #1073741824	@ 0x40000000
    3d4c:	02000074 	andeq	r0, r0, #116	@ 0x74
    3d50:	0000201e 	andeq	r2, r0, lr, lsl r0
    3d54:	00000ea8 	andeq	r0, r0, r8, lsr #29
    3d58:	000003a7 	andeq	r0, r0, r7, lsr #7
    3d5c:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    3d60:	01015891 			@ <UNDEFINED> instruction: 0x01015891
    3d64:	58910251 	ldmpl	r1, {r0, r4, r6, r9}
    3d68:	02520101 	subseq	r0, r2, #1073741824	@ 0x40000000
    3d6c:	0200007d 	andeq	r0, r0, #125	@ 0x7d
    3d70:	00002028 	andeq	r2, r0, r8, lsr #32
    3d74:	00000ea8 	andeq	r0, r0, r8, lsr #29
    3d78:	000003ca 	andeq	r0, r0, sl, asr #7
    3d7c:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    3d80:	01015891 			@ <UNDEFINED> instruction: 0x01015891
    3d84:	58910251 	ldmpl	r1, {r0, r4, r6, r9}
    3d88:	05520101 	ldrbeq	r0, [r2, #-257]	@ 0xfffffeff
    3d8c:	002cdc03 	eoreq	sp, ip, r3, lsl #24
    3d90:	32020000 	andcc	r0, r2, #0
    3d94:	26000020 	strcs	r0, [r0], -r0, lsr #32
    3d98:	ea00000d 	b	3dd4 <base_order+0x10b0>
    3d9c:	01000003 	tsteq	r0, r3
    3da0:	7d025001 	stcvc	0, cr5, [r2, #-4]
    3da4:	51010100 	mrspl	r0, (UNDEF: 17)
    3da8:	01007502 	tsteq	r0, r2, lsl #10
    3dac:	75025201 	strvc	r5, [r2, #-513]	@ 0xfffffdff
    3db0:	3c020000 	stccc	0, cr0, [r2], {-0}
    3db4:	a8000020 	stmdage	r0, {r5}
    3db8:	0a00000e 	beq	3df8 <base_order+0x10d4>
    3dbc:	01000004 	tsteq	r0, r4
    3dc0:	91025001 	tstls	r2, r1
    3dc4:	51010158 	tstpl	r1, r8, asr r1
    3dc8:	01589102 	cmpeq	r8, r2, lsl #2
    3dcc:	7d025201 	sfmvc	f5, 4, [r2, #-4]
    3dd0:	46020000 	strmi	r0, [r2], -r0
    3dd4:	26000020 	strcs	r0, [r0], -r0, lsr #32
    3dd8:	2a00000d 	bcs	3e14 <base_order+0x10f0>
    3ddc:	01000004 	tsteq	r0, r4
    3de0:	7d025001 	stcvc	0, cr5, [r2, #-4]
    3de4:	51010100 	mrspl	r0, (UNDEF: 17)
    3de8:	01007402 	tsteq	r0, r2, lsl #8
    3dec:	75025201 	strvc	r5, [r2, #-513]	@ 0xfffffdff
    3df0:	4e040000 	cdpmi	0, 0, cr0, cr4, cr0, {0}
    3df4:	c4000020 	strgt	r0, [r0], #-32	@ 0xffffffe0
    3df8:	01000010 	tsteq	r0, r0, lsl r0
    3dfc:	91025001 	tstls	r2, r1
    3e00:	51010158 	tstpl	r1, r8, asr r1
    3e04:	00007d02 	andeq	r7, r0, r2, lsl #26
    3e08:	006d1100 	rsbeq	r1, sp, r0, lsl #2
    3e0c:	58070000 	stmdapl	r7, {}	@ <UNPREDICTABLE>
    3e10:	7400000c 	strvc	r0, [r0], #-12
    3e14:	001f9602 	andseq	r9, pc, r2, lsl #12
    3e18:	00005600 	andeq	r5, r0, r0, lsl #12
    3e1c:	7f9c0100 	svcvc	0x009c0100
    3e20:	03000005 	movweq	r0, #5
    3e24:	02740078 	rsbseq	r0, r4, #120	@ 0x78
    3e28:	00057f24 	andeq	r7, r5, r4, lsr #30
    3e2c:	00198e00 	andseq	r8, r9, r0, lsl #28
    3e30:	00198a00 	andseq	r8, r9, r0, lsl #20
    3e34:	00790300 	rsbseq	r0, r9, r0, lsl #6
    3e38:	7f310274 	svcvc	0x00310274
    3e3c:	a1000005 	tstge	r0, r5
    3e40:	9d000019 	stcls	0, cr0, [r0, #-100]	@ 0xffffff9c
    3e44:	03000019 	movweq	r0, #25
    3e48:	00707865 	rsbseq	r7, r0, r5, ror #16
    3e4c:	41430274 	hvcmi	12324	@ 0x3024
    3e50:	b4000004 	strlt	r0, [r0], #-4
    3e54:	b0000019 	andlt	r0, r0, r9, lsl r0
    3e58:	17000019 	smladne	r0, r9, r0, r0
    3e5c:	00000abc 			@ <UNDEFINED> instruction: 0x00000abc
    3e60:	0000af0d 	andeq	sl, r0, sp, lsl #30
    3e64:	50910200 	addspl	r0, r1, r0, lsl #4
    3e68:	000ac117 	andeq	ip, sl, r7, lsl r1
    3e6c:	00af1300 	adceq	r1, pc, r0, lsl #6
    3e70:	91030000 	mrsls	r0, (UNDEF: 3)
    3e74:	69057fb8 	stmdbvs	r5, {r3, r4, r5, r7, r8, r9, sl, fp, ip, sp, lr}
    3e78:	07027700 	streq	r7, [r2, -r0, lsl #14]
    3e7c:	00000080 	andeq	r0, r0, r0, lsl #1
    3e80:	000019c5 	andeq	r1, r0, r5, asr #19
    3e84:	000019c3 	andeq	r1, r0, r3, asr #19
    3e88:	000b6312 	andeq	r6, fp, r2, lsl r3
    3e8c:	07027800 	streq	r7, [r2, -r0, lsl #16]
    3e90:	00000080 	andeq	r0, r0, r0, lsl #1
    3e94:	000019d3 	ldrdeq	r1, [r0], -r3
    3e98:	000019cd 	andeq	r1, r0, sp, asr #19
    3e9c:	001fa602 	andseq	sl, pc, r2, lsl #12
    3ea0:	000ffe00 	andeq	pc, pc, r0, lsl #28
    3ea4:	0004e800 	andeq	lr, r4, r0, lsl #16
    3ea8:	50010100 	andpl	r0, r1, r0, lsl #2
    3eac:	00007502 	andeq	r7, r0, r2, lsl #10
    3eb0:	001fb002 	andseq	fp, pc, r2
    3eb4:	000a5d00 	andeq	r5, sl, r0, lsl #26
    3eb8:	00050200 	andeq	r0, r5, r0, lsl #4
    3ebc:	50010100 	andpl	r0, r1, r0, lsl #2
    3ec0:	01509102 	cmpeq	r0, r2, lsl #2
    3ec4:	7d025101 	stfvcs	f5, [r2, #-4]
    3ec8:	c2020000 	andgt	r0, r2, #0
    3ecc:	7700001f 	smladvc	r0, pc, r0, r0	@ <UNPREDICTABLE>
    3ed0:	1c000008 	stcne	0, cr0, [r0], {8}
    3ed4:	01000005 	tsteq	r0, r5
    3ed8:	91025001 	tstls	r2, r1
    3edc:	51010150 	tstpl	r1, r0, asr r1
    3ee0:	00007d02 	andeq	r7, r0, r2, lsl #26
    3ee4:	001fca02 	andseq	ip, pc, r2, lsl #20
    3ee8:	00120900 	andseq	r0, r2, r0, lsl #18
    3eec:	00053600 	andeq	r3, r5, r0, lsl #12
    3ef0:	50010100 	andpl	r0, r1, r0, lsl #2
    3ef4:	01007502 	tsteq	r0, r2, lsl #10
    3ef8:	74025101 	strvc	r5, [r2], #-257	@ 0xfffffeff
    3efc:	da020000 	ble	83f04 <__ROM_SIZE__+0x43f04>
    3f00:	8400001f 	strhi	r0, [r0], #-31	@ 0xffffffe1
    3f04:	5c000005 	stcpl	0, cr0, [r0], {5}
    3f08:	01000005 	tsteq	r0, r5
    3f0c:	91025001 	tstls	r2, r1
    3f10:	51010150 	tstpl	r1, r0, asr r1
    3f14:	01007d02 	tsteq	r0, r2, lsl #26
    3f18:	76025201 	strvc	r5, [r2], -r1, lsl #4
    3f1c:	53010100 	movwpl	r0, #4352	@ 0x1100
    3f20:	00007702 	andeq	r7, r0, r2, lsl #14
    3f24:	001fe804 	andseq	lr, pc, r4, lsl #16
    3f28:	000abc00 	andeq	fp, sl, r0, lsl #24
    3f2c:	50010100 	andpl	r0, r1, r0, lsl #2
    3f30:	01007602 	tsteq	r0, r2, lsl #12
    3f34:	77025101 	strvc	r5, [r2, -r1, lsl #2]
    3f38:	52010100 	andpl	r0, r1, #0, 2
    3f3c:	01509102 	cmpeq	r0, r2, lsl #2
    3f40:	7d025301 	stcvc	3, cr5, [r2, #-4]
    3f44:	11000000 	mrsne	r0, (UNDEF: 0)
    3f48:	00000061 	andeq	r0, r0, r1, rrx
    3f4c:	000c1607 	andeq	r1, ip, r7, lsl #12
    3f50:	c2024200 	andgt	r4, r2, #0, 4
    3f54:	d400001e 	strle	r0, [r0], #-30	@ 0xffffffe2
    3f58:	01000000 	mrseq	r0, (UNDEF: 0)
    3f5c:	0008779c 	muleq	r8, ip, r7
    3f60:	31780300 	cmncc	r8, r0, lsl #6
    3f64:	24024200 	strcs	r4, [r2], #-512	@ 0xfffffe00
    3f68:	0000057f 	andeq	r0, r0, pc, ror r5
    3f6c:	000019ef 	andeq	r1, r0, pc, ror #19
    3f70:	000019eb 	andeq	r1, r0, fp, ror #19
    3f74:	00317903 	eorseq	r7, r1, r3, lsl #18
    3f78:	7f320242 	svcvc	0x00320242
    3f7c:	02000005 	andeq	r0, r0, #5
    3f80:	fe00001a 	mcr2	0, 0, r0, cr0, cr10, {0}
    3f84:	03000019 	movweq	r0, #25
    3f88:	42003278 	andmi	r3, r0, #120, 4	@ 0x80000007
    3f8c:	04414602 	strbeq	r4, [r1], #-1538	@ 0xfffff9fe
    3f90:	1a150000 	bne	543f98 <__ROM_SIZE__+0x503f98>
    3f94:	1a110000 	bne	443f9c <__ROM_SIZE__+0x403f9c>
    3f98:	79030000 	stmdbvc	r3, {}	@ <UNPREDICTABLE>
    3f9c:	02420032 	subeq	r0, r2, #50	@ 0x32
    3fa0:	0004415a 	andeq	r4, r4, sl, asr r1
    3fa4:	001a2800 	andseq	r2, sl, r0, lsl #16
    3fa8:	001a2400 	andseq	r2, sl, r0, lsl #8
    3fac:	1f1a1000 	svcne	0x001a1000
    3fb0:	007a0000 	rsbseq	r0, sl, r0
    3fb4:	07b80000 	ldreq	r0, [r8, r0]!
    3fb8:	61060000 	mrsvs	r0, (UNDEF: 6)
    3fbc:	13025a00 	movwne	r5, #10752	@ 0x2a00
    3fc0:	000000af 	andeq	r0, r0, pc, lsr #1
    3fc4:	7f889103 	svcvc	0x00889103
    3fc8:	5a006206 	bpl	1c7e8 <__RAM_SIZE__+0x147e8>
    3fcc:	00af1602 	adceq	r1, pc, r2, lsl #12
    3fd0:	91030000 	mrsls	r0, (UNDEF: 3)
    3fd4:	63067fa0 	movwvs	r7, #28576	@ 0x6fa0
    3fd8:	19025a00 	stmdbne	r2, {r9, fp, ip, lr}
    3fdc:	000000af 	andeq	r0, r0, pc, lsr #1
    3fe0:	7fb89103 	svcvc	0x00b89103
    3fe4:	5a006406 	bpl	1d004 <__RAM_SIZE__+0x15004>
    3fe8:	00af1c02 	adceq	r1, pc, r2, lsl #24
    3fec:	91020000 	mrsls	r0, (UNDEF: 2)
    3ff0:	1f240250 	svcne	0x00240250
    3ff4:	0ea80000 	cdpeq	0, 10, cr0, cr8, cr0, {0}
    3ff8:	06490000 	strbeq	r0, [r9], -r0
    3ffc:	01010000 	mrseq	r0, (UNDEF: 1)
    4000:	007d0250 	rsbseq	r0, sp, r0, asr r2
    4004:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    4008:	01010077 	tsteq	r1, r7, ror r0
    400c:	00760252 	rsbseq	r0, r6, r2, asr r2
    4010:	1f2e0200 	svcne	0x002e0200
    4014:	0ea80000 	cdpeq	0, 10, cr0, cr8, cr0, {0}
    4018:	066a0000 	strbteq	r0, [sl], -r0
    401c:	01010000 	mrseq	r0, (UNDEF: 1)
    4020:	a0910350 	addsge	r0, r1, r0, asr r3
    4024:	5101017f 	tstpl	r1, pc, ror r1
    4028:	01007402 	tsteq	r0, r2, lsl #8
    402c:	75025201 	strvc	r5, [r2, #-513]	@ 0xfffffdff
    4030:	36020000 	strcc	r0, [r2], -r0
    4034:	5000001f 	andpl	r0, r0, pc, lsl r0
    4038:	8600000b 	strhi	r0, [r0], -fp
    403c:	01000006 	tsteq	r0, r6
    4040:	91035001 	tstls	r3, r1
    4044:	01017fb8 			@ <UNDEFINED> instruction: 0x01017fb8
    4048:	a0910351 	addsge	r0, r1, r1, asr r3
    404c:	4002007f 	andmi	r0, r2, pc, ror r0
    4050:	2600001f 			@ <UNDEFINED> instruction: 0x2600001f
    4054:	a800000d 	stmdage	r0, {r0, r2, r3}
    4058:	01000006 	tsteq	r0, r6
    405c:	91035001 	tstls	r3, r1
    4060:	01017fb8 			@ <UNDEFINED> instruction: 0x01017fb8
    4064:	b8910351 	ldmlt	r1, {r0, r4, r6, r8, r9}
    4068:	5201017f 	andpl	r0, r1, #-1073741793	@ 0xc000001f
    406c:	00007d02 	andeq	r7, r0, r2, lsl #26
    4070:	001f4a02 	andseq	r4, pc, r2, lsl #20
    4074:	000d2600 	andeq	r2, sp, r0, lsl #12
    4078:	0006ca00 	andeq	ip, r6, r0, lsl #20
    407c:	50010100 	andpl	r0, r1, r0, lsl #2
    4080:	01509102 	cmpeq	r0, r2, lsl #2
    4084:	91035101 	tstls	r3, r1, lsl #2
    4088:	01017fb8 			@ <UNDEFINED> instruction: 0x01017fb8
    408c:	b8910352 	ldmlt	r1, {r1, r4, r6, r8, r9}
    4090:	5402007f 	strpl	r0, [r2], #-127	@ 0xffffff81
    4094:	a800001f 	stmdage	r0, {r0, r1, r2, r3, r4}
    4098:	eb00000e 	bl	40d8 <base_order+0x13b4>
    409c:	01000006 	tsteq	r0, r6
    40a0:	91025001 	tstls	r2, r1
    40a4:	51010150 	tstpl	r1, r0, asr r1
    40a8:	01509102 	cmpeq	r0, r2, lsl #2
    40ac:	91035201 	tstls	r3, r1, lsl #4
    40b0:	02007fb8 	andeq	r7, r0, #184, 30	@ 0x2e0
    40b4:	00001f5e 	andeq	r1, r0, lr, asr pc
    40b8:	00000ea8 	andeq	r0, r0, r8, lsr #29
    40bc:	0000070c 	andeq	r0, r0, ip, lsl #14
    40c0:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    40c4:	01015091 	swpeq	r5, r1, [r1]	@ <UNPREDICTABLE>
    40c8:	50910251 	addspl	r0, r1, r1, asr r2
    40cc:	03520101 	cmpeq	r2, #1073741824	@ 0x40000000
    40d0:	007fa091 			@ <UNDEFINED> instruction: 0x007fa091
    40d4:	001f6402 	andseq	r6, pc, r2, lsl #8
    40d8:	000e8600 	andeq	r8, lr, r0, lsl #12
    40dc:	00072000 	andeq	r2, r7, r0
    40e0:	50010100 	andpl	r0, r1, r0, lsl #2
    40e4:	00509102 	subseq	r9, r0, r2, lsl #2
    40e8:	001f6e02 	andseq	r6, pc, r2, lsl #28
    40ec:	000ea800 	andeq	sl, lr, r0, lsl #16
    40f0:	00074000 	andeq	r4, r7, r0
    40f4:	50010100 	andpl	r0, r1, r0, lsl #2
    40f8:	01007402 	tsteq	r0, r2, lsl #8
    40fc:	74025101 	strvc	r5, [r2], #-257	@ 0xfffffeff
    4100:	52010100 	andpl	r0, r1, #0, 2
    4104:	00509102 	subseq	r9, r0, r2, lsl #2
    4108:	001f7802 	andseq	r7, pc, r2, lsl #16
    410c:	000d2600 	andeq	r2, sp, r0, lsl #12
    4110:	00076100 	andeq	r6, r7, r0, lsl #2
    4114:	50010100 	andpl	r0, r1, r0, lsl #2
    4118:	01007d02 	tsteq	r0, r2, lsl #26
    411c:	74025101 	strvc	r5, [r2], #-257	@ 0xfffffeff
    4120:	52010100 	andpl	r0, r1, #0, 2
    4124:	7fb89103 	svcvc	0x00b89103
    4128:	1f820200 	svcne	0x00820200
    412c:	0ea80000 	cdpeq	0, 10, cr0, cr8, cr0, {0}
    4130:	07810000 	streq	r0, [r1, r0]
    4134:	01010000 	mrseq	r0, (UNDEF: 1)
    4138:	007d0250 	rsbseq	r0, sp, r0, asr r2
    413c:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    4140:	0101007d 	tsteq	r1, sp, ror r0
    4144:	50910252 	addspl	r0, r1, r2, asr r2
    4148:	1f8c0200 	svcne	0x008c0200
    414c:	0ea80000 	cdpeq	0, 10, cr0, cr8, cr0, {0}
    4150:	07a10000 	streq	r0, [r1, r0]!
    4154:	01010000 	mrseq	r0, (UNDEF: 1)
    4158:	00770250 	rsbseq	r0, r7, r0, asr r2
    415c:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    4160:	01010077 	tsteq	r1, r7, ror r0
    4164:	007d0252 	rsbseq	r0, sp, r2, asr r2
    4168:	1f940400 	svcne	0x00940400
    416c:	119b0000 	orrsne	r0, fp, r0
    4170:	01010000 	mrseq	r0, (UNDEF: 1)
    4174:	00740250 	rsbseq	r0, r4, r0, asr r2
    4178:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    417c:	00005091 	muleq	r0, r1, r0
    4180:	001ed602 	andseq	sp, lr, r2, lsl #12
    4184:	0009fa00 	andeq	pc, r9, r0, lsl #20
    4188:	0007d200 	andeq	sp, r7, r0, lsl #4
    418c:	50010100 	andpl	r0, r1, r0, lsl #2
    4190:	01007502 	tsteq	r0, r2, lsl #10
    4194:	76025101 	strvc	r5, [r2], -r1, lsl #2
    4198:	e0020000 	and	r0, r2, r0
    419c:	fa00001e 	blx	421c <base_order+0x14f8>
    41a0:	ec000009 	stc	0, cr0, [r0], {9}
    41a4:	01000007 	tsteq	r0, r7
    41a8:	74025001 	strvc	r5, [r2], #-1
    41ac:	51010100 	mrspl	r0, (UNDEF: 17)
    41b0:	00007702 	andeq	r7, r0, r2, lsl #14
    41b4:	001eea02 	andseq	lr, lr, r2, lsl #20
    41b8:	0010c400 	andseq	ip, r0, r0, lsl #8
    41bc:	00080600 	andeq	r0, r8, r0, lsl #12
    41c0:	50010100 	andpl	r0, r1, r0, lsl #2
    41c4:	01007402 	tsteq	r0, r2, lsl #8
    41c8:	75025101 	strvc	r5, [r2, #-257]	@ 0xfffffeff
    41cc:	f4020000 	vst4.8	{d0-d3}, [r2], r0
    41d0:	c400001e 	strgt	r0, [r0], #-30	@ 0xffffffe2
    41d4:	20000010 	andcs	r0, r0, r0, lsl r0
    41d8:	01000008 	tsteq	r0, r8
    41dc:	77025001 	strvc	r5, [r2, -r1]
    41e0:	51010100 	mrspl	r0, (UNDEF: 17)
    41e4:	00007602 	andeq	r7, r0, r2, lsl #12
    41e8:	001efe02 	andseq	pc, lr, r2, lsl #28
    41ec:	00087700 	andeq	r7, r8, r0, lsl #14
    41f0:	00083a00 	andeq	r3, r8, r0, lsl #20
    41f4:	50010100 	andpl	r0, r1, r0, lsl #2
    41f8:	01007402 	tsteq	r0, r2, lsl #8
    41fc:	77025101 	strvc	r5, [r2, -r1, lsl #2]
    4200:	0c020000 	stceq	0, cr0, [r2], {-0}
    4204:	bc00001f 	stclt	0, cr0, [r0], {31}
    4208:	6000000a 	andvs	r0, r0, sl
    420c:	01000008 	tsteq	r0, r8
    4210:	74025001 	strvc	r5, [r2], #-1
    4214:	51010100 	mrspl	r0, (UNDEF: 17)
    4218:	01007702 	tsteq	r0, r2, lsl #14
    421c:	75025201 	strvc	r5, [r2, #-513]	@ 0xfffffdff
    4220:	53010100 	movwpl	r0, #4352	@ 0x1100
    4224:	00007602 	andeq	r7, r0, r2, lsl #12
    4228:	001f1804 	andseq	r1, pc, r4, lsl #16
    422c:	000a5d00 	andeq	r5, sl, r0, lsl #26
    4230:	50010100 	andpl	r0, r1, r0, lsl #2
    4234:	01007402 	tsteq	r0, r2, lsl #8
    4238:	77025101 	strvc	r5, [r2, -r1, lsl #2]
    423c:	07000000 	streq	r0, [r0, -r0]
    4240:	00000b01 	andeq	r0, r0, r1, lsl #22
    4244:	1e540227 	cdpne	2, 5, cr0, cr4, cr7, {1}
    4248:	006e0000 	rsbeq	r0, lr, r0
    424c:	9c010000 	stcls	0, cr0, [r1], {-0}
    4250:	000009fa 	strdeq	r0, [r0], -sl
    4254:	27007803 	strcs	r7, [r0, -r3, lsl #16]
    4258:	057f2702 	ldrbeq	r2, [pc, #-1794]!	@ 3b5e <base_order+0xe3a>
    425c:	1a3b0000 	bne	ec4264 <__ROM_SIZE__+0xe84264>
    4260:	1a370000 	bne	dc4268 <__ROM_SIZE__+0xd84268>
    4264:	79030000 	stmdbvc	r3, {}	@ <UNPREDICTABLE>
    4268:	34022700 	strcc	r2, [r2], #-1792	@ 0xfffff900
    426c:	0000057f 	andeq	r0, r0, pc, ror r5
    4270:	00001a4e 	andeq	r1, r0, lr, asr #20
    4274:	00001a4a 	andeq	r1, r0, sl, asr #20
    4278:	001e6c10 	andseq	r6, lr, r0, lsl ip
    427c:	00005400 	andeq	r5, r0, r0, lsl #8
    4280:	0009d500 	andeq	sp, r9, r0, lsl #10
    4284:	006c0600 	rsbeq	r0, ip, r0, lsl #12
    4288:	af0f0230 	svcge	0x000f0230
    428c:	02000000 	andeq	r0, r0, #0
    4290:	74025891 	strvc	r5, [r2], #-2193	@ 0xfffff76f
    4294:	5000001e 	andpl	r0, r0, lr, lsl r0
    4298:	e400000b 	str	r0, [r0], #-11
    429c:	01000008 	tsteq	r0, r8
    42a0:	7d025001 	stcvc	0, cr5, [r2, #-4]
    42a4:	51010100 	mrspl	r0, (UNDEF: 17)
    42a8:	00007402 	andeq	r7, r0, r2, lsl #8
    42ac:	001e7e02 	andseq	r7, lr, r2, lsl #28
    42b0:	000d2600 	andeq	r2, sp, r0, lsl #12
    42b4:	00090400 	andeq	r0, r9, r0, lsl #8
    42b8:	50010100 	andpl	r0, r1, r0, lsl #2
    42bc:	01007d02 	tsteq	r0, r2, lsl #26
    42c0:	7d025101 	stfvcs	f5, [r2, #-4]
    42c4:	52010100 	andpl	r0, r1, #0, 2
    42c8:	00007502 	andeq	r7, r0, r2, lsl #10
    42cc:	001e8802 	andseq	r8, lr, r2, lsl #16
    42d0:	000ea800 	andeq	sl, lr, r0, lsl #16
    42d4:	00092400 	andeq	r2, r9, r0, lsl #8
    42d8:	50010100 	andpl	r0, r1, r0, lsl #2
    42dc:	01007d02 	tsteq	r0, r2, lsl #26
    42e0:	7d025101 	stfvcs	f5, [r2, #-4]
    42e4:	52010100 	andpl	r0, r1, #0, 2
    42e8:	00007402 	andeq	r7, r0, r2, lsl #8
    42ec:	001e9202 	andseq	r9, lr, r2, lsl #4
    42f0:	000d2600 	andeq	r2, sp, r0, lsl #12
    42f4:	00094400 	andeq	r4, r9, r0, lsl #8
    42f8:	50010100 	andpl	r0, r1, r0, lsl #2
    42fc:	01007502 	tsteq	r0, r2, lsl #10
    4300:	74025101 	strvc	r5, [r2], #-257	@ 0xfffffeff
    4304:	52010100 	andpl	r0, r1, #0, 2
    4308:	00007402 	andeq	r7, r0, r2, lsl #8
    430c:	001e9c02 	andseq	r9, lr, r2, lsl #24
    4310:	000d2600 	andeq	r2, sp, r0, lsl #12
    4314:	00096400 	andeq	r6, r9, r0, lsl #8
    4318:	50010100 	andpl	r0, r1, r0, lsl #2
    431c:	01007402 	tsteq	r0, r2, lsl #8
    4320:	7d025101 	stfvcs	f5, [r2, #-4]
    4324:	52010100 	andpl	r0, r1, #0, 2
    4328:	00007d02 	andeq	r7, r0, r2, lsl #26
    432c:	001ea202 	andseq	sl, lr, r2, lsl #4
    4330:	000e8600 	andeq	r8, lr, r0, lsl #12
    4334:	00097800 	andeq	r7, r9, r0, lsl #16
    4338:	50010100 	andpl	r0, r1, r0, lsl #2
    433c:	00007d02 	andeq	r7, r0, r2, lsl #26
    4340:	001eac02 	andseq	sl, lr, r2, lsl #24
    4344:	000ea800 	andeq	sl, lr, r0, lsl #16
    4348:	00099800 	andeq	r9, r9, r0, lsl #16
    434c:	50010100 	andpl	r0, r1, r0, lsl #2
    4350:	01007402 	tsteq	r0, r2, lsl #8
    4354:	74025101 	strvc	r5, [r2], #-257	@ 0xfffffeff
    4358:	52010100 	andpl	r0, r1, #0, 2
    435c:	00007d02 	andeq	r7, r0, r2, lsl #26
    4360:	001eb602 	andseq	fp, lr, r2, lsl #12
    4364:	000d2600 	andeq	r2, sp, r0, lsl #12
    4368:	0009b800 	andeq	fp, r9, r0, lsl #16
    436c:	50010100 	andpl	r0, r1, r0, lsl #2
    4370:	01007d02 	tsteq	r0, r2, lsl #26
    4374:	7d025101 	stfvcs	f5, [r2, #-4]
    4378:	52010100 	andpl	r0, r1, #0, 2
    437c:	00007402 	andeq	r7, r0, r2, lsl #8
    4380:	001ec004 	andseq	ip, lr, r4
    4384:	000ea800 	andeq	sl, lr, r0, lsl #16
    4388:	50010100 	andpl	r0, r1, r0, lsl #2
    438c:	01007502 	tsteq	r0, r2, lsl #10
    4390:	75025101 	strvc	r5, [r2, #-257]	@ 0xfffffeff
    4394:	52010100 	andpl	r0, r1, #0, 2
    4398:	00007d02 	andeq	r7, r0, r2, lsl #26
    439c:	1e600200 	cdpne	2, 6, cr0, cr0, cr0, {0}
    43a0:	10560000 	subsne	r0, r6, r0
    43a4:	09e90000 	stmibeq	r9!, {}^	@ <UNPREDICTABLE>
    43a8:	01010000 	mrseq	r0, (UNDEF: 1)
    43ac:	00740250 	rsbseq	r0, r4, r0, asr r2
    43b0:	1e680400 	cdpne	4, 6, cr0, cr8, cr0, {0}
    43b4:	10940000 	addsne	r0, r4, r0
    43b8:	01010000 	mrseq	r0, (UNDEF: 1)
    43bc:	00750250 	rsbseq	r0, r5, r0, asr r2
    43c0:	d30d0000 	movwle	r0, #53248	@ 0xd000
    43c4:	2000000b 	andcs	r0, r0, fp
    43c8:	00008002 	andeq	r8, r0, r2
    43cc:	001e3e00 	andseq	r3, lr, r0, lsl #28
    43d0:	00001600 	andeq	r1, r0, r0, lsl #12
    43d4:	5d9c0100 	ldfpls	f0, [ip]
    43d8:	0300000a 	movweq	r0, #10
    43dc:	02200078 	eoreq	r0, r0, #120	@ 0x78
    43e0:	0004412d 	andeq	r4, r4, sp, lsr #2
    43e4:	001a6100 	andseq	r6, sl, r0, lsl #2
    43e8:	001a5d00 	andseq	r5, sl, r0, lsl #26
    43ec:	00790300 	rsbseq	r0, r9, r0, lsl #6
    43f0:	41400220 	cmpmi	r0, r0, lsr #4
    43f4:	77000004 	strvc	r0, [r0, -r4]
    43f8:	7300001a 	movwvc	r0, #26
    43fc:	0200001a 	andeq	r0, r0, #26
    4400:	00001e46 	andeq	r1, r0, r6, asr #28
    4404:	00001056 	andeq	r1, r0, r6, asr r0
    4408:	00000a4c 	andeq	r0, r0, ip, asr #20
    440c:	03500101 	cmpeq	r0, #1073741824	@ 0x40000000
    4410:	005001a3 	subseq	r0, r0, r3, lsr #3
    4414:	001e4e04 	andseq	r4, lr, r4, lsl #28
    4418:	00105600 	andseq	r5, r0, r0, lsl #12
    441c:	50010100 	andpl	r0, r1, r0, lsl #2
    4420:	00007402 	andeq	r7, r0, r2, lsl #8
    4424:	0ac60700 	beq	ff18602c <_STACK_TOP_+0xdf17e030>
    4428:	021a0000 	andseq	r0, sl, #0
    442c:	00001e2e 	andeq	r1, r0, lr, lsr #28
    4430:	00000010 	andeq	r0, r0, r0, lsl r0
    4434:	0abc9c01 	beq	fef2b440 <_STACK_TOP_+0xdef23444>
    4438:	78030000 	stmdavc	r3, {}	@ <UNPREDICTABLE>
    443c:	29021a00 	stmdbcs	r2, {r9, fp, ip}
    4440:	0000057f 	andeq	r0, r0, pc, ror r5
    4444:	00001a8a 	andeq	r1, r0, sl, lsl #21
    4448:	00001a86 	andeq	r1, r0, r6, lsl #21
    444c:	1a007903 	bne	22860 <__RAM_SIZE__+0x1a860>
    4450:	057f3602 	ldrbeq	r3, [pc, #-1538]!	@ 3e56 <base_order+0x1132>
    4454:	1aa00000 	bne	fe80445c <_STACK_TOP_+0xde7fc460>
    4458:	1a9c0000 	bne	fe704460 <_STACK_TOP_+0xde6fc464>
    445c:	36020000 	strcc	r0, [r2], -r0
    4460:	9400001e 	strls	r0, [r0], #-30	@ 0xffffffe2
    4464:	ab000010 	blge	44ac <base_order+0x1788>
    4468:	0100000a 	tsteq	r0, sl
    446c:	a3035001 	movwge	r5, #12289	@ 0x3001
    4470:	04005001 	streq	r5, [r0], #-1
    4474:	00001e3c 	andeq	r1, r0, ip, lsr lr
    4478:	00001094 	muleq	r0, r4, r0
    447c:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    4480:	00000074 	andeq	r0, r0, r4, ror r0
    4484:	000c4207 	andeq	r4, ip, r7, lsl #4
    4488:	18021400 	stmdane	r2, {sl, ip}
    448c:	1600001e 			@ <UNDEFINED> instruction: 0x1600001e
    4490:	01000000 	mrseq	r0, (UNDEF: 0)
    4494:	000b509c 	muleq	fp, ip, r0
    4498:	31780300 	cmncc	r8, r0, lsl #6
    449c:	25021400 	strcs	r1, [r2, #-1024]	@ 0xfffffc00
    44a0:	0000057f 	andeq	r0, r0, pc, ror r5
    44a4:	00001ab3 			@ <UNDEFINED> instruction: 0x00001ab3
    44a8:	00001aaf 	andeq	r1, r0, pc, lsr #21
    44ac:	00317903 	eorseq	r7, r1, r3, lsl #18
    44b0:	7f330214 	svcvc	0x00330214
    44b4:	c9000005 	stmdbgt	r0, {r0, r2}
    44b8:	c500001a 	strgt	r0, [r0, #-26]	@ 0xffffffe6
    44bc:	0300001a 	movweq	r0, #26
    44c0:	14003278 	strne	r3, [r0], #-632	@ 0xfffffd88
    44c4:	04414702 	strbeq	r4, [r1], #-1794	@ 0xfffff8fe
    44c8:	1adc0000 	bne	ff7044d0 <_STACK_TOP_+0xdf6fc4d4>
    44cc:	1ad80000 	bne	ff6044d4 <_STACK_TOP_+0xdf5fc4d8>
    44d0:	79030000 	stmdbvc	r3, {}	@ <UNPREDICTABLE>
    44d4:	02140032 	andseq	r0, r4, #50	@ 0x32
    44d8:	0004415b 	andeq	r4, r4, fp, asr r1
    44dc:	001af200 	andseq	pc, sl, r0, lsl #4
    44e0:	001aee00 	andseq	lr, sl, r0, lsl #28
    44e4:	1e240200 	cdpne	2, 2, cr0, cr4, cr0, {0}
    44e8:	119b0000 	orrsne	r0, fp, r0
    44ec:	0b390000 	bleq	e444f4 <__ROM_SIZE__+0xe044f4>
    44f0:	01010000 	mrseq	r0, (UNDEF: 1)
    44f4:	01a30350 			@ <UNDEFINED> instruction: 0x01a30350
    44f8:	51010150 	tstpl	r1, r0, asr r1
    44fc:	5201a303 	andpl	sl, r1, #201326592	@ 0xc000000
    4500:	1e2c0400 	cdpne	4, 2, cr0, cr12, cr0, {0}
    4504:	119b0000 	orrsne	r0, fp, r0
    4508:	01010000 	mrseq	r0, (UNDEF: 1)
    450c:	00740250 	rsbseq	r0, r4, r0, asr r2
    4510:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    4514:	00000075 	andeq	r0, r0, r5, ror r0
    4518:	000b4407 	andeq	r4, fp, r7, lsl #8
    451c:	9401e600 	strls	lr, [r1], #-1536	@ 0xfffffa00
    4520:	8400001d 	strhi	r0, [r0], #-29	@ 0xffffffe3
    4524:	01000000 	mrseq	r0, (UNDEF: 0)
    4528:	000d269c 	muleq	sp, ip, r6
    452c:	007a0300 	rsbseq	r0, sl, r0, lsl #6
    4530:	7f2401e6 	svcvc	0x002401e6
    4534:	07000005 	streq	r0, [r0, -r5]
    4538:	0100001b 	tsteq	r0, fp, lsl r0
    453c:	0300001b 	movweq	r0, #27
    4540:	01e60078 	mvneq	r0, r8, ror r0
    4544:	00044137 	andeq	r4, r4, r7, lsr r1
    4548:	001b2400 	andseq	r2, fp, r0, lsl #8
    454c:	001b2000 	andseq	r2, fp, r0
    4550:	00750600 	rsbseq	r0, r5, r0, lsl #12
    4554:	af0d01e8 	svcge	0x000d01e8
    4558:	02000000 	andeq	r0, r0, #0
    455c:	76065091 			@ <UNDEFINED> instruction: 0x76065091
    4560:	1001e800 	andne	lr, r1, r0, lsl #16
    4564:	000000af 	andeq	r0, r0, pc, lsr #1
    4568:	7fb89103 	svcvc	0x00b89103
    456c:	e8006706 	stmda	r0, {r1, r2, r8, r9, sl, sp, lr}
    4570:	00af1301 	adceq	r1, pc, r1, lsl #6
    4574:	91030000 	mrsls	r0, (UNDEF: 3)
    4578:	68067fa0 	stmdavs	r6, {r5, r7, r8, r9, sl, fp, ip, sp, lr}
    457c:	1601e800 	strne	lr, [r1], -r0, lsl #16
    4580:	000000af 	andeq	r0, r0, pc, lsr #1
    4584:	7f889103 	svcvc	0x00889103
    4588:	e9006905 	stmdb	r0, {r0, r2, r8, fp, sp, lr}
    458c:	00800701 	addeq	r0, r0, r1, lsl #14
    4590:	1b3c0000 	blne	f04598 <__ROM_SIZE__+0xec4598>
    4594:	1b360000 	blne	d8459c <__ROM_SIZE__+0xd4459c>
    4598:	a0020000 	andge	r0, r2, r0
    459c:	9b00001d 	blls	4618 <base_order+0x18f4>
    45a0:	ed000011 	stc	0, cr0, [r0, #-68]	@ 0xffffffbc
    45a4:	0100000b 	tsteq	r0, fp
    45a8:	91025001 	tstls	r2, r1
    45ac:	51010150 	tstpl	r1, r0, asr r1
    45b0:	5101a303 	tstpl	r1, r3, lsl #6
    45b4:	1da80200 	sfmne	f0, 4, [r8]
    45b8:	119b0000 	orrsne	r0, fp, r0
    45bc:	0c0b0000 	stceq	0, cr0, [fp], {-0}
    45c0:	01010000 	mrseq	r0, (UNDEF: 1)
    45c4:	b8910350 	ldmlt	r1, {r4, r6, r8, r9}
    45c8:	5101017f 	tstpl	r1, pc, ror r1
    45cc:	2cc40305 	stclcs	3, cr0, [r4], {5}
    45d0:	02000000 	andeq	r0, r0, #0
    45d4:	00001dae 	andeq	r1, r0, lr, lsr #27
    45d8:	00001094 	muleq	r0, r4, r0
    45dc:	00000c20 	andeq	r0, r0, r0, lsr #24
    45e0:	03500101 	cmpeq	r0, #1073741824	@ 0x40000000
    45e4:	007fa091 			@ <UNDEFINED> instruction: 0x007fa091
    45e8:	001db402 	andseq	fp, sp, r2, lsl #8
    45ec:	000f3200 	andeq	r3, pc, r0, lsl #4
    45f0:	000c3400 	andeq	r3, ip, r0, lsl #8
    45f4:	50010100 	andpl	r0, r1, r0, lsl #2
    45f8:	00007702 	andeq	r7, r0, r2, lsl #14
    45fc:	001dc002 	andseq	ip, sp, r2
    4600:	000f6600 	andeq	r6, pc, r0, lsl #12
    4604:	000c5500 	andeq	r5, ip, r0, lsl #10
    4608:	50010100 	andpl	r0, r1, r0, lsl #2
    460c:	01007d02 	tsteq	r0, r2, lsl #26
    4610:	91035101 	tstls	r3, r1, lsl #2
    4614:	01017fb8 			@ <UNDEFINED> instruction: 0x01017fb8
    4618:	00760252 	rsbseq	r0, r6, r2, asr r2
    461c:	1dca0200 	sfmne	f0, 2, [sl]
    4620:	0ea80000 	cdpeq	0, 10, cr0, cr8, cr0, {0}
    4624:	0c750000 	ldcleq	0, cr0, [r5], #-0
    4628:	01010000 	mrseq	r0, (UNDEF: 1)
    462c:	50910250 	addspl	r0, r1, r0, asr r2
    4630:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    4634:	01015091 	swpeq	r5, r1, [r1]	@ <UNPREDICTABLE>
    4638:	007d0252 	rsbseq	r0, sp, r2, asr r2
    463c:	1dd40200 	lfmne	f0, 2, [r4]
    4640:	0f660000 	svceq	0x00660000
    4644:	0c960000 	ldceq	0, cr0, [r6], {0}
    4648:	01010000 	mrseq	r0, (UNDEF: 1)
    464c:	007d0250 	rsbseq	r0, sp, r0, asr r2
    4650:	03510101 	cmpeq	r1, #1073741824	@ 0x40000000
    4654:	017fa091 			@ <UNDEFINED> instruction: 0x017fa091
    4658:	76025201 	strvc	r5, [r2], -r1, lsl #4
    465c:	de020000 	cdple	0, 0, cr0, cr2, cr0, {0}
    4660:	a800001d 	stmdage	r0, {r0, r2, r3, r4}
    4664:	b600000e 	strlt	r0, [r0], -lr
    4668:	0100000c 	tsteq	r0, ip
    466c:	77025001 	strvc	r5, [r2, -r1]
    4670:	51010100 	mrspl	r0, (UNDEF: 17)
    4674:	01007702 	tsteq	r0, r2, lsl #14
    4678:	7d025201 	sfmvc	f5, 4, [r2, #-4]
    467c:	e4020000 	str	r0, [r2], #-0
    4680:	f400001d 	vst4.8	{d0-d3}, [r0 :64]!
    4684:	ca00000e 	bgt	46c4 <base_order+0x19a0>
    4688:	0100000c 	tsteq	r0, ip
    468c:	91025001 	tstls	r2, r1
    4690:	ec020050 	stc	0, cr0, [r2], {80}	@ 0x50
    4694:	fe00001d 	mcr2	0, 0, r0, cr0, cr13, {0}
    4698:	de00000f 	cdple	0, 0, cr0, cr0, cr15, {0}
    469c:	0100000c 	tsteq	r0, ip
    46a0:	91025001 	tstls	r2, r1
    46a4:	f4020050 	vst4.16	{d0-d3}, [r2 :64], r0
    46a8:	fe00001d 	mcr2	0, 0, r0, cr0, cr13, {0}
    46ac:	f300000f 	vhadd.u8	d0, d0, d15
    46b0:	0100000c 	tsteq	r0, ip
    46b4:	91035001 	tstls	r3, r1
    46b8:	02007fb8 	andeq	r7, r0, #184, 30	@ 0x2e0
    46bc:	00001e02 	andeq	r1, r0, r2, lsl #28
    46c0:	0000110b 	andeq	r1, r0, fp, lsl #2
    46c4:	00000d0e 	andeq	r0, r0, lr, lsl #26
    46c8:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    46cc:	01015091 	swpeq	r5, r1, [r1]	@ <UNPREDICTABLE>
    46d0:	b8910351 	ldmlt	r1, {r0, r4, r6, r8, r9}
    46d4:	0a04007f 	beq	1048d8 <__ROM_SIZE__+0xc48d8>
    46d8:	0b00001e 	bleq	4758 <base_order+0x1a34>
    46dc:	01000011 	tsteq	r0, r1, lsl r0
    46e0:	91035001 	tstls	r3, r1
    46e4:	01017fa0 	smlatbeq	r1, r0, pc, r7	@ <UNPREDICTABLE>
    46e8:	00770251 	rsbseq	r0, r7, r1, asr r2
    46ec:	09070000 	stmdbeq	r7, {}	@ <UNPREDICTABLE>
    46f0:	b000000c 	andlt	r0, r0, ip
    46f4:	001d1e01 	andseq	r1, sp, r1, lsl #28
    46f8:	00007600 	andeq	r7, r0, r0, lsl #12
    46fc:	869c0100 	ldrhi	r0, [ip], r0, lsl #2
    4700:	0300000e 	movweq	r0, #14
    4704:	01b0007a 	rorseq	r0, sl, r0
    4708:	00057f24 	andeq	r7, r5, r4, lsr #30
    470c:	001b5d00 	andseq	r5, fp, r0, lsl #26
    4710:	001b5700 	andseq	r5, fp, r0, lsl #14
    4714:	00780300 	rsbseq	r0, r8, r0, lsl #6
    4718:	413701b0 	teqmi	r7, r0	@ <illegal shifter operand>
    471c:	80000004 	andhi	r0, r0, r4
    4720:	7600001b 			@ <UNDEFINED> instruction: 0x7600001b
    4724:	0300001b 	movweq	r0, #27
    4728:	01b00079 	rorseq	r0, r9, r0
    472c:	0004414a 	andeq	r4, r4, sl, asr #2
    4730:	001bb000 	andseq	fp, fp, r0
    4734:	001baa00 	andseq	sl, fp, r0, lsl #20
    4738:	00690500 	rsbeq	r0, r9, r0, lsl #10
    473c:	800701b2 			@ <UNDEFINED> instruction: 0x800701b2
    4740:	cb000000 	blgt	4748 <base_order+0x1a24>
    4744:	c900001b 	stmdbgt	r0, {r0, r1, r3, r4}
    4748:	0600001b 			@ <UNDEFINED> instruction: 0x0600001b
    474c:	00706d74 	rsbseq	r6, r0, r4, ror sp
    4750:	af0d01b3 	svcge	0x000d01b3
    4754:	02000000 	andeq	r0, r0, #0
    4758:	2e025891 	mcrcs	8, 0, r5, cr2, cr1, {4}
    475c:	9b00001d 	blls	47d8 <base_order+0x1ab4>
    4760:	ac000011 	stcge	0, cr0, [r0], {17}
    4764:	0100000d 	tsteq	r0, sp
    4768:	7d025001 	stcvc	0, cr5, [r2, #-4]
    476c:	51010100 	mrspl	r0, (UNDEF: 17)
    4770:	00007402 	andeq	r7, r0, r2, lsl #8
    4774:	001d3602 	andseq	r3, sp, r2, lsl #12
    4778:	00120900 	andseq	r0, r2, r0, lsl #18
    477c:	000dc500 	andeq	ip, sp, r0, lsl #10
    4780:	50010100 	andpl	r0, r1, r0, lsl #2
    4784:	01007502 	tsteq	r0, r2, lsl #10
    4788:	30015101 	andcc	r5, r1, r1, lsl #2
    478c:	1d400200 	sfmne	f0, 2, [r0, #-0]
    4790:	119b0000 	orrsne	r0, fp, r0
    4794:	0ddf0000 	ldcleq	0, cr0, [pc]	@ 479c <base_order+0x1a78>
    4798:	01010000 	mrseq	r0, (UNDEF: 1)
    479c:	00760250 	rsbseq	r0, r6, r0, asr r2
    47a0:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    47a4:	02000074 	andeq	r0, r0, #116	@ 0x74
    47a8:	00001d4a 	andeq	r1, r0, sl, asr #26
    47ac:	00001094 	muleq	r0, r4, r0
    47b0:	00000df3 	strdeq	r0, [r0], -r3
    47b4:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    47b8:	02000076 	andeq	r0, r0, #118	@ 0x76
    47bc:	00001d56 	andeq	r1, r0, r6, asr sp
    47c0:	00000ea8 	andeq	r0, r0, r8, lsr #29
    47c4:	00000e16 	andeq	r0, r0, r6, lsl lr
    47c8:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    47cc:	0101007d 	tsteq	r1, sp, ror r0
    47d0:	007d0251 	rsbseq	r0, sp, r1, asr r2
    47d4:	05520101 	ldrbeq	r0, [r2, #-257]	@ 0xfffffeff
    47d8:	002cc403 	eoreq	ip, ip, r3, lsl #8
    47dc:	68020000 	stmdavs	r2, {}	@ <UNPREDICTABLE>
    47e0:	6600001d 			@ <UNDEFINED> instruction: 0x6600001d
    47e4:	3500000f 	strcc	r0, [r0, #-15]
    47e8:	0100000e 	tsteq	r0, lr
    47ec:	7d025001 	stcvc	0, cr5, [r2, #-4]
    47f0:	51010100 	mrspl	r0, (UNDEF: 17)
    47f4:	01007d02 	tsteq	r0, r2, lsl #26
    47f8:	31015201 	tstcc	r1, r1, lsl #4
    47fc:	1d700200 	lfmne	f0, 2, [r0, #-0]
    4800:	12090000 	andne	r0, r9, #0
    4804:	0e4f0000 	cdpeq	0, 4, cr0, cr15, cr0, {0}
    4808:	01010000 	mrseq	r0, (UNDEF: 1)
    480c:	007d0250 	rsbseq	r0, sp, r0, asr r2
    4810:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    4814:	0200a308 	andeq	sl, r0, #8, 6	@ 0x20000000
    4818:	00001d7c 	andeq	r1, r0, ip, ror sp
    481c:	00001209 	andeq	r1, r0, r9, lsl #4
    4820:	00000e69 	andeq	r0, r0, r9, ror #28
    4824:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    4828:	01010075 	tsteq	r1, r5, ror r0
    482c:	00740251 	rsbseq	r0, r4, r1, asr r2
    4830:	1d8a0400 	cfstrsne	mvf0, [sl]
    4834:	0ea80000 	cdpeq	0, 10, cr0, cr8, cr0, {0}
    4838:	01010000 	mrseq	r0, (UNDEF: 1)
    483c:	00760250 	rsbseq	r0, r6, r0, asr r2
    4840:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    4844:	01010076 	tsteq	r1, r6, ror r0
    4848:	007d0252 	rsbseq	r0, sp, r2, asr r2
    484c:	11070000 	mrsne	r0, (UNDEF: 7)
    4850:	a900000b 	stmdbge	r0, {r0, r1, r3}
    4854:	001d1401 	andseq	r1, sp, r1, lsl #8
    4858:	00000a00 	andeq	r0, r0, r0, lsl #20
    485c:	a89c0100 	ldmge	ip, {r8}
    4860:	0a00000e 	beq	48a0 <base_order+0x1b7c>
    4864:	01a90078 			@ <UNDEFINED> instruction: 0x01a90078
    4868:	00057f24 	andeq	r7, r5, r4, lsr #30
    486c:	00500100 	subseq	r0, r0, r0, lsl #2
    4870:	000bc607 	andeq	ip, fp, r7, lsl #12
    4874:	f2019f00 	vmax.f32	d9, d1, d0
    4878:	2200001c 	andcs	r0, r0, #28
    487c:	01000000 	mrseq	r0, (UNDEF: 0)
    4880:	000ef49c 	muleq	lr, ip, r4
    4884:	007a0a00 	rsbseq	r0, sl, r0, lsl #20
    4888:	7f24019f 	svcvc	0x0024019f
    488c:	01000005 	tsteq	r0, r5
    4890:	00780a50 	rsbseq	r0, r8, r0, asr sl
    4894:	4137019f 	teqmi	r7, pc	@ <illegal shifter operand>
    4898:	01000004 	tsteq	r0, r4
    489c:	00790a51 	rsbseq	r0, r9, r1, asr sl
    48a0:	414a019f 			@ <UNDEFINED> instruction: 0x414a019f
    48a4:	01000004 	tsteq	r0, r4
    48a8:	00690552 	rsbeq	r0, r9, r2, asr r5
    48ac:	800701a1 	andhi	r0, r7, r1, lsr #3
    48b0:	d7000000 	strle	r0, [r0, -r0]
    48b4:	d300001b 	movwle	r0, #27
    48b8:	0000001b 	andeq	r0, r0, fp, lsl r0
    48bc:	000bb60d 	andeq	fp, fp, sp, lsl #12
    48c0:	80017700 	andhi	r7, r1, r0, lsl #14
    48c4:	d0000000 	andle	r0, r0, r0
    48c8:	2200001c 	andcs	r0, r0, #28
    48cc:	01000000 	mrseq	r0, (UNDEF: 0)
    48d0:	000f329c 	muleq	pc, ip, r2	@ <UNPREDICTABLE>
    48d4:	00780300 	rsbseq	r0, r8, r0, lsl #6
    48d8:	412c0177 			@ <UNDEFINED> instruction: 0x412c0177
    48dc:	ef000004 	svc	0x00000004
    48e0:	e700001b 	smlad	r0, fp, r0, r0
    48e4:	0500001b 	streq	r0, [r0, #-27]	@ 0xffffffe5
    48e8:	017f0069 	cmneq	pc, r9, rrx
    48ec:	00008007 	andeq	r8, r0, r7
    48f0:	001c1400 	andseq	r1, ip, r0, lsl #8
    48f4:	001c1200 	andseq	r1, ip, r0, lsl #4
    48f8:	31070000 	mrscc	r0, (UNDEF: 7)
    48fc:	6900000c 	stmdbvs	r0, {r2, r3}
    4900:	001cbc01 	andseq	fp, ip, r1, lsl #24
    4904:	00001400 	andeq	r1, r0, r0, lsl #8
    4908:	669c0100 	ldrvs	r0, [ip], r0, lsl #2
    490c:	0a00000f 	beq	4950 <base_order+0x1c2c>
    4910:	01690078 	smceq	36872	@ 0x9008
    4914:	00057f28 	andeq	r7, r5, r8, lsr #30
    4918:	05500100 	ldrbeq	r0, [r0, #-256]	@ 0xffffff00
    491c:	016e0069 	cmneq	lr, r9, rrx
    4920:	00008007 	andeq	r8, r0, r7
    4924:	001c2000 	andseq	r2, ip, r0
    4928:	001c1c00 	andseq	r1, ip, r0, lsl #24
    492c:	78070000 	stmdavc	r7, {}	@ <UNPREDICTABLE>
    4930:	3f00000b 	svccc	0x0000000b
    4934:	001c4801 	andseq	r4, ip, r1, lsl #16
    4938:	00007400 	andeq	r7, r0, r0, lsl #8
    493c:	fe9c0100 	cdp2	1, 9, cr0, cr12, cr0, {0}
    4940:	0a00000f 	beq	4984 <base_order+0x1c60>
    4944:	013f0078 	teqeq	pc, r8, ror r0	@ <UNPREDICTABLE>
    4948:	00057f24 	andeq	r7, r5, r4, lsr #30
    494c:	03500100 	cmpeq	r0, #0, 2
    4950:	013f0079 	teqeq	pc, r9, ror r0	@ <UNPREDICTABLE>
    4954:	00044136 	andeq	r4, r4, r6, lsr r1
    4958:	001c3600 	andseq	r3, ip, r0, lsl #12
    495c:	001c3000 	andseq	r3, ip, r0
    4960:	0b630900 	bleq	18c6d68 <__ROM_SIZE__+0x1886d68>
    4964:	013f0000 	teqeq	pc, r0
    4968:	0000803d 	andeq	r8, r0, sp, lsr r0
    496c:	001c5500 	andseq	r5, ip, r0, lsl #10
    4970:	001c4f00 	andseq	r4, ip, r0, lsl #30
    4974:	0ae31200 	beq	ff8c917c <_STACK_TOP_+0xdf8c1180>
    4978:	01410000 	mrseq	r0, (UNDEF: 65)
    497c:	00008007 	andeq	r8, r0, r7
    4980:	001c7300 	andseq	r7, ip, r0, lsl #6
    4984:	001c6f00 	andseq	r6, ip, r0, lsl #30
    4988:	00690500 	rsbeq	r0, r9, r0, lsl #10
    498c:	80070144 	andhi	r0, r7, r4, asr #2
    4990:	88000000 	stmdahi	r0, {}	@ <UNPREDICTABLE>
    4994:	8200001c 	andhi	r0, r0, #28
    4998:	0500001c 	streq	r0, [r0, #-28]	@ 0xffffffe4
    499c:	0144006a 	cmpeq	r4, sl, rrx
    49a0:	00008009 	andeq	r8, r0, r9
    49a4:	001ca300 	andseq	sl, ip, r0, lsl #6
    49a8:	001c9f00 	andseq	r9, ip, r0, lsl #30
    49ac:	00c71800 	sbceq	r1, r7, r0, lsl #16
    49b0:	69050000 	stmdbvs	r5, {}	@ <UNPREDICTABLE>
    49b4:	09015800 	stmdbeq	r1, {fp, ip, lr}
    49b8:	00000080 	andeq	r0, r0, r0, lsl #1
    49bc:	00001cb4 			@ <UNDEFINED> instruction: 0x00001cb4
    49c0:	00001cb2 			@ <UNDEFINED> instruction: 0x00001cb2
    49c4:	910d0000 	mrsls	r0, (UNDEF: 13)
    49c8:	2400000b 	strcs	r0, [r0], #-11
    49cc:	00008001 	andeq	r8, r0, r1
    49d0:	001c1e00 	andseq	r1, ip, r0, lsl #28
    49d4:	00002a00 	andeq	r2, r0, r0, lsl #20
    49d8:	569c0100 	ldrpl	r0, [ip], r0, lsl #2
    49dc:	03000010 	movweq	r0, #16
    49e0:	01240078 			@ <UNDEFINED> instruction: 0x01240078
    49e4:	00044129 	andeq	r4, r4, r9, lsr #2
    49e8:	001cc400 	andseq	ip, ip, r0, lsl #8
    49ec:	001cbc00 	andseq	fp, ip, r0, lsl #24
    49f0:	00690500 	rsbeq	r0, r9, r0, lsl #10
    49f4:	80070126 	andhi	r0, r7, r6, lsr #2
    49f8:	e7000000 	str	r0, [r0, -r0]
    49fc:	e300001c 	movw	r0, #28
    4a00:	1800001c 	stmdane	r0, {r2, r3, r4}
    4a04:	000000bc 	strheq	r0, [r0], -ip
    4a08:	000c6512 	andeq	r6, ip, r2, lsl r5
    4a0c:	0e013400 	cfcpyseq	mvf3, mvf1
    4a10:	00000061 	andeq	r0, r0, r1, rrx
    4a14:	00001cfa 	strdeq	r1, [r0], -sl
    4a18:	00001cf8 	strdeq	r1, [r0], -r8
    4a1c:	350d0000 	strcc	r0, [sp, #-0]
    4a20:	0800000b 	stmdaeq	r0, {r0, r1, r3}
    4a24:	00008001 	andeq	r8, r0, r1
    4a28:	001c0400 	andseq	r0, ip, r0, lsl #8
    4a2c:	00001a00 	andeq	r1, r0, r0, lsl #20
    4a30:	949c0100 	ldrls	r0, [ip], #256	@ 0x100
    4a34:	03000010 	movweq	r0, #16
    4a38:	01080078 	tsteq	r8, r8, ror r0
    4a3c:	0004412a 	andeq	r4, r4, sl, lsr #2
    4a40:	001d0600 	andseq	r0, sp, r0, lsl #12
    4a44:	001d0200 	andseq	r0, sp, r0, lsl #4
    4a48:	00690500 	rsbeq	r0, r9, r0, lsl #10
    4a4c:	610c010a 	tstvs	ip, sl, lsl #2
    4a50:	1c000000 	stcne	0, cr0, [r0], {-0}
    4a54:	1800001d 	stmdane	r0, {r0, r2, r3, r4}
    4a58:	0000001d 	andeq	r0, r0, sp, lsl r0
    4a5c:	000bf913 	andeq	pc, fp, r3, lsl r9	@ <UNPREDICTABLE>
    4a60:	1bf2fd00 	blne	ffcc3e68 <_STACK_TOP_+0xdfcbbe6c>
    4a64:	00120000 	andseq	r0, r2, r0
    4a68:	9c010000 	stcls	0, cr0, [r1], {-0}
    4a6c:	000010c4 	andeq	r1, r0, r4, asr #1
    4a70:	fd00780e 	stc2	8, cr7, [r0, #-56]	@ 0xffffffc8
    4a74:	00057f26 	andeq	r7, r5, r6, lsr #30
    4a78:	15500100 	ldrbne	r0, [r0, #-256]	@ 0xffffff00
    4a7c:	80ff0069 	rscshi	r0, pc, r9, rrx
    4a80:	30000000 	andcc	r0, r0, r0
    4a84:	2c00001d 	stccs	0, cr0, [r0], {29}
    4a88:	0000001d 	andeq	r0, r0, sp, lsl r0
    4a8c:	000af41d 	andeq	pc, sl, sp, lsl r4	@ <UNPREDICTABLE>
    4a90:	0ce30100 	stfeqe	f0, [r3]
    4a94:	00000080 	andeq	r0, r0, r0, lsl #1
    4a98:	00001bd4 	ldrdeq	r1, [r0], -r4
    4a9c:	0000001e 	andeq	r0, r0, lr, lsl r0
    4aa0:	110b9c01 	tstne	fp, r1, lsl #24
    4aa4:	780b0000 	stmdavc	fp, {}	@ <UNPREDICTABLE>
    4aa8:	4128e300 			@ <UNDEFINED> instruction: 0x4128e300
    4aac:	48000004 	stmdami	r0, {r2}
    4ab0:	4000001d 	andmi	r0, r0, sp, lsl r0
    4ab4:	0e00001d 	mcreq	0, 0, r0, cr0, cr13, {0}
    4ab8:	3ae30079 	bcc	ff8c4ca4 <_STACK_TOP_+0xdf8bcca8>
    4abc:	00000441 	andeq	r0, r0, r1, asr #8
    4ac0:	69155101 	ldmdbvs	r5, {r0, r8, ip, lr}
    4ac4:	0080e500 	addeq	lr, r0, r0, lsl #10
    4ac8:	1d6a0000 	stclne	0, cr0, [sl, #-0]
    4acc:	1d660000 	stclne	0, cr0, [r6, #-0]
    4ad0:	13000000 	movwne	r0, #0
    4ad4:	00000be4 	andeq	r0, r0, r4, ror #23
    4ad8:	001bb0d9 	ldrsbeq	fp, [fp], -r9
    4adc:	00002400 	andeq	r2, r0, r0, lsl #8
    4ae0:	9b9c0100 	blls	fe704ee8 <_STACK_TOP_+0xde6fceec>
    4ae4:	0b000011 	bleq	4b30 <base_order+0x1e0c>
    4ae8:	22d90078 	sbcscs	r0, r9, #120	@ 0x78
    4aec:	0000057f 	andeq	r0, r0, pc, ror r5
    4af0:	00001d7d 	andeq	r1, r0, sp, ror sp
    4af4:	00001d77 	andeq	r1, r0, r7, ror sp
    4af8:	d900790b 	stmdble	r0, {r0, r1, r3, r8, fp, ip, sp, lr}
    4afc:	00057f2e 	andeq	r7, r5, lr, lsr #30
    4b00:	001d9100 	andseq	r9, sp, r0, lsl #2
    4b04:	001d8d00 	andseq	r8, sp, r0, lsl #26
    4b08:	6d741e00 	ldclvs	14, cr1, [r4, #-0]
    4b0c:	db010070 	blle	44cd4 <__ROM_SIZE__+0x4cd4>
    4b10:	00008e0c 	andeq	r8, r0, ip, lsl #28
    4b14:	58910200 	ldmpl	r1, {r9}
    4b18:	001bc002 	andseq	ip, fp, r2
    4b1c:	00119b00 	andseq	r9, r1, r0, lsl #22
    4b20:	00116a00 	andseq	r6, r1, r0, lsl #20
    4b24:	50010100 	andpl	r0, r1, r0, lsl #2
    4b28:	01007d02 	tsteq	r0, r2, lsl #26
    4b2c:	75025101 	strvc	r5, [r2, #-257]	@ 0xfffffeff
    4b30:	c8020000 	stmdagt	r2, {}	@ <UNPREDICTABLE>
    4b34:	9b00001b 	blls	4ba8 <base_order+0x1e84>
    4b38:	84000011 	strhi	r0, [r0], #-17	@ 0xffffffef
    4b3c:	01000011 	tsteq	r0, r1, lsl r0
    4b40:	75025001 	strvc	r5, [r2, #-1]
    4b44:	51010100 	mrspl	r0, (UNDEF: 17)
    4b48:	00007402 	andeq	r7, r0, r2, lsl #8
    4b4c:	001bd004 	andseq	sp, fp, r4
    4b50:	00119b00 	andseq	r9, r1, r0, lsl #22
    4b54:	50010100 	andpl	r0, r1, r0, lsl #2
    4b58:	01007402 	tsteq	r0, r2, lsl #8
    4b5c:	7d025101 	stfvcs	f5, [r2, #-4]
    4b60:	13000000 	movwne	r0, #0
    4b64:	00000b29 	andeq	r0, r0, r9, lsr #22
    4b68:	001b9cd0 			@ <UNDEFINED> instruction: 0x001b9cd0
    4b6c:	00001400 	andeq	r1, r0, r0, lsl #8
    4b70:	d69c0100 	ldrle	r0, [ip], r0, lsl #2
    4b74:	0e000011 	mcreq	0, 0, r0, cr0, cr1, {0}
    4b78:	22d00078 	sbcscs	r0, r0, #120	@ 0x78
    4b7c:	0000057f 	andeq	r0, r0, pc, ror r5
    4b80:	790e5001 	stmdbvc	lr, {r0, ip, lr}
    4b84:	4134d000 	teqmi	r4, r0
    4b88:	01000004 	tsteq	r0, r4
    4b8c:	00691551 	rsbeq	r1, r9, r1, asr r5
    4b90:	000080d2 	ldrdeq	r8, [r0], -r2
    4b94:	001da000 	andseq	sl, sp, r0
    4b98:	001d9c00 	andseq	r9, sp, r0, lsl #24
    4b9c:	a0130000 	andsge	r0, r3, r0
    4ba0:	cb00000c 	blgt	4bd8 <base_order+0x1eb4>
    4ba4:	00001b82 	andeq	r1, r0, r2, lsl #23
    4ba8:	0000001a 	andeq	r0, r0, sl, lsl r0
    4bac:	12099c01 	andne	r9, r9, #256	@ 0x100
    4bb0:	780e0000 	stmdavc	lr, {}	@ <UNPREDICTABLE>
    4bb4:	7f25cb00 	svcvc	0x0025cb00
    4bb8:	01000005 	tsteq	r0, r5
    4bbc:	64690b50 	strbtvs	r0, [r9], #-2896	@ 0xfffff4b0
    4bc0:	37cb0078 			@ <UNDEFINED> instruction: 0x37cb0078
    4bc4:	0000006d 	andeq	r0, r0, sp, rrx
    4bc8:	00001db0 			@ <UNDEFINED> instruction: 0x00001db0
    4bcc:	00001dac 	andeq	r1, r0, ip, lsr #27
    4bd0:	0b691f00 	bleq	1a4c7d8 <__ROM_SIZE__+0x1a0c7d8>
    4bd4:	c6010000 	strgt	r0, [r1], -r0
    4bd8:	0000800c 	andeq	r8, r0, ip
    4bdc:	001b7000 	andseq	r7, fp, r0
    4be0:	00001200 	andeq	r1, r0, r0, lsl #4
    4be4:	0b9c0100 	bleq	fe704fec <_STACK_TOP_+0xde6fcff0>
    4be8:	2ac60078 	bcs	ff184dd0 <_STACK_TOP_+0xdf17cdd4>
    4bec:	00000441 	andeq	r0, r0, r1, asr #8
    4bf0:	00001dc2 	andeq	r1, r0, r2, asr #27
    4bf4:	00001dbe 			@ <UNDEFINED> instruction: 0x00001dbe
    4bf8:	7864690b 	stmdavc	r4!, {r0, r1, r3, r8, fp, sp, lr}^
    4bfc:	6d3cc600 	ldcvs	6, cr12, [ip, #-0]
    4c00:	d4000000 	strle	r0, [r0], #-0
    4c04:	d000001d 	andle	r0, r0, sp, lsl r0
    4c08:	0000001d 	andeq	r0, r0, sp, lsl r0
    4c0c:	00014700 	andeq	r4, r1, r0, lsl #14
    4c10:	01000500 	tsteq	r0, r0, lsl #10
    4c14:	00174204 	andseq	r4, r7, r4, lsl #4
    4c18:	000d0500 	andeq	r0, sp, r0, lsl #10
    4c1c:	d51d0000 	ldrle	r0, [sp, #-0]
    4c20:	3a00000c 	bcc	4c58 <base_order+0x1f34>
    4c24:	f0000001 			@ <UNDEFINED> instruction: 0xf0000001
    4c28:	5c000020 	stcpl	0, cr0, [r0], {32}
    4c2c:	25000000 	strcs	r0, [r0, #-0]
    4c30:	01000034 	tsteq	r0, r4, lsr r0
    4c34:	00d90601 	sbcseq	r0, r9, r1, lsl #12
    4c38:	02010000 	andeq	r0, r1, #0
    4c3c:	00012b05 	andeq	r2, r1, r5, lsl #22
    4c40:	05040100 	streq	r0, [r4, #-256]	@ 0xffffff00
    4c44:	0000011b 	andeq	r0, r0, fp, lsl r1
    4c48:	16050801 	strne	r0, [r5], -r1, lsl #16
    4c4c:	01000001 	tsteq	r0, r1
    4c50:	00d70801 	sbcseq	r0, r7, r1, lsl #16
    4c54:	02010000 	andeq	r0, r1, #0
    4c58:	0000e507 	andeq	lr, r0, r7, lsl #10
    4c5c:	016d0600 	cmneq	sp, r0, lsl #12
    4c60:	34020000 	strcc	r0, [r2], #-0
    4c64:	00005c19 	andeq	r5, r0, r9, lsl ip
    4c68:	07040100 	streq	r0, [r4, -r0, lsl #2]
    4c6c:	000000fd 	strdeq	r0, [r0], -sp
    4c70:	f8070801 			@ <UNDEFINED> instruction: 0xf8070801
    4c74:	07000000 	streq	r0, [r0, -r0]
    4c78:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
    4c7c:	04010074 	streq	r0, [r1], #-116	@ 0xffffff8c
    4c80:	00010207 	andeq	r0, r1, r7, lsl #4
    4c84:	098e0800 	stmibeq	lr, {fp}
    4c88:	1b010000 	blne	44c90 <__ROM_SIZE__+0x4c90>
    4c8c:	0000500a 	andeq	r5, r0, sl
    4c90:	00210e00 	eoreq	r0, r1, r0, lsl #28
    4c94:	00003e00 	andeq	r3, r0, r0, lsl #28
    4c98:	e49c0100 	ldr	r0, [ip], #256	@ 0x100
    4c9c:	03000000 	movweq	r0, #0
    4ca0:	00727473 	rsbseq	r7, r2, r3, ror r4
    4ca4:	00e41b1b 	rsceq	r1, r4, fp, lsl fp
    4ca8:	1df20000 	ldclne	0, cr0, [r2]
    4cac:	1dee0000 	stclne	0, cr0, [lr]
    4cb0:	68020000 	stmdavs	r2, {}	@ <UNPREDICTABLE>
    4cb4:	1c007865 	stcne	8, cr7, [r0], {101}	@ 0x65
    4cb8:	0000500c 	andeq	r5, r0, ip
    4cbc:	001e0500 	andseq	r0, lr, r0, lsl #10
    4cc0:	001dfd00 	andseq	pc, sp, r0, lsl #26
    4cc4:	087e0900 	ldmdaeq	lr!, {r8, fp}^
    4cc8:	1d010000 	stcne	0, cr0, [r1, #-0]
    4ccc:	0000500c 	andeq	r5, r0, ip
    4cd0:	001e2700 	andseq	r2, lr, r0, lsl #14
    4cd4:	001e1f00 	andseq	r1, lr, r0, lsl #30
    4cd8:	00e50400 	rsceq	r0, r5, r0, lsl #8
    4cdc:	69020000 	stmdbvs	r2, {}	@ <UNPREDICTABLE>
    4ce0:	50111f00 	andspl	r1, r1, r0, lsl #30
    4ce4:	41000000 	mrsmi	r0, (UNDEF: 0)
    4ce8:	3d00001e 	stccc	0, cr0, [r0, #-120]	@ 0xffffff88
    4cec:	0000001e 	andeq	r0, r0, lr, lsl r0
    4cf0:	f1040a00 			@ <UNDEFINED> instruction: 0xf1040a00
    4cf4:	01000000 	mrseq	r0, (UNDEF: 0)
    4cf8:	00e00801 	rsceq	r0, r0, r1, lsl #16
    4cfc:	ea0b0000 	b	2c4d04 <__ROM_SIZE__+0x284d04>
    4d00:	0c000000 	stceq	0, cr0, [r0], {-0}
    4d04:	00000993 	muleq	r0, r3, r9
    4d08:	6a051301 	bvs	149914 <__ROM_SIZE__+0x109914>
    4d0c:	f0000000 			@ <UNDEFINED> instruction: 0xf0000000
    4d10:	1e000020 	cdpne	0, 0, cr0, cr0, cr0, {1}
    4d14:	01000000 	mrseq	r0, (UNDEF: 0)
    4d18:	7473039c 	ldrbtvc	r0, [r3], #-924	@ 0xfffffc64
    4d1c:	16130072 			@ <UNDEFINED> instruction: 0x16130072
    4d20:	000000e4 	andeq	r0, r0, r4, ror #1
    4d24:	00001e51 	andeq	r1, r0, r1, asr lr
    4d28:	00001e4d 	andeq	r1, r0, sp, asr #28
    4d2c:	73657202 	cmnvc	r5, #536870912	@ 0x20000000
    4d30:	6a071400 	bvs	1c9d38 <__ROM_SIZE__+0x189d38>
    4d34:	62000000 	andvs	r0, r0, #0
    4d38:	5c00001e 	stcpl	0, cr0, [r0], {30}
    4d3c:	0400001e 	streq	r0, [r0], #-30	@ 0xffffffe2
    4d40:	000000de 	ldrdeq	r0, [r0], -lr
    4d44:	15006902 	strne	r6, [r0, #-2306]	@ 0xfffff6fe
    4d48:	00006a0c 	andeq	r6, r0, ip, lsl #20
    4d4c:	001e7700 	andseq	r7, lr, r0, lsl #14
    4d50:	001e7300 	andseq	r7, lr, r0, lsl #6
    4d54:	00000000 	andeq	r0, r0, r0
    4d58:	00000226 	andeq	r0, r0, r6, lsr #4
    4d5c:	04010005 	streq	r0, [r1], #-5
    4d60:	00001808 	andeq	r1, r0, r8, lsl #16
    4d64:	00000d0c 	andeq	r0, r0, ip, lsl #26
    4d68:	0d461d00 	stcleq	13, cr1, [r6, #-0]
    4d6c:	013a0000 	teqeq	sl, r0
    4d70:	214c0000 	mrscs	r0, (UNDEF: 76)
    4d74:	00ac0000 	adceq	r0, ip, r0
    4d78:	35ae0000 	strcc	r0, [lr, #0]!
    4d7c:	01010000 	mrseq	r0, (UNDEF: 1)
    4d80:	0000d906 	andeq	sp, r0, r6, lsl #18
    4d84:	05020100 	streq	r0, [r2, #-256]	@ 0xffffff00
    4d88:	0000012b 	andeq	r0, r0, fp, lsr #2
    4d8c:	1b050401 	blne	145d98 <__ROM_SIZE__+0x105d98>
    4d90:	01000001 	tsteq	r0, r1
    4d94:	01160508 	tsteq	r6, r8, lsl #10
    4d98:	9b020000 	blls	84da0 <__ROM_SIZE__+0x44da0>
    4d9c:	02000003 	andeq	r0, r0, #3
    4da0:	0053182e 	subseq	r1, r3, lr, lsr #16
    4da4:	420d0000 	andmi	r0, sp, #0
    4da8:	01000000 	mrseq	r0, (UNDEF: 0)
    4dac:	00d70801 	sbcseq	r0, r7, r1, lsl #16
    4db0:	02010000 	andeq	r0, r1, #0
    4db4:	0000e507 	andeq	lr, r0, r7, lsl #10
    4db8:	016d0200 	cmneq	sp, r0, lsl #4
    4dbc:	34020000 	strcc	r0, [r2], #-0
    4dc0:	00006d19 	andeq	r6, r0, r9, lsl sp
    4dc4:	07040100 	streq	r0, [r4, -r0, lsl #2]
    4dc8:	000000fd 	strdeq	r0, [r0], -sp
    4dcc:	f8070801 			@ <UNDEFINED> instruction: 0xf8070801
    4dd0:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
    4dd4:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
    4dd8:	04010074 	streq	r0, [r1], #-116	@ 0xffffff8c
    4ddc:	00010207 	andeq	r0, r1, r7, lsl #4
    4de0:	0d2a0f00 	stceq	15, cr0, [sl, #-0]
    4de4:	01070000 	mrseq	r0, (UNDEF: 7)
    4de8:	00000053 	andeq	r0, r0, r3, asr r0
    4dec:	b40e1603 	strlt	r1, [lr], #-1539	@ 0xfffff9fd
    4df0:	07000000 	streq	r0, [r0, -r0]
    4df4:	00000d84 	andeq	r0, r0, r4, lsl #27
    4df8:	4e490800 	cdpmi	8, 4, cr0, cr9, cr0, {0}
    4dfc:	08010050 	stmdaeq	r1, {r4, r6}
    4e00:	0054554f 	subseq	r5, r4, pc, asr #10
    4e04:	0da10702 	stceq	7, cr0, [r1, #8]!
    4e08:	00030000 	andeq	r0, r3, r0
    4e0c:	000da902 	andeq	sl, sp, r2, lsl #18
    4e10:	031b0300 	tsteq	fp, #0, 6
    4e14:	00000089 	andeq	r0, r0, r9, lsl #1
    4e18:	000d0c10 	andeq	r0, sp, r0, lsl ip
    4e1c:	1d030c00 	stcne	12, cr0, [r3, #-0]
    4e20:	0000f210 	andeq	pc, r0, r0, lsl r2	@ <UNPREDICTABLE>
    4e24:	05eb0300 	strbeq	r0, [fp, #768]!	@ 0x300
    4e28:	151e0000 	ldrne	r0, [lr, #-0]
    4e2c:	000000f2 	strdeq	r0, [r0], -r2
    4e30:	06f20300 	ldrbteq	r0, [r2], r0, lsl #6
    4e34:	0c1f0000 	ldceq	0, cr0, [pc], {-0}
    4e38:	00000061 	andeq	r0, r0, r1, rrx
    4e3c:	0d3b0304 	ldceq	3, cr0, [fp, #-16]!
    4e40:	07210000 	streq	r0, [r1, -r0]!
    4e44:	0000007b 	andeq	r0, r0, fp, ror r0
    4e48:	4e090008 	cdpmi	0, 0, cr0, cr9, cr8, {0}
    4e4c:	02000000 	andeq	r0, r0, #0
    4e50:	00000d01 	andeq	r0, r0, r1, lsl #26
    4e54:	c0032203 	andgt	r2, r3, r3, lsl #4
    4e58:	02000000 	andeq	r0, r0, #0
    4e5c:	000003c6 	andeq	r0, r0, r6, asr #7
    4e60:	8217d604 	andshi	sp, r7, #4, 12	@ 0x400000
    4e64:	01000000 	mrseq	r0, (UNDEF: 0)
    4e68:	01610408 	cmneq	r1, r8, lsl #8
    4e6c:	78040000 	stmdavc	r4, {}	@ <UNPREDICTABLE>
    4e70:	1400000d 	strne	r0, [r0], #-13
    4e74:	0000f713 	andeq	pc, r0, r3, lsl r7	@ <UNPREDICTABLE>
    4e78:	34030500 	strcc	r0, [r3], #-1280	@ 0xfffffb00
    4e7c:	04200001 	strteq	r0, [r0], #-1
    4e80:	00000d15 	andeq	r0, r0, r5, lsl sp
    4e84:	00f72014 	rscseq	r2, r7, r4, lsl r0
    4e88:	03050000 	movweq	r0, #20480	@ 0x5000
    4e8c:	20000128 	andcs	r0, r0, r8, lsr #2
    4e90:	000d2104 	andeq	r2, sp, r4, lsl #2
    4e94:	b40f1500 	strlt	r1, [pc], #-1280	@ 4e9c <base_order+0x2178>
    4e98:	05000000 	streq	r0, [r0, #-0]
    4e9c:	00012403 	andeq	r2, r1, r3, lsl #8
    4ea0:	05961120 	ldreq	r1, [r6, #288]	@ 0x120
    4ea4:	41050000 	mrsmi	r0, (UNDEF: 5)
    4ea8:	00016907 	andeq	r6, r1, r7, lsl #18
    4eac:	00016900 	andeq	r6, r1, r0, lsl #18
    4eb0:	01690500 	cmneq	r9, r0, lsl #10
    4eb4:	7b050000 	blvc	144ebc <__ROM_SIZE__+0x104ebc>
    4eb8:	05000000 	streq	r0, [r0, #-0]
    4ebc:	00000103 	andeq	r0, r0, r3, lsl #2
    4ec0:	0a041200 	beq	1096c8 <__ROM_SIZE__+0xc96c8>
    4ec4:	00000d2f 	andeq	r0, r0, pc, lsr #26
    4ec8:	0021cc48 	eoreq	ip, r1, r8, asr #24
    4ecc:	00002c00 	andeq	r2, r0, r0, lsl #24
    4ed0:	8c9c0100 	ldfhis	f0, [ip], {0}
    4ed4:	13000001 	movwne	r0, #1
    4ed8:	48010063 	stmdami	r1, {r0, r1, r5, r6}
    4edc:	00018c17 	andeq	r8, r1, r7, lsl ip
    4ee0:	00500100 	subseq	r0, r0, r0, lsl #2
    4ee4:	e0080101 	and	r0, r8, r1, lsl #2
    4ee8:	14000000 	strne	r0, [r0], #-0
    4eec:	00000d95 	muleq	r0, r5, sp
    4ef0:	7b053401 	blvc	151efc <__ROM_SIZE__+0x111efc>
    4ef4:	8c000000 	stchi	0, cr0, [r0], {-0}
    4ef8:	40000021 	andmi	r0, r0, r1, lsr #32
    4efc:	01000000 	mrseq	r0, (UNDEF: 0)
    4f00:	0001c29c 	muleq	r1, ip, r2
    4f04:	61761500 	cmnvs	r6, r0, lsl #10
    4f08:	3d01006c 	stccc	0, cr0, [r1, #-432]	@ 0xfffffe50
    4f0c:	00007b07 	andeq	r7, r0, r7, lsl #22
    4f10:	001e9300 	andseq	r9, lr, r0, lsl #6
    4f14:	001e8f00 	andseq	r8, lr, r0, lsl #30
    4f18:	890a0000 	stmdbhi	sl, {}	@ <UNPREDICTABLE>
    4f1c:	1700000d 	strne	r0, [r0, -sp]
    4f20:	0000214c 	andeq	r2, r0, ip, asr #2
    4f24:	00000040 	andeq	r0, r0, r0, asr #32
    4f28:	02249c01 	eoreq	r9, r4, #256	@ 0x100
    4f2c:	eb060000 	bl	184f34 <__ROM_SIZE__+0x144f34>
    4f30:	1b000005 	blne	4f4c <base_order+0x2228>
    4f34:	00000224 	andeq	r0, r0, r4, lsr #4
    4f38:	00001ea4 	andeq	r1, r0, r4, lsr #29
    4f3c:	00001e9e 	muleq	r0, lr, lr
    4f40:	0006f206 	andeq	pc, r6, r6, lsl #4
    4f44:	00612a00 	rsbeq	r2, r1, r0, lsl #20
    4f48:	1ebf0000 	cdpne	0, 11, cr0, cr15, cr0, {0}
    4f4c:	1eb70000 	cdpne	0, 11, cr0, cr7, cr0, {0}
    4f50:	2a060000 	bcs	184f58 <__ROM_SIZE__+0x144f58>
    4f54:	3700000d 	strcc	r0, [r0, -sp]
    4f58:	000000b4 	strheq	r0, [r0], -r4
    4f5c:	00001edf 	ldrdeq	r1, [r0], -pc	@ <UNPREDICTABLE>
    4f60:	00001ed7 	ldrdeq	r1, [r0], -r7
    4f64:	00217616 	eoreq	r7, r1, r6, lsl r6
    4f68:	00014900 	andeq	r4, r1, r0, lsl #18
    4f6c:	51010b00 	tstpl	r1, r0, lsl #22
    4f70:	0b007502 	bleq	22380 <__RAM_SIZE__+0x1a380>
    4f74:	a3035201 	movwge	r5, #12801	@ 0x3201
    4f78:	00005101 	andeq	r5, r0, r1, lsl #2
    4f7c:	00004209 	andeq	r4, r0, r9, lsl #4
    4f80:	020a0000 	andeq	r0, sl, #0
    4f84:	00050000 	andeq	r0, r5, r0
    4f88:	195a0401 	ldmdbne	sl, {r0, sl}^
    4f8c:	0d090000 	stceq	0, cr0, [r9, #-0]
    4f90:	1d000000 	stcne	0, cr0, [r0, #-0]
    4f94:	00000dd4 	ldrdeq	r0, [r0], -r4
    4f98:	0000013a 	andeq	r0, r0, sl, lsr r1
    4f9c:	000021f8 	strdeq	r2, [r0], -r8
    4fa0:	00000060 	andeq	r0, r0, r0, rrx
    4fa4:	000037bd 			@ <UNDEFINED> instruction: 0x000037bd
    4fa8:	6905040a 	stmdbvs	r5, {r1, r3, sl}
    4fac:	0b00746e 	bleq	2216c <__RAM_SIZE__+0x1a16c>
    4fb0:	000003c6 	andeq	r0, r0, r6, asr #7
    4fb4:	3917d602 	ldmdbcc	r7, {r1, r9, sl, ip, lr, pc}
    4fb8:	02000000 	andeq	r0, r0, #0
    4fbc:	01020704 	tsteq	r2, r4, lsl #14
    4fc0:	08020000 	stmdaeq	r2, {}	@ <UNPREDICTABLE>
    4fc4:	00011605 	andeq	r1, r1, r5, lsl #12
    4fc8:	04080200 	streq	r0, [r8], #-512	@ 0xfffffe00
    4fcc:	00000161 	andeq	r0, r0, r1, ror #2
    4fd0:	00059603 	andeq	r9, r5, r3, lsl #12
    4fd4:	b7073500 	strlt	r3, [r7, -r0, lsl #10]
    4fd8:	48000000 	stmdami	r0, {}	@ <UNPREDICTABLE>
    4fdc:	10000022 	andne	r0, r0, r2, lsr #32
    4fe0:	01000000 	mrseq	r0, (UNDEF: 0)
    4fe4:	0000b79c 	muleq	r0, ip, r7
    4fe8:	0db00100 	ldfeqs	f0, [r0]
    4fec:	14350000 	ldrtne	r0, [r5], #-0
    4ff0:	000000b7 	strheq	r0, [r0], -r7
    4ff4:	00001f0b 	andeq	r1, r0, fp, lsl #30
    4ff8:	00001f07 	andeq	r1, r0, r7, lsl #30
    4ffc:	6c617607 	stclvs	6, cr7, [r1], #-28	@ 0xffffffe4
    5000:	261e3500 	ldrcs	r3, [lr], -r0, lsl #10
    5004:	01000000 	mrseq	r0, (UNDEF: 0)
    5008:	06f20851 	usateq	r0, #18, r1, asr #16
    500c:	2a350000 	bcs	d45014 <__ROM_SIZE__+0xd05014>
    5010:	0000002d 	andeq	r0, r0, sp, lsr #32
    5014:	69045201 	stmdbvs	r4, {r0, r9, ip, lr}
    5018:	002d3600 	eoreq	r3, sp, r0, lsl #12
    501c:	1f1d0000 	svcne	0x001d0000
    5020:	1f190000 	svcne	0x00190000
    5024:	c1050000 	mrsgt	r0, (UNDEF: 5)
    5028:	3700000d 	strcc	r0, [r0, -sp]
    502c:	000000b9 	strheq	r0, [r0], -r9
    5030:	00001f2d 	andeq	r1, r0, sp, lsr #30
    5034:	00001f29 	andeq	r1, r0, r9, lsr #30
    5038:	06040c00 	streq	r0, [r4], -r0, lsl #24
    503c:	000000be 	strheq	r0, [r0], -lr
    5040:	e0080102 	and	r0, r8, r2, lsl #2
    5044:	0d000000 	stceq	0, cr0, [r0, #-0]
    5048:	000000be 	strheq	r0, [r0], -lr
    504c:	00050403 	andeq	r0, r5, r3, lsl #8
    5050:	b7072b00 	strlt	r2, [r7, -r0, lsl #22]
    5054:	32000000 	andcc	r0, r0, #0
    5058:	16000022 	strne	r0, [r0], -r2, lsr #32
    505c:	01000000 	mrseq	r0, (UNDEF: 0)
    5060:	0001459c 	muleq	r1, ip, r5
    5064:	0db00100 	ldfeqs	f0, [r0]
    5068:	142b0000 	strtne	r0, [fp], #-0
    506c:	000000b7 	strheq	r0, [r0], -r7
    5070:	00001f3f 	andeq	r1, r0, pc, lsr pc
    5074:	00001f3b 	andeq	r1, r0, fp, lsr pc
    5078:	63727307 	cmnvs	r2, #469762048	@ 0x1c000000
    507c:	45262b00 	strmi	r2, [r6, #-2816]!	@ 0xfffff500
    5080:	01000001 	tsteq	r0, r1
    5084:	06f20851 	usateq	r0, #18, r1, asr #16
    5088:	322b0000 	eorcc	r0, fp, #0
    508c:	0000002d 	andeq	r0, r0, sp, lsr #32
    5090:	69045201 	stmdbvs	r4, {r0, r9, ip, lr}
    5094:	002d2c00 	eoreq	r2, sp, r0, lsl #24
    5098:	1f510000 	svcne	0x00510000
    509c:	1f4d0000 	svcne	0x004d0000
    50a0:	cb050000 	blgt	1450a8 <__ROM_SIZE__+0x1050a8>
    50a4:	2d00000d 	stccs	0, cr0, [r0, #-52]	@ 0xffffffcc
    50a8:	000000b9 	strheq	r0, [r0], -r9
    50ac:	00001f5f 	andeq	r1, r0, pc, asr pc
    50b0:	00001f5d 	andeq	r1, r0, sp, asr pc
    50b4:	000dc105 	andeq	ip, sp, r5, lsl #2
    50b8:	00b92e00 	adcseq	r2, r9, r0, lsl #28
    50bc:	1f690000 	svcne	0x00690000
    50c0:	1f650000 	svcne	0x00650000
    50c4:	06000000 	streq	r0, [r0], -r0
    50c8:	0000014a 	andeq	r0, r0, sl, asr #2
    50cc:	0db5030e 	ldceq	3, cr0, [r5, #56]!	@ 0x38
    50d0:	07230000 	streq	r0, [r3, -r0]!
    50d4:	000000b9 	strheq	r0, [r0], -r9
    50d8:	0000221e 	andeq	r2, r0, lr, lsl r2
    50dc:	00000014 	andeq	r0, r0, r4, lsl r0
    50e0:	018b9c01 	orreq	r9, fp, r1, lsl #24
    50e4:	bc010000 	stclt	0, cr0, [r1], {-0}
    50e8:	2300000d 	movwcs	r0, #13
    50ec:	0000b914 	andeq	fp, r0, r4, lsl r9
    50f0:	001f7d00 	andseq	r7, pc, r0, lsl #26
    50f4:	001f7700 	andseq	r7, pc, r0, lsl #14
    50f8:	09040100 	stmdbeq	r4, {r8}
    50fc:	26230000 	strtcs	r0, [r3], -r0
    5100:	0000018b 	andeq	r0, r0, fp, lsl #3
    5104:	00001f93 	muleq	r0, r3, pc	@ <UNPREDICTABLE>
    5108:	00001f8f 	andeq	r1, r0, pc, lsl #31
    510c:	00c50600 	sbceq	r0, r5, r0, lsl #12
    5110:	0f030000 	svceq	0x00030000
    5114:	1b000001 	blne	5120 <base_order+0x23fc>
    5118:	00002605 	andeq	r2, r0, r5, lsl #12
    511c:	00220800 	eoreq	r0, r2, r0, lsl #16
    5120:	00001600 	andeq	r1, r0, r0, lsl #12
    5124:	d09c0100 	addsle	r0, ip, r0, lsl #2
    5128:	01000001 	tsteq	r0, r1
    512c:	00000dbc 			@ <UNDEFINED> instruction: 0x00000dbc
    5130:	018b181b 	orreq	r1, fp, fp, lsl r8
    5134:	1fa20000 	svcne	0x00a20000
    5138:	1f9e0000 	svcne	0x009e0000
    513c:	04010000 	streq	r0, [r1], #-0
    5140:	1b000009 	blne	516c <base_order+0x2448>
    5144:	00018b2a 	andeq	r8, r1, sl, lsr #22
    5148:	001fb100 	andseq	fp, pc, r0, lsl #2
    514c:	001fad00 	andseq	sl, pc, r0, lsl #26
    5150:	f20f0000 	vhadd.s8	d0, d15, d0
    5154:	01000003 	tsteq	r0, r3
    5158:	002d0813 	eoreq	r0, sp, r3, lsl r8
    515c:	21f80000 	mvnscs	r0, r0
    5160:	00100000 	andseq	r0, r0, r0
    5164:	9c010000 	stcls	0, cr0, [r1], {-0}
    5168:	72747310 	rsbsvc	r7, r4, #16, 6	@ 0x40000000
    516c:	1b130100 	blne	4c5574 <__ROM_SIZE__+0x485574>
    5170:	0000018b 	andeq	r0, r0, fp, lsl #3
    5174:	00001fc0 	andeq	r1, r0, r0, asr #31
    5178:	00001fbc 			@ <UNDEFINED> instruction: 0x00001fbc
    517c:	6e656c04 	cdpvs	12, 6, cr6, cr5, cr4, {0}
    5180:	002d1400 	eoreq	r1, sp, r0, lsl #8
    5184:	1fcf0000 	svcne	0x00cf0000
    5188:	1fcb0000 	svcne	0x00cb0000
    518c:	00000000 	andeq	r0, r0, r0

Disassembly of section .debug_abbrev:

00000000 <.debug_abbrev>:
       0:	0b002401 	bleq	900c <__RAM_SIZE__+0x100c>
       4:	030b3e0b 	movweq	r3, #48651	@ 0xbe0b
       8:	0200000e 	andeq	r0, r0, #14
       c:	18020049 	stmdane	r2, {r0, r3, r6}
      10:	0000187e 	andeq	r1, r0, lr, ror r8
      14:	49000503 	stmdbmi	r0, {r0, r1, r8, sl}
      18:	04000013 	streq	r0, [r0], #-19	@ 0xffffffed
      1c:	017d0148 	cmneq	sp, r8, asr #2
      20:	1301137f 	movwne	r1, #4991	@ 0x137f
      24:	0f050000 	svceq	0x00050000
      28:	04210b00 	strteq	r0, [r1], #-2816	@ 0xfffff500
      2c:	00001349 	andeq	r1, r0, r9, asr #6
      30:	03000d06 	movweq	r0, #3334	@ 0xd06
      34:	02213a0e 	eoreq	r3, r1, #57344	@ 0xe000
      38:	0b390b3b 	bleq	e42d2c <__ROM_SIZE__+0xe02d2c>
      3c:	0b381349 	bleq	e04d68 <__ROM_SIZE__+0xdc4d68>
      40:	2e070000 	cdpcs	0, 0, cr0, cr7, cr0, {0}
      44:	03193f01 	tsteq	r9, #1, 30
      48:	3b0b3a0e 	blcc	2ce888 <__ROM_SIZE__+0x28e888>
      4c:	0521390b 	streq	r3, [r1, #-2315]!	@ 0xfffff6f5
      50:	13491927 	movtne	r1, #39207	@ 0x9927
      54:	1301193c 	movwne	r1, #6460	@ 0x193c
      58:	05080000 	streq	r0, [r8, #-0]
      5c:	3a0e0300 	bcc	380c64 <__ROM_SIZE__+0x340c64>
      60:	213b0121 	teqcs	fp, r1, lsr #2
      64:	490b3905 	stmdbmi	fp, {r0, r2, r8, fp, ip, sp}
      68:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
      6c:	00001742 	andeq	r1, r0, r2, asr #14
      70:	25011109 	strcs	r1, [r1, #-265]	@ 0xfffffef7
      74:	030b130e 	movweq	r1, #45838	@ 0xb30e
      78:	110e1b0e 	tstne	lr, lr, lsl #22
      7c:	10061201 	andne	r1, r6, r1, lsl #4
      80:	0a000017 	beq	e4 <vector_table+0xe4>
      84:	0b0b0024 	bleq	2c011c <__ROM_SIZE__+0x28011c>
      88:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
      8c:	160b0000 	strne	r0, [fp], -r0
      90:	3a080300 	bcc	200c98 <__ROM_SIZE__+0x1c0c98>
      94:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
      98:	0013490b 	andseq	r4, r3, fp, lsl #18
      9c:	01150c00 	tsteq	r5, r0, lsl #24
      a0:	13491927 	movtne	r1, #39207	@ 0x9927
      a4:	00001301 	andeq	r1, r0, r1, lsl #6
      a8:	4900260d 	stmdbmi	r0, {r0, r2, r3, r9, sl, sp}
      ac:	0e000013 	mcreq	0, 0, r0, cr0, cr3, {0}
      b0:	0b0b0113 	bleq	2c0504 <__ROM_SIZE__+0x280504>
      b4:	0b3b0b3a 	bleq	ec2da4 <__ROM_SIZE__+0xe82da4>
      b8:	13010b39 	movwne	r0, #6969	@ 0x1b39
      bc:	160f0000 	strne	r0, [pc], -r0
      c0:	3a0e0300 	bcc	380cc8 <__ROM_SIZE__+0x340cc8>
      c4:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
      c8:	0013490b 	andseq	r4, r3, fp, lsl #18
      cc:	00341000 	eorseq	r1, r4, r0
      d0:	0b3a0e03 	bleq	e838e4 <__ROM_SIZE__+0xe438e4>
      d4:	0b390b3b 	bleq	e42dc8 <__ROM_SIZE__+0xe02dc8>
      d8:	193f1349 	ldmdbne	pc!, {r0, r3, r6, r8, r9, ip}	@ <UNPREDICTABLE>
      dc:	00001802 	andeq	r1, r0, r2, lsl #16
      e0:	00001811 	andeq	r1, r0, r1, lsl r8
      e4:	012e1200 			@ <UNDEFINED> instruction: 0x012e1200
      e8:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
      ec:	0b3b0b3a 	bleq	ec2ddc <__ROM_SIZE__+0xe82ddc>
      f0:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
      f4:	01111349 	tsteq	r1, r9, asr #6
      f8:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
      fc:	0000197a 	andeq	r1, r0, sl, ror r9
     100:	03003413 	movweq	r3, #1043	@ 0x413
     104:	3b0b3a08 	blcc	2ce92c <__ROM_SIZE__+0x28e92c>
     108:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
     10c:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
     110:	00001742 	andeq	r1, r0, r2, asr #14
     114:	7d014814 	stcvc	8, cr4, [r1, #-80]	@ 0xffffffb0
     118:	00137f01 	andseq	r7, r3, r1, lsl #30
     11c:	24010000 	strcs	r0, [r1], #-0
     120:	3e0b0b00 	vmlacc.f64	d0, d11, d0
     124:	000e030b 	andeq	r0, lr, fp, lsl #6
     128:	01110200 	tsteq	r1, r0, lsl #4
     12c:	0b130e25 	bleq	4c39c8 <__ROM_SIZE__+0x4839c8>
     130:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
     134:	06120111 			@ <UNDEFINED> instruction: 0x06120111
     138:	00001710 	andeq	r1, r0, r0, lsl r7
     13c:	03001603 	movweq	r1, #1539	@ 0x603
     140:	3b0b3a0e 	blcc	2ce980 <__ROM_SIZE__+0x28e980>
     144:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
     148:	04000013 	streq	r0, [r0], #-19	@ 0xffffffed
     14c:	0b0b0024 	bleq	2c01e4 <__ROM_SIZE__+0x2801e4>
     150:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
     154:	34050000 	strcc	r0, [r5], #-0
     158:	3a0e0300 	bcc	380d60 <__ROM_SIZE__+0x340d60>
     15c:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     160:	3f13490b 	svccc	0x0013490b
     164:	00193c19 	andseq	r3, r9, r9, lsl ip
     168:	01010600 	tsteq	r1, r0, lsl #12
     16c:	13011349 	movwne	r1, #4937	@ 0x1349
     170:	21070000 	mrscs	r0, (UNDEF: 7)
     174:	2f134900 	svccs	0x00134900
     178:	0800000b 	stmdaeq	r0, {r0, r1, r3}
     17c:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     180:	0b3b0b3a 	bleq	ec2e70 <__ROM_SIZE__+0xe82e70>
     184:	13490b39 	movtne	r0, #39737	@ 0x9b39
     188:	1802193f 	stmdane	r2, {r0, r1, r2, r3, r4, r5, r8, fp, ip}
     18c:	2e090000 	cdpcs	0, 0, cr0, cr9, cr0, {0}
     190:	03193f00 	tsteq	r9, #0, 30
     194:	3b0b3a0e 	blcc	2ce9d4 <__ROM_SIZE__+0x28e9d4>
     198:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
     19c:	00193c19 	andseq	r3, r9, r9, lsl ip
     1a0:	002e0a00 	eoreq	r0, lr, r0, lsl #20
     1a4:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
     1a8:	0b3b0b3a 	bleq	ec2e98 <__ROM_SIZE__+0xe82e98>
     1ac:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
     1b0:	06120111 			@ <UNDEFINED> instruction: 0x06120111
     1b4:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
     1b8:	01000000 	mrseq	r0, (UNDEF: 0)
     1bc:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
     1c0:	0e030b13 	vmoveq.32	d3[0], r0
     1c4:	01110e1b 	tsteq	r1, fp, lsl lr
     1c8:	17100612 			@ <UNDEFINED> instruction: 0x17100612
     1cc:	2e020000 	cdpcs	0, 0, cr0, cr2, cr0, {0}
     1d0:	03193f00 	tsteq	r9, #0, 30
     1d4:	3b0b3a0e 	blcc	2cea14 <__ROM_SIZE__+0x28ea14>
     1d8:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
     1dc:	12011119 	andne	r1, r1, #1073741830	@ 0x40000006
     1e0:	7a184006 	bvc	610200 <__ROM_SIZE__+0x5d0200>
     1e4:	03000019 	movweq	r0, #25
     1e8:	193f002e 	ldmdbne	pc!, {r1, r2, r3, r5}	@ <UNPREDICTABLE>
     1ec:	0b3a0e03 	bleq	e83a00 <__ROM_SIZE__+0xe43a00>
     1f0:	0b390b3b 	bleq	e42ee4 <__ROM_SIZE__+0xe02ee4>
     1f4:	13491927 	movtne	r1, #39207	@ 0x9927
     1f8:	06120111 			@ <UNDEFINED> instruction: 0x06120111
     1fc:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
     200:	24040000 	strcs	r0, [r4], #-0
     204:	3e0b0b00 	vmlacc.f64	d0, d11, d0
     208:	0008030b 	andeq	r0, r8, fp, lsl #6
     20c:	012e0500 			@ <UNDEFINED> instruction: 0x012e0500
     210:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
     214:	0b3b0b3a 	bleq	ec2f04 <__ROM_SIZE__+0xe82f04>
     218:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
     21c:	06120111 			@ <UNDEFINED> instruction: 0x06120111
     220:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
     224:	00001301 	andeq	r1, r0, r1, lsl #6
     228:	03000506 	movweq	r0, #1286	@ 0x506
     22c:	3b0b3a08 	blcc	2cea54 <__ROM_SIZE__+0x28ea54>
     230:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
     234:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
     238:	00001742 	andeq	r1, r0, r2, asr #14
     23c:	7d014807 	stcvc	8, cr4, [r1, #-28]	@ 0xffffffe4
     240:	00137f01 	andseq	r7, r3, r1, lsl #30
     244:	00490800 	subeq	r0, r9, r0, lsl #16
     248:	187e1802 	ldmdane	lr!, {r1, fp, ip}^
     24c:	24090000 	strcs	r0, [r9], #-0
     250:	3e0b0b00 	vmlacc.f64	d0, d11, d0
     254:	000e030b 	andeq	r0, lr, fp, lsl #6
     258:	11010000 	mrsne	r0, (UNDEF: 1)
     25c:	130e2501 	movwne	r2, #58625	@ 0xe501
     260:	1b0e030b 	blne	380e94 <__ROM_SIZE__+0x340e94>
     264:	1201110e 	andne	r1, r1, #-2147483645	@ 0x80000003
     268:	00171006 	andseq	r1, r7, r6
     26c:	002e0200 	eoreq	r0, lr, r0, lsl #4
     270:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
     274:	0b3b0b3a 	bleq	ec2f64 <__ROM_SIZE__+0xe82f64>
     278:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
     27c:	06120111 			@ <UNDEFINED> instruction: 0x06120111
     280:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
     284:	2e030000 	cdpcs	0, 0, cr0, cr3, cr0, {0}
     288:	03193f00 	tsteq	r9, #0, 30
     28c:	3b0b3a0e 	blcc	2ceacc <__ROM_SIZE__+0x28eacc>
     290:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
     294:	11134919 	tstne	r3, r9, lsl r9
     298:	40061201 	andmi	r1, r6, r1, lsl #4
     29c:	00197a18 	andseq	r7, r9, r8, lsl sl
     2a0:	00240400 	eoreq	r0, r4, r0, lsl #8
     2a4:	0b3e0b0b 	bleq	f82ed8 <__ROM_SIZE__+0xf42ed8>
     2a8:	00000803 	andeq	r0, r0, r3, lsl #16
     2ac:	3f012e05 	svccc	0x00012e05
     2b0:	3a0e0319 	bcc	380f1c <__ROM_SIZE__+0x340f1c>
     2b4:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     2b8:	1119270b 	tstne	r9, fp, lsl #14
     2bc:	40061201 	andmi	r1, r6, r1, lsl #4
     2c0:	01197a18 	tsteq	r9, r8, lsl sl
     2c4:	06000013 			@ <UNDEFINED> instruction: 0x06000013
     2c8:	08030005 	stmdaeq	r3, {r0, r2}
     2cc:	0b3b0b3a 	bleq	ec2fbc <__ROM_SIZE__+0xe82fbc>
     2d0:	13490b39 	movtne	r0, #39737	@ 0x9b39
     2d4:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
     2d8:	07000017 	smladeq	r0, r7, r0, r0
     2dc:	017d0148 	cmneq	sp, r8, asr #2
     2e0:	0000137f 	andeq	r1, r0, pc, ror r3
     2e4:	02004908 	andeq	r4, r0, #8, 18	@ 0x20000
     2e8:	00187e18 	andseq	r7, r8, r8, lsl lr
     2ec:	00240900 	eoreq	r0, r4, r0, lsl #18
     2f0:	0b3e0b0b 	bleq	f82f24 <__ROM_SIZE__+0xf42f24>
     2f4:	00000e03 	andeq	r0, r0, r3, lsl #28
     2f8:	00240100 	eoreq	r0, r4, r0, lsl #2
     2fc:	0b3e0b0b 	bleq	f82f30 <__ROM_SIZE__+0xf42f30>
     300:	00000e03 	andeq	r0, r0, r3, lsl #28
     304:	49000502 	stmdbmi	r0, {r1, r8, sl}
     308:	03000013 	movweq	r0, #19
     30c:	017d0048 	cmneq	sp, r8, asr #32
     310:	0000137f 	andeq	r1, r0, pc, ror r3
     314:	3f012e04 	svccc	0x00012e04
     318:	3a0e0319 	bcc	380f84 <__ROM_SIZE__+0x340f84>
     31c:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     320:	19270621 	stmdbne	r7!, {r0, r5, r9, sl}
     324:	1301193c 	movwne	r1, #6460	@ 0x193c
     328:	0f050000 	svceq	0x00050000
     32c:	04210b00 	strteq	r0, [r1], #-2816	@ 0xfffff500
     330:	00001349 	andeq	r1, r0, r9, asr #6
     334:	3f002e06 	svccc	0x00002e06
     338:	3a0e0319 	bcc	380fa4 <__ROM_SIZE__+0x340fa4>
     33c:	29213b0b 	stmdbcs	r1!, {r0, r1, r3, r8, r9, fp, ip, sp}
     340:	27052139 	smladxcs	r5, r9, r1, r2
     344:	3c134919 			@ <UNDEFINED> instruction: 0x3c134919
     348:	07000019 	smladeq	r0, r9, r0, r0
     34c:	193f002e 	ldmdbne	pc!, {r1, r2, r3, r5}	@ <UNPREDICTABLE>
     350:	0b3a0e03 	bleq	e83b64 <__ROM_SIZE__+0xe43b64>
     354:	392f213b 	stmdbcc	pc!, {r0, r1, r3, r4, r5, r8, sp}	@ <UNPREDICTABLE>
     358:	19270621 	stmdbne	r7!, {r0, r5, r9, sl}
     35c:	0000193c 	andeq	r1, r0, ip, lsr r9
     360:	25011108 	strcs	r1, [r1, #-264]	@ 0xfffffef8
     364:	030b130e 	movweq	r1, #45838	@ 0xb30e
     368:	110e1b0e 	tstne	lr, lr, lsl #22
     36c:	10061201 	andne	r1, r6, r1, lsl #4
     370:	09000017 	stmdbeq	r0, {r0, r1, r2, r4}
     374:	0b0b0024 	bleq	2c040c <__ROM_SIZE__+0x28040c>
     378:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
     37c:	150a0000 	strne	r0, [sl, #-0]
     380:	01192701 	tsteq	r9, r1, lsl #14
     384:	0b000013 	bleq	3d8 <car_mesg+0x18>
     388:	19270015 	stmdbne	r7!, {r0, r2, r4}
     38c:	00001349 	andeq	r1, r0, r9, asr #6
     390:	3f012e0c 	svccc	0x00012e0c
     394:	3a0e0319 	bcc	381000 <__ROM_SIZE__+0x341000>
     398:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     39c:	1119270b 	tstne	r9, fp, lsl #14
     3a0:	40061201 	andmi	r1, r6, r1, lsl #4
     3a4:	01197a18 	tsteq	r9, r8, lsl sl
     3a8:	0d000013 	stceq	0, cr0, [r0, #-76]	@ 0xffffffb4
     3ac:	193f002e 	ldmdbne	pc!, {r1, r2, r3, r5}	@ <UNPREDICTABLE>
     3b0:	0b3a0e03 	bleq	e83bc4 <__ROM_SIZE__+0xe43bc4>
     3b4:	0b390b3b 	bleq	e430a8 <__ROM_SIZE__+0xe030a8>
     3b8:	06120111 			@ <UNDEFINED> instruction: 0x06120111
     3bc:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
int car_mesg(int argc, char** argv) {
     3c0:	01000000 	mrseq	r0, (UNDEF: 0)
     3c4:	0b0b0024 	bleq	2c045c <__ROM_SIZE__+0x28045c>
    printf("Received the message:");
     3c8:	0e030b3e 	vmoveq.16	d3[0], r0
    for (ctr = 1; ctr < argc; ctr++) {
     3cc:	0f020000 	svceq	0x00020000
        printf(" %s", argv[ctr]);
     3d0:	04210b00 	strteq	r0, [r1], #-2816	@ 0xfffff500
     3d4:	00001349 	andeq	r1, r0, r9, asr #6
     3d8:	49000503 	stmdbmi	r0, {r0, r1, r8, sl}
    for (ctr = 1; ctr < argc; ctr++) {
     3dc:	04000013 	streq	r0, [r0], #-19	@ 0xffffffed
    printf("\n");
     3e0:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
     3e4:	3b02213a 	blcc	888d4 <__ROM_SIZE__+0x488d4>
    if (argc > 0) {
     3e8:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
}
     3ec:	000b3813 	andeq	r3, fp, r3, lsl r8
        if (strcmp(argv[1], "PING_REPLY") == 0) {
     3f0:	012e0500 			@ <UNDEFINED> instruction: 0x012e0500
     3f4:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
            printf("Got a ping reply.\n");
     3f8:	3b03213a 	blcc	c88e8 <__ROM_SIZE__+0x888e8>
     3fc:	0521390b 	streq	r3, [r1, #-2315]!	@ 0xfffff6f5
            printf("Didn't know how to handle %s\n", argv[1]);
     400:	13491927 	movtne	r1, #39207	@ 0x9927
     404:	1301193c 	movwne	r1, #6460	@ 0x193c
     408:	18060000 	stmdane	r6, {}	@ <UNPREDICTABLE>
     40c:	07000000 	streq	r0, [r0, -r0]
     410:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
     414:	3b01213a 	blcc	48904 <__ROM_SIZE__+0x8904>
     418:	0b390521 	bleq	e418a4 <__ROM_SIZE__+0xe018a4>
     41c:	17021349 	strne	r1, [r2, -r9, asr #6]
     420:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
     424:	00490800 	subeq	r0, r9, r0, lsl #16
void uputc(char c) {
     428:	187e1802 	ldmdane	lr!, {r1, fp, ip}^
  while ((UARTFR >> 5) & 1)
     42c:	11090000 	mrsne	r0, (UNDEF: 9)
     430:	130e2501 	movwne	r2, #58625	@ 0xe501
  UART_DR = c;
     434:	1b0e030b 	blne	381068 <__ROM_SIZE__+0x341068>
  if (c == '\n')
     438:	1201110e 	andne	r1, r1, #-2147483645	@ 0x80000003
}
     43c:	00171006 	andseq	r1, r7, r6
    uputc('\r');
     440:	00240a00 	eoreq	r0, r4, r0, lsl #20
}
     444:	0b3e0b0b 	bleq	f83078 <__ROM_SIZE__+0xf43078>
     448:	00000803 	andeq	r0, r0, r3, lsl #16
  if (!((UARTFR >> 4) & 1)) return UART_DR;
     44c:	0300160b 	movweq	r1, #1547	@ 0x60b
     450:	3b0b3a08 	blcc	2cec78 <__ROM_SIZE__+0x28ec78>
     454:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
     458:	0c000013 	stceq	0, cr0, [r0], {19}
  return -1;
     45c:	19270115 	stmdbne	r7!, {r0, r2, r4, r8}
}
     460:	13011349 	movwne	r1, #4937	@ 0x1349
     464:	260d0000 	strcs	r0, [sp], -r0
  UARTCTL = 0;
     468:	00134900 	andseq	r4, r3, r0, lsl #18
     46c:	01130e00 	tsteq	r3, r0, lsl #28
  UARTIBRD = 8;
     470:	0b3a0b0b 	bleq	e830a4 <__ROM_SIZE__+0xe430a4>
  UARTFBRD = 44;
     474:	0b390b3b 	bleq	e43168 <__ROM_SIZE__+0xe03168>
  UARTCC = 0;
     478:	00001301 	andeq	r1, r0, r1, lsl #6
  UARTLCRH = 0x60;
     47c:	0300160f 	movweq	r1, #1551	@ 0x60f
  UARTCTL = 0x301;
     480:	3b0b3a0e 	blcc	2cecc0 <__ROM_SIZE__+0x28ecc0>
}
     484:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
     488:	10000013 	andne	r0, r0, r3, lsl r0
void u2putc(char c) {
     48c:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
  while ((UART2FR >> 5) & 1)
     490:	0b3b0b3a 	bleq	ec3180 <__ROM_SIZE__+0xe83180>
     494:	13490b39 	movtne	r0, #39737	@ 0x9b39
  UART2_DR = c;
     498:	1802193f 	stmdane	r2, {r0, r1, r2, r3, r4, r5, r8, fp, ip}
  if (c == '\n')
     49c:	2e110000 	cdpcs	0, 1, cr0, cr1, cr0, {0}
}
     4a0:	03193f01 	tsteq	r9, #1, 30
    u2putc('\r');
     4a4:	3b0b3a0e 	blcc	2cece4 <__ROM_SIZE__+0x28ece4>
}
     4a8:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
     4ac:	11134919 	tstne	r3, r9, lsl r9
  if (!((UART2FR >> 4) & 1)) return UART2_DR;
     4b0:	40061201 	andmi	r1, r6, r1, lsl #4
     4b4:	00197a18 	andseq	r7, r9, r8, lsl sl
     4b8:	01481200 	mrseq	r1, (UNDEF: 104)
     4bc:	137f017d 	cmnne	pc, #1073741855	@ 0x4000001f
  return -1;
     4c0:	00001301 	andeq	r1, r0, r1, lsl #6
}
     4c4:	7d014813 	stcvc	8, cr4, [r1, #-76]	@ 0xffffffb4
     4c8:	00137f01 	andseq	r7, r3, r1, lsl #30
  UART2CTL = 0;
     4cc:	49010000 	stmdbmi	r1, {}	@ <UNPREDICTABLE>
     4d0:	7e180200 	cdpvc	2, 1, cr0, cr8, cr0, {0}
  UART2IBRD = 8;
     4d4:	02000018 	andeq	r0, r0, #24
  UART2FBRD = 44;
     4d8:	13490005 	movtne	r0, #36869	@ 0x9005
  UART2CC = 0;
     4dc:	24030000 	strcs	r0, [r3], #-0
  UART2LCRH = 0x60;
     4e0:	3e0b0b00 	vmlacc.f64	d0, d11, d0
  UART2CTL = 0x301;
     4e4:	000e030b 	andeq	r0, lr, fp, lsl #6
}
     4e8:	000f0400 	andeq	r0, pc, r0, lsl #8
     4ec:	4904210b 	stmdbmi	r4, {r0, r1, r3, r8, sp}
  RCGCUART |= 3;
     4f0:	05000013 	streq	r0, [r0, #-19]	@ 0xffffffed
     4f4:	017d0148 	cmneq	sp, r8, asr #2
     4f8:	1301137f 	movwne	r1, #4991	@ 0x137f
     4fc:	0d060000 	stceq	0, cr0, [r6, #-0]
  RCGCGPIO |= 3;
     500:	3a0e0300 	bcc	381108 <__ROM_SIZE__+0x341108>
     504:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     508:	3813490b 	ldmdacc	r3, {r0, r1, r3, r8, fp, lr}
  GPIODEN = 0x03;
     50c:	0700000b 	streq	r0, [r0, -fp]
     510:	13490026 	movtne	r0, #36902	@ 0x9026
  GPIOAFSEL = 0x03;
     514:	21080000 	mrscs	r0, (UNDEF: 8)
  GPIOPCTL |= 0x00000011;
     518:	2f134900 	svccs	0x00134900
     51c:	0900000b 	stmdbeq	r0, {r0, r1, r3}
     520:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
  GPIODEN2 = 0x03;
     524:	213a0e03 	teqcs	sl, r3, lsl #28
     528:	390b3b02 	stmdbcc	fp, {r1, r8, r9, fp, ip, sp}
  GPIOAFSEL2 = 0x03;
     52c:	19270621 	stmdbne	r7!, {r0, r5, r9, sl}
  GPIOPCTL2 |= 0x00000011;
     530:	1301193c 	movwne	r1, #6460	@ 0x193c
     534:	2e0a0000 	cdpcs	0, 0, cr0, cr10, cr0, {0}
     538:	03193f01 	tsteq	r9, #1, 30
}
     53c:	3b0b3a0e 	blcc	2ced7c <__ROM_SIZE__+0x28ed7c>
     540:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
void platform_init() {
     544:	3c134919 			@ <UNDEFINED> instruction: 0x3c134919
    pin_setup();
     548:	00130119 	andseq	r0, r3, r9, lsl r1
    uart_init();
     54c:	00160b00 	andseq	r0, r6, r0, lsl #22
    uart2_init();
     550:	0b3a0e03 	bleq	e83d64 <__ROM_SIZE__+0xe43d64>
    set_read_char(ugetc);
     554:	0b390b3b 	bleq	e43248 <__ROM_SIZE__+0xe03248>
    set_read_char2(u2getc);
     558:	00001349 	andeq	r1, r0, r9, asr #6
     55c:	4901010c 	stmdbmi	r1, {r2, r3, r8}
    set_write_char(uputc);
     560:	00130113 	andseq	r0, r3, r3, lsl r1
    set_write_char2(u2putc);
     564:	00180d00 	andseq	r0, r8, r0, lsl #26
     568:	050e0000 	streq	r0, [lr, #-0]
}
     56c:	3a0e0300 	bcc	381174 <__ROM_SIZE__+0x341174>
     570:	213b0121 	teqcs	fp, r1, lsr #2
     574:	490b3903 	stmdbmi	fp, {r0, r1, r8, fp, ip, sp}
     578:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
int pair(int argc, char** argv) {
     57c:	00001742 	andeq	r1, r0, r2, asr #14
    printf("Sending a pair request.\n");
     580:	0300340f 	movweq	r3, #1039	@ 0x40f
    printf2("FOB_MESG PAIR\n");
     584:	01213a08 			@ <UNDEFINED> instruction: 0x01213a08
     588:	0b390b3b 	bleq	e4327c <__ROM_SIZE__+0xe0327c>
}
     58c:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
     590:	34100000 	ldrcc	r0, [r0], #-0
     594:	3a0e0300 	bcc	38119c <__ROM_SIZE__+0x34119c>
int aes(int argc, char** argv) {
     598:	0b3b0121 	bleq	ec0a24 <__ROM_SIZE__+0xe80a24>
    uint8_t key[16] = {0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,
     59c:	13490b39 	movtne	r0, #39737	@ 0x9b39
     5a0:	00001802 	andeq	r1, r0, r2, lsl #16
     5a4:	25011111 	strcs	r1, [r1, #-273]	@ 0xfffffeef
    uint8_t text[16] = "0123456789abcdef";
     5a8:	030b130e 	movweq	r1, #45838	@ 0xb30e
     5ac:	110e1b0e 	tstne	lr, lr, lsl #22
     5b0:	10061201 	andne	r1, r6, r1, lsl #4
    AES_init_ctx(&ctx, key);
     5b4:	12000017 	andne	r0, r0, #23
     5b8:	0b0b0024 	bleq	2c0650 <__ROM_SIZE__+0x280650>
    printf("Encrypting %s using AES\n", text);
     5bc:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
     5c0:	13130000 	tstne	r3, #0
    AES_ECB_encrypt(&ctx, text);
     5c4:	0b0e0301 	bleq	3811d0 <__ROM_SIZE__+0x3411d0>
     5c8:	3b0b3a0b 	blcc	2cedfc <__ROM_SIZE__+0x28edfc>
    printf("Encrypted is %s\n", text);
     5cc:	010b390b 	tsteq	fp, fp, lsl #18
     5d0:	14000013 	strne	r0, [r0], #-19	@ 0xffffffed
    len = encode_base64(text, 16, b64text);
     5d4:	0803000d 	stmdaeq	r3, {r0, r2, r3}
     5d8:	0b3b0b3a 	bleq	ec32c8 <__ROM_SIZE__+0xe832c8>
     5dc:	13490b39 	movtne	r0, #39737	@ 0x9b39
    b64text[len] = '\n';
     5e0:	00000b38 	andeq	r0, r0, r8, lsr fp
     5e4:	03001615 	movweq	r1, #1557	@ 0x615
     5e8:	3b0b3a08 	blcc	2cee10 <__ROM_SIZE__+0x28ee10>
    printf("Encrypted is %s\n", text);
     5ec:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
     5f0:	16000013 			@ <UNDEFINED> instruction: 0x16000013
    printf2("FOB_MESG AESB64 %s\n", b64text);
     5f4:	19270115 	stmdbne	r7!, {r0, r2, r4, r8}
     5f8:	13011349 	movwne	r1, #4937	@ 0x1349
    AES_ECB_decrypt(&ctx, text);
     5fc:	13170000 	tstne	r7, #0
     600:	3a0b0b01 	bcc	2c320c <__ROM_SIZE__+0x28320c>
    printf("Which should decrypt to %s \n", text);
     604:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     608:	0013010b 	andseq	r0, r3, fp, lsl #2
}
     60c:	00341800 	eorseq	r1, r4, r0, lsl #16
     610:	0b3a0e03 	bleq	e83e24 <__ROM_SIZE__+0xe43e24>
     614:	0b390b3b 	bleq	e43308 <__ROM_SIZE__+0xe03308>
     618:	193f1349 	ldmdbne	pc!, {r0, r3, r6, r8, r9, ip}	@ <UNPREDICTABLE>
     61c:	00001802 	andeq	r1, r0, r2, lsl #16
     620:	3f012e19 	svccc	0x00012e19
     624:	3a080319 	bcc	201290 <__ROM_SIZE__+0x1c1290>
     628:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
int encode64(int argc, char** argv) {
     62c:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
    if (argc > 1) {
     630:	12011113 	andne	r1, r1, #-1073741820	@ 0xc0000004
     634:	7a184006 	bvc	610654 <__ROM_SIZE__+0x5d0654>
        len = strlen(argv[1]);
     638:	00130119 	andseq	r0, r3, r9, lsl r1
     63c:	00341a00 	eorseq	r1, r4, r0, lsl #20
        if (len < MAX64LENGTH) {
     640:	0b3a0803 	bleq	e82654 <__ROM_SIZE__+0xe42654>
            len = encode_base64(argv[1], len, encoded);
     644:	0b390b3b 	bleq	e43338 <__ROM_SIZE__+0xe03338>
     648:	17021349 	strne	r1, [r2, -r9, asr #6]
            printf("Encoded %s as %s with %d characters\n", argv[1], encoded, len);
     64c:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
     650:	01481b00 	cmpeq	r8, r0, lsl #22
     654:	137f017d 	cmnne	pc, #1073741855	@ 0x4000001f
            printf("String exceeds max length of %d characters", MAX64LENGTH);
     658:	011c0000 	tsteq	ip, r0
     65c:	00134901 	andseq	r4, r3, r1, lsl #18
     660:	49010000 	stmdbmi	r1, {}	@ <UNPREDICTABLE>
        printf("Usage is 'encode64 string'\n");
     664:	7e180200 	cdpvc	2, 1, cr0, cr8, cr0, {0}
}
     668:	02000018 	andeq	r0, r0, #24
     66c:	0b0b0024 	bleq	2c0704 <__ROM_SIZE__+0x280704>
     670:	0e030b3e 	vmoveq.16	d3[0], r0
     674:	05030000 	streq	r0, [r3, #-0]
     678:	00134900 	andseq	r4, r3, r0, lsl #18
int decode64(int argc, char** argv) {
     67c:	01480400 	cmpeq	r8, r0, lsl #8
    if (argc > 1) {
     680:	137f017d 	cmnne	pc, #1073741855	@ 0x4000001f
     684:	00001301 	andeq	r1, r0, r1, lsl #6
        int len = strlen(argv[1]);
     688:	0b000f05 	bleq	42a4 <base_order+0x1580>
     68c:	13490421 	movtne	r0, #37921	@ 0x9421
        if (len < MAX64LENGTH-1) {
     690:	48060000 	stmdami	r6, {}	@ <UNPREDICTABLE>
                printf("encoded string is %d characters\n", len);
     694:	7f017d01 	svcvc	0x00017d01
     698:	07000013 	smladeq	r0, r3, r0, r0
                len = decode_base64(argv[1], len, plaintext);
     69c:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
     6a0:	0b3a0e03 	bleq	e83eb4 <__ROM_SIZE__+0xe43eb4>
     6a4:	0b390b3b 	bleq	e43398 <__ROM_SIZE__+0xe03398>
                printf("decoded string is %d characters\n", len);
     6a8:	13491927 	movtne	r1, #39207	@ 0x9927
     6ac:	1301193c 	movwne	r1, #6460	@ 0x193c
                printf("Adding NULL at the end of decoded string\n");
     6b0:	05080000 	streq	r0, [r8, #-0]
                plaintext[len] = '\n';
     6b4:	3a0e0300 	bcc	3812bc <__ROM_SIZE__+0x3412bc>
     6b8:	0b3b0121 	bleq	ec0b44 <__ROM_SIZE__+0xe80b44>
     6bc:	13490b39 	movtne	r0, #39737	@ 0x9b39
     6c0:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
                printf("Decoded %s as: %s\n", argv[1], plaintext);
     6c4:	09000017 	stmdbeq	r0, {r0, r1, r2, r4}
     6c8:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
     6cc:	3b02213a 	blcc	88bbc <__ROM_SIZE__+0x48bbc>
            printf("String exceeds max length of %d characters", MAX64LENGTH);
     6d0:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
     6d4:	000b3813 	andeq	r3, fp, r3, lsl r8
        printf("Usage is 'decode64 string'\n");
     6d8:	010b0a00 	tsteq	fp, r0, lsl #20
     6dc:	06120111 			@ <UNDEFINED> instruction: 0x06120111
}
     6e0:	00001301 	andeq	r1, r0, r1, lsl #6
     6e4:	0300160b 	movweq	r1, #1547	@ 0x60b
     6e8:	3b0b3a0e 	blcc	2cef28 <__ROM_SIZE__+0x28ef28>
     6ec:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
     6f0:	0c000013 	stceq	0, cr0, [r0], {19}
     6f4:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     6f8:	3b01213a 	blcc	48be8 <__ROM_SIZE__+0x8be8>
int send_ping(int argc, char** argv) {
     6fc:	0121390b 			@ <UNDEFINED> instruction: 0x0121390b
    printf("Pinging the car.\n");
     700:	193f1349 	ldmdbne	pc!, {r0, r3, r6, r8, r9, ip}	@ <UNPREDICTABLE>
    printf2("FOB_MESG PING\n");
     704:	00001802 	andeq	r1, r0, r2, lsl #16
     708:	3f012e0d 	svccc	0x00012e0d
}
     70c:	3a0e0319 	bcc	381378 <__ROM_SIZE__+0x341378>
     710:	0b3b0121 	bleq	ec0b9c <__ROM_SIZE__+0xe80b9c>
     714:	27052139 	smladxcs	r5, r9, r1, r2
void __attribute__((optimize("O0"), weak)) initial_setup(void) {
     718:	11134919 	tstne	r3, r9, lsl r9
     71c:	40061201 	andmi	r1, r6, r1, lsl #4
  char *src = &_etext, *dst = &_data;
     720:	01197a18 	tsteq	r9, r8, lsl sl
     724:	0e000013 	mcreq	0, 0, r0, cr0, cr3, {0}
  if (dst != src)
     728:	08030034 	stmdaeq	r3, {r2, r4, r5}
     72c:	3b01213a 	blcc	48c1c <__ROM_SIZE__+0x8c1c>
    while (dst < &_edata) *(dst++) = *(src++);
     730:	0d21390b 			@ <UNDEFINED> instruction: 0x0d21390b
     734:	17021349 	strne	r1, [r2, -r9, asr #6]
     738:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
     73c:	00340f00 	eorseq	r0, r4, r0, lsl #30
     740:	213a0e03 	teqcs	sl, r3, lsl #28
     744:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
  for (dst = &_bss; dst < &_ebss; dst++) *dst = 0;
     748:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
     74c:	10000018 	andne	r0, r0, r8, lsl r0
     750:	017d0048 	cmneq	sp, r8, asr #32
     754:	0000137f 	andeq	r1, r0, pc, ror r3
     758:	49002111 	stmdbmi	r0, {r0, r4, r8, sp}
     75c:	000b2f13 	andeq	r2, fp, r3, lsl pc
     760:	01111200 	tsteq	r1, r0, lsl #4
  platform_init();
     764:	0b130e25 	bleq	4c4000 <__ROM_SIZE__+0x484000>
}
     768:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
     76c:	06120111 			@ <UNDEFINED> instruction: 0x06120111
     770:	00001710 	andeq	r1, r0, r0, lsl r7
     774:	0b002413 	bleq	97c8 <__RAM_SIZE__+0x17c8>
     778:	030b3e0b 	movweq	r3, #48651	@ 0xbe0b
     77c:	14000008 	strne	r0, [r0], #-8
     780:	08030016 	stmdaeq	r3, {r1, r2, r4}
static void delete(void) {
     784:	0b3b0b3a 	bleq	ec3474 <__ROM_SIZE__+0xe83474>
  __write_char__(BACK_SPACE);
     788:	13490b39 	movtne	r0, #39737	@ 0x9b39
     78c:	15150000 	ldrne	r0, [r5, #-0]
  __write_char__(SPACE);
     790:	49192701 	ldmdbmi	r9, {r0, r8, r9, sl, sp}
  __write_char__(BACK_SPACE);
     794:	00130113 	andseq	r0, r3, r3, lsl r1
     798:	00261600 	eoreq	r1, r6, r0, lsl #12
}
     79c:	00001349 	andeq	r1, r0, r9, asr #6
static void clear_prompt(int char_count) {
     7a0:	0b011317 	bleq	45404 <__ROM_SIZE__+0x5404>
  while (char_count) {
     7a4:	3b0b3a0b 	blcc	2cefd8 <__ROM_SIZE__+0x28efd8>
    delete ();
     7a8:	010b390b 	tsteq	fp, fp, lsl #18
  while (char_count) {
     7ac:	18000013 	stmdane	r0, {r0, r1, r4}
}
     7b0:	00000018 	andeq	r0, r0, r8, lsl r0
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
     7b4:	49010119 	stmdbmi	r1, {r0, r3, r4, r8}
    auto_load[i].command(0, NULL);
     7b8:	00130113 	andseq	r0, r3, r3, lsl r1
     7bc:	01011a00 	tsteq	r1, r0, lsl #20
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
     7c0:	00001349 	andeq	r1, r0, r9, asr #6
     7c4:	00240100 	eoreq	r0, r4, r0, lsl #2
     7c8:	0b3e0b0b 	bleq	f833fc <__ROM_SIZE__+0xf433fc>
     7cc:	00000e03 	andeq	r0, r0, r3, lsl #28
     7d0:	0b000f02 	bleq	43e0 <base_order+0x16bc>
}
     7d4:	13490421 	movtne	r0, #37921	@ 0x9421
static int show_history(int argc, char **argv) {
     7d8:	05030000 	streq	r0, [r3, #-0]
  uint32_t end_index = total_num_commands-1;
     7dc:	00134900 	andseq	r4, r3, r0, lsl #18
  if (total_num_commands > NUM_HISTORY_ENTRIES) {
     7e0:	000d0400 	andeq	r0, sp, r0, lsl #8
     7e4:	213a0e03 	teqcs	sl, r3, lsl #28
    beg_index = total_num_commands - NUM_HISTORY_ENTRIES;
     7e8:	390b3b02 	stmdbcc	fp, {r1, r8, r9, fp, ip, sp}
     7ec:	3813490b 	ldmdacc	r3, {r0, r1, r3, r8, fp, lr}
  uint32_t beg_index = 0;
     7f0:	0500000b 	streq	r0, [r0, #-11]
    printf("%s\n", cmd_history[index % NUM_HISTORY_ENTRIES]);
     7f4:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
     7f8:	213a0e03 	teqcs	sl, r3, lsl #28
     7fc:	390b3b03 	stmdbcc	fp, {r0, r1, r8, r9, fp, ip, sp}
     800:	19270521 	stmdbne	r7!, {r0, r5, r8, sl}
  for (uint32_t index = beg_index; index <= end_index; ++index) {
     804:	193c1349 	ldmdbne	ip!, {r0, r3, r6, r8, r9, ip}
}
     808:	00001301 	andeq	r1, r0, r1, lsl #6
     80c:	00001806 	andeq	r1, r0, r6, lsl #16
     810:	00050700 	andeq	r0, r5, r0, lsl #14
     814:	213a0e03 	teqcs	sl, r3, lsl #28
int cmd_exec_status(int argc, char **argv) {
     818:	05213b01 	streq	r3, [r1, #-2817]!	@ 0xfffff4ff
  printf("%d\n", __cmd_exec_status);
     81c:	13490b39 	movtne	r0, #39737	@ 0x9b39
     820:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
     824:	08000017 	stmdaeq	r0, {r0, r1, r2, r4}
}
     828:	18020049 	stmdane	r2, {r0, r3, r6}
     82c:	0000187e 	andeq	r1, r0, lr, ror r8
     830:	25011109 	strcs	r1, [r1, #-265]	@ 0xfffffef7
static int build_info(int argc, char **argv) {
     834:	030b130e 	movweq	r1, #45838	@ 0xb30e
  printf("Build: [" SHELL_VERSION ":" USER_REPO_VERSION "] - [" BUILD_USER
     838:	110e1b0e 	tstne	lr, lr, lsl #22
}
     83c:	10061201 	andne	r1, r6, r1, lsl #4
     840:	0a000017 	beq	8a4 <help+0x4>
static void execute(int argc, char **argv) {
     844:	0b0b0024 	bleq	2c08dc <__ROM_SIZE__+0x2808dc>
     848:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
  for (int i = 0; table[i].command_name != NULL; i++) {
     84c:	160b0000 	strne	r0, [fp], -r0
     850:	3a080300 	bcc	201458 <__ROM_SIZE__+0x1c1458>
     854:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     858:	0013490b 	andseq	r4, r3, fp, lsl #18
     85c:	01150c00 	tsteq	r5, r0, lsl #24
    if (strcmp(argv[0], table[i].command_name) == 0) {
     860:	13491927 	movtne	r1, #39207	@ 0x9927
     864:	00001301 	andeq	r1, r0, r1, lsl #6
      __cmd_exec_status = table[i].command(argc, &argv[0]);
     868:	4900260d 	stmdbmi	r0, {r0, r2, r3, r9, sl, sp}
     86c:	0e000013 	mcreq	0, 0, r0, cr0, cr3, {0}
     870:	0b0b0113 	bleq	2c0cc4 <__ROM_SIZE__+0x280cc4>
     874:	0b3b0b3a 	bleq	ec3564 <__ROM_SIZE__+0xe83564>
     878:	13010b39 	movwne	r0, #6969	@ 0x1b39
    printf("\"%s\": command not found. Use \"help\" to list all command.\n",
     87c:	160f0000 	strne	r0, [pc], -r0
     880:	3a0e0300 	bcc	381488 <__ROM_SIZE__+0x341488>
    __cmd_exec_status = -1;
     884:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     888:	0013490b 	andseq	r4, r3, fp, lsl #18
     88c:	00341000 	eorseq	r1, r4, r0
}
     890:	0b3a0e03 	bleq	e840a4 <__ROM_SIZE__+0xe440a4>
     894:	0b390b3b 	bleq	e43588 <__ROM_SIZE__+0xe03588>
     898:	193f1349 	ldmdbne	pc!, {r0, r3, r6, r8, r9, ip}	@ <UNPREDICTABLE>
     89c:	00001802 	andeq	r1, r0, r2, lsl #16
int help(int argc, char **argv) {
     8a0:	3f012e11 	svccc	0x00012e11
  if (argc > 1 && (strcmp(argv[1], "-l")==0)) {
     8a4:	3a0e0319 	bcc	381510 <__ROM_SIZE__+0x341510>
     8a8:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     8ac:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
     8b0:	12011113 	andne	r1, r1, #-1073741820	@ 0xc0000004
    printf("use: help -l for list only.\n\n");
     8b4:	7a184006 	bvc	6108d4 <__ROM_SIZE__+0x5d08d4>
  bool verbose = true;
     8b8:	12000019 	andne	r0, r0, #25
    verbose = false;
     8bc:	017d0148 	cmneq	sp, r8, asr #2
    printf("\n");
     8c0:	1301137f 	movwne	r1, #4991	@ 0x137f
    i++;
     8c4:	48130000 	ldmdami	r3, {}	@ <UNPREDICTABLE>
  while (table[i].command_name != NULL) {
     8c8:	7f017d01 	svcvc	0x00017d01
     8cc:	00000013 	andeq	r0, r0, r3, lsl r0
     8d0:	02004901 	andeq	r4, r0, #16384	@ 0x4000
    printf(table[i].command_name);
     8d4:	00187e18 	andseq	r7, r8, r8, lsl lr
    if (verbose) {
     8d8:	01480200 	mrseq	r0, (UNDEF: 104)
      printf("\n\t");
     8dc:	137f017d 	cmnne	pc, #1073741855	@ 0x4000001f
      printf(table[i].command_help);
     8e0:	00001301 	andeq	r1, r0, r1, lsl #6
     8e4:	7d004803 	stcvc	8, cr4, [r0, #-12]
     8e8:	00137f01 	andseq	r7, r3, r1, lsl #30
    verbose = false;
     8ec:	00050400 	andeq	r0, r5, r0, lsl #8
}
     8f0:	213a0e03 	teqcs	sl, r3, lsl #28
     8f4:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
     8f8:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
     8fc:	1742b717 	smlaldne	fp, r2, r7, r7
     900:	05050000 	streq	r0, [r5, #-0]
     904:	00134900 	andseq	r4, r3, r0, lsl #18
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
     908:	01480600 	cmpeq	r8, r0, lsl #12
static void add_command_to_history(const char *cmd_str) {
     90c:	137f017d 	cmnne	pc, #1073741855	@ 0x4000001f
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
     910:	34070000 	strcc	r0, [r7], #-0
     914:	3a0e0300 	bcc	38151c <__ROM_SIZE__+0x34151c>
  int index = total_num_commands % NUM_HISTORY_ENTRIES;
     918:	0b3b0121 	bleq	ec0da4 <__ROM_SIZE__+0xe80da4>
     91c:	13490b39 	movtne	r0, #39737	@ 0x9b39
     920:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
     924:	08000017 	stmdaeq	r0, {r0, r1, r2, r4}
  memcpy(&cmd_history[index], cmd_str, LINE_BUFF_SIZE);
     928:	0b0b0024 	bleq	2c09c0 <__ROM_SIZE__+0x2809c0>
     92c:	0e030b3e 	vmoveq.16	d3[0], r0
     930:	0f090000 	svceq	0x00090000
     934:	04210b00 	strteq	r0, [r1], #-2816	@ 0xfffff500
  total_num_commands++;
     938:	00001349 	andeq	r1, r0, r9, asr #6
  curr_command_ptr = total_num_commands;
     93c:	0300340a 	movweq	r3, #1034	@ 0x40a
     940:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
     944:	0b390b3b 	bleq	e43638 <__ROM_SIZE__+0xe03638>
     948:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
     94c:	050b0000 	streq	r0, [fp, #-0]
static int parse_line(char **argv, char *line_buff, int argument_size) {
     950:	3a0e0300 	bcc	381558 <__ROM_SIZE__+0x341558>
     954:	053b0121 	ldreq	r0, [fp, #-289]!	@ 0xfffffedf
  int length = strlen(line_buff);
     958:	13490b39 	movtne	r0, #39737	@ 0x9b39
     95c:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
  int argc = 0;
     960:	0c000017 	stceq	0, cr0, [r0], {23}
         pos++)
     964:	08030034 	stmdaeq	r3, {r2, r4, r5}
    for (; line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
     968:	3b01213a 	blcc	48e58 <__ROM_SIZE__+0x8e58>
     96c:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
     970:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
     974:	00001742 	andeq	r1, r0, r2, asr #14
    if (line_buff[pos] == '\t' || line_buff[pos] == SPACE)
     978:	03012e0d 	movweq	r2, #7693	@ 0x1e0d
     97c:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
      line_buff[pos] = END_OF_LINE;
     980:	21390b3b 	teqcs	r9, fp, lsr fp
  while (pos <= length) {
     984:	1119270d 	tstne	r9, sp, lsl #14
    if (line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
     988:	40061201 	andmi	r1, r6, r1, lsl #4
     98c:	01197a18 	tsteq	r9, r8, lsl sl
     990:	0e000013 	mcreq	0, 0, r0, cr0, cr3, {0}
     994:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
      argv[argc++] = &line_buff[pos];
     998:	3b01213a 	blcc	48e88 <__ROM_SIZE__+0x8e88>
     99c:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
}
     9a0:	02193f13 	andseq	r3, r9, #19, 30	@ 0x4c
static int prefix_match(char *sub, int len, const char *str) {
     9a4:	0f000018 	svceq	0x00000018
     9a8:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
  if (sub == NULL || str == NULL || len <= 0 || len > strlen(str)) {
     9ac:	0b3a0e03 	bleq	e841c0 <__ROM_SIZE__+0xe441c0>
     9b0:	0b390b3b 	bleq	e436a4 <__ROM_SIZE__+0xe036a4>
     9b4:	13491927 	movtne	r1, #39207	@ 0x9927
     9b8:	1301193c 	movwne	r1, #6460	@ 0x193c
  for (int i = 0; i<len; ++i) {
     9bc:	34100000 	ldrcc	r0, [r0], #-0
     9c0:	3a0e0300 	bcc	3815c8 <__ROM_SIZE__+0x3415c8>
    if (sub[i] != str[i]) {
     9c4:	213b0121 	teqcs	fp, r1, lsr #2
     9c8:	0b390380 	bleq	e417d0 <__ROM_SIZE__+0xe017d0>
  for (int i = 0; i<len; ++i) {
     9cc:	193f1349 	ldmdbne	pc!, {r0, r3, r6, r8, r9, ip}	@ <UNPREDICTABLE>
}
     9d0:	0000193c 	andeq	r1, r0, ip, lsr r9
  return TRUE;
     9d4:	49002111 	stmdbmi	r0, {r0, r4, r8, sp}
      return FALSE;
     9d8:	000b2f13 	andeq	r2, fp, r3, lsl pc
}
     9dc:	012e1200 			@ <UNDEFINED> instruction: 0x012e1200
static void handle_up_arrow(char *cmd_buff, int *char_count) {
     9e0:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
     9e4:	3b01213a 	blcc	48ed4 <__ROM_SIZE__+0x8ed4>
     9e8:	05213905 	streq	r3, [r1, #-2309]!	@ 0xfffff6fb
     9ec:	13491927 	movtne	r1, #39207	@ 0x9927
     9f0:	06120111 			@ <UNDEFINED> instruction: 0x06120111
      curr_command_ptr == 0) {
     9f4:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
     9f8:	00001301 	andeq	r1, r0, r1, lsl #6
    printf("%s", cmd_buff);
     9fc:	03003413 	movweq	r3, #1043	@ 0x413
     a00:	01213a08 			@ <UNDEFINED> instruction: 0x01213a08
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
     a04:	0b39053b 	bleq	e41ef8 <__ROM_SIZE__+0xe01ef8>
     a08:	17021349 	strne	r1, [r2, -r9, asr #6]
  curr_command_ptr--;
     a0c:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
     a10:	01481400 	cmpeq	r8, r0, lsl #8
     a14:	1301017d 	movwne	r0, #4477	@ 0x117d
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
     a18:	05150000 	ldreq	r0, [r5, #-0]
     a1c:	3a0e0300 	bcc	381624 <__ROM_SIZE__+0x341624>
     a20:	0b3b0121 	bleq	ec0eac <__ROM_SIZE__+0xe80eac>
     a24:	13490b39 	movtne	r0, #39737	@ 0x9b39
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
     a28:	00001802 	andeq	r1, r0, r2, lsl #16
     a2c:	03001616 	movweq	r1, #1558	@ 0x616
     a30:	3b0b3a0e 	blcc	2cf270 <__ROM_SIZE__+0x28f270>
  *char_count = strlen(cmd_buff);
     a34:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
     a38:	17000013 	smladne	r0, r3, r0, r0
  printf("%s", cmd_buff);
     a3c:	13490035 	movtne	r0, #36917	@ 0x9035
     a40:	0d180000 	ldceq	0, cr0, [r8, #-0]
     a44:	3a0e0300 	bcc	38164c <__ROM_SIZE__+0x34164c>
     a48:	0b3b0421 	bleq	ec1ad4 <__ROM_SIZE__+0xe81ad4>
     a4c:	13490b39 	movtne	r0, #39737	@ 0x9b39
static void handle_down_arrow(char *cmd_buff, int *char_count) {
     a50:	00000b38 	andeq	r0, r0, r8, lsr fp
     a54:	49010119 	stmdbmi	r1, {r0, r3, r4, r8}
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
     a58:	00130113 	andseq	r0, r3, r3, lsl r1
     a5c:	00341a00 	eorseq	r1, r4, r0, lsl #20
  *char_count = 0;
     a60:	213a0e03 	teqcs	sl, r3, lsl #28
  if (curr_command_ptr == total_num_commands) return;
     a64:	39053b01 	stmdbcc	r5, {r0, r8, r9, fp, ip, sp}
     a68:	13490121 	movtne	r0, #37153	@ 0x9121
     a6c:	1802193f 	stmdane	r2, {r0, r1, r2, r3, r4, r5, r8, fp, ip}
  curr_command_ptr++;
     a70:	0b1b0000 	bleq	6c0a78 <__ROM_SIZE__+0x680a78>
     a74:	12011101 	andne	r1, r1, #1073741824	@ 0x40000000
     a78:	1c000006 	stcne	0, cr0, [r0], {6}
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
     a7c:	017d0148 	cmneq	sp, r8, asr #2
     a80:	0b1d0000 	bleq	740a88 <__ROM_SIZE__+0x700a88>
     a84:	12011101 	andne	r1, r1, #1073741824	@ 0x40000000
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
     a88:	00130106 	andseq	r0, r3, r6, lsl #2
     a8c:	012e1e00 			@ <UNDEFINED> instruction: 0x012e1e00
     a90:	213a0e03 	teqcs	sl, r3, lsl #28
     a94:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
  *char_count = strlen(cmd_buff);
     a98:	19270c21 	stmdbne	r7!, {r0, r5, sl, fp}
     a9c:	01111349 	tsteq	r1, r9, asr #6
  printf("%s", cmd_buff);
     aa0:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
     aa4:	1301197a 	movwne	r1, #6522	@ 0x197a
}
     aa8:	051f0000 	ldreq	r0, [pc, #-0]	@ ab0 <set_read_char>
     aac:	3a080300 	bcc	2016b4 <__ROM_SIZE__+0x1c16b4>
void set_read_char(int (*func)(void)) { __read_char__ = func; }
     ab0:	213b0121 	teqcs	fp, r1, lsr #2
     ab4:	0b390199 	bleq	e41120 <__ROM_SIZE__+0xe01120>
     ab8:	17021349 	strne	r1, [r2, -r9, asr #6]
void set_read_char2(int (*func)(void)) { __read_char2__ = func; }
     abc:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
     ac0:	012e2000 			@ <UNDEFINED> instruction: 0x012e2000
     ac4:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
void set_write_char(void (*func)(char)) { __write_char__ = func; }
     ac8:	3b01213a 	blcc	48fb8 <__ROM_SIZE__+0x8fb8>
     acc:	0621390b 	strteq	r3, [r1], -fp, lsl #18
     ad0:	01111927 	tsteq	r1, r7, lsr #18
void set_write_char2(void (*func)(char)) { __write_char2__ = func; }
     ad4:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
     ad8:	1301197a 	movwne	r1, #6522	@ 0x197a
     adc:	26210000 	strtcs	r0, [r1], -r0
}
     ae0:	00134900 	andseq	r4, r3, r0, lsl #18
}
     ae4:	00342200 	eorseq	r2, r4, r0, lsl #4
  if (cmd_buff == NULL || char_count <= 0) {
     ae8:	213a0e03 	teqcs	sl, r3, lsl #28
static void handle_tab(char *cmd_buff, int *char_count) {
     aec:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
     af0:	13491a21 	movtne	r1, #39457	@ 0x9a21
  int last_match = -1;
     af4:	193c193f 	ldmdbne	ip!, {r0, r1, r2, r3, r4, r5, r8, fp, ip}
  int match_count = 0;
     af8:	34230000 	strtcc	r0, [r3], #-0
  int i = 0;
     afc:	3a0e0300 	bcc	381704 <__ROM_SIZE__+0x341704>
    i++;
     b00:	0b3b0121 	bleq	ec0f8c <__ROM_SIZE__+0xe80f8c>
  while (table[i].command_name != NULL) { //loop over all commands
     b04:	49152139 	ldmdbmi	r5, {r0, r3, r4, r5, r8, sp}
     b08:	24000013 	strcs	r0, [r0], #-19	@ 0xffffffed
     b0c:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    if (prefix_match(cmd_buff, *char_count, table[i].command_name)) {
     b10:	3b01213a 	blcc	49000 <__ROM_SIZE__+0x9000>
     b14:	490b3905 	stmdbmi	fp, {r0, r2, r8, fp, ip, sp}
     b18:	00180213 	andseq	r0, r8, r3, lsl r2
      match_count++;
     b1c:	00342500 	eorseq	r2, r4, r0, lsl #10
      printf("\n%s", table[i].command_name);
     b20:	213a0e03 	teqcs	sl, r3, lsl #28
     b24:	39053b01 	stmdbcc	r5, {r0, r8, r9, fp, ip, sp}
      last_match = i;
     b28:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
  if (match_count == 1) {
     b2c:	1742b717 	smlaldne	fp, r2, r7, r7
     b30:	34260000 	strtcc	r0, [r6], #-0
  if (match_count) {
     b34:	3a080300 	bcc	20173c <__ROM_SIZE__+0x1c173c>
}
     b38:	213b0121 	teqcs	fp, r1, lsr #2
    memcpy(cmd_buff, table[last_match].command_name, LINE_BUFF_SIZE);
     b3c:	0b390381 	bleq	e41948 <__ROM_SIZE__+0xe01948>
     b40:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
     b44:	2e270000 	cdpcs	0, 2, cr0, cr7, cr0, {0}
     b48:	03193f00 	tsteq	r9, #0, 30
    *char_count = strlen(cmd_buff);
     b4c:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
     b50:	21390b3b 	teqcs	r9, fp, lsr fp
     b54:	1119271c 	tstne	r9, ip, lsl r7
    printf("\n");
     b58:	40061201 	andmi	r1, r6, r1, lsl #4
     b5c:	00197a18 	andseq	r7, r9, r8, lsl sl
    prepend_prompt();
     b60:	01112800 	tsteq	r1, r0, lsl #16
    printf(PROMPT);
     b64:	0b130e25 	bleq	4c4400 <__ROM_SIZE__+0x484400>
     b68:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
    printf("%s", cmd_buff);
     b6c:	06120111 			@ <UNDEFINED> instruction: 0x06120111
     b70:	00001710 	andeq	r1, r0, r0, lsl r7
     b74:	0b002429 	bleq	9c20 <__RAM_SIZE__+0x1c20>
     b78:	030b3e0b 	movweq	r3, #48651	@ 0xbe0b
     b7c:	2a000008 	bcs	ba4 <shell+0x18>
     b80:	08030016 	stmdaeq	r3, {r1, r2, r4}
     b84:	0b3b0b3a 	bleq	ec3874 <__ROM_SIZE__+0xe83874>
__attribute__((weak)) int active_prompt() { return TRUE; }
     b88:	13490b39 	movtne	r0, #39737	@ 0x9b39
static void shell(void) {
     b8c:	152b0000 	strne	r0, [fp, #-0]!
  int count = 0;
     b90:	49192701 	ldmdbmi	r9, {r0, r8, r9, sl, sp}
  for (int i = 0; i < LINE_BUFF_SIZE; i++) line_buff[i] = 0;
     b94:	00130113 	andseq	r0, r3, r3, lsl r1
     b98:	01132c00 	tsteq	r3, r0, lsl #24
     b9c:	0b3a0b0b 	bleq	e837d0 <__ROM_SIZE__+0xe437d0>
     ba0:	0b390b3b 	bleq	e43894 <__ROM_SIZE__+0xe03894>
     ba4:	00001301 	andeq	r1, r0, r1, lsl #6
  for (int i = 0; i < MAX_ARG_COUNT; i++) argv[i] = NULL;
     ba8:	2700152d 	strcs	r1, [r0, -sp, lsr #10]
     bac:	00134919 	andseq	r4, r3, r9, lsl r9
     bb0:	01152e00 	tsteq	r5, r0, lsl #28
     bb4:	13011927 	movwne	r1, #6439	@ 0x1927
     bb8:	0f2f0000 	svceq	0x002f0000
  prepend_prompt();
     bbc:	000b0b00 	andeq	r0, fp, r0, lsl #22
  printf(PROMPT);
     bc0:	00263000 	eoreq	r3, r6, r0
  int special_key = 0;
     bc4:	2e310000 	cdpcs	0, 3, cr0, cr1, cr0, {0}
        special_key = 1;
     bc8:	03193f00 	tsteq	r9, #0, 30
    if (s == -1) { s = __read_char2__();}
     bcc:	3b0b3a0e 	blcc	2cf40c <__ROM_SIZE__+0x28f40c>
     bd0:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
    if (s != -1) {
     bd4:	00193c19 	andseq	r3, r9, r9, lsl ip
     bd8:	00183200 	andseq	r3, r8, r0, lsl #4
      loop();
     bdc:	2e330000 	cdpcs	0, 3, cr0, cr3, cr0, {0}
        line_buff[count] = END_OF_LINE;
     be0:	03193f01 	tsteq	r9, #1, 30
     be4:	3b0b3a0e 	blcc	2cf424 <__ROM_SIZE__+0x28f424>
     be8:	110b3905 	tstne	fp, r5, lsl #18
     bec:	40061201 	andmi	r1, r6, r1, lsl #4
        __write_char__(NEW_LINE);
     bf0:	01197a18 	tsteq	r9, r8, lsl sl
     bf4:	34000013 	strcc	r0, [r0], #-19	@ 0xffffffed
  add_command_to_history(line_buff);
     bf8:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
  argc = parse_line(argv, line_buff, MAX_ARG_COUNT);
     bfc:	0b3a0e03 	bleq	e84410 <__ROM_SIZE__+0xe44410>
     c00:	0b39053b 	bleq	e420f4 <__ROM_SIZE__+0xe020f4>
     c04:	01111927 	tsteq	r1, r7, lsr #18
  if (argc > 0) execute(argc, argv);
     c08:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
}
     c0c:	1301197c 	movwne	r1, #6524	@ 0x197c
        if (!__echo) {
     c10:	2e350000 	cdpcs	0, 3, cr0, cr5, cr0, {0}
     c14:	3a0e0301 	bcc	381820 <__ROM_SIZE__+0x341820>
        if (count == 0) continue;
     c18:	39053b0b 	stmdbcc	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
        count--;
     c1c:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
        line_buff[count] = END_OF_LINE;
     c20:	12011113 	andne	r1, r1, #-1073741820	@ 0xc0000004
     c24:	7a184006 	bvc	610c44 <__ROM_SIZE__+0x5d0c44>
     c28:	00130119 	andseq	r0, r3, r9, lsl r1
        delete ();
     c2c:	012e3600 			@ <UNDEFINED> instruction: 0x012e3600
      if (__echo) {
     c30:	0b3a0e03 	bleq	e84444 <__ROM_SIZE__+0xe44444>
        __write_char__(c);
     c34:	0b39053b 	bleq	e42128 <__ROM_SIZE__+0xe02128>
     c38:	01111927 	tsteq	r1, r7, lsr #18
    if (!active_prompt()) {
     c3c:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
     c40:	1301197a 	movwne	r1, #6522	@ 0x197a
    s = __read_char__();
     c44:	2e370000 	cdpcs	0, 3, cr0, cr7, cr0, {0}
     c48:	3a0e0301 	bcc	381854 <__ROM_SIZE__+0x341854>
    if (s == -1) { s = __read_char2__();}
     c4c:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     c50:	1119270b 	tstne	r9, fp, lsl #14
      if (c == CARRIAGE_RETURN || c == NEW_LINE) {
     c54:	40061201 	andmi	r1, r6, r1, lsl #4
     c58:	01197c18 	tsteq	r9, r8, lsl ip
      if (c == DELETE || c == BACK_SPACE) {
     c5c:	38000013 	stmdacc	r0, {r0, r1, r4}
     c60:	1755010b 	ldrbne	r0, [r5, -fp, lsl #2]
      } else if (c == ESCAPE) {
     c64:	00001301 	andeq	r1, r0, r1, lsl #6
      } else if (c == SQUARE_BRACKET_OPEN && special_key == 1) {
     c68:	3f002e39 	svccc	0x00002e39
      } else if ((c == 'C' || c == 'D') && special_key != 0) {
     c6c:	3a0e0319 	bcc	3818d8 <__ROM_SIZE__+0x3418d8>
     c70:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     c74:	1113490b 	tstne	r3, fp, lsl #18
      } else if ((c == 'A' || c == 'B') && special_key == 2) {
     c78:	40061201 	andmi	r1, r6, r1, lsl #4
     c7c:	00197a18 	andseq	r7, r9, r8, lsl sl
      else if (c == TAB) {
     c80:	002e3a00 	eoreq	r3, lr, r0, lsl #20
        line_buff[count] = c;
     c84:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
     c88:	0b3b0b3a 	bleq	ec3978 <__ROM_SIZE__+0xe83978>
     c8c:	01110b39 	tsteq	r1, r9, lsr fp
        count++;
     c90:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
     c94:	0000197a 	andeq	r1, r0, sl, ror r9
          delete ();
     c98:	3f012e3b 	svccc	0x00012e3b
          delete ();
     c9c:	3a0e0319 	bcc	381908 <__ROM_SIZE__+0x341908>
      } else if (c == SQUARE_BRACKET_OPEN && special_key == 1) {
     ca0:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
        special_key = 2;
     ca4:	1119270b 	tstne	r9, fp, lsl #14
      } else if ((c == 'C' || c == 'D') && special_key != 0) {
     ca8:	40061201 	andmi	r1, r6, r1, lsl #4
        special_key = 0;
     cac:	00197a18 	andseq	r7, r9, r8, lsl sl
      } else if ((c == 'A' || c == 'B') && special_key == 2) {
     cb0:	48010000 	stmdami	r1, {}	@ <UNPREDICTABLE>
        if (!__echo) {
     cb4:	7f017d00 	svcvc	0x00017d00
     cb8:	02000013 	andeq	r0, r0, #19
          clear_prompt(count + 4);
     cbc:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
     cc0:	3b01213a 	blcc	491b0 <__ROM_SIZE__+0x91b0>
        if (c == 'A') {
     cc4:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
          handle_down_arrow(line_buff, &count);
     cc8:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
     ccc:	00001742 	andeq	r1, r0, r2, asr #14
        continue;
     cd0:	3f012e03 	svccc	0x00012e03
          clear_prompt(count);
     cd4:	3a0e0319 	bcc	381940 <__ROM_SIZE__+0x341940>
     cd8:	0b3b0121 	bleq	ec1164 <__ROM_SIZE__+0xe81164>
          handle_up_arrow(line_buff, &count);
     cdc:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
     ce0:	01111349 	tsteq	r1, r9, asr #6
        handle_tab(line_buff, &count);
     ce4:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
     ce8:	1301197a 	movwne	r1, #6522	@ 0x197a
        continue;
     cec:	34040000 	strcc	r0, [r4], #-0
  if (argc > 0) execute(argc, argv);
     cf0:	3a0e0300 	bcc	3818f8 <__ROM_SIZE__+0x3418f8>
}
     cf4:	0b3b0121 	bleq	ec1180 <__ROM_SIZE__+0xe81180>
     cf8:	13490b39 	movtne	r0, #39737	@ 0x9b39
     cfc:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
     d00:	05000017 	streq	r0, [r0, #-23]	@ 0xffffffe9
void prompt() {
     d04:	18020049 	stmdane	r2, {r0, r3, r6}
  initial_setup();
     d08:	0000187e 	andeq	r1, r0, lr, ror r8
  exec_auto_cmds();
     d0c:	11010b06 	tstne	r1, r6, lsl #22
  setup();
     d10:	01061201 	tsteq	r6, r1, lsl #4
    shell();
     d14:	07000013 	smladeq	r0, r3, r0, r0
int exec(char *cmd_str) {
     d18:	08030034 	stmdaeq	r3, {r2, r4, r5}
     d1c:	3b01213a 	blcc	4920c <__ROM_SIZE__+0x920c>
  argc = parse_line(argv, cmd_str, MAX_ARG_COUNT);
     d20:	1421390b 	strtne	r3, [r1], #-2315	@ 0xfffff6f5
     d24:	17021349 	strne	r1, [r2, -r9, asr #6]
  if (argc > 0) execute(argc, argv);
     d28:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
  return __cmd_exec_status;
     d2c:	01480800 	cmpeq	r8, r0, lsl #16
}
     d30:	137f017d 	cmnne	pc, #1073741855	@ 0x4000001f
     d34:	00001301 	andeq	r1, r0, r1, lsl #6
  if (argc > 0) execute(argc, argv);
     d38:	0b002409 	bleq	9d64 <__RAM_SIZE__+0x1d64>
     d3c:	030b3e0b 	movweq	r3, #48651	@ 0xbe0b
     d40:	0a00000e 	beq	d80 <binary_to_base64+0xc>
cmd get_function_addr(char *cmd_str) {
     d44:	08030005 	stmdaeq	r3, {r0, r2}
  for (int i = 0; table[i].command_name != NULL; i++) {
     d48:	3b01213a 	blcc	49238 <__ROM_SIZE__+0x9238>
     d4c:	2e21390b 	vmulcs.f16	s6, s2, s22	@ <UNPREDICTABLE>
     d50:	17021349 	strne	r1, [r2, -r9, asr #6]
     d54:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
     d58:	01110b00 	tsteq	r1, r0, lsl #22
    if (strcmp(cmd_str, table[i].command_name) == 0) {
     d5c:	0b130e25 	bleq	4c45f8 <__ROM_SIZE__+0x4845f8>
     d60:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
      return table[i].command;
     d64:	06120111 			@ <UNDEFINED> instruction: 0x06120111
     d68:	00001710 	andeq	r1, r0, r0, lsl r7
  return NULL;
     d6c:	0b000f0c 	bleq	49a4 <base_order+0x1c80>
}
     d70:	0013490b 	andseq	r4, r3, fp, lsl #18
  if(v < 26) return v + 'A';
     d74:	012e0d00 			@ <UNDEFINED> instruction: 0x012e0d00
  if(v < 52) return v + 71;
     d78:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
  if(v < 62) return v - 4;
     d7c:	0b3b0b3a 	bleq	ec3a6c <__ROM_SIZE__+0xe83a6c>
  if(v == 62) return '+';
     d80:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
  if(v == 63) return '/';
     d84:	01111349 	tsteq	r1, r9, asr #6
  return 64;
     d88:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
  if(v < 26) return v + 'A';
     d8c:	0000197a 	andeq	r1, r0, sl, ror r9
     d90:	00490100 	subeq	r0, r9, r0, lsl #2
  if(v < 52) return v + 71;
     d94:	187e1802 	ldmdane	lr!, {r1, fp, ip}^
  if(v < 62) return v - 4;
     d98:	34020000 	strcc	r0, [r2], #-0
     d9c:	3a0e0300 	bcc	3819a4 <__ROM_SIZE__+0x3419a4>
  if(v == 62) return '+';
     da0:	0b3b0121 	bleq	ec122c <__ROM_SIZE__+0xe8122c>
}
     da4:	13490b39 	movtne	r0, #39737	@ 0x9b39
  if('A' <= c && c <= 'Z') return c - 'A';
     da8:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
     dac:	03000017 	movweq	r0, #23
  if('a' <= c && c <= 'z') return c - 71;
     db0:	0b0b0024 	bleq	2c0e48 <__ROM_SIZE__+0x280e48>
     db4:	0e030b3e 	vmoveq.16	d3[0], r0
     db8:	16040000 	strne	r0, [r4], -r0
  if('0' <= c && c <= '9') return c + 4;
     dbc:	3a0e0300 	bcc	3819c4 <__ROM_SIZE__+0x3419c4>
     dc0:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
  if(c == '+') return 62;
     dc4:	0013490b 	andseq	r4, r3, fp, lsl #18
  if(c == '/') return 63;
     dc8:	000f0500 	andeq	r0, pc, r0, lsl #10
  return 255;
     dcc:	4904210b 	stmdbmi	r4, {r0, r1, r3, r8, sp}
  if('a' <= c && c <= 'z') return c - 71;
     dd0:	06000013 			@ <UNDEFINED> instruction: 0x06000013
     dd4:	08030005 	stmdaeq	r3, {r0, r2}
  if('0' <= c && c <= '9') return c + 4;
     dd8:	3b01213a 	blcc	492c8 <__ROM_SIZE__+0x92c8>
  if(c == '+') return 62;
     ddc:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
  if(c == '/') return 63;
     de0:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
  return (input_length + 2)/3*4;
     de4:	00001742 	andeq	r1, r0, r2, asr #14
     de8:	55010b07 	strpl	r0, [r1, #-2823]	@ 0xfffff4f9
     dec:	00130117 	andseq	r0, r3, r7, lsl r1
}
     df0:	01480800 	cmpeq	r8, r0, lsl #16
     df4:	137f017d 	cmnne	pc, #1073741855	@ 0x4000001f
unsigned int decode_base64_length(unsigned char input[], unsigned int input_length) {
     df8:	48090000 	stmdami	r9, {}	@ <UNPREDICTABLE>
     dfc:	00017d01 	andeq	r7, r1, r1, lsl #26
  while(base64_to_binary(input[0]) < 64 && (unsigned int) (input - start) < input_length) {
     e00:	00280a00 	eoreq	r0, r8, r0, lsl #20
     e04:	0b1c0e03 	bleq	704618 <__ROM_SIZE__+0x6c4618>
     e08:	010b0000 	mrseq	r0, (UNDEF: 11)
     e0c:	01134901 	tsteq	r3, r1, lsl #18
     e10:	0c000013 	stceq	0, cr0, [r0], {19}
  input_length = input - start;
     e14:	13490021 	movtne	r0, #36897	@ 0x9021
  return input_length/4*3 + (input_length % 4 ? input_length % 4 - 1 : 0);
     e18:	00000b2f 	andeq	r0, r0, pc, lsr #22
     e1c:	0300340d 	movweq	r3, #1037	@ 0x40d
     e20:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
}
     e24:	0b390b3b 	bleq	e43b18 <__ROM_SIZE__+0xe03b18>
  return input_length/4*3 + (input_length % 4 ? input_length % 4 - 1 : 0);
     e28:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
unsigned int encode_base64(unsigned char input[], unsigned int input_length, unsigned char output[]) {
     e2c:	050e0000 	streq	r0, [lr, #-0]
     e30:	3a0e0300 	bcc	381a38 <__ROM_SIZE__+0x341a38>
     e34:	213b0121 	teqcs	fp, r1, lsr #2
  unsigned int full_sets = input_length/3;
     e38:	490b3932 	stmdbmi	fp, {r1, r4, r5, r8, fp, ip, sp}
     e3c:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
  for(unsigned int i = 0; i < full_sets; ++i) {
     e40:	00001742 	andeq	r1, r0, r2, asr #14
    output[0] = binary_to_base64(                         input[0] >> 2);
     e44:	7d01480f 	stcvc	8, cr4, [r1, #-60]	@ 0xffffffc4
     e48:	00130101 	andseq	r0, r3, r1, lsl #2
    output[1] = binary_to_base64((input[0] & 0x03) << 4 | input[1] >> 4);
     e4c:	01111000 	tsteq	r1, r0
     e50:	0b130e25 	bleq	4c46ec <__ROM_SIZE__+0x4846ec>
     e54:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
     e58:	06120111 			@ <UNDEFINED> instruction: 0x06120111
     e5c:	00001710 	andeq	r1, r0, r0, lsl r7
    output[2] = binary_to_base64((input[1] & 0x0F) << 2 | input[2] >> 6);
     e60:	03011311 	movweq	r1, #4881	@ 0x1311
     e64:	3a0b0b0e 	bcc	2c3aa4 <__ROM_SIZE__+0x283aa4>
     e68:	010b3b0b 	tsteq	fp, fp, lsl #22
     e6c:	12000013 	andne	r0, r0, #19
     e70:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
    output[3] = binary_to_base64( input[2] & 0x3F);
     e74:	0b381349 	bleq	e05ba0 <__ROM_SIZE__+0xdc5ba0>
     e78:	00001934 	andeq	r1, r0, r4, lsr r9
     e7c:	0b000f13 	bleq	4ad0 <base_order+0x1dac>
    input += 3;
     e80:	1400000b 	strne	r0, [r0], #-11
  for(unsigned int i = 0; i < full_sets; ++i) {
     e84:	0b0b0024 	bleq	2c0f1c <__ROM_SIZE__+0x280f1c>
     e88:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
  switch(input_length % 3) {
     e8c:	15150000 	ldrne	r0, [r5, #-0]
     e90:	01192701 	tsteq	r9, r1, lsl #14
     e94:	16000013 			@ <UNDEFINED> instruction: 0x16000013
     e98:	13490005 	movtne	r0, #36869	@ 0x9005
     e9c:	26170000 	ldrcs	r0, [r7], -r0
     ea0:	00134900 	andseq	r4, r3, r0, lsl #18
     ea4:	00341800 	eorseq	r1, r4, r0, lsl #16
  return encode_base64_length(input_length);
     ea8:	0b3a0e03 	bleq	e846bc <__ROM_SIZE__+0xe446bc>
}
     eac:	0b390b3b 	bleq	e43ba0 <__ROM_SIZE__+0xe03ba0>
      output[0] = '\0';
     eb0:	193f1349 	ldmdbne	pc!, {r0, r3, r6, r8, r9, ip}	@ <UNPREDICTABLE>
      output[0] = binary_to_base64(                         input[0] >> 2);
     eb4:	0000193c 	andeq	r1, r0, ip, lsr r9
     eb8:	3e010419 	cfmvdlrcc	mvd1, r0
     ebc:	490b0b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp}
      output[1] = binary_to_base64((input[0] & 0x03) << 4);
     ec0:	3b0b3a13 	blcc	2cf714 <__ROM_SIZE__+0x28f714>
     ec4:	010b390b 	tsteq	fp, fp, lsl #18
     ec8:	1a000013 	bne	f1c <decode_base64+0x8>
      output[2] = '=';
     ecc:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
      output[3] = '=';
     ed0:	0b3a0e03 	bleq	e846e4 <__ROM_SIZE__+0xe446e4>
      output[4] = '\0';
     ed4:	0b390b3b 	bleq	e43bc8 <__ROM_SIZE__+0xe03bc8>
      output[0] = binary_to_base64(                         input[0] >> 2);
     ed8:	13491927 	movtne	r1, #39207	@ 0x9927
     edc:	06120111 			@ <UNDEFINED> instruction: 0x06120111
     ee0:	197c1840 	ldmdbne	ip!, {r6, fp, ip}^
      output[1] = binary_to_base64((input[0] & 0x03) << 4 | input[1] >> 4);
     ee4:	00001301 	andeq	r1, r0, r1, lsl #6
     ee8:	0000181b 	andeq	r1, r0, fp, lsl r8
     eec:	00481c00 	subeq	r1, r8, r0, lsl #24
     ef0:	137f017d 	cmnne	pc, #1073741855	@ 0x4000001f
     ef4:	2e1d0000 	cdpcs	0, 1, cr0, cr13, cr0, {0}
      output[2] = binary_to_base64((input[1] & 0x0F) << 2);
     ef8:	3a0e0301 	bcc	381b04 <__ROM_SIZE__+0x341b04>
     efc:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     f00:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
      output[3] = '=';
     f04:	12011113 	andne	r1, r1, #-1073741820	@ 0xc0000004
      output[4] = '\0';
     f08:	7a184006 	bvc	610f28 <__ROM_SIZE__+0x5d0f28>
      break;
     f0c:	00130119 	andseq	r0, r3, r9, lsl r1
     f10:	00341e00 	eorseq	r1, r4, r0, lsl #28
unsigned int decode_base64(unsigned char input[], unsigned int input_length, unsigned char output[]) {
     f14:	0b3a0803 	bleq	e82f28 <__ROM_SIZE__+0xe42f28>
     f18:	0b390b3b 	bleq	e43c0c <__ROM_SIZE__+0xe03c0c>
  unsigned int output_length = decode_base64_length(input, input_length);
     f1c:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
     f20:	0b1f0000 	bleq	7c0f28 <__ROM_SIZE__+0x780f28>
  for(unsigned int i = 2; i < output_length; i += 3) {
     f24:	12011101 	andne	r1, r1, #1073741824	@ 0x40000000
    output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
     f28:	00130106 	andseq	r0, r3, r6, lsl #2
     f2c:	010b2000 	mrseq	r2, (UNDEF: 11)
     f30:	00001755 	andeq	r1, r0, r5, asr r7
     f34:	03003421 	movweq	r3, #1057	@ 0x421
     f38:	3b0b3a08 	blcc	2cf760 <__ROM_SIZE__+0x28f760>
    output[1] = base64_to_binary(input[1]) << 4 | base64_to_binary(input[2]) >> 2;
     f3c:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
     f40:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
     f44:	00001742 	andeq	r1, r0, r2, asr #14
     f48:	03012e22 	movweq	r2, #7714	@ 0x1e22
     f4c:	3b0b3a0e 	blcc	2cf78c <__ROM_SIZE__+0x28f78c>
    output[2] = base64_to_binary(input[2]) << 6 | base64_to_binary(input[3]);
     f50:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
     f54:	12011119 	andne	r1, r1, #1073741830	@ 0x40000006
     f58:	7c184006 	ldcvc	0, cr4, [r8], {6}
     f5c:	00000019 	andeq	r0, r0, r9, lsl r0
    input += 4;
     f60:	02004901 	andeq	r4, r0, #16384	@ 0x4000
  for(unsigned int i = 2; i < output_length; i += 3) {
     f64:	00187e18 	andseq	r7, r8, r8, lsl lr
     f68:	00340200 	eorseq	r0, r4, r0, lsl #4
  switch(output_length % 3) {
     f6c:	213a0e03 	teqcs	sl, r3, lsl #28
     f70:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
     f74:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
     f78:	1742b717 	smlaldne	fp, r2, r7, r7
     f7c:	24030000 	strcs	r0, [r3], #-0
     f80:	3e0b0b00 	vmlacc.f64	d0, d11, d0
     f84:	000e030b 	andeq	r0, lr, fp, lsl #6
     f88:	00160400 	andseq	r0, r6, r0, lsl #8
      output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
     f8c:	0b3a0e03 	bleq	e847a0 <__ROM_SIZE__+0xe447a0>
     f90:	0b390b3b 	bleq	e43c84 <__ROM_SIZE__+0xe03c84>
     f94:	00001349 	andeq	r1, r0, r9, asr #6
     f98:	0b000f05 	bleq	4bb4 <base_order+0x1e90>
     f9c:	13490421 	movtne	r0, #37921	@ 0x9421
      output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
     fa0:	05060000 	streq	r0, [r6, #-0]
     fa4:	3a080300 	bcc	201bac <__ROM_SIZE__+0x1c1bac>
     fa8:	0b3b0121 	bleq	ec1434 <__ROM_SIZE__+0xe81434>
     fac:	13490b39 	movtne	r0, #39737	@ 0x9b39
     fb0:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
      output[1] = base64_to_binary(input[1]) << 4 | base64_to_binary(input[2]) >> 2;
     fb4:	07000017 	smladeq	r0, r7, r0, r0
     fb8:	1755010b 	ldrbne	r0, [r5, -fp, lsl #2]
     fbc:	00001301 	andeq	r1, r0, r1, lsl #6
     fc0:	7d014808 	stcvc	8, cr4, [r1, #-32]	@ 0xffffffe0
     fc4:	00137f01 	andseq	r7, r3, r1, lsl #30
  return output_length;
     fc8:	01480900 	cmpeq	r8, r0, lsl #18
     fcc:	0000017d 	andeq	r0, r0, sp, ror r1
static void outstr(const char *str) {
     fd0:	0300280a 	movweq	r2, #2058	@ 0x80a
  while (*str != '\0') {
     fd4:	000b1c0e 	andeq	r1, fp, lr, lsl #24
    __write_char__(*str);
     fd8:	01010b00 	tsteq	r1, r0, lsl #22
    str++;
     fdc:	13011349 	movwne	r1, #4937	@ 0x1349
  while (*str != '\0') {
     fe0:	210c0000 	mrscs	r0, (UNDEF: 12)
}
     fe4:	2f134900 	svccs	0x00134900
     fe8:	0d00000b 	stceq	0, cr0, [r0, #-44]	@ 0xffffffd4
static bool printf_numbers(const char fmt, va_list *args, int l_count) {
     fec:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     ff0:	3b01213a 	blcc	494e0 <__ROM_SIZE__+0x94e0>
  switch (fmt) {
     ff4:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
     ff8:	00180213 	andseq	r0, r8, r3, lsl r2
     ffc:	00050e00 	andeq	r0, r5, r0, lsl #28
      if (l_count == 0) {
    1000:	213a0e03 	teqcs	sl, r3, lsl #28
    1004:	30213b01 	eorcc	r3, r1, r1, lsl #22
        value = va_arg(*args, unsigned int);
    1008:	13490b39 	movtne	r0, #39737	@ 0x9b39
    100c:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
      if (fmt == 'u') {
    1010:	0f000017 	svceq	0x00000017
        if (value == 0) {
    1014:	017d0148 	cmneq	sp, r8, asr #2
          __write_char__(hextable[0]);
    1018:	00001301 	andeq	r1, r0, r1, lsl #6
    101c:	25011110 	strcs	r1, [r1, #-272]	@ 0xfffffef0
  return true;
    1020:	030b130e 	movweq	r1, #45838	@ 0xb30e
  switch (fmt) {
    1024:	110e1b0e 	tstne	lr, lr, lsl #22
      outstr("\nprintf-error\n");
    1028:	10061201 	andne	r1, r6, r1, lsl #4
      return false;
    102c:	11000017 	tstne	r0, r7, lsl r0
}
    1030:	0e030113 	mcreq	1, 0, r0, cr3, cr3, {0}
      if (l_count == 0) {
    1034:	0b3a0b0b 	bleq	e83c68 <__ROM_SIZE__+0xe43c68>
        value = va_arg(*args, int);
    1038:	13010b3b 	movwne	r0, #6971	@ 0x1b3b
    103c:	0d120000 	ldceq	0, cr0, [r2, #-0]
      if (value < 0) {
    1040:	490e0300 	stmdbmi	lr, {r8, r9}
        num[num_len++] = hextable[value % 10];
    1044:	340b3813 	strcc	r3, [fp], #-2067	@ 0xfffff7ed
    1048:	13000019 	movwne	r0, #25
    104c:	0b0b000f 	bleq	2c1090 <__ROM_SIZE__+0x281090>
    1050:	24140000 	ldrcs	r0, [r4], #-0
    1054:	3e0b0b00 	vmlacc.f64	d0, d11, d0
    1058:	0008030b 	andeq	r0, r8, fp, lsl #6
    105c:	01151500 	tsteq	r5, r0, lsl #10
    1060:	13011927 	movwne	r1, #6439	@ 0x1927
    1064:	05160000 	ldreq	r0, [r6, #-0]
        value = value / 10;
    1068:	00134900 	andseq	r4, r3, r0, lsl #18
      } while (value > 0);
    106c:	00261700 	eoreq	r1, r6, r0, lsl #14
    1070:	00001349 	andeq	r1, r0, r9, asr #6
        __write_char__('-');
    1074:	03003418 	movweq	r3, #1048	@ 0x418
    1078:	3b0b3a0e 	blcc	2cf8b8 <__ROM_SIZE__+0x28f8b8>
        value = -value;
    107c:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
        __write_char__(num[--num_len]);
    1080:	3c193f13 	ldccc	15, cr3, [r9], {19}
    1084:	19000019 	stmdbne	r0, {r0, r3, r4}
    1088:	0b3e0104 	bleq	f814a0 <__ROM_SIZE__+0xf414a0>
    108c:	13490b0b 	movtne	r0, #39691	@ 0x9b0b
    1090:	0b3b0b3a 	bleq	ec3d80 <__ROM_SIZE__+0xe83d80>
      while (num_len > 0) {
    1094:	13010b39 	movwne	r0, #6969	@ 0x1b39
  return true;
    1098:	2e1a0000 	cdpcs	0, 1, cr0, cr10, cr0, {0}
          num[num_len++] = hextable[value % 10];
    109c:	03193f01 	tsteq	r9, #1, 30
    10a0:	3b0b3a0e 	blcc	2cf8e0 <__ROM_SIZE__+0x28f8e0>
    10a4:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
    10a8:	11134919 	tstne	r3, r9, lsl r9
    10ac:	40061201 	andmi	r1, r6, r1, lsl #4
    10b0:	01197c18 	tsteq	r9, r8, lsl ip
    10b4:	1b000013 	blne	1108 <printf_numbers+0x11c>
    10b8:	00000018 	andeq	r0, r0, r8, lsl r0
          value = value / 10;
    10bc:	7d00481c 	stcvc	8, cr4, [r0, #-112]	@ 0xffffff90
        } while (value > 0);
    10c0:	00137f01 	andseq	r7, r3, r1, lsl #30
        while (num_len > 0) {
    10c4:	012e1d00 			@ <UNDEFINED> instruction: 0x012e1d00
          __write_char__(num[--num_len]);
    10c8:	0b3a0e03 	bleq	e848dc <__ROM_SIZE__+0xe448dc>
    10cc:	0b390b3b 	bleq	e43dc0 <__ROM_SIZE__+0xe03dc0>
    10d0:	13491927 	movtne	r1, #39207	@ 0x9927
    10d4:	06120111 			@ <UNDEFINED> instruction: 0x06120111
    10d8:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
    10dc:	00001301 	andeq	r1, r0, r1, lsl #6
  return true;
    10e0:	0300341e 	movweq	r3, #1054	@ 0x41e
              __write_char__(hextable[val]);
    10e4:	3b0b3a08 	blcc	2cf90c <__ROM_SIZE__+0x28f90c>
    10e8:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
              leading_zero_ignored = true;
    10ec:	00180213 	andseq	r0, r8, r3, lsl r2
          while (start_bit >= 0) {
    10f0:	010b1f00 	tsteq	fp, r0, lsl #30
            int val = (value >> start_bit) & 0xF;
    10f4:	06120111 			@ <UNDEFINED> instruction: 0x06120111
            if (val || leading_zero_ignored) {
    10f8:	00001301 	andeq	r1, r0, r1, lsl #6
    10fc:	55010b20 	strpl	r0, [r1, #-2848]	@ 0xfffff4e0
    1100:	21000017 	tstcs	r0, r7, lsl r0
          bool leading_zero_ignored = false;
    1104:	08030034 	stmdaeq	r3, {r2, r4, r5}
          int start_bit = LAST_NIBBLE_FIRST_BIT;
    1108:	0b3b0b3a 	bleq	ec3df8 <__ROM_SIZE__+0xe83df8>
  return true;
    110c:	13490b39 	movtne	r0, #39737	@ 0x9b39
        return false;
    1110:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
        return false;
    1114:	22000017 	andcs	r0, r0, #23
    1118:	0e03012e 	adfeqsp	f0, f3, #0.5
    111c:	0b3b0b3a 	bleq	ec3e0c <__ROM_SIZE__+0xe83e0c>
    1120:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
    1124:	06120111 			@ <UNDEFINED> instruction: 0x06120111
    1128:	197c1840 	ldmdbne	ip!, {r6, fp, ip}^
int printf(const char *fmt, ...) {
    112c:	01000000 	mrseq	r0, (UNDEF: 0)
    1130:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    1134:	3b01213a 	blcc	49624 <__ROM_SIZE__+0x9624>
  va_start(args, fmt);
    1138:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
  while (*fmt) {
    113c:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
        if (*fmt == '%') {
    1140:	00001742 	andeq	r1, r0, r2, asr #14
        __write_char__(*fmt);
    1144:	02004902 	andeq	r4, r0, #32768	@ 0x8000
        fmt++;
    1148:	00187e18 	andseq	r7, r8, r8, lsl lr
  while (*fmt) {
    114c:	00240300 	eoreq	r0, r4, r0, lsl #6
    switch (state) {
    1150:	0b3e0b0b 	bleq	f83d84 <__ROM_SIZE__+0xf43d84>
    1154:	00000e03 	andeq	r0, r0, r3, lsl #28
          fmt++;
    1158:	03000504 	movweq	r0, #1284	@ 0x504
          continue;
    115c:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
        while (*fmt && ((*fmt >= '0' && *fmt <= '9') || *fmt == '-')) {
    1160:	0b390b3b 	bleq	e43e54 <__ROM_SIZE__+0xe03e54>
    1164:	17021349 	strne	r1, [r2, -r9, asr #6]
    1168:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
    116c:	00480500 	subeq	r0, r8, r0, lsl #10
    1170:	137f017d 	cmnne	pc, #1073741855	@ 0x4000001f
        switch (*fmt) {
    1174:	48060000 	stmdami	r6, {}	@ <UNPREDICTABLE>
    1178:	7f017d01 	svcvc	0x00017d01
    117c:	07000013 	smladeq	r0, r3, r0, r0
    1180:	13490005 	movtne	r0, #36869	@ 0x9005
            __write_char__(*fmt);
    1184:	34080000 	strcc	r0, [r8], #-0
    1188:	3a0e0300 	bcc	381d90 <__ROM_SIZE__+0x341d90>
            state = CHECK_CH;
    118c:	0b3b0121 	bleq	ec1618 <__ROM_SIZE__+0xe81618>
            break;
    1190:	49012139 	stmdbmi	r1, {r0, r3, r4, r5, r8, sp}
    1194:	02193f13 	andseq	r3, r9, #19, 30	@ 0x4c
            outstr(va_arg(args, const char *));
    1198:	09000018 	stmdbeq	r0, {r3, r4}
    119c:	017d0148 	cmneq	sp, r8, asr #2
    11a0:	1301137f 	movwne	r1, #4991	@ 0x137f
            fmt++;
    11a4:	0f0a0000 	svceq	0x000a0000
            break;
    11a8:	04210b00 	strteq	r0, [r1], #-2816	@ 0xfffff500
            __write_char__(va_arg(args, int));
    11ac:	00001349 	andeq	r1, r0, r9, asr #6
    11b0:	0300160b 	movweq	r1, #1547	@ 0x60b
    11b4:	3b0b3a0e 	blcc	2cf9f4 <__ROM_SIZE__+0x28f9f4>
            fmt++;
    11b8:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
            break;
    11bc:	0c000013 	stceq	0, cr0, [r0], {19}
            if (*fmt == 'l') {
    11c0:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
    11c4:	3b03213a 	blcc	c96b4 <__ROM_SIZE__+0x896b4>
            if (printf_numbers(*fmt, &args, l_count)) {
    11c8:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
    11cc:	000b3813 	andeq	r3, fp, r3, lsl r8
    11d0:	012e0d00 			@ <UNDEFINED> instruction: 0x012e0d00
              state = CHECK_CH;
    11d4:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
              fmt++;
    11d8:	0b3b0b3a 	bleq	ec3ec8 <__ROM_SIZE__+0xe83ec8>
              l_count++;
    11dc:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
            if (printf_numbers(*fmt, &args, 0)) {
    11e0:	193c1349 	ldmdbne	ip!, {r0, r3, r6, r8, r9, ip}
    11e4:	00001301 	andeq	r1, r0, r1, lsl #6
              fmt++;
    11e8:	3f012e0e 	svccc	0x00012e0e
              break;
    11ec:	3a0e0319 	bcc	381e58 <__ROM_SIZE__+0x341e58>
            return -1;
    11f0:	0b3b0121 	bleq	ec167c <__ROM_SIZE__+0xe8167c>
}
    11f4:	27052139 	smladxcs	r5, r9, r1, r2
    11f8:	11134919 	tstne	r3, r9, lsl r9
            return -1;
    11fc:	40061201 	andmi	r1, r6, r1, lsl #4
    1200:	01197a18 	tsteq	r9, r8, lsl sl
    1204:	0f000013 	svceq	0x00000013
static void outstr2(const char *str) {
    1208:	0e03000a 	cdpeq	0, 0, cr0, cr3, cr10, {0}
  while (*str != '\0') {
    120c:	3b01213a 	blcc	496fc <__ROM_SIZE__+0x96fc>
    __write_char2__(*str);
    1210:	0121390b 			@ <UNDEFINED> instruction: 0x0121390b
    str++;
    1214:	00000111 	andeq	r0, r0, r1, lsl r1
  while (*str != '\0') {
    1218:	25011110 	strcs	r1, [r1, #-272]	@ 0xfffffef0
}
    121c:	030b130e 	movweq	r1, #45838	@ 0xb30e
    1220:	110e1b0e 	tstne	lr, lr, lsl #22
static bool printf2_numbers(const char fmt, va_list *args, int l_count) {
    1224:	10061201 	andne	r1, r6, r1, lsl #4
    1228:	11000017 	tstne	r0, r7, lsl r0
  switch (fmt) {
    122c:	0b0b0024 	bleq	2c12c4 <__ROM_SIZE__+0x2812c4>
    1230:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
    1234:	16120000 	ldrne	r0, [r2], -r0
      if (l_count == 0) {
    1238:	3a080300 	bcc	201e40 <__ROM_SIZE__+0x1c1e40>
    123c:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
        value = va_arg(*args, unsigned int);
    1240:	0013490b 	andseq	r4, r3, fp, lsl #18
    1244:	01151300 	tsteq	r5, r0, lsl #6
      if (fmt == 'u') {
    1248:	13491927 	movtne	r1, #39207	@ 0x9927
        if (value == 0) {
    124c:	00001301 	andeq	r1, r0, r1, lsl #6
          __write_char2__(hextable2[0]);
    1250:	49002614 	stmdbmi	r0, {r2, r4, r9, sl, sp}
    1254:	15000013 	strne	r0, [r0, #-19]	@ 0xffffffed
  return true;
    1258:	0b0b0113 	bleq	2c16ac <__ROM_SIZE__+0x2816ac>
  switch (fmt) {
    125c:	0b3b0b3a 	bleq	ec3f4c <__ROM_SIZE__+0xe83f4c>
      outstr2("\nprintf2-error\n");
    1260:	13010b39 	movwne	r0, #6969	@ 0x1b39
      return false;
    1264:	18160000 	ldmdane	r6, {}	@ <UNPREDICTABLE>
}
    1268:	17000000 	strne	r0, [r0, -r0]
      if (l_count == 0) {
    126c:	1755010b 	ldrbne	r0, [r5, -fp, lsl #2]
        value = va_arg(*args, int);
    1270:	00001301 	andeq	r1, r0, r1, lsl #6
    1274:	03003418 	movweq	r3, #1048	@ 0x418
      if (value < 0) {
    1278:	3b0b3a08 	blcc	2cfaa0 <__ROM_SIZE__+0x28faa0>
        num[num_len++] = hextable2[value % 10];
    127c:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
    1280:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
    1284:	00001742 	andeq	r1, r0, r2, asr #14
    1288:	3f012e19 	svccc	0x00012e19
    128c:	3a080319 	bcc	201ef8 <__ROM_SIZE__+0x1c1ef8>
    1290:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    1294:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
    1298:	12011113 	andne	r1, r1, #-1073741820	@ 0xc0000004
    129c:	7a184006 	bvc	6112bc <__ROM_SIZE__+0x5d12bc>
        value = value / 10;
    12a0:	00130119 	andseq	r0, r3, r9, lsl r1
      } while (value > 0);
    12a4:	012e1a00 			@ <UNDEFINED> instruction: 0x012e1a00
    12a8:	0803193f 	stmdaeq	r3, {r0, r1, r2, r3, r4, r5, r8, fp, ip}
        __write_char2__('-');
    12ac:	0b3b0b3a 	bleq	ec3f9c <__ROM_SIZE__+0xe83f9c>
    12b0:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
        value = -value;
    12b4:	01111349 	tsteq	r1, r9, asr #6
        __write_char2__(num[--num_len]);
    12b8:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
    12bc:	0000197a 	andeq	r1, r0, sl, ror r9
    12c0:	00490100 	subeq	r0, r9, r0, lsl #2
    12c4:	187e1802 	ldmdane	lr!, {r1, fp, ip}^
    12c8:	48020000 	stmdami	r2, {}	@ <UNPREDICTABLE>
      while (num_len > 0) {
    12cc:	7f017d01 	svcvc	0x00017d01
  return true;
    12d0:	00130113 	andseq	r0, r3, r3, lsl r1
          num[num_len++] = hextable2[value % 10];
    12d4:	00340300 	eorseq	r0, r4, r0, lsl #6
    12d8:	213a0803 	teqcs	sl, r3, lsl #16
    12dc:	39053b01 	stmdbcc	r5, {r0, r8, r9, fp, ip, sp}
    12e0:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
    12e4:	1742b717 	smlaldne	fp, r2, r7, r7
    12e8:	48040000 	stmdami	r4, {}	@ <UNPREDICTABLE>
    12ec:	7f017d01 	svcvc	0x00017d01
    12f0:	05000013 	streq	r0, [r0, #-19]	@ 0xffffffed
          value = value / 10;
    12f4:	08030005 	stmdaeq	r3, {r0, r2}
        } while (value > 0);
    12f8:	3b01213a 	blcc	497e8 <__ROM_SIZE__+0x97e8>
        while (num_len > 0) {
    12fc:	490b3905 	stmdbmi	fp, {r0, r2, r8, fp, ip, sp}
          __write_char2__(num[--num_len]);
    1300:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
    1304:	00001742 	andeq	r1, r0, r2, asr #14
    1308:	0b002406 	bleq	a328 <__RAM_SIZE__+0x2328>
    130c:	030b3e0b 	movweq	r3, #48651	@ 0xbe0b
    1310:	0700000e 	streq	r0, [r0, -lr]
    1314:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
  return true;
    1318:	3b01213a 	blcc	49808 <__ROM_SIZE__+0x9808>
              __write_char2__(hextable2[val]);
    131c:	490b3905 	stmdbmi	fp, {r0, r2, r8, fp, ip, sp}
    1320:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
              leading_zero_ignored = true;
    1324:	00001742 	andeq	r1, r0, r2, asr #14
          while (start_bit >= 0) {
    1328:	03012e08 	movweq	r2, #7688	@ 0x1e08
            int val = (value >> start_bit) & 0xF;
    132c:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
            if (val || leading_zero_ignored) {
    1330:	2139053b 	teqcs	r9, fp, lsr r5
    1334:	1119270d 	tstne	r9, sp, lsl #14
    1338:	40061201 	andmi	r1, r6, r1, lsl #4
          bool leading_zero_ignored = false;
    133c:	01197a18 	tsteq	r9, r8, lsl sl
          int start_bit = LAST_NIBBLE_FIRST_BIT;
    1340:	09000013 	stmdbeq	r0, {r0, r1, r4}
  return true;
    1344:	08030005 	stmdaeq	r3, {r0, r2}
        return false;
    1348:	3b01213a 	blcc	49838 <__ROM_SIZE__+0x9838>
        return false;
    134c:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
    1350:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
    1354:	00001742 	andeq	r1, r0, r2, asr #14
    1358:	4900210a 	stmdbmi	r0, {r1, r3, r8, sp}
    135c:	000b2f13 	andeq	r2, fp, r3, lsl pc
    1360:	00340b00 	eorseq	r0, r4, r0, lsl #22
int printf2(const char *fmt, ...) {
    1364:	213a0803 	teqcs	sl, r3, lsl #16
    1368:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
    136c:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
  va_start(args, fmt);
    1370:	1742b717 	smlaldne	fp, r2, r7, r7
  while (*fmt) {
    1374:	0f0c0000 	svceq	0x000c0000
        if (*fmt == '%') {
    1378:	04210b00 	strteq	r0, [r1], #-2816	@ 0xfffff500
        __write_char2__(*fmt);
    137c:	00001349 	andeq	r1, r0, r9, asr #6
        fmt++;
    1380:	4901010d 	stmdbmi	r1, {r0, r2, r3, r8}
  while (*fmt) {
    1384:	00130113 	andseq	r0, r3, r3, lsl r1
    switch (state) {
    1388:	012e0e00 			@ <UNDEFINED> instruction: 0x012e0e00
    138c:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
          fmt++;
    1390:	3b01213a 	blcc	49880 <__ROM_SIZE__+0x9880>
          continue;
    1394:	06213905 	strteq	r3, [r1], -r5, lsl #18
        while (*fmt && ((*fmt >= '0' && *fmt <= '9') || *fmt == '-')) {
    1398:	01111927 	tsteq	r1, r7, lsr #18
    139c:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
    13a0:	1301197a 	movwne	r1, #6522	@ 0x197a
    13a4:	050f0000 	streq	r0, [pc, #-0]	@ 13ac <printf2+0x48>
    13a8:	3a0e0300 	bcc	381fb0 <__ROM_SIZE__+0x341fb0>
        switch (*fmt) {
    13ac:	0b3b0121 	bleq	ec1838 <__ROM_SIZE__+0xe81838>
    13b0:	13490b39 	movtne	r0, #39737	@ 0x9b39
    13b4:	00001802 	andeq	r1, r0, r2, lsl #16
    13b8:	49002610 	stmdbmi	r0, {r4, r9, sl, sp}
            __write_char2__(*fmt);
    13bc:	11000013 	tstne	r0, r3, lsl r0
    13c0:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
            state = CHECK_CH;
    13c4:	3b01213a 	blcc	498b4 <__ROM_SIZE__+0x98b4>
            break;
    13c8:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
    13cc:	00180213 	andseq	r0, r8, r3, lsl r2
            outstr2(va_arg(args, const char *));
    13d0:	00341200 	eorseq	r1, r4, r0, lsl #4
    13d4:	213a0e03 	teqcs	sl, r3, lsl #28
    13d8:	39053b01 	stmdbcc	r5, {r0, r8, r9, fp, ip, sp}
            fmt++;
    13dc:	13490b21 	movtne	r0, #39713	@ 0x9b21
            break;
    13e0:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
            __write_char2__(va_arg(args, int));
    13e4:	13000017 	movwne	r0, #23
    13e8:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
    13ec:	0b3b0b3a 	bleq	ec40dc <__ROM_SIZE__+0xe840dc>
            fmt++;
    13f0:	13490b39 	movtne	r0, #39737	@ 0x9b39
            break;
    13f4:	05140000 	ldreq	r0, [r4, #-0]
            if (*fmt == 'l') {
    13f8:	00134900 	andseq	r4, r3, r0, lsl #18
    13fc:	00051500 	andeq	r1, r5, r0, lsl #10
            if (printf2_numbers(*fmt, &args, l_count)) {
    1400:	213a0e03 	teqcs	sl, r3, lsl #28
    1404:	39053b01 	stmdbcc	r5, {r0, r8, r9, fp, ip, sp}
    1408:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
              state = CHECK_CH;
    140c:	16000018 			@ <UNDEFINED> instruction: 0x16000018
              fmt++;
    1410:	0e03012e 	adfeqsp	f0, f3, #0.5
              l_count++;
    1414:	3b01213a 	blcc	49904 <__ROM_SIZE__+0x9904>
            if (printf2_numbers(*fmt, &args, 0)) {
    1418:	0d21390b 			@ <UNDEFINED> instruction: 0x0d21390b
    141c:	01111927 	tsteq	r1, r7, lsr #18
              fmt++;
    1420:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
              break;
    1424:	1301197a 	movwne	r1, #6522	@ 0x197a
            return -1;
    1428:	2e170000 	cdpcs	0, 1, cr0, cr7, cr0, {0}
}
    142c:	03193f01 	tsteq	r9, #1, 30
    1430:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
            return -1;
    1434:	21390b3b 	teqcs	r9, fp, lsr fp
    1438:	11192706 	tstne	r9, r6, lsl #14
    143c:	40061201 	andmi	r1, r6, r1, lsl #4
int r32(int argc, char *argv[]) {
    1440:	01197a18 	tsteq	r9, r8, lsl sl
  if (argc < 2) {
    1444:	18000013 	stmdane	r0, {r0, r1, r4}
  uint32_t addr = atoh(argv[1]);
    1448:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    144c:	3b01213a 	blcc	4993c <__ROM_SIZE__+0x993c>
  printf("0x%x: 0x%x\n", addr, data);
    1450:	0b213905 	bleq	84f86c <__ROM_SIZE__+0x80f86c>
    1454:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
}
    1458:	05190000 	ldreq	r0, [r9, #-0]
    printf("Usage: %s <address> (in hex)\n", argv[0]);
    145c:	3a080300 	bcc	202064 <__ROM_SIZE__+0x1c2064>
    1460:	213b0121 	teqcs	fp, r1, lsr #2
    return -1;
    1464:	0b3903ec 	bleq	e4241c <__ROM_SIZE__+0xe0241c>
    1468:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
    146c:	111a0000 	tstne	sl, r0
int w32(int argc, char *argv[]) {
    1470:	130e2501 	movwne	r2, #58625	@ 0xe501
  if (argc < 3) {
    1474:	1b0e030b 	blne	3820a8 <__ROM_SIZE__+0x3420a8>
  uint32_t addr = atoh(argv[1]);
    1478:	1201110e 	andne	r1, r1, #-2147483645	@ 0x80000003
    147c:	00171006 	andseq	r1, r7, r6
  uint32_t data = atoh(argv[2]);
    1480:	00241b00 	eoreq	r1, r4, r0, lsl #22
    1484:	0b3e0b0b 	bleq	f840b8 <__ROM_SIZE__+0xf440b8>
  return 0;
    1488:	00000803 	andeq	r0, r0, r3, lsl #16
    printf("Usage: %s <address> (in hex) <value> (in hex)\n", argv[0]);
    148c:	0301131c 	movweq	r1, #4892	@ 0x131c
    1490:	3a0b0b0e 	bcc	2c40d0 <__ROM_SIZE__+0x2840d0>
    return -1;
    1494:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    1498:	0013010b 	andseq	r0, r3, fp, lsl #2
    149c:	000d1d00 	andeq	r1, sp, r0, lsl #26
int read_mem(int argc, char *argv[]) {
    14a0:	0b3a0e03 	bleq	e84cb4 <__ROM_SIZE__+0xe44cb4>
  if (argc < 3) {
    14a4:	0b390b3b 	bleq	e44198 <__ROM_SIZE__+0xe04198>
  uint32_t addr = atoh(argv[1]);
    14a8:	0b381349 	bleq	e061d4 <__ROM_SIZE__+0xdc61d4>
    14ac:	0d1e0000 	ldceq	0, cr0, [lr, #-0]
  uint32_t length = atoi(argv[2]);
    14b0:	3a080300 	bcc	2020b8 <__ROM_SIZE__+0x1c20b8>
    14b4:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
  for (uint32_t i = 0, data = 0; i < length; i++) {
    14b8:	3813490b 	ldmdacc	r3, {r0, r1, r3, r8, fp, lr}
    printf("Usage: %s <address> (in hex) <num_words> (in decimal)\n", argv[0]);
    14bc:	1f00000b 	svcne	0x0000000b
    14c0:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
    return -1;
    14c4:	0b3a0e03 	bleq	e84cd8 <__ROM_SIZE__+0xe44cd8>
    14c8:	0b390b3b 	bleq	e441bc <__ROM_SIZE__+0xe041bc>
    printf("0x%x: 0x%x\n", addr, data);
    14cc:	13491927 	movtne	r1, #39207	@ 0x9927
    14d0:	1301193c 	movwne	r1, #6460	@ 0x193c
    addr += 4;
    14d4:	0f200000 	svceq	0x00200000
  for (uint32_t i = 0, data = 0; i < length; i++) {
    14d8:	000b0b00 	andeq	r0, fp, r0, lsl #22
  return 0;
    14dc:	00262100 	eoreq	r2, r6, r0, lsl #2
}
    14e0:	2e220000 	cdpcs	0, 2, cr0, cr2, cr0, {0}
    14e4:	3a0e0301 	bcc	3820f0 <__ROM_SIZE__+0x3420f0>
{
    14e8:	39053b0b 	stmdbcc	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
  if (argc < 4) {
    14ec:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
  uint32_t addr = atoh(argv[1]);
    14f0:	12011113 	andne	r1, r1, #-1073741820	@ 0xc0000004
    14f4:	7a184006 	bvc	611514 <__ROM_SIZE__+0x5d1514>
  uint32_t bit_loc = atoi(argv[2]);
    14f8:	00130119 	andseq	r0, r3, r9, lsl r1
    14fc:	010b2300 	mrseq	r2, (UNDEF: 59)
  uint32_t bit_val = atoi(argv[3]);
    1500:	06120111 			@ <UNDEFINED> instruction: 0x06120111
    1504:	34240000 	strtcc	r0, [r4], #-0
  if (bit_loc > 31) {
    1508:	3a0e0300 	bcc	382110 <__ROM_SIZE__+0x342110>
  if (bit_val != 0 && bit_val != 1) {
    150c:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
  data = data | (bit_val << bit_loc);
    1510:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
    1514:	1742b717 	smlaldne	fp, r2, r7, r7
  data = data & ~(!bit_val << bit_loc);
    1518:	01250000 			@ <UNDEFINED> instruction: 0x01250000
    151c:	00134901 	andseq	r4, r3, r1, lsl #18
    1520:	49010000 	stmdbmi	r1, {}	@ <UNPREDICTABLE>
  return 0;
    1524:	7e180200 	cdpvc	2, 1, cr0, cr8, cr0, {0}
    printf("Error: Invalid bit location argument\n");
    1528:	02000018 	andeq	r0, r0, #24
    152c:	017d0148 	cmneq	sp, r8, asr #2
    printf("Error: Invalid bit value argument\n");
    1530:	1301137f 	movwne	r1, #4991	@ 0x137f
    1534:	05030000 	streq	r0, [r3, #-0]
  printf("Usage: %s <address_in_hex(32-bits)> <bit_location_in_decimal(0 to 31)> <bit_value(0 or 1)>\n", argv[0]);
    1538:	3a080300 	bcc	202140 <__ROM_SIZE__+0x1c2140>
    153c:	053b0121 	ldreq	r0, [fp, #-289]!	@ 0xfffffedf
  return -1;
    1540:	13490b39 	movtne	r0, #39737	@ 0x9b39
    1544:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
    1548:	04000017 	streq	r0, [r0], #-23	@ 0xffffffe9
    154c:	017d0148 	cmneq	sp, r8, asr #2
{
    1550:	0000137f 	andeq	r1, r0, pc, ror r3
  if (argc < 3) {
    1554:	03003405 	movweq	r3, #1029	@ 0x405
  uint32_t addr = atoh(argv[1]);
    1558:	01213a08 			@ <UNDEFINED> instruction: 0x01213a08
    155c:	0b39053b 	bleq	e42a50 <__ROM_SIZE__+0xe02a50>
  uint32_t bit_loc = atoi(argv[2]);
    1560:	17021349 	strne	r1, [r2, -r9, asr #6]
    1564:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
  if (bit_loc > 31) {
    1568:	00340600 	eorseq	r0, r4, r0, lsl #12
  uint32_t data = reg32(addr);
    156c:	213a0803 	teqcs	sl, r3, lsl #16
  printf("Bit %u @ 0x%08x: %u\n", bit_loc, addr, bit_val);
    1570:	39053b01 	stmdbcc	r5, {r0, r8, r9, fp, ip, sp}
    1574:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
    1578:	07000018 	smladeq	r0, r8, r0, r0
  return 0;
    157c:	0e03012e 	adfeqsp	f0, f3, #0.5
    printf("Error: Invalid bit location argument\n");
    1580:	3b01213a 	blcc	49a70 <__ROM_SIZE__+0x9a70>
    1584:	0d213905 			@ <UNDEFINED> instruction: 0x0d213905
  printf("Usage: %s <address_in_hex(32-bits)> <bit_location_in_decimal(0 to 31)\n", argv[0]);
    1588:	01111927 	tsteq	r1, r7, lsr #18
    158c:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
  return -1;
    1590:	1301197a 	movwne	r1, #6522	@ 0x197a
    1594:	24080000 	strcs	r0, [r8], #-0
    1598:	3e0b0b00 	vmlacc.f64	d0, d11, d0
    159c:	000e030b 	andeq	r0, lr, fp, lsl #6
{
    15a0:	00050900 	andeq	r0, r5, r0, lsl #18
  for (i = 0; i < Nk; ++i)
    15a4:	213a0e03 	teqcs	sl, r3, lsl #28
    RoundKey[(i * 4) + 0] = Key[(i * 4) + 0];
    15a8:	39053b01 	stmdbcc	r5, {r0, r8, r9, fp, ip, sp}
    15ac:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
    15b0:	1742b717 	smlaldne	fp, r2, r7, r7
    RoundKey[(i * 4) + 1] = Key[(i * 4) + 1];
    15b4:	050a0000 	streq	r0, [sl, #-0]
    15b8:	3a080300 	bcc	2021c0 <__ROM_SIZE__+0x1c21c0>
    RoundKey[(i * 4) + 2] = Key[(i * 4) + 2];
    15bc:	053b0121 	ldreq	r0, [fp, #-289]!	@ 0xfffffedf
    15c0:	13490b39 	movtne	r0, #39737	@ 0x9b39
    15c4:	00001802 	andeq	r1, r0, r2, lsl #16
    RoundKey[(i * 4) + 3] = Key[(i * 4) + 3];
    15c8:	0300050b 	movweq	r0, #1291	@ 0x50b
  for (i = 0; i < Nk; ++i)
    15cc:	01213a08 			@ <UNDEFINED> instruction: 0x01213a08
    15d0:	0b390b3b 	bleq	e442c4 <__ROM_SIZE__+0xe042c4>
  for (i = Nk; i < Nb * (Nr + 1); ++i)
    15d4:	17021349 	strne	r1, [r2, -r9, asr #6]
    j = i * 4; k=(i - Nk) * 4;
    15d8:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
    RoundKey[j + 0] = RoundKey[k + 0] ^ tempa[0];
    15dc:	00340c00 	eorseq	r0, r4, r0, lsl #24
    15e0:	213a0e03 	teqcs	sl, r3, lsl #28
    15e4:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
    15e8:	13491121 	movtne	r1, #37153	@ 0x9121
    RoundKey[j + 1] = RoundKey[k + 1] ^ tempa[1];
    15ec:	1802193f 	stmdane	r2, {r0, r1, r2, r3, r4, r5, r8, fp, ip}
    15f0:	2e0d0000 	cdpcs	0, 0, cr0, cr13, cr0, {0}
    15f4:	3a0e0301 	bcc	382200 <__ROM_SIZE__+0x342200>
    15f8:	053b0121 	ldreq	r0, [fp, #-289]!	@ 0xfffffedf
    15fc:	270c2139 	smladxcs	ip, r9, r1, r2
    RoundKey[j + 2] = RoundKey[k + 2] ^ tempa[2];
    1600:	11134919 	tstne	r3, r9, lsl r9
    1604:	40061201 	andmi	r1, r6, r1, lsl #4
    1608:	01197a18 	tsteq	r9, r8, lsl sl
    160c:	0e000013 	mcreq	0, 0, r0, cr0, cr3, {0}
    1610:	08030005 	stmdaeq	r3, {r0, r2}
    RoundKey[j + 3] = RoundKey[k + 3] ^ tempa[3];
    1614:	3b01213a 	blcc	49b04 <__ROM_SIZE__+0x9b04>
    1618:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
    161c:	00180213 	andseq	r0, r8, r3, lsl r2
  for (i = Nk; i < Nb * (Nr + 1); ++i)
    1620:	00160f00 	andseq	r0, r6, r0, lsl #30
      k = (i - 1) * 4;
    1624:	0b3a0e03 	bleq	e84e38 <__ROM_SIZE__+0xe44e38>
      tempa[0]=RoundKey[k + 0];
    1628:	0b390b3b 	bleq	e4431c <__ROM_SIZE__+0xe0431c>
    162c:	00001349 	andeq	r1, r0, r9, asr #6
      tempa[1]=RoundKey[k + 1];
    1630:	11010b10 	tstne	r1, r0, lsl fp
    1634:	01061201 	tsteq	r6, r1, lsl #4
      tempa[2]=RoundKey[k + 2];
    1638:	11000013 	tstne	r0, r3, lsl r0
    163c:	210b000f 	tstcs	fp, pc
      tempa[3]=RoundKey[k + 3];
    1640:	00134904 	andseq	r4, r3, r4, lsl #18
    1644:	00341200 	eorseq	r1, r4, r0, lsl #4
    if (i % Nk == 0)
    1648:	213a0e03 	teqcs	sl, r3, lsl #28
    164c:	39053b01 	stmdbcc	r5, {r0, r8, r9, fp, ip, sp}
        tempa[0] = tempa[1];
    1650:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
        tempa[1] = tempa[2];
    1654:	1742b717 	smlaldne	fp, r2, r7, r7
        tempa[2] = tempa[3];
    1658:	2e130000 	cdpcs	0, 1, cr0, cr3, cr0, {0}
        tempa[3] = u8tmp;
    165c:	3a0e0301 	bcc	382268 <__ROM_SIZE__+0x342268>
        tempa[0] = getSBoxValue(tempa[0]);
    1660:	0b3b0121 	bleq	ec1aec <__ROM_SIZE__+0xe81aec>
    1664:	270d2139 	smladxcs	sp, r9, r1, r2
        tempa[1] = getSBoxValue(tempa[1]);
    1668:	12011119 	andne	r1, r1, #1073741830	@ 0x40000006
    166c:	7a184006 	bvc	61168c <__ROM_SIZE__+0x5d168c>
        tempa[2] = getSBoxValue(tempa[2]);
    1670:	00130119 	andseq	r0, r3, r9, lsl r1
    1674:	00261400 	eoreq	r1, r6, r0, lsl #8
        tempa[3] = getSBoxValue(tempa[3]);
    1678:	00001349 	andeq	r1, r0, r9, asr #6
      tempa[0] = tempa[0] ^ Rcon[i/Nk];
    167c:	03003415 	movweq	r3, #1045	@ 0x415
    1680:	01213a08 			@ <UNDEFINED> instruction: 0x01213a08
    1684:	21390b3b 	teqcs	r9, fp, lsr fp
    1688:	02134907 	andseq	r4, r3, #114688	@ 0x1c000
}
    168c:	1742b717 	smlaldne	fp, r2, r7, r7
    1690:	2e160000 	cdpcs	0, 1, cr0, cr6, cr0, {0}
{
    1694:	03193f01 	tsteq	r9, #1, 30
  for (i = 0; i < 4; ++i)
    1698:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
      (*state)[i][j] ^= RoundKey[(round * Nb * 4) + (i * Nb) + j];
    169c:	2139053b 	teqcs	r9, fp, lsr r5
    16a0:	49192705 	ldmdbmi	r9, {r0, r2, r8, r9, sl, sp}
    16a4:	12011113 	andne	r1, r1, #-1073741820	@ 0xc0000004
    16a8:	7a184006 	bvc	6116c8 <__ROM_SIZE__+0x5d16c8>
    16ac:	00130119 	andseq	r0, r3, r9, lsl r1
    16b0:	00341700 	eorseq	r1, r4, r0, lsl #14
    16b4:	213a0e03 	teqcs	sl, r3, lsl #28
    for (j = 0; j < 4; ++j)
    16b8:	f6213b01 			@ <UNDEFINED> instruction: 0xf6213b01
    16bc:	490b3904 	stmdbmi	fp, {r2, r8, fp, ip, sp}
  for (i = 0; i < 4; ++i)
    16c0:	00180213 	andseq	r0, r8, r3, lsl r2
    16c4:	010b1800 	tsteq	fp, r0, lsl #16
    for (j = 0; j < 4; ++j)
    16c8:	00001755 	andeq	r1, r0, r5, asr r7
  for (i = 0; i < 4; ++i)
    16cc:	25011119 	strcs	r1, [r1, #-281]	@ 0xfffffee7
    16d0:	030b130e 	movweq	r1, #45838	@ 0xb30e
    for (j = 0; j < 4; ++j)
    16d4:	110e1b0e 	tstne	lr, lr, lsl #22
{
    16d8:	10061201 	andne	r1, r6, r1, lsl #4
      (*state)[j][i] = getSBoxValue((*state)[j][i]);
    16dc:	1a000017 	bne	1740 <ShiftRows+0x30>
    16e0:	0b0b0024 	bleq	2c1778 <__ROM_SIZE__+0x281778>
    16e4:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
    16e8:	011b0000 	tsteq	fp, r0
    for (j = 0; j < 4; ++j)
    16ec:	01134901 	tsteq	r3, r1, lsl #18
    16f0:	1c000013 	stcne	0, cr0, [r0], {19}
  for (i = 0; i < 4; ++i)
    16f4:	13490021 	movtne	r0, #36897	@ 0x9021
    16f8:	00000b2f 	andeq	r0, r0, pc, lsr #22
    for (j = 0; j < 4; ++j)
    16fc:	03012e1d 	movweq	r2, #7709	@ 0x1e1d
}
    1700:	3b0b3a0e 	blcc	2cff40 <__ROM_SIZE__+0x28ff40>
  for (i = 0; i < 4; ++i)
    1704:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
    1708:	11134919 	tstne	r3, r9, lsl r9
    170c:	40061201 	andmi	r1, r6, r1, lsl #4
  temp           = (*state)[0][1];
    1710:	01197a18 	tsteq	r9, r8, lsl sl
  (*state)[0][1] = (*state)[1][1];
    1714:	1e000013 	mcrne	0, 0, r0, cr0, cr3, {0}
  (*state)[1][1] = (*state)[2][1];
    1718:	08030034 	stmdaeq	r3, {r2, r4, r5}
  (*state)[2][1] = (*state)[3][1];
    171c:	0b3b0b3a 	bleq	ec440c <__ROM_SIZE__+0xe8440c>
  temp           = (*state)[0][2];
    1720:	13490b39 	movtne	r0, #39737	@ 0x9b39
  (*state)[0][2] = (*state)[2][2];
    1724:	00001802 	andeq	r1, r0, r2, lsl #16
  temp           = (*state)[1][2];
    1728:	03012e1f 	movweq	r2, #7711	@ 0x1e1f
  (*state)[1][2] = (*state)[3][2];
    172c:	3b0b3a0e 	blcc	2cff6c <__ROM_SIZE__+0x28ff6c>
  temp           = (*state)[0][3];
    1730:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
  (*state)[0][3] = (*state)[3][3];
    1734:	11134919 	tstne	r3, r9, lsl r9
  (*state)[3][3] = (*state)[2][3];
    1738:	40061201 	andmi	r1, r6, r1, lsl #4
  (*state)[2][3] = (*state)[1][3];
    173c:	00197a18 	andseq	r7, r9, r8, lsl sl
}
    1740:	24010000 	strcs	r0, [r1], #-0
  return ((x<<1) ^ (((x>>7) & 1) * 0x1b));
    1744:	3e0b0b00 	vmlacc.f64	d0, d11, d0
    1748:	000e030b 	andeq	r0, lr, fp, lsl #6
    174c:	00340200 	eorseq	r0, r4, r0, lsl #4
}
    1750:	213a0803 	teqcs	sl, r3, lsl #16
{
    1754:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
    1758:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
  for (i = 0; i < 4; ++i)
    175c:	1742b717 	smlaldne	fp, r2, r7, r7
    t   = (*state)[i][0];
    1760:	05030000 	streq	r0, [r3, #-0]
    Tmp = (*state)[i][0] ^ (*state)[i][1] ^ (*state)[i][2] ^ (*state)[i][3] ;
    1764:	3a080300 	bcc	20236c <__ROM_SIZE__+0x1c236c>
    1768:	0b3b0121 	bleq	ec1bf4 <__ROM_SIZE__+0xe81bf4>
    176c:	13490b39 	movtne	r0, #39737	@ 0x9b39
    1770:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
    1774:	04000017 	streq	r0, [r0], #-23	@ 0xffffffe9
    1778:	1755010b 	ldrbne	r0, [r5, -fp, lsl #2]
    Tm  = (*state)[i][0] ^ (*state)[i][1] ; Tm = xtime(Tm);  (*state)[i][0] ^= Tm ^ Tmp ;
    177c:	11050000 	mrsne	r0, (UNDEF: 5)
    1780:	130e2501 	movwne	r2, #58625	@ 0xe501
    1784:	1b0e030b 	blne	3823b8 <__ROM_SIZE__+0x3423b8>
    Tm  = (*state)[i][1] ^ (*state)[i][2] ; Tm = xtime(Tm);  (*state)[i][1] ^= Tm ^ Tmp ;
    1788:	1201110e 	andne	r1, r1, #-2147483645	@ 0x80000003
    178c:	00171006 	andseq	r1, r7, r6
    1790:	00160600 	andseq	r0, r6, r0, lsl #12
    1794:	0b3a0e03 	bleq	e84fa8 <__ROM_SIZE__+0xe44fa8>
    1798:	0b390b3b 	bleq	e4448c <__ROM_SIZE__+0xe0448c>
    Tm  = (*state)[i][2] ^ (*state)[i][3] ; Tm = xtime(Tm);  (*state)[i][2] ^= Tm ^ Tmp ;
    179c:	00001349 	andeq	r1, r0, r9, asr #6
    17a0:	0b002407 	bleq	a7c4 <__RAM_SIZE__+0x27c4>
    17a4:	030b3e0b 	movweq	r3, #48651	@ 0xbe0b
    17a8:	08000008 	stmdaeq	r0, {r3}
    Tm  = (*state)[i][3] ^ t ;              Tm = xtime(Tm);  (*state)[i][3] ^= Tm ^ Tmp ;
    17ac:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
    17b0:	0b3a0e03 	bleq	e84fc4 <__ROM_SIZE__+0xe44fc4>
    17b4:	0b390b3b 	bleq	e444a8 <__ROM_SIZE__+0xe044a8>
    17b8:	13491927 	movtne	r1, #39207	@ 0x9927
    17bc:	06120111 			@ <UNDEFINED> instruction: 0x06120111
  for (i = 0; i < 4; ++i)
    17c0:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
    17c4:	00001301 	andeq	r1, r0, r1, lsl #6
}
    17c8:	03003409 	movweq	r3, #1033	@ 0x409
{
    17cc:	3b0b3a0e 	blcc	2d000c <__ROM_SIZE__+0x29000c>
    17d0:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
  for (i = 0; i < 4; ++i)
    17d4:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
    a = (*state)[i][0];
    17d8:	00001742 	andeq	r1, r0, r2, asr #14
    b = (*state)[i][1];
    17dc:	0b000f0a 	bleq	540c <base_order+0x26e8>
    17e0:	0013490b 	andseq	r4, r3, fp, lsl #18
    c = (*state)[i][2];
    17e4:	00260b00 	eoreq	r0, r6, r0, lsl #22
    d = (*state)[i][3];
    17e8:	00001349 	andeq	r1, r0, r9, asr #6
    (*state)[i][0] = Multiply(a, 0x0e) ^ Multiply(b, 0x0b) ^ Multiply(c, 0x0d) ^ Multiply(d, 0x09);
    17ec:	3f012e0c 	svccc	0x00012e0c
    17f0:	3a0e0319 	bcc	38245c <__ROM_SIZE__+0x34245c>
    17f4:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    17f8:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
    17fc:	12011113 	andne	r1, r1, #-1073741820	@ 0xc0000004
    1800:	7a184006 	bvc	611820 <__ROM_SIZE__+0x5d1820>
    1804:	00000019 	andeq	r0, r0, r9, lsl r0
    1808:	0b002401 	bleq	a814 <__RAM_SIZE__+0x2814>
    180c:	030b3e0b 	movweq	r3, #48651	@ 0xbe0b
    1810:	0200000e 	andeq	r0, r0, #14
    1814:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
    1818:	0b3b0b3a 	bleq	ec4508 <__ROM_SIZE__+0xe84508>
    181c:	13490b39 	movtne	r0, #39737	@ 0x9b39
    1820:	0d030000 	stceq	0, cr0, [r3, #-0]
    1824:	3a0e0300 	bcc	38242c <__ROM_SIZE__+0x34242c>
    1828:	0b3b0321 	bleq	ec24b4 <__ROM_SIZE__+0xe824b4>
    182c:	13490b39 	movtne	r0, #39737	@ 0x9b39
    1830:	00000b38 	andeq	r0, r0, r8, lsr fp
    1834:	03003404 	movweq	r3, #1028	@ 0x404
    1838:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
    183c:	0b390b3b 	bleq	e44530 <__ROM_SIZE__+0xe04530>
    1840:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
    1844:	05050000 	streq	r0, [r5, #-0]
    1848:	00134900 	andseq	r4, r3, r0, lsl #18
    184c:	00050600 	andeq	r0, r5, r0, lsl #12
    1850:	213a0e03 	teqcs	sl, r3, lsl #28
    1854:	17213b01 	strne	r3, [r1, -r1, lsl #22]!
    1858:	13490b39 	movtne	r0, #39737	@ 0x9b39
    185c:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
    1860:	07000017 	smladeq	r0, r7, r0, r0
    1864:	0e030028 	cdpeq	0, 0, cr0, cr3, cr8, {1}
    1868:	00000b1c 	andeq	r0, r0, ip, lsl fp
    186c:	03002808 	movweq	r2, #2056	@ 0x808
    1870:	000b1c08 	andeq	r1, fp, r8, lsl #24
    1874:	000f0900 	andeq	r0, pc, r0, lsl #18
    1878:	4904210b 	stmdbmi	r4, {r0, r1, r3, r8, sp}
    (*state)[i][1] = Multiply(a, 0x09) ^ Multiply(b, 0x0e) ^ Multiply(c, 0x0b) ^ Multiply(d, 0x0d);
    187c:	0a000013 	beq	18d0 <InvMixColumns+0x106>
    1880:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
    1884:	213a0e03 	teqcs	sl, r3, lsl #28
    1888:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
    188c:	19270621 	stmdbne	r7!, {r0, r5, r9, sl}
    1890:	06120111 			@ <UNDEFINED> instruction: 0x06120111
    1894:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
    1898:	00001301 	andeq	r1, r0, r1, lsl #6
    189c:	0200490b 	andeq	r4, r0, #180224	@ 0x2c000
    18a0:	00187e18 	andseq	r7, r8, r8, lsl lr
    18a4:	01110c00 	tsteq	r1, r0, lsl #24
    18a8:	0b130e25 	bleq	4c5144 <__ROM_SIZE__+0x485144>
    18ac:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
    18b0:	06120111 			@ <UNDEFINED> instruction: 0x06120111
    (*state)[i][2] = Multiply(a, 0x0d) ^ Multiply(b, 0x09) ^ Multiply(c, 0x0e) ^ Multiply(d, 0x0b);
    18b4:	00001710 	andeq	r1, r0, r0, lsl r7
    18b8:	4900350d 	stmdbmi	r0, {r0, r2, r3, r8, sl, ip, sp}
    18bc:	0e000013 	mcreq	0, 0, r0, cr0, cr3, {0}
    18c0:	0b0b0024 	bleq	2c1958 <__ROM_SIZE__+0x281958>
    18c4:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
    18c8:	040f0000 	streq	r0, [pc], #-0	@ 18d0 <InvMixColumns+0x106>
    18cc:	3e0e0301 	cdpcc	3, 0, cr0, cr14, cr1, {0}
    18d0:	490b0b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp}
    18d4:	3b0b3a13 	blcc	2d0128 <__ROM_SIZE__+0x290128>
    18d8:	010b390b 	tsteq	fp, fp, lsl #18
    18dc:	10000013 	andne	r0, r0, r3, lsl r0
    18e0:	0e030113 	mcreq	1, 0, r0, cr3, cr3, {0}
    (*state)[i][3] = Multiply(a, 0x0b) ^ Multiply(b, 0x0d) ^ Multiply(c, 0x09) ^ Multiply(d, 0x0e);
    18e4:	0b3a0b0b 	bleq	e84518 <__ROM_SIZE__+0xe44518>
    18e8:	0b390b3b 	bleq	e445dc <__ROM_SIZE__+0xe045dc>
    18ec:	00001301 	andeq	r1, r0, r1, lsl #6
    18f0:	3f012e11 	svccc	0x00012e11
    18f4:	3a0e0319 	bcc	382560 <__ROM_SIZE__+0x342560>
    18f8:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    18fc:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
    1900:	01193c13 	tsteq	r9, r3, lsl ip
    1904:	12000013 	andne	r0, r0, #19
    1908:	0b0b000f 	bleq	2c194c <__ROM_SIZE__+0x28194c>
    190c:	05130000 	ldreq	r0, [r3, #-0]
    1910:	3a080300 	bcc	202518 <__ROM_SIZE__+0x1c2518>
    1914:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
  for (i = 0; i < 4; ++i)
    1918:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
    191c:	14000018 	strne	r0, [r0], #-24	@ 0xffffffe8
}
    1920:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
  for (i = 0; i < 4; ++i)
    1924:	0b3a0e03 	bleq	e85138 <__ROM_SIZE__+0xe45138>
    1928:	0b390b3b 	bleq	e4461c <__ROM_SIZE__+0xe0461c>
    for (j = 0; j < 4; ++j)
    192c:	13491927 	movtne	r1, #39207	@ 0x9927
{
    1930:	06120111 			@ <UNDEFINED> instruction: 0x06120111
      (*state)[j][i] = getSBoxInvert((*state)[j][i]);
    1934:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
    1938:	00001301 	andeq	r1, r0, r1, lsl #6
    193c:	03003415 	movweq	r3, #1045	@ 0x415
    1940:	3b0b3a08 	blcc	2d0168 <__ROM_SIZE__+0x290168>
    1944:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
    for (j = 0; j < 4; ++j)
    1948:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
    194c:	00001742 	andeq	r1, r0, r2, asr #14
  for (i = 0; i < 4; ++i)
    1950:	7d014816 	stcvc	8, cr4, [r1, #-88]	@ 0xffffffa8
    1954:	00137f01 	andseq	r7, r3, r1, lsl #30
    for (j = 0; j < 4; ++j)
    1958:	05010000 	streq	r0, [r1, #-0]
}
    195c:	3a0e0300 	bcc	382564 <__ROM_SIZE__+0x342564>
  for (i = 0; i < 4; ++i)
    1960:	0b3b0121 	bleq	ec1dec <__ROM_SIZE__+0xe81dec>
    1964:	13490b39 	movtne	r0, #39737	@ 0x9b39
    1968:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
  temp = (*state)[3][1];
    196c:	02000017 	andeq	r0, r0, #23
  (*state)[3][1] = (*state)[2][1];
    1970:	0b0b0024 	bleq	2c1a08 <__ROM_SIZE__+0x281a08>
  (*state)[2][1] = (*state)[1][1];
    1974:	0e030b3e 	vmoveq.16	d3[0], r0
  (*state)[1][1] = (*state)[0][1];
    1978:	2e030000 	cdpcs	0, 0, cr0, cr3, cr0, {0}
  temp = (*state)[0][2];
    197c:	03193f01 	tsteq	r9, #1, 30
  (*state)[0][2] = (*state)[2][2];
    1980:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
  temp = (*state)[1][2];
    1984:	0b390b3b 	bleq	e44678 <__ROM_SIZE__+0xe04678>
  (*state)[1][2] = (*state)[3][2];
    1988:	13491927 	movtne	r1, #39207	@ 0x9927
  temp = (*state)[0][3];
    198c:	06120111 			@ <UNDEFINED> instruction: 0x06120111
  (*state)[0][3] = (*state)[1][3];
    1990:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
  (*state)[1][3] = (*state)[2][3];
    1994:	00001301 	andeq	r1, r0, r1, lsl #6
  (*state)[2][3] = (*state)[3][3];
    1998:	03003404 	movweq	r3, #1028	@ 0x404
}
    199c:	01213a08 			@ <UNDEFINED> instruction: 0x01213a08
{
    19a0:	21390b3b 	teqcs	r9, fp, lsr fp
  AddRoundKey(0, state, RoundKey);
    19a4:	0213490a 	andseq	r4, r3, #163840	@ 0x28000
    19a8:	1742b717 	smlaldne	fp, r2, r7, r7
    19ac:	34050000 	strcc	r0, [r5], #-0
  for (round = 1; ; ++round)
    19b0:	3a0e0300 	bcc	3825b8 <__ROM_SIZE__+0x3425b8>
    MixColumns(state);
    19b4:	0b3b0121 	bleq	ec1e40 <__ROM_SIZE__+0xe81e40>
    AddRoundKey(round, state, RoundKey);
    19b8:	49092139 	stmdbmi	r9, {r0, r3, r4, r5, r8, sp}
    19bc:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
    19c0:	00001742 	andeq	r1, r0, r2, asr #14
  for (round = 1; ; ++round)
    19c4:	0b000f06 	bleq	55e4 <base_order+0x28c0>
    SubBytes(state);
    19c8:	13490421 	movtne	r0, #37921	@ 0x9421
    ShiftRows(state);
    19cc:	05070000 	streq	r0, [r7, #-0]
    19d0:	3a080300 	bcc	2025d8 <__ROM_SIZE__+0x1c25d8>
    if (round == Nr) {
    19d4:	0b3b0121 	bleq	ec1e60 <__ROM_SIZE__+0xe81e60>
  AddRoundKey(Nr, state, RoundKey);
    19d8:	13490b39 	movtne	r0, #39737	@ 0x9b39
    19dc:	00001802 	andeq	r1, r0, r2, lsl #16
}
    19e0:	03000508 	movweq	r0, #1288	@ 0x508
{
    19e4:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
  AddRoundKey(Nr, state, RoundKey);
    19e8:	0b390b3b 	bleq	e446dc <__ROM_SIZE__+0xe046dc>
    19ec:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
    19f0:	11090000 	mrsne	r0, (UNDEF: 9)
  for (round = (Nr - 1); ; --round)
    19f4:	130e2501 	movwne	r2, #58625	@ 0xe501
    InvMixColumns(state);
    19f8:	1b0e030b 	blne	38262c <__ROM_SIZE__+0x34262c>
  for (round = (Nr - 1); ; --round)
    19fc:	1201110e 	andne	r1, r1, #-2147483645	@ 0x80000003
    InvShiftRows(state);
    1a00:	00171006 	andseq	r1, r7, r6
    1a04:	00240a00 	eoreq	r0, r4, r0, lsl #20
    InvSubBytes(state);
    1a08:	0b3e0b0b 	bleq	f8463c <__ROM_SIZE__+0xf4463c>
    AddRoundKey(round, state, RoundKey);
    1a0c:	00000803 	andeq	r0, r0, r3, lsl #16
    1a10:	0300160b 	movweq	r1, #1547	@ 0x60b
    1a14:	3b0b3a0e 	blcc	2d0254 <__ROM_SIZE__+0x290254>
    if (round == 0) {
    1a18:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
  for (i = 0; i < AES_BLOCKLEN; ++i) // The block in AES is always 128bit no matter the key size
    1a1c:	0c000013 	stceq	0, cr0, [r0], {19}
    buf[i] ^= Iv[i];
    1a20:	0b0b000f 	bleq	2c1a64 <__ROM_SIZE__+0x281a64>
    1a24:	260d0000 	strcs	r0, [sp], -r0
    1a28:	00134900 	andseq	r4, r3, r0, lsl #18
  for (i = 0; i < AES_BLOCKLEN; ++i) // The block in AES is always 128bit no matter the key size
    1a2c:	00260e00 	eoreq	r0, r6, r0, lsl #28
    1a30:	2e0f0000 	cdpcs	0, 0, cr0, cr15, cr0, {0}
}
    1a34:	03193f01 	tsteq	r9, #1, 30
  KeyExpansion(ctx->RoundKey, key);
    1a38:	3b0b3a0e 	blcc	2d0278 <__ROM_SIZE__+0x290278>
}
    1a3c:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
{
    1a40:	11134919 	tstne	r3, r9, lsl r9
  KeyExpansion(ctx->RoundKey, key);
    1a44:	40061201 	andmi	r1, r6, r1, lsl #4
  memcpy (ctx->Iv, iv, AES_BLOCKLEN);
    1a48:	00197a18 	andseq	r7, r9, r8, lsl sl
    1a4c:	00051000 	andeq	r1, r5, r0
    1a50:	0b3a0803 	bleq	e83a64 <__ROM_SIZE__+0xe43a64>
}
    1a54:	0b390b3b 	bleq	e44748 <__ROM_SIZE__+0xe04748>
  memcpy (ctx->Iv, iv, AES_BLOCKLEN);
    1a58:	17021349 	strne	r1, [r2, -r9, asr #6]
    1a5c:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
	...

Disassembly of section .debug_loclists:

00000000 <.debug_loclists>:
       0:	00000036 	andeq	r0, r0, r6, lsr r0
       4:	00040005 	andeq	r0, r4, r5
	...
      10:	01080004 	tsteq	r8, r4
      14:	64080450 	strvs	r0, [r8], #-1104	@ 0xfffffbb0
      18:	00005501 	andeq	r5, r0, r1, lsl #10
      1c:	04000000 	streq	r0, [r0], #-0
      20:	51010b00 	tstpl	r1, r0, lsl #22
      24:	01640b04 	cmneq	r4, r4, lsl #22
      28:	00010056 	andeq	r0, r1, r6, asr r0
      2c:	0c040000 	stceq	0, cr0, [r4], {-0}
      30:	9f310210 	svcls	0x00310210
      34:	01641004 	cmneq	r4, r4
      38:	002b0054 	eoreq	r0, fp, r4, asr r0
      3c:	00050000 	andeq	r0, r5, r0
      40:	00000004 	andeq	r0, r0, r4
      44:	00010000 	andeq	r0, r1, r0
      48:	00000000 	andeq	r0, r0, r0
      4c:	00040000 	andeq	r0, r4, r0
      50:	04500114 	ldrbeq	r0, [r0], #-276	@ 0xfffffeec
      54:	a3041614 	movwge	r1, #17940	@ 0x4614
      58:	049f5001 	ldreq	r5, [pc], #1	@ 60 <vector_table+0x60>
      5c:	50011816 	andpl	r1, r1, r6, lsl r8
      60:	04241804 	strteq	r1, [r4], #-2052	@ 0xfffff7fc
      64:	9f5001a3 	svcls	0x005001a3
      68:	00002b00 	andeq	r2, r0, r0, lsl #22
      6c:	04000500 	streq	r0, [r0], #-1280	@ 0xfffffb00
      70:	00000000 	andeq	r0, r0, r0
      74:	00000100 	andeq	r0, r0, r0, lsl #2
      78:	00000000 	andeq	r0, r0, r0
      7c:	14000400 	strne	r0, [r0], #-1024	@ 0xfffffc00
      80:	14045001 	strne	r5, [r4], #-1
      84:	01a30416 			@ <UNDEFINED> instruction: 0x01a30416
      88:	16049f50 			@ <UNDEFINED> instruction: 0x16049f50
      8c:	04500118 	ldrbeq	r0, [r0], #-280	@ 0xfffffee8
      90:	a3042418 	movwge	r2, #17432	@ 0x4418
      94:	009f5001 	addseq	r5, pc, r1
      98:	0000002c 	andeq	r0, r0, ip, lsr #32
      9c:	00040005 	andeq	r0, r4, r5
	...
      a8:	01040004 	tsteq	r4, r4
      ac:	1c040450 	cfstrsne	mvf0, [r4], {80}	@ 0x50
      b0:	5001a304 	andpl	sl, r1, r4, lsl #6
      b4:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
      b8:	00040000 	andeq	r0, r4, r0
      bc:	04510107 	ldrbeq	r0, [r1], #-263	@ 0xfffffef9
      c0:	a3041c07 	movwge	r1, #19463	@ 0x4c07
      c4:	009f5101 	addseq	r5, pc, r1, lsl #2
      c8:	00000040 	andeq	r0, r0, r0, asr #32
      cc:	00040005 	andeq	r0, r4, r5
	...
      d8:	010c0004 	tsteq	ip, r4
      dc:	940c0450 	strls	r0, [ip], #-1104	@ 0xfffffbb0
      e0:	01a30401 			@ <UNDEFINED> instruction: 0x01a30401
      e4:	00009f50 	andeq	r9, r0, r0, asr pc
      e8:	04000000 	streq	r0, [r0], #-0
      ec:	51010c00 	tstpl	r1, r0, lsl #24
      f0:	01940c04 	orrseq	r0, r4, r4, lsl #24
      f4:	5101a304 	tstpl	r1, r4, lsl #6
      f8:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
      fc:	46040000 	strmi	r0, [r4], -r0
     100:	0450014e 	ldrbeq	r0, [r0], #-334	@ 0xfffffeb2
     104:	7304504e 	movwvc	r5, #16462	@ 0x404e
     108:	009f7e88 	addseq	r7, pc, r8, lsl #29
     10c:	00000108 	andeq	r0, r0, r8, lsl #2
     110:	00040005 	andeq	r0, r4, r5
	...
     120:	015c5004 	cmpeq	ip, r4
     124:	ac5c0450 	cfldrdge	mvd0, [ip], {80}	@ 0x50
     128:	01a30401 			@ <UNDEFINED> instruction: 0x01a30401
     12c:	ac049f50 	stcge	15, cr9, [r4], {80}	@ 0x50
     130:	0101ae01 	tsteq	r1, r1, lsl #28
     134:	01ae0450 			@ <UNDEFINED> instruction: 0x01ae0450
     138:	a30401d0 	movwge	r0, #16848	@ 0x41d0
     13c:	009f5001 	addseq	r5, pc, r1
	...
     148:	015f5004 	cmpeq	pc, r4
     14c:	ac5f0451 	cfldrdge	mvd0, [pc], {81}	@ 0x51
     150:	04540101 	ldrbeq	r0, [r4], #-257	@ 0xfffffeff
     154:	01b101ac 			@ <UNDEFINED> instruction: 0x01b101ac
     158:	b1045101 	tstlt	r4, r1, lsl #2
     15c:	0401d001 	streq	sp, [r1], #-1
     160:	9f5101a3 	svcls	0x005101a3
	...
     174:	04000000 	streq	r0, [r0], #-0
     178:	50016a62 	andpl	r6, r1, r2, ror #20
     17c:	016d6a04 	cmneq	sp, r4, lsl #20
     180:	7a6d0451 	bvc	1b412cc <__ROM_SIZE__+0x1b012cc>
     184:	7a045501 	bvc	115590 <__ROM_SIZE__+0xd5590>
     188:	0450017e 	ldrbeq	r0, [r0], #-382	@ 0xfffffe82
     18c:	0101817e 	tsteq	r1, lr, ror r1
     190:	01810451 	orreq	r0, r1, r1, asr r4
     194:	55010190 	strpl	r0, [r1, #-400]	@ 0xfffffe70
     198:	92019004 	andls	r9, r1, #4
     19c:	98730401 	ldmdals	r3!, {r0, sl}^
     1a0:	a2049f7f 	andge	r9, r4, #508	@ 0x1fc
     1a4:	0101a601 	tsteq	r1, r1, lsl #12
     1a8:	01a60450 			@ <UNDEFINED> instruction: 0x01a60450
     1ac:	550101ac 	strpl	r0, [r1, #-428]	@ 0xfffffe54
	...
     1b8:	0c000400 	cfstrseq	mvf0, [r0], {-0}
     1bc:	0c045001 	stceq	0, cr5, [r4], {1}
     1c0:	01a30436 			@ <UNDEFINED> instruction: 0x01a30436
     1c4:	36049f50 			@ <UNDEFINED> instruction: 0x36049f50
     1c8:	04500138 	ldrbeq	r0, [r0], #-312	@ 0xfffffec8
     1cc:	a3045038 	movwge	r5, #16440	@ 0x4038
     1d0:	009f5001 	addseq	r5, pc, r1
	...
     1dc:	010f0004 	tsteq	pc, r4
     1e0:	360f0451 			@ <UNDEFINED> instruction: 0x360f0451
     1e4:	36045401 	strcc	r5, [r4], -r1, lsl #8
     1e8:	0451013b 	ldrbeq	r0, [r1], #-315	@ 0xfffffec5
     1ec:	a304503b 	movwge	r5, #16443	@ 0x403b
     1f0:	009f5101 	addseq	r5, pc, r1, lsl #2
	...
     1fc:	12040000 	andne	r0, r4, #0
     200:	0450011a 	ldrbeq	r0, [r0], #-282	@ 0xfffffee6
     204:	51011d1a 	tstpl	r1, sl, lsl sp
     208:	01262004 			@ <UNDEFINED> instruction: 0x01262004
     20c:	29260450 	stmdbcs	r6!, {r4, r6, sl}
     210:	2c045301 	stccs	3, cr5, [r4], {1}
     214:	00500130 	subseq	r0, r0, r0, lsr r1
     218:	0000002c 	andeq	r0, r0, ip, lsr #32
     21c:	00040005 	andeq	r0, r4, r5
	...
     228:	01040004 	tsteq	r4, r4
     22c:	1c040450 	cfstrsne	mvf0, [r4], {80}	@ 0x50
     230:	5001a304 	andpl	sl, r1, r4, lsl #6
     234:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
     238:	00040000 	andeq	r0, r4, r0
     23c:	04510107 	ldrbeq	r0, [r1], #-263	@ 0xfffffef9
     240:	a3041c07 	movwge	r1, #19463	@ 0x4c07
     244:	009f5101 	addseq	r5, pc, r1, lsl #2
     248:	00000538 	andeq	r0, r0, r8, lsr r5
     24c:	00040005 	andeq	r0, r4, r5
	...
     258:	8a028004 	bhi	a0270 <__ROM_SIZE__+0x60270>
     25c:	04500102 	ldrbeq	r0, [r0], #-258	@ 0xfffffefe
     260:	029c028a 	addseq	r0, ip, #-1610612728	@ 0xa0000008
     264:	5001a304 	andpl	sl, r1, r4, lsl #6
     268:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
     26c:	80040000 	andhi	r0, r4, r0
     270:	01028802 	tsteq	r2, r2, lsl #16
     274:	02880451 	addeq	r0, r8, #1358954496	@ 0x51000000
     278:	a304029c 	movwge	r0, #17052	@ 0x429c
     27c:	009f5101 	addseq	r5, pc, r1, lsl #2
     280:	00000000 	andeq	r0, r0, r0
     284:	94038804 	strls	r8, [r3], #-2052	@ 0xfffff7fc
     288:	04500103 	ldrbeq	r0, [r0], #-259	@ 0xfffffefd
     28c:	03f00394 	mvnseq	r0, #148, 6	@ 0x50000002
     290:	5001a304 	andpl	sl, r1, r4, lsl #6
     294:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
     298:	00000000 	andeq	r0, r0, r0
     29c:	92038804 	andls	r8, r3, #4, 16	@ 0x40000
     2a0:	04510103 	ldrbeq	r0, [r1], #-259	@ 0xfffffefd
     2a4:	03970392 	orrseq	r0, r7, #1207959554	@ 0x48000002
     2a8:	97045301 	strls	r5, [r4, -r1, lsl #6]
     2ac:	0403f003 	streq	pc, [r3], #-3
     2b0:	9f5101a3 	svcls	0x005101a3
     2b4:	00000100 	andeq	r0, r0, r0, lsl #2
     2b8:	00000000 	andeq	r0, r0, r0
     2bc:	038a0400 	orreq	r0, sl, #0, 8
     2c0:	300203a6 	andcc	r0, r2, r6, lsr #7
     2c4:	03a6049f 			@ <UNDEFINED> instruction: 0x03a6049f
     2c8:	550103d4 	strpl	r0, [r1, #-980]	@ 0xfffffc2c
     2cc:	d803d404 	stmdale	r3, {r2, sl, ip, lr, pc}
     2d0:	9f300203 	svcls	0x00300203
     2d4:	da03d804 	ble	f62ec <__ROM_SIZE__+0xb62ec>
     2d8:	00550103 	subseq	r0, r5, r3, lsl #2
     2dc:	00000002 	andeq	r0, r0, r2
     2e0:	00000000 	andeq	r0, r0, r0
     2e4:	a2038a04 	andge	r8, r3, #4, 20	@ 0x4000
     2e8:	9f310203 	svcls	0x00310203
     2ec:	d403a604 	strle	sl, [r3], #-1540	@ 0xfffff9fc
     2f0:	04560103 	ldrbeq	r0, [r6], #-259	@ 0xfffffefd
     2f4:	03d803d4 	bicseq	r0, r8, #212, 6	@ 0x50000003
     2f8:	049f3102 	ldreq	r3, [pc], #258	@ 300 <vector_table+0x300>
     2fc:	03da03d8 	bicseq	r0, sl, #216, 6	@ 0x60000003
     300:	00005601 	andeq	r5, r0, r1, lsl #12
     304:	00000000 	andeq	r0, r0, r0
     308:	0cac0400 	cfstrseq	mvf0, [ip]
     30c:	50010cb4 			@ <UNDEFINED> instruction: 0x50010cb4
     310:	d80cb404 	stmdale	ip, {r2, sl, ip, sp, pc}
     314:	0456010c 	ldrbeq	r0, [r6], #-268	@ 0xfffffef4
     318:	0cdc0cd8 	ldcleq	12, cr0, [ip], {216}	@ 0xd8
     31c:	5001a304 	andpl	sl, r1, r4, lsl #6
     320:	0002009f 	muleq	r2, pc, r0	@ <UNPREDICTABLE>
     324:	b0040000 	andlt	r0, r4, r0
     328:	020cb40c 	andeq	fp, ip, #12, 8	@ 0xc000000
     32c:	b4049f30 	strlt	r9, [r4], #-3888	@ 0xfffff0d0
     330:	010cd80c 	tsteq	ip, ip, lsl #16
     334:	00000055 	andeq	r0, r0, r5, asr r0
     338:	00000000 	andeq	r0, r0, r0
     33c:	8a0c8004 	bhi	320354 <__ROM_SIZE__+0x2e0354>
     340:	0450010c 	ldrbeq	r0, [r0], #-268	@ 0xfffffef4
     344:	0c8d0c8a 	stceq	12, cr0, [sp], {138}	@ 0x8a
     348:	8d045101 	stfhis	f5, [r4, #-4]
     34c:	040cac0c 	streq	sl, [ip], #-3084	@ 0xfffff3f4
     350:	9f5001a3 	svcls	0x005001a3
     354:	00000000 	andeq	r0, r0, r0
     358:	0c8e0400 	cfstrseq	mvf0, [lr], {0}
     35c:	50010c92 	mulpl	r1, r2, ip
     360:	a30c9e04 	movwge	r9, #52740	@ 0xce04
     364:	0050010c 	subseq	r0, r0, ip, lsl #2
     368:	00000000 	andeq	r0, r0, r0
     36c:	a0029c04 	andge	r9, r2, r4, lsl #24
     370:	04500102 	ldrbeq	r0, [r0], #-258	@ 0xfffffefe
     374:	02ac02a0 	adceq	r0, ip, #160, 4
     378:	5001a304 	andpl	sl, r1, r4, lsl #6
     37c:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
     380:	9c040000 	stcls	0, cr0, [r4], {-0}
     384:	0102a302 	tsteq	r2, r2, lsl #6
     388:	02a30451 	adceq	r0, r3, #1358954496	@ 0x51000000
     38c:	a30402ac 	movwge	r0, #17068	@ 0x42ac
     390:	009f5101 	addseq	r5, pc, r1, lsl #2
     394:	00000002 	andeq	r0, r0, r2
     398:	a0019c04 	andge	r9, r1, r4, lsl #24
     39c:	9f300201 	svcls	0x00300201
     3a0:	bc01a004 	stclt	0, cr10, [r1], {4}
     3a4:	00540101 	subseq	r0, r4, r1, lsl #2
     3a8:	00000000 	andeq	r0, r0, r0
     3ac:	b4040000 	strlt	r0, [r4], #-0
     3b0:	0109bb09 	tsteq	r9, r9, lsl #22
     3b4:	09bc0450 	ldmibeq	ip!, {r4, r6, sl}
     3b8:	500109c5 	andpl	r0, r1, r5, asr #19
     3bc:	ba0ab404 	blt	2ad3d4 <__ROM_SIZE__+0x26d3d4>
int car_mesg(int argc, char** argv) {
     3c0:	0050010a 	subseq	r0, r0, sl, lsl #2
     3c4:	00000000 	andeq	r0, r0, r0
    printf("Received the message:");
     3c8:	f209ee04 	vceq.f32	d14, d9, d4
    for (ctr = 1; ctr < argc; ctr++) {
     3cc:	04500109 	ldrbeq	r0, [r0], #-265	@ 0xfffffef7
        printf(" %s", argv[ctr]);
     3d0:	0bdb0bd6 	bleq	ff6c3330 <_STACK_TOP_+0xdf6bb334>
     3d4:	01005001 	tsteq	r0, r1
	...
    printf("\n");
     3e0:	01010000 	mrseq	r0, (UNDEF: 1)
     3e4:	04000000 	streq	r0, [r0], #-0
    if (argc > 0) {
     3e8:	09b008fc 	ldmibeq	r0!, {r2, r3, r4, r5, r6, r7, fp}
}
     3ec:	049f3002 	ldreq	r3, [pc], #2	@ 3f4 <car_mesg+0x34>
        if (strcmp(argv[1], "PING_REPLY") == 0) {
     3f0:	09b209b0 	ldmibeq	r2!, {r4, r5, r7, r8, fp}
     3f4:	b4045501 	strlt	r5, [r4], #-1281	@ 0xfffffaff
            printf("Got a ping reply.\n");
     3f8:	0109c609 	tsteq	r9, r9, lsl #12
     3fc:	09c80455 	stmibeq	r8, {r0, r2, r4, r6, sl}^
            printf("Didn't know how to handle %s\n", argv[1]);
     400:	55010b8e 	strpl	r0, [r1, #-2958]	@ 0xfffff472
     404:	960b9004 	strls	r9, [fp], -r4
     408:	0455010b 	ldrbeq	r0, [r5], #-267	@ 0xfffffef5
     40c:	0bb60b98 	bleq	fed83274 <_STACK_TOP_+0xded7b278>
     410:	b6045501 	strlt	r5, [r4], -r1, lsl #10
     414:	020bba0b 	andeq	fp, fp, #45056	@ 0xb000
     418:	ba049f30 	blt	1280e0 <__ROM_SIZE__+0xe80e0>
     41c:	010bec0b 	tsteq	fp, fp, lsl #24
     420:	00000055 	andeq	r0, r0, r5, asr r0
     424:	00000000 	andeq	r0, r0, r0
void uputc(char c) {
     428:	b409b004 	strlt	fp, [r9], #-4
  while ((UARTFR >> 5) & 1)
     42c:	04540109 	ldrbeq	r0, [r4], #-265	@ 0xfffffef7
     430:	0aa409c8 	beq	fe902b58 <_STACK_TOP_+0xde8fab5c>
  UART_DR = c;
     434:	bc045401 	cfstrslt	mvf5, [r4], {1}
  if (c == '\n')
     438:	010bec0a 	tsteq	fp, sl, lsl #24
}
     43c:	00060054 	andeq	r0, r6, r4, asr r0
    uputc('\r');
     440:	fc040000 	stc2	0, cr0, [r4], {-0}
}
     444:	0208fe08 	andeq	pc, r8, #8, 28	@ 0x80
     448:	fe049f30 	mcr2	15, 0, r9, cr4, cr0, {1}
  if (!((UARTFR >> 4) & 1)) return UART_DR;
     44c:	01099208 	tsteq	r9, r8, lsl #4
     450:	00000053 	andeq	r0, r0, r3, asr r0
     454:	a5099404 	strge	r9, [r9, #-1028]	@ 0xfffffbfc
     458:	00530109 	subseq	r0, r3, r9, lsl #2
  return -1;
     45c:	00000000 	andeq	r0, r0, r0
}
     460:	ac040000 	stcge	0, cr0, [r4], {-0}
     464:	0102b802 	tsteq	r2, r2, lsl #16
  UARTCTL = 0;
     468:	02b80450 	adcseq	r0, r8, #80, 8	@ 0x50000000
     46c:	580102fa 	stmdapl	r1, {r1, r3, r4, r5, r6, r7, r9}
  UARTIBRD = 8;
     470:	8802fa04 	stmdahi	r2, {r2, r9, fp, ip, sp, lr, pc}
  UARTFBRD = 44;
     474:	01a30403 			@ <UNDEFINED> instruction: 0x01a30403
  UARTCC = 0;
     478:	00009f50 	andeq	r9, r0, r0, asr pc
  UARTLCRH = 0x60;
     47c:	00000000 	andeq	r0, r0, r0
  UARTCTL = 0x301;
     480:	02ac0400 	adceq	r0, ip, #0, 8
}
     484:	510102b8 			@ <UNDEFINED> instruction: 0x510102b8
     488:	fa02b804 	blx	ae4a0 <__ROM_SIZE__+0x6e4a0>
void u2putc(char c) {
     48c:	04560102 	ldrbeq	r0, [r6], #-258	@ 0xfffffefe
  while ((UART2FR >> 5) & 1)
     490:	038802fa 	orreq	r0, r8, #-1610612721	@ 0xa000000f
     494:	5101a304 	tstpl	r1, r4, lsl #6
  UART2_DR = c;
     498:	0101009f 	swpeq	r0, pc, [r1]	@ <UNPREDICTABLE>
  if (c == '\n')
     49c:	00000001 	andeq	r0, r0, r1
}
     4a0:	e202b404 	and	fp, r2, #4, 8	@ 0x4000000
    u2putc('\r');
     4a4:	9f300202 	svcls	0x00300202
}
     4a8:	e402e204 	str	lr, [r2], #-516	@ 0xfffffdfc
     4ac:	9f310202 	svcls	0x00310202
  if (!((UART2FR >> 4) & 1)) return UART2_DR;
     4b0:	f602e404 			@ <UNDEFINED> instruction: 0xf602e404
     4b4:	9f300202 	svcls	0x00300202
     4b8:	00000300 	andeq	r0, r0, r0, lsl #6
     4bc:	02b40400 	adcseq	r0, r4, #0, 8
  return -1;
     4c0:	300202b8 			@ <UNDEFINED> instruction: 0x300202b8
}
     4c4:	02b8049f 	adcseq	r0, r8, #-1627389952	@ 0x9f000000
     4c8:	550102fa 	strpl	r0, [r1, #-762]	@ 0xfffffd06
  UART2CTL = 0;
     4cc:	00000000 	andeq	r0, r0, r0
     4d0:	04b80400 	ldrteq	r0, [r8], #1024	@ 0x400
  UART2IBRD = 8;
     4d4:	500104c0 	andpl	r0, r1, r0, asr #9
  UART2FBRD = 44;
     4d8:	8a04c004 	bhi	1304f0 <__ROM_SIZE__+0xf04f0>
  UART2CC = 0;
     4dc:	00550105 	subseq	r0, r5, r5, lsl #2
  UART2LCRH = 0x60;
     4e0:	00000000 	andeq	r0, r0, r0
  UART2CTL = 0x301;
     4e4:	c304b804 	movwgt	fp, #18436	@ 0x4804
}
     4e8:	04510104 	ldrbeq	r0, [r1], #-260	@ 0xfffffefc
     4ec:	058a04c3 	streq	r0, [sl, #1219]	@ 0x4c3
  RCGCUART |= 3;
     4f0:	00005401 	andeq	r5, r0, r1, lsl #8
     4f4:	04000000 	streq	r0, [r0], #-0
     4f8:	04c304b8 	strbeq	r0, [r3], #1208	@ 0x4b8
     4fc:	c3045201 	movwgt	r5, #16897	@ 0x4201
  RCGCGPIO |= 3;
     500:	04058a04 	streq	r8, [r5], #-2564	@ 0xfffff5fc
     504:	9f5201a3 	svcls	0x005201a3
     508:	00000100 	andeq	r0, r0, r0, lsl #2
  GPIODEN = 0x03;
     50c:	00000101 	andeq	r0, r0, r1, lsl #2
     510:	04be0400 	ldrteq	r0, [lr], #1024	@ 0x400
  GPIOAFSEL = 0x03;
     514:	300204cc 	andcc	r0, r2, ip, asr #9
  GPIOPCTL |= 0x00000011;
     518:	04cc049f 	strbeq	r0, [ip], #1183	@ 0x49f
     51c:	50010580 	andpl	r0, r1, r0, lsl #11
     520:	86058004 	strhi	r8, [r5], -r4
  GPIODEN2 = 0x03;
     524:	01700305 	cmneq	r0, r5, lsl #6
     528:	0586049f 	streq	r0, [r6, #1183]	@ 0x49f
  GPIOAFSEL2 = 0x03;
     52c:	5001058a 	andpl	r0, r1, sl, lsl #11
  GPIOPCTL2 |= 0x00000011;
     530:	00000200 	andeq	r0, r0, r0, lsl #4
     534:	04be0400 	ldrteq	r0, [lr], #1024	@ 0x400
     538:	300204cc 	andcc	r0, r2, ip, asr #9
}
     53c:	04cc049f 	strbeq	r0, [ip], #1183	@ 0x49f
     540:	5301058a 	movwpl	r0, #5514	@ 0x158a
void platform_init() {
     544:	00000000 	andeq	r0, r0, r0
    pin_setup();
     548:	04c60400 	strbeq	r0, [r6], #1024	@ 0x400
    uart_init();
     54c:	500104ca 	andpl	r0, r1, sl, asr #9
    uart2_init();
     550:	8a04ca04 	bhi	132d68 <__ROM_SIZE__+0xf2d68>
    set_read_char(ugetc);
     554:	005c0105 	subseq	r0, ip, r5, lsl #2
    set_read_char2(u2getc);
     558:	00000000 	andeq	r0, r0, r0
     55c:	ce040000 	cdpgt	0, 0, cr0, cr4, cr0, {0}
    set_write_char(uputc);
     560:	0107e807 	tsteq	r7, r7, lsl #16
    set_write_char2(u2putc);
     564:	07e80450 	ubfxeq	r0, r0, #8, #9
     568:	580108e0 	stmdapl	r1, {r5, r6, r7, fp}
}
     56c:	f008e004 			@ <UNDEFINED> instruction: 0xf008e004
     570:	00500108 	subseq	r0, r0, r8, lsl #2
     574:	00000000 	andeq	r0, r0, r0
     578:	ce040000 	cdpgt	0, 0, cr0, cr4, cr0, {0}
int pair(int argc, char** argv) {
     57c:	0107e807 	tsteq	r7, r7, lsl #16
    printf("Sending a pair request.\n");
     580:	07e80451 	ubfxeq	r0, r1, #8, #9
    printf2("FOB_MESG PAIR\n");
     584:	560108e0 	strpl	r0, [r1], -r0, ror #17
     588:	f008e004 			@ <UNDEFINED> instruction: 0xf008e004
}
     58c:	00510108 	subseq	r0, r1, r8, lsl #2
     590:	00000000 	andeq	r0, r0, r0
     594:	a007e804 	andge	lr, r7, r4, lsl #16
int aes(int argc, char** argv) {
     598:	04550108 	ldrbeq	r0, [r5], #-264	@ 0xfffffef8
    uint8_t key[16] = {0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,
     59c:	08e008a4 	stmiaeq	r0!, {r2, r5, r7, fp}^
     5a0:	00005501 	andeq	r5, r0, r1, lsl #10
     5a4:	04000000 	streq	r0, [r0], #-0
    uint8_t text[16] = "0123456789abcdef";
     5a8:	08a007e8 	stmiaeq	r0!, {r3, r5, r6, r7, r8, r9, sl}
     5ac:	a4045901 	strge	r5, [r4], #-2305	@ 0xfffff6ff
     5b0:	0108e008 	tsteq	r8, r8
    AES_init_ctx(&ctx, key);
     5b4:	01000059 	qaddeq	r0, r9, r0
     5b8:	00000001 	andeq	r0, r0, r1
    printf("Encrypting %s using AES\n", text);
     5bc:	e8040000 	stmda	r4, {}	@ <UNPREDICTABLE>
     5c0:	01088607 	tsteq	r8, r7, lsl #12
    AES_ECB_encrypt(&ctx, text);
     5c4:	0886045a 	stmeq	r6, {r1, r3, r4, r6, sl}
     5c8:	55010894 	strpl	r0, [r1, #-2196]	@ 0xfffff76c
    printf("Encrypted is %s\n", text);
     5cc:	9a089404 	bls	2255e4 <__ROM_SIZE__+0x1e55e4>
     5d0:	045a0108 	ldrbeq	r0, [sl], #-264	@ 0xfffffef8
    len = encode_base64(text, 16, b64text);
     5d4:	08a808a4 	stmiaeq	r8!, {r2, r5, r7, fp}
     5d8:	00005a01 	andeq	r5, r0, r1, lsl #20
     5dc:	00000000 	andeq	r0, r0, r0
    b64text[len] = '\n';
     5e0:	04000000 	streq	r0, [r0], #-0
     5e4:	059c058a 	ldreq	r0, [ip, #1418]	@ 0x58a
     5e8:	9c045001 	stcls	0, cr5, [r4], {1}
    printf("Encrypted is %s\n", text);
     5ec:	0105c205 	tsteq	r5, r5, lsl #4
     5f0:	05c20456 	strbeq	r0, [r2, #1110]	@ 0x456
    printf2("FOB_MESG AESB64 %s\n", b64text);
     5f4:	500105c4 	andpl	r0, r1, r4, asr #11
     5f8:	c605c404 	strgt	ip, [r5], -r4, lsl #8
    AES_ECB_decrypt(&ctx, text);
     5fc:	01a30405 			@ <UNDEFINED> instruction: 0x01a30405
     600:	00009f50 	andeq	r9, r0, r0, asr pc
    printf("Which should decrypt to %s \n", text);
     604:	00000000 	andeq	r0, r0, r0
     608:	058a0400 	streq	r0, [sl, #1024]	@ 0x400
}
     60c:	5101059f 			@ <UNDEFINED> instruction: 0x5101059f
     610:	c2059f04 	andgt	r9, r5, #4, 30
     614:	04550105 	ldrbeq	r0, [r5], #-261	@ 0xfffffefb
     618:	05c605c2 	strbeq	r0, [r6, #1474]	@ 0x5c2
     61c:	00005101 	andeq	r5, r0, r1, lsl #2
     620:	00000000 	andeq	r0, r0, r0
     624:	058a0400 	streq	r0, [sl, #1024]	@ 0x400
     628:	5201059f 	andpl	r0, r1, #666894336	@ 0x27c00000
int encode64(int argc, char** argv) {
     62c:	c2059f04 	andgt	r9, r5, #4, 30
    if (argc > 1) {
     630:	04540105 	ldrbeq	r0, [r4], #-261	@ 0xfffffefb
     634:	05c605c2 	strbeq	r0, [r6, #1474]	@ 0x5c2
        len = strlen(argv[1]);
     638:	00005201 	andeq	r5, r0, r1, lsl #4
     63c:	04000000 	streq	r0, [r0], #-0
        if (len < MAX64LENGTH) {
     640:	05b605a6 	ldreq	r0, [r6, #1446]!	@ 0x5a6
            len = encode_base64(argv[1], len, encoded);
     644:	ba045301 	blt	115250 <__ROM_SIZE__+0xd5250>
     648:	0105c205 	tsteq	r5, r5, lsl #4
            printf("Encoded %s as %s with %d characters\n", argv[1], encoded, len);
     64c:	00000053 	andeq	r0, r0, r3, asr r0
     650:	c0040000 	andgt	r0, r4, r0
     654:	0101da01 	tsteq	r1, r1, lsl #20
            printf("String exceeds max length of %d characters", MAX64LENGTH);
     658:	01da0450 	bicseq	r0, sl, r0, asr r4
     65c:	a3040280 	movwge	r0, #17024	@ 0x4280
     660:	009f5001 	addseq	r5, pc, r1
        printf("Usage is 'encode64 string'\n");
     664:	00000000 	andeq	r0, r0, r0
}
     668:	da01c004 	ble	70680 <__ROM_SIZE__+0x30680>
     66c:	04510101 	ldrbeq	r0, [r1], #-257	@ 0xfffffeff
     670:	028001da 	addeq	r0, r0, #-2147483594	@ 0x80000036
     674:	5101a304 	tstpl	r1, r4, lsl #6
     678:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
int decode64(int argc, char** argv) {
     67c:	f401c804 	vst2.8	{d12-d13}, [r1], r4
    if (argc > 1) {
     680:	00550101 	subseq	r0, r5, r1, lsl #2
     684:	00000001 	andeq	r0, r0, r1
        int len = strlen(argv[1]);
     688:	c8040000 	stmdagt	r4, {}	@ <UNPREDICTABLE>
     68c:	0201d401 	andeq	sp, r1, #16777216	@ 0x1000000
        if (len < MAX64LENGTH-1) {
     690:	d4049f30 	strle	r9, [r4], #-3888	@ 0xfffff0d0
                printf("encoded string is %d characters\n", len);
     694:	0101d601 	tsteq	r1, r1, lsl #12
     698:	01d60454 	bicseq	r0, r6, r4, asr r4
                len = decode_base64(argv[1], len, plaintext);
     69c:	300201da 	ldrdcc	r0, [r2], -sl
     6a0:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
     6a4:	f401da04 	vst1.8	{d13-d14}, [r1], r4
                printf("decoded string is %d characters\n", len);
     6a8:	00540101 	subseq	r0, r4, r1, lsl #2
     6ac:	00000000 	andeq	r0, r0, r0
                printf("Adding NULL at the end of decoded string\n");
     6b0:	f0040000 			@ <UNDEFINED> instruction: 0xf0040000
                plaintext[len] = '\n';
     6b4:	0103fb03 	tsteq	r3, r3, lsl #22	@ <UNPREDICTABLE>
     6b8:	03fb0450 	mvnseq	r0, #80, 8	@ 0x50000000
     6bc:	550104ac 	strpl	r0, [r1, #-1196]	@ 0xfffffb54
     6c0:	b804ac04 	stmdalt	r4, {r2, sl, fp, sp, pc}
                printf("Decoded %s as: %s\n", argv[1], plaintext);
     6c4:	00500104 	subseq	r0, r0, r4, lsl #2
     6c8:	8e040000 	cdphi	0, 0, cr0, cr4, cr0, {0}
     6cc:	01049a04 	tsteq	r4, r4, lsl #20
            printf("String exceeds max length of %d characters", MAX64LENGTH);
     6d0:	00000050 	andeq	r0, r0, r0, asr r0
     6d4:	00000000 	andeq	r0, r0, r0
        printf("Usage is 'decode64 string'\n");
     6d8:	c506b804 	strgt	fp, [r6, #-2052]	@ 0xfffff7fc
     6dc:	04500106 	ldrbeq	r0, [r0], #-262	@ 0xfffffefa
}
     6e0:	079006c5 	ldreq	r0, [r0, r5, asr #13]
     6e4:	90045401 	andls	r5, r4, r1, lsl #8
     6e8:	04079807 	streq	r9, [r7], #-2055	@ 0xfffff7f9
     6ec:	9f5001a3 	svcls	0x005001a3
     6f0:	00000000 	andeq	r0, r0, r0
     6f4:	04000000 	streq	r0, [r0], #-0
     6f8:	06c206b8 			@ <UNDEFINED> instruction: 0x06c206b8
int send_ping(int argc, char** argv) {
     6fc:	c2045101 	andgt	r5, r4, #1073741824	@ 0x40000000
    printf("Pinging the car.\n");
     700:	01079006 	tsteq	r7, r6
    printf2("FOB_MESG PING\n");
     704:	07900455 			@ <UNDEFINED> instruction: 0x07900455
     708:	a3040798 	movwge	r0, #18328	@ 0x4798
}
     70c:	009f5101 	addseq	r5, pc, r1, lsl #2
     710:	f0040000 			@ <UNDEFINED> instruction: 0xf0040000
     714:	0106fd06 	tsteq	r6, r6, lsl #26	@ <UNPREDICTABLE>
void __attribute__((optimize("O0"), weak)) initial_setup(void) {
     718:	00000053 	andeq	r0, r0, r3, asr r0
     71c:	00000000 	andeq	r0, r0, r0
  char *src = &_etext, *dst = &_data;
     720:	c6040000 	strgt	r0, [r4], -r0
     724:	0105e605 	tsteq	r5, r5, lsl #12
  if (dst != src)
     728:	05e60450 	strbeq	r0, [r6, #1104]!	@ 0x450
     72c:	540105ec 	strpl	r0, [r1], #-1516	@ 0xfffffa14
    while (dst < &_edata) *(dst++) = *(src++);
     730:	f305ec04 			@ <UNDEFINED> instruction: 0xf305ec04
     734:	04500105 	ldrbeq	r0, [r0], #-261	@ 0xfffffefb
     738:	06b805f3 			@ <UNDEFINED> instruction: 0x06b805f3
     73c:	00005401 	andeq	r5, r0, r1, lsl #8
     740:	00000000 	andeq	r0, r0, r0
     744:	04000000 	streq	r0, [r0], #-0
  for (dst = &_bss; dst < &_ebss; dst++) *dst = 0;
     748:	05e405c6 	strbeq	r0, [r4, #1478]!	@ 0x5c6
     74c:	e4045101 	str	r5, [r4], #-257	@ 0xfffffeff
     750:	0405ec05 	streq	lr, [r5], #-3077	@ 0xfffff3fb
     754:	9f5101a3 	svcls	0x005101a3
     758:	f005ec04 			@ <UNDEFINED> instruction: 0xf005ec04
     75c:	04510105 	ldrbeq	r0, [r1], #-261	@ 0xfffffefb
     760:	06b805f0 			@ <UNDEFINED> instruction: 0x06b805f0
  platform_init();
     764:	00005501 	andeq	r5, r0, r1, lsl #10
}
     768:	068e0400 	streq	r0, [lr], r0, lsl #8
     76c:	51010696 			@ <UNDEFINED> instruction: 0x51010696
     770:	00000000 	andeq	r0, r0, r0
     774:	01880400 	orreq	r0, r8, r0, lsl #8
     778:	5001018e 	andpl	r0, r1, lr, lsl #3
     77c:	9a018e04 	bls	63f94 <__ROM_SIZE__+0x23f94>
     780:	00540101 	subseq	r0, r4, r1, lsl #2
static void delete(void) {
     784:	00000199 	muleq	r0, r9, r1
  __write_char__(BACK_SPACE);
     788:	00040005 	andeq	r0, r4, r5
	...
  __write_char__(BACK_SPACE);
     794:	ab03a004 	blge	e87ac <__ROM_SIZE__+0xa87ac>
     798:	04500103 	ldrbeq	r0, [r0], #-259	@ 0xfffffefd
}
     79c:	04dc03ab 	ldrbeq	r0, [ip], #939	@ 0x3ab
static void clear_prompt(int char_count) {
     7a0:	00005401 	andeq	r5, r0, r1, lsl #8
  while (char_count) {
     7a4:	04000000 	streq	r0, [r0], #-0
    delete ();
     7a8:	03ab03a0 			@ <UNDEFINED> instruction: 0x03ab03a0
  while (char_count) {
     7ac:	ab045101 	blge	114bb8 <__ROM_SIZE__+0xd4bb8>
}
     7b0:	0404dc03 	streq	sp, [r4], #-3075	@ 0xfffff3fd
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
     7b4:	9f5101a3 	svcls	0x005101a3
    auto_load[i].command(0, NULL);
     7b8:	00000000 	andeq	r0, r0, r0
     7bc:	03a00400 	moveq	r0, #0, 8
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
     7c0:	520103ab 	andpl	r0, r1, #-1409286142	@ 0xac000002
     7c4:	dc03ab04 			@ <UNDEFINED> instruction: 0xdc03ab04
     7c8:	00560104 	subseq	r0, r6, r4, lsl #2
     7cc:	00000000 	andeq	r0, r0, r0
     7d0:	b203ae04 	andlt	sl, r3, #4, 28	@ 0x40
}
     7d4:	04500103 	ldrbeq	r0, [r0], #-259	@ 0xfffffefd
static int show_history(int argc, char **argv) {
     7d8:	04dc03b2 	ldrbeq	r0, [ip], #946	@ 0x3b2
  uint32_t end_index = total_num_commands-1;
     7dc:	02005801 	andeq	r5, r0, #65536	@ 0x10000
  if (total_num_commands > NUM_HISTORY_ENTRIES) {
     7e0:	04000000 	streq	r0, [r0], #-0
     7e4:	03b203ae 			@ <UNDEFINED> instruction: 0x03b203ae
    beg_index = total_num_commands - NUM_HISTORY_ENTRIES;
     7e8:	049f3202 	ldreq	r3, [pc], #514	@ 7f0 <show_history+0x18>
     7ec:	04dc03b2 	ldrbeq	r0, [ip], #946	@ 0x3b2
  uint32_t beg_index = 0;
     7f0:	00005701 	andeq	r5, r0, r1, lsl #14
    printf("%s\n", cmd_history[index % NUM_HISTORY_ENTRIES]);
     7f4:	04000000 	streq	r0, [r0], #-0
     7f8:	01ce01b8 	strheq	r0, [lr, #24]
     7fc:	ce045001 	cdpgt	0, 0, cr5, cr4, cr1, {0}
     800:	0103a001 	tsteq	r3, r1
  for (uint32_t index = beg_index; index <= end_index; ++index) {
     804:	00000054 	andeq	r0, r0, r4, asr r0
}
     808:	b8040000 	stmdalt	r4, {}	@ <UNPREDICTABLE>
     80c:	0101ce01 	tsteq	r1, r1, lsl #28
     810:	01ce0451 	biceq	r0, lr, r1, asr r4
     814:	580103a0 	stmdapl	r1, {r5, r7, r8, r9}
int cmd_exec_status(int argc, char **argv) {
     818:	00000000 	andeq	r0, r0, r0
  printf("%d\n", __cmd_exec_status);
     81c:	01b80400 			@ <UNDEFINED> instruction: 0x01b80400
     820:	520101ce 	andpl	r0, r1, #-2147483597	@ 0x80000033
     824:	a001ce04 	andge	ip, r1, r4, lsl #28
}
     828:	00550103 	subseq	r0, r5, r3, lsl #2
     82c:	ca040000 	bgt	100834 <__ROM_SIZE__+0xc0834>
     830:	0103a001 	tsteq	r3, r1
static int build_info(int argc, char **argv) {
     834:	00020057 	andeq	r0, r2, r7, asr r0
  printf("Build: [" SHELL_VERSION ":" USER_REPO_VERSION "] - [" BUILD_USER
     838:	ca040000 	bgt	100840 <__ROM_SIZE__+0xc0840>
}
     83c:	0201ce01 	andeq	ip, r1, #1, 28
     840:	ce049f30 	mcrgt	15, 0, r9, cr4, cr0, {1}
static void execute(int argc, char **argv) {
     844:	0103a001 	tsteq	r3, r1
     848:	00000056 	andeq	r0, r0, r6, asr r0
  for (int i = 0; table[i].command_name != NULL; i++) {
     84c:	84040000 	strhi	r0, [r4], #-0
     850:	01018e01 	tsteq	r1, r1, lsl #28
     854:	018e0450 	orreq	r0, lr, r0, asr r4
     858:	540101a2 	strpl	r0, [r1], #-418	@ 0xfffffe5e
     85c:	00000000 	andeq	r0, r0, r0
    if (strcmp(argv[0], table[i].command_name) == 0) {
     860:	04000000 	streq	r0, [r0], #-0
     864:	018e0184 	orreq	r0, lr, r4, lsl #3
      __cmd_exec_status = table[i].command(argc, &argv[0]);
     868:	8e045101 	adfhis	f5, f4, f1
     86c:	0101a201 	tsteq	r1, r1, lsl #4
     870:	01a20456 			@ <UNDEFINED> instruction: 0x01a20456
     874:	540101ac 	strpl	r0, [r1], #-428	@ 0xfffffe54
     878:	00000100 	andeq	r0, r0, r0, lsl #2
    printf("\"%s\": command not found. Use \"help\" to list all command.\n",
     87c:	018a0400 	orreq	r0, sl, r0, lsl #8
     880:	5001018e 	andpl	r0, r1, lr, lsl #3
    __cmd_exec_status = -1;
     884:	b8018e04 	stmdalt	r1, {r2, r9, sl, fp, pc}
     888:	00550101 	subseq	r0, r5, r1, lsl #2
     88c:	00000000 	andeq	r0, r0, r0
}
     890:	70040000 	andvc	r0, r4, r0
     894:	04500172 	ldrbeq	r0, [r0], #-370	@ 0xfffffe8e
     898:	70037872 	andvc	r7, r3, r2, ror r8
     89c:	78049f7e 	stmdavc	r4, {r1, r2, r3, r4, r5, r6, r8, r9, sl, fp, ip, pc}
int help(int argc, char **argv) {
     8a0:	a3040184 	movwge	r0, #16772	@ 0x4184
  if (argc > 1 && (strcmp(argv[1], "-l")==0)) {
     8a4:	009f5001 	addseq	r5, pc, r1
     8a8:	00000000 	andeq	r0, r0, r0
     8ac:	01363204 	teqeq	r6, r4, lsl #4
     8b0:	70360450 	eorsvc	r0, r6, r0, asr r4
    printf("use: help -l for list only.\n\n");
     8b4:	5001a304 	andpl	sl, r1, r4, lsl #6
  bool verbose = true;
     8b8:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
	...
  while (table[i].command_name != NULL) {
     8d0:	00040000 	andeq	r0, r4, r0
    printf(table[i].command_name);
     8d4:	04500116 	ldrbeq	r0, [r0], #-278	@ 0xfffffeea
    if (verbose) {
     8d8:	a3041816 	movwge	r1, #18454	@ 0x4816
      printf("\n\t");
     8dc:	049f5001 	ldreq	r5, [pc], #1	@ 8e4 <help+0x44>
      printf(table[i].command_help);
     8e0:	50011a18 	andpl	r1, r1, r8, lsl sl
     8e4:	041e1a04 	ldreq	r1, [lr], #-2564	@ 0xfffff5fc
     8e8:	9f5001a3 	svcls	0x005001a3
    verbose = false;
     8ec:	01201e04 			@ <UNDEFINED> instruction: 0x01201e04
}
     8f0:	24200450 	strtcs	r0, [r0], #-1104	@ 0xfffffbb0
     8f4:	5001a304 	andpl	sl, r1, r4, lsl #6
     8f8:	2624049f 			@ <UNDEFINED> instruction: 0x2624049f
     8fc:	26045001 	strcs	r5, [r4], -r1
     900:	01a3042a 			@ <UNDEFINED> instruction: 0x01a3042a
     904:	2a049f50 	bcs	12864c <__ROM_SIZE__+0xe864c>
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
     908:	0450012c 	ldrbeq	r0, [r0], #-300	@ 0xfffffed4
static void add_command_to_history(const char *cmd_str) {
     90c:	a3042e2c 	movwge	r2, #20012	@ 0x4e2c
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
     910:	049f5001 	ldreq	r5, [pc], #1	@ 918 <add_command_to_history+0x10>
     914:	5001302e 	andpl	r3, r1, lr, lsr #32
  int index = total_num_commands % NUM_HISTORY_ENTRIES;
     918:	04323004 	ldrteq	r3, [r2], #-4
     91c:	9f5001a3 	svcls	0x005001a3
     920:	00038c00 	andeq	r8, r3, r0, lsl #24
     924:	04000500 	streq	r0, [r0], #-1280	@ 0xfffffb00
	...
  curr_command_ptr = total_num_commands;
     93c:	02dc0400 	sbcseq	r0, ip, #0, 8
     940:	910202ee 	smlattls	r2, lr, r2, r0
     944:	02ee0470 	rsceq	r0, lr, #112, 8	@ 0x70000000
     948:	540103f0 	strpl	r0, [r1], #-1008	@ 0xfffffc10
     94c:	8403f004 	strhi	pc, [r3], #-4
static int parse_line(char **argv, char *line_buff, int argument_size) {
     950:	04550104 	ldrbeq	r0, [r5], #-260	@ 0xfffffefc
     954:	04880484 	streq	r0, [r8], #1156	@ 0x484
  int length = strlen(line_buff);
     958:	88045401 	stmdahi	r4, {r0, sl, ip, lr}
     95c:	01048e04 	tsteq	r4, r4, lsl #28
  int argc = 0;
     960:	048e0455 	streq	r0, [lr], #1109	@ 0x455
         pos++)
     964:	5401049e 	strpl	r0, [r1], #-1182	@ 0xfffffb62
    for (; line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
     968:	a2049e04 	andge	r9, r4, #4, 28	@ 0x40
     96c:	04550104 	ldrbeq	r0, [r5], #-260	@ 0xfffffefc
     970:	04b804ac 	ldrteq	r0, [r8], #1196	@ 0x4ac
     974:	01005401 	tsteq	r0, r1, lsl #8
    if (line_buff[pos] == '\t' || line_buff[pos] == SPACE)
     978:	01010000 	mrseq	r0, (UNDEF: 1)
     97c:	01010000 	mrseq	r0, (UNDEF: 1)
      line_buff[pos] = END_OF_LINE;
     980:	01010000 	mrseq	r0, (UNDEF: 1)
  while (pos <= length) {
     984:	01010000 	mrseq	r0, (UNDEF: 1)
    if (line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
     988:	01000000 	mrseq	r0, (UNDEF: 0)
     98c:	01010000 	mrseq	r0, (UNDEF: 1)
     990:	04000000 	streq	r0, [r0], #-0
     994:	02ee02e8 	rsceq	r0, lr, #232, 4	@ 0x8000000e
      argv[argc++] = &line_buff[pos];
     998:	049f3002 	ldreq	r3, [pc], #2	@ 9a0 <parse_line+0x50>
     99c:	038802ee 	orreq	r0, r8, #-536870898	@ 0xe000000e
}
     9a0:	88045501 	stmdahi	r4, {r0, r8, sl, ip, lr}
static int prefix_match(char *sub, int len, const char *str) {
     9a4:	02038e03 	andeq	r8, r3, #3, 28	@ 0x30
     9a8:	8e049f31 	mcrhi	15, 0, r9, cr4, cr1, {1}
  if (sub == NULL || str == NULL || len <= 0 || len > strlen(str)) {
     9ac:	0103bc03 	tsteq	r3, r3, lsl #24
     9b0:	03bc0455 			@ <UNDEFINED> instruction: 0x03bc0455
     9b4:	300203c0 	andcc	r0, r2, r0, asr #7
     9b8:	03c0049f 	biceq	r0, r0, #-1627389952	@ 0x9f000000
  for (int i = 0; i<len; ++i) {
     9bc:	550103d6 	strpl	r0, [r1, #-982]	@ 0xfffffc2a
     9c0:	da03d604 	ble	f61d8 <__ROM_SIZE__+0xb61d8>
    if (sub[i] != str[i]) {
     9c4:	9f300203 	svcls	0x00300203
     9c8:	ea03da04 	b	f71e0 <__ROM_SIZE__+0xb71e0>
  for (int i = 0; i<len; ++i) {
     9cc:	04550103 	ldrbeq	r0, [r5], #-259	@ 0xfffffefd
}
     9d0:	03ee03ea 	mvneq	r0, #-1476395005	@ 0xa8000003
  return TRUE;
     9d4:	049f3002 	ldreq	r3, [pc], #2	@ 9dc <prefix_match+0x3a>
      return FALSE;
     9d8:	03f003ee 	mvnseq	r0, #-1207959549	@ 0xb8000003
}
     9dc:	82045501 	andhi	r5, r4, #4194304	@ 0x400000
static void handle_up_arrow(char *cmd_buff, int *char_count) {
     9e0:	02048804 	andeq	r8, r4, #4, 16	@ 0x40000
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
     9e4:	8e049f30 	mcrhi	15, 0, r9, cr4, cr0, {1}
     9e8:	01049804 	tsteq	r4, r4, lsl #16
     9ec:	04980455 	ldreq	r0, [r8], #1109	@ 0x455
     9f0:	3002049e 	mulcc	r2, lr, r4
      curr_command_ptr == 0) {
     9f4:	04ac049f 	strteq	r0, [ip], #1183	@ 0x49f
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
     9f8:	550104b8 	strpl	r0, [r1, #-1208]	@ 0xfffffb48
    printf("%s", cmd_buff);
     9fc:	00000100 	andeq	r0, r0, r0, lsl #2
     a00:	01010000 	mrseq	r0, (UNDEF: 1)
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
     a04:	03ee0400 	mvneq	r0, #0, 8
     a08:	310203f8 	strdcc	r0, [r2, -r8]
  curr_command_ptr--;
     a0c:	03f8049f 	mvnseq	r0, #-1627389952	@ 0x9f000000
     a10:	520103ff 	andpl	r0, r1, #-67108861	@ 0xfc000003
     a14:	88048804 	stmdahi	r4, {r2, fp, pc}
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
     a18:	9f310204 	svcls	0x00310204
     a1c:	8e048804 	cdphi	8, 0, cr8, cr4, cr4, {0}
     a20:	9f320204 	svcls	0x00320204
	...
  printf("%s", cmd_buff);
     a40:	4c1c0400 	cfldrsmi	mvf0, [ip], {-0}
     a44:	4c045001 	stcmi	0, cr5, [r4], {1}
     a48:	01a30452 			@ <UNDEFINED> instruction: 0x01a30452
     a4c:	52049f50 	andpl	r9, r4, #80, 30	@ 0x140
static void handle_down_arrow(char *cmd_buff, int *char_count) {
     a50:	04500158 	ldrbeq	r0, [r0], #-344	@ 0xfffffea8
     a54:	a3046258 	movwge	r6, #16984	@ 0x4258
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
     a58:	049f5001 	ldreq	r5, [pc], #1	@ a60 <handle_down_arrow+0x10>
     a5c:	50017262 	andpl	r7, r1, r2, ror #4
  *char_count = 0;
     a60:	01a27204 			@ <UNDEFINED> instruction: 0x01a27204
  if (curr_command_ptr == total_num_commands) return;
     a64:	5001a304 	andpl	sl, r1, r4, lsl #6
     a68:	01a2049f 			@ <UNDEFINED> instruction: 0x01a2049f
     a6c:	500101a8 	andpl	r0, r1, r8, lsr #3
  curr_command_ptr++;
     a70:	b401a804 	strlt	sl, [r1], #-2052	@ 0xfffff7fc
     a74:	01a30402 			@ <UNDEFINED> instruction: 0x01a30402
     a78:	b4049f50 	strlt	r9, [r4], #-3920	@ 0xfffff0b0
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
     a7c:	0102ba02 	tsteq	r2, r2, lsl #20
     a80:	02ba0450 	adcseq	r0, sl, #80, 8	@ 0x50000000
     a84:	a30402be 	movwge	r0, #17086	@ 0x42be
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
     a88:	049f5001 	ldreq	r5, [pc], #1	@ a90 <handle_down_arrow+0x40>
     a8c:	02c002be 	sbceq	r0, r0, #-536870901	@ 0xe000000b
     a90:	c0045001 	andgt	r5, r4, r1
     a94:	0402c202 	streq	ip, [r2], #-514	@ 0xfffffdfe
  *char_count = strlen(cmd_buff);
     a98:	9f5001a3 	svcls	0x005001a3
     a9c:	c402c204 	strgt	ip, [r2], #-516	@ 0xfffffdfc
  printf("%s", cmd_buff);
     aa0:	04500102 	ldrbeq	r0, [r0], #-258	@ 0xfffffefe
     aa4:	02dc02c4 	sbcseq	r0, ip, #196, 4	@ 0x4000000c
}
     aa8:	5001a304 	andpl	sl, r1, r4, lsl #6
     aac:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
	...
void set_read_char2(int (*func)(void)) { __read_char2__ = func; }
     ac4:	014d1c04 	cmpeq	sp, r4, lsl #24
void set_write_char(void (*func)(char)) { __write_char__ = func; }
     ac8:	524d0451 	subpl	r0, sp, #1358954496	@ 0x51000000
     acc:	5101a304 	tstpl	r1, r4, lsl #6
     ad0:	5b52049f 	blpl	1481d54 <__ROM_SIZE__+0x1441d54>
void set_write_char2(void (*func)(char)) { __write_char2__ = func; }
     ad4:	5b045101 	blpl	114ee0 <__ROM_SIZE__+0xd4ee0>
     ad8:	01a30462 			@ <UNDEFINED> instruction: 0x01a30462
     adc:	62049f51 	andvs	r9, r4, #324	@ 0x144
}
     ae0:	04510172 	ldrbeq	r0, [r1], #-370	@ 0xfffffe8e
}
     ae4:	0401a272 	streq	sl, [r1], #-626	@ 0xfffffd8e
  if (cmd_buff == NULL || char_count <= 0) {
     ae8:	9f5101a3 	svcls	0x005101a3
static void handle_tab(char *cmd_buff, int *char_count) {
     aec:	a901a204 	stmdbge	r1, {r2, r9, sp, pc}
     af0:	04510101 	ldrbeq	r0, [r1], #-257	@ 0xfffffeff
  int last_match = -1;
     af4:	02b401a9 	adcseq	r0, r4, #1073741866	@ 0x4000002a
  int match_count = 0;
     af8:	5101a304 	tstpl	r1, r4, lsl #6
  int i = 0;
     afc:	02b4049f 	adcseq	r0, r4, #-1627389952	@ 0x9f000000
    i++;
     b00:	510102ba 			@ <UNDEFINED> instruction: 0x510102ba
  while (table[i].command_name != NULL) { //loop over all commands
     b04:	be02ba04 	vmlalt.f32	s22, s4, s8
     b08:	01a30402 			@ <UNDEFINED> instruction: 0x01a30402
     b0c:	be049f51 	mcrlt	15, 0, r9, cr4, cr1, {2}
    if (prefix_match(cmd_buff, *char_count, table[i].command_name)) {
     b10:	0102dc02 	tsteq	r2, r2, lsl #24
     b14:	00000051 	andeq	r0, r0, r1, asr r0
	...
  if (match_count == 1) {
     b30:	013a1c04 	teqeq	sl, r4, lsl #24
  if (match_count) {
     b34:	523a0452 	eorspl	r0, sl, #1375731712	@ 0x52000000
}
     b38:	52045401 	andpl	r5, r4, #16777216	@ 0x1000000
    memcpy(cmd_buff, table[last_match].command_name, LINE_BUFF_SIZE);
     b3c:	0452015b 	ldrbeq	r0, [r2], #-347	@ 0xfffffea5
     b40:	54015e5b 	strpl	r5, [r1], #-3675	@ 0xfffff1a5
     b44:	04625e04 	strbteq	r5, [r2], #-3588	@ 0xfffff1fc
     b48:	9f5201a3 	svcls	0x005201a3
    *char_count = strlen(cmd_buff);
     b4c:	016a6204 	cmneq	sl, r4, lsl #4
     b50:	726a0452 	rsbvc	r0, sl, #1375731712	@ 0x52000000
     b54:	72045401 	andvc	r5, r4, #16777216	@ 0x1000000
    printf("\n");
     b58:	a30401a2 	movwge	r0, #16802	@ 0x41a2
     b5c:	049f5201 	ldreq	r5, [pc], #513	@ b64 <handle_tab+0x7e>
    prepend_prompt();
     b60:	01ae01a2 			@ <UNDEFINED> instruction: 0x01ae01a2
    printf(PROMPT);
     b64:	ae045401 	cdpge	4, 0, cr5, cr4, cr1, {0}
     b68:	0402b401 	streq	fp, [r2], #-1025	@ 0xfffffbff
    printf("%s", cmd_buff);
     b6c:	9f5201a3 	svcls	0x005201a3
     b70:	b802b404 	stmdalt	r2, {r2, sl, ip, sp, pc}
     b74:	04540102 	ldrbeq	r0, [r4], #-258	@ 0xfffffefe
     b78:	02be02b8 	adcseq	r0, lr, #184, 4	@ 0x8000000b
     b7c:	5201a304 	andpl	sl, r1, #4, 6	@ 0x10000000
     b80:	02be049f 	adcseq	r0, lr, #-1627389952	@ 0x9f000000
     b84:	520102dc 	andpl	r0, r1, #220, 4	@ 0xc000000d
__attribute__((weak)) int active_prompt() { return TRUE; }
     b88:	00000200 	andeq	r0, r0, r0, lsl #4
	...
  for (int i = 0; i < LINE_BUFF_SIZE; i++) line_buff[i] = 0;
     b98:	04000000 	streq	r0, [r0], #-0
     b9c:	30025e22 	andcc	r5, r2, r2, lsr #28
     ba0:	7262049f 	rsbvc	r0, r2, #-1627389952	@ 0x9f000000
     ba4:	049f3002 	ldreq	r3, [pc], #2	@ bac <shell+0x20>
  for (int i = 0; i < MAX_ARG_COUNT; i++) argv[i] = NULL;
     ba8:	01019472 	tsteq	r1, r2, ror r4
     bac:	01940454 	orrseq	r0, r4, r4, asr r4
     bb0:	740301a2 	strvc	r0, [r3], #-418	@ 0xfffffe5e
     bb4:	a2049f7f 	andge	r9, r4, #508	@ 0x1fc
     bb8:	0201ae01 	andeq	sl, r1, #1, 28
  prepend_prompt();
     bbc:	ae049f30 	mcrge	15, 0, r9, cr4, cr0, {1}
  printf(PROMPT);
     bc0:	0101e801 	tsteq	r1, r1, lsl #16
  int special_key = 0;
     bc4:	01e80454 	mvneq	r0, r4, asr r4
        special_key = 1;
     bc8:	740301f4 	strvc	r0, [r3], #-500	@ 0xfffffe0c
    if (s == -1) { s = __read_char2__();}
     bcc:	f4049f7f 			@ <UNDEFINED> instruction: 0xf4049f7f
     bd0:	01029201 	tsteq	r2, r1, lsl #4
    if (s != -1) {
     bd4:	02920454 	addseq	r0, r2, #84, 8	@ 0x54000000
     bd8:	300202dc 	ldrdcc	r0, [r2], -ip
      loop();
     bdc:	0001009f 	muleq	r1, pc, r0	@ <UNPREDICTABLE>
	...
        line_buff[count] = END_OF_LINE;
     be8:	026e6204 	rsbeq	r6, lr, #4, 4	@ 0x40000000
     bec:	72049f30 	andvc	r9, r4, #48, 30	@ 0xc0
        __write_char__(NEW_LINE);
     bf0:	5501019c 	strpl	r0, [r1, #-412]	@ 0xfffffe64
     bf4:	a2019c04 	andge	r9, r1, #4, 24	@ 0x400
  add_command_to_history(line_buff);
     bf8:	04510101 	ldrbeq	r0, [r1], #-257	@ 0xfffffeff
  argc = parse_line(argv, line_buff, MAX_ARG_COUNT);
     bfc:	01ca01ac 	biceq	r0, sl, ip, lsr #3
     c00:	be045501 	cfsh32lt	mvfx5, mvfx4, #1
     c04:	0202c202 	andeq	ip, r2, #536870912	@ 0x20000000
  if (argc > 0) execute(argc, argv);
     c08:	01009f30 	tsteq	r0, r0, lsr pc
	...
        if (!__echo) {
     c14:	3e300400 	cfabsscc	mvf0, mvf0
        if (count == 0) continue;
     c18:	049f3002 	ldreq	r3, [pc], #2	@ c20 <shell+0x94>
        count--;
     c1c:	01f001ca 	mvnseq	r0, sl, asr #3
        line_buff[count] = END_OF_LINE;
     c20:	f0045501 			@ <UNDEFINED> instruction: 0xf0045501
     c24:	0101f401 	tsteq	r1, r1, lsl #8	@ <UNPREDICTABLE>
     c28:	01f40451 	mvnseq	r0, r1, asr r4
        delete ();
     c2c:	55010292 	strpl	r0, [r1, #-658]	@ 0xfffffd6e
      if (__echo) {
     c30:	dc02c204 	sfmle	f4, 1, [r2], {4}
        __write_char__(c);
     c34:	9f300202 	svcls	0x00300202
     c38:	00000000 	andeq	r0, r0, r0
    if (!active_prompt()) {
     c3c:	02920400 	addseq	r0, r2, #0, 8
     c40:	540102b4 	strpl	r0, [r1], #-692	@ 0xfffffd4c
    s = __read_char__();
     c44:	be02ba04 	vmlalt.f32	s22, s4, s8
     c48:	00540102 	subseq	r0, r4, r2, lsl #2
    if (s == -1) { s = __read_char2__();}
     c4c:	00010100 	andeq	r0, r1, r0, lsl #2
     c50:	00000000 	andeq	r0, r0, r0
      if (c == CARRIAGE_RETURN || c == NEW_LINE) {
     c54:	92029204 	andls	r9, r2, #4, 4	@ 0x40000000
     c58:	04520102 	ldrbeq	r0, [r2], #-258	@ 0xfffffefe
      if (c == DELETE || c == BACK_SPACE) {
     c5c:	029e0292 	addseq	r0, lr, #536870921	@ 0x20000009
     c60:	049f3102 	ldreq	r3, [pc], #258	@ c68 <shell+0xdc>
      } else if (c == ESCAPE) {
     c64:	02b4029e 	adcseq	r0, r4, #-536870903	@ 0xe0000009
      } else if (c == SQUARE_BRACKET_OPEN && special_key == 1) {
     c68:	ba045201 	blt	115474 <__ROM_SIZE__+0xd5474>
      } else if ((c == 'C' || c == 'D') && special_key != 0) {
     c6c:	0102be02 	tsteq	r2, r2, lsl #28
     c70:	00000052 	andeq	r0, r0, r2, asr r0
     c74:	00000000 	andeq	r0, r0, r0
      } else if ((c == 'A' || c == 'B') && special_key == 2) {
     c78:	92040000 	andls	r0, r4, #0
     c7c:	01029b02 	tsteq	r2, r2, lsl #22
      else if (c == TAB) {
     c80:	029b0453 	addseq	r0, fp, #1392508928	@ 0x53000000
        line_buff[count] = c;
     c84:	750802a0 	strvc	r0, [r8, #-672]	@ 0xfffffd60
     c88:	25007400 	strcs	r7, [r0, #-1024]	@ 0xfffffc00
     c8c:	049f1a3f 	ldreq	r1, [pc], #2623	@ c94 <shell+0x108>
        count++;
     c90:	02ac02a8 	adceq	r0, ip, #168, 4	@ 0x8000000a
     c94:	3f007305 	svccc	0x00007305
          delete ();
     c98:	ac049f1a 	stcge	15, cr9, [r4], {26}
          delete ();
     c9c:	0102b402 	tsteq	r2, r2, lsl #8
      } else if (c == SQUARE_BRACKET_OPEN && special_key == 1) {
     ca0:	00000053 	andeq	r0, r0, r3, asr r0
        special_key = 2;
     ca4:	00040000 	andeq	r0, r4, r0
      } else if ((c == 'C' || c == 'D') && special_key != 0) {
     ca8:	04500106 	ldrbeq	r0, [r0], #-262	@ 0xfffffefa
        special_key = 0;
     cac:	54011606 	strpl	r1, [r1], #-1542	@ 0xfffff9fa
      } else if ((c == 'A' || c == 'B') && special_key == 2) {
     cb0:	00038c00 	andeq	r8, r3, r0, lsl #24
        if (!__echo) {
     cb4:	04000500 	streq	r0, [r0], #-1280	@ 0xfffffb00
	...
          handle_down_arrow(line_buff, &count);
     ccc:	02dc0400 	sbcseq	r0, ip, #0, 8
        continue;
     cd0:	910202ee 	smlattls	r2, lr, r2, r0
          clear_prompt(count);
     cd4:	02ee0470 	rsceq	r0, lr, #112, 8	@ 0x70000000
     cd8:	540103f0 	strpl	r0, [r1], #-1008	@ 0xfffffc10
          handle_up_arrow(line_buff, &count);
     cdc:	8403f004 	strhi	pc, [r3], #-4
     ce0:	04550104 	ldrbeq	r0, [r5], #-260	@ 0xfffffefc
        handle_tab(line_buff, &count);
     ce4:	04880484 	streq	r0, [r8], #1156	@ 0x484
     ce8:	88045401 	stmdahi	r4, {r0, sl, ip, lr}
        continue;
     cec:	01048e04 	tsteq	r4, r4, lsl #28
  if (argc > 0) execute(argc, argv);
     cf0:	048e0455 	streq	r0, [lr], #1109	@ 0x455
}
     cf4:	5401049e 	strpl	r0, [r1], #-1182	@ 0xfffffb62
     cf8:	a2049e04 	andge	r9, r4, #4, 28	@ 0x40
     cfc:	04550104 	ldrbeq	r0, [r5], #-260	@ 0xfffffefc
     d00:	04b804ac 	ldrteq	r0, [r8], #1196	@ 0x4ac
void prompt() {
     d04:	01005401 	tsteq	r0, r1, lsl #8
  initial_setup();
     d08:	01010000 	mrseq	r0, (UNDEF: 1)
  exec_auto_cmds();
     d0c:	01010000 	mrseq	r0, (UNDEF: 1)
  setup();
     d10:	01010000 	mrseq	r0, (UNDEF: 1)
    shell();
     d14:	01010000 	mrseq	r0, (UNDEF: 1)
int exec(char *cmd_str) {
     d18:	01000000 	mrseq	r0, (UNDEF: 0)
     d1c:	01010000 	mrseq	r0, (UNDEF: 1)
  argc = parse_line(argv, cmd_str, MAX_ARG_COUNT);
     d20:	04000000 	streq	r0, [r0], #-0
     d24:	02ee02e8 	rsceq	r0, lr, #232, 4	@ 0x8000000e
  if (argc > 0) execute(argc, argv);
     d28:	049f3002 	ldreq	r3, [pc], #2	@ d30 <exec+0x18>
  return __cmd_exec_status;
     d2c:	038802ee 	orreq	r0, r8, #-536870898	@ 0xe000000e
}
     d30:	88045501 	stmdahi	r4, {r0, r8, sl, ip, lr}
     d34:	02038e03 	andeq	r8, r3, #3, 28	@ 0x30
  if (argc > 0) execute(argc, argv);
     d38:	8e049f31 	mcrhi	15, 0, r9, cr4, cr1, {1}
     d3c:	0103bc03 	tsteq	r3, r3, lsl #24
     d40:	03bc0455 			@ <UNDEFINED> instruction: 0x03bc0455
cmd get_function_addr(char *cmd_str) {
     d44:	300203c0 	andcc	r0, r2, r0, asr #7
  for (int i = 0; table[i].command_name != NULL; i++) {
     d48:	03c0049f 	biceq	r0, r0, #-1627389952	@ 0x9f000000
     d4c:	550103d6 	strpl	r0, [r1, #-982]	@ 0xfffffc2a
     d50:	da03d604 	ble	f6568 <__ROM_SIZE__+0xb6568>
     d54:	9f300203 	svcls	0x00300203
     d58:	ea03da04 	b	f7570 <__ROM_SIZE__+0xb7570>
    if (strcmp(cmd_str, table[i].command_name) == 0) {
     d5c:	04550103 	ldrbeq	r0, [r5], #-259	@ 0xfffffefd
     d60:	03ee03ea 	mvneq	r0, #-1476395005	@ 0xa8000003
      return table[i].command;
     d64:	049f3002 	ldreq	r3, [pc], #2	@ d6c <get_function_addr+0x28>
     d68:	03f003ee 	mvnseq	r0, #-1207959549	@ 0xb8000003
  return NULL;
     d6c:	82045501 	andhi	r5, r4, #4194304	@ 0x400000
}
     d70:	02048804 	andeq	r8, r4, #4, 16	@ 0x40000
  if(v < 26) return v + 'A';
     d74:	8e049f30 	mcrhi	15, 0, r9, cr4, cr0, {1}
  if(v < 52) return v + 71;
     d78:	01049804 	tsteq	r4, r4, lsl #16
  if(v < 62) return v - 4;
     d7c:	04980455 	ldreq	r0, [r8], #1109	@ 0x455
  if(v == 62) return '+';
     d80:	3002049e 	mulcc	r2, lr, r4
  if(v == 63) return '/';
     d84:	04ac049f 	strteq	r0, [ip], #1183	@ 0x49f
  return 64;
     d88:	550104b8 	strpl	r0, [r1, #-1208]	@ 0xfffffb48
  if(v < 26) return v + 'A';
     d8c:	00000100 	andeq	r0, r0, r0, lsl #2
     d90:	01010000 	mrseq	r0, (UNDEF: 1)
  if(v < 52) return v + 71;
     d94:	03ee0400 	mvneq	r0, #0, 8
  if(v < 62) return v - 4;
     d98:	310203f8 	strdcc	r0, [r2, -r8]
     d9c:	03f8049f 	mvnseq	r0, #-1627389952	@ 0x9f000000
  if(v == 62) return '+';
     da0:	520103ff 	andpl	r0, r1, #-67108861	@ 0xfc000003
}
     da4:	88048804 	stmdahi	r4, {r2, fp, pc}
  if('A' <= c && c <= 'Z') return c - 'A';
     da8:	9f310204 	svcls	0x00310204
     dac:	8e048804 	cdphi	8, 0, cr8, cr4, cr4, {0}
  if('a' <= c && c <= 'z') return c - 71;
     db0:	9f320204 	svcls	0x00320204
	...
     dd0:	4c1c0400 	cfldrsmi	mvf0, [ip], {-0}
     dd4:	4c045001 	stcmi	0, cr5, [r4], {1}
  if('0' <= c && c <= '9') return c + 4;
     dd8:	01a30452 			@ <UNDEFINED> instruction: 0x01a30452
  if(c == '+') return 62;
     ddc:	52049f50 	andpl	r9, r4, #80, 30	@ 0x140
  if(c == '/') return 63;
     de0:	04500158 	ldrbeq	r0, [r0], #-344	@ 0xfffffea8
  return (input_length + 2)/3*4;
     de4:	a3046258 	movwge	r6, #16984	@ 0x4258
     de8:	049f5001 	ldreq	r5, [pc], #1	@ df0 <encode_base64_length+0xc>
     dec:	50017262 	andpl	r7, r1, r2, ror #4
}
     df0:	01a27204 			@ <UNDEFINED> instruction: 0x01a27204
     df4:	5001a304 	andpl	sl, r1, r4, lsl #6
unsigned int decode_base64_length(unsigned char input[], unsigned int input_length) {
     df8:	01a2049f 			@ <UNDEFINED> instruction: 0x01a2049f
     dfc:	500101a8 	andpl	r0, r1, r8, lsr #3
  while(base64_to_binary(input[0]) < 64 && (unsigned int) (input - start) < input_length) {
     e00:	b401a804 	strlt	sl, [r1], #-2052	@ 0xfffff7fc
     e04:	01a30402 			@ <UNDEFINED> instruction: 0x01a30402
     e08:	b4049f50 	strlt	r9, [r4], #-3920	@ 0xfffff0b0
     e0c:	0102ba02 	tsteq	r2, r2, lsl #20
     e10:	02ba0450 	adcseq	r0, sl, #80, 8	@ 0x50000000
  input_length = input - start;
     e14:	a30402be 	movwge	r0, #17086	@ 0x42be
  return input_length/4*3 + (input_length % 4 ? input_length % 4 - 1 : 0);
     e18:	049f5001 	ldreq	r5, [pc], #1	@ e20 <decode_base64_length+0x28>
     e1c:	02c002be 	sbceq	r0, r0, #-536870901	@ 0xe000000b
     e20:	c0045001 	andgt	r5, r4, r1
}
     e24:	0402c202 	streq	ip, [r2], #-514	@ 0xfffffdfe
  return input_length/4*3 + (input_length % 4 ? input_length % 4 - 1 : 0);
     e28:	9f5001a3 	svcls	0x005001a3
unsigned int encode_base64(unsigned char input[], unsigned int input_length, unsigned char output[]) {
     e2c:	c402c204 	strgt	ip, [r2], #-516	@ 0xfffffdfc
     e30:	04500102 	ldrbeq	r0, [r0], #-258	@ 0xfffffefe
     e34:	02dc02c4 	sbcseq	r0, ip, #196, 4	@ 0x4000000c
  unsigned int full_sets = input_length/3;
     e38:	5001a304 	andpl	sl, r1, r4, lsl #6
     e3c:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
	...
    output[1] = binary_to_base64((input[0] & 0x03) << 4 | input[1] >> 4);
     e54:	014d1c04 	cmpeq	sp, r4, lsl #24
     e58:	524d0451 	subpl	r0, sp, #1358954496	@ 0x51000000
     e5c:	5101a304 	tstpl	r1, r4, lsl #6
    output[2] = binary_to_base64((input[1] & 0x0F) << 2 | input[2] >> 6);
     e60:	5b52049f 	blpl	14820e4 <__ROM_SIZE__+0x14420e4>
     e64:	5b045101 	blpl	115270 <__ROM_SIZE__+0xd5270>
     e68:	01a30462 			@ <UNDEFINED> instruction: 0x01a30462
     e6c:	62049f51 	andvs	r9, r4, #324	@ 0x144
     e70:	04510172 	ldrbeq	r0, [r1], #-370	@ 0xfffffe8e
    output[3] = binary_to_base64( input[2] & 0x3F);
     e74:	0401a272 	streq	sl, [r1], #-626	@ 0xfffffd8e
     e78:	9f5101a3 	svcls	0x005101a3
     e7c:	a901a204 	stmdbge	r1, {r2, r9, sp, pc}
    input += 3;
     e80:	04510101 	ldrbeq	r0, [r1], #-257	@ 0xfffffeff
  for(unsigned int i = 0; i < full_sets; ++i) {
     e84:	02b401a9 	adcseq	r0, r4, #1073741866	@ 0x4000002a
     e88:	5101a304 	tstpl	r1, r4, lsl #6
  switch(input_length % 3) {
     e8c:	02b4049f 	adcseq	r0, r4, #-1627389952	@ 0x9f000000
     e90:	510102ba 			@ <UNDEFINED> instruction: 0x510102ba
     e94:	be02ba04 	vmlalt.f32	s22, s4, s8
     e98:	01a30402 			@ <UNDEFINED> instruction: 0x01a30402
     e9c:	be049f51 	mcrlt	15, 0, r9, cr4, cr1, {2}
     ea0:	0102dc02 	tsteq	r2, r2, lsl #24
     ea4:	00000051 	andeq	r0, r0, r1, asr r0
	...
      output[1] = binary_to_base64((input[0] & 0x03) << 4);
     ec0:	013a1c04 	teqeq	sl, r4, lsl #24
     ec4:	523a0452 	eorspl	r0, sl, #1375731712	@ 0x52000000
     ec8:	52045401 	andpl	r5, r4, #16777216	@ 0x1000000
      output[2] = '=';
     ecc:	0452015b 	ldrbeq	r0, [r2], #-347	@ 0xfffffea5
      output[3] = '=';
     ed0:	54015e5b 	strpl	r5, [r1], #-3675	@ 0xfffff1a5
      output[4] = '\0';
     ed4:	04625e04 	strbteq	r5, [r2], #-3588	@ 0xfffff1fc
      output[0] = binary_to_base64(                         input[0] >> 2);
     ed8:	9f5201a3 	svcls	0x005201a3
     edc:	016a6204 	cmneq	sl, r4, lsl #4
     ee0:	726a0452 	rsbvc	r0, sl, #1375731712	@ 0x52000000
      output[1] = binary_to_base64((input[0] & 0x03) << 4 | input[1] >> 4);
     ee4:	72045401 	andvc	r5, r4, #16777216	@ 0x1000000
     ee8:	a30401a2 	movwge	r0, #16802	@ 0x41a2
     eec:	049f5201 	ldreq	r5, [pc], #513	@ ef4 <encode_base64+0xc8>
     ef0:	01ae01a2 			@ <UNDEFINED> instruction: 0x01ae01a2
     ef4:	ae045401 	cdpge	4, 0, cr5, cr4, cr1, {0}
      output[2] = binary_to_base64((input[1] & 0x0F) << 2);
     ef8:	0402b401 	streq	fp, [r2], #-1025	@ 0xfffffbff
     efc:	9f5201a3 	svcls	0x005201a3
     f00:	b802b404 	stmdalt	r2, {r2, sl, ip, sp, pc}
      output[3] = '=';
     f04:	04540102 	ldrbeq	r0, [r4], #-258	@ 0xfffffefe
      output[4] = '\0';
     f08:	02be02b8 	adcseq	r0, lr, #184, 4	@ 0x8000000b
      break;
     f0c:	5201a304 	andpl	sl, r1, #4, 6	@ 0x10000000
     f10:	02be049f 	adcseq	r0, lr, #-1627389952	@ 0x9f000000
unsigned int decode_base64(unsigned char input[], unsigned int input_length, unsigned char output[]) {
     f14:	520102dc 	andpl	r0, r1, #220, 4	@ 0xc000000d
     f18:	00000200 	andeq	r0, r0, r0, lsl #4
	...
    output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
     f28:	04000000 	streq	r0, [r0], #-0
     f2c:	30025e22 	andcc	r5, r2, r2, lsr #28
     f30:	7262049f 	rsbvc	r0, r2, #-1627389952	@ 0x9f000000
     f34:	049f3002 	ldreq	r3, [pc], #2	@ f3c <decode_base64+0x28>
     f38:	01019472 	tsteq	r1, r2, ror r4
    output[1] = base64_to_binary(input[1]) << 4 | base64_to_binary(input[2]) >> 2;
     f3c:	01940454 	orrseq	r0, r4, r4, asr r4
     f40:	740301a2 	strvc	r0, [r3], #-418	@ 0xfffffe5e
     f44:	a2049f7f 	andge	r9, r4, #508	@ 0x1fc
     f48:	0201ae01 	andeq	sl, r1, #1, 28
     f4c:	ae049f30 	mcrge	15, 0, r9, cr4, cr0, {1}
    output[2] = base64_to_binary(input[2]) << 6 | base64_to_binary(input[3]);
     f50:	0101e801 	tsteq	r1, r1, lsl #16
     f54:	01e80454 	mvneq	r0, r4, asr r4
     f58:	740301f4 	strvc	r0, [r3], #-500	@ 0xfffffe0c
     f5c:	f4049f7f 			@ <UNDEFINED> instruction: 0xf4049f7f
    input += 4;
     f60:	01029201 	tsteq	r2, r1, lsl #4
  for(unsigned int i = 2; i < output_length; i += 3) {
     f64:	02920454 	addseq	r0, r2, #84, 8	@ 0x54000000
     f68:	300202dc 	ldrdcc	r0, [r2], -ip
  switch(output_length % 3) {
     f6c:	0001009f 	muleq	r1, pc, r0	@ <UNPREDICTABLE>
	...
     f78:	026e6204 	rsbeq	r6, lr, #4, 4	@ 0x40000000
     f7c:	72049f30 	andvc	r9, r4, #48, 30	@ 0xc0
     f80:	5501019c 	strpl	r0, [r1, #-412]	@ 0xfffffe64
     f84:	a2019c04 	andge	r9, r1, #4, 24	@ 0x400
     f88:	04510101 	ldrbeq	r0, [r1], #-257	@ 0xfffffeff
      output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
     f8c:	01ca01ac 	biceq	r0, sl, ip, lsr #3
     f90:	be045501 	cfsh32lt	mvfx5, mvfx4, #1
     f94:	0202c202 	andeq	ip, r2, #536870912	@ 0x20000000
     f98:	01009f30 	tsteq	r0, r0, lsr pc
	...
      output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
     fa4:	3e300400 	cfabsscc	mvf0, mvf0
     fa8:	049f3002 	ldreq	r3, [pc], #2	@ fb0 <decode_base64+0x9c>
     fac:	01f001ca 	mvnseq	r0, sl, asr #3
     fb0:	f0045501 			@ <UNDEFINED> instruction: 0xf0045501
      output[1] = base64_to_binary(input[1]) << 4 | base64_to_binary(input[2]) >> 2;
     fb4:	0101f401 	tsteq	r1, r1, lsl #8	@ <UNPREDICTABLE>
     fb8:	01f40451 	mvnseq	r0, r1, asr r4
     fbc:	55010292 	strpl	r0, [r1, #-658]	@ 0xfffffd6e
     fc0:	dc02c204 	sfmle	f4, 1, [r2], {4}
     fc4:	9f300202 	svcls	0x00300202
  return output_length;
     fc8:	00000000 	andeq	r0, r0, r0
     fcc:	02920400 	addseq	r0, r2, #0, 8
static void outstr(const char *str) {
     fd0:	540102b4 	strpl	r0, [r1], #-692	@ 0xfffffd4c
  while (*str != '\0') {
     fd4:	be02ba04 	vmlalt.f32	s22, s4, s8
    __write_char__(*str);
     fd8:	00540102 	subseq	r0, r4, r2, lsl #2
    str++;
     fdc:	00010100 	andeq	r0, r1, r0, lsl #2
  while (*str != '\0') {
     fe0:	00000000 	andeq	r0, r0, r0
}
     fe4:	92029204 	andls	r9, r2, #4, 4	@ 0x40000000
     fe8:	04520102 	ldrbeq	r0, [r2], #-258	@ 0xfffffefe
static bool printf_numbers(const char fmt, va_list *args, int l_count) {
     fec:	029e0292 	addseq	r0, lr, #536870921	@ 0x20000009
     ff0:	049f3102 	ldreq	r3, [pc], #258	@ ff8 <printf_numbers+0xc>
  switch (fmt) {
     ff4:	02b4029e 	adcseq	r0, r4, #-536870903	@ 0xe0000009
     ff8:	ba045201 	blt	115804 <__ROM_SIZE__+0xd5804>
     ffc:	0102be02 	tsteq	r2, r2, lsl #28
      if (l_count == 0) {
    1000:	00000052 	andeq	r0, r0, r2, asr r0
    1004:	00000000 	andeq	r0, r0, r0
        value = va_arg(*args, unsigned int);
    1008:	92040000 	andls	r0, r4, #0
    100c:	01029b02 	tsteq	r2, r2, lsl #22
      if (fmt == 'u') {
    1010:	029b0453 	addseq	r0, fp, #1392508928	@ 0x53000000
        if (value == 0) {
    1014:	750802a0 	strvc	r0, [r8, #-672]	@ 0xfffffd60
          __write_char__(hextable[0]);
    1018:	25007400 	strcs	r7, [r0, #-1024]	@ 0xfffffc00
    101c:	049f1a3f 	ldreq	r1, [pc], #2623	@ 1024 <printf_numbers+0x38>
  return true;
    1020:	02ac02a8 	adceq	r0, ip, #168, 4	@ 0x8000000a
  switch (fmt) {
    1024:	3f007305 	svccc	0x00007305
      outstr("\nprintf-error\n");
    1028:	ac049f1a 	stcge	15, cr9, [r4], {26}
      return false;
    102c:	0102b402 	tsteq	r2, r2, lsl #8
}
    1030:	00000053 	andeq	r0, r0, r3, asr r0
      if (l_count == 0) {
    1034:	00040000 	andeq	r0, r4, r0
        value = va_arg(*args, int);
    1038:	04500106 	ldrbeq	r0, [r0], #-262	@ 0xfffffefa
    103c:	54011606 	strpl	r1, [r1], #-1542	@ 0xfffff9fa
      if (value < 0) {
    1040:	00027e00 	andeq	r7, r2, r0, lsl #28
        num[num_len++] = hextable[value % 10];
    1044:	04000500 	streq	r0, [r0], #-1280	@ 0xfffffb00
	...
    1050:	02900400 	addseq	r0, r0, #0, 8
    1054:	5001029a 	mulpl	r1, sl, r2
    1058:	e0029a04 	and	r9, r2, r4, lsl #20
    105c:	01a30402 			@ <UNDEFINED> instruction: 0x01a30402
    1060:	00009f50 	andeq	r9, r0, r0, asr pc
    1064:	04000000 	streq	r0, [r0], #-0
        value = value / 10;
    1068:	029d0290 	addseq	r0, sp, #144, 4
      } while (value > 0);
    106c:	9d045101 	stflss	f5, [r4, #-4]
    1070:	0102e002 	tsteq	r2, r2
        __write_char__('-');
    1074:	00000054 	andeq	r0, r0, r4, asr r0
    1078:	01000000 	mrseq	r0, (UNDEF: 0)
        value = -value;
    107c:	a202a004 	andge	sl, r2, #4
        __write_char__(num[--num_len]);
    1080:	04500102 	ldrbeq	r0, [r0], #-258	@ 0xfffffefe
    1084:	02be02a2 	adcseq	r0, lr, #536870922	@ 0x2000000a
    1088:	c0045501 	andgt	r5, r4, r1, lsl #10
    108c:	0102c602 	tsteq	r2, r2, lsl #12
    1090:	00000055 	andeq	r0, r0, r5, asr r0
      while (num_len > 0) {
    1094:	00000000 	andeq	r0, r0, r0
  return true;
    1098:	a8040000 	stmdage	r4, {}	@ <UNPREDICTABLE>
          num[num_len++] = hextable[value % 10];
    109c:	0102b802 	tsteq	r2, r2, lsl #16
    10a0:	02b80450 	adcseq	r0, r8, #80, 8	@ 0x50000000
    10a4:	510102bb 			@ <UNDEFINED> instruction: 0x510102bb
    10a8:	c202c004 	andgt	ip, r2, #4
    10ac:	04500102 	ldrbeq	r0, [r0], #-258	@ 0xfffffefe
    10b0:	02c502c2 	sbceq	r0, r5, #536870924	@ 0x2000000c
    10b4:	00005101 	andeq	r5, r0, r1, lsl #2
    10b8:	02ae0400 	adceq	r0, lr, #0, 8
          value = value / 10;
    10bc:	530102b0 	movwpl	r0, #4784	@ 0x12b0
        } while (value > 0);
    10c0:	00000000 	andeq	r0, r0, r0
        while (num_len > 0) {
    10c4:	02b00400 	adcseq	r0, r0, #0, 8
          __write_char__(num[--num_len]);
    10c8:	730502b4 	movwvc	r0, #21172	@ 0x52b4
    10cc:	9f1a3100 	svcls	0x001a3100
    10d0:	bb02b404 	bllt	ae0e8 <__ROM_SIZE__+0x6e0e8>
    10d4:	00530102 	subseq	r0, r3, r2, lsl #2
    10d8:	00000000 	andeq	r0, r0, r0
    10dc:	b201a804 	andlt	sl, r1, #4, 16	@ 0x40000
  return true;
    10e0:	04500101 	ldrbeq	r0, [r0], #-257	@ 0xfffffeff
              __write_char__(hextable[val]);
    10e4:	029001b2 	addseq	r0, r0, #-2147483604	@ 0x8000002c
    10e8:	5001a304 	andpl	sl, r1, r4, lsl #6
              leading_zero_ignored = true;
    10ec:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
          while (start_bit >= 0) {
    10f0:	a8040000 	stmdage	r4, {}	@ <UNPREDICTABLE>
            int val = (value >> start_bit) & 0xF;
    10f4:	0101b501 	tsteq	r1, r1, lsl #10
            if (val || leading_zero_ignored) {
    10f8:	01b50451 			@ <UNDEFINED> instruction: 0x01b50451
    10fc:	54010290 	strpl	r0, [r1], #-656	@ 0xfffffd70
    1100:	00000000 	andeq	r0, r0, r0
          bool leading_zero_ignored = false;
    1104:	04010000 	streq	r0, [r1], #-0
          int start_bit = LAST_NIBBLE_FIRST_BIT;
    1108:	01ba01b8 			@ <UNDEFINED> instruction: 0x01ba01b8
  return true;
    110c:	ba045001 	blt	115118 <__ROM_SIZE__+0xd5118>
        return false;
    1110:	0101e601 	tsteq	r1, r1, lsl #12
        return false;
    1114:	01e80456 	mvneq	r0, r6, asr r4
    1118:	560101f6 			@ <UNDEFINED> instruction: 0x560101f6
    111c:	00000000 	andeq	r0, r0, r0
    1120:	04010000 	streq	r0, [r1], #-0
    1124:	01c201c0 	biceq	r0, r2, r0, asr #3
    1128:	c2045001 	andgt	r5, r4, #1
int printf(const char *fmt, ...) {
    112c:	0101e601 	tsteq	r1, r1, lsl #12
    1130:	01e80455 	mvneq	r0, r5, asr r4
    1134:	550101f6 	strpl	r0, [r1, #-502]	@ 0xfffffe0a
  va_start(args, fmt);
    1138:	00000000 	andeq	r0, r0, r0
  while (*fmt) {
    113c:	04000000 	streq	r0, [r0], #-0
        if (*fmt == '%') {
    1140:	01e601c6 	mvneq	r0, r6, asr #3
        __write_char__(*fmt);
    1144:	e8045001 	stmda	r4, {r0, ip, lr}
        fmt++;
    1148:	0101ea01 	tsteq	r1, r1, lsl #20
  while (*fmt) {
    114c:	01f00450 	mvnseq	r0, r0, asr r4
    switch (state) {
    1150:	500101f2 	strdpl	r0, [r1], -r2
    1154:	00000000 	andeq	r0, r0, r0
          fmt++;
    1158:	01d00400 	bicseq	r0, r0, r0, lsl #8
          continue;
    115c:	520101e2 	andpl	r0, r1, #-2147483592	@ 0x80000038
        while (*fmt && ((*fmt >= '0' && *fmt <= '9') || *fmt == '-')) {
    1160:	e601e204 	str	lr, [r1], -r4, lsl #4
    1164:	00530101 	subseq	r0, r3, r1, lsl #2
	...
    1170:	016a6004 	cmneq	sl, r4
        switch (*fmt) {
    1174:	7c6a0450 	cfstrdvc	mvd0, [sl], #-320	@ 0xfffffec0
    1178:	5001a304 	andpl	sl, r1, r4, lsl #6
    117c:	807c049f 			@ <UNDEFINED> instruction: 0x807c049f
    1180:	04500101 	ldrbeq	r0, [r0], #-257	@ 0xfffffeff
            __write_char__(*fmt);
    1184:	01a80180 			@ <UNDEFINED> instruction: 0x01a80180
    1188:	5001a304 	andpl	sl, r1, r4, lsl #6
            state = CHECK_CH;
    118c:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
	...
            outstr(va_arg(args, const char *));
    1198:	60040000 	andvs	r0, r4, r0
    119c:	0451016d 	ldrbeq	r0, [r1], #-365	@ 0xfffffe93
    11a0:	55017a6d 	strpl	r7, [r1, #-2669]	@ 0xfffff593
            fmt++;
    11a4:	047c7a04 	ldrbteq	r7, [ip], #-2564	@ 0xfffff5fc
            break;
    11a8:	9f5101a3 	svcls	0x005101a3
            __write_char__(va_arg(args, int));
    11ac:	017e7c04 	cmneq	lr, r4, lsl #24
    11b0:	8a7e0451 	bhi	1f822fc <__ROM_SIZE__+0x1f422fc>
    11b4:	04550101 	ldrbeq	r0, [r5], #-257	@ 0xfffffeff
            fmt++;
    11b8:	01a8018a 			@ <UNDEFINED> instruction: 0x01a8018a
            break;
    11bc:	5101a304 	tstpl	r1, r4, lsl #6
            if (*fmt == 'l') {
    11c0:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
    11c4:	00000000 	andeq	r0, r0, r0
            if (printf_numbers(*fmt, &args, l_count)) {
    11c8:	01727004 	cmneq	r2, r4
    11cc:	7c720450 	cfldrdvc	mvd0, [r2], #-320	@ 0xfffffec0
    11d0:	8a045401 	bhi	1161dc <__ROM_SIZE__+0xd61dc>
              state = CHECK_CH;
    11d4:	01019e01 	tsteq	r1, r1, lsl #28
              fmt++;
    11d8:	00000054 	andeq	r0, r0, r4, asr r0
              l_count++;
    11dc:	78040000 	stmdavc	r4, {}	@ <UNPREDICTABLE>
            if (printf_numbers(*fmt, &args, 0)) {
    11e0:	0450017c 	ldrbeq	r0, [r0], #-380	@ 0xfffffe84
    11e4:	019e018a 	orrseq	r0, lr, sl, lsl #3
              fmt++;
    11e8:	02005601 	andeq	r5, r0, #1048576	@ 0x100000
              break;
    11ec:	04000000 	streq	r0, [r0], #-0
            return -1;
    11f0:	30027c78 	andcc	r7, r2, r8, ror ip
}
    11f4:	018a049f 			@ <UNDEFINED> instruction: 0x018a049f
    11f8:	5501019e 	strpl	r0, [r1, #-414]	@ 0xfffffe62
            return -1;
    11fc:	00000200 	andeq	r0, r0, r0, lsl #4
    1200:	7c780400 	cfldrdvc	mvd0, [r8], #-0
    1204:	049f3002 	ldreq	r3, [pc], #2	@ 120c <outstr2+0x4>
static void outstr2(const char *str) {
    1208:	0193018c 	orrseq	r0, r3, ip, lsl #3
  while (*str != '\0') {
    120c:	00005201 	andeq	r5, r0, r1, lsl #4
    __write_char2__(*str);
    1210:	00000000 	andeq	r0, r0, r0
    str++;
    1214:	04000000 	streq	r0, [r0], #-0
  while (*str != '\0') {
    1218:	50013a30 	andpl	r3, r1, r0, lsr sl
}
    121c:	044c3a04 	strbeq	r3, [ip], #-2564	@ 0xfffff5fc
    1220:	9f5001a3 	svcls	0x005001a3
static bool printf2_numbers(const char fmt, va_list *args, int l_count) {
    1224:	01504c04 	cmpeq	r0, r4, lsl #24
    1228:	60500450 	subsvs	r0, r0, r0, asr r4
  switch (fmt) {
    122c:	5001a304 	andpl	sl, r1, r4, lsl #6
    1230:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
    1234:	00000000 	andeq	r0, r0, r0
      if (l_count == 0) {
    1238:	30040000 	andcc	r0, r4, r0
    123c:	0451013d 	ldrbeq	r0, [r1], #-317	@ 0xfffffec3
        value = va_arg(*args, unsigned int);
    1240:	54014c3d 	strpl	r4, [r1], #-3133	@ 0xfffff3c3
    1244:	014e4c04 	cmpeq	lr, r4, lsl #24
      if (fmt == 'u') {
    1248:	604e0451 	subvs	r0, lr, r1, asr r4
        if (value == 0) {
    124c:	00005401 	andeq	r5, r0, r1, lsl #8
          __write_char2__(hextable2[0]);
    1250:	04000000 	streq	r0, [r0], #-0
    1254:	50014240 	andpl	r4, r1, r0, asr #4
  return true;
    1258:	014a4204 	cmpeq	sl, r4, lsl #4
  switch (fmt) {
    125c:	00000055 	andeq	r0, r0, r5, asr r0
      outstr2("\nprintf2-error\n");
    1260:	014a4604 	cmpeq	sl, r4, lsl #12
      return false;
    1264:	00000050 	andeq	r0, r0, r0, asr r0
}
    1268:	00000000 	andeq	r0, r0, r0
      if (l_count == 0) {
    126c:	00040000 	andeq	r0, r4, r0
        value = va_arg(*args, int);
    1270:	04500108 	ldrbeq	r0, [r0], #-264	@ 0xfffffef8
    1274:	a3041a08 	movwge	r1, #18952	@ 0x4a08
      if (value < 0) {
    1278:	049f5001 	ldreq	r5, [pc], #1	@ 1280 <printf2_numbers+0x5c>
        num[num_len++] = hextable2[value % 10];
    127c:	50011e1a 	andpl	r1, r1, sl, lsl lr
    1280:	04301e04 	ldrteq	r1, [r0], #-3588	@ 0xfffff1fc
    1284:	9f5001a3 	svcls	0x005001a3
	...
    1290:	0b000400 	bleq	2298 <_varencode64>
    1294:	0b045101 	bleq	1156a0 <__ROM_SIZE__+0xd56a0>
    1298:	01a3041a 			@ <UNDEFINED> instruction: 0x01a3041a
    129c:	1a049f51 	bne	128fe8 <__ROM_SIZE__+0xe8fe8>
        value = value / 10;
    12a0:	0451011c 	ldrbeq	r0, [r1], #-284	@ 0xfffffee4
      } while (value > 0);
    12a4:	a304301c 	movwge	r3, #16412	@ 0x401c
    12a8:	009f5101 	addseq	r5, pc, r1, lsl #2
        __write_char2__('-');
    12ac:	00000000 	andeq	r0, r0, r0
    12b0:	01120e04 	tsteq	r2, r4, lsl #28
        value = -value;
    12b4:	15120450 	ldrne	r0, [r2, #-1104]	@ 0xfffffbb0
        __write_char2__(num[--num_len]);
    12b8:	00005101 	andeq	r5, r0, r1, lsl #2
    12bc:	15100400 	ldrne	r0, [r0, #-1024]	@ 0xfffffc00
    12c0:	14005201 	strne	r5, [r0], #-513	@ 0xfffffdff
    12c4:	05000006 	streq	r0, [r0, #-6]
    12c8:	00000400 	andeq	r0, r0, r0, lsl #8
      while (num_len > 0) {
    12cc:	00000000 	andeq	r0, r0, r0
  return true;
    12d0:	04000000 	streq	r0, [r0], #-0
          num[num_len++] = hextable2[value % 10];
    12d4:	0aec0adc 	beq	ffb03e4c <_STACK_TOP_+0xdfafbe50>
    12d8:	ec045001 	stc	0, cr5, [r4], {1}
    12dc:	010bd00a 	tsteq	fp, sl
    12e0:	00000057 	andeq	r0, r0, r7, asr r0
    12e4:	dc040000 	stcle	0, cr0, [r4], {-0}
    12e8:	010aec0a 	tsteq	sl, sl, lsl #24
    12ec:	0aec0451 	beq	ffb02438 <_STACK_TOP_+0xdfafa43c>
    12f0:	55010bd0 	strpl	r0, [r1, #-3024]	@ 0xfffff430
          value = value / 10;
    12f4:	00000000 	andeq	r0, r0, r0
        } while (value > 0);
    12f8:	0adc0400 	beq	ff702300 <_STACK_TOP_+0xdf6fa304>
        while (num_len > 0) {
    12fc:	52010aec 	andpl	r0, r1, #236, 20	@ 0xec000
          __write_char2__(num[--num_len]);
    1300:	d00aec04 	andle	lr, sl, r4, lsl #24
    1304:	0056010b 	subseq	r0, r6, fp, lsl #2
    1308:	00000004 	andeq	r0, r0, r4
    130c:	ec0ae604 	stc	6, cr14, [sl], {4}
    1310:	9f30020a 	svcls	0x0030020a
    1314:	d00aec04 	andle	lr, sl, r4, lsl #24
  return true;
    1318:	0054010b 	subseq	r0, r4, fp, lsl #2
              __write_char2__(hextable2[val]);
    131c:	00000004 	andeq	r0, r0, r4
    1320:	00000001 	andeq	r0, r0, r1
              leading_zero_ignored = true;
    1324:	e6040000 	str	r0, [r4], -r0
          while (start_bit >= 0) {
    1328:	020aec0a 	andeq	lr, sl, #2560	@ 0xa00
            int val = (value >> start_bit) & 0xF;
    132c:	ec049f40 	stc	15, cr9, [r4], {64}	@ 0x40
            if (val || leading_zero_ignored) {
    1330:	010ba70a 	tsteq	fp, sl, lsl #14
    1334:	0bb00453 	bleq	fec02488 <_STACK_TOP_+0xdebfa48c>
    1338:	3f020bb2 	svccc	0x00020bb2
          bool leading_zero_ignored = false;
    133c:	0bb2049f 	bleq	fec825c0 <_STACK_TOP_+0xdec7a5c4>
          int start_bit = LAST_NIBBLE_FIRST_BIT;
    1340:	53010bc2 	movwpl	r0, #7106	@ 0x1bc2
  return true;
    1344:	d00bcc04 	andle	ip, fp, r4, lsl #24
        return false;
    1348:	0053010b 	subseq	r0, r3, fp, lsl #2
        return false;
    134c:	00000000 	andeq	r0, r0, r0
    1350:	a60a9604 	strge	r9, [sl], -r4, lsl #12
    1354:	0450010a 	ldrbeq	r0, [r0], #-266	@ 0xfffffef6
    1358:	0adc0aa6 	beq	ff703df8 <_STACK_TOP_+0xdf6fbdfc>
    135c:	00005701 	andeq	r5, r0, r1, lsl #14
    1360:	04000000 	streq	r0, [r0], #-0
int printf2(const char *fmt, ...) {
    1364:	0aa60a96 	beq	fe983dc4 <_STACK_TOP_+0xde97bdc8>
    1368:	a6045101 	strge	r5, [r4], -r1, lsl #2
    136c:	010adc0a 	tsteq	sl, sl, lsl #24
  va_start(args, fmt);
    1370:	00000054 	andeq	r0, r0, r4, asr r0
  while (*fmt) {
    1374:	96040000 	strls	r0, [r4], -r0
        if (*fmt == '%') {
    1378:	010aa60a 	tsteq	sl, sl, lsl #12
        __write_char2__(*fmt);
    137c:	0aa60452 	beq	fe9824cc <_STACK_TOP_+0xde97a4d0>
        fmt++;
    1380:	58010adc 	stmdapl	r1, {r2, r3, r4, r6, r7, r9, fp}
  while (*fmt) {
    1384:	00000300 	andeq	r0, r0, r0, lsl #6
    switch (state) {
    1388:	0aa20400 	beq	fe882390 <_STACK_TOP_+0xde87a394>
    138c:	30020aa6 	andcc	r0, r2, r6, lsr #21
          fmt++;
    1390:	0aa6049f 	beq	fe982614 <_STACK_TOP_+0xde97a618>
          continue;
    1394:	55010adc 	strpl	r0, [r1, #-2780]	@ 0xfffff524
        while (*fmt && ((*fmt >= '0' && *fmt <= '9') || *fmt == '-')) {
    1398:	00000000 	andeq	r0, r0, r0
    139c:	09de0400 	ldmibeq	lr, {sl}^
    13a0:	500109f2 	strdpl	r0, [r1], -r2
    13a4:	9609f204 	strls	pc, [r9], -r4, lsl #4
    13a8:	0056010a 	subseq	r0, r6, sl, lsl #2
        switch (*fmt) {
    13ac:	02000000 	andeq	r0, r0, #0
    13b0:	00000002 	andeq	r0, r0, r2
    13b4:	ee09de04 	cdp	14, 0, cr13, cr9, cr4, {0}
    13b8:	04510109 	ldrbeq	r0, [r1], #-265	@ 0xfffffef7
            __write_char2__(*fmt);
    13bc:	0a8009ee 	beq	fe003b7c <_STACK_TOP_+0xddffbb80>
    13c0:	80045401 	andhi	r5, r4, r1, lsl #8
            state = CHECK_CH;
    13c4:	030a860a 	movweq	r8, #42506	@ 0xa60a
            break;
    13c8:	049f1074 	ldreq	r1, [pc], #116	@ 13d0 <printf2+0x6c>
    13cc:	0a960a86 	beq	fe583dec <_STACK_TOP_+0xde57bdf0>
            outstr2(va_arg(args, const char *));
    13d0:	00005401 	andeq	r5, r0, r1, lsl #8
    13d4:	04000000 	streq	r0, [r0], #-0
    13d8:	09f209de 	ldmibeq	r2!, {r1, r2, r3, r4, r6, r7, r8, fp}^
            fmt++;
    13dc:	f2045201 	vhsub.s8	d5, d4, d1
            break;
    13e0:	010a9609 	tsteq	sl, r9, lsl #12
            __write_char2__(va_arg(args, int));
    13e4:	00010057 	andeq	r0, r1, r7, asr r0
    13e8:	ec040000 	stc	0, cr0, [r4], {-0}
    13ec:	0209f209 	andeq	pc, r9, #-1879048192	@ 0x90000000
            fmt++;
    13f0:	f2049f30 	vrecps.f32	d9, d4, d16
            break;
    13f4:	010a9609 	tsteq	sl, r9, lsl #12
            if (*fmt == 'l') {
    13f8:	00000055 	andeq	r0, r0, r5, asr r0
    13fc:	00010000 	andeq	r0, r1, r0
            if (printf2_numbers(*fmt, &args, l_count)) {
    1400:	ec040000 	stc	0, cr0, [r4], {-0}
    1404:	0109f209 	tsteq	r9, r9, lsl #4	@ <UNPREDICTABLE>
    1408:	09f20458 	ldmibeq	r2!, {r3, r4, r6, sl}^
              state = CHECK_CH;
    140c:	510109f7 	strdpl	r0, [r1, -r7]
              fmt++;
    1410:	860a8004 	strhi	r8, [sl], -r4
              l_count++;
    1414:	0454010a 	ldrbeq	r0, [r4], #-266	@ 0xfffffef6
            if (printf2_numbers(*fmt, &args, 0)) {
    1418:	0a910a86 	beq	fe443e38 <_STACK_TOP_+0xde43be3c>
    141c:	03005101 	movweq	r5, #257	@ 0x101
              fmt++;
    1420:	00000000 	andeq	r0, r0, r0
              break;
    1424:	08fc0400 	ldmeq	ip!, {sl}^
            return -1;
    1428:	30020980 	andcc	r0, r2, r0, lsl #19
}
    142c:	0980049f 	stmibeq	r0, {r0, r1, r2, r3, r4, r7, sl}
    1430:	5301098e 	movwpl	r0, #6542	@ 0x198e
            return -1;
    1434:	96099004 	strls	r9, [r9], -r4
    1438:	00530109 	subseq	r0, r3, r9, lsl #2
    143c:	00000000 	andeq	r0, r0, r0
int r32(int argc, char *argv[]) {
    1440:	d0040000 	andle	r0, r4, r0
  if (argc < 2) {
    1444:	0109d809 	tsteq	r9, r9, lsl #16
  uint32_t addr = atoh(argv[1]);
    1448:	09d80450 	ldmibeq	r8, {r4, r6, sl}^
    144c:	510109db 	ldrdpl	r0, [r1, -fp]
  printf("0x%x: 0x%x\n", addr, data);
    1450:	de09db04 	vmlale.f64	d13, d9, d4
    1454:	01a30409 			@ <UNDEFINED> instruction: 0x01a30409
}
    1458:	00009f50 	andeq	r9, r0, r0, asr pc
    printf("Usage: %s <address> (in hex)\n", argv[0]);
    145c:	00000000 	andeq	r0, r0, r0
    1460:	09d00400 	ldmibeq	r0, {sl}^
    return -1;
    1464:	510109d6 	ldrdpl	r0, [r1, -r6]
    1468:	db09d604 	blle	276c80 <__ROM_SIZE__+0x236c80>
    146c:	04530109 	ldrbeq	r0, [r3], #-265	@ 0xfffffef7
int w32(int argc, char *argv[]) {
    1470:	09de09db 	ldmibeq	lr, {r0, r1, r3, r4, r6, r7, r8, fp}^
  if (argc < 3) {
    1474:	5101a304 	tstpl	r1, r4, lsl #6
  uint32_t addr = atoh(argv[1]);
    1478:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
    147c:	00000000 	andeq	r0, r0, r0
  uint32_t data = atoh(argv[2]);
    1480:	ca09c204 	bgt	271c98 <__ROM_SIZE__+0x231c98>
    1484:	04500109 	ldrbeq	r0, [r0], #-265	@ 0xfffffef7
  return 0;
    1488:	09cd09ca 	stmibeq	sp, {r1, r3, r6, r7, r8, fp}^
    printf("Usage: %s <address> (in hex) <value> (in hex)\n", argv[0]);
    148c:	cd045101 	stfgts	f5, [r4, #-4]
    1490:	0409d009 	streq	sp, [r9], #-9
    return -1;
    1494:	9f5001a3 	svcls	0x005001a3
    1498:	00000000 	andeq	r0, r0, r0
    149c:	04000000 	streq	r0, [r0], #-0
int read_mem(int argc, char *argv[]) {
    14a0:	09c809c2 	stmibeq	r8, {r1, r6, r7, r8, fp}^
  if (argc < 3) {
    14a4:	c8045101 	stmdagt	r4, {r0, r8, ip, lr}
  uint32_t addr = atoh(argv[1]);
    14a8:	0109cd09 	tsteq	r9, r9, lsl #26
    14ac:	09cd0453 	stmibeq	sp, {r0, r1, r4, r6, sl}^
  uint32_t length = atoi(argv[2]);
    14b0:	a30409d0 	movwge	r0, #18896	@ 0x49d0
    14b4:	009f5101 	addseq	r5, pc, r1, lsl #2
  for (uint32_t i = 0, data = 0; i < length; i++) {
    14b8:	00000000 	andeq	r0, r0, r0
    printf("Usage: %s <address> (in hex) <num_words> (in decimal)\n", argv[0]);
    14bc:	c2040000 	andgt	r0, r4, #0
    14c0:	0108ce08 	tsteq	r8, r8, lsl #28
    return -1;
    14c4:	08ce0450 	stmiaeq	lr, {r4, r6, sl}^
    14c8:	510108d1 	ldrdpl	r0, [r1, -r1]
    printf("0x%x: 0x%x\n", addr, data);
    14cc:	fc08d104 	stc2	1, cr13, [r8], {4}
    14d0:	00550108 	subseq	r0, r5, r8, lsl #2
    addr += 4;
    14d4:	00000000 	andeq	r0, r0, r0
  for (uint32_t i = 0, data = 0; i < length; i++) {
    14d8:	c2040000 	andgt	r0, r4, #0
  return 0;
    14dc:	0108cc08 	tsteq	r8, r8, lsl #24
}
    14e0:	08cc0451 	stmiaeq	ip, {r0, r4, r6, sl}^
    14e4:	520108d1 	andpl	r0, r1, #13697024	@ 0xd10000
{
    14e8:	fc08d104 	stc2	1, cr13, [r8], {4}
  if (argc < 4) {
    14ec:	00560108 	subseq	r0, r6, r8, lsl #2
  uint32_t addr = atoh(argv[1]);
    14f0:	00010101 	andeq	r0, r1, r1, lsl #2
    14f4:	00000000 	andeq	r0, r0, r0
  uint32_t bit_loc = atoi(argv[2]);
    14f8:	d208c804 	andle	ip, r8, #4, 16	@ 0x40000
    14fc:	9f300208 	svcls	0x00300208
  uint32_t bit_val = atoi(argv[3]);
    1500:	d608d204 	strle	sp, [r8], -r4, lsl #4
    1504:	9f390208 	svcls	0x00390208
  if (bit_loc > 31) {
    1508:	de08d604 	cfmadd32le	mvax0, mvfx13, mvfx8, mvfx4
  if (bit_val != 0 && bit_val != 1) {
    150c:	04540108 	ldrbeq	r0, [r4], #-264	@ 0xfffffef8
  data = data | (bit_val << bit_loc);
    1510:	08fc08e0 	ldmeq	ip!, {r5, r6, r7, fp}^
    1514:	00005401 	andeq	r5, r0, r1, lsl #8
  data = data & ~(!bit_val << bit_loc);
    1518:	00000000 	andeq	r0, r0, r0
    151c:	07fe0400 	ldrbeq	r0, [lr, r0, lsl #8]!
    1520:	5001088a 	andpl	r0, r1, sl, lsl #17
  return 0;
    1524:	8d088a04 	vstrhi	s16, [r8, #-16]
    printf("Error: Invalid bit location argument\n");
    1528:	04510108 	ldrbeq	r0, [r1], #-264	@ 0xfffffef8
    152c:	08c2088d 	stmiaeq	r2, {r0, r2, r3, r7, fp}^
    printf("Error: Invalid bit value argument\n");
    1530:	00005501 	andeq	r5, r0, r1, lsl #10
    1534:	00000000 	andeq	r0, r0, r0
  printf("Usage: %s <address_in_hex(32-bits)> <bit_location_in_decimal(0 to 31)> <bit_value(0 or 1)>\n", argv[0]);
    1538:	07fe0400 	ldrbeq	r0, [lr, r0, lsl #8]!
    153c:	51010888 	smlabbpl	r1, r8, r8, r0
  return -1;
    1540:	8d088804 	stchi	8, cr8, [r8, #-16]
    1544:	04520108 	ldrbeq	r0, [r2], #-264	@ 0xfffffef8
    1548:	08c2088d 	stmiaeq	r2, {r0, r2, r3, r7, fp}^
    154c:	01005601 	tsteq	r0, r1, lsl #12
{
    1550:	00000101 	andeq	r0, r0, r1, lsl #2
  if (argc < 3) {
    1554:	04000000 	streq	r0, [r0], #-0
  uint32_t addr = atoh(argv[1]);
    1558:	088e0884 	stmeq	lr, {r2, r7, fp}
    155c:	049f3002 	ldreq	r3, [pc], #2	@ 1564 <r32_bit+0x14>
  uint32_t bit_loc = atoi(argv[2]);
    1560:	0892088e 	ldmeq	r2, {r1, r2, r3, r7, fp}
    1564:	049f3102 	ldreq	r3, [pc], #258	@ 156c <r32_bit+0x1c>
  if (bit_loc > 31) {
    1568:	08a40892 	stmiaeq	r4!, {r1, r4, r7, fp}
  uint32_t data = reg32(addr);
    156c:	a6045401 	strge	r5, [r4], -r1, lsl #8
  printf("Bit %u @ 0x%08x: %u\n", bit_loc, addr, bit_val);
    1570:	0108c208 	tsteq	r8, r8, lsl #4
    1574:	00000054 	andeq	r0, r0, r4, asr r0
    1578:	fe07ce04 	cdp2	14, 0, cr12, cr7, cr4, {0}
  return 0;
    157c:	00530107 	subseq	r0, r3, r7, lsl #2
    printf("Error: Invalid bit location argument\n");
    1580:	00000003 	andeq	r0, r0, r3
    1584:	00000000 	andeq	r0, r0, r0
  printf("Usage: %s <address_in_hex(32-bits)> <bit_location_in_decimal(0 to 31)\n", argv[0]);
    1588:	86078404 	strhi	r8, [r7], -r4, lsl #8
    158c:	9f300207 	svcls	0x00300207
  return -1;
    1590:	b0078604 	andlt	r8, r7, r4, lsl #12
    1594:	04510107 	ldrbeq	r0, [r1], #-263	@ 0xfffffef9
    1598:	07c007b2 			@ <UNDEFINED> instruction: 0x07c007b2
    159c:	c2045101 	andgt	r5, r4, #1073741824	@ 0x40000000
{
    15a0:	0107cc07 	tsteq	r7, r7, lsl #24
  for (i = 0; i < Nk; ++i)
    15a4:	00000051 	andeq	r0, r0, r1, asr r0
    RoundKey[(i * 4) + 0] = Key[(i * 4) + 0];
    15a8:	00000000 	andeq	r0, r0, r0
    15ac:	a8078c04 	stmdage	r7, {r2, sl, fp, pc}
    15b0:	04530107 	ldrbeq	r0, [r3], #-263	@ 0xfffffef9
    RoundKey[(i * 4) + 1] = Key[(i * 4) + 1];
    15b4:	07b807aa 	ldreq	r0, [r8, sl, lsr #15]!
    15b8:	ba045301 	blt	1161c4 <__ROM_SIZE__+0xd61c4>
    RoundKey[(i * 4) + 2] = Key[(i * 4) + 2];
    15bc:	0107c407 	tsteq	r7, r7, lsl #8
    15c0:	00000053 	andeq	r0, r0, r3, asr r0
    15c4:	00000000 	andeq	r0, r0, r0
    RoundKey[(i * 4) + 3] = Key[(i * 4) + 3];
    15c8:	b604aa04 	strlt	sl, [r4], -r4, lsl #20
  for (i = 0; i < Nk; ++i)
    15cc:	04500104 	ldrbeq	r0, [r0], #-260	@ 0xfffffefc
    15d0:	078004b6 			@ <UNDEFINED> instruction: 0x078004b6
  for (i = Nk; i < Nb * (Nr + 1); ++i)
    15d4:	04007d02 	streq	r7, [r0], #-3330	@ 0xfffff2fe
    j = i * 4; k=(i - Nk) * 4;
    15d8:	07840780 	streq	r0, [r4, r0, lsl #15]
    RoundKey[j + 0] = RoundKey[k + 0] ^ tempa[0];
    15dc:	7fb09103 	svcvc	0x00b09103
    15e0:	00000300 	andeq	r0, r0, r0, lsl #6
    15e4:	04b20400 	ldrteq	r0, [r2], #1024	@ 0x400
    15e8:	300204b6 			@ <UNDEFINED> instruction: 0x300204b6
    RoundKey[j + 1] = RoundKey[k + 1] ^ tempa[1];
    15ec:	04b6049f 	ldrteq	r0, [r6], #1183	@ 0x49f
    15f0:	54010784 	strpl	r0, [r1], #-1924	@ 0xfffff87c
    15f4:	04000000 	streq	r0, [r0], #-0
    15f8:	06f804bc 			@ <UNDEFINED> instruction: 0x06f804bc
    15fc:	00005b01 	andeq	r5, r0, r1, lsl #22
    RoundKey[j + 2] = RoundKey[k + 2] ^ tempa[2];
    1600:	04c40400 	strbeq	r0, [r4], #1024	@ 0x400
    1604:	5a0106f8 	bpl	431ec <__ROM_SIZE__+0x31ec>
    1608:	04000000 	streq	r0, [r0], #-0
    160c:	06f804c8 	ldrbteq	r0, [r8], r8, asr #9
    1610:	00005901 	andeq	r5, r0, r1, lsl #18
    RoundKey[j + 3] = RoundKey[k + 3] ^ tempa[3];
    1614:	04cc0400 	strbeq	r0, [ip], #1024	@ 0x400
    1618:	550106b8 	strpl	r0, [r1, #-1720]	@ 0xfffff948
    161c:	00000000 	andeq	r0, r0, r0
  for (i = Nk; i < Nb * (Nr + 1); ++i)
    1620:	03b40400 			@ <UNDEFINED> instruction: 0x03b40400
      k = (i - 1) * 4;
    1624:	500103be 			@ <UNDEFINED> instruction: 0x500103be
      tempa[0]=RoundKey[k + 0];
    1628:	aa03be04 	bge	f0e40 <__ROM_SIZE__+0xb0e40>
    162c:	00590104 	subseq	r0, r9, r4, lsl #2
      tempa[1]=RoundKey[k + 1];
    1630:	00000003 	andeq	r0, r0, r3
    1634:	ba040000 	blt	10163c <__ROM_SIZE__+0xc163c>
      tempa[2]=RoundKey[k + 2];
    1638:	0203be03 	andeq	fp, r3, #3, 28	@ 0x30
    163c:	be049f30 	mcrlt	15, 0, r9, cr4, cr0, {1}
      tempa[3]=RoundKey[k + 3];
    1640:	0104a003 	tsteq	r4, r3
    1644:	04a20455 	strteq	r0, [r2], #1109	@ 0x455
    if (i % Nk == 0)
    1648:	550104aa 	strpl	r0, [r1, #-1194]	@ 0xfffffb56
    164c:	04000000 	streq	r0, [r0], #-0
        tempa[0] = tempa[1];
    1650:	049c03da 	ldreq	r0, [ip], #986	@ 0x3da
        tempa[1] = tempa[2];
    1654:	01005401 	tsteq	r0, r1, lsl #8
        tempa[2] = tempa[3];
    1658:	00000000 	andeq	r0, r0, r0
        tempa[3] = u8tmp;
    165c:	00000100 	andeq	r0, r0, r0, lsl #2
        tempa[0] = getSBoxValue(tempa[0]);
    1660:	00000000 	andeq	r0, r0, r0
    1664:	00000100 	andeq	r0, r0, r0, lsl #2
        tempa[1] = getSBoxValue(tempa[1]);
    1668:	00000000 	andeq	r0, r0, r0
    166c:	00000100 	andeq	r0, r0, r0, lsl #2
        tempa[2] = getSBoxValue(tempa[2]);
    1670:	00000000 	andeq	r0, r0, r0
    1674:	03da0400 	bicseq	r0, sl, #0, 8
        tempa[3] = getSBoxValue(tempa[3]);
    1678:	500103dd 	ldrdpl	r0, [r1], -sp
      tempa[0] = tempa[0] ^ Rcon[i/Nk];
    167c:	de03dd04 	cdple	13, 0, cr13, cr3, cr4, {0}
    1680:	007b0603 	rsbseq	r0, fp, r3, lsl #12
    1684:	9f27007a 	svcls	0x0027007a
    1688:	e003de04 	and	sp, r3, r4, lsl #28
}
    168c:	04500103 	ldrbeq	r0, [r0], #-259	@ 0xfffffefd
    1690:	03ec03e8 	mvneq	r0, #232, 6	@ 0xa0000003
{
    1694:	78007b06 	stmdavc	r0, {r1, r2, r8, r9, fp, ip, sp, lr}
  for (i = 0; i < 4; ++i)
    1698:	049f2700 	ldreq	r2, [pc], #1792	@ 16a0 <AddRoundKey+0xc>
      (*state)[i][j] ^= RoundKey[(round * Nb * 4) + (i * Nb) + j];
    169c:	03ef03ec 	mvneq	r0, #236, 6	@ 0xb0000003
    16a0:	ef045001 	svc	0x00045001
    16a4:	0603f003 	streq	pc, [r3], -r3
    16a8:	0078007b 	rsbseq	r0, r8, fp, ror r0
    16ac:	f0049f27 			@ <UNDEFINED> instruction: 0xf0049f27
    16b0:	0103f203 	tsteq	r3, r3, lsl #4	@ <UNPREDICTABLE>
    16b4:	03fa0450 	mvnseq	r0, #80, 8	@ 0x50000000
    for (j = 0; j < 4; ++j)
    16b8:	780603fe 	stmdavc	r6, {r1, r2, r3, r4, r5, r6, r7, r8, r9}
    16bc:	27007700 	strcs	r7, [r0, -r0, lsl #14]
  for (i = 0; i < 4; ++i)
    16c0:	03fe049f 	mvnseq	r0, #-1627389952	@ 0x9f000000
    16c4:	50010481 	andpl	r0, r1, r1, lsl #9
    for (j = 0; j < 4; ++j)
    16c8:	82048104 	andhi	r8, r4, #4, 2
  for (i = 0; i < 4; ++i)
    16cc:	00780604 	rsbseq	r0, r8, r4, lsl #12
    16d0:	9f270077 	svcls	0x00270077
    for (j = 0; j < 4; ++j)
    16d4:	84048204 	strhi	r8, [r4], #-516	@ 0xfffffdfc
{
    16d8:	04500104 	ldrbeq	r0, [r0], #-260	@ 0xfffffefc
      (*state)[j][i] = getSBoxValue((*state)[j][i]);
    16dc:	0490048c 	ldreq	r0, [r0], #1164	@ 0x48c
    16e0:	7a007706 	bvc	1f300 <__RAM_SIZE__+0x17300>
    16e4:	049f2700 	ldreq	r2, [pc], #1792	@ 16ec <SubBytes+0x20>
    16e8:	04930490 	ldreq	r0, [r3], #1168	@ 0x490
    for (j = 0; j < 4; ++j)
    16ec:	93045001 	movwls	r5, #16385	@ 0x4001
    16f0:	06049404 	streq	r9, [r4], -r4, lsl #8
  for (i = 0; i < 4; ++i)
    16f4:	007a0077 	rsbseq	r0, sl, r7, ror r0
    16f8:	94049f27 	strls	r9, [r4], #-3879	@ 0xfffff0d9
    for (j = 0; j < 4; ++j)
    16fc:	0104a204 	tsteq	r4, r4, lsl #4
}
    1700:	00000050 	andeq	r0, r0, r0, asr r0
  for (i = 0; i < 4; ++i)
    1704:	a203c204 	andge	ip, r3, #4, 4	@ 0x40000000
    1708:	005a0104 	subseq	r0, sl, r4, lsl #2
    170c:	00000000 	andeq	r0, r0, r0
  temp           = (*state)[0][1];
    1710:	b003a204 	andlt	sl, r3, r4, lsl #4
  (*state)[0][1] = (*state)[1][1];
    1714:	04500103 	ldrbeq	r0, [r0], #-259	@ 0xfffffefd
  (*state)[1][1] = (*state)[2][1];
    1718:	03b403b0 			@ <UNDEFINED> instruction: 0x03b403b0
  (*state)[2][1] = (*state)[3][1];
    171c:	5001a304 	andpl	sl, r1, r4, lsl #6
  temp           = (*state)[0][2];
    1720:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
  (*state)[0][2] = (*state)[2][2];
    1724:	a202f204 	andge	pc, r2, #4, 4	@ 0x40000000
  temp           = (*state)[1][2];
    1728:	00530103 	subseq	r0, r3, r3, lsl #2
  (*state)[1][2] = (*state)[3][2];
    172c:	00000003 	andeq	r0, r0, r3
  temp           = (*state)[0][3];
    1730:	00000000 	andeq	r0, r0, r0
  (*state)[0][3] = (*state)[3][3];
    1734:	ae02ac04 	cdpge	12, 0, cr10, cr2, cr4, {0}
  (*state)[3][3] = (*state)[2][3];
    1738:	9f300202 	svcls	0x00300202
  (*state)[2][3] = (*state)[1][3];
    173c:	d602ae04 	strle	sl, [r2], -r4, lsl #28
}
    1740:	04520102 	ldrbeq	r0, [r2], #-258	@ 0xfffffefe
  return ((x<<1) ^ (((x>>7) & 1) * 0x1b));
    1744:	02e602d8 	rsceq	r0, r6, #216, 4	@ 0x8000000d
    1748:	e8045201 	stmda	r4, {r0, r9, ip, lr}
    174c:	0102f002 	tsteq	r2, r2	@ <UNPREDICTABLE>
}
    1750:	00000052 	andeq	r0, r0, r2, asr r0
{
    1754:	00000000 	andeq	r0, r0, r0
    1758:	ce02b404 	cdpgt	4, 0, cr11, cr2, cr4, {0}
  for (i = 0; i < 4; ++i)
    175c:	04530102 	ldrbeq	r0, [r3], #-258	@ 0xfffffefe
    t   = (*state)[i][0];
    1760:	02de02d0 	sbcseq	r0, lr, #208, 4
    Tmp = (*state)[i][0] ^ (*state)[i][1] ^ (*state)[i][2] ^ (*state)[i][3] ;
    1764:	e0045301 	and	r5, r4, r1, lsl #6
    1768:	0102ea02 	tsteq	r2, r2, lsl #20
    176c:	00020053 	andeq	r0, r2, r3, asr r0
    1770:	00000000 	andeq	r0, r0, r0
    1774:	fa01f604 	blx	7ef8c <__ROM_SIZE__+0x3ef8c>
    1778:	9f300201 	svcls	0x00300201
    Tm  = (*state)[i][0] ^ (*state)[i][1] ; Tm = xtime(Tm);  (*state)[i][0] ^= Tm ^ Tmp ;
    177c:	a001fa04 	andge	pc, r1, r4, lsl #20
    1780:	04540102 	ldrbeq	r0, [r4], #-258	@ 0xfffffefe
    1784:	02ac02a2 	adceq	r0, ip, #536870922	@ 0x2000000a
    Tm  = (*state)[i][1] ^ (*state)[i][2] ; Tm = xtime(Tm);  (*state)[i][1] ^= Tm ^ Tmp ;
    1788:	00005401 	andeq	r5, r0, r1, lsl #8
    178c:	04000000 	streq	r0, [r0], #-0
    1790:	029801fa 	addseq	r0, r8, #-2147483586	@ 0x8000003e
    1794:	9a045301 	bls	1163a0 <__ROM_SIZE__+0xd63a0>
    1798:	0102a202 	tsteq	r2, r2, lsl #4
    Tm  = (*state)[i][2] ^ (*state)[i][3] ; Tm = xtime(Tm);  (*state)[i][2] ^= Tm ^ Tmp ;
    179c:	00000053 	andeq	r0, r0, r3, asr r0
    17a0:	00000000 	andeq	r0, r0, r0
    17a4:	bc09b604 	stclt	6, cr11, [r9], {4}
    17a8:	04500109 	ldrbeq	r0, [r0], #-265	@ 0xfffffef7
    Tm  = (*state)[i][3] ^ t ;              Tm = xtime(Tm);  (*state)[i][3] ^= Tm ^ Tmp ;
    17ac:	09bf09bc 	ldmibeq	pc!, {r2, r3, r4, r5, r7, r8, fp}	@ <UNPREDICTABLE>
    17b0:	7ed07004 	cdpvc	0, 13, cr7, cr0, cr4, {0}
    17b4:	09bf049f 	ldmibeq	pc!, {r0, r1, r2, r3, r4, r7, sl}	@ <UNPREDICTABLE>
    17b8:	a30409c2 	movwge	r0, #18882	@ 0x49c2
    17bc:	009f5001 	addseq	r5, pc, r1
  for (i = 0; i < 4; ++i)
    17c0:	00000000 	andeq	r0, r0, r0
    17c4:	bf09b604 	svclt	0x0009b604
}
    17c8:	04510109 	ldrbeq	r0, [r1], #-265	@ 0xfffffef7
{
    17cc:	09c209bf 	stmibeq	r2, {r0, r1, r2, r3, r4, r5, r7, r8, fp}^
    17d0:	5101a304 	tstpl	r1, r4, lsl #6
  for (i = 0; i < 4; ++i)
    17d4:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
    a = (*state)[i][0];
    17d8:	9e040000 	cdpls	0, 0, cr0, cr4, cr0, {0}
    b = (*state)[i][1];
    17dc:	0109a709 	tsteq	r9, r9, lsl #14
    17e0:	09a70450 	stmibeq	r7!, {r4, r6, sl}
    c = (*state)[i][2];
    17e4:	540109b6 	strpl	r0, [r1], #-2486	@ 0xfffff64a
    d = (*state)[i][3];
    17e8:	00000000 	andeq	r0, r0, r0
    (*state)[i][0] = Multiply(a, 0x0e) ^ Multiply(b, 0x0b) ^ Multiply(c, 0x0d) ^ Multiply(d, 0x09);
    17ec:	099e0400 	ldmibeq	lr, {sl}
    17f0:	510109a7 	smlatbpl	r1, r7, r9, r0
    17f4:	b609a704 	strlt	sl, [r9], -r4, lsl #14
    17f8:	01a30409 			@ <UNDEFINED> instruction: 0x01a30409
    17fc:	00009f51 	andeq	r9, r0, r1, asr pc
    1800:	04000000 	streq	r0, [r0], #-0
    1804:	09a7099e 	stmibeq	r7!, {r1, r2, r3, r4, r7, r8, fp}
    1808:	a7045201 	strge	r5, [r4, -r1, lsl #4]
    180c:	0109b609 	tsteq	r9, r9, lsl #12
    1810:	00000055 	andeq	r0, r0, r5, asr r0
    1814:	96040000 	strls	r0, [r4], -r0
    1818:	01099b09 	tsteq	r9, r9, lsl #22
    181c:	099b0450 	ldmibeq	fp, {r4, r6, sl}
    1820:	a304099e 	movwge	r0, #18846	@ 0x499e
    1824:	009f5001 	addseq	r5, pc, r1
    1828:	00000000 	andeq	r0, r0, r0
    182c:	9b099604 	blls	267044 <__ROM_SIZE__+0x227044>
    1830:	04510109 	ldrbeq	r0, [r1], #-265	@ 0xfffffef7
    1834:	099e099b 	ldmibeq	lr, {r0, r1, r3, r4, r7, r8, fp}
    1838:	5101a304 	tstpl	r1, r4, lsl #6
    183c:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
    1840:	00040000 	andeq	r0, r4, r0
    1844:	04510136 	ldrbeq	r0, [r1], #-310	@ 0xfffffeca
    1848:	0401f436 	streq	pc, [r1], #-1078	@ 0xfffffbca
    184c:	9f5101a3 	svcls	0x005101a3
    1850:	00000300 	andeq	r0, r0, r0, lsl #6
    1854:	04000000 	streq	r0, [r0], #-0
    1858:	30020804 	andcc	r0, r2, r4, lsl #16
    185c:	3608049f 			@ <UNDEFINED> instruction: 0x3608049f
    1860:	36045201 	strcc	r5, [r4], -r1, lsl #4
    1864:	530101f4 	movwpl	r0, #4596	@ 0x11f4
    1868:	00000000 	andeq	r0, r0, r0
    186c:	7a380400 	bvc	e02874 <__ROM_SIZE__+0xdc2874>
    1870:	7a045101 	bvc	115c7c <__ROM_SIZE__+0xd5c7c>
    1874:	71030180 	smlabbvc	r3, r0, r1, r0
    1878:	00009f7d 	andeq	r9, r0, sp, ror pc
	...
    (*state)[i][1] = Multiply(a, 0x09) ^ Multiply(b, 0x0e) ^ Multiply(c, 0x0b) ^ Multiply(d, 0x0d);
    1884:	3a360400 	bcc	d8288c <__ROM_SIZE__+0xd4288c>
    1888:	327f7305 	rsbscc	r7, pc, #335544320	@ 0x14000000
    188c:	3a049f24 	bcc	129524 <__ROM_SIZE__+0xe9524>
    1890:	0072054e 	rsbseq	r0, r2, lr, asr #10
    1894:	049f2432 	ldreq	r2, [pc], #1074	@ 189c <InvMixColumns+0xd2>
    1898:	0501804e 	streq	r8, [r1, #-78]	@ 0xffffffb2
    189c:	24327c73 	ldrtcs	r7, [r2], #-3187	@ 0xfffff38d
    18a0:	0186049f 			@ <UNDEFINED> instruction: 0x0186049f
    18a4:	72050192 	andvc	r0, r5, #-2147483612	@ 0x80000024
    18a8:	9f243200 	svcls	0x00243200
    18ac:	ec019204 	sfm	f1, 1, [r1], {4}
    18b0:	7f730501 	svcvc	0x00730501
    (*state)[i][2] = Multiply(a, 0x0d) ^ Multiply(b, 0x09) ^ Multiply(c, 0x0e) ^ Multiply(d, 0x0b);
    18b4:	009f2432 	addseq	r2, pc, r2, lsr r4	@ <UNPREDICTABLE>
    18b8:	00000001 	andeq	r0, r0, r1
    18bc:	ae040000 	cdpge	0, 0, cr0, cr4, cr0, {0}
    18c0:	0101d801 	tsteq	r1, r1, lsl #16
    18c4:	01d80451 	bicseq	r0, r8, r1, asr r4
    18c8:	910201dc 	ldrdls	r0, [r2, -ip]
    18cc:	01dc0477 	bicseq	r0, ip, r7, ror r4
    18d0:	730701ec 	movwvc	r0, #29164	@ 0x71ec
    18d4:	7024327f 	eorvc	r3, r4, pc, ror r2
    18d8:	03002200 	movweq	r2, #512	@ 0x200
    18dc:	05000005 	streq	r0, [r0, #-5]
    18e0:	00000400 	andeq	r0, r0, r0, lsl #8
    (*state)[i][3] = Multiply(a, 0x0b) ^ Multiply(b, 0x0d) ^ Multiply(c, 0x09) ^ Multiply(d, 0x0e);
    18e4:	00000000 	andeq	r0, r0, r0
    18e8:	04000000 	streq	r0, [r0], #-0
    18ec:	0ac80ab8 	beq	ff2043d4 <_STACK_TOP_+0xdf1fc3d8>
    18f0:	c8045001 	stmdagt	r4, {r0, ip, lr}
    18f4:	010b800a 	tsteq	fp, sl
    18f8:	00000056 	andeq	r0, r0, r6, asr r0
    18fc:	b8040000 	stmdalt	r4, {}	@ <UNPREDICTABLE>
    1900:	010ac60a 	tsteq	sl, sl, lsl #12
    1904:	0ac60451 	beq	ff182a50 <_STACK_TOP_+0xdf17aa54>
    1908:	54010b80 	strpl	r0, [r1], #-2944	@ 0xfffff480
    190c:	00000000 	andeq	r0, r0, r0
    1910:	0ab80400 	beq	fee02918 <_STACK_TOP_+0xdedfa91c>
    1914:	52010acb 	andpl	r0, r1, #831488	@ 0xcb000
  for (i = 0; i < 4; ++i)
    1918:	800acb04 	andhi	ip, sl, r4, lsl #22
    191c:	0055010b 	subseq	r0, r5, fp, lsl #2
}
    1920:	e2040000 	and	r0, r4, #0
  for (i = 0; i < 4; ++i)
    1924:	010afb0a 	tsteq	sl, sl, lsl #22	@ <UNPREDICTABLE>
    1928:	00000053 	andeq	r0, r0, r3, asr r0
    for (j = 0; j < 4; ++j)
    192c:	e4040000 	str	r0, [r4], #-0
{
    1930:	0109fb09 	tsteq	r9, r9, lsl #22	@ <UNPREDICTABLE>
      (*state)[j][i] = getSBoxInvert((*state)[j][i]);
    1934:	09fb0450 	ldmibeq	fp!, {r4, r6, sl}^
    1938:	56010ab8 			@ <UNDEFINED> instruction: 0x56010ab8
    193c:	00000000 	andeq	r0, r0, r0
    1940:	09e40400 	stmibeq	r4!, {sl}^
    1944:	510109f8 	strdpl	r0, [r1, -r8]
    for (j = 0; j < 4; ++j)
    1948:	b809f804 	stmdalt	r9, {r2, fp, ip, sp, lr, pc}
    194c:	0055010a 	subseq	r0, r5, sl, lsl #2
  for (i = 0; i < 4; ++i)
    1950:	8c040000 	stchi	0, cr0, [r4], {-0}
    1954:	010a900a 	tsteq	sl, sl
    for (j = 0; j < 4; ++j)
    1958:	00000050 	andeq	r0, r0, r0, asr r0
}
    195c:	aa0a8e04 	bge	2a5174 <__ROM_SIZE__+0x265174>
  for (i = 0; i < 4; ++i)
    1960:	0054010a 	subseq	r0, r4, sl, lsl #2
    1964:	00000000 	andeq	r0, r0, r0
    1968:	8708fc04 	strhi	pc, [r8, -r4, lsl #24]
  temp = (*state)[3][1];
    196c:	04500109 	ldrbeq	r0, [r0], #-265	@ 0xfffffef7
  (*state)[3][1] = (*state)[2][1];
    1970:	09e40987 	stmibeq	r4!, {r0, r1, r2, r7, r8, fp}^
  (*state)[2][1] = (*state)[1][1];
    1974:	00005401 	andeq	r5, r0, r1, lsl #8
  (*state)[1][1] = (*state)[0][1];
    1978:	04000000 	streq	r0, [r0], #-0
  temp = (*state)[0][2];
    197c:	098708fc 	stmibeq	r7, {r2, r3, r4, r5, r6, r7, fp}
  (*state)[0][2] = (*state)[2][2];
    1980:	87045101 	strhi	r5, [r4, -r1, lsl #2]
  temp = (*state)[1][2];
    1984:	0109e409 	tsteq	r9, r9, lsl #8
  (*state)[1][2] = (*state)[3][2];
    1988:	00000055 	andeq	r0, r0, r5, asr r0
  temp = (*state)[0][3];
    198c:	a6040000 	strge	r0, [r4], -r0
  (*state)[0][3] = (*state)[1][3];
    1990:	0108b208 	tsteq	r8, r8, lsl #4
  (*state)[1][3] = (*state)[2][3];
    1994:	08b20450 	ldmeq	r2!, {r4, r6, sl}
  (*state)[2][3] = (*state)[3][3];
    1998:	560108fc 			@ <UNDEFINED> instruction: 0x560108fc
}
    199c:	00000000 	andeq	r0, r0, r0
{
    19a0:	08a60400 	stmiaeq	r6!, {sl}
  AddRoundKey(0, state, RoundKey);
    19a4:	510108b5 			@ <UNDEFINED> instruction: 0x510108b5
    19a8:	fc08b504 	stc2	5, cr11, [r8], {4}
    19ac:	00570108 	subseq	r0, r7, r8, lsl #2
  for (round = 1; ; ++round)
    19b0:	00000000 	andeq	r0, r0, r0
    MixColumns(state);
    19b4:	b508a604 	strlt	sl, [r8, #-1540]	@ 0xfffff9fc
    AddRoundKey(round, state, RoundKey);
    19b8:	04520108 	ldrbeq	r0, [r2], #-264	@ 0xfffffef8
    19bc:	08fc08b5 	ldmeq	ip!, {r0, r2, r4, r5, r7, fp}^
    19c0:	00005501 	andeq	r5, r0, r1, lsl #10
  for (round = 1; ; ++round)
    19c4:	08c20400 	stmiaeq	r2, {sl}^
    SubBytes(state);
    19c8:	540108fc 	strpl	r0, [r1], #-2300	@ 0xfffff704
    ShiftRows(state);
    19cc:	00000000 	andeq	r0, r0, r0
    19d0:	04000000 	streq	r0, [r0], #-0
    if (round == Nr) {
    19d4:	08bc08b8 	ldmeq	ip!, {r3, r4, r5, r7, fp}
  AddRoundKey(Nr, state, RoundKey);
    19d8:	bc045001 	stclt	0, cr5, [r4], {1}
    19dc:	0108c208 	tsteq	r8, r8, lsl #4
}
    19e0:	08c20454 	stmiaeq	r2, {r2, r4, r6, sl}^
{
    19e4:	740308c4 	strvc	r0, [r3], #-2244	@ 0xfffff73c
  AddRoundKey(Nr, state, RoundKey);
    19e8:	00009f01 	andeq	r9, r0, r1, lsl #30
    19ec:	04000000 	streq	r0, [r0], #-0
    19f0:	06e206d2 	usateq	r0, #2, r2, asr #13
  for (round = (Nr - 1); ; --round)
    19f4:	e2045001 	and	r5, r4, #1
    InvMixColumns(state);
    19f8:	0108a606 	tsteq	r8, r6, lsl #12
  for (round = (Nr - 1); ; --round)
    19fc:	00000054 	andeq	r0, r0, r4, asr r0
    InvShiftRows(state);
    1a00:	d2040000 	andle	r0, r4, #0
    1a04:	0106e006 	tsteq	r6, r6
    InvSubBytes(state);
    1a08:	06e00451 	usateq	r0, #0, r1, asr #8
    AddRoundKey(round, state, RoundKey);
    1a0c:	570108a6 	strpl	r0, [r1, -r6, lsr #17]
    1a10:	00000000 	andeq	r0, r0, r0
    1a14:	06d20400 	ldrbeq	r0, [r2], r0, lsl #8
    if (round == 0) {
    1a18:	520106e5 	andpl	r0, r1, #240123904	@ 0xe500000
  for (i = 0; i < AES_BLOCKLEN; ++i) // The block in AES is always 128bit no matter the key size
    1a1c:	a606e504 	strge	lr, [r6], -r4, lsl #10
    buf[i] ^= Iv[i];
    1a20:	00550108 	subseq	r0, r5, r8, lsl #2
    1a24:	00000000 	andeq	r0, r0, r0
    1a28:	e506d204 	str	sp, [r6, #-516]	@ 0xfffffdfc
  for (i = 0; i < AES_BLOCKLEN; ++i) // The block in AES is always 128bit no matter the key size
    1a2c:	04530106 	ldrbeq	r0, [r3], #-262	@ 0xfffffefa
    1a30:	08a606e5 	stmiaeq	r6!, {r0, r2, r5, r6, r7, r9, sl}
}
    1a34:	00005601 	andeq	r5, r0, r1, lsl #12
  KeyExpansion(ctx->RoundKey, key);
    1a38:	04000000 	streq	r0, [r0], #-0
}
    1a3c:	05ef05e4 	strbeq	r0, [pc, #1508]!	@ 2028 <gf2point_on_curve+0x3c>
{
    1a40:	ef045001 	svc	0x00045001
  KeyExpansion(ctx->RoundKey, key);
    1a44:	0106d205 	tsteq	r6, r5, lsl #4
  memcpy (ctx->Iv, iv, AES_BLOCKLEN);
    1a48:	00000054 	andeq	r0, r0, r4, asr r0
    1a4c:	e4040000 	str	r0, [r4], #-0
    1a50:	0105ef05 	tsteq	r5, r5, lsl #30
}
    1a54:	05ef0451 	strbeq	r0, [pc, #1105]!	@ 1ead <gf2point_double+0x59>
  memcpy (ctx->Iv, iv, AES_BLOCKLEN);
    1a58:	550106d2 	strpl	r0, [r1, #-1746]	@ 0xfffff92e
    1a5c:	00000000 	andeq	r0, r0, r0
}
    1a60:	05ce0400 	strbeq	r0, [lr, #1024]	@ 0x400
{
    1a64:	500105d5 	ldrdpl	r0, [r1], -r5
  Cipher((state_t*)buf, ctx->RoundKey);
    1a68:	e405d504 	str	sp, [r5], #-1284	@ 0xfffffafc
    1a6c:	01a30405 			@ <UNDEFINED> instruction: 0x01a30405
{
    1a70:	00009f50 	andeq	r9, r0, r0, asr pc
  InvCipher((state_t*)buf, ctx->RoundKey);
    1a74:	04000000 	streq	r0, [r0], #-0
    1a78:	05d505ce 	ldrbeq	r0, [r5, #1486]	@ 0x5ce
}
    1a7c:	d5045101 	strle	r5, [r4, #-257]	@ 0xfffffeff
{
    1a80:	0105e405 	tsteq	r5, r5, lsl #8
    1a84:	00000054 	andeq	r0, r0, r4, asr r0
  uint8_t *Iv = ctx->Iv;
    1a88:	be040000 	cdplt	0, 0, cr0, cr4, cr0, {0}
    1a8c:	0105c505 	tsteq	r5, r5, lsl #10
  for (i = 0; i < length; i += AES_BLOCKLEN)
    1a90:	05c50450 	strbeq	r0, [r5, #1104]	@ 0x450
    XorWithIv(buf, Iv);
    1a94:	a30405ce 	movwge	r0, #17870	@ 0x45ce
    Cipher((state_t*)buf, ctx->RoundKey);
    1a98:	009f5001 	addseq	r5, pc, r1
    1a9c:	00000000 	andeq	r0, r0, r0
  for (i = 0; i < length; i += AES_BLOCKLEN)
    1aa0:	c505be04 	strgt	fp, [r5, #-3588]	@ 0xfffff1fc
    buf += AES_BLOCKLEN;
    1aa4:	04510105 	ldrbeq	r0, [r1], #-261	@ 0xfffffefb
  for (i = 0; i < length; i += AES_BLOCKLEN)
    1aa8:	05ce05c5 	strbeq	r0, [lr, #1477]	@ 0x5c5
  memcpy(ctx->Iv, Iv, AES_BLOCKLEN);
    1aac:	00005401 	andeq	r5, r0, r1, lsl #8
    1ab0:	04000000 	streq	r0, [r0], #-0
}
    1ab4:	05b305a8 	ldreq	r0, [r3, #1448]!	@ 0x5a8
{
    1ab8:	b3045001 	movwlt	r5, #16385	@ 0x4001
    1abc:	0405be05 	streq	fp, [r5], #-3589	@ 0xfffff1fb
    1ac0:	9f5001a3 	svcls	0x005001a3
  for (i = 0; i < length; i += AES_BLOCKLEN)
    1ac4:	00000000 	andeq	r0, r0, r0
    memcpy(storeNextIv, buf, AES_BLOCKLEN);
    1ac8:	05a80400 	streq	r0, [r8, #1024]!	@ 0x400
    1acc:	510105b0 			@ <UNDEFINED> instruction: 0x510105b0
    InvCipher((state_t*)buf, ctx->RoundKey);
    1ad0:	be05b004 	cdplt	0, 0, cr11, cr5, cr4, {0}
    1ad4:	00540105 	subseq	r0, r4, r5, lsl #2
    XorWithIv(buf, ctx->Iv);
    1ad8:	00000000 	andeq	r0, r0, r0
    1adc:	b305a804 	movwlt	sl, #22532	@ 0x5804
    1ae0:	04520105 	ldrbeq	r0, [r2], #-261	@ 0xfffffefb
    memcpy(ctx->Iv, storeNextIv, AES_BLOCKLEN);
    1ae4:	05be05b3 	ldreq	r0, [lr, #1459]!	@ 0x5b3
    1ae8:	5201a304 	andpl	sl, r1, #4, 6	@ 0x10000000
    1aec:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
  for (i = 0; i < length; i += AES_BLOCKLEN)
    1af0:	a8040000 	stmdage	r4, {}	@ <UNPREDICTABLE>
    1af4:	0105b305 	tsteq	r5, r5, lsl #6
}
    1af8:	05b30453 	ldreq	r0, [r3, #1107]!	@ 0x453
{
    1afc:	550105be 	strpl	r0, [r1, #-1470]	@ 0xfffffa42
    1b00:	00000000 	andeq	r0, r0, r0
    1b04:	04000000 	streq	r0, [r0], #-0
  for (i = 0, bi = AES_BLOCKLEN; i < length; ++i, ++bi)
    1b08:	04ac04a4 	strteq	r0, [ip], #1188	@ 0x4a4
          ctx->Iv[bi] = 0;
    1b0c:	ac045001 	stcge	0, cr5, [r4], {1}
    1b10:	0105a204 	tsteq	r5, r4, lsl #4
      for (bi = (AES_BLOCKLEN - 1); bi >= 0; --bi)
    1b14:	05a20457 	streq	r0, [r2, #1111]!	@ 0x457
      bi = 0;
    1b18:	a30405a8 	movwge	r0, #17832	@ 0x45a8
    buf[i] = (buf[i] ^ buffer[bi]);
    1b1c:	009f5001 	addseq	r5, pc, r1
    1b20:	00000000 	andeq	r0, r0, r0
    1b24:	af04a404 	svcge	0x0004a404
    1b28:	04510104 	ldrbeq	r0, [r1], #-260	@ 0xfffffefc
    1b2c:	05a804af 	streq	r0, [r8, #1199]!	@ 0x4af
  for (i = 0, bi = AES_BLOCKLEN; i < length; ++i, ++bi)
    1b30:	5101a304 	tstpl	r1, r4, lsl #6
    1b34:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
    if (bi == AES_BLOCKLEN) /* we need to regen xor compliment in buffer */
    1b38:	00000000 	andeq	r0, r0, r0
      memcpy(buffer, ctx->Iv, AES_BLOCKLEN);
    1b3c:	ee04c604 	cfmadd32	mvax0, mvfx12, mvfx4, mvfx4
    1b40:	04560104 	ldrbeq	r0, [r6], #-260	@ 0xfffffefc
    1b44:	05880586 	streq	r0, [r8, #1414]	@ 0x586
      Cipher((state_t*)buffer,ctx->RoundKey);
    1b48:	70007406 	andvc	r7, r0, r6, lsl #8
    1b4c:	049f1c00 	ldreq	r1, [pc], #3072	@ 1b54 <AES_CTR_xcrypt_buffer+0x58>
      for (bi = (AES_BLOCKLEN - 1); bi >= 0; --bi)
    1b50:	059e0588 	ldreq	r0, [lr, #1416]	@ 0x588
    1b54:	00005601 	andeq	r5, r0, r1, lsl #12
        if (ctx->Iv[bi] == 255)
    1b58:	00000000 	andeq	r0, r0, r0
    1b5c:	03ae0400 			@ <UNDEFINED> instruction: 0x03ae0400
        ctx->Iv[bi] += 1;
    1b60:	500103ba 			@ <UNDEFINED> instruction: 0x500103ba
    1b64:	a003ba04 	andge	fp, r3, r4, lsl #20
      bi = 0;
    1b68:	04560104 	ldrbeq	r0, [r6], #-260	@ 0xfffffefc
}
    1b6c:	04a404a0 	strteq	r0, [r4], #1184	@ 0x4a0
  return ((x[idx / 32U] >> (idx & 31U) & 1U));
    1b70:	5001a304 	andpl	sl, r1, r4, lsl #6
    1b74:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
	...
}
    1b80:	bd03ae04 	stclt	14, cr10, [r3, #-16]
  x[idx / 32U] &= ~(1U << (idx & 31U));
    1b84:	04510103 	ldrbeq	r0, [r1], #-259	@ 0xfffffefd
    1b88:	03d203bd 	bicseq	r0, r2, #-201326590	@ 0xf4000002
    1b8c:	d2045401 	andle	r5, r4, #16777216	@ 0x1000000
    1b90:	0403d403 	streq	sp, [r3], #-1027	@ 0xfffffbfd
    1b94:	9f5101a3 	svcls	0x005101a3
    1b98:	dc03d404 	cfstrsle	mvf13, [r3], {4}
  for (i = 0; i < BITVEC_NWORDS; ++i)
    1b9c:	04540103 	ldrbeq	r0, [r4], #-259	@ 0xfffffefd
    x[i] = y[i];
    1ba0:	04a403dc 	strteq	r0, [r4], #988	@ 0x3dc
    1ba4:	5101a304 	tstpl	r1, r4, lsl #6
  for (i = 0; i < BITVEC_NWORDS; ++i)
    1ba8:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
    1bac:	00000000 	andeq	r0, r0, r0
{
    1bb0:	bd03ae04 	stclt	14, cr10, [r3, #-16]
    1bb4:	04520103 	ldrbeq	r0, [r2], #-259	@ 0xfffffefd
  bitvec_copy(tmp, x);
    1bb8:	04a003bd 	strteq	r0, [r0], #957	@ 0x3bd
    1bbc:	a0045501 	andge	r5, r4, r1, lsl #10
  bitvec_copy(x, y);
    1bc0:	0404a404 	streq	sl, [r4], #-1028	@ 0xfffffbfc
    1bc4:	9f5201a3 	svcls	0x005201a3
  bitvec_copy(y, tmp);
    1bc8:	04000000 	streq	r0, [r0], #-0
    1bcc:	04a003dc 	strteq	r0, [r0], #988	@ 0x3dc
}
    1bd0:	03005401 	movweq	r5, #1025	@ 0x401
  for (i = 0; i < BITVEC_NWORDS; ++i)
    1bd4:	04000000 	streq	r0, [r0], #-0
    1bd8:	03840382 	orreq	r0, r4, #134217730	@ 0x8000002
    if (x[i] != y[i])
    1bdc:	049f3002 	ldreq	r3, [pc], #2	@ 1be4 <bitvec_equal+0x10>
    1be0:	03a40384 			@ <UNDEFINED> instruction: 0x03a40384
    1be4:	00005301 	andeq	r5, r0, r1, lsl #6
  for (i = 0; i < BITVEC_NWORDS; ++i)
    1be8:	00000000 	andeq	r0, r0, r0
  return 1;
    1bec:	04000000 	streq	r0, [r0], #-0
}
    1bf0:	02fa02e0 	rscseq	r0, sl, #224, 4
  for (i = 0; i < BITVEC_NWORDS; ++i)
    1bf4:	fa045001 	blx	115c00 <__ROM_SIZE__+0xd5c00>
    x[i] = 0;
    1bf8:	0402fe02 	streq	pc, [r2], #-3586	@ 0xfffff1fe
  for (i = 0; i < BITVEC_NWORDS; ++i)
    1bfc:	9f5001a3 	svcls	0x005001a3
    1c00:	8002fe04 	andhi	pc, r2, r4, lsl #28
  uint32_t i = 0;
    1c04:	04500103 	ldrbeq	r0, [r0], #-259	@ 0xfffffefd
  while (i < BITVEC_NWORDS)
    1c08:	03820380 	orreq	r0, r2, #128, 6
    if (x[i] != 0)
    1c0c:	5001a304 	andpl	sl, r1, r4, lsl #6
    i += 1;
    1c10:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
}
    1c14:	fe02e604 	cdp2	6, 0, cr14, cr2, cr4, {0}
    1c18:	00530102 	subseq	r0, r3, r2, lsl #2
    1c1c:	00000002 	andeq	r0, r0, r2
  x += BITVEC_NWORDS;
    1c20:	d202d004 	andle	sp, r2, #4
          && (*(--x)) == 0)
    1c24:	9f310202 	svcls	0x00310202
    1c28:	e002d204 	and	sp, r2, r4, lsl #4
    1c2c:	00530102 	subseq	r0, r3, r2, lsl #2
    i -= 32;
    1c30:	00000000 	andeq	r0, r0, r0
  if (i != 0)
    1c34:	d8040000 	stmdale	r4, {}	@ <UNPREDICTABLE>
      i -= 1;
    1c38:	01029801 	tsteq	r2, r1, lsl #16
    while (((*x) & u32mask) == 0)
    1c3c:	02980451 	addseq	r0, r8, #1358954496	@ 0x51000000
}
    1c40:	a30402c8 	movwge	r0, #17096	@ 0x42c8
    uint32_t u32mask = ((uint32_t)1 << 31);
    1c44:	049f5101 	ldreq	r5, [pc], #257	@ 1c4c <bitvec_lshift+0x4>
{
    1c48:	02cc02c8 	sbceq	r0, ip, #200, 4	@ 0x8000000c
  int nwords = (nbits / 32);
    1c4c:	00005101 	andeq	r5, r0, r1, lsl #2
    1c50:	00000101 	andeq	r0, r0, r1, lsl #2
  for (i = 0; i < nwords; ++i)
    1c54:	01d80400 	bicseq	r0, r8, r0, lsl #8
  int nwords = (nbits / 32);
    1c58:	52010292 	andpl	r0, r1, #536870921	@ 0x20000009
    1c5c:	96029204 	strls	r9, [r2], -r4, lsl #4
    x[i] = 0;
    1c60:	00720502 	rsbseq	r0, r2, r2, lsl #10
  for (i = 0; i < nwords; ++i)
    1c64:	049f1a4f 	ldreq	r1, [pc], #2639	@ 1c6c <bitvec_lshift+0x24>
    1c68:	02cc0296 	sbceq	r0, ip, #1610612745	@ 0x60000009
  j = 0;
    1c6c:	00005201 	andeq	r5, r0, r1, lsl #4
    x[i] = y[j];
    1c70:	04000000 	streq	r0, [r0], #-0
    1c74:	01e801e4 	mvneq	r0, r4, ror #3
    i += 1;
    1c78:	ee045c01 	cdp	12, 0, cr5, cr4, cr1, {0}
    j += 1;
    1c7c:	0101fe01 	tsteq	r1, r1, lsl #28	@ <UNPREDICTABLE>
  while (i < BITVEC_NWORDS)
    1c80:	0002005c 	andeq	r0, r2, ip, asr r0
  if (nbits != 0)
    1c84:	00000000 	andeq	r0, r0, r0
}
    1c88:	e801e404 	stmda	r1, {r2, sl, sp, lr, pc}
      x[i]  = (x[i] << nbits) | (x[i - 1] >> (32 - nbits));
    1c8c:	9f300201 	svcls	0x00300201
    1c90:	9801ee04 	stmdals	r1, {r2, r9, sl, fp, sp, lr, pc}
    1c94:	04530102 	ldrbeq	r0, [r3], #-258	@ 0xfffffefe
    1c98:	02ca02c8 	sbceq	r0, sl, #200, 4	@ 0x8000000c
    1c9c:	00005301 	andeq	r5, r0, r1, lsl #6
    1ca0:	04000000 	streq	r0, [r0], #-0
    1ca4:	02980280 	addseq	r0, r8, #128, 4
    1ca8:	c8045c01 	stmdagt	r4, {r0, sl, fp, ip, lr}
    for (i = (BITVEC_NWORDS - 1); i > 0; --i)
    1cac:	0102cc02 	tsteq	r2, r2, lsl #24
    x[0] <<= nbits;
    1cb0:	0000005c 	andeq	r0, r0, ip, asr r0
    1cb4:	c2029c04 	andgt	r9, r2, #4, 24	@ 0x400
    for (i = (BITVEC_NWORDS - 1); i > 0; --i)
    1cb8:	00530102 	subseq	r0, r3, r2, lsl #2
	...
    x[i] = 0;
    1cc4:	b201ae04 	andlt	sl, r1, #4, 28	@ 0x40
  for (i = 1; i < BITVEC_NWORDS; ++i)
    1cc8:	04500101 	ldrbeq	r0, [r0], #-257	@ 0xfffffeff
    1ccc:	01b801b2 			@ <UNDEFINED> instruction: 0x01b801b2
  if (x[0] != 1)
    1cd0:	b8045301 	stmdalt	r4, {r0, r8, r9, ip, lr}
    1cd4:	0301bc01 	movweq	fp, #7169	@ 0x1c01
  for (i = 1; i < BITVEC_NWORDS; ++i)
    1cd8:	049f7c73 	ldreq	r7, [pc], #3187	@ 1ce0 <gf2field_is_one+0x10>
    if (x[i] != 0)
    1cdc:	01d801bc 	ldrheq	r0, [r8, #28]
  for (i = 1; i < BITVEC_NWORDS; ++i)
    1ce0:	02005301 	andeq	r5, r0, #67108864	@ 0x4000000
  return (i == BITVEC_NWORDS);
    1ce4:	04000000 	streq	r0, [r0], #-0
    1ce8:	01b401ae 			@ <UNDEFINED> instruction: 0x01b401ae
    1cec:	9fc00803 	svcls	0x00c00803
}
    1cf0:	d801b404 	stmdale	r1, {r2, sl, ip, sp, pc}
  for (i = 0; i < BITVEC_NWORDS; ++i)
    1cf4:	00500101 	subseq	r0, r0, r1, lsl #2
{
    1cf8:	c6040000 	strgt	r0, [r4], -r0
    z[i] = (x[i] ^ y[i]);
    1cfc:	0101d201 	tsteq	r1, r1, lsl #4
    1d00:	00000052 	andeq	r0, r0, r2, asr r0
    1d04:	94040000 	strls	r0, [r4], #-0
  for (i = 0; i < BITVEC_NWORDS; ++i)
    1d08:	0101aa01 	tsteq	r1, r1, lsl #20
    1d0c:	01aa0450 			@ <UNDEFINED> instruction: 0x01aa0450
}
    1d10:	a30401ae 	movwge	r0, #16814	@ 0x41ae
  x[0] ^= 1;
    1d14:	009f5001 	addseq	r5, pc, r1
    1d18:	00000002 	andeq	r0, r0, r2
}
    1d1c:	96019404 	strls	r9, [r1], -r4, lsl #8
{
    1d20:	9f300201 	svcls	0x00300201
    1d24:	ae019604 	cfmadd32ge	mvax0, mvfx9, mvfx1, mvfx4
  bitvec_copy(tmp, x);
    1d28:	00530101 	subseq	r0, r3, r1, lsl #2
    1d2c:	00000003 	andeq	r0, r0, r3
  if (bitvec_get_bit(y, 0) != 0)
    1d30:	86018204 	strhi	r8, [r1], -r4, lsl #4
    1d34:	9f300201 	svcls	0x00300201
    bitvec_copy(z, x);
    1d38:	94018604 	strls	r8, [r1], #-1540	@ 0xfffff9fc
    1d3c:	00530101 	subseq	r0, r3, r1, lsl #2
	...
    bitvec_set_zero(z);
    1d48:	017c6404 	cmneq	ip, r4, lsl #8
      gf2field_add(tmp, tmp, polynomial);
    1d4c:	7e7c0450 	mrcvc	4, 3, r0, cr12, cr0, {2}
    1d50:	5001a304 	andpl	sl, r1, r4, lsl #6
    1d54:	807e049f 			@ <UNDEFINED> instruction: 0x807e049f
  for (i = 1; i < CURVE_DEGREE; ++i)
    1d58:	04500101 	ldrbeq	r0, [r0], #-257	@ 0xfffffeff
    1d5c:	01820180 	orreq	r0, r2, r0, lsl #3
    bitvec_lshift(tmp, tmp, 1);
    1d60:	5001a304 	andpl	sl, r1, r4, lsl #6
    1d64:	0003009f 	muleq	r3, pc, r0	@ <UNPREDICTABLE>
    if (bitvec_get_bit(tmp, CURVE_DEGREE))
    1d68:	64040000 	strvs	r0, [r4], #-0
    1d6c:	9f300266 	svcls	0x00300266
    1d70:	01826604 	orreq	r6, r2, r4, lsl #12
    if (bitvec_get_bit(y, i))
    1d74:	00005301 	andeq	r5, r0, r1, lsl #6
    1d78:	00000000 	andeq	r0, r0, r0
    1d7c:	4c400400 	cfstrdmi	mvd0, [r0], {-0}
      gf2field_add(z, z, tmp);
    1d80:	4c045001 	stcmi	0, cr5, [r4], {1}
    1d84:	0451014f 	ldrbeq	r0, [r1], #-335	@ 0xfffffeb1
    1d88:	5501644f 	strpl	r6, [r1, #-1103]	@ 0xfffffbb1
}
    1d8c:	00000000 	andeq	r0, r0, r0
    1d90:	4a400400 	bmi	1002d98 <__ROM_SIZE__+0xfc2d98>
{
    1d94:	4a045101 	bmi	1161a0 <__ROM_SIZE__+0xd61a0>
    1d98:	00540164 	subseq	r0, r4, r4, ror #2
  bitvec_copy(u, x);
    1d9c:	00000003 	andeq	r0, r0, r3
  bitvec_copy(v, polynomial);
    1da0:	02302c04 	eorseq	r2, r0, #4, 24	@ 0x400
    1da4:	30049f30 	andcc	r9, r4, r0, lsr pc
  bitvec_set_zero(g);
    1da8:	00530140 	subseq	r0, r3, r0, asr #2
    1dac:	00000000 	andeq	r0, r0, r0
  gf2field_set_one(z);
    1db0:	011e1204 	tsteq	lr, r4, lsl #4
  while (!gf2field_is_one(u))
    1db4:	2c1e0451 	cfldrscs	mvf0, [lr], {81}	@ 0x51
    bitvec_lshift(h, v, i);
    1db8:	5101a304 	tstpl	r1, r4, lsl #6
    1dbc:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
    gf2field_add(u, u, h);
    1dc0:	00040000 	andeq	r0, r4, r0
    1dc4:	04500106 	ldrbeq	r0, [r0], #-262	@ 0xfffffefa
    1dc8:	a3041206 	movwge	r1, #16902	@ 0x4206
    bitvec_lshift(h, g, i);
    1dcc:	009f5001 	addseq	r5, pc, r1
    1dd0:	00000000 	andeq	r0, r0, r0
    gf2field_add(z, z, h);
    1dd4:	010a0004 	tsteq	sl, r4
    1dd8:	120a0451 	andne	r0, sl, #1358954496	@ 0x51000000
    1ddc:	5101a304 	tstpl	r1, r4, lsl #6
  while (!gf2field_is_one(u))
    1de0:	009d009f 	umullseq	r0, sp, pc, r0	@ <UNPREDICTABLE>
    1de4:	00050000 	andeq	r0, r5, r0
    i = (bitvec_degree(u) - bitvec_degree(v));
    1de8:	00000004 	andeq	r0, r0, r4
    1dec:	00000000 	andeq	r0, r0, r0
    1df0:	1e040000 	cdpne	0, 0, cr0, cr4, cr0, {0}
    1df4:	04500124 	ldrbeq	r0, [r0], #-292	@ 0xfffffedc
    if (i < 0)
    1df8:	5c015c24 	stcpl	12, cr5, [r1], {36}	@ 0x24
      bitvec_swap(u, v);
    1dfc:	00000100 	andeq	r0, r0, r0, lsl #2
    1e00:	00000101 	andeq	r0, r0, r1, lsl #2
      bitvec_swap(g, z);
    1e04:	26200400 	strtcs	r0, [r0], -r0, lsl #8
    1e08:	049f3002 	ldreq	r3, [pc], #2	@ 1e10 <gf2field_inv+0x7c>
      i = -i;
    1e0c:	50013226 	andpl	r3, r1, r6, lsr #4
}
    1e10:	05363204 	ldreq	r3, [r6, #-516]!	@ 0xfffffdfc
    1e14:	24340070 	ldrtcs	r0, [r4], #-112	@ 0xffffff90
{
    1e18:	5c36049f 	cfldrspl	mvf0, [r6], #-636	@ 0xfffffd84
    1e1c:	02005001 	andeq	r5, r0, #1
  bitvec_copy(x1, x2);
    1e20:	00000000 	andeq	r0, r0, r0
  bitvec_copy(y1, y2);
    1e24:	04000000 	streq	r0, [r0], #-0
    1e28:	30022620 	andcc	r2, r2, r0, lsr #12
}
    1e2c:	3632049f 			@ <UNDEFINED> instruction: 0x3632049f
{
    1e30:	4a045301 	bmi	116a3c <__ROM_SIZE__+0xd6a3c>
  bitvec_set_zero(x);
    1e34:	0453014c 	ldrbeq	r0, [r3], #-332	@ 0xfffffeb4
  bitvec_set_zero(y);
    1e38:	53015a58 	movwpl	r5, #6744	@ 0x1a58
}
    1e3c:	00000400 	andeq	r0, r0, r0, lsl #8
{
    1e40:	26200400 	strtcs	r0, [r0], -r0, lsl #8
  return (    bitvec_is_zero(x)
    1e44:	049f3002 	ldreq	r3, [pc], #2	@ 1e4c <gf2point_is_zero+0xe>
           && bitvec_is_zero(y));
    1e48:	51015c26 	tstpl	r1, r6, lsr #24
    1e4c:	00000000 	andeq	r0, r0, r0
    1e50:	06000400 	streq	r0, [r0], -r0, lsl #8
{
    1e54:	06045001 	streq	r5, [r4], -r1
    1e58:	0051011e 	subseq	r0, r1, lr, lsl r1
  if (bitvec_is_zero(x))
    1e5c:	00000001 	andeq	r0, r0, r1
    1e60:	02040000 	andeq	r0, r4, #0
    bitvec_set_zero(y);
    1e64:	9f300208 	svcls	0x00300208
}
    1e68:	010c0804 	tsteq	ip, r4, lsl #16
    gf2field_inv(l, x);
    1e6c:	1e140450 	cfmvrsne	r0, mvf4
    1e70:	03005001 	movweq	r5, #1
    gf2field_mul(l, l, y);
    1e74:	04000000 	streq	r0, [r0], #-0
    1e78:	30020802 	andcc	r0, r2, r2, lsl #16
    1e7c:	1e08049f 	mcrne	4, 0, r0, cr8, cr15, {4}
    gf2field_add(l, l, x);
    1e80:	74005201 	strvc	r5, [r0], #-513	@ 0xfffffdff
    1e84:	05000000 	streq	r0, [r0, #-0]
    gf2field_mul(y, x, x);
    1e88:	00000400 	andeq	r0, r0, r0, lsl #8
    1e8c:	00000000 	andeq	r0, r0, r0
    1e90:	04000000 	streq	r0, [r0], #-0
    gf2field_mul(x, l, l);
    1e94:	50016858 	andpl	r6, r1, r8, asr r8
    1e98:	01706a04 	cmneq	r0, r4, lsl #20
    gf2field_inc(l);
    1e9c:	00000050 	andeq	r0, r0, r0, asr r0
    1ea0:	00000000 	andeq	r0, r0, r0
    gf2field_add(x, x, l);
    1ea4:	01290004 			@ <UNDEFINED> instruction: 0x01290004
    1ea8:	2c290450 	cfstrscs	mvf0, [r9], #-320	@ 0xfffffec0
    gf2field_mul(l, l, x);
    1eac:	5001a304 	andpl	sl, r1, r4, lsl #6
    1eb0:	402c049f 	mlami	ip, pc, r4, r0	@ <UNPREDICTABLE>
    1eb4:	00005001 	andeq	r5, r0, r1
    gf2field_add(y, y, l);
    1eb8:	00000000 	andeq	r0, r0, r0
    1ebc:	04000000 	streq	r0, [r0], #-0
}
    1ec0:	51012600 	tstpl	r1, r0, lsl #12
{
    1ec4:	01292604 			@ <UNDEFINED> instruction: 0x01292604
    1ec8:	2c290452 	cfstrscs	mvf0, [r9], #-328	@ 0xfffffeb8
    1ecc:	5101a304 	tstpl	r1, r4, lsl #6
  if (!gf2point_is_zero(x2, y2))
    1ed0:	402c049f 	mlami	ip, pc, r4, r0	@ <UNPREDICTABLE>
    1ed4:	00005101 	andeq	r5, r0, r1, lsl #2
    if (gf2point_is_zero(x1, y1))
    1ed8:	00000000 	andeq	r0, r0, r0
    1edc:	04000000 	streq	r0, [r0], #-0
    1ee0:	52012400 	andpl	r2, r1, #0, 8
      if (bitvec_equal(x1, x2))
    1ee4:	05292404 	streq	r2, [r9, #-1028]!	@ 0xfffffbfc
    1ee8:	00012403 	andeq	r2, r1, r3, lsl #8
        if (bitvec_equal(y1, y2))
    1eec:	2c290420 	cfstrscs	mvf0, [r9], #-128	@ 0xffffff80
    1ef0:	5201a304 	andpl	sl, r1, #4, 6	@ 0x10000000
    1ef4:	402c049f 	mlami	ip, pc, r4, r0	@ <UNPREDICTABLE>
          gf2point_double(x1, y1);
    1ef8:	dc005201 	sfmle	f5, 4, [r0], {1}
    1efc:	05000000 	streq	r0, [r0, #-0]
      gf2point_copy(x1, y1, x2, y2);
    1f00:	00000400 	andeq	r0, r0, r0, lsl #8
    1f04:	00000000 	andeq	r0, r0, r0
    1f08:	04000000 	streq	r0, [r0], #-0
}
    1f0c:	50015e50 	andpl	r5, r1, r0, asr lr
          gf2point_set_zero(x1, y1);
    1f10:	04605e04 	strbteq	r5, [r0], #-3588	@ 0xfffff1fc
    1f14:	9f5001a3 	svcls	0x005001a3
    1f18:	00000400 	andeq	r0, r0, r0, lsl #8
        gf2field_add(a, y1, y2);
    1f1c:	54500400 	ldrbpl	r0, [r0], #-1024	@ 0xfffffc00
    1f20:	049f3002 	ldreq	r3, [pc], #2	@ 1f28 <gf2point_add+0x66>
        gf2field_add(b, x1, x2);
    1f24:	53016054 	movwpl	r6, #4180	@ 0x1054
    1f28:	00000300 	andeq	r0, r0, r0, lsl #6
    1f2c:	5e500400 	cdppl	4, 5, cr0, cr0, cr0, {0}
        gf2field_inv(c, b);
    1f30:	5e045001 	cdppl	0, 0, cr5, cr4, cr1, {0}
    1f34:	01a30460 			@ <UNDEFINED> instruction: 0x01a30460
        gf2field_mul(c, c, a);
    1f38:	00009f50 	andeq	r9, r0, r0, asr pc
    1f3c:	04000000 	streq	r0, [r0], #-0
        gf2field_mul(d, c, c);
    1f40:	50014e3a 	andpl	r4, r1, sl, lsr lr
    1f44:	04504e04 	ldrbeq	r4, [r0], #-3588	@ 0xfffff1fc
    1f48:	9f5001a3 	svcls	0x005001a3
        gf2field_add(d, d, c);
    1f4c:	00000500 	andeq	r0, r0, r0, lsl #10
    1f50:	3e3a0400 	cfabsscc	mvf0, mvf10
        gf2field_add(d, d, b);
    1f54:	049f3002 	ldreq	r3, [pc], #2	@ 1f5c <gf2point_add+0x9a>
    1f58:	5301503e 	movwpl	r5, #4158	@ 0x103e
    1f5c:	04000300 	streq	r0, [r0], #-768	@ 0xfffffd00
        gf2field_inc(d);
    1f60:	5101503a 	tstpl	r1, sl, lsr r0
        gf2field_add(x1, x1, d);
    1f64:	00000400 	andeq	r0, r0, r0, lsl #8
    1f68:	4e3a0400 	cfabssmi	mvf0, mvf10
    1f6c:	4e045001 	cdpmi	0, 0, cr5, cr4, cr1, {0}
        gf2field_mul(a, x1, c);
    1f70:	01a30450 			@ <UNDEFINED> instruction: 0x01a30450
    1f74:	00009f50 	andeq	r9, r0, r0, asr pc
        gf2field_add(a, a, d);
    1f78:	00000000 	andeq	r0, r0, r0
    1f7c:	2a260400 	bcs	982f84 <__ROM_SIZE__+0x942f84>
    1f80:	2a045001 	bcs	115f8c <__ROM_SIZE__+0xd5f8c>
        gf2field_add(y1, y1, a);
    1f84:	0170032e 	cmneq	r0, lr, lsr #6
    1f88:	382e049f 	stmdacc	lr!, {r0, r1, r2, r3, r4, r7, sl}
        bitvec_copy(x1, d);
    1f8c:	00005001 	andeq	r5, r0, r1
    1f90:	04000000 	streq	r0, [r0], #-0
}
    1f94:	51012a26 	tstpl	r1, r6, lsr #20
{
    1f98:	013a2a04 	teqeq	sl, r4, lsl #20
    1f9c:	00000051 	andeq	r0, r0, r1, asr r0
  int nbits = bitvec_degree(exp);
    1fa0:	10040000 	andne	r0, r4, r0
    1fa4:	04500114 	ldrbeq	r0, [r0], #-276	@ 0xfffffeec
  gf2point_set_zero(tmpx, tmpy);
    1fa8:	50012214 	andpl	r2, r1, r4, lsl r2
    1fac:	00000000 	andeq	r0, r0, r0
  for (i = (nbits - 1); i >= 0; --i)
    1fb0:	16100400 	ldrne	r0, [r0], -r0, lsl #8
    1fb4:	16045101 	strne	r5, [r4], -r1, lsl #2
    1fb8:	00510126 	subseq	r0, r1, r6, lsr #2
    gf2point_double(tmpx, tmpy);
    1fbc:	00000000 	andeq	r0, r0, r0
    1fc0:	01040004 	tsteq	r4, r4
    if (bitvec_get_bit(exp, i))
    1fc4:	10040450 	andne	r0, r4, r0, asr r4
    1fc8:	01005201 	tsteq	r0, r1, lsl #4
    1fcc:	04000000 	streq	r0, [r0], #-0
      gf2point_add(tmpx, tmpy, x, y);
    1fd0:	30020602 	andcc	r0, r2, r2, lsl #12
    1fd4:	1006049f 	mulne	r6, pc, r4	@ <UNPREDICTABLE>
    1fd8:	Address 0x1fd8 is out of bounds.


Disassembly of section .debug_aranges:

00000000 <.debug_aranges>:
   0:	0000001c 	andeq	r0, r0, ip, lsl r0
   4:	00000002 	andeq	r0, r0, r2
   8:	00040000 	andeq	r0, r4, r0
   c:	00000000 	andeq	r0, r0, r0
  10:	000003c0 	andeq	r0, r0, r0, asr #7
  14:	00000064 	andeq	r0, r0, r4, rrx
	...
  20:	0000001c 	andeq	r0, r0, ip, lsl r0
  24:	02050002 	andeq	r0, r5, #2
  28:	00040000 	andeq	r0, r4, r0
  2c:	00000000 	andeq	r0, r0, r0
  30:	00000424 	andeq	r0, r0, r4, lsr #8
  34:	00000002 	andeq	r0, r0, r2
	...
  40:	0000001c 	andeq	r0, r0, ip, lsl r0
  44:	02c60002 	sbceq	r0, r6, #2
  48:	00040000 	andeq	r0, r4, r0
  4c:	00000000 	andeq	r0, r0, r0
  50:	00000428 	andeq	r0, r0, r8, lsr #8
  54:	00000064 	andeq	r0, r0, r4, rrx
	...
  60:	0000001c 	andeq	r0, r0, ip, lsl r0
  64:	035b0002 	cmpeq	fp, #2
  68:	00040000 	andeq	r0, r4, r0
  6c:	00000000 	andeq	r0, r0, r0
  70:	0000048c 	andeq	r0, r0, ip, lsl #9
  74:	00000064 	andeq	r0, r0, r4, rrx
	...
  80:	0000001c 	andeq	r0, r0, ip, lsl r0
  84:	03f00002 	mvnseq	r0, #2
  88:	00040000 	andeq	r0, r4, r0
  8c:	00000000 	andeq	r0, r0, r0
  90:	000004f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
  94:	0000008c 	andeq	r0, r0, ip, lsl #1
	...
  a0:	0000001c 	andeq	r0, r0, ip, lsl r0
  a4:	05730002 	ldrbeq	r0, [r3, #-2]!
  a8:	00040000 	andeq	r0, r4, r0
  ac:	00000000 	andeq	r0, r0, r0
  b0:	0000057c 	andeq	r0, r0, ip, ror r5
  b4:	0000001c 	andeq	r0, r0, ip, lsl r0
	...
  c0:	0000001c 	andeq	r0, r0, ip, lsl r0
  c4:	07020002 	streq	r0, [r2, -r2]
  c8:	00040000 	andeq	r0, r4, r0
  cc:	00000000 	andeq	r0, r0, r0
  d0:	00000598 	muleq	r0, r8, r5
  d4:	00000094 	muleq	r0, r4, r0
	...
  e0:	0000001c 	andeq	r0, r0, ip, lsl r0
  e4:	0a9b0002 	beq	fe6c00f4 <_STACK_TOP_+0xde6b80f8>
  e8:	00040000 	andeq	r0, r4, r0
  ec:	00000000 	andeq	r0, r0, r0
  f0:	0000062c 	andeq	r0, r0, ip, lsr #12
  f4:	000000d0 	ldrdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
	...
 100:	0000001c 	andeq	r0, r0, ip, lsl r0
 104:	0e500002 	cdpeq	0, 5, cr0, cr0, cr2, {0}
 108:	00040000 	andeq	r0, r4, r0
 10c:	00000000 	andeq	r0, r0, r0
 110:	000006fc 	strdeq	r0, [r0], -ip
 114:	0000001c 	andeq	r0, r0, ip, lsl r0
	...
 120:	0000001c 	andeq	r0, r0, ip, lsl r0
 124:	0fdf0002 	svceq	0x00df0002
 128:	00040000 	andeq	r0, r4, r0
 12c:	00000000 	andeq	r0, r0, r0
 130:	00000718 	andeq	r0, r0, r8, lsl r7
 134:	0000065c 	andeq	r0, r0, ip, asr r6
	...
 140:	0000001c 	andeq	r0, r0, ip, lsl r0
 144:	1ec20002 	cdpne	0, 12, cr0, cr2, cr2, {0}
 148:	00040000 	andeq	r0, r4, r0
 14c:	00000000 	andeq	r0, r0, r0
 150:	00000d74 	andeq	r0, r0, r4, ror sp
 154:	0000025c 	andeq	r0, r0, ip, asr r2
	...
 160:	0000001c 	andeq	r0, r0, ip, lsl r0
 164:	21cb0002 	biccs	r0, fp, r2
 168:	00040000 	andeq	r0, r4, r0
 16c:	00000000 	andeq	r0, r0, r0
 170:	00000fd0 	ldrdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
 174:	00000238 	andeq	r0, r0, r8, lsr r2
	...
 180:	0000001c 	andeq	r0, r0, ip, lsl r0
 184:	24fa0002 	ldrbtcs	r0, [sl], #2
 188:	00040000 	andeq	r0, r4, r0
 18c:	00000000 	andeq	r0, r0, r0
 190:	00001208 	andeq	r1, r0, r8, lsl #4
 194:	00000238 	andeq	r0, r0, r8, lsr r2
	...
 1a0:	0000001c 	andeq	r0, r0, ip, lsl r0
 1a4:	28290002 	stmdacs	r9!, {r1}
 1a8:	00040000 	andeq	r0, r4, r0
 1ac:	00000000 	andeq	r0, r0, r0
 1b0:	00001440 	andeq	r1, r0, r0, asr #8
 1b4:	00000160 	andeq	r0, r0, r0, ror #2
	...
 1c0:	0000001c 	andeq	r0, r0, ip, lsl r0
 1c4:	2d950002 	ldccs	0, cr0, [r5, #8]
 1c8:	00040000 	andeq	r0, r4, r0
 1cc:	00000000 	andeq	r0, r0, r0
 1d0:	000015a0 	andeq	r1, r0, r0, lsr #11
 1d4:	000005d0 	ldrdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
	...
 1e0:	0000001c 	andeq	r0, r0, ip, lsl r0
 1e4:	39c80002 	stmibcc	r8, {r1}^
 1e8:	00040000 	andeq	r0, r4, r0
 1ec:	00000000 	andeq	r0, r0, r0
 1f0:	00001b70 	andeq	r1, r0, r0, ror fp
 1f4:	00000580 	andeq	r0, r0, r0, lsl #11
	...
 200:	0000001c 	andeq	r0, r0, ip, lsl r0
 204:	4c0d0002 	stcmi	0, cr0, [sp], {2}
 208:	00040000 	andeq	r0, r4, r0
 20c:	00000000 	andeq	r0, r0, r0
 210:	000020f0 	strdeq	r2, [r0], -r0
 214:	0000005c 	andeq	r0, r0, ip, asr r0
	...
 220:	0000001c 	andeq	r0, r0, ip, lsl r0
 224:	4d580002 	ldclmi	0, cr0, [r8, #-8]
 228:	00040000 	andeq	r0, r4, r0
 22c:	00000000 	andeq	r0, r0, r0
 230:	0000214c 	andeq	r2, r0, ip, asr #2
 234:	000000ac 	andeq	r0, r0, ip, lsr #1
	...
 240:	0000001c 	andeq	r0, r0, ip, lsl r0
 244:	4f820002 	svcmi	0x00820002
 248:	00040000 	andeq	r0, r4, r0
 24c:	00000000 	andeq	r0, r0, r0
 250:	000021f8 	strdeq	r2, [r0], -r8
 254:	00000060 	andeq	r0, r0, r0, rrx
	...

Disassembly of section .debug_line:

00000000 <.debug_line>:
       0:	00000138 	andeq	r0, r0, r8, lsr r1
       4:	00d70003 	sbcseq	r0, r7, r3
       8:	01020000 	mrseq	r0, (UNDEF: 2)
       c:	000d0efb 	strdeq	r0, [sp], -fp
      10:	01010101 	tsteq	r1, r1, lsl #2
      14:	01000000 	mrseq	r0, (UNDEF: 0)
      18:	2f010000 	svccs	0x00010000
      1c:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
      20:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
      24:	63652f66 	cmnvs	r5, #408	@ 0x198
      28:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
      2c:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
      30:	652f7265 	strvs	r7, [pc, #-613]!	@ fffffdd3 <_STACK_TOP_+0xdfff7dd7>
      34:	2f667463 	svccs	0x00667463
      38:	00626f66 	rsbeq	r6, r2, r6, ror #30
      3c:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ ffffff88 <_STACK_TOP_+0xdfff7f8c>
      40:	63652f65 	cmnvs	r5, #404	@ 0x194
      44:	652f6674 	strvs	r6, [pc, #-1652]!	@ fffff9d8 <_STACK_TOP_+0xdfff79dc>
      48:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
      4c:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
      50:	2f72656e 	svccs	0x0072656e
      54:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
      58:	68732f6c 	ldmdavs	r3!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
      5c:	006c6c65 	rsbeq	r6, ip, r5, ror #24
      60:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ ffffffac <_STACK_TOP_+0xdfff7fb0>
      64:	63652f65 	cmnvs	r5, #404	@ 0x194
      68:	652f6674 	strvs	r6, [pc, #-1652]!	@ fffff9fc <_STACK_TOP_+0xdfff7a00>
      6c:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
      70:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
      74:	2f72656e 	svccs	0x0072656e
      78:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
      7c:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
      80:	74732f62 	ldrbtvc	r2, [r3], #-3938	@ 0xfffff09e
      84:	676e6972 			@ <UNDEFINED> instruction: 0x676e6972
      88:	6f682f00 	svcvs	0x00682f00
      8c:	652f656d 	strvs	r6, [pc, #-1389]!	@ fffffb27 <_STACK_TOP_+0xdfff7b2b>
      90:	2f667463 	svccs	0x00667463
      94:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
      98:	6172742d 	cmnvs	r2, sp, lsr #8
      9c:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
      a0:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
      a4:	6c2f6c6c 	stcvs	12, cr6, [pc], #-432	@ fffffefc <_STACK_TOP_+0xdfff7f00>
      a8:	702f6269 	eorvc	r6, pc, r9, ror #4
      ac:	746e6972 	strbtvc	r6, [lr], #-2418	@ 0xfffff68e
      b0:	6d000066 	stcvs	0, cr0, [r0, #-408]	@ 0xfffffe68
      b4:	2e677365 	cdpcs	3, 6, cr7, cr7, cr5, {3}
      b8:	00010063 	andeq	r0, r1, r3, rrx
      bc:	65687300 	strbvs	r7, [r8, #-768]!	@ 0xfffffd00
      c0:	682e6c6c 	stmdavs	lr!, {r2, r3, r5, r6, sl, fp, sp, lr}
      c4:	00000200 	andeq	r0, r0, r0, lsl #4
      c8:	69727473 	ldmdbvs	r2!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
      cc:	682e676e 	stmdavs	lr!, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}
      d0:	00000300 	andeq	r0, r0, r0, lsl #6
      d4:	6e697270 	mcrvs	2, 3, r7, cr9, cr0, {3}
      d8:	682e6674 	stmdavs	lr!, {r2, r4, r5, r6, r9, sl, sp, lr}
      dc:	00000400 	andeq	r0, r0, r0, lsl #8
      e0:	00250500 	eoreq	r0, r5, r0, lsl #10
      e4:	03c00205 	biceq	r0, r0, #1342177280	@ 0x50000000
      e8:	06160000 	ldreq	r0, [r6], -r0
      ec:	06050501 	streq	r0, [r5], -r1, lsl #10
      f0:	2006133d 	andcs	r1, r6, sp, lsr r3
      f4:	0e052f06 	cdpeq	15, 0, cr2, cr5, cr6, {0}
      f8:	05050106 	streq	r0, [r5, #-262]	@ 0xfffffefa
      fc:	00090520 	andeq	r0, r9, r0, lsr #10
     100:	06030402 	streq	r0, [r3], -r2, lsl #8
     104:	00220521 	eoreq	r0, r2, r1, lsr #10
     108:	57030402 	strpl	r0, [r3, -r2, lsl #8]
     10c:	02001705 	andeq	r1, r0, #1310720	@ 0x140000
     110:	05200104 	streq	r0, [r0, #-260]!	@ 0xfffffefc
     114:	053e3105 	ldreq	r3, [lr, #-261]!	@ 0xfffffefb
     118:	05010608 	streq	r0, [r1, #-1544]	@ 0xfffff9f8
     11c:	0a030605 	beq	c1938 <__ROM_SIZE__+0x81938>
     120:	0601052e 	streq	r0, [r1], -lr, lsr #10
     124:	06090513 			@ <UNDEFINED> instruction: 0x06090513
     128:	052e7703 	streq	r7, [lr, #-1795]!	@ 0xfffff8fd
     12c:	0501060d 	streq	r0, [r1, #-1549]	@ 0xfffff9f3
     130:	0d054a0c 	vstreq	s8, [r5, #-48]	@ 0xffffffd0
     134:	024d2106 	subeq	r2, sp, #-2147483647	@ 0x80000001
     138:	01010012 	tsteq	r1, r2, lsl r0
     13c:	000000c0 	andeq	r0, r0, r0, asr #1
     140:	009b0003 	addseq	r0, fp, r3
     144:	01020000 	mrseq	r0, (UNDEF: 2)
     148:	000d0efb 	strdeq	r0, [sp], -fp
     14c:	01010101 	tsteq	r1, r1, lsl #2
     150:	01000000 	mrseq	r0, (UNDEF: 0)
     154:	2f010000 	svccs	0x00010000
     158:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
     15c:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
     160:	63652f66 	cmnvs	r5, #408	@ 0x198
     164:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
     168:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
     16c:	652f7265 	strvs	r7, [pc, #-613]!	@ ffffff0f <_STACK_TOP_+0xdfff7f13>
     170:	2f667463 	svccs	0x00667463
     174:	2f626f66 	svccs	0x00626f66
     178:	74616c70 	strbtvc	r6, [r1], #-3184	@ 0xfffff390
     17c:	6d726f66 	ldclvs	15, cr6, [r2, #-408]!	@ 0xfffffe68
     180:	706f2f00 	rsbvc	r2, pc, r0, lsl #30
     184:	63672f74 	cmnvs	r7, #116, 30	@ 0x1d0
     188:	72612d63 	rsbvc	r2, r1, #6336	@ 0x18c0
     18c:	6f6e2d6d 	svcvs	0x006e2d6d
     190:	652d656e 	strvs	r6, [sp, #-1390]!	@ 0xfffffa92
     194:	2f696261 	svccs	0x00696261
     198:	2f62696c 	svccs	0x0062696c
     19c:	2f636367 	svccs	0x00636367
     1a0:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	@ 0xfffffe7c
     1a4:	656e6f6e 	strbvs	r6, [lr, #-3950]!	@ 0xfffff092
     1a8:	6261652d 	rsbvs	r6, r1, #188743680	@ 0xb400000
     1ac:	32312f69 	eorscc	r2, r1, #420	@ 0x1a4
     1b0:	312e322e 			@ <UNDEFINED> instruction: 0x312e322e
     1b4:	636e692f 	cmnvs	lr, #770048	@ 0xbc000
     1b8:	6564756c 	strbvs	r7, [r4, #-1388]!	@ 0xfffffa94
     1bc:	65760000 	ldrbvs	r0, [r6, #-0]!
     1c0:	726f7463 	rsbvc	r7, pc, #1660944384	@ 0x63000000
     1c4:	6261745f 	rsbvs	r7, r1, #1593835520	@ 0x5f000000
     1c8:	632e656c 			@ <UNDEFINED> instruction: 0x632e656c
     1cc:	00000100 	andeq	r0, r0, r0, lsl #2
     1d0:	69647473 	stmdbvs	r4!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
     1d4:	672d746e 	strvs	r7, [sp, -lr, ror #8]!
     1d8:	682e6363 	stmdavs	lr!, {r0, r1, r5, r6, r8, r9, sp, lr}
     1dc:	00000200 	andeq	r0, r0, r0, lsl #4
     1e0:	001c0500 	andseq	r0, ip, r0, lsl #10
     1e4:	04240205 	strteq	r0, [r4], #-517	@ 0xfffffdfb
     1e8:	16030000 	strne	r0, [r3], -r0
     1ec:	00030501 	andeq	r0, r3, r1, lsl #10
     1f0:	13010402 	movwne	r0, #5122	@ 0x1402
     1f4:	02000905 	andeq	r0, r0, #81920	@ 0x14000
     1f8:	02010104 	andeq	r0, r1, #4, 2
     1fc:	01010001 	tsteq	r1, r1
     200:	000000f9 	strdeq	r0, [r0], -r9
     204:	004c0003 	subeq	r0, ip, r3
     208:	01020000 	mrseq	r0, (UNDEF: 2)
     20c:	000d0efb 	strdeq	r0, [sp], -fp
     210:	01010101 	tsteq	r1, r1, lsl #2
     214:	01000000 	mrseq	r0, (UNDEF: 0)
     218:	2f010000 	svccs	0x00010000
     21c:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
     220:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
     224:	63652f66 	cmnvs	r5, #408	@ 0x198
     228:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
     22c:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
     230:	652f7265 	strvs	r7, [pc, #-613]!	@ ffffffd3 <_STACK_TOP_+0xdfff7fd7>
     234:	2f667463 	svccs	0x00667463
     238:	2f626f66 	svccs	0x00626f66
     23c:	74616c70 	strbtvc	r6, [r1], #-3184	@ 0xfffff390
     240:	6d726f66 	ldclvs	15, cr6, [r2, #-408]!	@ 0xfffffe68
     244:	7261752f 	rsbvc	r7, r1, #197132288	@ 0xbc00000
     248:	75000074 	strvc	r0, [r0, #-116]	@ 0xffffff8c
     24c:	2e747261 	cdpcs	2, 7, cr7, cr4, cr1, {3}
     250:	00010063 	andeq	r0, r1, r3, rrx
     254:	14050000 	strne	r0, [r5], #-0
     258:	28020500 	stmdacs	r2, {r8, sl}
     25c:	03000004 	movweq	r0, #4
     260:	01060112 	tsteq	r6, r2, lsl r1
     264:	02000a05 	andeq	r0, r0, #20480	@ 0x5000
     268:	21060104 	tstcs	r6, r4, lsl #2
     26c:	02000b05 	andeq	r0, r0, #5120	@ 0x1400
     270:	01060104 	tsteq	r6, r4, lsl #2
     274:	02000a05 	andeq	r0, r0, #20480	@ 0x5000
     278:	052e0104 	streq	r0, [lr, #-260]!	@ 0xfffffefc
     27c:	053f0603 	ldreq	r0, [pc, #-1539]!	@ fffffc81 <_STACK_TOP_+0xdfff7c85>
     280:	0501060b 	streq	r0, [r1, #-1547]	@ 0xfffff9f5
     284:	052f0603 	streq	r0, [pc, #-1539]!	@ fffffc89 <_STACK_TOP_+0xdfff7c8d>
     288:	05010606 	streq	r0, [r1, #-1542]	@ 0xfffff9fa
     28c:	05053001 	streq	r3, [r5, #-1]
     290:	20061f06 	andcs	r1, r6, r6, lsl #30
     294:	052f0105 	streq	r0, [pc, #-261]!	@ 197 <vector_table+0x197>
     298:	05000611 	streq	r0, [r0, #-1553]	@ 0xfffff9ef
     29c:	00044c02 	andeq	r4, r4, r2, lsl #24
     2a0:	03051400 	movweq	r1, #21504	@ 0x5400
     2a4:	060a0513 			@ <UNDEFINED> instruction: 0x060a0513
     2a8:	2e060501 	cfsh32cs	mvfx0, mvfx6, #1
     2ac:	02001d05 	andeq	r1, r0, #320	@ 0x140
     2b0:	3c060104 	stfccs	f0, [r6], {4}
     2b4:	02002405 	andeq	r2, r0, #83886080	@ 0x5000000
     2b8:	01060104 	tsteq	r6, r4, lsl #2
     2bc:	053e0a05 	ldreq	r0, [lr, #-2565]!	@ 0xfffff5fb
     2c0:	16052f01 	strne	r2, [r5], -r1, lsl #30
     2c4:	03054c06 	movweq	r4, #23558	@ 0x5c06
     2c8:	060b0514 			@ <UNDEFINED> instruction: 0x060b0514
     2cc:	06030501 	streq	r0, [r3], -r1, lsl #10
     2d0:	060c053f 			@ <UNDEFINED> instruction: 0x060c053f
     2d4:	06030501 	streq	r0, [r3], -r1, lsl #10
     2d8:	060c052f 	streq	r0, [ip], -pc, lsr #10
     2dc:	06030501 	streq	r0, [r3], -r1, lsl #10
     2e0:	060a0531 			@ <UNDEFINED> instruction: 0x060a0531
     2e4:	06030501 	streq	r0, [r3], -r1, lsl #10
     2e8:	060c0531 			@ <UNDEFINED> instruction: 0x060c0531
     2ec:	06030501 	streq	r0, [r3], -r1, lsl #10
     2f0:	060b0531 			@ <UNDEFINED> instruction: 0x060b0531
     2f4:	3d010501 	cfstr32cc	mvfx0, [r1, #-4]
     2f8:	01000402 	tsteq	r0, r2, lsl #8
     2fc:	0000fa01 	andeq	pc, r0, r1, lsl #20
     300:	4d000300 	stcmi	3, cr0, [r0, #-0]
     304:	02000000 	andeq	r0, r0, #0
     308:	0d0efb01 	vstreq	d15, [lr, #-4]
     30c:	01010100 	mrseq	r0, (UNDEF: 17)
     310:	00000001 	andeq	r0, r0, r1
     314:	01000001 	tsteq	r0, r1
     318:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 264 <vector_table+0x264>
     31c:	63652f65 	cmnvs	r5, #404	@ 0x194
     320:	652f6674 	strvs	r6, [pc, #-1652]!	@ fffffcb4 <_STACK_TOP_+0xdfff7cb8>
     324:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
     328:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
     32c:	2f72656e 	svccs	0x0072656e
     330:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
     334:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
     338:	616c702f 	cmnvs	ip, pc, lsr #32
     33c:	726f6674 	rsbvc	r6, pc, #116, 12	@ 0x7400000
     340:	61752f6d 	cmnvs	r5, sp, ror #30
     344:	00007472 	andeq	r7, r0, r2, ror r4
     348:	74726175 	ldrbtvc	r6, [r2], #-373	@ 0xfffffe8b
     34c:	00632e32 	rsbeq	r2, r3, r2, lsr lr
     350:	00000001 	andeq	r0, r0, r1
     354:	05001505 	streq	r1, [r0, #-1285]	@ 0xfffffafb
     358:	00048c02 	andeq	r8, r4, r2, lsl #24
     35c:	01120300 	tsteq	r2, r0, lsl #6
     360:	0a050106 	beq	140780 <__ROM_SIZE__+0x100780>
     364:	01040200 	mrseq	r0, R12_usr
     368:	0b052106 	bleq	148788 <__ROM_SIZE__+0x108788>
     36c:	01040200 	mrseq	r0, R12_usr
     370:	0a050106 	beq	140790 <__ROM_SIZE__+0x100790>
     374:	01040200 	mrseq	r0, R12_usr
     378:	0603052e 	streq	r0, [r3], -lr, lsr #10
     37c:	060c053f 			@ <UNDEFINED> instruction: 0x060c053f
     380:	06030501 	streq	r0, [r3], -r1, lsl #10
     384:	0606052f 	streq	r0, [r6], -pc, lsr #10
     388:	30010501 	andcc	r0, r1, r1, lsl #10
     38c:	1f060505 	svcne	0x00060505
     390:	01052006 	tsteq	r5, r6
     394:	0612052f 	ldreq	r0, [r2], -pc, lsr #10
     398:	b0020500 	andlt	r0, r2, r0, lsl #10
     39c:	14000004 	strne	r0, [r0], #-4
     3a0:	05130305 	ldreq	r0, [r3, #-773]	@ 0xfffffcfb
     3a4:	0501060a 	streq	r0, [r1, #-1546]	@ 0xfffff9f6
     3a8:	1e052e06 	cdpne	14, 0, cr2, cr5, cr6, {0}
     3ac:	01040200 	mrseq	r0, R12_usr
     3b0:	25053c06 	strcs	r3, [r5, #-3078]	@ 0xfffff3fa
     3b4:	01040200 	mrseq	r0, R12_usr
     3b8:	0a050106 	beq	1407d8 <__ROM_SIZE__+0x1007d8>
     3bc:	2f01053e 	svccs	0x0001053e
int car_mesg(int argc, char** argv) {
     3c0:	4c061705 	stcmi	7, cr1, [r6], {5}
     3c4:	05140305 	ldreq	r0, [r4, #-773]	@ 0xfffffcfb
    printf("Received the message:");
     3c8:	0501060c 	streq	r0, [r1, #-1548]	@ 0xfffff9f4
    for (ctr = 1; ctr < argc; ctr++) {
     3cc:	053f0603 	ldreq	r0, [pc, #-1539]!	@ fffffdd1 <_STACK_TOP_+0xdfff7dd5>
        printf(" %s", argv[ctr]);
     3d0:	0501060d 	streq	r0, [r1, #-1549]	@ 0xfffff9f3
     3d4:	052f0603 	streq	r0, [pc, #-1539]!	@ fffffdd9 <_STACK_TOP_+0xdfff7ddd>
     3d8:	0501060d 	streq	r0, [r1, #-1549]	@ 0xfffff9f3
    for (ctr = 1; ctr < argc; ctr++) {
     3dc:	05310603 	ldreq	r0, [r1, #-1539]!	@ 0xfffff9fd
    printf("\n");
     3e0:	0501060b 	streq	r0, [r1, #-1547]	@ 0xfffff9f5
     3e4:	05310603 	ldreq	r0, [r1, #-1539]!	@ 0xfffff9fd
    if (argc > 0) {
     3e8:	0501060d 	streq	r0, [r1, #-1549]	@ 0xfffff9f3
}
     3ec:	05310603 	ldreq	r0, [r1, #-1539]!	@ 0xfffff9fd
        if (strcmp(argv[1], "PING_REPLY") == 0) {
     3f0:	0501060c 	streq	r0, [r1, #-1548]	@ 0xfffff9f4
     3f4:	04023d01 	streq	r3, [r2], #-3329	@ 0xfffff2ff
            printf("Got a ping reply.\n");
     3f8:	28010100 	stmdacs	r1, {r8}
     3fc:	03000001 	movweq	r0, #1
            printf("Didn't know how to handle %s\n", argv[1]);
     400:	0000be00 	andeq	fp, r0, r0, lsl #28
     404:	fb010200 	blx	40c0e <__ROM_SIZE__+0xc0e>
     408:	01000d0e 	tsteq	r0, lr, lsl #26
     40c:	00010101 	andeq	r0, r1, r1, lsl #2
     410:	00010000 	andeq	r0, r1, r0
     414:	682f0100 	stmdavs	pc!, {r8}	@ <UNPREDICTABLE>
     418:	2f656d6f 	svccs	0x00656d6f
     41c:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
     420:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
     424:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
void uputc(char c) {
     428:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
  while ((UARTFR >> 5) & 1)
     42c:	63652f72 	cmnvs	r5, #456	@ 0x1c8
     430:	662f6674 			@ <UNDEFINED> instruction: 0x662f6674
  UART_DR = c;
     434:	702f626f 	eorvc	r6, pc, pc, ror #4
  if (c == '\n')
     438:	6674616c 	ldrbtvs	r6, [r4], -ip, ror #2
}
     43c:	006d726f 	rsbeq	r7, sp, pc, ror #4
    uputc('\r');
     440:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 38c <vector_table+0x38c>
}
     444:	63652f65 	cmnvs	r5, #404	@ 0x194
     448:	652f6674 	strvs	r6, [pc, #-1652]!	@ fffffddc <_STACK_TOP_+0xdfff7de0>
  if (!((UARTFR >> 4) & 1)) return UART_DR;
     44c:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
     450:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
     454:	2f72656e 	svccs	0x0072656e
     458:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
  return -1;
     45c:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
}
     460:	616c702f 	cmnvs	ip, pc, lsr #32
     464:	726f6674 	rsbvc	r6, pc, #116, 12	@ 0x7400000
  UARTCTL = 0;
     468:	61752f6d 	cmnvs	r5, sp, ror #30
     46c:	2f007472 	svccs	0x00007472
  UARTIBRD = 8;
     470:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
  UARTFBRD = 44;
     474:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
  UARTCC = 0;
     478:	63652f66 	cmnvs	r5, #408	@ 0x198
  UARTLCRH = 0x60;
     47c:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
  UARTCTL = 0x301;
     480:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
}
     484:	732f7265 			@ <UNDEFINED> instruction: 0x732f7265
     488:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
void u2putc(char c) {
     48c:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
  while ((UART2FR >> 5) & 1)
     490:	00006c6c 	andeq	r6, r0, ip, ror #24
     494:	74616c70 	strbtvc	r6, [r1], #-3184	@ 0xfffff390
  UART2_DR = c;
     498:	6d726f66 	ldclvs	15, cr6, [r2, #-408]!	@ 0xfffffe68
  if (c == '\n')
     49c:	0100632e 	tsteq	r0, lr, lsr #6
}
     4a0:	61750000 	cmnvs	r5, r0
    u2putc('\r');
     4a4:	2e327472 	mrccs	4, 1, r7, cr2, cr2, {3}
}
     4a8:	00020068 	andeq	r0, r2, r8, rrx
     4ac:	65687300 	strbvs	r7, [r8, #-768]!	@ 0xfffffd00
  if (!((UART2FR >> 4) & 1)) return UART2_DR;
     4b0:	682e6c6c 	stmdavs	lr!, {r2, r3, r5, r6, sl, fp, sp, lr}
     4b4:	00000300 	andeq	r0, r0, r0, lsl #6
     4b8:	74726175 	ldrbtvc	r6, [r2], #-373	@ 0xfffffe8b
     4bc:	0200682e 	andeq	r6, r0, #3014656	@ 0x2e0000
  return -1;
     4c0:	05000000 	streq	r0, [r0, #-0]
}
     4c4:	02050012 	andeq	r0, r5, #18
     4c8:	000004f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
  UART2CTL = 0;
     4cc:	05012103 	streq	r2, [r1, #-259]	@ 0xfffffefd
     4d0:	0c051503 	cfstr32eq	mvfx1, [r5], {3}
  UART2IBRD = 8;
     4d4:	03053c06 	movweq	r3, #23558	@ 0x5c06
  UART2FBRD = 44;
     4d8:	0c054c06 	stceq	12, cr4, [r5], {6}
  UART2CC = 0;
     4dc:	03052e06 	movweq	r2, #24070	@ 0x5e06
  UART2LCRH = 0x60;
     4e0:	0b054d06 	bleq	153900 <__ROM_SIZE__+0x113900>
  UART2CTL = 0x301;
     4e4:	03050106 	movweq	r0, #20742	@ 0x5106
}
     4e8:	0d055906 	vstreq.16	s10, [r5, #-12]	@ <UNPREDICTABLE>
     4ec:	03050106 	movweq	r0, #20742	@ 0x5106
  RCGCUART |= 3;
     4f0:	0c052f06 	stceq	15, cr2, [r5], {6}
     4f4:	03052e06 	movweq	r2, #24070	@ 0x5e06
     4f8:	0c054d06 	stceq	13, cr4, [r5], {6}
     4fc:	03050106 	movweq	r0, #20742	@ 0x5106
  RCGCGPIO |= 3;
     500:	0e054b06 	vmlaeq.f64	d4, d5, d6
     504:	03050106 	movweq	r0, #20742	@ 0x5106
     508:	0d052f06 	stceq	15, cr2, [r5, #-24]	@ 0xffffffe8
  GPIODEN = 0x03;
     50c:	01052e06 	tsteq	r5, r6, lsl #28
     510:	0616054b 	ldreq	r0, [r6], -fp, asr #10
  GPIOAFSEL = 0x03;
     514:	21050550 	tstcs	r5, r0, asr r5
  GPIOPCTL |= 0x00000011;
     518:	3d2f2f2f 	stccc	15, cr2, [pc, #-188]!	@ 464 <ugetc+0x18>
     51c:	01053d3d 	tsteq	r5, sp, lsr sp
     520:	09023d06 	stmdbeq	r2, {r1, r2, r8, sl, fp, ip, sp}
  GPIODEN2 = 0x03;
     524:	c6010100 	strgt	r0, [r1], -r0, lsl #2
     528:	03000000 	movweq	r0, #0
  GPIOAFSEL2 = 0x03;
     52c:	0000a200 	andeq	sl, r0, r0, lsl #4
  GPIOPCTL2 |= 0x00000011;
     530:	fb010200 	blx	40d3a <__ROM_SIZE__+0xd3a>
     534:	01000d0e 	tsteq	r0, lr, lsl #26
     538:	00010101 	andeq	r0, r1, r1, lsl #2
}
     53c:	00010000 	andeq	r0, r1, r0
     540:	682f0100 	stmdavs	pc!, {r8}	@ <UNPREDICTABLE>
void platform_init() {
     544:	2f656d6f 	svccs	0x00656d6f
    pin_setup();
     548:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    uart_init();
     54c:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
    uart2_init();
     550:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
    set_read_char(ugetc);
     554:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
    set_read_char2(u2getc);
     558:	63652f72 	cmnvs	r5, #456	@ 0x1c8
     55c:	662f6674 			@ <UNDEFINED> instruction: 0x662f6674
    set_write_char(uputc);
     560:	2f00626f 	svccs	0x0000626f
    set_write_char2(u2putc);
     564:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
     568:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
}
     56c:	63652f66 	cmnvs	r5, #408	@ 0x198
     570:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
     574:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
     578:	732f7265 			@ <UNDEFINED> instruction: 0x732f7265
int pair(int argc, char** argv) {
     57c:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
    printf("Sending a pair request.\n");
     580:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
    printf2("FOB_MESG PAIR\n");
     584:	2f006c6c 	svccs	0x00006c6c
     588:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
}
     58c:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
     590:	63652f66 	cmnvs	r5, #408	@ 0x198
     594:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
int aes(int argc, char** argv) {
     598:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
    uint8_t key[16] = {0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,
     59c:	732f7265 			@ <UNDEFINED> instruction: 0x732f7265
     5a0:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
     5a4:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
    uint8_t text[16] = "0123456789abcdef";
     5a8:	6972702f 	ldmdbvs	r2!, {r0, r1, r2, r3, r5, ip, sp, lr}^
     5ac:	0066746e 	rsbeq	r7, r6, lr, ror #8
     5b0:	69617000 	stmdbvs	r1!, {ip, sp, lr}^
    AES_init_ctx(&ctx, key);
     5b4:	00632e72 	rsbeq	r2, r3, r2, ror lr
     5b8:	73000001 	movwvc	r0, #1
    printf("Encrypting %s using AES\n", text);
     5bc:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
     5c0:	0200682e 	andeq	r6, r0, #3014656	@ 0x2e0000
    AES_ECB_encrypt(&ctx, text);
     5c4:	72700000 	rsbsvc	r0, r0, #0
     5c8:	66746e69 	ldrbtvs	r6, [r4], -r9, ror #28
    printf("Encrypted is %s\n", text);
     5cc:	0300682e 	movweq	r6, #2094	@ 0x82e
     5d0:	05000000 	streq	r0, [r0, #-0]
    len = encode_base64(text, 16, b64text);
     5d4:	02050021 	andeq	r0, r5, #33	@ 0x21
     5d8:	0000057c 	andeq	r0, r0, ip, ror r5
     5dc:	05010616 	streq	r0, [r1, #-1558]	@ 0xfffff9ea
    b64text[len] = '\n';
     5e0:	06210605 	strteq	r0, [r1], -r5, lsl #12
     5e4:	3d2f0620 	stccc	6, cr0, [pc, #-128]!	@ 56c <platform_init+0x28>
     5e8:	13060105 	movwne	r0, #24837	@ 0x6105
    printf("Encrypted is %s\n", text);
     5ec:	01000702 	tsteq	r0, r2, lsl #14
     5f0:	0001a301 	andeq	sl, r1, r1, lsl #6
    printf2("FOB_MESG AESB64 %s\n", b64text);
     5f4:	56000300 	strpl	r0, [r0], -r0, lsl #6
     5f8:	02000001 	andeq	r0, r0, #1
    AES_ECB_decrypt(&ctx, text);
     5fc:	0d0efb01 	vstreq	d15, [lr, #-4]
     600:	01010100 	mrseq	r0, (UNDEF: 17)
    printf("Which should decrypt to %s \n", text);
     604:	00000001 	andeq	r0, r0, r1
     608:	01000001 	tsteq	r0, r1
}
     60c:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 558 <platform_init+0x14>
     610:	63652f65 	cmnvs	r5, #404	@ 0x194
     614:	652f6674 	strvs	r6, [pc, #-1652]!	@ ffffffa8 <_STACK_TOP_+0xdfff7fac>
     618:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
     61c:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
     620:	2f72656e 	svccs	0x0072656e
     624:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
     628:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
int encode64(int argc, char** argv) {
     62c:	6f682f00 	svcvs	0x00682f00
    if (argc > 1) {
     630:	652f656d 	strvs	r6, [pc, #-1389]!	@ cb <vector_table+0xcb>
     634:	2f667463 	svccs	0x00667463
        len = strlen(argv[1]);
     638:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
     63c:	6172742d 	cmnvs	r2, sp, lsr #8
        if (len < MAX64LENGTH) {
     640:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
            len = encode_base64(argv[1], len, encoded);
     644:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
     648:	6c2f6c6c 	stcvs	12, cr6, [pc], #-432	@ 4a0 <u2putc+0x14>
            printf("Encoded %s as %s with %d characters\n", argv[1], encoded, len);
     64c:	742f6269 	strtvc	r6, [pc], #-617	@ 654 <encode64+0x28>
     650:	2d796e69 	ldclcs	14, cr6, [r9, #-420]!	@ 0xfffffe5c
     654:	00736561 	rsbseq	r6, r3, r1, ror #10
            printf("String exceeds max length of %d characters", MAX64LENGTH);
     658:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 5a4 <aes+0xc>
     65c:	63652f65 	cmnvs	r5, #404	@ 0x194
     660:	652f6674 	strvs	r6, [pc, #-1652]!	@ fffffff4 <_STACK_TOP_+0xdfff7ff8>
        printf("Usage is 'encode64 string'\n");
     664:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
}
     668:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
     66c:	2f72656e 	svccs	0x0072656e
     670:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
     674:	68732f6c 	ldmdavs	r3!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
     678:	006c6c65 	rsbeq	r6, ip, r5, ror #24
int decode64(int argc, char** argv) {
     67c:	74706f2f 	ldrbtvc	r6, [r0], #-3887	@ 0xfffff0d1
    if (argc > 1) {
     680:	6363672f 	cmnvs	r3, #12320768	@ 0xbc0000
     684:	6d72612d 	ldfvse	f6, [r2, #-180]!	@ 0xffffff4c
        int len = strlen(argv[1]);
     688:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
     68c:	61652d65 	cmnvs	r5, r5, ror #26
        if (len < MAX64LENGTH-1) {
     690:	6c2f6962 			@ <UNDEFINED> instruction: 0x6c2f6962
                printf("encoded string is %d characters\n", len);
     694:	672f6269 	strvs	r6, [pc, -r9, ror #4]!
     698:	612f6363 			@ <UNDEFINED> instruction: 0x612f6363
                len = decode_base64(argv[1], len, plaintext);
     69c:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
     6a0:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	@ 0xfffffe44
     6a4:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
                printf("decoded string is %d characters\n", len);
     6a8:	2e32312f 	rsfcssp	f3, f2, #10.0
     6ac:	2f312e32 	svccs	0x00312e32
                printf("Adding NULL at the end of decoded string\n");
     6b0:	6c636e69 	stclvs	14, cr6, [r3], #-420	@ 0xfffffe5c
                plaintext[len] = '\n';
     6b4:	00656475 	rsbeq	r6, r5, r5, ror r4
     6b8:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 604 <aes+0x6c>
     6bc:	63652f65 	cmnvs	r5, #404	@ 0x194
     6c0:	652f6674 	strvs	r6, [pc, #-1652]!	@ 54 <vector_table+0x54>
                printf("Decoded %s as: %s\n", argv[1], plaintext);
     6c4:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
     6c8:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
     6cc:	2f72656e 	svccs	0x0072656e
            printf("String exceeds max length of %d characters", MAX64LENGTH);
     6d0:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
     6d4:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
        printf("Usage is 'decode64 string'\n");
     6d8:	72702f62 	rsbsvc	r2, r0, #392	@ 0x188
     6dc:	66746e69 	ldrbtvs	r6, [r4], -r9, ror #28
}
     6e0:	6f682f00 	svcvs	0x00682f00
     6e4:	652f656d 	strvs	r6, [pc, #-1389]!	@ 17f <vector_table+0x17f>
     6e8:	2f667463 	svccs	0x00667463
     6ec:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
     6f0:	6172742d 	cmnvs	r2, sp, lsr #8
     6f4:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
     6f8:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
int send_ping(int argc, char** argv) {
     6fc:	6c2f6c6c 	stcvs	12, cr6, [pc], #-432	@ 554 <platform_init+0x10>
    printf("Pinging the car.\n");
     700:	622f6269 	eorvs	r6, pc, #-1879048186	@ 0x90000006
    printf2("FOB_MESG PING\n");
     704:	36657361 	strbtcc	r7, [r5], -r1, ror #6
     708:	61000034 	tstvs	r0, r4, lsr r0
}
     70c:	632e7365 			@ <UNDEFINED> instruction: 0x632e7365
     710:	00000100 	andeq	r0, r0, r0, lsl #2
     714:	2e736561 	cdpcs	5, 7, cr6, cr3, cr1, {3}
void __attribute__((optimize("O0"), weak)) initial_setup(void) {
     718:	00020068 	andeq	r0, r2, r8, rrx
     71c:	65687300 	strbvs	r7, [r8, #-768]!	@ 0xfffffd00
  char *src = &_etext, *dst = &_data;
     720:	682e6c6c 	stmdavs	lr!, {r2, r3, r5, r6, sl, fp, sp, lr}
     724:	00000300 	andeq	r0, r0, r0, lsl #6
  if (dst != src)
     728:	69647473 	stmdbvs	r4!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
     72c:	672d746e 	strvs	r7, [sp, -lr, ror #8]!
    while (dst < &_edata) *(dst++) = *(src++);
     730:	682e6363 	stmdavs	lr!, {r0, r1, r5, r6, r8, r9, sp, lr}
     734:	00000400 	andeq	r0, r0, r0, lsl #8
     738:	6e697270 	mcrvs	2, 3, r7, cr9, cr0, {3}
     73c:	682e6674 	stmdavs	lr!, {r2, r4, r5, r6, r9, sl, sp, lr}
     740:	00000500 	andeq	r0, r0, r0, lsl #10
     744:	65736162 	ldrbvs	r6, [r3, #-354]!	@ 0xfffffe9e
  for (dst = &_bss; dst < &_ebss; dst++) *dst = 0;
     748:	682e3436 	stmdavs	lr!, {r1, r2, r4, r5, sl, ip, sp}
     74c:	00000600 	andeq	r0, r0, r0, lsl #12
     750:	00200500 	eoreq	r0, r0, r0, lsl #10
     754:	05980205 	ldreq	r0, [r8, #517]	@ 0x205
     758:	06140000 	ldreq	r0, [r4], -r0
     75c:	06050501 	streq	r0, [r5], -r1, lsl #10
     760:	0d051330 	stceq	3, cr1, [r5, #-192]	@ 0xffffff40
  platform_init();
     764:	054a0106 	strbeq	r0, [sl, #-262]	@ 0xfffffefa
}
     768:	05310605 	ldreq	r0, [r1, #-1541]!	@ 0xfffff9fb
     76c:	0501060d 	streq	r0, [r1, #-1549]	@ 0xfffff9f3
     770:	4b590605 	blmi	1641f8c <__ROM_SIZE__+0x1601f8c>
     774:	5b4b4b14 	blpl	12d33cc <__ROM_SIZE__+0x12933cc>
     778:	060b0513 			@ <UNDEFINED> instruction: 0x060b0513
     77c:	06050501 	streq	r0, [r5], -r1, lsl #10
     780:	06120559 			@ <UNDEFINED> instruction: 0x06120559
static void delete(void) {
     784:	05204a01 	streq	r4, [r0, #-2561]!	@ 0xfffff5ff
  __write_char__(BACK_SPACE);
     788:	4b2f0605 	blmi	bc1fa4 <__ROM_SIZE__+0xb81fa4>
     78c:	054c4b4d 	strbeq	r4, [ip, #-2893]	@ 0xfffff4b3
  __write_char__(SPACE);
     790:	02130601 	andseq	r0, r3, #1048576	@ 0x100000
  __write_char__(BACK_SPACE);
     794:	01010010 	tsteq	r1, r0, lsl r0
     798:	00000208 	andeq	r0, r0, r8, lsl #4
}
     79c:	01560003 	cmpeq	r6, r3
static void clear_prompt(int char_count) {
     7a0:	01020000 	mrseq	r0, (UNDEF: 2)
  while (char_count) {
     7a4:	000d0efb 	strdeq	r0, [sp], -fp
    delete ();
     7a8:	01010101 	tsteq	r1, r1, lsl #2
  while (char_count) {
     7ac:	01000000 	mrseq	r0, (UNDEF: 0)
}
     7b0:	2f010000 	svccs	0x00010000
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
     7b4:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
    auto_load[i].command(0, NULL);
     7b8:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
     7bc:	63652f66 	cmnvs	r5, #408	@ 0x198
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
     7c0:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
     7c4:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
     7c8:	652f7265 	strvs	r7, [pc, #-613]!	@ 56b <platform_init+0x27>
     7cc:	2f667463 	svccs	0x00667463
     7d0:	00626f66 	rsbeq	r6, r2, r6, ror #30
}
     7d4:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 720 <initial_setup+0x8>
static int show_history(int argc, char **argv) {
     7d8:	63652f65 	cmnvs	r5, #404	@ 0x194
  uint32_t end_index = total_num_commands-1;
     7dc:	652f6674 	strvs	r6, [pc, #-1652]!	@ 170 <vector_table+0x170>
  if (total_num_commands > NUM_HISTORY_ENTRIES) {
     7e0:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
     7e4:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
    beg_index = total_num_commands - NUM_HISTORY_ENTRIES;
     7e8:	2f72656e 	svccs	0x0072656e
     7ec:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
  uint32_t beg_index = 0;
     7f0:	68732f6c 	ldmdavs	r3!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
    printf("%s\n", cmd_history[index % NUM_HISTORY_ENTRIES]);
     7f4:	006c6c65 	rsbeq	r6, ip, r5, ror #24
     7f8:	74706f2f 	ldrbtvc	r6, [r0], #-3887	@ 0xfffff0d1
     7fc:	6363672f 	cmnvs	r3, #12320768	@ 0xbc0000
     800:	6d72612d 	ldfvse	f6, [r2, #-180]!	@ 0xffffff4c
  for (uint32_t index = beg_index; index <= end_index; ++index) {
     804:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
}
     808:	61652d65 	cmnvs	r5, r5, ror #26
     80c:	6c2f6962 			@ <UNDEFINED> instruction: 0x6c2f6962
     810:	672f6269 	strvs	r6, [pc, -r9, ror #4]!
     814:	612f6363 			@ <UNDEFINED> instruction: 0x612f6363
int cmd_exec_status(int argc, char **argv) {
     818:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
  printf("%d\n", __cmd_exec_status);
     81c:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	@ 0xfffffe44
     820:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
     824:	2e32312f 	rsfcssp	f3, f2, #10.0
}
     828:	2f312e32 	svccs	0x00312e32
     82c:	6c636e69 	stclvs	14, cr6, [r3], #-420	@ 0xfffffe5c
     830:	00656475 	rsbeq	r6, r5, r5, ror r4
static int build_info(int argc, char **argv) {
     834:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 780 <initial_setup+0x68>
  printf("Build: [" SHELL_VERSION ":" USER_REPO_VERSION "] - [" BUILD_USER
     838:	63652f65 	cmnvs	r5, #404	@ 0x194
}
     83c:	652f6674 	strvs	r6, [pc, #-1652]!	@ 1d0 <vector_table+0x1d0>
     840:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
static void execute(int argc, char **argv) {
     844:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
     848:	2f72656e 	svccs	0x0072656e
  for (int i = 0; table[i].command_name != NULL; i++) {
     84c:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
     850:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
     854:	61622f62 	cmnvs	r2, r2, ror #30
     858:	34366573 	ldrtcc	r6, [r6], #-1395	@ 0xfffffa8d
     85c:	6f682f00 	svcvs	0x00682f00
    if (strcmp(argv[0], table[i].command_name) == 0) {
     860:	652f656d 	strvs	r6, [pc, #-1389]!	@ 2fb <vector_table+0x2fb>
     864:	2f667463 	svccs	0x00667463
      __cmd_exec_status = table[i].command(argc, &argv[0]);
     868:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
     86c:	6172742d 	cmnvs	r2, sp, lsr #8
     870:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
     874:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
     878:	6c2f6c6c 	stcvs	12, cr6, [pc], #-432	@ 6d0 <decode64+0x54>
    printf("\"%s\": command not found. Use \"help\" to list all command.\n",
     87c:	702f6269 	eorvc	r6, pc, r9, ror #4
     880:	746e6972 	strbtvc	r6, [lr], #-2418	@ 0xfffff68e
    __cmd_exec_status = -1;
     884:	682f0066 	stmdavs	pc!, {r1, r2, r5, r6}	@ <UNPREDICTABLE>
     888:	2f656d6f 	svccs	0x00656d6f
     88c:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
}
     890:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
     894:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
     898:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
     89c:	68732f72 	ldmdavs	r3!, {r1, r4, r5, r6, r8, r9, sl, fp, sp}^
int help(int argc, char **argv) {
     8a0:	2f6c6c65 	svccs	0x006c6c65
  if (argc > 1 && (strcmp(argv[1], "-l")==0)) {
     8a4:	2f62696c 	svccs	0x0062696c
     8a8:	69727473 	ldmdbvs	r2!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
     8ac:	0000676e 	andeq	r6, r0, lr, ror #14
     8b0:	65736162 	ldrbvs	r6, [r3, #-354]!	@ 0xfffffe9e
    printf("use: help -l for list only.\n\n");
     8b4:	632e3436 			@ <UNDEFINED> instruction: 0x632e3436
  bool verbose = true;
     8b8:	00000100 	andeq	r0, r0, r0, lsl #2
    verbose = false;
     8bc:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
    printf("\n");
     8c0:	00682e6c 	rsbeq	r2, r8, ip, ror #28
    i++;
     8c4:	73000002 	movwvc	r0, #2
  while (table[i].command_name != NULL) {
     8c8:	65646474 	strbvs	r6, [r4, #-1140]!	@ 0xfffffb8c
     8cc:	00682e66 	rsbeq	r2, r8, r6, ror #28
     8d0:	62000003 	andvs	r0, r0, #3
    printf(table[i].command_name);
     8d4:	36657361 	strbtcc	r7, [r5], -r1, ror #6
    if (verbose) {
     8d8:	00682e34 	rsbeq	r2, r8, r4, lsr lr
      printf("\n\t");
     8dc:	70000004 	andvc	r0, r0, r4
      printf(table[i].command_help);
     8e0:	746e6972 	strbtvc	r6, [lr], #-2418	@ 0xfffff68e
     8e4:	00682e66 	rsbeq	r2, r8, r6, ror #28
     8e8:	73000005 	movwvc	r0, #5
    verbose = false;
     8ec:	6e697274 	mcrvs	2, 3, r7, cr9, cr4, {3}
}
     8f0:	00682e67 	rsbeq	r2, r8, r7, ror #28
     8f4:	00000006 	andeq	r0, r0, r6
     8f8:	05002505 	streq	r2, [r0, #-1285]	@ 0xfffffafb
     8fc:	00062c02 	andeq	r2, r6, r2, lsl #24
     900:	01061500 	tsteq	r6, r0, lsl #10
     904:	32060505 	andcc	r0, r6, #20971520	@ 0x1400000
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
     908:	01060805 	tsteq	r6, r5, lsl #16
static void add_command_to_history(const char *cmd_str) {
     90c:	3e060905 	vmlacc.f16	s0, s12, s10	@ <UNPREDICTABLE>
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
     910:	0f051413 	svceq	0x00051413
     914:	2e200106 	sufcss	f0, f0, f6
  int index = total_num_commands % NUM_HISTORY_ENTRIES;
     918:	22060905 	andcs	r0, r6, #81920	@ 0x14000
     91c:	01060c05 	tsteq	r6, r5, lsl #24
     920:	2f060d05 	svccs	0x00060d05
     924:	01061305 	tsteq	r6, r5, lsl #6
  memcpy(&cmd_history[index], cmd_str, LINE_BUFF_SIZE);
     928:	0d052e2e 	stceq	14, cr2, [r5, #-184]	@ 0xffffff48
     92c:	3c062106 	stfccs	f2, [r6], {6}
     930:	0623062e 	strteq	r0, [r3], -lr, lsr #12
     934:	09053c2e 	stmdbeq	r5, {r1, r2, r3, r5, sl, fp, ip, sp}
  total_num_commands++;
     938:	20061706 	andcs	r1, r6, r6, lsl #14
  curr_command_ptr = total_num_commands;
     93c:	31060505 	tstcc	r6, r5, lsl #10
     940:	13060105 	movwne	r0, #24837	@ 0x6105
     944:	00062505 	andeq	r2, r6, r5, lsl #10
     948:	067c0205 	ldrbteq	r0, [ip], -r5, lsl #4
     94c:	06140000 	ldreq	r0, [r4], -r0
static int parse_line(char **argv, char *line_buff, int argument_size) {
     950:	06050501 	streq	r0, [r5], -r1, lsl #10
     954:	06080530 			@ <UNDEFINED> instruction: 0x06080530
  int length = strlen(line_buff);
     958:	06090501 	streq	r0, [r9], -r1, lsl #10
     95c:	0613053e 			@ <UNDEFINED> instruction: 0x0613053e
  int argc = 0;
     960:	052e2001 	streq	r2, [lr, #-1]!
         pos++)
     964:	05220609 	streq	r0, [r2, #-1545]!	@ 0xfffff9f7
    for (; line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
     968:	0501060c 	streq	r0, [r1, #-1548]	@ 0xfffff9f4
     96c:	14300611 	ldrtne	r0, [r0], #-1553	@ 0xfffff9ef
     970:	2f062e06 	svccs	0x00062e06
     974:	01061705 	tsteq	r6, r5, lsl #14
    if (line_buff[pos] == '\t' || line_buff[pos] == SPACE)
     978:	67061105 	strvs	r1, [r6, -r5, lsl #2]
     97c:	2f062e06 	svccs	0x00062e06
      line_buff[pos] = END_OF_LINE;
     980:	0620053d 			@ <UNDEFINED> instruction: 0x0620053d
  while (pos <= length) {
     984:	05204a01 	streq	r4, [r0, #-2561]!	@ 0xfffff5ff
    if (line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
     988:	05300611 	ldreq	r0, [r0, #-1553]!	@ 0xfffff9ef
     98c:	2e066a0d 	vmlacs.f32	s12, s12, s26
     990:	0609053c 			@ <UNDEFINED> instruction: 0x0609053c
     994:	05200617 	streq	r0, [r0, #-1559]!	@ 0xfffff9e9
      argv[argc++] = &line_buff[pos];
     998:	05310605 	ldreq	r0, [r1, #-1541]!	@ 0xfffff9fb
     99c:	02130601 	andseq	r0, r3, #1048576	@ 0x100000
}
     9a0:	0101000f 	tsteq	r1, pc
static int prefix_match(char *sub, int len, const char *str) {
     9a4:	000000c6 	andeq	r0, r0, r6, asr #1
     9a8:	00a20003 	adceq	r0, r2, r3
  if (sub == NULL || str == NULL || len <= 0 || len > strlen(str)) {
     9ac:	01020000 	mrseq	r0, (UNDEF: 2)
     9b0:	000d0efb 	strdeq	r0, [sp], -fp
     9b4:	01010101 	tsteq	r1, r1, lsl #2
     9b8:	01000000 	mrseq	r0, (UNDEF: 0)
  for (int i = 0; i<len; ++i) {
     9bc:	2f010000 	svccs	0x00010000
     9c0:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
    if (sub[i] != str[i]) {
     9c4:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
     9c8:	63652f66 	cmnvs	r5, #408	@ 0x198
  for (int i = 0; i<len; ++i) {
     9cc:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
}
     9d0:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
  return TRUE;
     9d4:	652f7265 	strvs	r7, [pc, #-613]!	@ 777 <initial_setup+0x5f>
      return FALSE;
     9d8:	2f667463 	svccs	0x00667463
}
     9dc:	00626f66 	rsbeq	r6, r2, r6, ror #30
static void handle_up_arrow(char *cmd_buff, int *char_count) {
     9e0:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 92c <add_command_to_history+0x24>
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
     9e4:	63652f65 	cmnvs	r5, #404	@ 0x194
     9e8:	652f6674 	strvs	r6, [pc, #-1652]!	@ 37c <vector_table+0x37c>
     9ec:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
     9f0:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
      curr_command_ptr == 0) {
     9f4:	2f72656e 	svccs	0x0072656e
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
     9f8:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
    printf("%s", cmd_buff);
     9fc:	68732f6c 	ldmdavs	r3!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
     a00:	006c6c65 	rsbeq	r6, ip, r5, ror #24
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
     a04:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 950 <parse_line>
     a08:	63652f65 	cmnvs	r5, #404	@ 0x194
  curr_command_ptr--;
     a0c:	652f6674 	strvs	r6, [pc, #-1652]!	@ 3a0 <vector_table+0x3a0>
     a10:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
     a14:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
     a18:	2f72656e 	svccs	0x0072656e
     a1c:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
     a20:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
     a24:	72702f62 	rsbsvc	r2, r0, #392	@ 0x188
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
     a28:	66746e69 	ldrbtvs	r6, [r4], -r9, ror #28
     a2c:	69700000 	ldmdbvs	r0!, {}^	@ <UNPREDICTABLE>
     a30:	632e676e 			@ <UNDEFINED> instruction: 0x632e676e
  *char_count = strlen(cmd_buff);
     a34:	00000100 	andeq	r0, r0, r0, lsl #2
     a38:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
  printf("%s", cmd_buff);
     a3c:	00682e6c 	rsbeq	r2, r8, ip, ror #28
     a40:	70000002 	andvc	r0, r0, r2
     a44:	746e6972 	strbtvc	r6, [lr], #-2418	@ 0xfffff68e
     a48:	00682e66 	rsbeq	r2, r8, r6, ror #28
     a4c:	00000003 	andeq	r0, r0, r3
static void handle_down_arrow(char *cmd_buff, int *char_count) {
     a50:	05002605 	streq	r2, [r0, #-1541]	@ 0xfffff9fb
     a54:	0006fc02 	andeq	pc, r6, r2, lsl #24
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
     a58:	01061600 	tsteq	r6, r0, lsl #12
     a5c:	21060505 	tstcs	r6, r5, lsl #10
  *char_count = 0;
     a60:	2f062006 	svccs	0x00062006
  if (curr_command_ptr == total_num_commands) return;
     a64:	0601053d 			@ <UNDEFINED> instruction: 0x0601053d
     a68:	00070213 	andeq	r0, r7, r3, lsl r2
     a6c:	09660101 	stmdbeq	r6!, {r0, r8}^
  curr_command_ptr++;
     a70:	00030000 	andeq	r0, r3, r0
     a74:	0000010f 	andeq	r0, r0, pc, lsl #2
     a78:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
     a7c:	0101000d 	tsteq	r1, sp
     a80:	00000101 	andeq	r0, r0, r1, lsl #2
     a84:	00000100 	andeq	r0, r0, r0, lsl #2
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
     a88:	6f682f01 	svcvs	0x00682f01
     a8c:	652f656d 	strvs	r6, [pc, #-1389]!	@ 527 <pin_setup+0x37>
     a90:	2f667463 	svccs	0x00667463
     a94:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
  *char_count = strlen(cmd_buff);
     a98:	6172742d 	cmnvs	r2, sp, lsr #8
     a9c:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
  printf("%s", cmd_buff);
     aa0:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
     aa4:	732f6c6c 			@ <UNDEFINED> instruction: 0x732f6c6c
}
     aa8:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
     aac:	706f2f00 	rsbvc	r2, pc, r0, lsl #30
void set_read_char(int (*func)(void)) { __read_char__ = func; }
     ab0:	63672f74 	cmnvs	r7, #116, 30	@ 0x1d0
     ab4:	72612d63 	rsbvc	r2, r1, #6336	@ 0x18c0
     ab8:	6f6e2d6d 	svcvs	0x006e2d6d
void set_read_char2(int (*func)(void)) { __read_char2__ = func; }
     abc:	652d656e 	strvs	r6, [sp, #-1390]!	@ 0xfffffa92
     ac0:	2f696261 	svccs	0x00696261
     ac4:	2f62696c 	svccs	0x0062696c
void set_write_char(void (*func)(char)) { __write_char__ = func; }
     ac8:	2f636367 	svccs	0x00636367
     acc:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	@ 0xfffffe7c
     ad0:	656e6f6e 	strbvs	r6, [lr, #-3950]!	@ 0xfffff092
void set_write_char2(void (*func)(char)) { __write_char2__ = func; }
     ad4:	6261652d 	rsbvs	r6, r1, #188743680	@ 0xb400000
     ad8:	32312f69 	eorscc	r2, r1, #420	@ 0x1a4
     adc:	312e322e 			@ <UNDEFINED> instruction: 0x312e322e
}
     ae0:	636e692f 	cmnvs	lr, #770048	@ 0xbc000
}
     ae4:	6564756c 	strbvs	r7, [r4, #-1388]!	@ 0xfffffa94
  if (cmd_buff == NULL || char_count <= 0) {
     ae8:	6f682f00 	svcvs	0x00682f00
static void handle_tab(char *cmd_buff, int *char_count) {
     aec:	652f656d 	strvs	r6, [pc, #-1389]!	@ 587 <pair+0xb>
     af0:	2f667463 	svccs	0x00667463
  int last_match = -1;
     af4:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
  int match_count = 0;
     af8:	6172742d 	cmnvs	r2, sp, lsr #8
  int i = 0;
     afc:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
    i++;
     b00:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
  while (table[i].command_name != NULL) { //loop over all commands
     b04:	6c2f6c6c 	stcvs	12, cr6, [pc], #-432	@ 95c <parse_line+0xc>
     b08:	732f6269 			@ <UNDEFINED> instruction: 0x732f6269
     b0c:	6e697274 	mcrvs	2, 3, r7, cr9, cr4, {3}
    if (prefix_match(cmd_buff, *char_count, table[i].command_name)) {
     b10:	682f0067 	stmdavs	pc!, {r0, r1, r2, r5, r6}	@ <UNPREDICTABLE>
     b14:	2f656d6f 	svccs	0x00656d6f
     b18:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
      match_count++;
     b1c:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
      printf("\n%s", table[i].command_name);
     b20:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
     b24:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
      last_match = i;
     b28:	68732f72 	ldmdavs	r3!, {r1, r4, r5, r6, r8, r9, sl, fp, sp}^
  if (match_count == 1) {
     b2c:	2f6c6c65 	svccs	0x006c6c65
     b30:	2f62696c 	svccs	0x0062696c
  if (match_count) {
     b34:	6e697270 	mcrvs	2, 3, r7, cr9, cr0, {3}
}
     b38:	00006674 	andeq	r6, r0, r4, ror r6
    memcpy(cmd_buff, table[last_match].command_name, LINE_BUFF_SIZE);
     b3c:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
     b40:	00632e6c 	rsbeq	r2, r3, ip, ror #28
     b44:	73000001 	movwvc	r0, #1
     b48:	6e696474 	mcrvs	4, 3, r6, cr9, cr4, {3}
    *char_count = strlen(cmd_buff);
     b4c:	63672d74 	cmnvs	r7, #116, 26	@ 0x1d00
     b50:	00682e63 	rsbeq	r2, r8, r3, ror #28
     b54:	73000002 	movwvc	r0, #2
    printf("\n");
     b58:	65646474 	strbvs	r6, [r4, #-1140]!	@ 0xfffffb8c
     b5c:	00682e66 	rsbeq	r2, r8, r6, ror #28
    prepend_prompt();
     b60:	73000002 	movwvc	r0, #2
    printf(PROMPT);
     b64:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
     b68:	0100682e 	tsteq	r0, lr, lsr #16
    printf("%s", cmd_buff);
     b6c:	74730000 	ldrbtvc	r0, [r3], #-0
     b70:	676e6972 			@ <UNDEFINED> instruction: 0x676e6972
     b74:	0300682e 	movweq	r6, #2094	@ 0x82e
     b78:	72700000 	rsbsvc	r0, r0, #0
     b7c:	66746e69 	ldrbtvs	r6, [r4], -r9, ror #28
     b80:	0400682e 	streq	r6, [r0], #-2094	@ 0xfffff7d2
     b84:	05000000 	streq	r0, [r0, #-0]
__attribute__((weak)) int active_prompt() { return TRUE; }
     b88:	02050040 	andeq	r0, r5, #64	@ 0x40
static void shell(void) {
     b8c:	00000718 	andeq	r0, r0, r8, lsl r7
  int count = 0;
     b90:	0102f403 	tsteq	r2, r3, lsl #8	@ <UNPREDICTABLE>
  for (int i = 0; i < LINE_BUFF_SIZE; i++) line_buff[i] = 0;
     b94:	0c030905 			@ <UNDEFINED> instruction: 0x0c030905
     b98:	2e19053c 	mrccs	5, 0, r0, cr9, cr12, {1}
     b9c:	05350605 	ldreq	r0, [r5, #-1541]!	@ 0xfffff9fb
     ba0:	2b054b0b 	blcs	1537d4 <__ROM_SIZE__+0x1137d4>
     ba4:	02040200 	andeq	r0, r4, #0, 4
  for (int i = 0; i < MAX_ARG_COUNT; i++) argv[i] = NULL;
     ba8:	00200520 	eoreq	r0, r0, r0, lsr #10
     bac:	3c020402 	cfstrscc	mvf0, [r2], {2}
     bb0:	02002605 	andeq	r2, r0, #5242880	@ 0x500000
     bb4:	053c0204 	ldreq	r0, [ip, #-516]!	@ 0xfffffdfc
     bb8:	04020024 	streq	r0, [r2], #-36	@ 0xffffffdc
  prepend_prompt();
     bbc:	10052002 	andne	r2, r5, r2
  printf(PROMPT);
     bc0:	01040200 	mrseq	r0, R12_usr
  int special_key = 0;
     bc4:	4d0c0520 	cfstr32mi	mvfx0, [ip, #-128]	@ 0xffffff80
        special_key = 1;
     bc8:	052e0305 	streq	r0, [lr, #-773]!	@ 0xfffffcfb
    if (s == -1) { s = __read_char2__();}
     bcc:	0402002f 	streq	r0, [r2], #-47	@ 0xffffffd1
     bd0:	26052003 	strcs	r2, [r5], -r3
    if (s != -1) {
     bd4:	03040200 	movweq	r0, #16896	@ 0x4200
     bd8:	0019053c 	andseq	r0, r9, ip, lsr r5
      loop();
     bdc:	3c010402 	cfstrscc	mvf0, [r1], {2}
        line_buff[count] = END_OF_LINE;
     be0:	10030305 	andne	r0, r3, r5, lsl #6
     be4:	2f01054a 	svccs	0x0001054a
     be8:	ab031a05 	blge	c7404 <__ROM_SIZE__+0x87404>
     bec:	0305e47d 	movweq	lr, #21629	@ 0x547d
        __write_char__(NEW_LINE);
     bf0:	053d4b21 	ldreq	r4, [sp, #-2849]!	@ 0xfffff4df
     bf4:	053d0601 	ldreq	r0, [sp, #-1537]!	@ 0xfffff9ff
  add_command_to_history(line_buff);
     bf8:	063e062a 	ldrteq	r0, [lr], -sl, lsr #12
  argc = parse_line(argv, line_buff, MAX_ARG_COUNT);
     bfc:	06030501 	streq	r0, [r3], -r1, lsl #10
     c00:	0609052f 	streq	r0, [r9], -pc, lsr #10
     c04:	06050501 	streq	r0, [r5], -r1, lsl #10
  if (argc > 0) execute(argc, argv);
     c08:	0f052f21 	svceq	0x00052f21
}
     c0c:	0a050106 	beq	14102c <__ROM_SIZE__+0x10102c>
        if (!__echo) {
     c10:	01051e06 	tsteq	r5, r6, lsl #28
     c14:	05203206 	streq	r3, [r0, #-518]!	@ 0xfffffdfa
        if (count == 0) continue;
     c18:	05000622 	streq	r0, [r0, #-1570]	@ 0xfffff9de
        count--;
     c1c:	0007b202 	andeq	fp, r7, r2, lsl #4
        line_buff[count] = END_OF_LINE;
     c20:	02950300 	addseq	r0, r5, #0, 6
     c24:	21030501 	tstcs	r3, r1, lsl #10
     c28:	05010805 	streq	r0, [r1, #-2053]	@ 0xfffff7fb
        delete ();
     c2c:	0501060c 	streq	r0, [r1, #-1548]	@ 0xfffff9f4
      if (__echo) {
     c30:	05052003 	streq	r2, [r5, #-3]
        __write_char__(c);
     c34:	03040200 	movweq	r0, #16896	@ 0x4200
     c38:	11052106 	tstne	r5, r6, lsl #2
    if (!active_prompt()) {
     c3c:	03040200 	movweq	r0, #16896	@ 0x4200
     c40:	05050106 	streq	r0, [r5, #-262]	@ 0xfffffefa
    s = __read_char__();
     c44:	03040200 	movweq	r0, #16896	@ 0x4200
     c48:	00370520 	eorseq	r0, r7, r0, lsr #10
    if (s == -1) { s = __read_char2__();}
     c4c:	06030402 	streq	r0, [r3], -r2, lsl #8
     c50:	002d053b 	eoreq	r0, sp, fp, lsr r5
      if (c == CARRIAGE_RETURN || c == NEW_LINE) {
     c54:	20010402 	andcs	r0, r1, r2, lsl #8
     c58:	02001c05 	andeq	r1, r0, #1280	@ 0x500
      if (c == DELETE || c == BACK_SPACE) {
     c5c:	01060104 	tsteq	r6, r4, lsl #2
     c60:	02001f05 	andeq	r1, r0, #5, 30
      } else if (c == ESCAPE) {
     c64:	05580104 	ldrbeq	r0, [r8, #-260]	@ 0xfffffefc
      } else if (c == SQUARE_BRACKET_OPEN && special_key == 1) {
     c68:	0402002d 	streq	r0, [r2], #-45	@ 0xffffffd3
      } else if ((c == 'C' || c == 'D') && special_key != 0) {
     c6c:	01052001 	tsteq	r5, r1
     c70:	30052031 	andcc	r2, r5, r1, lsr r0
     c74:	02050006 	andeq	r0, r5, #6
      } else if ((c == 'A' || c == 'B') && special_key == 2) {
     c78:	000007d8 	ldrdeq	r0, [r0], -r8
     c7c:	017e9903 	cmneq	lr, r3, lsl #18
      else if (c == TAB) {
     c80:	03050106 	movweq	r0, #20742	@ 0x5106
        line_buff[count] = c;
     c84:	2a052106 	bcs	1490a4 <__ROM_SIZE__+0x1090a4>
     c88:	03050106 	movweq	r0, #20742	@ 0x5106
     c8c:	05133d06 	ldreq	r3, [r3, #-3334]	@ 0xfffff2fa
        count++;
     c90:	0501061a 	streq	r0, [r1, #-1562]	@ 0xfffff9e6
     c94:	05052006 	streq	r2, [r5, #-6]
          delete ();
     c98:	24052f06 	strcs	r2, [r5], #-3846	@ 0xfffff0fa
          delete ();
     c9c:	053c0106 	ldreq	r0, [ip, #-262]!	@ 0xfffffefa
      } else if (c == SQUARE_BRACKET_OPEN && special_key == 1) {
     ca0:	05051e0c 	streq	r1, [r5, #-3596]	@ 0xfffff1f4
        special_key = 2;
     ca4:	03040200 	movweq	r0, #16896	@ 0x4200
      } else if ((c == 'C' || c == 'D') && special_key != 0) {
     ca8:	26053306 	strcs	r3, [r5], -r6, lsl #6
        special_key = 0;
     cac:	03040200 	movweq	r0, #16896	@ 0x4200
      } else if ((c == 'A' || c == 'B') && special_key == 2) {
     cb0:	05050106 	streq	r0, [r5, #-262]	@ 0xfffffefa
        if (!__echo) {
     cb4:	03040200 	movweq	r0, #16896	@ 0x4200
     cb8:	0038052e 	eorseq	r0, r8, lr, lsr #10
          clear_prompt(count + 4);
     cbc:	06030402 	streq	r0, [r3], -r2, lsl #8
     cc0:	002a0565 	eoreq	r0, sl, r5, ror #10
        if (c == 'A') {
     cc4:	20010402 	andcs	r0, r1, r2, lsl #8
          handle_down_arrow(line_buff, &count);
     cc8:	05320305 	ldreq	r0, [r2, #-773]!	@ 0xfffffcfb
     ccc:	2e130601 	cfmsub32cs	mvax0, mvfx0, mvfx3, mvfx1
        continue;
     cd0:	00062c05 	andeq	r2, r6, r5, lsl #24
          clear_prompt(count);
     cd4:	08180205 	ldmdaeq	r8, {r0, r2, r9}
     cd8:	cf030000 	svcgt	0x00030000
          handle_up_arrow(line_buff, &count);
     cdc:	01060102 	tsteq	r6, r2, lsl #2
     ce0:	21060305 	tstcs	r6, r5, lsl #6
        handle_tab(line_buff, &count);
     ce4:	06203c06 	strteq	r3, [r0], -r6, lsl #24
     ce8:	0601052f 	streq	r0, [r1], -pc, lsr #10
        continue;
     cec:	062e0513 			@ <UNDEFINED> instruction: 0x062e0513
  if (argc > 0) execute(argc, argv);
     cf0:	34020500 	strcc	r0, [r2], #-1280	@ 0xfffffb00
}
     cf4:	03000008 	movweq	r0, #8
     cf8:	06017f8c 	streq	r7, [r1], -ip, lsl #31
     cfc:	06030501 	streq	r0, [r3], -r1, lsl #10
     d00:	06200621 	strteq	r0, [r0], -r1, lsr #12
void prompt() {
     d04:	06010530 			@ <UNDEFINED> instruction: 0x06010530
  initial_setup();
     d08:	062c0513 			@ <UNDEFINED> instruction: 0x062c0513
  exec_auto_cmds();
     d0c:	44020500 	strmi	r0, [r2], #-1280	@ 0xfffffb00
  setup();
     d10:	03000008 	movweq	r0, #8
    shell();
     d14:	06017ef1 			@ <UNDEFINED> instruction: 0x06017ef1
int exec(char *cmd_str) {
     d18:	06030501 	streq	r0, [r3], -r1, lsl #10
     d1c:	0805144b 	stmdaeq	r5, {r0, r1, r3, r6, sl, ip}
  argc = parse_line(argv, cmd_str, MAX_ARG_COUNT);
     d20:	060c0501 	streq	r0, [ip], -r1, lsl #10
     d24:	20030501 	andcs	r0, r3, r1, lsl #10
  if (argc > 0) execute(argc, argv);
     d28:	02003305 	andeq	r3, r0, #335544320	@ 0x14000000
  return __cmd_exec_status;
     d2c:	20060204 	andcs	r0, r6, r4, lsl #4
}
     d30:	02002905 	andeq	r2, r0, #81920	@ 0x14000
     d34:	05200104 	streq	r0, [r0, #-260]!	@ 0xfffffefc
  if (argc > 0) execute(argc, argv);
     d38:	04020018 	streq	r0, [r2], #-24	@ 0xffffffe8
     d3c:	05010601 	streq	r0, [r1, #-1537]	@ 0xfffff9ff
     d40:	0402001b 	streq	r0, [r2], #-27	@ 0xffffffe5
cmd get_function_addr(char *cmd_str) {
     d44:	29054a01 	stmdbcs	r5, {r0, r9, fp, lr}
  for (int i = 0; table[i].command_name != NULL; i++) {
     d48:	01040200 	mrseq	r0, R12_usr
     d4c:	06050520 	streq	r0, [r5], -r0, lsr #10
     d50:	06090521 	streq	r0, [r9], -r1, lsr #10
     d54:	3c080501 	cfstr32cc	mvfx0, [r8], {1}
     d58:	2f060705 	svccs	0x00060705
    if (strcmp(cmd_str, table[i].command_name) == 0) {
     d5c:	01062005 	tsteq	r6, r5
     d60:	052e2305 	streq	r2, [lr, #-773]!	@ 0xfffffcfb
      return table[i].command;
     d64:	1905201b 	stmdbne	r5, {r0, r1, r3, r4, sp}
     d68:	0607053c 			@ <UNDEFINED> instruction: 0x0607053c
  return NULL;
     d6c:	0106133d 	tsteq	r6, sp, lsr r3
}
     d70:	16060305 	strne	r0, [r6], -r5, lsl #6
  if(v < 26) return v + 'A';
     d74:	13050520 	movwne	r0, #21792	@ 0x5520
  if(v < 52) return v + 71;
     d78:	0617054c 	ldreq	r0, [r7], -ip, asr #10
  if(v < 62) return v - 4;
     d7c:	5a010501 	bpl	42188 <__ROM_SIZE__+0x2188>
  if(v == 62) return '+';
     d80:	0621052e 	strteq	r0, [r1], -lr, lsr #10
  if(v == 63) return '/';
     d84:	a0020500 	andge	r0, r2, r0, lsl #10
  return 64;
     d88:	03000008 	movweq	r0, #8
  if(v < 26) return v + 'A';
     d8c:	060101d2 			@ <UNDEFINED> instruction: 0x060101d2
     d90:	06030501 	streq	r0, [r3], -r1, lsl #10
  if(v < 52) return v + 71;
     d94:	05141421 	ldreq	r1, [r4, #-1057]	@ 0xfffffbdf
  if(v < 62) return v - 4;
     d98:	05010606 	streq	r0, [r1, #-1542]	@ 0xfffff9fa
     d9c:	04020014 	streq	r0, [r2], #-20	@ 0xffffffec
  if(v == 62) return '+';
     da0:	02003c01 	andeq	r3, r0, #256	@ 0x100
}
     da4:	00200104 	eoreq	r0, r0, r4, lsl #2
  if('A' <= c && c <= 'Z') return c - 'A';
     da8:	20010402 	andcs	r0, r1, r2, lsl #8
     dac:	02001005 	andeq	r1, r0, #5
  if('a' <= c && c <= 'z') return c - 71;
     db0:	052e0104 	streq	r0, [lr, #-260]!	@ 0xfffffefc
     db4:	05230605 	streq	r0, [r3, #-1541]!	@ 0xfffff9fb
     db8:	05370608 	ldreq	r0, [r7, #-1544]!	@ 0xfffff9f8
  if('0' <= c && c <= '9') return c + 4;
     dbc:	0505230d 	streq	r2, [r5, #-781]	@ 0xfffffcf3
     dc0:	2e0d0306 	cdpcs	3, 0, cr0, cr13, cr6, {0}
  if(c == '+') return 62;
     dc4:	0606053d 			@ <UNDEFINED> instruction: 0x0606053d
  if(c == '/') return 63;
     dc8:	06200501 	strteq	r0, [r0], -r1, lsl #10
  return 255;
     dcc:	05207703 	streq	r7, [r0, #-1795]!	@ 0xfffff8fd
  if('a' <= c && c <= 'z') return c - 71;
     dd0:	0501060f 	streq	r0, [r1, #-1551]	@ 0xfffff9f1
     dd4:	20054a12 	andcs	r4, r5, r2, lsl sl
  if('0' <= c && c <= '9') return c + 4;
     dd8:	06050520 	streq	r0, [r5], -r0, lsr #10
  if(c == '+') return 62;
     ddc:	08053021 	stmdaeq	r5, {r0, r5, ip, sp}
  if(c == '/') return 63;
     de0:	07050106 	streq	r0, [r5, -r6, lsl #2]
  return (input_length + 2)/3*4;
     de4:	053d2f06 	ldreq	r2, [sp, #-3846]!	@ 0xfffff0fa
     de8:	05010613 	streq	r0, [r1, #-1555]	@ 0xfffff9ed
     dec:	0d052e07 	stceq	14, cr2, [r5, #-28]	@ 0xffffffe4
}
     df0:	054a7603 	strbeq	r7, [sl, #-1539]	@ 0xfffff9fd
     df4:	11030603 	tstne	r3, r3, lsl #12
unsigned int decode_base64_length(unsigned char input[], unsigned int input_length) {
     df8:	0601052e 	streq	r0, [r1], -lr, lsr #10
     dfc:	39052013 	stmdbcc	r5, {r0, r1, r4, sp}
  while(base64_to_binary(input[0]) < 64 && (unsigned int) (input - start) < input_length) {
     e00:	02050006 	andeq	r0, r5, #6
     e04:	00000908 	andeq	r0, r0, r8, lsl #18
     e08:	017d9c03 	cmneq	sp, r3, lsl #24
     e0c:	05150305 	ldreq	r0, [r5, #-773]	@ 0xfffffcfb
     e10:	05010606 	streq	r0, [r1, #-1542]	@ 0xfffff9fa
  input_length = input - start;
     e14:	04020039 	streq	r0, [r2], #-57	@ 0xffffffc7
  return input_length/4*3 + (input_length % 4 ? input_length % 4 - 1 : 0);
     e18:	1a051d01 	bne	148224 <__ROM_SIZE__+0x108224>
     e1c:	01040200 	mrseq	r0, R12_usr
     e20:	00170531 	andseq	r0, r7, r1, lsr r5
}
     e24:	3c010402 	cfstrscc	mvf0, [r1], {2}
  return input_length/4*3 + (input_length % 4 ? input_length % 4 - 1 : 0);
     e28:	05270105 	streq	r0, [r7, #-261]!	@ 0xfffffefb
unsigned int encode_base64(unsigned char input[], unsigned int input_length, unsigned char output[]) {
     e2c:	051c0603 	ldreq	r0, [ip, #-1539]	@ 0xfffff9fd
     e30:	05010622 	streq	r0, [r1, #-1570]	@ 0xfffff9de
     e34:	03052e07 	movweq	r2, #24071	@ 0x5e07
  unsigned int full_sets = input_length/3;
     e38:	0a055906 	beq	157258 <__ROM_SIZE__+0x117258>
     e3c:	03050106 	movweq	r0, #20742	@ 0x5106
  for(unsigned int i = 0; i < full_sets; ++i) {
     e40:	2f064a2e 	svccs	0x00064a2e
    output[0] = binary_to_base64(                         input[0] >> 2);
     e44:	01061505 	tsteq	r6, r5, lsl #10
     e48:	3d060305 	stccc	3, cr0, [r6, #-20]	@ 0xffffffec
    output[1] = binary_to_base64((input[0] & 0x03) << 4 | input[1] >> 4);
     e4c:	01061405 	tsteq	r6, r5, lsl #8
     e50:	0648054a 	strbeq	r0, [r8], -sl, asr #10
     e54:	6600c903 	strvs	ip, [r0], -r3, lsl #18
     e58:	03050106 	movweq	r0, #20742	@ 0x5106
     e5c:	13133d06 	tstne	r3, #384	@ 0x180
    output[2] = binary_to_base64((input[1] & 0x0F) << 2 | input[2] >> 6);
     e60:	01061005 	tsteq	r6, r5
     e64:	03052e20 	movweq	r2, #24096	@ 0x5e20
     e68:	07052206 	streq	r2, [r5, -r6, lsl #4]
     e6c:	051f0f06 	ldreq	r0, [pc, #-3846]	@ ffffff6e <_STACK_TOP_+0xdfff7f72>
     e70:	0d052409 	cfstrseq	mvf2, [r5, #-36]	@ 0xffffffdc
    output[3] = binary_to_base64( input[2] & 0x3F);
     e74:	3e052706 	cdpcc	7, 0, cr2, cr5, cr6, {0}
     e78:	0615051e 			@ <UNDEFINED> instruction: 0x0615051e
     e7c:	2e3e0501 	cdpcs	5, 3, cr0, cr14, cr1, {0}
    input += 3;
     e80:	02002305 	andeq	r2, r0, #335544320	@ 0x14000000
  for(unsigned int i = 0; i < full_sets; ++i) {
     e84:	052e0104 	streq	r0, [lr, #-260]!	@ 0xfffffefc
     e88:	0402003e 	streq	r0, [r2], #-62	@ 0xffffffc2
  switch(input_length % 3) {
     e8c:	05052e02 	streq	r2, [r5, #-3586]	@ 0xfffff1fe
     e90:	08053306 	stmdaeq	r5, {r1, r2, r8, r9, ip, sp}
     e94:	20050106 	andcs	r0, r5, r6, lsl #2
     e98:	01040200 	mrseq	r0, R12_usr
     e9c:	0607052e 	streq	r0, [r7], -lr, lsr #10
     ea0:	0616052f 	ldreq	r0, [r6], -pc, lsr #10
     ea4:	06050501 	streq	r0, [r5], -r1, lsl #10
  return encode_base64_length(input_length);
     ea8:	06080530 			@ <UNDEFINED> instruction: 0x06080530
}
     eac:	060e0501 	streq	r0, [lr], -r1, lsl #10
      output[0] = '\0';
     eb0:	05207303 	streq	r7, [r0, #-771]!	@ 0xfffffcfd
      output[0] = binary_to_base64(                         input[0] >> 2);
     eb4:	12052f05 	andne	r2, r5, #5, 30
     eb8:	08050106 	stmdaeq	r5, {r1, r2, r8}
     ebc:	0020052e 	eoreq	r0, r0, lr, lsr #10
      output[1] = binary_to_base64((input[0] & 0x03) << 4);
     ec0:	2e010402 	cdpcs	4, 0, cr0, cr1, cr2, {0}
     ec4:	02003b05 	andeq	r3, r0, #5120	@ 0x1400
     ec8:	052e0204 	streq	r0, [lr, #-516]!	@ 0xfffffdfc
      output[2] = '=';
     ecc:	05300607 	ldreq	r0, [r0, #-1543]!	@ 0xfffff9f9
      output[3] = '=';
     ed0:	05010614 	streq	r0, [r1, #-1556]	@ 0xfffff9ec
      output[4] = '\0';
     ed4:	05202e10 	streq	r2, [r0, #-3600]!	@ 0xfffff1f0
      output[0] = binary_to_base64(                         input[0] >> 2);
     ed8:	0d030603 	stceq	6, cr0, [r3, #-12]
     edc:	06010520 	streq	r0, [r1], -r0, lsr #10
     ee0:	3e052013 	mcrcc	0, 0, r2, cr5, cr3, {0}
      output[1] = binary_to_base64((input[0] & 0x03) << 4 | input[1] >> 4);
     ee4:	02050006 	andeq	r0, r5, #6
     ee8:	000009a2 	andeq	r0, r0, r2, lsr #19
     eec:	017fb803 	cmneq	pc, r3, lsl #16
     ef0:	05130305 	ldreq	r0, [r3, #-773]	@ 0xfffffcfb
     ef4:	05010606 	streq	r0, [r1, #-1542]	@ 0xfffff9fa
      output[2] = binary_to_base64((input[1] & 0x0F) << 2);
     ef8:	0402003e 	streq	r0, [r2], #-62	@ 0xffffffc2
     efc:	13051f01 	movwne	r1, #24321	@ 0x5f01
     f00:	01040200 	mrseq	r0, R12_usr
      output[3] = '=';
     f04:	0022054b 	eoreq	r0, r2, fp, asr #10
      output[4] = '\0';
     f08:	20020402 	andcs	r0, r2, r2, lsl #8
      break;
     f0c:	02003705 	andeq	r3, r0, #1310720	@ 0x140000
     f10:	002e0304 	eoreq	r0, lr, r4, lsl #6
unsigned int decode_base64(unsigned char input[], unsigned int input_length, unsigned char output[]) {
     f14:	20030402 	andcs	r0, r3, r2, lsl #8
     f18:	02002e05 	andeq	r2, r0, #5, 28	@ 0x50
  unsigned int output_length = decode_base64_length(input, input_length);
     f1c:	052e0304 	streq	r0, [lr, #-772]!	@ 0xfffffcfc
     f20:	1405320c 	strne	r3, [r5], #-524	@ 0xfffffdf4
  for(unsigned int i = 2; i < output_length; i += 3) {
     f24:	01040200 	mrseq	r0, R12_usr
    output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
     f28:	05052006 	streq	r2, [r5, #-6]
     f2c:	060c052f 	streq	r0, [ip], -pc, lsr #10
     f30:	20100501 	andscs	r0, r0, r1, lsl #10
     f34:	05200805 	streq	r0, [r0, #-2053]!	@ 0xfffff7fb
     f38:	0402001a 	streq	r0, [r2], #-26	@ 0xffffffe6
    output[1] = base64_to_binary(input[1]) << 4 | base64_to_binary(input[2]) >> 2;
     f3c:	002d0602 	eoreq	r0, sp, r2, lsl #12
     f40:	06020402 	streq	r0, [r2], -r2, lsl #8
     f44:	04020020 	streq	r0, [r2], #-32	@ 0xffffffe0
     f48:	05052002 	streq	r2, [r5, #-2]
     f4c:	0c050f06 	stceq	15, cr0, [r5], {6}
    output[2] = base64_to_binary(input[2]) << 6 | base64_to_binary(input[3]);
     f50:	01050106 	tsteq	r5, r6, lsl #2
     f54:	05200a03 	streq	r0, [r0, #-2563]!	@ 0xfffff5fd
     f58:	0e051f0a 	cdpeq	15, 0, cr1, cr5, cr10, {0}
     f5c:	05052e2a 	streq	r2, [r5, #-3626]	@ 0xfffff1d6
    input += 4;
     f60:	0c050d06 	stceq	13, cr0, [r5], {6}
  for(unsigned int i = 2; i < output_length; i += 3) {
     f64:	01050106 	tsteq	r5, r6, lsl #2
     f68:	05200a03 	streq	r0, [r0, #-2563]!	@ 0xfffff5fd
  switch(output_length % 3) {
     f6c:	b603063e 			@ <UNDEFINED> instruction: 0xb603063e
     f70:	0106207f 	tsteq	r6, pc, ror r0
     f74:	2f060305 	svccs	0x00060305
     f78:	01062d05 	tsteq	r6, r5, lsl #26
     f7c:	053c1805 	ldreq	r1, [ip, #-2053]!	@ 0xfffff7fb
     f80:	18052e06 	stmdane	r5, {r1, r2, r9, sl, fp, sp}
     f84:	01040200 	mrseq	r0, R12_usr
     f88:	0043053d 	subeq	r0, r3, sp, lsr r5
      output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
     f8c:	3b010402 	blcc	41f9c <__ROM_SIZE__+0x1f9c>
     f90:	22060505 	andcs	r0, r6, #20971520	@ 0x1400000
     f94:	06202006 	strteq	r2, [r0], -r6
     f98:	0601052f 	streq	r0, [r1], -pc, lsr #10
     f9c:	05010b03 	streq	r0, [r1, #-2819]	@ 0xfffff4fd
      output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
     fa0:	78030603 	stmdavc	r3, {r0, r1, r9, sl}
     fa4:	062e0620 	strteq	r0, [lr], -r0, lsr #12
     fa8:	06130530 			@ <UNDEFINED> instruction: 0x06130530
     fac:	06030501 	streq	r0, [r3], -r1, lsl #10
     fb0:	06210567 	strteq	r0, [r1], -r7, ror #10
      output[1] = base64_to_binary(input[1]) << 4 | base64_to_binary(input[2]) >> 2;
     fb4:	2e070501 	cfsh32cs	mvfx0, mvfx7, #1
     fb8:	59060305 	stmdbpl	r6, {r0, r2, r8, r9}
     fbc:	01061405 	tsteq	r6, r5, lsl #8
     fc0:	3c200305 	stccc	3, cr0, [r0], #-20	@ 0xffffffec
     fc4:	11053d06 	tstne	r5, r6, lsl #26
  return output_length;
     fc8:	0f050106 	svceq	0x00050106
     fcc:	0603053c 			@ <UNDEFINED> instruction: 0x0603053c
static void outstr(const char *str) {
     fd0:	a1400522 	cmpge	r0, r2, lsr #10
  while (*str != '\0') {
     fd4:	03050106 	movweq	r0, #20742	@ 0x5106
    __write_char__(*str);
     fd8:	2e063d06 	cdpcs	13, 0, cr3, cr6, cr6, {0}
    str++;
     fdc:	0f052f06 	svceq	0x00052f06
  while (*str != '\0') {
     fe0:	03050106 	movweq	r0, #20742	@ 0x5106
}
     fe4:	18052f06 	stmdane	r5, {r1, r2, r8, r9, sl, fp, sp}
     fe8:	06050106 	streq	r0, [r5], -r6, lsl #2
static bool printf_numbers(const char fmt, va_list *args, int l_count) {
     fec:	0603054a 	streq	r0, [r3], -sl, asr #10
     ff0:	06130530 			@ <UNDEFINED> instruction: 0x06130530
  switch (fmt) {
     ff4:	06030501 	streq	r0, [r3], -r1, lsl #10
     ff8:	06210567 	strteq	r0, [r1], -r7, ror #10
     ffc:	2e070501 	cfsh32cs	mvfx0, mvfx7, #1
      if (l_count == 0) {
    1000:	59060305 	stmdbpl	r6, {r0, r2, r8, r9}
    1004:	01061405 	tsteq	r6, r5, lsl #8
        value = va_arg(*args, unsigned int);
    1008:	06200305 	strteq	r0, [r0], -r5, lsl #6
    100c:	06110567 	ldreq	r0, [r1], -r7, ror #10
      if (fmt == 'u') {
    1010:	3c0f0501 	cfstr32cc	mvfx0, [pc], {1}
        if (value == 0) {
    1014:	22060305 	andcs	r0, r6, #335544320	@ 0x14000000
          __write_char__(hextable[0]);
    1018:	4b060105 	blmi	181434 <__ROM_SIZE__+0x141434>
    101c:	06270520 	strteq	r0, [r7], -r0, lsr #10
  return true;
    1020:	b0020500 	andlt	r0, r2, r0, lsl #10
  switch (fmt) {
    1024:	0300000a 	movweq	r0, #10
      outstr("\nprintf-error\n");
    1028:	05017fba 	streq	r7, [r1, #-4026]	@ 0xfffff046
      return false;
    102c:	37050129 	strcc	r0, [r5, -r9, lsr #2]
}
    1030:	3f050106 	svccc	0x00050106
      if (l_count == 0) {
    1034:	0628053c 			@ <UNDEFINED> instruction: 0x0628053c
        value = va_arg(*args, int);
    1038:	012a053d 			@ <UNDEFINED> instruction: 0x012a053d
    103c:	01063905 	tsteq	r6, r5, lsl #18
      if (value < 0) {
    1040:	053c4105 	ldreq	r4, [ip, #-261]!	@ 0xfffffefb
        num[num_len++] = hextable[value % 10];
    1044:	053e0629 	ldreq	r0, [lr, #-1577]!	@ 0xfffff9d7
    1048:	3a05012b 	bcc	1414fc <__ROM_SIZE__+0x1014fc>
    104c:	42050106 	andmi	r0, r5, #-2147483647	@ 0x80000001
    1050:	062a052e 	strteq	r0, [sl], -lr, lsr #10
    1054:	012c054b 			@ <UNDEFINED> instruction: 0x012c054b
    1058:	01063c05 	tsteq	r6, r5, lsl #24
    105c:	053c4405 	ldreq	r4, [ip, #-1029]!	@ 0xfffffbfb
    1060:	053e0628 	ldreq	r0, [lr, #-1576]!	@ 0xfffff9d8
    1064:	27051401 	strcs	r1, [r5, -r1, lsl #8]
        value = value / 10;
    1068:	14010522 	strne	r0, [r1], #-1314	@ 0xfffffade
      } while (value > 0);
    106c:	05232d05 	streq	r2, [r3, #-3333]!	@ 0xfffff2fb
    1070:	01051303 	tsteq	r5, r3, lsl #6
        __write_char__('-');
    1074:	39051306 	stmdbcc	r5, {r1, r2, r8, r9, ip}
    1078:	00e40306 	rsceq	r0, r4, r6, lsl #6
        value = -value;
    107c:	13030520 	movwne	r0, #13600	@ 0x3520
        __write_char__(num[--num_len]);
    1080:	01060605 	tsteq	r6, r5, lsl #12
    1084:	02003905 	andeq	r3, r0, #81920	@ 0x14000
    1088:	052d0104 	streq	r0, [sp, #-260]!	@ 0xfffffefc
    108c:	04020018 	streq	r0, [r2], #-24	@ 0xffffffe8
    1090:	07054b01 	streq	r4, [r5, -r1, lsl #22]
      while (num_len > 0) {
    1094:	052d2d26 	streq	r2, [sp, #-3366]!	@ 0xfffff2da
  return true;
    1098:	0c030605 	stceq	6, cr0, [r3], {5}
          num[num_len++] = hextable[value % 10];
    109c:	0606052e 	streq	r0, [r6], -lr, lsr #10
    10a0:	06200501 	strteq	r0, [r0], -r1, lsl #10
    10a4:	05207703 	streq	r7, [r0, #-1795]!	@ 0xfffff8fd
    10a8:	0501060f 	streq	r0, [r1, #-1551]	@ 0xfffff9f1
    10ac:	20054a12 	andcs	r4, r5, r2, lsl sl
    10b0:	06050520 	streq	r0, [r5], -r0, lsr #10
    10b4:	06090523 	streq	r0, [r9], -r3, lsr #10
    10b8:	4a080501 	bmi	2024c4 <__ROM_SIZE__+0x1c24c4>
          value = value / 10;
    10bc:	2f060705 	svccs	0x00060705
        } while (value > 0);
    10c0:	01061205 	tsteq	r6, r5, lsl #4
        while (num_len > 0) {
    10c4:	2f060705 	svccs	0x00060705
          __write_char__(num[--num_len]);
    10c8:	06120513 			@ <UNDEFINED> instruction: 0x06120513
    10cc:	06030557 			@ <UNDEFINED> instruction: 0x06030557
    10d0:	06060536 			@ <UNDEFINED> instruction: 0x06060536
    10d4:	06030501 	streq	r0, [r3], -r1, lsl #10
    10d8:	06060542 	streq	r0, [r6], -r2, asr #10
    10dc:	42010501 	andmi	r0, r1, #4194304	@ 0x400000
  return true;
    10e0:	03060505 	movweq	r0, #25861	@ 0x6505
              __write_char__(hextable[val]);
    10e4:	1b052e75 	blne	14cac0 <__ROM_SIZE__+0x10cac0>
    10e8:	05050106 	streq	r0, [r5, #-262]	@ 0xfffffefa
              leading_zero_ignored = true;
    10ec:	0567062e 	strbeq	r0, [r7, #-1582]!	@ 0xfffff9d2
          while (start_bit >= 0) {
    10f0:	05010613 	streq	r0, [r1, #-1555]	@ 0xfffff9ed
            int val = (value >> start_bit) & 0xF;
    10f4:	05053c11 	streq	r3, [r5, #-3089]	@ 0xfffff3ef
            if (val || leading_zero_ignored) {
    10f8:	2f593306 	svccs	0x00593306
    10fc:	0566064b 	strbeq	r0, [r6, #-1611]!	@ 0xfffff9b5
    1100:	8103062b 	tsthi	r3, fp, lsr #12
          bool leading_zero_ignored = false;
    1104:	2d05827f 	sfmcs	f0, 1, [r5, #-508]	@ 0xfffffe04
          int start_bit = LAST_NIBBLE_FIRST_BIT;
    1108:	063a0501 	ldrteq	r0, [sl], -r1, lsl #10
  return true;
    110c:	06190501 	ldreq	r0, [r9], -r1, lsl #10
        return false;
    1110:	8c020500 	cfstr32hi	mvfx0, [r2], {-0}
        return false;
    1114:	0300000b 	movweq	r0, #11
    1118:	050101af 	streq	r0, [r1, #-431]	@ 0xfffffe51
    111c:	05132f03 	ldreq	r2, [r3, #-3843]	@ 0xfffff0fd
    1120:	05010607 	streq	r0, [r1, #-1543]	@ 0xfffff9f9
    1124:	132f0603 			@ <UNDEFINED> instruction: 0x132f0603
    1128:	05141314 	ldreq	r1, [r4, #-788]	@ 0xfffffcec
int printf(const char *fmt, ...) {
    112c:	03050108 	movweq	r0, #20744	@ 0x5108
    1130:	2c050106 	stfcss	f0, [r5], {6}
    1134:	03040200 	movweq	r0, #16896	@ 0x4200
  va_start(args, fmt);
    1138:	39052006 	stmdbcc	r5, {r1, r2, sp}
  while (*fmt) {
    113c:	03040200 	movweq	r0, #16896	@ 0x4200
        if (*fmt == '%') {
    1140:	28050106 	stmdacs	r5, {r1, r2, r8}
        __write_char__(*fmt);
    1144:	03040200 	movweq	r0, #16896	@ 0x4200
        fmt++;
    1148:	15056606 	strne	r6, [r5, #-1542]	@ 0xfffff9fa
  while (*fmt) {
    114c:	01040200 	mrseq	r0, R12_usr
    switch (state) {
    1150:	060c0520 	streq	r0, [ip], -r0, lsr #10
    1154:	2b052030 	blcs	14921c <__ROM_SIZE__+0x10921c>
          fmt++;
    1158:	03040200 	movweq	r0, #16896	@ 0x4200
          continue;
    115c:	33052006 	movwcc	r2, #20486	@ 0x5006
        while (*fmt && ((*fmt >= '0' && *fmt <= '9') || *fmt == '-')) {
    1160:	03040200 	movweq	r0, #16896	@ 0x4200
    1164:	27050106 	strcs	r0, [r5, -r6, lsl #2]
    1168:	03040200 	movweq	r0, #16896	@ 0x4200
    116c:	15054a06 	strne	r4, [r5, #-2566]	@ 0xfffff5fa
    1170:	01040200 	mrseq	r0, R12_usr
        switch (*fmt) {
    1174:	30030520 	andcc	r0, r3, r0, lsr #10
    1178:	0607052f 	streq	r0, [r7], -pc, lsr #10
    117c:	053c7503 	ldreq	r7, [ip, #-1283]!	@ 0xfffffafd
    1180:	2e300315 	mrccs	3, 1, r0, cr0, cr5, {0}
            __write_char__(*fmt);
    1184:	00140520 	andseq	r0, r4, r0, lsr #10
    1188:	06010402 	streq	r0, [r1], -r2, lsl #8
            state = CHECK_CH;
    118c:	05206603 	streq	r6, [r0, #-1539]!	@ 0xfffff9fd
            break;
    1190:	04020018 	streq	r0, [r2], #-24	@ 0xffffffe8
    1194:	05010601 	streq	r0, [r1, #-1537]	@ 0xfffff9ff
            outstr(va_arg(args, const char *));
    1198:	04020005 	streq	r0, [r2], #-5
    119c:	054d0601 	strbeq	r0, [sp, #-1537]	@ 0xfffff9ff
    11a0:	04020008 	streq	r0, [r2], #-8
            fmt++;
    11a4:	05010601 	streq	r0, [r1, #-1537]	@ 0xfffff9ff
            break;
    11a8:	c3030607 	movwgt	r0, #13831	@ 0x3607
            __write_char__(va_arg(args, int));
    11ac:	2e063c00 	cdpcs	12, 0, cr3, cr6, cr0, {0}
    11b0:	03060905 	movweq	r0, #26885	@ 0x6905
    11b4:	12052041 	andne	r2, r5, #65	@ 0x41
            fmt++;
    11b8:	1a050106 	bne	1415d8 <__ROM_SIZE__+0x1015d8>
            break;
    11bc:	06090520 	streq	r0, [r9], -r0, lsr #10
            if (*fmt == 'l') {
    11c0:	03054b67 	movweq	r4, #23399	@ 0x5b67
    11c4:	0100c703 	tsteq	r0, r3, lsl #14
            if (printf_numbers(*fmt, &args, l_count)) {
    11c8:	060a0540 	streq	r0, [sl], -r0, asr #10
    11cc:	06030501 	streq	r0, [r3], -r1, lsl #10
    11d0:	0606055b 			@ <UNDEFINED> instruction: 0x0606055b
              state = CHECK_CH;
    11d4:	01052001 	tsteq	r5, r1
              fmt++;
    11d8:	06090521 	streq	r0, [r9], -r1, lsr #10
              l_count++;
    11dc:	2e7fb503 	cdpcs	5, 7, cr11, cr15, cr3, {0}
            if (printf_numbers(*fmt, &args, 0)) {
    11e0:	01060d05 	tsteq	r6, r5, lsl #26
    11e4:	052e0c05 	streq	r0, [lr, #-3077]!	@ 0xfffff3fb
              fmt++;
    11e8:	05340609 	ldreq	r0, [r4, #-1545]!	@ 0xfffff9f7
              break;
    11ec:	05010613 	streq	r0, [r1, #-1555]	@ 0xfffff9ed
            return -1;
    11f0:	0905200c 	stmdbeq	r5, {r2, r3, sp}
}
    11f4:	0e052206 	cdpeq	2, 0, cr2, cr5, cr6, {0}
    11f8:	09050106 	stmdbeq	r5, {r1, r2, r8}
            return -1;
    11fc:	1a053006 	bne	14d21c <__ROM_SIZE__+0x10d21c>
    1200:	09050106 	stmdbeq	r5, {r1, r2, r8}
    1204:	07056706 	streq	r6, [r5, -r6, lsl #14]
static void outstr2(const char *str) {
    1208:	052e2a03 	streq	r2, [lr, #-2563]!	@ 0xfffff5fd
  while (*str != '\0') {
    120c:	0501060b 	streq	r0, [r1, #-1547]	@ 0xfffff9f5
    __write_char2__(*str);
    1210:	09052e0a 	stmdbeq	r5, {r1, r3, r9, sl, fp, sp}
    str++;
    1214:	03052106 	movweq	r2, #20742	@ 0x5106
  while (*str != '\0') {
    1218:	4a7fb403 	bmi	1fee22c <__ROM_SIZE__+0x1fae22c>
}
    121c:	05130505 	ldreq	r0, [r3, #-1285]	@ 0xfffffafb
    1220:	0501060a 	streq	r0, [r1, #-1546]	@ 0xfffff9f6
static bool printf2_numbers(const char fmt, va_list *args, int l_count) {
    1224:	05052e08 	streq	r2, [r5, #-3592]	@ 0xfffff1f8
    1228:	09053306 	stmdbeq	r5, {r1, r2, r8, r9, ip, sp}
  switch (fmt) {
    122c:	05050106 	streq	r0, [r5, #-262]	@ 0xfffffefa
    1230:	08054d06 	stmdaeq	r5, {r1, r2, r8, sl, fp, lr}
    1234:	07050106 	streq	r0, [r5, -r6, lsl #2]
      if (l_count == 0) {
    1238:	09054006 	stmdbeq	r5, {r1, r2, lr}
    123c:	07050106 	streq	r0, [r5, -r6, lsl #2]
        value = va_arg(*args, unsigned int);
    1240:	0a052206 	beq	149a60 <__ROM_SIZE__+0x109a60>
    1244:	20050106 	andcs	r0, r5, r6, lsl #2
      if (fmt == 'u') {
    1248:	01040200 	mrseq	r0, R12_usr
        if (value == 0) {
    124c:	0607052e 	streq	r0, [r7], -lr, lsr #10
          __write_char2__(hextable2[0]);
    1250:	060a0534 			@ <UNDEFINED> instruction: 0x060a0534
    1254:	00170501 	andseq	r0, r7, r1, lsl #10
  return true;
    1258:	2e010402 	cdpcs	4, 0, cr0, cr1, cr2, {0}
  switch (fmt) {
    125c:	03060e05 	movweq	r0, #28165	@ 0x6e05
      outstr2("\nprintf2-error\n");
    1260:	11052e0d 	tstne	r5, sp, lsl #28
      return false;
    1264:	0e050106 	adfeqs	f0, f5, f6
}
    1268:	11053106 	tstne	r5, r6, lsl #2
      if (l_count == 0) {
    126c:	0e050106 	adfeqs	f0, f5, f6
        value = va_arg(*args, int);
    1270:	1c053106 	stfnes	f3, [r5], {6}
    1274:	11050106 	tstne	r5, r6, lsl #2
      if (value < 0) {
    1278:	060e053c 			@ <UNDEFINED> instruction: 0x060e053c
        num[num_len++] = hextable2[value % 10];
    127c:	061c0532 			@ <UNDEFINED> instruction: 0x061c0532
    1280:	3c110501 	cfldr32cc	mvfx0, [r1], {1}
    1284:	03060c05 	movweq	r0, #27653	@ 0x6c05
    1288:	0f052e16 	svceq	0x00052e16
    128c:	09050106 	stmdbeq	r5, {r1, r2, r8}
    1290:	12053406 	andne	r3, r5, #100663296	@ 0x6000000
    1294:	1a050106 	bne	1416b4 <__ROM_SIZE__+0x1016b4>
    1298:	06090520 	streq	r0, [r9], -r0, lsr #10
    129c:	060e0559 			@ <UNDEFINED> instruction: 0x060e0559
        value = value / 10;
    12a0:	060b0501 	streq	r0, [fp], -r1, lsl #10
      } while (value > 0);
    12a4:	2f3c4e03 	svccs	0x003c4e03
    12a8:	02002b05 	andeq	r2, r0, #5120	@ 0x1400
        __write_char2__('-');
    12ac:	03060104 	movweq	r0, #24836	@ 0x6104
    12b0:	15053c0d 	strne	r3, [r5, #-3085]	@ 0xfffff3f3
        value = -value;
    12b4:	2905202f 	stmdbcs	r5, {r0, r1, r2, r3, r5, sp}
        __write_char2__(num[--num_len]);
    12b8:	01040200 	mrseq	r0, R12_usr
    12bc:	30150522 	andscc	r0, r5, r2, lsr #10
    12c0:	00290520 	eoreq	r0, r9, r0, lsr #10
    12c4:	22010402 	andcs	r0, r1, #33554432	@ 0x2000000
    12c8:	2f060905 	svccs	0x00060905
      while (num_len > 0) {
    12cc:	01060d05 	tsteq	r6, r5, lsl #26
  return true;
    12d0:	052e0c05 	streq	r0, [lr, #-3077]!	@ 0xfffff3fb
          num[num_len++] = hextable2[value % 10];
    12d4:	0521060b 	streq	r0, [r1, #-1547]!	@ 0xfffff9f5
    12d8:	4a0a0309 	bmi	281f04 <__ROM_SIZE__+0x241f04>
    12dc:	01060c05 	tsteq	r6, r5, lsl #24
    12e0:	31060b05 	tstcc	r6, r5, lsl #22
    12e4:	134d0905 	movtne	r0, #55557	@ 0xd905
    12e8:	11061505 	tstne	r6, r5, lsl #10
    12ec:	05210905 	streq	r0, [r1, #-2309]!	@ 0xfffff6fb
    12f0:	7103060b 	tstvc	r3, fp, lsl #12
          value = value / 10;
    12f4:	4a090320 	bmi	241f7c <__ROM_SIZE__+0x201f7c>
        } while (value > 0);
    12f8:	02000905 	andeq	r0, r0, #81920	@ 0x14000
        while (num_len > 0) {
    12fc:	0a030104 	beq	c1714 <__ROM_SIZE__+0x81714>
          __write_char2__(num[--num_len]);
    1300:	04020058 	streq	r0, [r2], #-88	@ 0xffffffa8
    1304:	11054b01 	tstne	r5, r1, lsl #22
    1308:	01040200 	mrseq	r0, R12_usr
    130c:	05201c03 	streq	r1, [r0, #-3075]!	@ 0xfffff3fd
    1310:	04020001 	streq	r0, [r2], #-1
    1314:	053d0601 	ldreq	r0, [sp, #-1537]!	@ 0xfffff9ff
  return true;
    1318:	0500060f 	streq	r0, [r0, #-1551]	@ 0xfffff9f1
              __write_char2__(hextable2[val]);
    131c:	000d0402 	andeq	r0, sp, r2, lsl #8
    1320:	013d0300 	teqeq	sp, r0, lsl #6
              leading_zero_ignored = true;
    1324:	2f210305 	svccs	0x00210305
          while (start_bit >= 0) {
    1328:	0402002f 	streq	r0, [r2], #-47	@ 0xffffffd1
            int val = (value >> start_bit) & 0xF;
    132c:	05053001 	streq	r3, [r5, #-1]
            if (val || leading_zero_ignored) {
    1330:	01040200 	mrseq	r0, R12_usr
    1334:	00090513 	andeq	r0, r9, r3, lsl r5
    1338:	2d010402 	cfstrscs	mvf0, [r1, #-8]
          bool leading_zero_ignored = false;
    133c:	05001905 	streq	r1, [r0, #-2309]	@ 0xfffff6fb
          int start_bit = LAST_NIBBLE_FIRST_BIT;
    1340:	000d1802 	andeq	r1, sp, r2, lsl #16
  return true;
    1344:	01061700 	tsteq	r6, r0, lsl #14
        return false;
    1348:	3d060305 	stccc	3, cr0, [r6, #-20]	@ 0xffffffec
        return false;
    134c:	0a051515 	beq	1467a8 <__ROM_SIZE__+0x1067a8>
    1350:	052e0106 	streq	r0, [lr, #-262]!	@ 0xfffffefa
    1354:	05310603 	ldreq	r0, [r1, #-1539]!	@ 0xfffff9fd
    1358:	20010606 	andcs	r0, r1, r6, lsl #12
    135c:	22060305 	andcs	r0, r6, #335544320	@ 0x14000000
    1360:	01060a05 	tsteq	r6, r5, lsl #20
int printf2(const char *fmt, ...) {
    1364:	053d0105 	ldreq	r0, [sp, #-261]!	@ 0xfffffefb
    1368:	04020011 	streq	r0, [r2], #-17	@ 0xffffffef
    136c:	00390601 	eorseq	r0, r9, r1, lsl #12
  va_start(args, fmt);
    1370:	06010402 	streq	r0, [r1], -r2, lsl #8
  while (*fmt) {
    1374:	0626053c 			@ <UNDEFINED> instruction: 0x0626053c
        if (*fmt == '%') {
    1378:	44020500 	strmi	r0, [r2], #-1280	@ 0xfffffb00
        __write_char2__(*fmt);
    137c:	1700000d 	strne	r0, [r0, -sp]
        fmt++;
    1380:	03050106 	movweq	r0, #20742	@ 0x5106
  while (*fmt) {
    1384:	08052f06 	stmdaeq	r5, {r1, r2, r8, r9, sl, fp, sp}
    switch (state) {
    1388:	060c0501 	streq	r0, [ip], -r1, lsl #10
    138c:	20030501 	andcs	r0, r3, r1, lsl #10
          fmt++;
    1390:	02003305 	andeq	r3, r0, #335544320	@ 0x14000000
          continue;
    1394:	20060204 	andcs	r0, r6, r4, lsl #4
        while (*fmt && ((*fmt >= '0' && *fmt <= '9') || *fmt == '-')) {
    1398:	02002905 	andeq	r2, r0, #81920	@ 0x14000
    139c:	05200104 	streq	r0, [r0, #-260]!	@ 0xfffffefc
    13a0:	04020018 	streq	r0, [r2], #-24	@ 0xffffffe8
    13a4:	05010601 	streq	r0, [r1, #-1537]	@ 0xfffff9ff
    13a8:	0402001b 	streq	r0, [r2], #-27	@ 0xffffffe5
        switch (*fmt) {
    13ac:	29054a01 	stmdbcs	r5, {r0, r9, fp, lr}
    13b0:	01040200 	mrseq	r0, R12_usr
    13b4:	06050520 	streq	r0, [r5], -r0, lsr #10
    13b8:	06090521 	streq	r0, [r9], -r1, lsr #10
            __write_char2__(*fmt);
    13bc:	3c080501 	cfstr32cc	mvfx0, [r8], {1}
    13c0:	2f060705 	svccs	0x00060705
            state = CHECK_CH;
    13c4:	01061305 	tsteq	r6, r5, lsl #6
            break;
    13c8:	2e2e1605 	cfmadda32cs	mvax0, mvax1, mvfx14, mvfx5
    13cc:	05150a05 	ldreq	r0, [r5, #-2565]	@ 0xfffff5fb
            outstr2(va_arg(args, const char *));
    13d0:	02202101 	eoreq	r2, r0, #1073741824	@ 0x40000000
    13d4:	01010002 	tsteq	r1, r2
    13d8:	00000462 	andeq	r0, r0, r2, ror #8
            fmt++;
    13dc:	00480003 	subeq	r0, r8, r3
            break;
    13e0:	01020000 	mrseq	r0, (UNDEF: 2)
            __write_char2__(va_arg(args, int));
    13e4:	000d0efb 	strdeq	r0, [sp], -fp
    13e8:	01010101 	tsteq	r1, r1, lsl #2
    13ec:	01000000 	mrseq	r0, (UNDEF: 0)
            fmt++;
    13f0:	2f010000 	svccs	0x00010000
            break;
    13f4:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
            if (*fmt == 'l') {
    13f8:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
    13fc:	63652f66 	cmnvs	r5, #408	@ 0x198
            if (printf2_numbers(*fmt, &args, l_count)) {
    1400:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
    1404:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
    1408:	732f7265 			@ <UNDEFINED> instruction: 0x732f7265
              state = CHECK_CH;
    140c:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
              fmt++;
    1410:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
              l_count++;
    1414:	7361622f 	cmnvc	r1, #-268435454	@ 0xf0000002
            if (printf2_numbers(*fmt, &args, 0)) {
    1418:	00343665 	eorseq	r3, r4, r5, ror #12
    141c:	73616200 	cmnvc	r1, #0, 4
              fmt++;
    1420:	2e343665 	cfmsuba32cs	mvax3, mvax3, mvfx4, mvfx5
              break;
    1424:	00010063 	andeq	r0, r1, r3, rrx
            return -1;
    1428:	31050000 	mrscc	r0, (UNDEF: 5)
}
    142c:	74020500 	strvc	r0, [r2], #-1280	@ 0xfffffb00
    1430:	1400000d 	strne	r0, [r0], #-13
            return -1;
    1434:	05140305 	ldreq	r0, [r4, #-773]	@ 0xfffffcfb
    1438:	05010605 	streq	r0, [r1, #-1541]	@ 0xfffff9fb
    143c:	05310603 	ldreq	r0, [r1, #-1539]!	@ 0xfffff9fd
int r32(int argc, char *argv[]) {
    1440:	05010605 	streq	r0, [r1, #-1541]	@ 0xfffff9fb
  if (argc < 2) {
    1444:	05310603 	ldreq	r0, [r1, #-1539]!	@ 0xfffff9fd
  uint32_t addr = atoh(argv[1]);
    1448:	05010605 	streq	r0, [r1, #-1541]	@ 0xfffff9fb
    144c:	05310603 	ldreq	r0, [r1, #-1539]!	@ 0xfffff9fd
  printf("0x%x: 0x%x\n", addr, data);
    1450:	05010605 	streq	r0, [r1, #-1541]	@ 0xfffff9fb
    1454:	05310603 	ldreq	r0, [r1, #-1539]!	@ 0xfffff9fd
}
    1458:	05010605 	streq	r0, [r1, #-1541]	@ 0xfffff9fb
    printf("Usage: %s <address> (in hex)\n", argv[0]);
    145c:	0520300a 	streq	r3, [r0, #-10]!
    1460:	0402000e 	streq	r0, [r2], #-14
    return -1;
    1464:	72030601 	andvc	r0, r3, #1048576	@ 0x100000
    1468:	00170520 	andseq	r0, r7, r0, lsr #10
    146c:	06010402 	streq	r0, [r1], -r2, lsl #8
int w32(int argc, char *argv[]) {
    1470:	04020001 	streq	r0, [r2], #-1
  if (argc < 3) {
    1474:	0e052001 	cdpeq	0, 0, cr2, cr5, cr1, {0}
  uint32_t addr = atoh(argv[1]);
    1478:	01040200 	mrseq	r0, R12_usr
    147c:	17053106 	strne	r3, [r5, -r6, lsl #2]
  uint32_t data = atoh(argv[2]);
    1480:	01040200 	mrseq	r0, R12_usr
    1484:	02000106 	andeq	r0, r0, #-2147483647	@ 0x80000001
  return 0;
    1488:	05200104 	streq	r0, [r0, #-260]!	@ 0xfffffefc
    printf("Usage: %s <address> (in hex) <value> (in hex)\n", argv[0]);
    148c:	0402000e 	streq	r0, [r2], #-14
    1490:	05310601 	ldreq	r0, [r1, #-1537]!	@ 0xfffff9ff
    return -1;
    1494:	04020017 	streq	r0, [r2], #-23	@ 0xffffffe9
    1498:	00010601 	andeq	r0, r1, r1, lsl #12
    149c:	20010402 	andcs	r0, r1, r2, lsl #8
int read_mem(int argc, char *argv[]) {
    14a0:	20311605 	eorscs	r1, r1, r5, lsl #12
  if (argc < 3) {
    14a4:	23010523 	movwcs	r0, #5411	@ 0x1523
  uint32_t addr = atoh(argv[1]);
    14a8:	22063105 	andcs	r3, r6, #1073741825	@ 0x40000001
    14ac:	03050106 	movweq	r0, #20742	@ 0x5106
  uint32_t length = atoi(argv[2]);
    14b0:	0f052206 	svceq	0x00052206
    14b4:	05200106 	streq	r0, [r0, #-262]!	@ 0xfffffefa
  for (uint32_t i = 0, data = 0; i < length; i++) {
    14b8:	03052005 	movweq	r2, #20485	@ 0x5005
    printf("Usage: %s <address> (in hex) <num_words> (in decimal)\n", argv[0]);
    14bc:	0f053106 	svceq	0x00053106
    14c0:	05050106 	streq	r0, [r5, #-262]	@ 0xfffffefa
    return -1;
    14c4:	0603053c 			@ <UNDEFINED> instruction: 0x0603053c
    14c8:	060f0531 			@ <UNDEFINED> instruction: 0x060f0531
    printf("0x%x: 0x%x\n", addr, data);
    14cc:	3c050501 	cfstr32cc	mvfx0, [r5], {1}
    14d0:	31060305 	tstcc	r6, r5, lsl #6
    addr += 4;
    14d4:	01060505 	tsteq	r6, r5, lsl #10
  for (uint32_t i = 0, data = 0; i < length; i++) {
    14d8:	31060305 	tstcc	r6, r5, lsl #6
  return 0;
    14dc:	01060505 	tsteq	r6, r5, lsl #10
}
    14e0:	05300a05 	ldreq	r0, [r0, #-2565]!	@ 0xfffff5fb
    14e4:	0402001c 	streq	r0, [r2], #-28	@ 0xffffffe4
{
    14e8:	75030601 	strvc	r0, [r3, #-1537]	@ 0xfffff9ff
  if (argc < 4) {
    14ec:	0025052e 	eoreq	r0, r5, lr, lsr #10
  uint32_t addr = atoh(argv[1]);
    14f0:	06010402 	streq	r0, [r1], -r2, lsl #8
    14f4:	001c0501 	andseq	r0, ip, r1, lsl #10
  uint32_t bit_loc = atoi(argv[2]);
    14f8:	06010402 	streq	r0, [r1], -r2, lsl #8
    14fc:	0025053f 	eoreq	r0, r5, pc, lsr r5
  uint32_t bit_val = atoi(argv[3]);
    1500:	06010402 	streq	r0, [r1], -r2, lsl #8
    1504:	3f170501 	svccc	0x00170501
  if (bit_loc > 31) {
    1508:	23010531 	movwcs	r0, #5425	@ 0x1531
  if (bit_val != 0 && bit_val != 1) {
    150c:	22063e05 	andcs	r3, r6, #5, 28	@ 0x50
  data = data | (bit_val << bit_loc);
    1510:	05130305 	ldreq	r0, [r3, #-773]	@ 0xfffffcfb
    1514:	05010618 	streq	r0, [r1, #-1560]	@ 0xfffff9e8
  data = data & ~(!bit_val << bit_loc);
    1518:	053c201c 	ldreq	r2, [ip, #-28]!	@ 0xffffffe4
    151c:	55052101 	strpl	r2, [r5, #-257]	@ 0xfffffeff
    1520:	01065a06 	tsteq	r6, r6, lsl #20
  return 0;
    1524:	3d060305 	stccc	3, cr0, [r6, #-20]	@ 0xffffffec
    printf("Error: Invalid bit location argument\n");
    1528:	06080514 			@ <UNDEFINED> instruction: 0x06080514
    152c:	06050501 	streq	r0, [r5], -r1, lsl #10
    printf("Error: Invalid bit value argument\n");
    1530:	1f29052f 	svcne	0x0029052f
    1534:	01060905 	tsteq	r6, r5, lsl #18
  printf("Usage: %s <address_in_hex(32-bits)> <bit_location_in_decimal(0 to 31)> <bit_value(0 or 1)>\n", argv[0]);
    1538:	053c2905 	ldreq	r2, [ip, #-2309]!	@ 0xfffff6fb
    153c:	04020042 	streq	r0, [r2], #-66	@ 0xffffffbe
  return -1;
    1540:	29052e01 	stmdbcs	r5, {r0, r9, sl, fp, sp}
    1544:	01040200 	mrseq	r0, R12_usr
    1548:	06030520 	streq	r0, [r3], -r0, lsr #10
    154c:	06180532 			@ <UNDEFINED> instruction: 0x06180532
{
    1550:	06030501 	streq	r0, [r3], -r1, lsl #10
  if (argc < 3) {
    1554:	06160521 	ldreq	r0, [r6], -r1, lsr #10
  uint32_t addr = atoh(argv[1]);
    1558:	20180501 	andscs	r0, r8, r1, lsl #10
    155c:	2e2e4605 	cfmadda32cs	mvax0, mvax4, mvfx14, mvfx5
  uint32_t bit_loc = atoi(argv[2]);
    1560:	01040200 	mrseq	r0, R12_usr
    1564:	00010520 	andeq	r0, r1, r0, lsr #10
  if (bit_loc > 31) {
    1568:	21040402 	tstcs	r4, r2, lsl #8
  uint32_t data = reg32(addr);
    156c:	052d4605 	streq	r4, [sp, #-1541]!	@ 0xfffff9fb
  printf("Bit %u @ 0x%08x: %u\n", bit_loc, addr, bit_val);
    1570:	05000666 	streq	r0, [r0, #-1638]	@ 0xfffff99a
    1574:	000e2c02 	andeq	r2, lr, r2, lsl #24
    1578:	01061500 	tsteq	r6, r0, lsl #10
  return 0;
    157c:	59060305 	stmdbpl	r6, {r0, r2, r8, r9}
    printf("Error: Invalid bit location argument\n");
    1580:	01061005 	tsteq	r6, r5
    1584:	4d060305 	stcmi	3, cr0, [r6, #-20]	@ 0xffffffec
  printf("Usage: %s <address_in_hex(32-bits)> <bit_location_in_decimal(0 to 31)\n", argv[0]);
    1588:	05010705 	streq	r0, [r1, #-1797]	@ 0xfffff8fb
    158c:	05010614 	streq	r0, [r1, #-1556]	@ 0xfffff9ec
  return -1;
    1590:	05052003 	streq	r2, [r5, #-3]
    1594:	03040200 	movweq	r0, #16896	@ 0x4200
    1598:	40052106 	andmi	r2, r5, r6, lsl #2
    159c:	03040200 	movweq	r0, #16896	@ 0x4200
{
    15a0:	11050106 	tstne	r5, r6, lsl #2
  for (i = 0; i < Nk; ++i)
    15a4:	03040200 	movweq	r0, #16896	@ 0x4200
    RoundKey[(i * 4) + 0] = Key[(i * 4) + 0];
    15a8:	000f0520 	andeq	r0, pc, r0, lsr #10
    15ac:	3c030402 	cfstrscc	mvf0, [r3], {2}
    15b0:	02000505 	andeq	r0, r0, #20971520	@ 0x1400000
    RoundKey[(i * 4) + 1] = Key[(i * 4) + 1];
    15b4:	21060304 	tstcs	r6, r4, lsl #6
    15b8:	02002805 	andeq	r2, r0, #327680	@ 0x50000
    RoundKey[(i * 4) + 2] = Key[(i * 4) + 2];
    15bc:	01060304 	tsteq	r6, r4, lsl #6
    15c0:	02003405 	andeq	r3, r0, #83886080	@ 0x5000000
    15c4:	05200304 	streq	r0, [r0, #-772]!	@ 0xfffffcfc
    RoundKey[(i * 4) + 3] = Key[(i * 4) + 3];
    15c8:	04020040 	streq	r0, [r2], #-64	@ 0xffffffc0
  for (i = 0; i < Nk; ++i)
    15cc:	11053c03 	tstne	r5, r3, lsl #24
    15d0:	03040200 	movweq	r0, #16896	@ 0x4200
  for (i = Nk; i < Nb * (Nr + 1); ++i)
    15d4:	000f0520 	andeq	r0, pc, r0, lsr #10
    j = i * 4; k=(i - Nk) * 4;
    15d8:	4a030402 	bmi	c25e8 <__ROM_SIZE__+0x825e8>
    RoundKey[j + 0] = RoundKey[k + 0] ^ tempa[0];
    15dc:	02000505 	andeq	r0, r0, #20971520	@ 0x1400000
    15e0:	21060304 	tstcs	r6, r4, lsl #6
    15e4:	02002805 	andeq	r2, r0, #327680	@ 0x50000
    15e8:	01060304 	tsteq	r6, r4, lsl #6
    RoundKey[j + 1] = RoundKey[k + 1] ^ tempa[1];
    15ec:	02003405 	andeq	r3, r0, #83886080	@ 0x5000000
    15f0:	05200304 	streq	r0, [r0, #-772]!	@ 0xfffffcfc
    15f4:	04020040 	streq	r0, [r2], #-64	@ 0xffffffc0
    15f8:	11053c03 	tstne	r5, r3, lsl #24
    15fc:	03040200 	movweq	r0, #16896	@ 0x4200
    RoundKey[j + 2] = RoundKey[k + 2] ^ tempa[2];
    1600:	000f0520 	andeq	r0, pc, r0, lsr #10
    1604:	4a030402 	bmi	c2614 <__ROM_SIZE__+0x82614>
    1608:	02000505 	andeq	r0, r0, #20971520	@ 0x1400000
    160c:	21060304 	tstcs	r6, r4, lsl #6
    1610:	02002805 	andeq	r2, r0, #327680	@ 0x50000
    RoundKey[j + 3] = RoundKey[k + 3] ^ tempa[3];
    1614:	01060304 	tsteq	r6, r4, lsl #6
    1618:	02001105 	andeq	r1, r0, #1073741825	@ 0x40000001
    161c:	05200304 	streq	r0, [r0, #-772]!	@ 0xfffffcfc
  for (i = Nk; i < Nb * (Nr + 1); ++i)
    1620:	0402000f 	streq	r0, [r2], #-15
      k = (i - 1) * 4;
    1624:	05054a03 	streq	r4, [r5, #-2563]	@ 0xfffff5fd
      tempa[0]=RoundKey[k + 0];
    1628:	03040200 	movweq	r0, #16896	@ 0x4200
    162c:	0b052206 	bleq	149e4c <__ROM_SIZE__+0x109e4c>
      tempa[1]=RoundKey[k + 1];
    1630:	03040200 	movweq	r0, #16896	@ 0x4200
    1634:	05050106 	streq	r0, [r5, #-262]	@ 0xfffffefa
      tempa[2]=RoundKey[k + 2];
    1638:	03040200 	movweq	r0, #16896	@ 0x4200
    163c:	0c052106 	stfeqs	f2, [r5], {6}
      tempa[3]=RoundKey[k + 3];
    1640:	03040200 	movweq	r0, #16896	@ 0x4200
    1644:	2a050106 	bcs	141a64 <__ROM_SIZE__+0x101a64>
    if (i % Nk == 0)
    1648:	03040200 	movweq	r0, #16896	@ 0x4200
    164c:	20790306 	rsbscs	r0, r9, r6, lsl #6
        tempa[0] = tempa[1];
    1650:	02001d05 	andeq	r1, r0, #320	@ 0x140
        tempa[1] = tempa[2];
    1654:	00200104 	eoreq	r0, r0, r4, lsl #2
        tempa[2] = tempa[3];
    1658:	06010402 	streq	r0, [r1], -r2, lsl #8
        tempa[3] = u8tmp;
    165c:	0603052e 	streq	r0, [r3], -lr, lsr #10
        tempa[0] = getSBoxValue(tempa[0]);
    1660:	05010a03 	streq	r0, [r1, #-2563]	@ 0xfffff5fd
    1664:	05010617 	streq	r0, [r1, #-1559]	@ 0xfffff9e9
        tempa[1] = getSBoxValue(tempa[1]);
    1668:	03069003 	movweq	r9, #24579	@ 0x6003
    166c:	0a055814 	beq	1576c4 <__ROM_SIZE__+0x1176c4>
        tempa[2] = getSBoxValue(tempa[2]);
    1670:	01050106 	tsteq	r5, r6, lsl #2
    1674:	0607053d 			@ <UNDEFINED> instruction: 0x0607053d
        tempa[3] = getSBoxValue(tempa[3]);
    1678:	052e6d03 	streq	r6, [lr, #-3331]!	@ 0xfffff2fd
      tempa[0] = tempa[0] ^ Rcon[i/Nk];
    167c:	05010611 	streq	r0, [r1, #-1553]	@ 0xfffff9ef
    1680:	22210607 	eorcs	r0, r1, #7340032	@ 0x700000
    1684:	01064205 	tsteq	r6, r5, lsl #4
    1688:	05201305 	streq	r1, [r0, #-773]!	@ 0xfffffcfb
}
    168c:	07053c11 	smladeq	r5, r1, ip, r3
    1690:	2a052106 	bcs	149ab0 <__ROM_SIZE__+0x109ab0>
{
    1694:	36050106 	strcc	r0, [r5], -r6, lsl #2
  for (i = 0; i < 4; ++i)
    1698:	20130520 	andscs	r0, r3, r0, lsr #10
      (*state)[i][j] ^= RoundKey[(round * Nb * 4) + (i * Nb) + j];
    169c:	054a1105 	strbeq	r1, [sl, #-261]	@ 0xfffffefb
    16a0:	05210607 	streq	r0, [r1, #-1543]!	@ 0xfffff9f9
    16a4:	05010611 	streq	r0, [r1, #-1553]	@ 0xfffff9ef
    16a8:	052f0607 	streq	r0, [pc, #-1543]!	@ 10a9 <printf_numbers+0xbd>
    16ac:	05010611 	streq	r0, [r1, #-1553]	@ 0xfffff9ef
    16b0:	05210607 	streq	r0, [r1, #-1543]!	@ 0xfffff9f9
    16b4:	05010611 	streq	r0, [r1, #-1553]	@ 0xfffff9ef
    for (j = 0; j < 4; ++j)
    16b8:	222f0607 	eorcs	r0, pc, #7340032	@ 0x700000
    16bc:	01064205 	tsteq	r6, r5, lsl #4
  for (i = 0; i < 4; ++i)
    16c0:	05201305 	streq	r1, [r0, #-773]!	@ 0xfffffcfb
    16c4:	07053c11 	smladeq	r5, r1, ip, r3
    for (j = 0; j < 4; ++j)
    16c8:	2a052106 	bcs	149ae8 <__ROM_SIZE__+0x109ae8>
  for (i = 0; i < 4; ++i)
    16cc:	36050106 	strcc	r0, [r5], -r6, lsl #2
    16d0:	3c420520 	cfstr64cc	mvdx0, [r2], {32}
    for (j = 0; j < 4; ++j)
    16d4:	05201305 	streq	r1, [r0, #-773]!	@ 0xfffffcfb
{
    16d8:	07054a11 	smladeq	r5, r1, sl, r4
      (*state)[j][i] = getSBoxValue((*state)[j][i]);
    16dc:	2a052106 	bcs	149afc <__ROM_SIZE__+0x109afc>
    16e0:	36050106 	strcc	r0, [r5], -r6, lsl #2
    16e4:	20130520 	andscs	r0, r3, r0, lsr #10
    16e8:	054a1105 	strbeq	r1, [sl, #-261]	@ 0xfffffefb
    for (j = 0; j < 4; ++j)
    16ec:	05210607 	streq	r0, [r1, #-1543]!	@ 0xfffff9f9
    16f0:	05010611 	streq	r0, [r1, #-1553]	@ 0xfffff9ef
  for (i = 0; i < 4; ++i)
    16f4:	052f0607 	streq	r0, [pc, #-1543]!	@ 10f5 <printf_numbers+0x109>
    16f8:	05010611 	streq	r0, [r1, #-1553]	@ 0xfffff9ef
    for (j = 0; j < 4; ++j)
    16fc:	052f0607 	streq	r0, [pc, #-1543]!	@ 10fd <printf_numbers+0x111>
}
    1700:	02050066 	andeq	r0, r5, #102	@ 0x66
  for (i = 0; i < 4; ++i)
    1704:	00000f14 	andeq	r0, r0, r4, lsl pc
    1708:	05010619 	streq	r0, [r1, #-1561]	@ 0xfffff9e7
    170c:	054b0603 	strbeq	r0, [fp, #-1539]	@ 0xfffff9fd
  temp           = (*state)[0][1];
    1710:	2e010620 	cfmadd32cs	mvax1, mvfx0, mvfx1, mvfx0
  (*state)[0][1] = (*state)[1][1];
    1714:	23060305 	movwcs	r0, #25349	@ 0x6305
  (*state)[1][1] = (*state)[2][1];
    1718:	05010705 	streq	r0, [r1, #-1797]	@ 0xfffff8fb
  (*state)[2][1] = (*state)[3][1];
    171c:	05010614 	streq	r0, [r1, #-1556]	@ 0xfffff9ec
  temp           = (*state)[0][2];
    1720:	05052003 	streq	r2, [r5, #-3]
  (*state)[0][2] = (*state)[2][2];
    1724:	03040200 	movweq	r0, #16896	@ 0x4200
  temp           = (*state)[1][2];
    1728:	11052106 	tstne	r5, r6, lsl #2
  (*state)[1][2] = (*state)[3][2];
    172c:	03040200 	movweq	r0, #16896	@ 0x4200
  temp           = (*state)[0][3];
    1730:	2c050106 	stfcss	f0, [r5], {6}
  (*state)[0][3] = (*state)[3][3];
    1734:	03040200 	movweq	r0, #16896	@ 0x4200
  (*state)[3][3] = (*state)[2][3];
    1738:	0033053c 	eorseq	r0, r3, ip, lsr r5
  (*state)[2][3] = (*state)[1][3];
    173c:	20030402 	andcs	r0, r3, r2, lsl #8
}
    1740:	02003105 	andeq	r3, r0, #1073741825	@ 0x40000001
  return ((x<<1) ^ (((x>>7) & 1) * 0x1b));
    1744:	053c0304 	ldreq	r0, [ip, #-772]!	@ 0xfffffcfc
    1748:	0402000f 	streq	r0, [r2], #-15
    174c:	05052e03 	streq	r2, [r5, #-3587]	@ 0xfffff1fd
}
    1750:	03040200 	movweq	r0, #16896	@ 0x4200
{
    1754:	11052106 	tstne	r5, r6, lsl #2
    1758:	03040200 	movweq	r0, #16896	@ 0x4200
  for (i = 0; i < 4; ++i)
    175c:	2c050106 	stfcss	f0, [r5], {6}
    t   = (*state)[i][0];
    1760:	03040200 	movweq	r0, #16896	@ 0x4200
    Tmp = (*state)[i][0] ^ (*state)[i][1] ^ (*state)[i][2] ^ (*state)[i][3] ;
    1764:	0033053c 	eorseq	r0, r3, ip, lsr r5
    1768:	20030402 	andcs	r0, r3, r2, lsl #8
    176c:	02003105 	andeq	r3, r0, #1073741825	@ 0x40000001
    1770:	053c0304 	ldreq	r0, [ip, #-772]!	@ 0xfffffcfc
    1774:	0402000f 	streq	r0, [r2], #-15
    1778:	05052e03 	streq	r2, [r5, #-3587]	@ 0xfffff1fd
    Tm  = (*state)[i][0] ^ (*state)[i][1] ; Tm = xtime(Tm);  (*state)[i][0] ^= Tm ^ Tmp ;
    177c:	03040200 	movweq	r0, #16896	@ 0x4200
    1780:	11052106 	tstne	r5, r6, lsl #2
    1784:	03040200 	movweq	r0, #16896	@ 0x4200
    Tm  = (*state)[i][1] ^ (*state)[i][2] ; Tm = xtime(Tm);  (*state)[i][1] ^= Tm ^ Tmp ;
    1788:	2c050106 	stfcss	f0, [r5], {6}
    178c:	03040200 	movweq	r0, #16896	@ 0x4200
    1790:	0033053c 	eorseq	r0, r3, ip, lsr r5
    1794:	20030402 	andcs	r0, r3, r2, lsl #8
    1798:	02003105 	andeq	r3, r0, #1073741825	@ 0x40000001
    Tm  = (*state)[i][2] ^ (*state)[i][3] ; Tm = xtime(Tm);  (*state)[i][2] ^= Tm ^ Tmp ;
    179c:	053c0304 	ldreq	r0, [ip, #-772]!	@ 0xfffffcfc
    17a0:	0402000f 	streq	r0, [r2], #-15
    17a4:	05052003 	streq	r2, [r5, #-3]
    17a8:	03040200 	movweq	r0, #16896	@ 0x4200
    Tm  = (*state)[i][3] ^ t ;              Tm = xtime(Tm);  (*state)[i][3] ^= Tm ^ Tmp ;
    17ac:	0b052206 	bleq	149fcc <__ROM_SIZE__+0x109fcc>
    17b0:	03040200 	movweq	r0, #16896	@ 0x4200
    17b4:	05050106 	streq	r0, [r5, #-262]	@ 0xfffffefa
    17b8:	03040200 	movweq	r0, #16896	@ 0x4200
    17bc:	0c052106 	stfeqs	f2, [r5], {6}
  for (i = 0; i < 4; ++i)
    17c0:	03040200 	movweq	r0, #16896	@ 0x4200
    17c4:	30050106 	andcc	r0, r5, r6, lsl #2
}
    17c8:	03040200 	movweq	r0, #16896	@ 0x4200
{
    17cc:	207a0306 	rsbscs	r0, sl, r6, lsl #6
    17d0:	02001d05 	andeq	r1, r0, #320	@ 0x140
  for (i = 0; i < 4; ++i)
    17d4:	00200104 	eoreq	r0, r0, r4, lsl #2
    a = (*state)[i][0];
    17d8:	06010402 	streq	r0, [r1], -r2, lsl #8
    b = (*state)[i][1];
    17dc:	0603052e 	streq	r0, [r3], -lr, lsr #10
    17e0:	05010903 	streq	r0, [r1, #-2307]	@ 0xfffff6fd
    c = (*state)[i][2];
    17e4:	05010618 	streq	r0, [r1, #-1560]	@ 0xfffff9e8
    d = (*state)[i][3];
    17e8:	01059003 	tsteq	r5, r3
    (*state)[i][0] = Multiply(a, 0x0e) ^ Multiply(b, 0x0b) ^ Multiply(c, 0x0d) ^ Multiply(d, 0x09);
    17ec:	054a0b03 	strbeq	r0, [sl, #-2819]	@ 0xfffff4fd
    17f0:	77030607 	strvc	r0, [r3, -r7, lsl #12]
    17f4:	0613053c 			@ <UNDEFINED> instruction: 0x0613053c
    17f8:	3c2e0501 	cfstr32cc	mvfx0, [lr], #-4
    17fc:	05203505 	streq	r3, [r0, #-1285]!	@ 0xfffffafb
    1800:	11053c33 	tstne	r5, r3, lsr ip
    1804:	0607052e 	streq	r0, [r7], -lr, lsr #10
    1808:	13052221 	movwne	r2, #21025	@ 0x5221
    180c:	2e050106 	adfcss	f0, f5, f6
    1810:	2035053c 	eorscs	r0, r5, ip, lsr r5
    1814:	053c3305 	ldreq	r3, [ip, #-773]!	@ 0xfffffcfb
    1818:	07052e11 	smladeq	r5, r1, lr, r2
    181c:	13052106 	movwne	r2, #20742	@ 0x5106
    1820:	2e050106 	adfcss	f0, f5, f6
    1824:	2035053c 	eorscs	r0, r5, ip, lsr r5
    1828:	053c3305 	ldreq	r3, [ip, #-773]!	@ 0xfffffcfb
    182c:	07052e11 	smladeq	r5, r1, lr, r2
    1830:	03052106 	movweq	r2, #20742	@ 0x5106
    1834:	060a0515 			@ <UNDEFINED> instruction: 0x060a0515
    1838:	00040201 	andeq	r0, r4, r1, lsl #4
    183c:	039f0101 	orrseq	r0, pc, #1073741824	@ 0x40000000
    1840:	00030000 	andeq	r0, r3, r0
    1844:	0000009e 	muleq	r0, lr, r0
    1848:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
    184c:	0101000d 	tsteq	r1, sp
    1850:	00000101 	andeq	r0, r0, r1, lsl #2
    1854:	00000100 	andeq	r0, r0, r0, lsl #2
    1858:	6f682f01 	svcvs	0x00682f01
    185c:	652f656d 	strvs	r6, [pc, #-1389]!	@ 12f7 <printf2_numbers+0xd3>
    1860:	2f667463 	svccs	0x00667463
    1864:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    1868:	6172742d 	cmnvs	r2, sp, lsr #8
    186c:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
    1870:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
    1874:	6c2f6c6c 	stcvs	12, cr6, [pc], #-432	@ 16cc <SubBytes>
    1878:	702f6269 	eorvc	r6, pc, r9, ror #4
    (*state)[i][1] = Multiply(a, 0x09) ^ Multiply(b, 0x0e) ^ Multiply(c, 0x0b) ^ Multiply(d, 0x0d);
    187c:	746e6972 	strbtvc	r6, [lr], #-2418	@ 0xfffff68e
    1880:	6f2f0066 	svcvs	0x002f0066
    1884:	672f7470 			@ <UNDEFINED> instruction: 0x672f7470
    1888:	612d6363 			@ <UNDEFINED> instruction: 0x612d6363
    188c:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
    1890:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	@ 0xfffffe44
    1894:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
    1898:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
    189c:	6363672f 	cmnvs	r3, #12320768	@ 0xbc0000
    18a0:	6d72612f 	ldfvse	f6, [r2, #-188]!	@ 0xffffff44
    18a4:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
    18a8:	61652d65 	cmnvs	r5, r5, ror #26
    18ac:	312f6962 			@ <UNDEFINED> instruction: 0x312f6962
    18b0:	2e322e32 	mrccs	14, 1, r2, cr2, cr2, {1}
    (*state)[i][2] = Multiply(a, 0x0d) ^ Multiply(b, 0x09) ^ Multiply(c, 0x0e) ^ Multiply(d, 0x0b);
    18b4:	6e692f31 	mcrvs	15, 3, r2, cr9, cr1, {1}
    18b8:	64756c63 	ldrbtvs	r6, [r5], #-3171	@ 0xfffff39d
    18bc:	70000065 	andvc	r0, r0, r5, rrx
    18c0:	746e6972 	strbtvc	r6, [lr], #-2418	@ 0xfffff68e
    18c4:	00632e66 	rsbeq	r2, r3, r6, ror #28
    18c8:	73000001 	movwvc	r0, #1
    18cc:	72616474 	rsbvc	r6, r1, #116, 8	@ 0x74000000
    18d0:	00682e67 	rsbeq	r2, r8, r7, ror #28
    18d4:	3c000002 	stccc	0, cr0, [r0], {2}
    18d8:	6c697562 	cfstr64vs	mvdx7, [r9], #-392	@ 0xfffffe78
    18dc:	6e692d74 	mcrvs	13, 3, r2, cr9, cr4, {3}
    18e0:	0000003e 	andeq	r0, r0, lr, lsr r0
    (*state)[i][3] = Multiply(a, 0x0b) ^ Multiply(b, 0x0d) ^ Multiply(c, 0x09) ^ Multiply(d, 0x0e);
    18e4:	25050000 	strcs	r0, [r5, #-0]
    18e8:	d0020500 	andle	r0, r2, r0, lsl #10
    18ec:	0300000f 	movweq	r0, #15
    18f0:	0106012a 	tsteq	r6, sl, lsr #2
    18f4:	2f060305 	svccs	0x00060305
    18f8:	01060905 	tsteq	r6, r5, lsl #18
    18fc:	21060505 	tstcs	r6, r5, lsl #10
    1900:	0608053d 			@ <UNDEFINED> instruction: 0x0608053d
    1904:	060f0501 	streq	r0, [pc], -r1, lsl #10
    1908:	060a051e 			@ <UNDEFINED> instruction: 0x060a051e
    190c:	200f0501 	andcs	r0, pc, r1, lsl #10
    1910:	20320105 	eorscs	r0, r2, r5, lsl #2
    1914:	00064805 	andeq	r4, r6, r5, lsl #16
  for (i = 0; i < 4; ++i)
    1918:	0fec0205 	svceq	0x00ec0205
    191c:	06140000 	ldreq	r0, [r4], -r0
}
    1920:	06030501 	streq	r0, [r3], -r1, lsl #10
  for (i = 0; i < 4; ++i)
    1924:	0514133d 	ldreq	r1, [r4, #-829]	@ 0xfffffcc3
    1928:	743b0307 	ldrtvc	r0, [fp], #-775	@ 0xfffffcf9
    for (j = 0; j < 4; ++j)
    192c:	060a0514 			@ <UNDEFINED> instruction: 0x060a0514
{
    1930:	06090501 	streq	r0, [r9], -r1, lsl #10
      (*state)[j][i] = getSBoxInvert((*state)[j][i]);
    1934:	060f053d 			@ <UNDEFINED> instruction: 0x060f053d
    1938:	07052e01 	streq	r2, [r5, -r1, lsl #28]
    193c:	2e110306 	cdpcs	3, 1, cr0, cr1, cr6, {0}
    1940:	01060a05 	tsteq	r6, r5, lsl #20
    1944:	03060905 	movweq	r0, #26885	@ 0x6905
    for (j = 0; j < 4; ++j)
    1948:	0c052e0a 	stceq	14, cr2, [r5], {10}
    194c:	0b050106 	bleq	141d6c <__ROM_SIZE__+0x101d6c>
  for (i = 0; i < 4; ++i)
    1950:	3c062f06 	stccc	15, cr2, [r6], {6}
    1954:	030a0520 	movweq	r0, #42272	@ 0xa520
    for (j = 0; j < 4; ++j)
    1958:	052e0116 	streq	r0, [lr, #-278]!	@ 0xfffffeea
}
    195c:	7f900303 	svcvc	0x00900303
  for (i = 0; i < 4; ++i)
    1960:	06070501 	streq	r0, [r7], -r1, lsl #10
    1964:	2e00ed03 	cdpcs	13, 0, cr14, cr0, cr3, {0}
    1968:	2f062006 	svccs	0x00062006
  temp = (*state)[3][1];
    196c:	01060e05 	tsteq	r6, r5, lsl #28
  (*state)[3][1] = (*state)[2][1];
    1970:	05230105 	streq	r0, [r3, #-261]!	@ 0xfffffefb
  (*state)[2][1] = (*state)[1][1];
    1974:	9a030607 	bls	c3198 <__ROM_SIZE__+0x83198>
  (*state)[1][1] = (*state)[0][1];
    1978:	05142e7f 	ldreq	r2, [r4, #-3711]	@ 0xfffff181
  temp = (*state)[0][2];
    197c:	0501060a 	streq	r0, [r1, #-1546]	@ 0xfffff9f6
  (*state)[0][2] = (*state)[2][2];
    1980:	052f0609 	streq	r0, [pc, #-1545]!	@ 137f <printf2+0x1b>
  temp = (*state)[1][2];
    1984:	2e01060f 	cfmadd32cs	mvax0, mvfx0, mvfx1, mvfx15
  (*state)[1][2] = (*state)[3][2];
    1988:	03060705 	movweq	r0, #26373	@ 0x6705
  temp = (*state)[0][3];
    198c:	0a052e12 	beq	14d1dc <__ROM_SIZE__+0x10d1dc>
  (*state)[0][3] = (*state)[1][3];
    1990:	07050106 	streq	r0, [r5, -r6, lsl #2]
  (*state)[1][3] = (*state)[2][3];
    1994:	01040200 	mrseq	r0, R12_usr
  (*state)[2][3] = (*state)[3][3];
    1998:	09053306 	stmdbeq	r5, {r1, r2, r8, r9, ip, sp}
}
    199c:	01040200 	mrseq	r0, R12_usr
{
    19a0:	00290513 	eoreq	r0, r9, r3, lsl r5
  AddRoundKey(0, state, RoundKey);
    19a4:	06010402 	streq	r0, [r1], -r2, lsl #8
    19a8:	00220501 	eoreq	r0, r2, r1, lsl #10
    19ac:	ac010402 	cfstrsge	mvf0, [r1], {2}
  for (round = 1; ; ++round)
    19b0:	02001805 	andeq	r1, r0, #327680	@ 0x50000
    MixColumns(state);
    19b4:	002e0104 	eoreq	r0, lr, r4, lsl #2
    AddRoundKey(round, state, RoundKey);
    19b8:	4a010402 	bmi	429c8 <__ROM_SIZE__+0x29c8>
    19bc:	02000905 	andeq	r0, r0, #81920	@ 0x14000
    19c0:	2f060104 	svccs	0x00060104
  for (round = 1; ; ++round)
    19c4:	02000f05 	andeq	r0, r0, #5, 30
    SubBytes(state);
    19c8:	20060104 	andcs	r0, r6, r4, lsl #2
    ShiftRows(state);
    19cc:	02001605 	andeq	r1, r0, #5242880	@ 0x500000
    19d0:	21060104 	tstcs	r6, r4, lsl #2
    if (round == Nr) {
    19d4:	79030905 	stmdbvc	r3, {r0, r2, r8, fp}
  AddRoundKey(Nr, state, RoundKey);
    19d8:	063c063c 			@ <UNDEFINED> instruction: 0x063c063c
    19dc:	060f0521 	streq	r0, [pc], -r1, lsr #10
}
    19e0:	09052001 	stmdbeq	r5, {r0, sp}
{
    19e4:	20090306 	andcs	r0, r9, r6, lsl #6
  AddRoundKey(Nr, state, RoundKey);
    19e8:	16052006 	strne	r2, [r5], -r6
    19ec:	0a058f06 	beq	16560c <__ROM_SIZE__+0x12560c>
    19f0:	00c60306 	sbceq	r0, r6, r6, lsl #6
  for (round = (Nr - 1); ; --round)
    19f4:	0009052e 	andeq	r0, r9, lr, lsr #10
    InvMixColumns(state);
    19f8:	06010402 	streq	r0, [r1], -r2, lsl #8
  for (round = (Nr - 1); ; --round)
    19fc:	052e6003 	streq	r6, [lr, #-3]!
    InvShiftRows(state);
    1a00:	0402000b 	streq	r0, [r2], #-11
    1a04:	2b051301 	blcs	146610 <__ROM_SIZE__+0x106610>
    InvSubBytes(state);
    1a08:	01040200 	mrseq	r0, R12_usr
    AddRoundKey(round, state, RoundKey);
    1a0c:	24050106 	strcs	r0, [r5], #-262	@ 0xfffffefa
    1a10:	01040200 	mrseq	r0, R12_usr
    1a14:	001a0590 	mulseq	sl, r0, r5
    if (round == 0) {
    1a18:	2e010402 	cdpcs	4, 0, cr0, cr1, cr2, {0}
  for (i = 0; i < AES_BLOCKLEN; ++i) // The block in AES is always 128bit no matter the key size
    1a1c:	01040200 	mrseq	r0, R12_usr
    buf[i] ^= Iv[i];
    1a20:	000b054a 	andeq	r0, fp, sl, asr #10
    1a24:	06010402 	streq	r0, [r1], -r2, lsl #8
    1a28:	0011052f 	andseq	r0, r1, pc, lsr #10
  for (i = 0; i < AES_BLOCKLEN; ++i) // The block in AES is always 128bit no matter the key size
    1a2c:	06010402 	streq	r0, [r1], -r2, lsl #8
    1a30:	00180520 	andseq	r0, r8, r0, lsr #10
}
    1a34:	06010402 	streq	r0, [r1], -r2, lsl #8
  KeyExpansion(ctx->RoundKey, key);
    1a38:	0b053021 	bleq	14dac4 <__ROM_SIZE__+0x10dac4>
}
    1a3c:	9e20062f 	cfmadda32ls	mvax1, mvax0, mvfx0, mvfx15
{
    1a40:	1a030a05 	bne	c425c <__ROM_SIZE__+0x8425c>
  KeyExpansion(ctx->RoundKey, key);
    1a44:	060f0501 	streq	r0, [pc], -r1, lsl #10
  memcpy (ctx->Iv, iv, AES_BLOCKLEN);
    1a48:	132e7303 			@ <UNDEFINED> instruction: 0x132e7303
    1a4c:	57062405 	strpl	r2, [r6, -r5, lsl #8]
    1a50:	23060d05 	movwcs	r0, #27909	@ 0x6d05
}
    1a54:	01061705 	tsteq	r6, r5, lsl #14
  memcpy (ctx->Iv, iv, AES_BLOCKLEN);
    1a58:	061c0520 	ldreq	r0, [ip], -r0, lsr #10
    1a5c:	05017a03 	streq	r7, [r1, #-2563]	@ 0xfffff5fd
}
    1a60:	1e052f0d 	cdpne	15, 0, cr2, cr5, cr13, {0}
{
    1a64:	0d050106 	stfeqs	f0, [r5, #-24]	@ 0xffffffe8
  Cipher((state_t*)buf, ctx->RoundKey);
    1a68:	10052f06 	andne	r2, r5, r6, lsl #30
    1a6c:	052e0106 	streq	r0, [lr, #-262]!	@ 0xfffffefa
{
    1a70:	04020015 	streq	r0, [r2], #-21	@ 0xffffffeb
  InvCipher((state_t*)buf, ctx->RoundKey);
    1a74:	02002001 	andeq	r2, r0, #1
    1a78:	053c0104 	ldreq	r0, [ip, #-260]!	@ 0xfffffefc
}
    1a7c:	0f050e10 	svceq	0x00050e10
{
    1a80:	0520201f 	streq	r2, [r0, #-31]!	@ 0xffffffe1
    1a84:	0113030a 	tsteq	r3, sl, lsl #6
  uint8_t *Iv = ctx->Iv;
    1a88:	ac031005 	stcge	0, cr1, [r3], {5}
    1a8c:	20202e7f 	eorcs	r2, r0, pc, ror lr
  for (i = 0; i < length; i += AES_BLOCKLEN)
    1a90:	20013003 	andcs	r3, r1, r3
    XorWithIv(buf, Iv);
    1a94:	00062205 	andeq	r2, r6, r5, lsl #4
    Cipher((state_t*)buf, ctx->RoundKey);
    1a98:	112c0205 			@ <UNDEFINED> instruction: 0x112c0205
    1a9c:	27030000 	strcs	r0, [r3, -r0]
  for (i = 0; i < length; i += AES_BLOCKLEN)
    1aa0:	05010601 	streq	r0, [r1, #-1537]	@ 0xfffff9ff
    buf += AES_BLOCKLEN;
    1aa4:	13670603 	cmnne	r7, #3145728	@ 0x300000
  for (i = 0; i < length; i += AES_BLOCKLEN)
    1aa8:	10052214 	andne	r2, r5, r4, lsl r2
  memcpy(ctx->Iv, Iv, AES_BLOCKLEN);
    1aac:	09050d06 	stmdbeq	r5, {r1, r2, r8, sl, fp}
    1ab0:	05230625 	streq	r0, [r3, #-1573]!	@ 0xfffff9db
}
    1ab4:	0501060c 	streq	r0, [r1, #-1548]	@ 0xfffff9f4
{
    1ab8:	3d330609 	ldccc	6, cr0, [r3, #-36]!	@ 0xffffffdc
    1abc:	01060c05 	tsteq	r6, r5, lsl #24
    1ac0:	21060905 	tstcs	r6, r5, lsl #18
  for (i = 0; i < length; i += AES_BLOCKLEN)
    1ac4:	76030a05 	strvc	r0, [r3], -r5, lsl #20
    memcpy(storeNextIv, buf, AES_BLOCKLEN);
    1ac8:	3d050501 	cfstr32cc	mvfx0, [r5, #-4]
    1acc:	02000b05 	andeq	r0, r0, #5120	@ 0x1400
    InvCipher((state_t*)buf, ctx->RoundKey);
    1ad0:	004d0104 	subeq	r0, sp, r4, lsl #2
    1ad4:	13010402 	movwne	r0, #5122	@ 0x1402
    XorWithIv(buf, ctx->Iv);
    1ad8:	02000e05 	andeq	r0, r0, #5, 28	@ 0x50
    1adc:	01060104 	tsteq	r6, r4, lsl #2
    1ae0:	02000b05 	andeq	r0, r0, #5120	@ 0x1400
    memcpy(ctx->Iv, storeNextIv, AES_BLOCKLEN);
    1ae4:	21060104 	tstcs	r6, r4, lsl #2
    1ae8:	02001105 	andeq	r1, r0, #1073741825	@ 0x40000001
    1aec:	10060104 	andne	r0, r6, r4, lsl #2
  for (i = 0; i < length; i += AES_BLOCKLEN)
    1af0:	02000b05 	andeq	r0, r0, #5120	@ 0x1400
    1af4:	06220104 	strteq	r0, [r2], -r4, lsl #2
}
    1af8:	05200903 	streq	r0, [r0, #-2307]!	@ 0xfffff6fd
{
    1afc:	0501060e 	streq	r0, [r1, #-1550]	@ 0xfffff9f2
    1b00:	051f0615 	ldreq	r0, [pc, #-1557]	@ 14f3 <w32_bit+0xb>
    1b04:	05010610 	streq	r0, [r1, #-1552]	@ 0xfffff9f0
  for (i = 0, bi = AES_BLOCKLEN; i < length; ++i, ++bi)
    1b08:	26052015 			@ <UNDEFINED> instruction: 0x26052015
          ctx->Iv[bi] = 0;
    1b0c:	01040200 	mrseq	r0, R12_usr
    1b10:	00150520 	andseq	r0, r5, r0, lsr #10
      for (bi = (AES_BLOCKLEN - 1); bi >= 0; --bi)
    1b14:	3c010402 	cfstrscc	mvf0, [r1], {2}
      bi = 0;
    1b18:	02003605 	andeq	r3, r0, #5242880	@ 0x500000
    buf[i] = (buf[i] ^ buffer[bi]);
    1b1c:	052e0204 	streq	r0, [lr, #-516]!	@ 0xfffffdfc
    1b20:	05320609 	ldreq	r0, [r2, #-1545]!	@ 0xfffff9f7
    1b24:	053d920d 	ldreq	r9, [sp, #-525]!	@ 0xfffffdf3
    1b28:	05010610 	streq	r0, [r1, #-1552]	@ 0xfffff9f0
    1b2c:	1321060d 			@ <UNDEFINED> instruction: 0x1321060d
  for (i = 0, bi = AES_BLOCKLEN; i < length; ++i, ++bi)
    1b30:	11061305 	tstne	r6, r5, lsl #6
    1b34:	20210d05 	eorcs	r0, r1, r5, lsl #26
    if (bi == AES_BLOCKLEN) /* we need to regen xor compliment in buffer */
    1b38:	4a090306 	bmi	242758 <__ROM_SIZE__+0x202758>
      memcpy(buffer, ctx->Iv, AES_BLOCKLEN);
    1b3c:	06100567 	ldreq	r0, [r0], -r7, ror #10
    1b40:	060d0501 	streq	r0, [sp], -r1, lsl #10
    1b44:	13051321 	movwne	r1, #21281	@ 0x5321
      Cipher((state_t*)buffer,ctx->RoundKey);
    1b48:	0d051106 	stfeqs	f1, [r5, #-24]	@ 0xffffffe8
    1b4c:	77030621 	strvc	r0, [r3, -r1, lsr #12]
      for (bi = (AES_BLOCKLEN - 1); bi >= 0; --bi)
    1b50:	061c0520 	ldreq	r0, [ip], -r0, lsr #10
    1b54:	3c0d052e 	cfstr32cc	mvfx0, [sp], {46}	@ 0x2e
        if (ctx->Iv[bi] == 255)
    1b58:	10052f06 	andne	r2, r5, r6, lsl #30
    1b5c:	0d050106 	stfeqs	f0, [r5, #-24]	@ 0xffffffe8
        ctx->Iv[bi] += 1;
    1b60:	05132106 	ldreq	r2, [r3, #-262]	@ 0xfffffefa
    1b64:	05110613 	ldreq	r0, [r1, #-1555]	@ 0xfffff9ed
      bi = 0;
    1b68:	2806210d 	stmdacs	r6, {r0, r2, r3, r8, sp}
}
    1b6c:	06100513 			@ <UNDEFINED> instruction: 0x06100513
  return ((x[idx / 32U] >> (idx & 31U) & 1U));
    1b70:	060d0501 	streq	r0, [sp], -r1, lsl #10
    1b74:	06110521 	ldreq	r0, [r1], -r1, lsr #10
    1b78:	20100501 	andscs	r0, r0, r1, lsl #10
}
    1b7c:	052c1105 	streq	r1, [ip, #-261]!	@ 0xfffffefb
    1b80:	0526060d 	streq	r0, [r6, #-1549]!	@ 0xfffff9f3
  x[idx / 32U] &= ~(1U << (idx & 31U));
    1b84:	05010611 	streq	r0, [r1, #-1553]	@ 0xfffff9ef
    1b88:	0f054a10 	svceq	0x00054a10
    1b8c:	05132106 	ldreq	r2, [r3, #-262]	@ 0xfffffefa
    1b90:	05010612 	streq	r0, [r1, #-1554]	@ 0xfffff9ee
    1b94:	0521060f 	streq	r0, [r1, #-1551]!	@ 0xfffff9f1
    1b98:	05100615 	ldreq	r0, [r0, #-1557]	@ 0xfffff9eb
  for (i = 0; i < BITVEC_NWORDS; ++i)
    1b9c:	0306220f 	movweq	r2, #25103	@ 0x620f
    x[i] = y[i];
    1ba0:	0513207a 	ldreq	r2, [r3, #-122]	@ 0xffffff86
    1ba4:	05010612 	streq	r0, [r1, #-1554]	@ 0xfffff9ee
  for (i = 0; i < BITVEC_NWORDS; ++i)
    1ba8:	052e1f16 	streq	r1, [lr, #-3862]!	@ 0xfffff0ea
    1bac:	0b03060d 	bleq	c33e8 <__ROM_SIZE__+0x833e8>
{
    1bb0:	06110501 	ldreq	r0, [r1], -r1, lsl #10
    1bb4:	4a100501 	bmi	402fc0 <__ROM_SIZE__+0x3c2fc0>
  bitvec_copy(tmp, x);
    1bb8:	21060f05 	tstcs	r6, r5, lsl #30
    1bbc:	06120513 			@ <UNDEFINED> instruction: 0x06120513
  bitvec_copy(x, y);
    1bc0:	060f0501 	streq	r0, [pc], -r1, lsl #10
    1bc4:	06150521 	ldreq	r0, [r5], -r1, lsr #10
  bitvec_copy(y, tmp);
    1bc8:	220f0510 	andcs	r0, pc, #16, 10	@ 0x4000000
    1bcc:	7a031405 	bvc	c6be8 <__ROM_SIZE__+0x86be8>
}
    1bd0:	01052e20 	tsteq	r5, r0, lsr #28
  for (i = 0; i < BITVEC_NWORDS; ++i)
    1bd4:	05011103 	streq	r1, [r1, #-259]	@ 0xfffffefd
    1bd8:	58770314 	ldmdapl	r7!, {r2, r4, r8, r9}^
    if (x[i] != y[i])
    1bdc:	01000602 	tsteq	r0, r2, lsl #12
    1be0:	0003a001 	andeq	sl, r3, r1
    1be4:	9f000300 	svcls	0x00000300
  for (i = 0; i < BITVEC_NWORDS; ++i)
    1be8:	02000000 	andeq	r0, r0, #0
  return 1;
    1bec:	0d0efb01 	vstreq	d15, [lr, #-4]
}
    1bf0:	01010100 	mrseq	r0, (UNDEF: 17)
  for (i = 0; i < BITVEC_NWORDS; ++i)
    1bf4:	00000001 	andeq	r0, r0, r1
    x[i] = 0;
    1bf8:	01000001 	tsteq	r0, r1
  for (i = 0; i < BITVEC_NWORDS; ++i)
    1bfc:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 1b48 <AES_CTR_xcrypt_buffer+0x4c>
    1c00:	63652f65 	cmnvs	r5, #404	@ 0x194
  uint32_t i = 0;
    1c04:	652f6674 	strvs	r6, [pc, #-1652]!	@ 1598 <r32_bit+0x48>
  while (i < BITVEC_NWORDS)
    1c08:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
    if (x[i] != 0)
    1c0c:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
    i += 1;
    1c10:	2f72656e 	svccs	0x0072656e
}
    1c14:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
    1c18:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
    1c1c:	72702f62 	rsbsvc	r2, r0, #392	@ 0x188
  x += BITVEC_NWORDS;
    1c20:	66746e69 	ldrbtvs	r6, [r4], -r9, ror #28
          && (*(--x)) == 0)
    1c24:	706f2f00 	rsbvc	r2, pc, r0, lsl #30
    1c28:	63672f74 	cmnvs	r7, #116, 30	@ 0x1d0
    1c2c:	72612d63 	rsbvc	r2, r1, #6336	@ 0x18c0
    i -= 32;
    1c30:	6f6e2d6d 	svcvs	0x006e2d6d
  if (i != 0)
    1c34:	652d656e 	strvs	r6, [sp, #-1390]!	@ 0xfffffa92
      i -= 1;
    1c38:	2f696261 	svccs	0x00696261
    while (((*x) & u32mask) == 0)
    1c3c:	2f62696c 	svccs	0x0062696c
}
    1c40:	2f636367 	svccs	0x00636367
    uint32_t u32mask = ((uint32_t)1 << 31);
    1c44:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	@ 0xfffffe7c
{
    1c48:	656e6f6e 	strbvs	r6, [lr, #-3950]!	@ 0xfffff092
  int nwords = (nbits / 32);
    1c4c:	6261652d 	rsbvs	r6, r1, #188743680	@ 0xb400000
    1c50:	32312f69 	eorscc	r2, r1, #420	@ 0x1a4
  for (i = 0; i < nwords; ++i)
    1c54:	312e322e 			@ <UNDEFINED> instruction: 0x312e322e
  int nwords = (nbits / 32);
    1c58:	636e692f 	cmnvs	lr, #770048	@ 0xbc000
    1c5c:	6564756c 	strbvs	r7, [r4, #-1388]!	@ 0xfffffa94
    x[i] = 0;
    1c60:	72700000 	rsbsvc	r0, r0, #0
  for (i = 0; i < nwords; ++i)
    1c64:	66746e69 	ldrbtvs	r6, [r4], -r9, ror #28
    1c68:	00632e32 	rsbeq	r2, r3, r2, lsr lr
  j = 0;
    1c6c:	73000001 	movwvc	r0, #1
    x[i] = y[j];
    1c70:	72616474 	rsbvc	r6, r1, #116, 8	@ 0x74000000
    1c74:	00682e67 	rsbeq	r2, r8, r7, ror #28
    i += 1;
    1c78:	3c000002 	stccc	0, cr0, [r0], {2}
    j += 1;
    1c7c:	6c697562 	cfstr64vs	mvdx7, [r9], #-392	@ 0xfffffe78
  while (i < BITVEC_NWORDS)
    1c80:	6e692d74 	mcrvs	13, 3, r2, cr9, cr4, {3}
  if (nbits != 0)
    1c84:	0000003e 	andeq	r0, r0, lr, lsr r0
}
    1c88:	26050000 	strcs	r0, [r5], -r0
      x[i]  = (x[i] << nbits) | (x[i - 1] >> (32 - nbits));
    1c8c:	08020500 	stmdaeq	r2, {r8, sl}
    1c90:	03000012 	movweq	r0, #18
    1c94:	01060128 	tsteq	r6, r8, lsr #2
    1c98:	2f060305 	svccs	0x00060305
    1c9c:	01060905 	tsteq	r6, r5, lsl #18
    1ca0:	21060505 	tstcs	r6, r5, lsl #10
    1ca4:	0608053d 			@ <UNDEFINED> instruction: 0x0608053d
    1ca8:	060f0501 	streq	r0, [pc], -r1, lsl #10
    for (i = (BITVEC_NWORDS - 1); i > 0; --i)
    1cac:	060a051e 			@ <UNDEFINED> instruction: 0x060a051e
    x[0] <<= nbits;
    1cb0:	200f0501 	andcs	r0, pc, r1, lsl #10
    1cb4:	20320105 	eorscs	r0, r2, r5, lsl #2
    for (i = (BITVEC_NWORDS - 1); i > 0; --i)
    1cb8:	00064905 	andeq	r4, r6, r5, lsl #18
  x[0] = 1;
    1cbc:	12240205 	eorne	r0, r4, #1342177280	@ 0x50000000
  for (i = 1; i < BITVEC_NWORDS; ++i)
    1cc0:	06140000 	ldreq	r0, [r4], -r0
    x[i] = 0;
    1cc4:	06030501 	streq	r0, [r3], -r1, lsl #10
  for (i = 1; i < BITVEC_NWORDS; ++i)
    1cc8:	0514133d 	ldreq	r1, [r4, #-829]	@ 0xfffffcc3
    1ccc:	743b0307 	ldrtvc	r0, [fp], #-775	@ 0xfffffcf9
  if (x[0] != 1)
    1cd0:	060a0514 			@ <UNDEFINED> instruction: 0x060a0514
    1cd4:	06090501 	streq	r0, [r9], -r1, lsl #10
  for (i = 1; i < BITVEC_NWORDS; ++i)
    1cd8:	060f053d 			@ <UNDEFINED> instruction: 0x060f053d
    if (x[i] != 0)
    1cdc:	07052e01 	streq	r2, [r5, -r1, lsl #28]
  for (i = 1; i < BITVEC_NWORDS; ++i)
    1ce0:	2e110306 	cdpcs	3, 1, cr0, cr1, cr6, {0}
  return (i == BITVEC_NWORDS);
    1ce4:	01060a05 	tsteq	r6, r5, lsl #20
    1ce8:	03060905 	movweq	r0, #26885	@ 0x6905
    1cec:	0c052e0a 	stceq	14, cr2, [r5], {10}
}
    1cf0:	0b050106 	bleq	142110 <__ROM_SIZE__+0x102110>
  for (i = 0; i < BITVEC_NWORDS; ++i)
    1cf4:	3c062f06 	stccc	15, cr2, [r6], {6}
{
    1cf8:	030a0520 	movweq	r0, #42272	@ 0xa520
    z[i] = (x[i] ^ y[i]);
    1cfc:	052e0116 	streq	r0, [lr, #-278]!	@ 0xfffffeea
    1d00:	7f900303 	svcvc	0x00900303
    1d04:	06070501 	streq	r0, [r7], -r1, lsl #10
  for (i = 0; i < BITVEC_NWORDS; ++i)
    1d08:	2e00ed03 	cdpcs	13, 0, cr14, cr0, cr3, {0}
    1d0c:	2f062006 	svccs	0x00062006
}
    1d10:	01060e05 	tsteq	r6, r5, lsl #28
  x[0] ^= 1;
    1d14:	05230105 	streq	r0, [r3, #-261]!	@ 0xfffffefb
    1d18:	9a030607 	bls	c353c <__ROM_SIZE__+0x8353c>
}
    1d1c:	05142e7f 	ldreq	r2, [r4, #-3711]	@ 0xfffff181
{
    1d20:	0501060a 	streq	r0, [r1, #-1546]	@ 0xfffff9f6
    1d24:	052f0609 	streq	r0, [pc, #-1545]!	@ 1723 <ShiftRows+0x13>
  bitvec_copy(tmp, x);
    1d28:	2e01060f 	cfmadd32cs	mvax0, mvfx0, mvfx1, mvfx15
    1d2c:	03060705 	movweq	r0, #26373	@ 0x6705
  if (bitvec_get_bit(y, 0) != 0)
    1d30:	0a052e12 	beq	14d580 <__ROM_SIZE__+0x10d580>
    1d34:	07050106 	streq	r0, [r5, -r6, lsl #2]
    bitvec_copy(z, x);
    1d38:	01040200 	mrseq	r0, R12_usr
    1d3c:	09053306 	stmdbeq	r5, {r1, r2, r8, r9, ip, sp}
{
    1d40:	01040200 	mrseq	r0, R12_usr
    bitvec_set_zero(z);
    1d44:	002a0513 	eoreq	r0, sl, r3, lsl r5
    1d48:	06010402 	streq	r0, [r1], -r2, lsl #8
      gf2field_add(tmp, tmp, polynomial);
    1d4c:	00230501 	eoreq	r0, r3, r1, lsl #10
    1d50:	ac010402 	cfstrsge	mvf0, [r1], {2}
    1d54:	02001805 	andeq	r1, r0, #327680	@ 0x50000
  for (i = 1; i < CURVE_DEGREE; ++i)
    1d58:	002e0104 	eoreq	r0, lr, r4, lsl #2
    1d5c:	4a010402 	bmi	42d6c <__ROM_SIZE__+0x2d6c>
    bitvec_lshift(tmp, tmp, 1);
    1d60:	02000905 	andeq	r0, r0, #81920	@ 0x14000
    1d64:	2f060104 	svccs	0x00060104
    if (bitvec_get_bit(tmp, CURVE_DEGREE))
    1d68:	02000f05 	andeq	r0, r0, #5, 30
    1d6c:	20060104 	andcs	r0, r6, r4, lsl #2
    1d70:	02001605 	andeq	r1, r0, #5242880	@ 0x500000
    if (bitvec_get_bit(y, i))
    1d74:	21060104 	tstcs	r6, r4, lsl #2
    1d78:	79030905 	stmdbvc	r3, {r0, r2, r8, fp}
    1d7c:	063c063c 			@ <UNDEFINED> instruction: 0x063c063c
      gf2field_add(z, z, tmp);
    1d80:	060f0521 	streq	r0, [pc], -r1, lsr #10
    1d84:	09052001 	stmdbeq	r5, {r0, sp}
    1d88:	20090306 	andcs	r0, r9, r6, lsl #6
}
    1d8c:	16052006 	strne	r2, [r5], -r6
    1d90:	0a058f06 	beq	1659b0 <__ROM_SIZE__+0x1259b0>
{
    1d94:	00c60306 	sbceq	r0, r6, r6, lsl #6
    1d98:	0009052e 	andeq	r0, r9, lr, lsr #10
  bitvec_copy(u, x);
    1d9c:	06010402 	streq	r0, [r1], -r2, lsl #8
  bitvec_copy(v, polynomial);
    1da0:	052e6003 	streq	r6, [lr, #-3]!
    1da4:	0402000b 	streq	r0, [r2], #-11
  bitvec_set_zero(g);
    1da8:	2c051301 	stccs	3, cr1, [r5], {1}
    1dac:	01040200 	mrseq	r0, R12_usr
  gf2field_set_one(z);
    1db0:	25050106 	strcs	r0, [r5, #-262]	@ 0xfffffefa
  while (!gf2field_is_one(u))
    1db4:	01040200 	mrseq	r0, R12_usr
    bitvec_lshift(h, v, i);
    1db8:	001a0590 	mulseq	sl, r0, r5
    1dbc:	2e010402 	cdpcs	4, 0, cr0, cr1, cr2, {0}
    gf2field_add(u, u, h);
    1dc0:	01040200 	mrseq	r0, R12_usr
    1dc4:	000b054a 	andeq	r0, fp, sl, asr #10
    1dc8:	06010402 	streq	r0, [r1], -r2, lsl #8
    bitvec_lshift(h, g, i);
    1dcc:	0011052f 	andseq	r0, r1, pc, lsr #10
    1dd0:	06010402 	streq	r0, [r1], -r2, lsl #8
    gf2field_add(z, z, h);
    1dd4:	00180520 	andseq	r0, r8, r0, lsr #10
    1dd8:	06010402 	streq	r0, [r1], -r2, lsl #8
    1ddc:	0b053021 	bleq	14de68 <__ROM_SIZE__+0x10de68>
  while (!gf2field_is_one(u))
    1de0:	9e20062f 	cfmadda32ls	mvax1, mvax0, mvfx0, mvfx15
    1de4:	1a030a05 	bne	c4600 <__ROM_SIZE__+0x84600>
    i = (bitvec_degree(u) - bitvec_degree(v));
    1de8:	060f0501 	streq	r0, [pc], -r1, lsl #10
    1dec:	132e7303 			@ <UNDEFINED> instruction: 0x132e7303
    1df0:	57062405 	strpl	r2, [r6, -r5, lsl #8]
    1df4:	23060d05 	movwcs	r0, #27909	@ 0x6d05
    if (i < 0)
    1df8:	01061705 	tsteq	r6, r5, lsl #14
      bitvec_swap(u, v);
    1dfc:	061c0520 	ldreq	r0, [ip], -r0, lsr #10
    1e00:	05017a03 	streq	r7, [r1, #-2563]	@ 0xfffff5fd
      bitvec_swap(g, z);
    1e04:	1e052f0d 	cdpne	15, 0, cr2, cr5, cr13, {0}
    1e08:	0d050106 	stfeqs	f0, [r5, #-24]	@ 0xffffffe8
      i = -i;
    1e0c:	10052f06 	andne	r2, r5, r6, lsl #30
}
    1e10:	052e0106 	streq	r0, [lr, #-262]!	@ 0xfffffefa
    1e14:	04020015 	streq	r0, [r2], #-21	@ 0xffffffeb
{
    1e18:	02002001 	andeq	r2, r0, #1
    1e1c:	053c0104 	ldreq	r0, [ip, #-260]!	@ 0xfffffefc
  bitvec_copy(x1, x2);
    1e20:	0f050e10 	svceq	0x00050e10
  bitvec_copy(y1, y2);
    1e24:	0520201f 	streq	r2, [r0, #-31]!	@ 0xffffffe1
    1e28:	0113030a 	tsteq	r3, sl, lsl #6
}
    1e2c:	ac031005 	stcge	0, cr1, [r3], {5}
{
    1e30:	20202e7f 	eorcs	r2, r0, pc, ror lr
  bitvec_set_zero(x);
    1e34:	20013003 	andcs	r3, r1, r3
  bitvec_set_zero(y);
    1e38:	00062305 	andeq	r2, r6, r5, lsl #6
}
    1e3c:	13640205 	cmnne	r4, #1342177280	@ 0x50000000
{
    1e40:	27030000 	strcs	r0, [r3, -r0]
  return (    bitvec_is_zero(x)
    1e44:	05010601 	streq	r0, [r1, #-1537]	@ 0xfffff9ff
           && bitvec_is_zero(y));
    1e48:	13670603 	cmnne	r7, #3145728	@ 0x300000
    1e4c:	11052214 	tstne	r5, r4, lsl r2
    1e50:	09050d06 	stmdbeq	r5, {r1, r2, r8, sl, fp}
{
    1e54:	05230625 	streq	r0, [r3, #-1573]!	@ 0xfffff9db
    1e58:	0501060c 	streq	r0, [r1, #-1548]	@ 0xfffff9f4
  if (bitvec_is_zero(x))
    1e5c:	3d330609 	ldccc	6, cr0, [r3, #-36]!	@ 0xffffffdc
    1e60:	01060c05 	tsteq	r6, r5, lsl #24
    bitvec_set_zero(y);
    1e64:	21060905 	tstcs	r6, r5, lsl #18
}
    1e68:	76030a05 	strvc	r0, [r3], -r5, lsl #20
    gf2field_inv(l, x);
    1e6c:	3d050501 	cfstr32cc	mvfx0, [r5, #-4]
    1e70:	02000b05 	andeq	r0, r0, #5120	@ 0x1400
    gf2field_mul(l, l, y);
    1e74:	004d0104 	subeq	r0, sp, r4, lsl #2
    1e78:	13010402 	movwne	r0, #5122	@ 0x1402
    1e7c:	02000e05 	andeq	r0, r0, #5, 28	@ 0x50
    gf2field_add(l, l, x);
    1e80:	01060104 	tsteq	r6, r4, lsl #2
    1e84:	02000b05 	andeq	r0, r0, #5120	@ 0x1400
    gf2field_mul(y, x, x);
    1e88:	21060104 	tstcs	r6, r4, lsl #2
    1e8c:	02001105 	andeq	r1, r0, #1073741825	@ 0x40000001
    1e90:	10060104 	andne	r0, r6, r4, lsl #2
    gf2field_mul(x, l, l);
    1e94:	02000b05 	andeq	r0, r0, #5120	@ 0x1400
    1e98:	06220104 	strteq	r0, [r2], -r4, lsl #2
    gf2field_inc(l);
    1e9c:	05200903 	streq	r0, [r0, #-2307]!	@ 0xfffff6fd
    1ea0:	0501060e 	streq	r0, [r1, #-1550]	@ 0xfffff9f2
    gf2field_add(x, x, l);
    1ea4:	051f0615 	ldreq	r0, [pc, #-1557]	@ 1897 <InvMixColumns+0xcd>
    1ea8:	05010610 	streq	r0, [r1, #-1552]	@ 0xfffff9f0
    gf2field_mul(l, l, x);
    1eac:	26052015 			@ <UNDEFINED> instruction: 0x26052015
    1eb0:	01040200 	mrseq	r0, R12_usr
    1eb4:	00150520 	andseq	r0, r5, r0, lsr #10
    gf2field_add(y, y, l);
    1eb8:	3c010402 	cfstrscc	mvf0, [r1], {2}
    1ebc:	02003605 	andeq	r3, r0, #5242880	@ 0x500000
}
    1ec0:	052e0204 	streq	r0, [lr, #-516]!	@ 0xfffffdfc
{
    1ec4:	05320609 	ldreq	r0, [r2, #-1545]!	@ 0xfffff9f7
    1ec8:	053d920d 	ldreq	r9, [sp, #-525]!	@ 0xfffffdf3
    1ecc:	05010610 	streq	r0, [r1, #-1552]	@ 0xfffff9f0
  if (!gf2point_is_zero(x2, y2))
    1ed0:	1321060d 			@ <UNDEFINED> instruction: 0x1321060d
    1ed4:	11061305 	tstne	r6, r5, lsl #6
    if (gf2point_is_zero(x1, y1))
    1ed8:	20210d05 	eorcs	r0, r1, r5, lsl #26
    1edc:	4a090306 	bmi	242afc <__ROM_SIZE__+0x202afc>
    1ee0:	06100567 	ldreq	r0, [r0], -r7, ror #10
      if (bitvec_equal(x1, x2))
    1ee4:	060d0501 	streq	r0, [sp], -r1, lsl #10
    1ee8:	13051321 	movwne	r1, #21281	@ 0x5321
        if (bitvec_equal(y1, y2))
    1eec:	0d051106 	stfeqs	f1, [r5, #-24]	@ 0xffffffe8
    1ef0:	77030621 	strvc	r0, [r3, -r1, lsr #12]
    1ef4:	061d0520 	ldreq	r0, [sp], -r0, lsr #10
          gf2point_double(x1, y1);
    1ef8:	3c0d052e 	cfstr32cc	mvfx0, [sp], {46}	@ 0x2e
    1efc:	10052f06 	andne	r2, r5, r6, lsl #30
      gf2point_copy(x1, y1, x2, y2);
    1f00:	0d050106 	stfeqs	f0, [r5, #-24]	@ 0xffffffe8
    1f04:	05132106 	ldreq	r2, [r3, #-262]	@ 0xfffffefa
    1f08:	05110613 	ldreq	r0, [r1, #-1555]	@ 0xfffff9ed
}
    1f0c:	2806210d 	stmdacs	r6, {r0, r2, r3, r8, sp}
          gf2point_set_zero(x1, y1);
    1f10:	06100513 			@ <UNDEFINED> instruction: 0x06100513
    1f14:	060d0501 	streq	r0, [sp], -r1, lsl #10
    1f18:	06110521 	ldreq	r0, [r1], -r1, lsr #10
        gf2field_add(a, y1, y2);
    1f1c:	20100501 	andscs	r0, r0, r1, lsl #10
    1f20:	052c1105 	streq	r1, [ip, #-261]!	@ 0xfffffefb
        gf2field_add(b, x1, x2);
    1f24:	0526060d 	streq	r0, [r6, #-1549]!	@ 0xfffff9f3
    1f28:	05010611 	streq	r0, [r1, #-1553]	@ 0xfffff9ef
    1f2c:	0f054a10 	svceq	0x00054a10
        gf2field_inv(c, b);
    1f30:	05132106 	ldreq	r2, [r3, #-262]	@ 0xfffffefa
    1f34:	05010612 	streq	r0, [r1, #-1554]	@ 0xfffff9ee
        gf2field_mul(c, c, a);
    1f38:	0521060f 	streq	r0, [r1, #-1551]!	@ 0xfffff9f1
    1f3c:	05100615 	ldreq	r0, [r0, #-1557]	@ 0xfffff9eb
        gf2field_mul(d, c, c);
    1f40:	0306220f 	movweq	r2, #25103	@ 0x620f
    1f44:	0513207a 	ldreq	r2, [r3, #-122]	@ 0xffffff86
    1f48:	05010612 	streq	r0, [r1, #-1554]	@ 0xfffff9ee
        gf2field_add(d, d, c);
    1f4c:	052e1f16 	streq	r1, [lr, #-3862]!	@ 0xfffff0ea
    1f50:	0b03060d 	bleq	c378c <__ROM_SIZE__+0x8378c>
        gf2field_add(d, d, b);
    1f54:	06110501 	ldreq	r0, [r1], -r1, lsl #10
    1f58:	4a100501 	bmi	403364 <__ROM_SIZE__+0x3c3364>
    1f5c:	21060f05 	tstcs	r6, r5, lsl #30
        gf2field_inc(d);
    1f60:	06120513 			@ <UNDEFINED> instruction: 0x06120513
        gf2field_add(x1, x1, d);
    1f64:	060f0501 	streq	r0, [pc], -r1, lsl #10
    1f68:	06150521 	ldreq	r0, [r5], -r1, lsr #10
    1f6c:	220f0510 	andcs	r0, pc, #16, 10	@ 0x4000000
        gf2field_mul(a, x1, c);
    1f70:	7a031405 	bvc	c6f8c <__ROM_SIZE__+0x86f8c>
    1f74:	01052e20 	tsteq	r5, r0, lsr #28
        gf2field_add(a, a, d);
    1f78:	05011103 	streq	r1, [r1, #-259]	@ 0xfffffefd
    1f7c:	58770314 	ldmdapl	r7!, {r2, r4, r8, r9}^
    1f80:	01000602 	tsteq	r0, r2, lsl #12
        gf2field_add(y1, y1, a);
    1f84:	00031f01 	andeq	r1, r3, r1, lsl #30
    1f88:	25000300 	strcs	r0, [r0, #-768]	@ 0xfffffd00
        bitvec_copy(x1, d);
    1f8c:	02000001 	andeq	r0, r0, #1
    1f90:	0d0efb01 	vstreq	d15, [lr, #-4]
}
    1f94:	01010100 	mrseq	r0, (UNDEF: 17)
{
    1f98:	00000001 	andeq	r0, r0, r1
    1f9c:	01000001 	tsteq	r0, r1
  int nbits = bitvec_degree(exp);
    1fa0:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 1eec <gf2point_add+0x2a>
    1fa4:	63652f65 	cmnvs	r5, #404	@ 0x194
  gf2point_set_zero(tmpx, tmpy);
    1fa8:	652f6674 	strvs	r6, [pc, #-1652]!	@ 193c <InvSubBytes+0x18>
    1fac:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
  for (i = (nbits - 1); i >= 0; --i)
    1fb0:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
    1fb4:	2f72656e 	svccs	0x0072656e
    1fb8:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
    gf2point_double(tmpx, tmpy);
    1fbc:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
    1fc0:	74752f62 	ldrbtvc	r2, [r5], #-3938	@ 0xfffff09e
    if (bitvec_get_bit(exp, i))
    1fc4:	00736c69 	rsbseq	r6, r3, r9, ror #24
    1fc8:	74706f2f 	ldrbtvc	r6, [r0], #-3887	@ 0xfffff0d1
    1fcc:	6363672f 	cmnvs	r3, #12320768	@ 0xbc0000
      gf2point_add(tmpx, tmpy, x, y);
    1fd0:	6d72612d 	ldfvse	f6, [r2, #-180]!	@ 0xffffff4c
    1fd4:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
    1fd8:	61652d65 	cmnvs	r5, r5, ror #26
  gf2point_copy(x, y, tmpx, tmpy);
    1fdc:	6c2f6962 			@ <UNDEFINED> instruction: 0x6c2f6962
    1fe0:	672f6269 	strvs	r6, [pc, -r9, ror #4]!
    1fe4:	612f6363 			@ <UNDEFINED> instruction: 0x612f6363
}
    1fe8:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
{
    1fec:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	@ 0xfffffe44
    1ff0:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
  if (gf2point_is_zero(x, y))
    1ff4:	2e32312f 	rsfcssp	f3, f2, #10.0
    1ff8:	2f312e32 	svccs	0x00312e32
}
    1ffc:	6c636e69 	stclvs	14, cr6, [r3], #-420	@ 0xfffffe5c
    gf2field_mul(a, x, x);
    2000:	00656475 	rsbeq	r6, r5, r5, ror r4
    2004:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 1f50 <gf2point_add+0x8e>
    2008:	63652f65 	cmnvs	r5, #404	@ 0x194
    gf2field_mul(b, a, x);
    200c:	652f6674 	strvs	r6, [pc, #-1652]!	@ 19a0 <Cipher+0x2>
    2010:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
    gf2field_add(a, a, b);
    2014:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
    2018:	2f72656e 	svccs	0x0072656e
    201c:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
    gf2field_add(a, a, coeff_b);
    2020:	68732f6c 	ldmdavs	r3!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
    2024:	006c6c65 	rsbeq	r6, ip, r5, ror #24
    gf2field_mul(b, y, y);
    2028:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 1f74 <gf2point_add+0xb2>
    202c:	63652f65 	cmnvs	r5, #404	@ 0x194
    2030:	652f6674 	strvs	r6, [pc, #-1652]!	@ 19c4 <Cipher+0x26>
    gf2field_add(a, a, b);
    2034:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
    2038:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
    gf2field_mul(b, x, y);
    203c:	2f72656e 	svccs	0x0072656e
    2040:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
    2044:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
    return bitvec_equal(a, b);
    2048:	32612f62 	rsbcc	r2, r1, #392	@ 0x188
    204c:	682f0069 	stmdavs	pc!, {r0, r3, r5, r6}	@ <UNPREDICTABLE>
    2050:	2f656d6f 	svccs	0x00656d6f
{
    2054:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    2058:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
  gf2point_copy((uint32_t*)public_key, (uint32_t*)(public_key + BITVEC_NBYTES), base_x, base_y);
    205c:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
    2060:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
    2064:	68732f72 	ldmdavs	r3!, {r1, r4, r5, r6, r8, r9, sl, fp, sp}^
    2068:	2f6c6c65 	svccs	0x006c6c65
  if (bitvec_degree((uint32_t*)private_key) < (CURVE_DEGREE / 2))
    206c:	2f62696c 	svccs	0x0062696c
    2070:	6e697270 	mcrvs	2, 3, r7, cr9, cr0, {3}
    2074:	00006674 	andeq	r6, r0, r4, ror r6
    int nbits = bitvec_degree(base_order);
    2078:	6c697475 	cfstrdvs	mvd7, [r9], #-468	@ 0xfffffe2c
    for (i = (nbits - 1); i < (BITVEC_NWORDS * 32); ++i)
    207c:	00632e73 	rsbeq	r2, r3, r3, ror lr
      bitvec_clr_bit((uint32_t*)private_key, i);
    2080:	73000001 	movwvc	r0, #1
    2084:	6e696474 	mcrvs	4, 3, r6, cr9, cr4, {3}
    for (i = (nbits - 1); i < (BITVEC_NWORDS * 32); ++i)
    2088:	63672d74 	cmnvs	r7, #116, 26	@ 0x1d00
    208c:	00682e63 	rsbeq	r2, r8, r3, ror #28
    gf2point_mul((uint32_t*)public_key, (uint32_t*)(public_key + BITVEC_NBYTES), (uint32_t*)private_key);
    2090:	73000002 	movwvc	r0, #2
    2094:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
    return 1;
    2098:	0300682e 	movweq	r6, #2094	@ 0x82e
    return 0;
    209c:	32610000 	rsbcc	r0, r1, #0
    20a0:	00682e69 	rsbeq	r2, r8, r9, ror #28
    20a4:	70000004 	andvc	r0, r0, r4
{
    20a8:	746e6972 	strbtvc	r6, [lr], #-2418	@ 0xfffff68e
    20ac:	00682e66 	rsbeq	r2, r8, r6, ror #28
  if (    !gf2point_is_zero ((uint32_t*)others_pub, (uint32_t*)(others_pub + BITVEC_NBYTES))
    20b0:	00000005 	andeq	r0, r0, r5
    20b4:	05002105 	streq	r2, [r0, #-261]	@ 0xfffffefb
    20b8:	00144002 	andseq	r4, r4, r2
    20bc:	01180300 	tsteq	r8, r0, lsl #6
}
    20c0:	03050106 	movweq	r0, #20742	@ 0x5106
       &&  gf2point_on_curve((uint32_t*)others_pub, (uint32_t*)(others_pub + BITVEC_NBYTES)) )
    20c4:	06052106 	streq	r2, [r5], -r6, lsl #2
    20c8:	03050106 	movweq	r0, #20742	@ 0x5106
    20cc:	13053306 	movwne	r3, #21254	@ 0x5306
    for (i = 0; i < (BITVEC_NBYTES * 2); ++i)
    20d0:	2e200106 	sufcss	f0, f0, f6
      output[i] = others_pub[i];
    20d4:	21060305 	tstcs	r6, r5, lsl #6
    20d8:	06080514 			@ <UNDEFINED> instruction: 0x06080514
    for (i = 0; i < (BITVEC_NBYTES * 2); ++i)
    20dc:	06030501 	streq	r0, [r3], -r1, lsl #10
    gf2point_mul((uint32_t*)output,(uint32_t*)(output + BITVEC_NBYTES), (const uint32_t*)private_key);
    20e0:	06200622 	strteq	r0, [r0], -r2, lsr #12
    20e4:	060a052f 	streq	r0, [sl], -pc, lsr #10
    20e8:	21010501 	tstcs	r1, r1, lsl #10
    return 1;
    20ec:	03060505 	movweq	r0, #25861	@ 0x6505
int atoi(const char* str) {
    20f0:	20062075 	andcs	r2, r6, r5, ror r0
  int res = 0;
    20f4:	052f0620 	streq	r0, [pc, #-1568]!	@ 1adc <AES_CBC_decrypt_buffer+0x26>
    res = res * 10 + str[i] - '0';
    20f8:	0501060c 	streq	r0, [r1, #-1548]	@ 0xfffff9f4
    20fc:	0c030621 	stceq	6, cr0, [r3], {33}	@ 0x21
    2100:	05010674 	streq	r0, [r1, #-1652]	@ 0xfffff98c
  for (int i = 0; str[i] != '\0'; ++i) {
    2104:	052f0603 	streq	r0, [pc, #-1539]!	@ 1b09 <AES_CTR_xcrypt_buffer+0xd>
    2108:	05010606 	streq	r0, [r1, #-1542]	@ 0xfffff9fa
}
    210c:	05320603 	ldreq	r0, [r2, #-1539]!	@ 0xfffff9fd
  for (uint32_t i = 0; str[i] != '\0'; i++) {
    2110:	20010613 	andcs	r0, r1, r3, lsl r6
    2114:	0603052e 	streq	r0, [r3], -lr, lsr #10
    } else if (str[i] >= 'a' && str[i] <= 'f') {
    2118:	06130521 	ldreq	r0, [r3], -r1, lsr #10
    211c:	03052001 	movweq	r2, #20481	@ 0x5001
      value = str[i] - 'a' + 10;
    2120:	0f052f06 	svceq	0x00052f06
    hex |= value;
    2124:	03050106 	movweq	r0, #20742	@ 0x5106
  for (uint32_t i = 0; str[i] != '\0'; i++) {
    2128:	0a052206 	beq	14a948 <__ROM_SIZE__+0x10a948>
    212c:	01050106 	tsteq	r5, r6, lsl #2
    if (str[i] >= '0' && str[i] <= '9') {
    2130:	06050521 	streq	r0, [r5], -r1, lsr #10
    2134:	06207803 	strteq	r7, [r0], -r3, lsl #16
      value = str[i] - '0';
    2138:	2f062020 	svccs	0x00062020
    } else if (str[i] >= 'A' && str[i] <= 'F') {
    213c:	01060c05 	tsteq	r6, r5, lsl #24
    2140:	03062605 	movweq	r2, #26117	@ 0x6605
    2144:	01066609 	tsteq	r6, r9, lsl #12
      value = str[i] - 'A' + 10;
    2148:	2f060305 	svccs	0x00060305
  selected_mode = mode;
    214c:	01060605 	tsteq	r6, r5, lsl #12
  if (selected_mode == NONE) {
    2150:	33060305 	movwcc	r0, #25349	@ 0x6305
  out_buf_rgn.addr = addr;
    2154:	01061305 	tsteq	r6, r5, lsl #6
  out_buf_rgn.size = size / 2;
    2158:	03052e20 	movweq	r2, #24096	@ 0x5e20
  out_buf_rgn.curr_index = 0;
    215c:	15052106 	strne	r2, [r5, #-262]	@ 0xfffffefa
  inp_buf_rgn.addr = addr + size / 2;
    2160:	05200106 	streq	r0, [r0, #-262]!	@ 0xfffffefa
  inp_buf_rgn.curr_index = 0;
    2164:	053e0603 	ldreq	r0, [lr, #-1539]!	@ 0xfffff9fd
  if (!(selected_mode & INP)) {
    2168:	11050108 	tstne	r5, r8, lsl #2
    out_buf_rgn.size = size;
    216c:	03050106 	movweq	r0, #20742	@ 0x5106
  memset(addr, 0, size);
    2170:	05052020 	streq	r2, [r5, #-32]	@ 0xffffffe0
    2174:	01790306 	cmneq	r9, r6, lsl #6
  } else if (!(selected_mode & OUT)) {
    2178:	06202006 	strteq	r2, [r0], -r6
    217c:	060c052f 	streq	r0, [ip], -pc, lsr #10
    inp_buf_rgn.addr = addr;
    2180:	00050501 	andeq	r0, r5, r1, lsl #10
    inp_buf_rgn.size = size;
    2184:	06030402 	streq	r0, [r3], -r2, lsl #8
    2188:	000a0543 	andeq	r0, sl, r3, asr #10
  if (!(selected_mode & INP)) {
    218c:	06030402 	streq	r0, [r3], -r2, lsl #8
    2190:	00050501 	andeq	r0, r5, r1, lsl #10
    2194:	06030402 	streq	r0, [r3], -r2, lsl #8
  if (inp_buf_rgn.addr[inp_buf_rgn.curr_index] == 0) {
    2198:	04020021 	streq	r0, [r2], #-33	@ 0xffffffdf
    219c:	0a054c03 	beq	1551b0 <__ROM_SIZE__+0x1151b0>
  int val = inp_buf_rgn.addr[inp_buf_rgn.curr_index];
    21a0:	03040200 	movweq	r0, #16896	@ 0x4200
  inp_buf_rgn.addr[inp_buf_rgn.curr_index] = 0;
    21a4:	2f050106 	svccs	0x00050106
  inp_buf_rgn.curr_index++;
    21a8:	03040200 	movweq	r0, #16896	@ 0x4200
    21ac:	24051c06 	strcs	r1, [r5], #-3078	@ 0xfffff3fa
  if (inp_buf_rgn.curr_index == inp_buf_rgn.size) {
    21b0:	01040200 	mrseq	r0, R12_usr
}
    21b4:	04020020 	streq	r0, [r2], #-32	@ 0xffffffe0
    inp_buf_rgn.curr_index = 0;
    21b8:	052e0601 	streq	r0, [lr, #-1537]!	@ 0xfffff9ff
    return -1;
    21bc:	0105190a 	tsteq	r5, sl, lsl #18
    21c0:	065c0621 	ldrbeq	r0, [ip], -r1, lsr #12
    return -1;
    21c4:	06030501 	streq	r0, [r3], -r1, lsl #10
    21c8:	0606052f 	streq	r0, [r6], -pc, lsr #10
  if (!(selected_mode & OUT) || c == 0) {
    21cc:	06030501 	streq	r0, [r3], -r1, lsl #10
    21d0:	06130532 			@ <UNDEFINED> instruction: 0x06130532
    21d4:	052e2001 	streq	r2, [lr, #-1]!
  out_buf_rgn.addr[out_buf_rgn.curr_index] = (uint8_t) c;
    21d8:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
    21dc:	20010616 	andcs	r0, r1, r6, lsl r6
  out_buf_rgn.curr_index++;
    21e0:	3d060305 	stccc	3, cr0, [r6, #-20]	@ 0xffffffec
  if (out_buf_rgn.curr_index == out_buf_rgn.size) {
    21e4:	01061605 	tsteq	r6, r5, lsl #12
    21e8:	06030520 	streq	r0, [r3], -r0, lsr #10
    out_buf_rgn.curr_index = 0;
    21ec:	06060530 			@ <UNDEFINED> instruction: 0x06060530
    21f0:	06030501 	streq	r0, [r3], -r1, lsl #10
    21f4:	06060533 			@ <UNDEFINED> instruction: 0x06060533
size_t strlen(const char *str) {
    21f8:	06030501 	streq	r0, [r3], -r1, lsl #10
  while (str[len]) {
    21fc:	060c0533 			@ <UNDEFINED> instruction: 0x060c0533
    2200:	06030501 	streq	r0, [r3], -r1, lsl #10
    2204:	061a0521 	ldreq	r0, [sl], -r1, lsr #10
  while (*str1 && (*str1 == *str2)) {
    2208:	2e080501 	cfsh32cs	mvfx0, mvfx8, #1
    str2++;
    220c:	21060305 	tstcs	r6, r5, lsl #6
  while (*str1 && (*str1 == *str2)) {
    2210:	01061305 	tsteq	r6, r5, lsl #6
    2214:	053c1c05 	ldreq	r1, [ip, #-3077]!	@ 0xfffff3fb
  return *str1 - *str2;
    2218:	03052008 	movweq	r2, #20488	@ 0x5008
}
    221c:	0f052f06 	svceq	0x00052f06
    *(str1++) = *(str2++);
    2220:	03050106 	movweq	r0, #20742	@ 0x5106
    2224:	0a052206 	beq	14aa44 <__ROM_SIZE__+0x10aa44>
  while (*str2) {
    2228:	01050106 	tsteq	r5, r6, lsl #2
  *str1 = '\0';
    222c:	06050524 	streq	r0, [r5], -r4, lsr #10
}
    2230:	06206e03 	strteq	r6, [r0], -r3, lsl #28
  for (i = 0; i < size; i++) {
    2234:	242f0620 	strtcs	r0, [pc], #-1568	@ 223c <memcpy+0xa>
    dest_char[i] = src_char[i];
    2238:	2f062006 	svccs	0x00062006
    223c:	0a030305 	beq	c2e58 <__ROM_SIZE__+0x82e58>
  for (i = 0; i < size; i++) {
    2240:	0a054b01 	beq	154e4c <__ROM_SIZE__+0x114e4c>
}
    2244:	01050106 	tsteq	r5, r6, lsl #2
  for (i = 0; i < size; i++) {
    2248:	01069406 	tsteq	r6, r6, lsl #8
    dest_char[i] = val;
    224c:	2f060305 	svccs	0x00060305
  for (i = 0; i < size; i++) {
    2250:	01060605 	tsteq	r6, r5, lsl #12
}
    2254:	32060305 	andcc	r0, r6, #335544320	@ 0x14000000
    2258:	01061305 	tsteq	r6, r5, lsl #6
    225c:	03052e20 	movweq	r2, #24096	@ 0x5e20
    2260:	16052106 	strne	r2, [r5], -r6, lsl #2
    2264:	05200106 	streq	r0, [r0, #-262]!	@ 0xfffffefa
    2268:	053e0603 	ldreq	r0, [lr, #-1539]!	@ 0xfffff9fd
    226c:	05010606 	streq	r0, [r1, #-1542]	@ 0xfffff9fa
    2270:	05330603 	ldreq	r0, [r3, #-1539]!	@ 0xfffff9fd
    2274:	0501060c 	streq	r0, [r1, #-1548]	@ 0xfffff9f4
    2278:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
    227c:	0501061c 	streq	r0, [r1, #-1564]	@ 0xfffff9e4
    2280:	06210603 	strteq	r0, [r1], -r3, lsl #12
    2284:	2f062e2e 	svccs	0x00062e2e
    2288:	01060a05 	tsteq	r6, r5, lsl #20
    228c:	05250105 	streq	r0, [r5, #-261]!	@ 0xfffffefb
    2290:	74030605 	strvc	r0, [r3], #-1541	@ 0xfffff9fb
    2294:	06200620 	strteq	r0, [r0], -r0, lsr #12
    2298:	0303052f 	movweq	r0, #13615	@ 0x352f
    229c:	054b0109 	strbeq	r0, [fp, #-265]	@ 0xfffffef7
    22a0:	0201060a 	andeq	r0, r1, #10485760	@ 0xa00000
    22a4:	01010009 	tsteq	r1, r9
    22a8:	00000ad7 	ldrdeq	r0, [r0], -r7
    22ac:	00dd0003 	sbcseq	r0, sp, r3
    22b0:	01020000 	mrseq	r0, (UNDEF: 2)
    22b4:	000d0efb 	strdeq	r0, [sp], -fp
    22b8:	01010101 	tsteq	r1, r1, lsl #2
    22bc:	01000000 	mrseq	r0, (UNDEF: 0)
    22c0:	2f010000 	svccs	0x00010000
    22c4:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
    22c8:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
    22cc:	63652f66 	cmnvs	r5, #408	@ 0x198
    22d0:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
    22d4:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
    22d8:	732f7265 			@ <UNDEFINED> instruction: 0x732f7265
    22dc:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
    22e0:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
    22e4:	6e69742f 	cdpvs	4, 6, cr7, cr9, cr15, {1}
    22e8:	65612d79 	strbvs	r2, [r1, #-3449]!	@ 0xfffff287
    22ec:	6f2f0073 	svcvs	0x002f0073
    22f0:	672f7470 			@ <UNDEFINED> instruction: 0x672f7470
    22f4:	612d6363 			@ <UNDEFINED> instruction: 0x612d6363
    22f8:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
    22fc:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	@ 0xfffffe44
    2300:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
    2304:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
    2308:	6363672f 	cmnvs	r3, #12320768	@ 0xbc0000
    230c:	6d72612f 	ldfvse	f6, [r2, #-188]!	@ 0xffffff44
    2310:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
    2314:	61652d65 	cmnvs	r5, r5, ror #26
    2318:	312f6962 			@ <UNDEFINED> instruction: 0x312f6962
    231c:	2e322e32 	mrccs	14, 1, r2, cr2, cr2, {1}
    2320:	6e692f31 	mcrvs	15, 3, r2, cr9, cr1, {1}
    2324:	64756c63 	ldrbtvs	r6, [r5], #-3171	@ 0xfffff39d
    2328:	682f0065 	stmdavs	pc!, {r0, r2, r5, r6}	@ <UNPREDICTABLE>
    232c:	2f656d6f 	svccs	0x00656d6f
    2330:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    2334:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
    2338:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
    233c:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
    2340:	68732f72 	ldmdavs	r3!, {r1, r4, r5, r6, r8, r9, sl, fp, sp}^
    2344:	2f6c6c65 	svccs	0x006c6c65
    2348:	2f62696c 	svccs	0x0062696c
    234c:	69727473 	ldmdbvs	r2!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
    2350:	0000676e 	andeq	r6, r0, lr, ror #14
    2354:	2e736561 	cdpcs	5, 7, cr6, cr3, cr1, {3}
    2358:	00010063 	andeq	r0, r1, r3, rrx
    235c:	64747300 	ldrbtvs	r7, [r4], #-768	@ 0xfffffd00
    2360:	2e666564 	cdpcs	5, 6, cr6, cr6, cr4, {3}
    2364:	00020068 	andeq	r0, r2, r8, rrx
    2368:	64747300 	ldrbtvs	r7, [r4], #-768	@ 0xfffffd00
    236c:	2d746e69 	ldclcs	14, cr6, [r4, #-420]!	@ 0xfffffe5c
    2370:	2e636367 	cdpcs	3, 6, cr6, cr3, cr7, {3}
    2374:	00020068 	andeq	r0, r2, r8, rrx
    2378:	73656100 	cmnvc	r5, #0, 2
    237c:	0100682e 	tsteq	r0, lr, lsr #16
    2380:	74730000 	ldrbtvc	r0, [r3], #-0
    2384:	676e6972 			@ <UNDEFINED> instruction: 0x676e6972
    2388:	0300682e 	movweq	r6, #2094	@ 0x82e
    238c:	05000000 	streq	r0, [r0, #-0]
    2390:	02050001 	andeq	r0, r5, #1
    2394:	000015a0 	andeq	r1, r0, r0, lsr #11
    2398:	01019203 	tsteq	r1, r3, lsl #4
    239c:	03050106 	movweq	r0, #20742	@ 0x5106
    23a0:	15132f06 	ldrne	r2, [r3, #-3846]	@ 0xfffff0fa
    23a4:	01060a05 	tsteq	r6, r5, lsl #20
    23a8:	05200305 	streq	r0, [r0, #-773]!	@ 0xfffffcfb
    23ac:	04020005 	streq	r0, [r2], #-5
    23b0:	05220603 	streq	r0, [r2, #-1539]!	@ 0xfffff9fd
    23b4:	04020024 	streq	r0, [r2], #-36	@ 0xffffffdc
    23b8:	05010603 	streq	r0, [r1, #-1539]	@ 0xfffff9fd
    23bc:	04020020 	streq	r0, [r2], #-32	@ 0xffffffe0
    23c0:	1b052003 	blne	14a3d4 <__ROM_SIZE__+0x10a3d4>
    23c4:	03040200 	movweq	r0, #16896	@ 0x4200
    23c8:	0005052e 	andeq	r0, r5, lr, lsr #10
    23cc:	06030402 	streq	r0, [r3], -r2, lsl #8
    23d0:	0020052f 	eoreq	r0, r0, pc, lsr #10
    23d4:	06030402 	streq	r0, [r3], -r2, lsl #8
    23d8:	001b0501 	andseq	r0, fp, r1, lsl #10
    23dc:	3c030402 	cfstrscc	mvf0, [r3], {2}
    23e0:	02000505 	andeq	r0, r0, #20971520	@ 0x1400000
    23e4:	2f060304 	svccs	0x00060304
    23e8:	02002005 	andeq	r2, r0, #5
    23ec:	01060304 	tsteq	r6, r4, lsl #6
    23f0:	02001b05 	andeq	r1, r0, #5120	@ 0x1400
    23f4:	053c0304 	ldreq	r0, [ip, #-772]!	@ 0xfffffcfc
    23f8:	04020005 	streq	r0, [r2], #-5
    23fc:	052f0603 	streq	r0, [pc, #-1539]!	@ 1e01 <gf2field_inv+0x6d>
    2400:	04020020 	streq	r0, [r2], #-32	@ 0xffffffe0
    2404:	05010603 	streq	r0, [r1, #-1539]	@ 0xfffff9fd
    2408:	0402001b 	streq	r0, [r2], #-27	@ 0xffffffe5
    240c:	17052e03 	strne	r2, [r5, -r3, lsl #28]
    2410:	03040200 	movweq	r0, #16896	@ 0x4200
    2414:	11051b06 	tstne	r5, r6, lsl #22
    2418:	01040200 	mrseq	r0, R12_usr
    241c:	060a0520 	streq	r0, [sl], -r0, lsr #10
    2420:	052e0903 	streq	r0, [lr, #-2307]!	@ 0xfffff6fd
    2424:	04020005 	streq	r0, [r2], #-5
    2428:	32030602 	andcc	r0, r3, #2097152	@ 0x200000
    242c:	0007052e 	andeq	r0, r7, lr, lsr #10
    2430:	06020402 	streq	r0, [r2], -r2, lsl #8
    2434:	00100501 	andseq	r0, r0, r1, lsl #10
    2438:	06020402 	streq	r0, [r2], -r2, lsl #8
    243c:	00150520 	andseq	r0, r5, r0, lsr #10
    2440:	06020402 	streq	r0, [r2], -r2, lsl #8
    2444:	00050501 	andeq	r0, r5, r1, lsl #10
    2448:	06020402 	streq	r0, [r2], -r2, lsl #8
    244c:	001f0521 	andseq	r0, pc, r1, lsr #10
    2450:	06020402 	streq	r0, [r2], -r2, lsl #8
    2454:	002e0501 	eoreq	r0, lr, r1, lsl #10
    2458:	2e020402 	cdpcs	4, 0, cr0, cr2, cr2, {0}
    245c:	02001505 	andeq	r1, r0, #20971520	@ 0x1400000
    2460:	052e0204 	streq	r0, [lr, #-516]!	@ 0xfffffdfc
    2464:	04020005 	streq	r0, [r2], #-5
    2468:	054b0602 	strbeq	r0, [fp, #-1538]	@ 0xfffff9fe
    246c:	0402001f 	streq	r0, [r2], #-31	@ 0xffffffe1
    2470:	00010602 	andeq	r0, r1, r2, lsl #12
    2474:	2e020402 	cdpcs	4, 0, cr0, cr2, cr2, {0}
    2478:	02002e05 	andeq	r2, r0, #5, 28	@ 0x50
    247c:	052e0204 	streq	r0, [lr, #-516]!	@ 0xfffffdfc
    2480:	0402000d 	streq	r0, [r2], #-13
    2484:	15052e02 	strne	r2, [r5, #-3586]	@ 0xfffff1fe
    2488:	02040200 	andeq	r0, r4, #0, 4
    248c:	00050520 	andeq	r0, r5, r0, lsr #10
    2490:	06020402 	streq	r0, [r2], -r2, lsl #8
    2494:	001f054b 	andseq	r0, pc, fp, asr #10
    2498:	06020402 	streq	r0, [r2], -r2, lsl #8
    249c:	002e0501 	eoreq	r0, lr, r1, lsl #10
    24a0:	2e020402 	cdpcs	4, 0, cr0, cr2, cr2, {0}
    24a4:	02000d05 	andeq	r0, r0, #320	@ 0x140
    24a8:	052e0204 	streq	r0, [lr, #-516]!	@ 0xfffffdfc
    24ac:	04020015 	streq	r0, [r2], #-21	@ 0xffffffeb
    24b0:	05052002 	streq	r2, [r5, #-2]
    24b4:	02040200 	andeq	r0, r4, #0, 4
    24b8:	1f054b06 	svcne	0x00054b06
    24bc:	02040200 	andeq	r0, r4, #0, 4
    24c0:	2e050106 	adfcss	f0, f5, f6
    24c4:	02040200 	andeq	r0, r4, #0, 4
    24c8:	000d0520 	andeq	r0, sp, r0, lsr #10
    24cc:	2e020402 	cdpcs	4, 0, cr0, cr2, cr2, {0}
    24d0:	02001505 	andeq	r1, r0, #20971520	@ 0x1400000
    24d4:	05200204 	streq	r0, [r0, #-516]!	@ 0xfffffdfc
    24d8:	04020023 	streq	r0, [r2], #-35	@ 0xffffffdd
    24dc:	4a030602 	bmi	c3cec <__ROM_SIZE__+0x83cec>
    24e0:	0012052e 	andseq	r0, r2, lr, lsr #10
    24e4:	20010402 	andcs	r0, r1, r2, lsl #8
    24e8:	05310705 	ldreq	r0, [r1, #-1797]!	@ 0xfffff8fb
    24ec:	0501060e 	streq	r0, [r1, #-1550]	@ 0xfffff9f2
    24f0:	05210607 	streq	r0, [r1, #-1543]!	@ 0xfffff9f9
    24f4:	05010618 	streq	r0, [r1, #-1560]	@ 0xfffff9e8
    24f8:	07052e0f 	streq	r2, [r5, -pc, lsl #28]
    24fc:	18052f06 	stmdane	r5, {r1, r2, r8, r9, sl, fp, sp}
    2500:	052e0106 	streq	r0, [lr, #-262]!	@ 0xfffffefa
    2504:	0705200f 	streq	r2, [r5, -pc]
    2508:	18052f06 	stmdane	r5, {r1, r2, r8, r9, sl, fp, sp}
    250c:	0f050106 	svceq	0x00050106
    2510:	0607052e 	streq	r0, [r7], -lr, lsr #10
    2514:	0618052f 	ldreq	r0, [r8], -pc, lsr #10
    2518:	2e0f0501 	cfsh32cs	mvfx0, mvfx15, #1
    251c:	32060505 	andcc	r0, r6, #20971520	@ 0x1400000
    2520:	01060805 	tsteq	r6, r5, lsl #16
    2524:	43060905 	movwmi	r0, #26885	@ 0x6905
    2528:	06120513 			@ <UNDEFINED> instruction: 0x06120513
    252c:	06090501 	streq	r0, [r9], -r1, lsl #10
    2530:	0612052f 	ldreq	r0, [r2], -pc, lsr #10
    2534:	06090501 	streq	r0, [r9], -r1, lsl #10
    2538:	0612052f 	ldreq	r0, [r2], -pc, lsr #10
    253c:	06090501 	streq	r0, [r9], -r1, lsl #10
    2540:	0612052f 	ldreq	r0, [r2], -pc, lsr #10
    2544:	06090501 	streq	r0, [r9], -r1, lsl #10
    2548:	06140536 			@ <UNDEFINED> instruction: 0x06140536
    254c:	2e120501 	cfmul32cs	mvfx0, mvfx2, mvfx1
    2550:	2f060905 	svccs	0x00060905
    2554:	01061405 	tsteq	r6, r5, lsl #8
    2558:	052e1205 	streq	r1, [lr, #-517]!	@ 0xfffffdfb
    255c:	052f0609 	streq	r0, [pc, #-1545]!	@ 1f5b <gf2point_add+0x99>
    2560:	05010614 	streq	r0, [r1, #-1556]	@ 0xfffff9ec
    2564:	09052e12 	stmdbeq	r5, {r1, r4, r9, sl, fp, sp}
    2568:	14052f06 	strne	r2, [r5], #-3846	@ 0xfffff0fa
    256c:	12050106 	andne	r0, r5, #-2147483647	@ 0x80000001
    2570:	06070520 	streq	r0, [r7], -r0, lsr #10
    2574:	06210531 			@ <UNDEFINED> instruction: 0x06210531
    2578:	4a100501 	bmi	403984 <__ROM_SIZE__+0x3c3984>
    257c:	14030105 	strne	r0, [r3], #-261	@ 0xfffffefb
    2580:	0500064a 	streq	r0, [r0, #-1610]	@ 0xfffff9b6
    2584:	00169402 	andseq	r9, r6, r2, lsl #8
    2588:	01150300 	tsteq	r5, r0, lsl #6
    258c:	03050106 	movweq	r0, #20742	@ 0x5106
    2590:	05132106 	ldreq	r2, [r3, #-262]	@ 0xfffffefa
    2594:	0501060a 	streq	r0, [r1, #-1546]	@ 0xfffff9f6
    2598:	07052003 	streq	r2, [r5, -r3]
    259c:	03040200 	movweq	r0, #16896	@ 0x4200
    25a0:	12052406 	andne	r2, r5, #100663296	@ 0x6000000
    25a4:	03040200 	movweq	r0, #16896	@ 0x4200
    25a8:	33050106 	movwcc	r0, #20742	@ 0x5106
    25ac:	03040200 	movweq	r0, #16896	@ 0x4200
    25b0:	003e054a 	eorseq	r0, lr, sl, asr #10
    25b4:	2e030402 	cdpcs	4, 0, cr0, cr3, cr2, {0}
    25b8:	02002105 	andeq	r2, r0, #1073741825	@ 0x40000001
    25bc:	052e0304 	streq	r0, [lr, #-772]!	@ 0xfffffcfc
    25c0:	04020016 	streq	r0, [r2], #-22	@ 0xffffffea
    25c4:	18052e03 	stmdane	r5, {r0, r1, r9, sl, fp, sp}
    25c8:	03040200 	movweq	r0, #16896	@ 0x4200
    25cc:	02004806 	andeq	r4, r0, #393216	@ 0x60000
    25d0:	20060304 	andcs	r0, r6, r4, lsl #6
    25d4:	02001305 	andeq	r1, r0, #335544320	@ 0x14000000
    25d8:	20060104 	andcs	r0, r6, r4, lsl #2
    25dc:	02001605 	andeq	r1, r0, #5242880	@ 0x500000
    25e0:	002c0204 	eoreq	r0, ip, r4, lsl #4
    25e4:	06020402 	streq	r0, [r2], -r2, lsl #8
    25e8:	00110520 	andseq	r0, r1, r0, lsr #10
    25ec:	06010402 	streq	r0, [r1], -r2, lsl #8
    25f0:	060c0520 	streq	r0, [ip], -r0, lsr #10
    25f4:	33010530 	movwcc	r0, #5424	@ 0x1530
    25f8:	05000620 	streq	r0, [r0, #-1568]	@ 0xfffff9e0
    25fc:	0016cc02 	andseq	ip, r6, r2, lsl #24
    2600:	03051700 	movweq	r1, #22272	@ 0x5700
    2604:	0a051313 	beq	147258 <__ROM_SIZE__+0x107258>
    2608:	11050106 	tstne	r5, r6, lsl #2
    260c:	0c052006 	stceq	0, cr2, [r5], {6}
    2610:	13053006 	movwne	r3, #20486	@ 0x5006
    2614:	01052006 	tsteq	r5, r6
    2618:	07052a06 	streq	r2, [r5, -r6, lsl #20]
    261c:	03040200 	movweq	r0, #16896	@ 0x4200
    2620:	18052606 	stmdane	r5, {r1, r2, r9, sl, sp}
    2624:	03040200 	movweq	r0, #16896	@ 0x4200
    2628:	16050106 	strne	r0, [r5], -r6, lsl #2
    262c:	03040200 	movweq	r0, #16896	@ 0x4200
    2630:	00180574 	andseq	r0, r8, r4, ror r5
    2634:	06030402 	streq	r0, [r3], -r2, lsl #8
    2638:	0402002c 	streq	r0, [r2], #-44	@ 0xffffffd4
    263c:	05200603 	streq	r0, [r0, #-1539]!	@ 0xfffff9fd
    2640:	04020013 	streq	r0, [r2], #-19	@ 0xffffffed
    2644:	05200601 	streq	r0, [r0, #-1537]!	@ 0xfffff9ff
    2648:	04020016 	streq	r0, [r2], #-22	@ 0xffffffea
    264c:	02002c02 	andeq	r2, r0, #512	@ 0x200
    2650:	20060204 	andcs	r0, r6, r4, lsl #4
    2654:	02001105 	andeq	r1, r0, #1073741825	@ 0x40000001
    2658:	20060204 	andcs	r0, r6, r4, lsl #4
    265c:	30060c05 	andcc	r0, r6, r5, lsl #24
    2660:	25010520 	strcs	r0, [r1, #-1312]	@ 0xfffffae0
    2664:	03061605 	movweq	r1, #26117	@ 0x6605
    2668:	20062e79 	andcs	r2, r6, r9, ror lr
    266c:	01052020 	tsteq	r5, r0, lsr #32
    2670:	3c0d0306 	stccc	3, cr0, [sp], {6}
    2674:	15130305 	ldrne	r0, [r3, #-773]	@ 0xfffffcfb
    2678:	01061205 	tsteq	r6, r5, lsl #4
    267c:	21060305 	tstcs	r6, r5, lsl #6
    2680:	01061f05 	tsteq	r6, r5, lsl #30
    2684:	05201205 	streq	r1, [r0, #-517]!	@ 0xfffffdfb
    2688:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
    268c:	0501061f 	streq	r0, [r1, #-1567]	@ 0xfffff9e1
    2690:	03052012 	movweq	r2, #20498	@ 0x5012
    2694:	1f052106 	svcne	0x00052106
    2698:	12050106 	andne	r0, r5, #-2147483647	@ 0x80000001
    269c:	06030520 	streq	r0, [r3], -r0, lsr #10
    26a0:	06120521 	ldreq	r0, [r2], -r1, lsr #10
    26a4:	06030501 	streq	r0, [r3], -r1, lsl #10
    26a8:	06120523 	ldreq	r0, [r2], -r3, lsr #10
    26ac:	06030501 	streq	r0, [r3], -r1, lsl #10
    26b0:	061f0521 	ldreq	r0, [pc], -r1, lsr #10
    26b4:	20120501 	andscs	r0, r2, r1, lsl #10
    26b8:	21060305 	tstcs	r6, r5, lsl #6
    26bc:	01061205 	tsteq	r6, r5, lsl #4
    26c0:	22060305 	andcs	r0, r6, #335544320	@ 0x14000000
    26c4:	01061205 	tsteq	r6, r5, lsl #4
    26c8:	21060305 	tstcs	r6, r5, lsl #6
    26cc:	01061f05 	tsteq	r6, r5, lsl #30
    26d0:	05201205 	streq	r1, [r0, #-517]!	@ 0xfffffdfb
    26d4:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
    26d8:	05010612 	streq	r0, [r1, #-1554]	@ 0xfffff9ee
    26dc:	05230603 	streq	r0, [r3, #-1539]!	@ 0xfffff9fd
    26e0:	05010612 	streq	r0, [r1, #-1554]	@ 0xfffff9ee
    26e4:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
    26e8:	0501061f 	streq	r0, [r1, #-1567]	@ 0xfffff9e1
    26ec:	03052012 	movweq	r2, #20498	@ 0x5012
    26f0:	1f052106 	svcne	0x00052106
    26f4:	12050106 	andne	r0, r5, #-2147483647	@ 0x80000001
    26f8:	06030520 	streq	r0, [r3], -r0, lsr #10
    26fc:	061f0521 	ldreq	r0, [pc], -r1, lsr #10
    2700:	20120501 	andscs	r0, r2, r1, lsl #10
    2704:	21060305 	tstcs	r6, r5, lsl #6
    2708:	01061205 	tsteq	r6, r5, lsl #4
    270c:	06210105 	strteq	r0, [r1], -r5, lsl #2
    2710:	13030523 	movwne	r0, #13603	@ 0x3523
    2714:	01061205 	tsteq	r6, r5, lsl #4
    2718:	06750105 	ldrbteq	r0, [r5], -r5, lsl #2
    271c:	05010632 	streq	r0, [r1, #-1586]	@ 0xfffff9ce
    2720:	133d0603 	teqne	sp, #3145728	@ 0x300000
    2724:	060a0513 			@ <UNDEFINED> instruction: 0x060a0513
    2728:	20030501 	andcs	r0, r3, r1, lsl #10
    272c:	02000505 	andeq	r0, r0, #20971520	@ 0x1400000
    2730:	22060304 	andcs	r0, r6, #4, 6	@ 0x10000000
    2734:	02000905 	andeq	r0, r0, #81920	@ 0x14000
    2738:	01060304 	tsteq	r6, r4, lsl #6
    273c:	02000505 	andeq	r0, r0, #20971520	@ 0x1400000
    2740:	2f060304 	svccs	0x00060304
    2744:	02002705 	andeq	r2, r0, #1310720	@ 0x140000
    2748:	01060304 	tsteq	r6, r4, lsl #6
    274c:	02000905 	andeq	r0, r0, #81920	@ 0x14000
    2750:	054a0304 	strbeq	r0, [sl, #-772]	@ 0xfffffcfc
    2754:	04020038 	streq	r0, [r2], #-56	@ 0xffffffc8
    2758:	49052e03 	stmdbmi	r5, {r0, r1, r9, sl, fp, sp}
    275c:	03040200 	movweq	r0, #16896	@ 0x4200
    2760:	0009052e 	andeq	r0, r9, lr, lsr #10
    2764:	20030402 	andcs	r0, r3, r2, lsl #8
    2768:	02000505 	andeq	r0, r0, #20971520	@ 0x1400000
    276c:	3d060304 	stccc	3, cr0, [r6, #-16]
    2770:	02002d05 	andeq	r2, r0, #320	@ 0x140
    2774:	05010304 	streq	r0, [r1, #-772]	@ 0xfffffcfc
    2778:	04020032 	streq	r0, [r2], #-50	@ 0xffffffce
    277c:	05010603 	streq	r0, [r1, #-1539]	@ 0xfffff9fd
    2780:	0402003e 	streq	r0, [r2], #-62	@ 0xffffffc2
    2784:	052e0603 	streq	r0, [lr, #-1539]!	@ 0xfffff9fd
    2788:	0402004d 	streq	r0, [r2], #-77	@ 0xffffffb3
    278c:	00010603 	andeq	r0, r1, r3, lsl #12
    2790:	20030402 	andcs	r0, r3, r2, lsl #8
    2794:	02000505 	andeq	r0, r0, #20971520	@ 0x1400000
    2798:	4b060304 	blmi	1833b0 <__ROM_SIZE__+0x1433b0>
    279c:	02002d05 	andeq	r2, r0, #320	@ 0x140
    27a0:	05010304 	streq	r0, [r1, #-772]	@ 0xfffffcfc
    27a4:	04020032 	streq	r0, [r2], #-50	@ 0xffffffce
    27a8:	00010603 	andeq	r0, r1, r3, lsl #12
    27ac:	2e030402 	cdpcs	4, 0, cr0, cr3, cr2, {0}
    27b0:	02003e05 	andeq	r3, r0, #5, 28	@ 0x50
    27b4:	2e060304 	cdpcs	3, 0, cr0, cr6, cr4, {0}
    27b8:	02004d05 	andeq	r4, r0, #320	@ 0x140
    27bc:	01060304 	tsteq	r6, r4, lsl #6
    27c0:	03040200 	movweq	r0, #16896	@ 0x4200
    27c4:	00050520 	andeq	r0, r5, r0, lsr #10
    27c8:	06030402 	streq	r0, [r3], -r2, lsl #8
    27cc:	002d054b 	eoreq	r0, sp, fp, asr #10
    27d0:	01030402 	tsteq	r3, r2, lsl #8
    27d4:	02003205 	andeq	r3, r0, #1342177280	@ 0x50000000
    27d8:	01060304 	tsteq	r6, r4, lsl #6
    27dc:	03040200 	movweq	r0, #16896	@ 0x4200
    27e0:	003e052e 	eorseq	r0, lr, lr, lsr #10
    27e4:	06030402 	streq	r0, [r3], -r2, lsl #8
    27e8:	004d052e 	subeq	r0, sp, lr, lsr #10
    27ec:	06030402 	streq	r0, [r3], -r2, lsl #8
    27f0:	04020001 	streq	r0, [r2], #-1
    27f4:	05052003 	streq	r2, [r5, #-3]
    27f8:	03040200 	movweq	r0, #16896	@ 0x4200
    27fc:	2d054b06 	vstrcs	d4, [r5, #-24]	@ 0xffffffe8
    2800:	03040200 	movweq	r0, #16896	@ 0x4200
    2804:	00320501 	eorseq	r0, r2, r1, lsl #10
    2808:	06030402 	streq	r0, [r3], -r2, lsl #8
    280c:	04020001 	streq	r0, [r2], #-1
    2810:	3e052e03 	cdpcc	14, 0, cr2, cr5, cr3, {0}
    2814:	03040200 	movweq	r0, #16896	@ 0x4200
    2818:	4d052e06 	stcmi	14, cr2, [r5, #-24]	@ 0xffffffe8
    281c:	03040200 	movweq	r0, #16896	@ 0x4200
    2820:	02000106 	andeq	r0, r0, #-2147483647	@ 0x80000001
    2824:	054a0304 	strbeq	r0, [sl, #-772]	@ 0xfffffcfc
    2828:	04020016 	streq	r0, [r2], #-22	@ 0xffffffea
    282c:	79030603 	stmdbvc	r3, {r0, r1, r9, sl}
    2830:	04020020 	streq	r0, [r2], #-32	@ 0xffffffe0
    2834:	05200603 	streq	r0, [r0, #-1539]!	@ 0xfffff9fd
    2838:	04020011 	streq	r0, [r2], #-17	@ 0xffffffef
    283c:	05200601 	streq	r0, [r0, #-1537]!	@ 0xfffff9ff
    2840:	09030601 	stmdbeq	r3, {r0, r9, sl}
    2844:	00062e2e 	andeq	r2, r6, lr, lsr #28
    2848:	17ca0205 	strbne	r0, [sl, r5, lsl #4]
    284c:	26030000 	strcs	r0, [r3], -r0
    2850:	05010601 	streq	r0, [r1, #-1537]	@ 0xfffff9ff
    2854:	134b0603 	movtne	r0, #46595	@ 0xb603
    2858:	060a0513 			@ <UNDEFINED> instruction: 0x060a0513
    285c:	20030501 	andcs	r0, r3, r1, lsl #10
    2860:	02000505 	andeq	r0, r0, #20971520	@ 0x1400000
    2864:	22060304 	andcs	r0, r6, #4, 6	@ 0x10000000
    2868:	02000705 	andeq	r0, r0, #1310720	@ 0x140000
    286c:	01060304 	tsteq	r6, r4, lsl #6
    2870:	02000505 	andeq	r0, r0, #20971520	@ 0x1400000
    2874:	3d060304 	stccc	3, cr0, [r6, #-16]
    2878:	02000705 	andeq	r0, r0, #1310720	@ 0x140000
    287c:	01060304 	tsteq	r6, r4, lsl #6
    2880:	02000505 	andeq	r0, r0, #20971520	@ 0x1400000
    2884:	4b060304 	blmi	18349c <__ROM_SIZE__+0x14349c>
    2888:	02000705 	andeq	r0, r0, #1310720	@ 0x140000
    288c:	01060304 	tsteq	r6, r4, lsl #6
    2890:	02000505 	andeq	r0, r0, #20971520	@ 0x1400000
    2894:	2f060304 	svccs	0x00060304
    2898:	02000705 	andeq	r0, r0, #1310720	@ 0x140000
    289c:	01060304 	tsteq	r6, r4, lsl #6
    28a0:	02000505 	andeq	r0, r0, #20971520	@ 0x1400000
    28a4:	30060304 	andcc	r0, r6, r4, lsl #6
    28a8:	02001605 	andeq	r1, r0, #5242880	@ 0x500000
    28ac:	01060304 	tsteq	r6, r4, lsl #6
    28b0:	02002a05 	andeq	r2, r0, #20480	@ 0x5000
    28b4:	059e0304 	ldreq	r0, [lr, #772]	@ 0x304
    28b8:	0402003e 	streq	r0, [r2], #-62	@ 0xffffffc2
    28bc:	52059e03 	andpl	r9, r5, #3, 28	@ 0x30
    28c0:	03040200 	movweq	r0, #16896	@ 0x4200
    28c4:	0016059e 	mulseq	r6, lr, r5
    28c8:	90030402 	andls	r0, r3, r2, lsl #8
    28cc:	02002a05 	andeq	r2, r0, #20480	@ 0x5000
    28d0:	05900304 	ldreq	r0, [r0, #772]	@ 0x304
    28d4:	04020028 	streq	r0, [r2], #-40	@ 0xffffffd8
    28d8:	3e057403 	cdpcc	4, 0, cr7, cr5, cr3, {0}
    28dc:	03040200 	movweq	r0, #16896	@ 0x4200
    28e0:	003c0520 	eorseq	r0, ip, r0, lsr #10
    28e4:	66030402 	strvs	r0, [r3], -r2, lsl #8
    28e8:	02005205 	andeq	r5, r0, #1342177280	@ 0x50000000
    28ec:	05200304 	streq	r0, [r0, #-772]!	@ 0xfffffcfc
    28f0:	04020050 	streq	r0, [r2], #-80	@ 0xffffffb0
    28f4:	14053c03 	strne	r3, [r5], #-3075	@ 0xfffff3fd
    28f8:	03040200 	movweq	r0, #16896	@ 0x4200
    28fc:	00050520 	andeq	r0, r5, r0, lsr #10
    2900:	06030402 	streq	r0, [r3], -r2, lsl #8
    2904:	0016054b 	andseq	r0, r6, fp, asr #10
    2908:	06030402 	streq	r0, [r3], -r2, lsl #8
    290c:	002a0501 	eoreq	r0, sl, r1, lsl #10
    2910:	3c030402 	cfstrscc	mvf0, [r3], {2}
    2914:	02002805 	andeq	r2, r0, #327680	@ 0x50000
    2918:	05820304 	streq	r0, [r2, #772]	@ 0x304
    291c:	0402003e 	streq	r0, [r2], #-62	@ 0xffffffc2
    2920:	3c052003 	stccc	0, cr2, [r5], {3}
    2924:	03040200 	movweq	r0, #16896	@ 0x4200
    2928:	00520574 	subseq	r0, r2, r4, ror r5
    292c:	20030402 	andcs	r0, r3, r2, lsl #8
    2930:	02005005 	andeq	r5, r0, #5
    2934:	05580304 	ldrbeq	r0, [r8, #-772]	@ 0xfffffcfc
    2938:	04020014 	streq	r0, [r2], #-20	@ 0xffffffec
    293c:	05052003 	streq	r2, [r5, #-3]
    2940:	03040200 	movweq	r0, #16896	@ 0x4200
    2944:	16052f06 	strne	r2, [r5], -r6, lsl #30
    2948:	03040200 	movweq	r0, #16896	@ 0x4200
    294c:	2a050106 	bcs	142d6c <__ROM_SIZE__+0x102d6c>
    2950:	03040200 	movweq	r0, #16896	@ 0x4200
    2954:	00280566 	eoreq	r0, r8, r6, ror #10
    2958:	3c030402 	cfstrscc	mvf0, [r3], {2}
    295c:	02003e05 	andeq	r3, r0, #5, 28	@ 0x50
    2960:	05200304 	streq	r0, [r0, #-772]!	@ 0xfffffcfc
    2964:	0402003c 	streq	r0, [r2], #-60	@ 0xffffffc4
    2968:	52056603 	andpl	r6, r5, #3145728	@ 0x300000
    296c:	03040200 	movweq	r0, #16896	@ 0x4200
    2970:	04020020 	streq	r0, [r2], #-32	@ 0xffffffe0
    2974:	50052e03 	andpl	r2, r5, r3, lsl #28
    2978:	03040200 	movweq	r0, #16896	@ 0x4200
    297c:	0014053c 	andseq	r0, r4, ip, lsr r5
    2980:	20030402 	andcs	r0, r3, r2, lsl #8
    2984:	02000505 	andeq	r0, r0, #20971520	@ 0x1400000
    2988:	2f060304 	svccs	0x00060304
    298c:	02001605 	andeq	r1, r0, #5242880	@ 0x500000
    2990:	01060304 	tsteq	r6, r4, lsl #6
    2994:	02002a05 	andeq	r2, r0, #20480	@ 0x5000
    2998:	05580304 	ldrbeq	r0, [r8, #-772]	@ 0xfffffcfc
    299c:	04020028 	streq	r0, [r2], #-40	@ 0xffffffd8
    29a0:	3e056603 	cfmadd32cc	mvax0, mvfx6, mvfx5, mvfx3
    29a4:	03040200 	movweq	r0, #16896	@ 0x4200
    29a8:	003c0520 	eorseq	r0, ip, r0, lsr #10
    29ac:	3c030402 	cfstrscc	mvf0, [r3], {2}
    29b0:	02005205 	andeq	r5, r0, #1342177280	@ 0x50000000
    29b4:	05200304 	streq	r0, [r0, #-772]!	@ 0xfffffcfc
    29b8:	04020050 	streq	r0, [r2], #-80	@ 0xffffffb0
    29bc:	14056603 	strne	r6, [r5], #-1539	@ 0xfffff9fd
    29c0:	03040200 	movweq	r0, #16896	@ 0x4200
    29c4:	00160520 	andseq	r0, r6, r0, lsr #10
    29c8:	06030402 	streq	r0, [r3], -r2, lsl #8
    29cc:	052e7603 	streq	r7, [lr, #-1539]!	@ 0xfffff9fd
    29d0:	04020011 	streq	r0, [r2], #-17	@ 0xffffffef
    29d4:	01052001 	tsteq	r5, r1
    29d8:	3c0c0306 	stccc	3, cr0, [ip], {6}
    29dc:	00062e20 	andeq	r2, r6, r0, lsr #28
    29e0:	19240205 	stmdbne	r4!, {r0, r2, r9}
    29e4:	05180000 	ldreq	r0, [r8, #-0]
    29e8:	05131303 	ldreq	r1, [r3, #-771]	@ 0xfffffcfd
    29ec:	0501060a 	streq	r0, [r1, #-1546]	@ 0xfffff9f6
    29f0:	05200611 	streq	r0, [r0, #-1553]!	@ 0xfffff9ef
    29f4:	0530060c 	ldreq	r0, [r0, #-1548]!	@ 0xfffff9f4
    29f8:	05200613 	streq	r0, [r0, #-1555]!	@ 0xfffff9ed
    29fc:	052a0601 	streq	r0, [sl, #-1537]!	@ 0xfffff9ff
    2a00:	04020007 	streq	r0, [r2], #-7
    2a04:	05260603 	streq	r0, [r6, #-1539]!	@ 0xfffff9fd
    2a08:	04020018 	streq	r0, [r2], #-24	@ 0xffffffe8
    2a0c:	05010603 	streq	r0, [r1, #-1539]	@ 0xfffff9fd
    2a10:	04020016 	streq	r0, [r2], #-22	@ 0xffffffea
    2a14:	18058203 	stmdane	r5, {r0, r1, r9, pc}
    2a18:	03040200 	movweq	r0, #16896	@ 0x4200
    2a1c:	02002c06 	andeq	r2, r0, #1536	@ 0x600
    2a20:	20060304 	andcs	r0, r6, r4, lsl #6
    2a24:	02001305 	andeq	r1, r0, #335544320	@ 0x14000000
    2a28:	20060104 	andcs	r0, r6, r4, lsl #2
    2a2c:	02001605 	andeq	r1, r0, #5242880	@ 0x500000
    2a30:	002c0204 	eoreq	r0, ip, r4, lsl #4
    2a34:	06020402 	streq	r0, [r2], -r2, lsl #8
    2a38:	00110520 	andseq	r0, r1, r0, lsr #10
    2a3c:	06020402 	streq	r0, [r2], -r2, lsl #8
    2a40:	060c0520 	streq	r0, [ip], -r0, lsr #10
    2a44:	01052030 	tsteq	r5, r0, lsr r0
    2a48:	06160525 	ldreq	r0, [r6], -r5, lsr #10
    2a4c:	062e7903 	strteq	r7, [lr], -r3, lsl #18
    2a50:	05202020 	streq	r2, [r0, #-32]!	@ 0xffffffe0
    2a54:	0a030601 	beq	c4260 <__ROM_SIZE__+0x84260>
    2a58:	1303054a 	movwne	r0, #13642	@ 0x354a
    2a5c:	06080515 			@ <UNDEFINED> instruction: 0x06080515
    2a60:	06030501 	streq	r0, [r3], -r1, lsl #10
    2a64:	061f0521 	ldreq	r0, [pc], -r1, lsr #10
    2a68:	20120501 	andscs	r0, r2, r1, lsl #10
    2a6c:	21060305 	tstcs	r6, r5, lsl #6
    2a70:	01061f05 	tsteq	r6, r5, lsl #30
    2a74:	05201205 	streq	r1, [r0, #-517]!	@ 0xfffffdfb
    2a78:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
    2a7c:	0501061f 	streq	r0, [r1, #-1567]	@ 0xfffff9e1
    2a80:	03052012 	movweq	r2, #20498	@ 0x5012
    2a84:	12052106 	andne	r2, r5, #-2147483647	@ 0x80000001
    2a88:	03050106 	movweq	r0, #20742	@ 0x5106
    2a8c:	08052306 	stmdaeq	r5, {r1, r2, r8, r9, sp}
    2a90:	03050106 	movweq	r0, #20742	@ 0x5106
    2a94:	1f052106 	svcne	0x00052106
    2a98:	12050106 	andne	r0, r5, #-2147483647	@ 0x80000001
    2a9c:	06030520 	streq	r0, [r3], -r0, lsr #10
    2aa0:	06120521 	ldreq	r0, [r2], -r1, lsr #10
    2aa4:	06030501 	streq	r0, [r3], -r1, lsl #10
    2aa8:	06080522 	streq	r0, [r8], -r2, lsr #10
    2aac:	06030501 	streq	r0, [r3], -r1, lsl #10
    2ab0:	061f0521 	ldreq	r0, [pc], -r1, lsr #10
    2ab4:	20120501 	andscs	r0, r2, r1, lsl #10
    2ab8:	21060305 	tstcs	r6, r5, lsl #6
    2abc:	01061205 	tsteq	r6, r5, lsl #4
    2ac0:	23060305 	movwcs	r0, #25349	@ 0x6305
    2ac4:	01060805 	tsteq	r6, r5, lsl #16
    2ac8:	21060305 	tstcs	r6, r5, lsl #6
    2acc:	01061f05 	tsteq	r6, r5, lsl #30
    2ad0:	05201205 	streq	r1, [r0, #-517]!	@ 0xfffffdfb
    2ad4:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
    2ad8:	0501061f 	streq	r0, [r1, #-1567]	@ 0xfffff9e1
    2adc:	03052012 	movweq	r2, #20498	@ 0x5012
    2ae0:	1f052106 	svcne	0x00052106
    2ae4:	12050106 	andne	r0, r5, #-2147483647	@ 0x80000001
    2ae8:	06030520 	streq	r0, [r3], -r0, lsr #10
    2aec:	06120521 	ldreq	r0, [r2], -r1, lsr #10
    2af0:	21010501 	tstcs	r1, r1, lsl #10
    2af4:	01062506 	tsteq	r6, r6, lsl #10
    2af8:	3d060305 	stccc	3, cr0, [r6, #-20]	@ 0xffffffec
    2afc:	202e0615 	eorcs	r0, lr, r5, lsl r6
    2b00:	0e053406 	cdpeq	4, 0, cr3, cr5, cr6, {0}
    2b04:	05050106 	streq	r0, [r5, #-262]	@ 0xfffffefa
    2b08:	053d3506 	ldreq	r3, [sp, #-1286]!	@ 0xfffffafa
    2b0c:	58780315 	ldmdapl	r8!, {r0, r2, r4, r8, r9}^
    2b10:	03052006 	movweq	r2, #20486	@ 0x5006
    2b14:	05052006 	streq	r2, [r5, #-6]
    2b18:	053d3d14 	ldreq	r3, [sp, #-3348]!	@ 0xfffff2ec
    2b1c:	05010608 	streq	r0, [r1, #-1544]	@ 0xfffff9f8
    2b20:	05350603 	ldreq	r0, [r5, #-1539]!	@ 0xfffff9fd
    2b24:	20590601 	subscs	r0, r9, r1, lsl #12
    2b28:	02050006 	andeq	r0, r5, #6
    2b2c:	000019e2 	andeq	r1, r0, r2, ror #19
    2b30:	05010616 	streq	r0, [r1, #-1558]	@ 0xfffff9ea
    2b34:	153d0603 	ldrne	r0, [sp, #-1539]!	@ 0xfffff9fd
    2b38:	06202e06 	strteq	r2, [r0], -r6, lsl #28
    2b3c:	060e0534 			@ <UNDEFINED> instruction: 0x060e0534
    2b40:	06050501 	streq	r0, [r5], -r1, lsl #10
    2b44:	031c0536 	tsteq	ip, #226492416	@ 0xd800000
    2b48:	20063c78 	andcs	r3, r6, r8, ror ip
    2b4c:	20060305 	andcs	r0, r6, r5, lsl #6
    2b50:	3d140505 	cfldr32cc	mvfx0, [r4, #-20]	@ 0xffffffec
    2b54:	0805593d 	stmdaeq	r5, {r0, r2, r3, r4, r5, r8, fp, ip, lr}
    2b58:	01050106 	tsteq	r5, r6, lsl #2
    2b5c:	00062034 	andeq	r2, r6, r4, lsr r0
    2b60:	1a1c0205 	bne	70337c <__ROM_SIZE__+0x6c337c>
    2b64:	20030000 	andcs	r0, r3, r0
    2b68:	13030501 	movwne	r0, #13569	@ 0x3501
    2b6c:	060a0513 			@ <UNDEFINED> instruction: 0x060a0513
    2b70:	20030501 	andcs	r0, r3, r1, lsl #10
    2b74:	02000505 	andeq	r0, r0, #20971520	@ 0x1400000
    2b78:	22060304 	andcs	r0, r6, #4, 6	@ 0x10000000
    2b7c:	02000805 	andeq	r0, r0, #327680	@ 0x50000
    2b80:	01060304 	tsteq	r6, r4, lsl #6
    2b84:	02001105 	andeq	r1, r0, #1073741825	@ 0x40000001
    2b88:	05200304 	streq	r0, [r0, #-772]!	@ 0xfffffcfc
    2b8c:	0402000c 	streq	r0, [r2], #-12
    2b90:	21052e03 	tstcs	r5, r3, lsl #28
    2b94:	03040200 	movweq	r0, #16896	@ 0x4200
    2b98:	02003a06 	andeq	r3, r0, #24576	@ 0x6000
    2b9c:	20060304 	andcs	r0, r6, r4, lsl #6
    2ba0:	02001105 	andeq	r1, r0, #1073741825	@ 0x40000001
    2ba4:	20060104 	andcs	r0, r6, r4, lsl #2
    2ba8:	32060105 	andcc	r0, r6, #1073741825	@ 0x40000001
    2bac:	7de90306 	stclvc	3, cr0, [r9, #24]!
    2bb0:	05010620 	streq	r0, [r1, #-1568]	@ 0xfffff9e0
    2bb4:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
    2bb8:	062f0601 	strteq	r0, [pc], -r1, lsl #12
    2bbc:	05010623 	streq	r0, [r1, #-1571]	@ 0xfffff9dd
    2bc0:	2f3d0603 	svccs	0x003d0603
    2bc4:	67060105 	strvs	r0, [r6, -r5, lsl #2]
    2bc8:	05000620 	streq	r0, [r0, #-1568]	@ 0xfffff9e0
    2bcc:	001a5602 	andseq	r5, sl, r2, lsl #12
    2bd0:	01061400 	tsteq	r6, r0, lsl #8
    2bd4:	21060305 	tstcs	r6, r5, lsl #6
    2bd8:	01052e06 	tsteq	r5, r6, lsl #28
    2bdc:	ef03062f 	svc	0x0003062f
    2be0:	01062001 	tsteq	r6, r1
    2be4:	30060305 	andcc	r0, r6, r5, lsl #6
    2be8:	05202006 	streq	r2, [r0, #-6]!
    2bec:	23062f01 	movwcs	r2, #28417	@ 0x6f01
    2bf0:	03050106 	movweq	r0, #20742	@ 0x5106
    2bf4:	20063006 	andcs	r3, r6, r6
    2bf8:	2f010520 	svccs	0x00010520
    2bfc:	20160306 	andscs	r0, r6, r6, lsl #6
    2c00:	03050106 	movweq	r0, #20742	@ 0x5106
    2c04:	05135906 	ldreq	r5, [r3, #-2310]	@ 0xfffff6fa
    2c08:	0501060c 	streq	r0, [r1, #-1548]	@ 0xfffff9f4
    2c0c:	052f0603 	streq	r0, [pc, #-1539]!	@ 2611 <cmd_end_+0x2f5>
    2c10:	0511060c 	ldreq	r0, [r1, #-1548]	@ 0xfffff9f4
    2c14:	0305210a 	movweq	r2, #20746	@ 0x510a
    2c18:	00050520 	andeq	r0, r5, r0, lsr #10
    2c1c:	06030402 	streq	r0, [r3], -r2, lsl #8
    2c20:	04020022 	streq	r0, [r2], #-34	@ 0xffffffde
    2c24:	02003d03 	andeq	r3, r0, #3, 26	@ 0xc0
    2c28:	004b0304 	subeq	r0, fp, r4, lsl #6
    2c2c:	13030402 	movwne	r0, #13314	@ 0x3402
    2c30:	02001d05 	andeq	r1, r0, #320	@ 0x140
    2c34:	050d0304 	streq	r0, [sp, #-772]	@ 0xfffffcfc
    2c38:	04020008 	streq	r0, [r2], #-8
    2c3c:	05240603 	streq	r0, [r4, #-1539]!	@ 0xfffff9fd
    2c40:	04020009 	streq	r0, [r2], #-9
    2c44:	11052103 	tstne	r5, r3, lsl #2
    2c48:	01040200 	mrseq	r0, R12_usr
    2c4c:	03051b06 	movweq	r1, #23302	@ 0x5b06
    2c50:	06010536 			@ <UNDEFINED> instruction: 0x06010536
    2c54:	00062e4b 	andeq	r2, r6, fp, asr #28
    2c58:	1ab60205 	bne	fed83474 <_STACK_TOP_+0xded7b478>
    2c5c:	06150000 	ldreq	r0, [r5], -r0
    2c60:	06030501 	streq	r0, [r3], -r1, lsl #10
    2c64:	05131367 	ldreq	r1, [r3, #-871]	@ 0xfffffc99
    2c68:	0501060a 	streq	r0, [r1, #-1546]	@ 0xfffff9f6
    2c6c:	05052003 	streq	r2, [r5, #-3]
    2c70:	03040200 	movweq	r0, #16896	@ 0x4200
    2c74:	02002206 	andeq	r2, r0, #1610612736	@ 0x60000000
    2c78:	00590304 	subseq	r0, r9, r4, lsl #6
    2c7c:	4b030402 	blmi	c3c8c <__ROM_SIZE__+0x83c8c>
    2c80:	02001705 	andeq	r1, r0, #1310720	@ 0x140000
    2c84:	01060304 	tsteq	r6, r4, lsl #6
    2c88:	02000505 	andeq	r0, r0, #20971520	@ 0x1400000
    2c8c:	002e0304 	eoreq	r0, lr, r4, lsl #6
    2c90:	06030402 	streq	r0, [r3], -r2, lsl #8
    2c94:	0402004b 	streq	r0, [r2], #-75	@ 0xffffffb5
    2c98:	09055903 	stmdbeq	r5, {r0, r1, r8, fp, ip, lr}
    2c9c:	03040200 	movweq	r0, #16896	@ 0x4200
    2ca0:	1d050106 	stfnes	f0, [r5, #-24]	@ 0xffffffe8
    2ca4:	03040200 	movweq	r0, #16896	@ 0x4200
    2ca8:	207a0306 	rsbscs	r0, sl, r6, lsl #6
    2cac:	02001105 	andeq	r1, r0, #1073741825	@ 0x40000001
    2cb0:	05200104 	streq	r0, [r0, #-260]!	@ 0xfffffefc
    2cb4:	09030601 	stmdbeq	r3, {r0, r9, sl}
    2cb8:	00063c2e 	andeq	r3, r6, lr, lsr #24
    2cbc:	1afc0205 	bne	fff034d8 <_STACK_TOP_+0xdfefb4dc>
    2cc0:	0a030000 	beq	c2cc8 <__ROM_SIZE__+0x82cc8>
    2cc4:	05010601 	streq	r0, [r1, #-1537]	@ 0xfffff9ff
    2cc8:	14590603 	ldrbne	r0, [r9], #-1539	@ 0xfffff9fd
    2ccc:	12051313 	andne	r1, r5, #1275068416	@ 0x4c000000
    2cd0:	0a050106 	beq	1430f0 <__ROM_SIZE__+0x1030f0>
    2cd4:	20030520 	andcs	r0, r3, r0, lsr #10
    2cd8:	02000b05 	andeq	r0, r0, #5120	@ 0x1400
    2cdc:	03060104 	movweq	r0, #24836	@ 0x6104
    2ce0:	1705200e 	strne	r2, [r5, -lr]
    2ce4:	01040200 	mrseq	r0, R12_usr
    2ce8:	0b050106 	bleq	143108 <__ROM_SIZE__+0x103108>
    2cec:	01040200 	mrseq	r0, R12_usr
    2cf0:	2e054b06 	vmlacs.f64	d4, d5, d6
    2cf4:	01040200 	mrseq	r0, R12_usr
    2cf8:	00017a03 	andeq	r7, r1, r3, lsl #20
    2cfc:	06010402 	streq	r0, [r1], -r2, lsl #8
    2d00:	030a0520 	movweq	r0, #42272	@ 0xa520
    2d04:	0505200b 	streq	r2, [r5, #-11]
    2d08:	02040200 	andeq	r0, r4, #0, 4
    2d0c:	12052306 	andne	r2, r5, #402653184	@ 0x18000000
    2d10:	02040200 	andeq	r0, r4, #0, 4
    2d14:	1e050106 	adfnes	f0, f5, f6
    2d18:	02040200 	andeq	r0, r4, #0, 4
    2d1c:	000c052e 	andeq	r0, ip, lr, lsr #10
    2d20:	58020402 	stmdapl	r2, {r1, sl}
    2d24:	02003105 	andeq	r3, r0, #1073741825	@ 0x40000001
    2d28:	03060204 	movweq	r0, #25092	@ 0x6204
    2d2c:	2e054a69 	vmlscs.f32	s8, s10, s19
    2d30:	02040200 	andeq	r0, r4, #0, 4
    2d34:	33050106 	movwcc	r0, #20742	@ 0x5106
    2d38:	02040200 	andeq	r0, r4, #0, 4
    2d3c:	00240520 	eoreq	r0, r4, r0, lsr #10
    2d40:	06010402 	streq	r0, [r1], -r2, lsl #8
    2d44:	30050520 	andcc	r0, r5, r0, lsr #10
    2d48:	01060805 	tsteq	r6, r5, lsl #16
    2d4c:	31060705 	tstcc	r6, r5, lsl #14
    2d50:	0f054d67 	svceq	0x00054d67
    2d54:	28050106 	stmdacs	r5, {r1, r2, r8}
    2d58:	01040200 	mrseq	r0, R12_usr
    2d5c:	09052006 	stmdbeq	r5, {r1, r2, sp}
    2d60:	06140531 			@ <UNDEFINED> instruction: 0x06140531
    2d64:	3c0c0501 	cfstr32cc	mvfx0, [ip], {1}
    2d68:	33060905 	movwcc	r0, #26885	@ 0x6905
    2d6c:	01061505 	tsteq	r6, r5, lsl #10
    2d70:	06090520 	streq	r0, [r9], -r0, lsr #10
    2d74:	060a053d 			@ <UNDEFINED> instruction: 0x060a053d
    2d78:	1e090514 	mcrne	5, 0, r0, cr9, cr4, {0}
    2d7c:	2e270105 	sufcss	f0, f7, f5
    2d80:	9e010100 	adflss	f0, f1, f0
    2d84:	03000006 	movweq	r0, #6
    2d88:	00009500 	andeq	r9, r0, r0, lsl #10
    2d8c:	fb010200 	blx	43596 <__ROM_SIZE__+0x3596>
    2d90:	01000d0e 	tsteq	r0, lr, lsl #26
    2d94:	00010101 	andeq	r0, r1, r1, lsl #2
    2d98:	00010000 	andeq	r0, r1, r0
    2d9c:	682f0100 	stmdavs	pc!, {r8}	@ <UNPREDICTABLE>
    2da0:	2f656d6f 	svccs	0x00656d6f
    2da4:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    2da8:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
    2dac:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
    2db0:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
    2db4:	68732f72 	ldmdavs	r3!, {r1, r4, r5, r6, r8, r9, sl, fp, sp}^
    2db8:	2f6c6c65 	svccs	0x006c6c65
    2dbc:	2f62696c 	svccs	0x0062696c
    2dc0:	796e6974 	stmdbvc	lr!, {r2, r4, r5, r6, r8, fp, sp, lr}^
    2dc4:	6463652d 	strbtvs	r6, [r3], #-1325	@ 0xfffffad3
    2dc8:	6f2f0068 	svcvs	0x002f0068
    2dcc:	672f7470 			@ <UNDEFINED> instruction: 0x672f7470
    2dd0:	612d6363 			@ <UNDEFINED> instruction: 0x612d6363
    2dd4:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
    2dd8:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	@ 0xfffffe44
    2ddc:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
    2de0:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
    2de4:	6363672f 	cmnvs	r3, #12320768	@ 0xbc0000
    2de8:	6d72612f 	ldfvse	f6, [r2, #-188]!	@ 0xffffff44
    2dec:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
    2df0:	61652d65 	cmnvs	r5, r5, ror #26
    2df4:	312f6962 			@ <UNDEFINED> instruction: 0x312f6962
    2df8:	2e322e32 	mrccs	14, 1, r2, cr2, cr2, {1}
    2dfc:	6e692f31 	mcrvs	15, 3, r2, cr9, cr1, {1}
    2e00:	64756c63 	ldrbtvs	r6, [r5], #-3171	@ 0xfffff39d
    2e04:	65000065 	strvs	r0, [r0, #-101]	@ 0xffffff9b
    2e08:	2e686463 	cdpcs	4, 6, cr6, cr8, cr3, {3}
    2e0c:	00010063 	andeq	r0, r1, r3, rrx
    2e10:	64747300 	ldrbtvs	r7, [r4], #-768	@ 0xfffffd00
    2e14:	2d746e69 	ldclcs	14, cr6, [r4, #-420]!	@ 0xfffffe5c
    2e18:	2e636367 	cdpcs	3, 6, cr6, cr3, cr7, {3}
    2e1c:	00020068 	andeq	r0, r2, r8, rrx
    2e20:	01050000 	mrseq	r0, (UNDEF: 5)
    2e24:	70020500 	andvc	r0, r2, r0, lsl #10
    2e28:	0300001b 	movweq	r0, #27
    2e2c:	050101c6 	streq	r0, [r1, #-454]	@ 0xfffffe3a
    2e30:	12051303 	andne	r1, r5, #201326592	@ 0xc000000
    2e34:	0d050106 	stfeqs	f0, [r5, #-24]	@ 0xffffffe8
    2e38:	2e210520 	cfsh64cs	mvdx0, mvdx1, #16
    2e3c:	052e1905 	streq	r1, [lr, #-2309]!	@ 0xfffff6fb
    2e40:	3f062101 	svccc	0x00062101
    2e44:	05130305 	ldreq	r0, [r3, #-773]	@ 0xfffffcfb
    2e48:	05010609 	streq	r0, [r1, #-1545]	@ 0xfffff9f7
    2e4c:	20052e04 	andcs	r2, r5, r4, lsl #28
    2e50:	2e18052e 	cfmul64cs	mvdx0, mvdx8, mvdx14
    2e54:	052e1005 	streq	r1, [lr, #-5]!
    2e58:	23064b01 	movwcs	r4, #27393	@ 0x6b01
    2e5c:	13130305 	tstne	r3, #335544320	@ 0x14000000
    2e60:	01060a05 	tsteq	r6, r5, lsl #20
    2e64:	05200305 	streq	r0, [r0, #-773]!	@ 0xfffffcfb
    2e68:	04020005 	streq	r0, [r2], #-5
    2e6c:	05220603 	streq	r0, [r2, #-1539]!	@ 0xfffff9fd
    2e70:	0402000d 	streq	r0, [r2], #-13
    2e74:	05010603 	streq	r0, [r1, #-1539]	@ 0xfffff9fd
    2e78:	0402000a 	streq	r0, [r2], #-10
    2e7c:	22052e03 	andcs	r2, r5, #3, 28	@ 0x30
    2e80:	03040200 	movweq	r0, #16896	@ 0x4200
    2e84:	11052c06 	tstne	r5, r6, lsl #24
    2e88:	01040200 	mrseq	r0, R12_usr
    2e8c:	06010520 	streq	r0, [r1], -r0, lsr #10
    2e90:	06230632 			@ <UNDEFINED> instruction: 0x06230632
    2e94:	06030501 	streq	r0, [r3], -r1, lsl #10
    2e98:	2006134b 	andcs	r1, r6, fp, asr #6
    2e9c:	4b2f0620 	blmi	bc4724 <__ROM_SIZE__+0xb84724>
    2ea0:	4b060105 	blmi	1832bc <__ROM_SIZE__+0x1432bc>
    2ea4:	0500062e 	streq	r0, [r0, #-1582]	@ 0xfffff9d2
    2ea8:	001bd402 	andseq	sp, fp, r2, lsl #8
    2eac:	03051700 	movweq	r1, #22272	@ 0x5700
    2eb0:	0a051313 	beq	147b04 <__ROM_SIZE__+0x107b04>
    2eb4:	11050106 	tstne	r5, r6, lsl #2
    2eb8:	01040200 	mrseq	r0, R12_usr
    2ebc:	05052006 	streq	r2, [r5, #-6]
    2ec0:	06120530 			@ <UNDEFINED> instruction: 0x06120530
    2ec4:	2e080501 	cfsh32cs	mvfx0, mvfx8, #1
    2ec8:	02002205 	andeq	r2, r0, #1342177280	@ 0x50000000
    2ecc:	48060204 	stmdami	r6, {r2, r9}
    2ed0:	02040200 	andeq	r0, r4, #0, 4
    2ed4:	0a052006 	beq	14aef4 <__ROM_SIZE__+0x10aef4>
    2ed8:	0e052027 	cdpeq	0, 0, cr2, cr5, cr7, {1}
    2edc:	2401051d 	strcs	r0, [r1], #-1309	@ 0xfffffae3
    2ee0:	20100306 	andscs	r0, r0, r6, lsl #6
    2ee4:	13130305 	tstne	r3, #335544320	@ 0x14000000
    2ee8:	01060a05 	tsteq	r6, r5, lsl #20
    2eec:	05200305 	streq	r0, [r0, #-773]!	@ 0xfffffcfb
    2ef0:	04020005 	streq	r0, [r2], #-5
    2ef4:	05220603 	streq	r0, [r2, #-1539]!	@ 0xfffff9fd
    2ef8:	0402000a 	streq	r0, [r2], #-10
    2efc:	05010603 	streq	r0, [r1, #-1539]	@ 0xfffff9fd
    2f00:	04020022 	streq	r0, [r2], #-34	@ 0xffffffde
    2f04:	053a0603 	ldreq	r0, [sl, #-1539]!	@ 0xfffff9fd
    2f08:	04020011 	streq	r0, [r2], #-17	@ 0xffffffef
    2f0c:	01052001 	tsteq	r5, r1
    2f10:	25063206 	strcs	r3, [r6, #-518]	@ 0xfffffdfa
    2f14:	13130305 	tstne	r3, #335544320	@ 0x14000000
    2f18:	11060c05 	tstne	r6, r5, lsl #24
    2f1c:	05052106 	streq	r2, [r5, #-262]	@ 0xfffffefa
    2f20:	060a0530 			@ <UNDEFINED> instruction: 0x060a0530
    2f24:	2e080501 	cfsh32cs	mvfx0, mvfx8, #1
    2f28:	24060505 	strcs	r0, [r6], #-1285	@ 0xfffffafb
    2f2c:	01060705 	tsteq	r6, r5, lsl #14
    2f30:	06030520 	streq	r0, [r3], -r0, lsr #10
    2f34:	06010522 	streq	r0, [r1], -r2, lsr #10
    2f38:	00063c13 	andeq	r3, r6, r3, lsl ip
    2f3c:	1c1e0205 	lfmne	f0, 4, [lr], {5}
    2f40:	11030000 	mrsne	r0, (UNDEF: 3)
    2f44:	13030501 	movwne	r0, #13569	@ 0x3501
    2f48:	06050515 			@ <UNDEFINED> instruction: 0x06050515
    2f4c:	06030501 	streq	r0, [r3], -r1, lsl #10
    2f50:	06070531 			@ <UNDEFINED> instruction: 0x06070531
    2f54:	05017a03 	streq	r7, [r1, #-2563]	@ 0xfffff5fd
    2f58:	0527060b 	streq	r0, [r7, #-1547]!	@ 0xfffff9f5
    2f5c:	0402000f 	streq	r0, [r2], #-15
    2f60:	052e0601 	streq	r0, [lr, #-1537]!	@ 0xfffff9ff
    2f64:	0402000b 	streq	r0, [r2], #-11
    2f68:	05052e01 	streq	r2, [r5, #-3585]	@ 0xfffff1ff
    2f6c:	07052206 	streq	r2, [r5, -r6, lsl #4]
    2f70:	05200106 	streq	r0, [r0, #-262]!	@ 0xfffffefa
    2f74:	05230603 	streq	r0, [r3, #-1539]!	@ 0xfffff9fd
    2f78:	20010606 	andcs	r0, r1, r6, lsl #12
    2f7c:	25060705 	strcs	r0, [r6, #-1797]	@ 0xfffff8fb
    2f80:	01060f05 	tsteq	r6, r5, lsl #30
    2f84:	21060705 	tstcs	r6, r5, lsl #14
    2f88:	01060905 	tsteq	r6, r5, lsl #18
    2f8c:	1d061d05 	stcne	13, cr1, [r6, #-20]	@ 0xffffffec
    2f90:	01060e05 	tsteq	r6, r5, lsl #28
    2f94:	2e201d05 	cdpcs	13, 2, cr1, cr0, cr5, {0}
    2f98:	05190105 	ldreq	r0, [r9, #-261]	@ 0xfffffefb
    2f9c:	2078030e 	rsbscs	r0, r8, lr, lsl #6
    2fa0:	03060105 	movweq	r0, #24837	@ 0x6105
    2fa4:	01063c0c 	tsteq	r6, ip, lsl #24
    2fa8:	21060305 	tstcs	r6, r5, lsl #6
    2fac:	01060705 	tsteq	r6, r5, lsl #14
    2fb0:	0603053c 			@ <UNDEFINED> instruction: 0x0603053c
    2fb4:	0a051331 	beq	147c80 <__ROM_SIZE__+0x107c80>
    2fb8:	03050106 	movweq	r0, #20742	@ 0x5106
    2fbc:	1c070520 	cfstr32ne	mvfx0, [r7], {32}
    2fc0:	02000505 	andeq	r0, r0, #20971520	@ 0x1400000
    2fc4:	43060304 	movwmi	r0, #25348	@ 0x6304
    2fc8:	02000a05 	andeq	r0, r0, #20480	@ 0x5000
    2fcc:	01060304 	tsteq	r6, r4, lsl #6
    2fd0:	02001b05 	andeq	r1, r0, #5120	@ 0x1400
    2fd4:	39060304 	stmdbcc	r6, {r2, r8, r9}
    2fd8:	02001105 	andeq	r1, r0, #1073741825	@ 0x40000001
    2fdc:	05200104 	streq	r0, [r0, #-260]!	@ 0xfffffefc
    2fe0:	2e330605 	cfmsuba32cs	mvax0, mvax0, mvfx3, mvfx5
    2fe4:	0a052406 	beq	14c004 <__ROM_SIZE__+0x10c004>
    2fe8:	05050106 	streq	r0, [r5, #-262]	@ 0xfffffefa
    2fec:	07054b06 	streq	r4, [r5, -r6, lsl #22]
    2ff0:	05050106 	streq	r0, [r5, #-262]	@ 0xfffffefa
    2ff4:	07052106 	streq	r2, [r5, -r6, lsl #2]
    2ff8:	0c050106 	stfeqs	f0, [r5], {6}
    2ffc:	03052a06 	movweq	r2, #23046	@ 0x5a06
    3000:	06051336 			@ <UNDEFINED> instruction: 0x06051336
    3004:	052e0106 	streq	r0, [lr, #-262]!	@ 0xfffffefa
    3008:	200a0301 	andcs	r0, sl, r1, lsl #6
    300c:	02000705 	andeq	r0, r0, #1310720	@ 0x140000
    3010:	2a060304 	bcs	183c28 <__ROM_SIZE__+0x143c28>
    3014:	02001105 	andeq	r1, r0, #1073741825	@ 0x40000001
    3018:	01060304 	tsteq	r6, r4, lsl #6
    301c:	02001505 	andeq	r1, r0, #20971520	@ 0x1400000
    3020:	052e0304 	streq	r0, [lr, #-772]!	@ 0xfffffcfc
    3024:	04020023 	streq	r0, [r2], #-35	@ 0xffffffdd
    3028:	32052003 	andcc	r2, r5, #3
    302c:	03040200 	movweq	r0, #16896	@ 0x4200
    3030:	002b0558 	eoreq	r0, fp, r8, asr r5
    3034:	2e030402 	cdpcs	4, 0, cr0, cr3, cr2, {0}
    3038:	02001f05 	andeq	r1, r0, #5, 30
    303c:	052e0304 	streq	r0, [lr, #-772]!	@ 0xfffffcfc
    3040:	0402000d 	streq	r0, [r2], #-13
    3044:	2a052003 	bcs	14b058 <__ROM_SIZE__+0x10b058>
    3048:	03040200 	movweq	r0, #16896	@ 0x4200
    304c:	25052c06 	strcs	r2, [r5, #-3078]	@ 0xfffff3fa
    3050:	01040200 	mrseq	r0, R12_usr
    3054:	32050520 	andcc	r0, r5, #32, 10	@ 0x8000000
    3058:	01060605 	tsteq	r6, r5, lsl #12
    305c:	05200a05 	streq	r0, [r0, #-2565]!	@ 0xfffff5fb
    3060:	0c053001 	stceq	0, cr3, [r5], {1}
    3064:	20207a03 	eorcs	r7, r0, r3, lsl #20
    3068:	00060105 	andeq	r0, r6, r5, lsl #2
    306c:	1cbc0205 	lfmne	f0, 4, [ip], #20
    3070:	11030000 	mrsne	r0, (UNDEF: 3)
    3074:	14030501 	strne	r0, [r3], #-1281	@ 0xfffffaff
    3078:	01060805 	tsteq	r6, r5, lsl #16
    307c:	30060305 	andcc	r0, r6, r5, lsl #6
    3080:	05010613 	streq	r0, [r1, #-1555]	@ 0xfffff9ed
    3084:	04020005 	streq	r0, [r2], #-5
    3088:	05220603 	streq	r0, [r2, #-1539]!	@ 0xfffff9fd
    308c:	0402000a 	streq	r0, [r2], #-10
    3090:	05010603 	streq	r0, [r1, #-1539]	@ 0xfffff9fd
    3094:	04020022 	streq	r0, [r2], #-34	@ 0xffffffde
    3098:	053a0603 	ldreq	r0, [sl, #-1539]!	@ 0xfffff9fd
    309c:	04020011 	streq	r0, [r2], #-17	@ 0xffffffef
    30a0:	01052001 	tsteq	r5, r1
    30a4:	25063206 	strcs	r3, [r6, #-518]	@ 0xfffffdfa
    30a8:	05140305 	ldreq	r0, [r4, #-773]	@ 0xfffffcfb
    30ac:	05010608 	streq	r0, [r1, #-1544]	@ 0xfffff9f8
    30b0:	11052006 	tstne	r5, r6
    30b4:	01040200 	mrseq	r0, R12_usr
    30b8:	05053406 	streq	r3, [r5, #-1030]	@ 0xfffffbfa
    30bc:	060a0530 			@ <UNDEFINED> instruction: 0x060a0530
    30c0:	2e080501 	cfsh32cs	mvfx0, mvfx8, #1
    30c4:	02002205 	andeq	r2, r0, #1342177280	@ 0x50000000
    30c8:	1e060204 	cdpne	2, 0, cr0, cr6, cr4, {0}
    30cc:	02040200 	andeq	r0, r4, #0, 4
    30d0:	03052006 	movweq	r2, #20486	@ 0x5006
    30d4:	0d052706 	stceq	7, cr2, [r5, #-24]	@ 0xffffffe8
    30d8:	053c0106 	ldreq	r0, [ip, #-262]!	@ 0xfffffefa
    30dc:	2e75030c 	cdpcs	3, 7, cr0, cr5, cr12, {0}
    30e0:	0c030105 	stfeqs	f0, [r3], {5}
    30e4:	18030620 	stmdane	r3, {r5, r9, sl}
    30e8:	13030520 	movwne	r0, #13600	@ 0x3520
    30ec:	060a0513 			@ <UNDEFINED> instruction: 0x060a0513
    30f0:	06110501 	ldreq	r0, [r1], -r1, lsl #10
    30f4:	06010520 	streq	r0, [r1], -r0, lsr #10
    30f8:	0005052c 	andeq	r0, r5, ip, lsr #10
    30fc:	06030402 	streq	r0, [r3], -r2, lsl #8
    3100:	00150524 	andseq	r0, r5, r4, lsr #10
    3104:	06030402 	streq	r0, [r3], -r2, lsl #8
    3108:	00120501 	andseq	r0, r2, r1, lsl #10
    310c:	2e030402 	cdpcs	4, 0, cr0, cr3, cr2, {0}
    3110:	02000a05 	andeq	r0, r0, #20480	@ 0x5000
    3114:	053c0304 	ldreq	r0, [ip, #-772]!	@ 0xfffffcfc
    3118:	04020022 	streq	r0, [r2], #-34	@ 0xffffffde
    311c:	052c0603 	streq	r0, [ip, #-1539]!	@ 0xfffff9fd
    3120:	04020011 	streq	r0, [r2], #-17	@ 0xffffffef
    3124:	01052003 	tsteq	r5, r3
    3128:	062e3206 	strteq	r3, [lr], -r6, lsl #4
    312c:	13030524 	movwne	r0, #13604	@ 0x3524
    3130:	01060405 	tsteq	r6, r5, lsl #8
    3134:	05200805 	streq	r0, [r0, #-2053]!	@ 0xfffff7fb
    3138:	25063d01 	strcs	r3, [r6, #-3329]	@ 0xfffff2ff
    313c:	03050106 	movweq	r0, #20742	@ 0x5106
    3140:	18135906 	ldmdane	r3, {r1, r2, r8, fp, ip, lr}
    3144:	31062006 	tstcc	r6, r6
    3148:	01060705 	tsteq	r6, r5, lsl #14
    314c:	054a0605 	strbeq	r0, [sl, #-1541]	@ 0xfffff9fb
    3150:	05220605 	streq	r0, [r2, #-1541]!	@ 0xfffff9fb
    3154:	04020001 	streq	r0, [r2], #-1
    3158:	73030601 	movwvc	r0, #13825	@ 0x3601
    315c:	0402004a 	streq	r0, [r2], #-74	@ 0xffffffb6
    3160:	05052001 	streq	r2, [r5, #-1]
    3164:	20110306 	andscs	r0, r1, r6, lsl #6
    3168:	0c030705 	stceq	7, cr0, [r3], {5}
    316c:	0021054a 	eoreq	r0, r1, sl, asr #10
    3170:	03020402 	movweq	r0, #9218	@ 0x2402
    3174:	11056678 	tstne	r5, r8, ror r6
    3178:	01040200 	mrseq	r0, R12_usr
    317c:	31050520 	tstcc	r5, r0, lsr #10
    3180:	0609055b 			@ <UNDEFINED> instruction: 0x0609055b
    3184:	4a080501 	bmi	204590 <__ROM_SIZE__+0x1c4590>
    3188:	03060505 	movweq	r0, #25861	@ 0x6505
    318c:	09052e0c 	stmdbeq	r5, {r2, r3, r9, sl, fp, sp}
    3190:	08050106 	stmdaeq	r5, {r1, r2, r8}
    3194:	0607054a 	streq	r0, [r7], -sl, asr #10
    3198:	06010530 			@ <UNDEFINED> instruction: 0x06010530
    319c:	2e660903 	vmulcs.f16	s1, s12, s6	@ <UNPREDICTABLE>
    31a0:	02050006 	andeq	r0, r5, #6
    31a4:	00001d94 	muleq	r0, r4, sp
    31a8:	05010616 	streq	r0, [r1, #-1558]	@ 0xfffff9ea
    31ac:	133d0603 	teqne	sp, #3145728	@ 0x300000
    31b0:	06200614 			@ <UNDEFINED> instruction: 0x06200614
    31b4:	3e3d4b2f 	vaddcc.f64	d4, d13, d31
    31b8:	01060905 	tsteq	r6, r5, lsl #18
    31bc:	03060505 	movweq	r0, #25861	@ 0x6505
    31c0:	59592011 	ldmdbpl	r9, {r0, r4, sp}^
    31c4:	030a0559 	movweq	r0, #42329	@ 0xa559
    31c8:	0b05586c 	bleq	159380 <__ROM_SIZE__+0x119380>
    31cc:	0a050106 	beq	1435ec <__ROM_SIZE__+0x1035ec>
    31d0:	0605053c 			@ <UNDEFINED> instruction: 0x0605053c
    31d4:	060a0522 	streq	r0, [sl], -r2, lsr #10
    31d8:	4a1d0501 	bmi	7445e4 <__ROM_SIZE__+0x7045e4>
    31dc:	4c060505 	cfstr32mi	mvfx0, [r6], {5}
    31e0:	01060805 	tsteq	r6, r5, lsl #16
    31e4:	06070520 	streq	r0, [r7], -r0, lsr #10
    31e8:	054b4b22 	strbeq	r4, [fp, #-2850]	@ 0xfffff4de
    31ec:	20010609 	andcs	r0, r1, r9, lsl #12
    31f0:	0e030105 	adfeqs	f0, f3, f5
    31f4:	00062e20 	andeq	r2, r6, r0, lsr #28
    31f8:	1e180205 	cdpne	2, 1, cr0, cr8, cr5, {0}
    31fc:	0f030000 	svceq	0x00030000
    3200:	05010601 	streq	r0, [r1, #-1537]	@ 0xfffff9ff
    3204:	063d0603 	ldrteq	r0, [sp], -r3, lsl #12
    3208:	052f0620 	streq	r0, [pc, #-1568]!	@ 2bf0 <rsbox+0x2c>
    320c:	204b0601 	subcs	r0, fp, r1, lsl #12
    3210:	02050006 	andeq	r0, r5, #6
    3214:	00001e2e 	andeq	r1, r0, lr, lsr #28
    3218:	05010615 	streq	r0, [r1, #-1557]	@ 0xfffff9eb
    321c:	2f2f0603 	svccs	0x002f0603
    3220:	3d060105 	stfccs	f0, [r6, #-20]	@ 0xffffffec
    3224:	05000620 	streq	r0, [r0, #-1568]	@ 0xfffff9e0
    3228:	001e3e02 	andseq	r3, lr, r2, lsl #28
    322c:	01061500 	tsteq	r6, r0, lsl #10
    3230:	2f060305 	svccs	0x00060305
    3234:	01060f05 	tsteq	r6, r5, lsl #30
    3238:	052f0c05 	streq	r0, [pc, #-3077]!	@ 263b <cmd_end_+0x31f>
    323c:	0402000f 	streq	r0, [r2], #-15
    3240:	0c052001 	stceq	0, cr2, [r5], {1}
    3244:	01040200 	mrseq	r0, R12_usr
    3248:	0105203c 	tsteq	r5, ip, lsr r0
    324c:	00062021 	andeq	r2, r6, r1, lsr #32
    3250:	1e540205 	cdpne	2, 5, cr0, cr4, cr5, {0}
    3254:	06160000 	ldreq	r0, [r6], -r0
    3258:	06030501 	streq	r0, [r3], -r1, lsl #10
    325c:	0607054c 	streq	r0, [r7], -ip, asr #10
    3260:	2e060501 	cfsh32cs	mvfx0, mvfx6, #1
    3264:	22060505 	andcs	r0, r6, #20971520	@ 0x1400000
    3268:	03060105 	movweq	r0, #24837	@ 0x6105
    326c:	05053c12 	streq	r3, [r5, #-3090]	@ 0xfffff3ee
    3270:	2e720306 	cdpcs	3, 7, cr0, cr2, cr6, {0}
    3274:	59594b14 	ldmdbpl	r9, {r2, r4, r8, r9, fp, lr}^
    3278:	593e5a59 	ldmdbpl	lr!, {r0, r3, r4, r6, r9, fp, ip, lr}
    327c:	06010559 			@ <UNDEFINED> instruction: 0x06010559
    3280:	0500065a 	streq	r0, [r0, #-1626]	@ 0xfffff9a6
    3284:	001ec202 	andseq	ip, lr, r2, lsl #4
    3288:	01061700 	tsteq	r6, r0, lsl #14
    328c:	67060305 	strvs	r0, [r6, -r5, lsl #6]
    3290:	01060805 	tsteq	r6, r5, lsl #16
    3294:	06052020 	streq	r2, [r5], -r0, lsr #32
    3298:	0605052e 	streq	r0, [r5], -lr, lsr #10
    329c:	06090522 	streq	r0, [r9], -r2, lsr #10
    32a0:	4a080501 	bmi	2046ac <__ROM_SIZE__+0x1c46ac>
    32a4:	26060705 	strcs	r0, [r6], -r5, lsl #14
    32a8:	01060b05 	tsteq	r6, r5, lsl #22
    32ac:	054a0a05 	strbeq	r0, [sl, #-2565]	@ 0xfffff5fb
    32b0:	05220609 	streq	r0, [r2, #-1545]!	@ 0xfffff9f7
    32b4:	0501060d 	streq	r0, [r1, #-1549]	@ 0xfffff9f3
    32b8:	0b054a0c 	bleq	155af0 <__ROM_SIZE__+0x115af0>
    32bc:	07052206 	streq	r2, [r5, -r6, lsl #4]
    32c0:	05587803 	ldrbeq	r7, [r8, #-2051]	@ 0xfffff7fd
    32c4:	26030601 	strcs	r0, [r3], -r1, lsl #12
    32c8:	060b0566 	streq	r0, [fp], -r6, ror #10
    32cc:	052e6603 	streq	r6, [lr, #-1539]!	@ 0xfffff9fd
    32d0:	59145e09 	ldmdbpl	r4, {r0, r3, r9, sl, fp, ip, lr}
    32d4:	59594b59 	ldmdbpl	r9, {r0, r3, r4, r6, r8, r9, fp, lr}^
    32d8:	593e5a59 	ldmdbpl	lr!, {r0, r3, r4, r6, r9, fp, ip, lr}
    32dc:	05595959 	ldrbeq	r5, [r9, #-2393]	@ 0xfffff6a7
    32e0:	064e0601 	strbeq	r0, [lr], -r1, lsl #12
    32e4:	96020500 	strls	r0, [r2], -r0, lsl #10
    32e8:	1900001f 	stmdbne	r0, {r0, r1, r2, r3, r4}
    32ec:	03050106 	movweq	r0, #20742	@ 0x5106
    32f0:	13135906 	tstne	r3, #98304	@ 0x18000
    32f4:	01060f05 	tsteq	r6, r5, lsl #30
    32f8:	03052e20 	movweq	r2, #24096	@ 0x5e20
    32fc:	2e062206 	cdpcs	2, 0, cr2, cr6, cr6, {0}
    3300:	0a053006 	beq	14f320 <__ROM_SIZE__+0x10f320>
    3304:	03050106 	movweq	r0, #20742	@ 0x5106
    3308:	00210520 	eoreq	r0, r1, r0, lsr #10
    330c:	06020402 	streq	r0, [r2], -r2, lsl #8
    3310:	001b0520 	andseq	r0, fp, r0, lsr #10
    3314:	20010402 	andcs	r0, r1, r2, lsl #8
    3318:	4b300505 	blmi	c04734 <__ROM_SIZE__+0xbc4734>
    331c:	01060905 	tsteq	r6, r5, lsl #18
    3320:	054a0805 	strbeq	r0, [sl, #-2053]	@ 0xfffff7fb
    3324:	05300607 	ldreq	r0, [r0, #-1543]!	@ 0xfffff9f9
    3328:	01057703 	tsteq	r5, r3, lsl #14
    332c:	062e6706 	strteq	r6, [lr], -r6, lsl #14
    3330:	ec020500 	cfstr32	mvfx0, [r2], {-0}
    3334:	0300001f 	movweq	r0, #31
    3338:	01060124 	tsteq	r6, r4, lsr #2
    333c:	4b060305 	blmi	183f58 <__ROM_SIZE__+0x143f58>
    3340:	06070514 			@ <UNDEFINED> instruction: 0x06070514
    3344:	2e060501 	cfsh32cs	mvfx0, mvfx6, #1
    3348:	05220c05 	streq	r0, [r2, #-3077]!	@ 0xfffff3fb
    334c:	20120301 	andscs	r0, r2, r1, lsl #6
    3350:	03060505 	movweq	r0, #25861	@ 0x6505
    3354:	595c2e72 	ldmdbpl	ip, {r1, r4, r5, r6, r9, sl, fp, sp}^
    3358:	5959595a 	ldmdbpl	r9, {r1, r3, r4, r6, r8, fp, ip, lr}^
    335c:	060c055a 			@ <UNDEFINED> instruction: 0x060c055a
    3360:	06010501 	streq	r0, [r1], -r1, lsl #10
    3364:	06740f03 	ldrbteq	r0, [r4], -r3, lsl #30
    3368:	06030501 	streq	r0, [r3], -r1, lsl #10
    336c:	063f053e 			@ <UNDEFINED> instruction: 0x063f053e
    3370:	2e030501 	cfsh32cs	mvfx0, mvfx3, #1
    3374:	05310658 	ldreq	r0, [r1, #-1624]!	@ 0xfffff9a8
    3378:	05010607 	streq	r0, [r1, #-1543]	@ 0xfffff9f9
    337c:	05053c06 	streq	r3, [r5, #-3078]	@ 0xfffff3fa
    3380:	11053506 	tstne	r5, r6, lsl #10
    3384:	05050106 	streq	r0, [r5, #-262]	@ 0xfffffefa
    3388:	05143d06 	ldreq	r3, [r4, #-3334]	@ 0xfffff2fa
    338c:	0501060c 	streq	r0, [r1, #-1548]	@ 0xfffff9f4
    3390:	07052005 	streq	r2, [r5, -r5]
    3394:	03040200 	movweq	r0, #16896	@ 0x4200
    3398:	35052206 	strcc	r2, [r5, #-518]	@ 0xfffffdfa
    339c:	03040200 	movweq	r0, #16896	@ 0x4200
    33a0:	001d0548 	andseq	r0, sp, r8, asr #10
    33a4:	20010402 	andcs	r0, r1, r2, lsl #8
    33a8:	5a340505 	bpl	d047c4 <__ROM_SIZE__+0xcc47c4>
    33ac:	01060c05 	tsteq	r6, r5, lsl #24
    33b0:	14010520 	strne	r0, [r1], #-1312	@ 0xfffffae0
    33b4:	6e030c05 	cdpvs	12, 0, cr0, cr3, cr5, {0}
    33b8:	06010520 	streq	r0, [r1], -r0, lsr #10
    33bc:	a8020500 	stmdage	r2, {r8, sl}
    33c0:	03000020 	movweq	r0, #32
    33c4:	01060117 	tsteq	r6, r7, lsl r1
    33c8:	4c060305 	stcmi	3, cr0, [r6], {5}
    33cc:	01064c05 	tsteq	r6, r5, lsl #24
    33d0:	202e0c05 	eorcs	r0, lr, r5, lsl #24
    33d4:	2e060520 	cfsh32cs	mvfx0, mvfx6, #16
    33d8:	03060505 	movweq	r0, #25861	@ 0x6505
    33dc:	0c05201b 	stceq	0, cr2, [r5], {27}
    33e0:	01050106 	tsteq	r5, r6, lsl #2
    33e4:	030c0522 	movweq	r0, #50466	@ 0xc522
    33e8:	08052064 	stmdaeq	r5, {r2, r5, r6, sp}
    33ec:	320c054a 	andcc	r0, ip, #310378496	@ 0x12800000
    33f0:	02000705 	andeq	r0, r0, #1310720	@ 0x140000
    33f4:	30060304 	andcc	r0, r6, r4, lsl #6
    33f8:	02001d05 	andeq	r1, r0, #320	@ 0x140
    33fc:	01060304 	tsteq	r6, r4, lsl #6
    3400:	02001105 	andeq	r1, r0, #1073741825	@ 0x40000001
    3404:	052e0304 	streq	r0, [lr, #-772]!	@ 0xfffffcfc
    3408:	0402002a 	streq	r0, [r2], #-42	@ 0xffffffd6
    340c:	052c0603 	streq	r0, [ip, #-1539]!	@ 0xfffff9fd
    3410:	04020013 	streq	r0, [r2], #-19	@ 0xffffffed
    3414:	05052001 	streq	r2, [r5, #-1]
    3418:	660c0334 			@ <UNDEFINED> instruction: 0x660c0334
    341c:	01060c05 	tsteq	r6, r5, lsl #24
    3420:	01000202 	tsteq	r0, r2, lsl #4
    3424:	00018501 	andeq	r8, r1, r1, lsl #10
    3428:	8e000300 	cdphi	3, 0, cr0, cr0, cr0, {0}
    342c:	02000000 	andeq	r0, r0, #0
    3430:	0d0efb01 	vstreq	d15, [lr, #-4]
    3434:	01010100 	mrseq	r0, (UNDEF: 17)
    3438:	00000001 	andeq	r0, r0, r1
    343c:	01000001 	tsteq	r0, r1
    3440:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 338c <base_order+0x668>
    3444:	63652f65 	cmnvs	r5, #404	@ 0x194
    3448:	652f6674 	strvs	r6, [pc, #-1652]!	@ 2ddc <base_order+0xb8>
    344c:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
    3450:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
    3454:	2f72656e 	svccs	0x0072656e
    3458:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
    345c:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
    3460:	32612f62 	rsbcc	r2, r1, #392	@ 0x188
    3464:	6f2f0069 	svcvs	0x002f0069
    3468:	672f7470 			@ <UNDEFINED> instruction: 0x672f7470
    346c:	612d6363 			@ <UNDEFINED> instruction: 0x612d6363
    3470:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
    3474:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	@ 0xfffffe44
    3478:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
    347c:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
    3480:	6363672f 	cmnvs	r3, #12320768	@ 0xbc0000
    3484:	6d72612f 	ldfvse	f6, [r2, #-188]!	@ 0xffffff44
    3488:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
    348c:	61652d65 	cmnvs	r5, r5, ror #26
    3490:	312f6962 			@ <UNDEFINED> instruction: 0x312f6962
    3494:	2e322e32 	mrccs	14, 1, r2, cr2, cr2, {1}
    3498:	6e692f31 	mcrvs	15, 3, r2, cr9, cr1, {1}
    349c:	64756c63 	ldrbtvs	r6, [r5], #-3171	@ 0xfffff39d
    34a0:	61000065 	tstvs	r0, r5, rrx
    34a4:	632e6932 			@ <UNDEFINED> instruction: 0x632e6932
    34a8:	00000100 	andeq	r0, r0, r0, lsl #2
    34ac:	69647473 	stmdbvs	r4!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
    34b0:	672d746e 	strvs	r7, [sp, -lr, ror #8]!
    34b4:	682e6363 	stmdavs	lr!, {r0, r1, r5, r6, r8, r9, sp, lr}
    34b8:	00000200 	andeq	r0, r0, r0, lsl #4
    34bc:	001b0500 	andseq	r0, fp, r0, lsl #10
    34c0:	20f00205 	rscscs	r0, r0, r5, lsl #4
    34c4:	12030000 	andne	r0, r3, #0
    34c8:	05010601 	streq	r0, [r1, #-1537]	@ 0xfffff9ff
    34cc:	13210603 			@ <UNDEFINED> instruction: 0x13210603
    34d0:	05010805 	streq	r0, [r1, #-2053]	@ 0xfffff7fb
    34d4:	0501060c 	streq	r0, [r1, #-1548]	@ 0xfffff9f4
    34d8:	03051f07 	movweq	r1, #24327	@ 0x5f07
    34dc:	00050521 	andeq	r0, r5, r1, lsr #10
    34e0:	06030402 	streq	r0, [r3], -r2, lsl #8
    34e4:	000f0521 	andeq	r0, pc, r1, lsr #10
    34e8:	06030402 	streq	r0, [r3], -r2, lsl #8
    34ec:	00140501 	andseq	r0, r4, r1, lsl #10
    34f0:	2e030402 	cdpcs	4, 0, cr0, cr3, cr2, {0}
    34f4:	02000905 	andeq	r0, r0, #81920	@ 0x14000
    34f8:	052e0304 	streq	r0, [lr, #-772]!	@ 0xfffffcfc
    34fc:	04020023 	streq	r0, [r2], #-35	@ 0xffffffdd
    3500:	052d0603 	streq	r0, [sp, #-1539]!	@ 0xfffff9fd
    3504:	0402001a 	streq	r0, [r2], #-26	@ 0xffffffe6
    3508:	16052001 	strne	r2, [r5], -r1
    350c:	01040200 	mrseq	r0, R12_usr
    3510:	1a050106 	bne	143930 <__ROM_SIZE__+0x103930>
    3514:	01040200 	mrseq	r0, R12_usr
    3518:	06030520 	streq	r0, [r3], -r0, lsr #10
    351c:	06010531 			@ <UNDEFINED> instruction: 0x06010531
    3520:	06200513 			@ <UNDEFINED> instruction: 0x06200513
    3524:	05010622 	streq	r0, [r1, #-1570]	@ 0xfffff9de
    3528:	13210603 			@ <UNDEFINED> instruction: 0x13210603
    352c:	01080514 	tsteq	r8, r4, lsl r5
    3530:	01061105 	tsteq	r6, r5, lsl #2
    3534:	051d0c05 	ldreq	r0, [sp, #-3077]	@ 0xfffff3fb
    3538:	0c052303 	stceq	3, cr2, [r5], {3}
    353c:	1e052306 	cdpne	3, 0, cr2, cr5, cr6, {0}
    3540:	0f050106 	svceq	0x00050106
    3544:	0607053c 			@ <UNDEFINED> instruction: 0x0607053c
    3548:	061c052f 	ldreq	r0, [ip], -pc, lsr #10
    354c:	06050501 	streq	r0, [r5], -r1, lsl #10
    3550:	09051328 	stmdbeq	r5, {r3, r5, r8, r9, ip}
    3554:	29050106 	stmdbcs	r5, {r1, r2, r8}
    3558:	02040200 	andeq	r0, r4, #0, 4
    355c:	2e730306 	cdpcs	3, 7, cr0, cr3, cr6, {0}
    3560:	02001f05 	andeq	r1, r0, #5, 30
    3564:	05200104 	streq	r0, [r0, #-260]!	@ 0xfffffefc
    3568:	0402001b 	streq	r0, [r2], #-27	@ 0xffffffe5
    356c:	05010601 	streq	r0, [r1, #-1537]	@ 0xfffff9ff
    3570:	0402001f 	streq	r0, [r2], #-31	@ 0xffffffe1
    3574:	05052e01 	streq	r2, [r5, #-3585]	@ 0xfffff1ff
    3578:	17052106 	strne	r2, [r5, -r6, lsl #2]
    357c:	08050106 	stmdaeq	r5, {r1, r2, r8}
    3580:	0607053c 			@ <UNDEFINED> instruction: 0x0607053c
    3584:	0616052f 	ldreq	r0, [r6], -pc, lsr #10
    3588:	0c052001 	stceq	0, cr2, [r5], {1}
    358c:	1e052306 	cdpne	3, 0, cr2, cr5, cr6, {0}
    3590:	0f050106 	svceq	0x00050106
    3594:	0607053c 			@ <UNDEFINED> instruction: 0x0607053c
    3598:	061c052f 	ldreq	r0, [ip], -pc, lsr #10
    359c:	05202001 	streq	r2, [r0, #-1]!
    35a0:	0a030603 	beq	c4db4 <__ROM_SIZE__+0x84db4>
    35a4:	06010501 	streq	r0, [r1], -r1, lsl #10
    35a8:	00010213 	andeq	r0, r1, r3, lsl r2
    35ac:	020b0101 	andeq	r0, fp, #1073741824	@ 0x40000000
    35b0:	00030000 	andeq	r0, r3, r0
    35b4:	000000e1 	andeq	r0, r0, r1, ror #1
    35b8:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
    35bc:	0101000d 	tsteq	r1, sp
    35c0:	00000101 	andeq	r0, r0, r1, lsl #2
    35c4:	00000100 	andeq	r0, r0, r0, lsl #2
    35c8:	6f682f01 	svcvs	0x00682f01
    35cc:	652f656d 	strvs	r6, [pc, #-1389]!	@ 3067 <base_order+0x343>
    35d0:	2f667463 	svccs	0x00667463
    35d4:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    35d8:	6172742d 	cmnvs	r2, sp, lsr #8
    35dc:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
    35e0:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
    35e4:	6c2f6c6c 	stcvs	12, cr6, [pc], #-432	@ 343c <base_order+0x718>
    35e8:	6d2f6269 	sfmvs	f6, 4, [pc, #-420]!	@ 344c <base_order+0x728>
    35ec:	6f6c6d65 	svcvs	0x006c6d65
    35f0:	6f2f0067 	svcvs	0x002f0067
    35f4:	672f7470 			@ <UNDEFINED> instruction: 0x672f7470
    35f8:	612d6363 			@ <UNDEFINED> instruction: 0x612d6363
    35fc:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
    3600:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	@ 0xfffffe44
    3604:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
    3608:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
    360c:	6363672f 	cmnvs	r3, #12320768	@ 0xbc0000
    3610:	6d72612f 	ldfvse	f6, [r2, #-188]!	@ 0xffffff44
    3614:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
    3618:	61652d65 	cmnvs	r5, r5, ror #26
    361c:	312f6962 			@ <UNDEFINED> instruction: 0x312f6962
    3620:	2e322e32 	mrccs	14, 1, r2, cr2, cr2, {1}
    3624:	6e692f31 	mcrvs	15, 3, r2, cr9, cr1, {1}
    3628:	64756c63 	ldrbtvs	r6, [r5], #-3171	@ 0xfffff39d
    362c:	682f0065 	stmdavs	pc!, {r0, r2, r5, r6}	@ <UNPREDICTABLE>
    3630:	2f656d6f 	svccs	0x00656d6f
    3634:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    3638:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
    363c:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
    3640:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
    3644:	68732f72 	ldmdavs	r3!, {r1, r4, r5, r6, r8, r9, sl, fp, sp}^
    3648:	2f6c6c65 	svccs	0x006c6c65
    364c:	2f62696c 	svccs	0x0062696c
    3650:	69727473 	ldmdbvs	r2!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
    3654:	0000676e 	andeq	r6, r0, lr, ror #14
    3658:	6c6d656d 	cfstr64vs	mvdx6, [sp], #-436	@ 0xfffffe4c
    365c:	632e676f 			@ <UNDEFINED> instruction: 0x632e676f
    3660:	00000100 	andeq	r0, r0, r0, lsl #2
    3664:	69647473 	stmdbvs	r4!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
    3668:	672d746e 	strvs	r7, [sp, -lr, ror #8]!
    366c:	682e6363 	stmdavs	lr!, {r0, r1, r5, r6, r8, r9, sp, lr}
    3670:	00000200 	andeq	r0, r0, r0, lsl #4
    3674:	6c6d656d 	cfstr64vs	mvdx6, [sp], #-436	@ 0xfffffe4c
    3678:	682e676f 	stmdavs	lr!, {r0, r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}
    367c:	00000100 	andeq	r0, r0, r0, lsl #2
    3680:	64647473 	strbtvs	r7, [r4], #-1139	@ 0xfffffb8d
    3684:	682e6665 	stmdavs	lr!, {r0, r2, r5, r6, r9, sl, sp, lr}
    3688:	00000200 	andeq	r0, r0, r0, lsl #4
    368c:	69727473 	ldmdbvs	r2!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
    3690:	682e676e 	stmdavs	lr!, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}
    3694:	00000300 	andeq	r0, r0, r0, lsl #6
    3698:	003d0500 	eorseq	r0, sp, r0, lsl #10
    369c:	214c0205 	cmpcs	ip, r5, lsl #4
    36a0:	16030000 	strne	r0, [r3], -r0
    36a4:	13030501 	movwne	r0, #13569	@ 0x3501
    36a8:	01061105 	tsteq	r6, r5, lsl #2
    36ac:	30060305 	andcc	r0, r6, r5, lsl #6
    36b0:	01060605 	tsteq	r6, r5, lsl #12
    36b4:	051d3d05 	ldreq	r3, [sp, #-3333]	@ 0xfffff2fb
    36b8:	05270603 	streq	r0, [r7, #-1539]!	@ 0xfffff9fd
    36bc:	05010614 	streq	r0, [r1, #-1556]	@ 0xfffff9ec
    36c0:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
    36c4:	0501061b 	streq	r0, [r1, #-1563]	@ 0xfffff9e5
    36c8:	03052014 	movweq	r2, #20500	@ 0x5014
    36cc:	1a052106 	bne	14baec <__ROM_SIZE__+0x10baec>
    36d0:	03050106 	movweq	r0, #20742	@ 0x5106
    36d4:	1b053006 	blne	14f6f4 <__ROM_SIZE__+0x10f6f4>
    36d8:	14050106 	strne	r0, [r5], #-262	@ 0xfffffefa
    36dc:	06030520 	streq	r0, [r3], -r0, lsr #10
    36e0:	06140521 	ldreq	r0, [r4], -r1, lsr #10
    36e4:	06030501 	streq	r0, [r3], -r1, lsl #10
    36e8:	061a0521 	ldreq	r0, [sl], -r1, lsr #10
    36ec:	06030501 	streq	r0, [r3], -r1, lsl #10
    36f0:	06060522 	streq	r0, [r6], -r2, lsr #10
    36f4:	06050501 	streq	r0, [r5], -r1, lsl #10
    36f8:	0616053f 			@ <UNDEFINED> instruction: 0x0616053f
    36fc:	06030501 	streq	r0, [r3], -r1, lsl #10
    3700:	20200628 	eorcs	r0, r0, r8, lsr #12
    3704:	052f0105 	streq	r0, [pc, #-261]!	@ 3607 <base_order+0x8e3>
    3708:	7803060a 	stmdavc	r3, {r1, r3, r9, sl}
    370c:	060d0520 	streq	r0, [sp], -r0, lsr #10
    3710:	06050501 	streq	r0, [r5], -r1, lsl #10
    3714:	0616053f 			@ <UNDEFINED> instruction: 0x0616053f
    3718:	06050501 	streq	r0, [r5], -r1, lsl #10
    371c:	0616052f 	ldreq	r0, [r6], -pc, lsr #10
    3720:	13052e01 	movwne	r2, #24065	@ 0x5e01
    3724:	03054206 	movweq	r4, #20998	@ 0x5206
    3728:	06170513 			@ <UNDEFINED> instruction: 0x06170513
    372c:	2e060501 	cfsh32cs	mvfx0, mvfx6, #1
    3730:	40060305 	andmi	r0, r6, r5, lsl #6
    3734:	01061205 	tsteq	r6, r5, lsl #4
    3738:	052e2305 	streq	r2, [lr, #-773]!	@ 0xfffffcfb
    373c:	06052017 			@ <UNDEFINED> instruction: 0x06052017
    3740:	06030520 	streq	r0, [r3], -r0, lsr #10
    3744:	061d0524 	ldreq	r0, [sp], -r4, lsr #10
    3748:	06030501 	streq	r0, [r3], -r1, lsl #10
    374c:	062c052f 	strteq	r0, [ip], -pc, lsr #10
    3750:	06030501 	streq	r0, [r3], -r1, lsl #10
    3754:	0619052f 	ldreq	r0, [r9], -pc, lsr #10
    3758:	06030501 	streq	r0, [r3], -r1, lsl #10
    375c:	062c053e 			@ <UNDEFINED> instruction: 0x062c053e
    3760:	20060501 	andcs	r0, r6, r1, lsl #10
    3764:	05330105 	ldreq	r0, [r3, #-261]!	@ 0xfffffefb
    3768:	051c0605 	ldreq	r0, [ip, #-1541]	@ 0xfffff9fb
    376c:	0501061c 	streq	r0, [r1, #-1564]	@ 0xfffff9e4
    3770:	3c74030c 	ldclcc	3, cr0, [r4], #-48	@ 0xffffffd0
    3774:	061a0540 	ldreq	r0, [sl], -r0, asr #10
    3778:	05580e03 	ldrbeq	r0, [r8, #-3587]	@ 0xfffff1fd
    377c:	17051303 	strne	r1, [r5, -r3, lsl #6]
    3780:	06050106 	streq	r0, [r5], -r6, lsl #2
    3784:	001e052e 	andseq	r0, lr, lr, lsr #10
    3788:	3c010402 	cfstrscc	mvf0, [r1], {2}
    378c:	24060305 	strcs	r0, [r6], #-773	@ 0xfffffcfb
    3790:	01060e05 	tsteq	r6, r5, lsl #28
    3794:	052e1f05 	streq	r1, [lr, #-3845]!	@ 0xfffff0fb
    3798:	0305202c 	movweq	r2, #20524	@ 0x502c
    379c:	19052106 	stmdbne	r5, {r1, r2, r8, sp}
    37a0:	03050106 	movweq	r0, #20742	@ 0x5106
    37a4:	2c053006 	stccs	0, cr3, [r5], {6}
    37a8:	06050106 	streq	r0, [r5], -r6, lsl #2
    37ac:	31010520 	tstcc	r1, r0, lsr #10
    37b0:	1e060505 	cfsh32ne	mvfx0, mvfx6, #5
    37b4:	01061c05 	tsteq	r6, r5, lsl #24
    37b8:	01000602 	tsteq	r0, r2, lsl #12
    37bc:	0001af01 	andeq	sl, r1, r1, lsl #30
    37c0:	90000300 	andls	r0, r0, r0, lsl #6
    37c4:	02000000 	andeq	r0, r0, #0
    37c8:	0d0efb01 	vstreq	d15, [lr, #-4]
    37cc:	01010100 	mrseq	r0, (UNDEF: 17)
    37d0:	00000001 	andeq	r0, r0, r1
    37d4:	01000001 	tsteq	r0, r1
    37d8:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 3724 <base_order+0xa00>
    37dc:	63652f65 	cmnvs	r5, #404	@ 0x194
    37e0:	652f6674 	strvs	r6, [pc, #-1652]!	@ 3174 <base_order+0x450>
    37e4:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
    37e8:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
    37ec:	2f72656e 	svccs	0x0072656e
    37f0:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
    37f4:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
    37f8:	74732f62 	ldrbtvc	r2, [r3], #-3938	@ 0xfffff09e
    37fc:	676e6972 			@ <UNDEFINED> instruction: 0x676e6972
    3800:	706f2f00 	rsbvc	r2, pc, r0, lsl #30
    3804:	63672f74 	cmnvs	r7, #116, 30	@ 0x1d0
    3808:	72612d63 	rsbvc	r2, r1, #6336	@ 0x18c0
    380c:	6f6e2d6d 	svcvs	0x006e2d6d
    3810:	652d656e 	strvs	r6, [sp, #-1390]!	@ 0xfffffa92
    3814:	2f696261 	svccs	0x00696261
    3818:	2f62696c 	svccs	0x0062696c
    381c:	2f636367 	svccs	0x00636367
    3820:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	@ 0xfffffe7c
    3824:	656e6f6e 	strbvs	r6, [lr, #-3950]!	@ 0xfffff092
    3828:	6261652d 	rsbvs	r6, r1, #188743680	@ 0xb400000
    382c:	32312f69 	eorscc	r2, r1, #420	@ 0x1a4
    3830:	312e322e 			@ <UNDEFINED> instruction: 0x312e322e
    3834:	636e692f 	cmnvs	lr, #770048	@ 0xbc000
    3838:	6564756c 	strbvs	r7, [r4, #-1388]!	@ 0xfffffa94
    383c:	74730000 	ldrbtvc	r0, [r3], #-0
    3840:	676e6972 			@ <UNDEFINED> instruction: 0x676e6972
    3844:	0100632e 	tsteq	r0, lr, lsr #6
    3848:	74730000 	ldrbtvc	r0, [r3], #-0
    384c:	66656464 	strbtvs	r6, [r5], -r4, ror #8
    3850:	0200682e 	andeq	r6, r0, #3014656	@ 0x2e0000
    3854:	05000000 	streq	r0, [r0, #-0]
    3858:	02050020 	andeq	r0, r5, #32
    385c:	000021f8 	strdeq	r2, [r0], -r8
    3860:	06011203 	streq	r1, [r1], -r3, lsl #4
    3864:	06030501 	streq	r0, [r3], -r1, lsl #10
    3868:	0a051321 	beq	1484f4 <__ROM_SIZE__+0x1084f4>
    386c:	09051106 	stmdbeq	r5, {r1, r2, r8, ip}
    3870:	06050521 	streq	r0, [r5], -r1, lsr #10
    3874:	06080521 	streq	r0, [r8], -r1, lsr #10
    3878:	060a0501 	streq	r0, [sl], -r1, lsl #10
    387c:	060d051f 			@ <UNDEFINED> instruction: 0x060d051f
    3880:	200a0501 	andcs	r0, sl, r1, lsl #10
    3884:	31060305 	tstcc	r6, r5, lsl #6
    3888:	13060105 	movwne	r0, #24837	@ 0x6105
    388c:	22063005 	andcs	r3, r6, #5
    3890:	05130305 	ldreq	r0, [r3, #-773]	@ 0xfffffcfb
    3894:	05010609 	streq	r0, [r1, #-1545]	@ 0xfffff9f7
    3898:	05210605 	streq	r0, [r1, #-1541]!	@ 0xfffff9fb
    389c:	05010609 	streq	r0, [r1, #-1545]	@ 0xfffff9f7
    38a0:	05210605 	streq	r0, [r1, #-1541]!	@ 0xfffff9fb
    38a4:	05010609 	streq	r0, [r1, #-1545]	@ 0xfffff9f7
    38a8:	051e0610 	ldreq	r0, [lr, #-1552]	@ 0xfffff9f0
    38ac:	0501060a 	streq	r0, [r1, #-1546]	@ 0xfffff9f6
    38b0:	1d052010 	stcne	0, cr2, [r5, #-64]	@ 0xffffffc0
    38b4:	01040200 	mrseq	r0, R12_usr
    38b8:	00100520 	andseq	r0, r0, r0, lsr #10
    38bc:	20010402 	andcs	r0, r1, r2, lsl #8
    38c0:	32060305 	andcc	r0, r6, #335544320	@ 0x14000000
    38c4:	01061205 	tsteq	r6, r5, lsl #4
    38c8:	05210105 	streq	r0, [r1, #-261]!	@ 0xfffffefb
    38cc:	0530062c 	ldreq	r0, [r0, #-1580]!	@ 0xfffff9d4
    38d0:	09051303 	stmdbeq	r5, {r0, r1, r8, r9, ip}
    38d4:	05050106 	streq	r0, [r5, #-262]	@ 0xfffffefa
    38d8:	17052106 	strne	r2, [r5, -r6, lsl #2]
    38dc:	0f050106 	svceq	0x00050106
    38e0:	060a0520 	streq	r0, [sl], -r0, lsr #10
    38e4:	3f03052d 	svccc	0x0003052d
    38e8:	01060905 	tsteq	r6, r5, lsl #18
    38ec:	21060305 	tstcs	r6, r5, lsl #6
    38f0:	13060105 	movwne	r0, #24837	@ 0x6105
    38f4:	06380520 	ldrteq	r0, [r8], -r0, lsr #10
    38f8:	13030522 	movwne	r0, #13602	@ 0x3522
    38fc:	05131313 	ldreq	r1, [r3, #-787]	@ 0xfffffced
    3900:	0501060a 	streq	r0, [r1, #-1546]	@ 0xfffff9f6
    3904:	05052003 	streq	r2, [r5, #-3]
    3908:	03040200 	movweq	r0, #16896	@ 0x4200
    390c:	1c052106 	stfnes	f2, [r5], {6}
    3910:	03040200 	movweq	r0, #16896	@ 0x4200
    3914:	12050106 	andne	r0, r5, #-2147483647	@ 0x80000001
    3918:	03040200 	movweq	r0, #16896	@ 0x4200
    391c:	001a052e 	andseq	r0, sl, lr, lsr #10
    3920:	06030402 	streq	r0, [r3], -r2, lsl #8
    3924:	0011052d 	andseq	r0, r1, sp, lsr #10
    3928:	20010402 	andcs	r0, r1, r2, lsl #8
    392c:	05310305 	ldreq	r0, [r1, #-773]!	@ 0xfffffcfb
    3930:	20130601 	andscs	r0, r3, r1, lsl #12
    3934:	22063005 	andcs	r3, r6, #5
    3938:	13130305 	tstne	r3, #335544320	@ 0x14000000
    393c:	060a0513 			@ <UNDEFINED> instruction: 0x060a0513
    3940:	20030501 	andcs	r0, r3, r1, lsl #10
    3944:	02000505 	andeq	r0, r0, #20971520	@ 0x1400000
    3948:	21060304 	tstcs	r6, r4, lsl #6
    394c:	02001205 	andeq	r1, r0, #1342177280	@ 0x50000000
    3950:	01060304 	tsteq	r6, r4, lsl #6
    3954:	02001a05 	andeq	r1, r0, #20480	@ 0x5000
    3958:	1f060304 	svcne	0x00060304
    395c:	02001105 	andeq	r1, r0, #1073741825	@ 0x40000001
    3960:	05200104 	streq	r0, [r0, #-260]!	@ 0xfffffefc
    3964:	01053203 	tsteq	r5, r3, lsl #4
    3968:	02201306 	eoreq	r1, r0, #402653184	@ 0x18000000
    396c:	01010001 	tsteq	r1, r1

Disassembly of section .debug_str:

00000000 <.debug_str>:
   0:	6d6d6f63 	stclvs	15, cr6, [sp, #-396]!	@ 0xfffffe74
   4:	5f646e61 	svcpl	0x00646e61
   8:	706c6568 	rsbvc	r6, ip, r8, ror #10
   c:	554e4700 	strbpl	r4, [lr, #-1792]	@ 0xfffff900
  10:	37314320 	ldrcc	r4, [r1, -r0, lsr #6]!
  14:	2e323120 	rsfcssp	f3, f2, f0
  18:	20312e32 	eorscs	r2, r1, r2, lsr lr
  1c:	33323032 	teqcc	r2, #50	@ 0x32
  20:	34313230 	ldrtcc	r3, [r1], #-560	@ 0xfffffdd0
  24:	636d2d20 	cmnvs	sp, #32, 26	@ 0x800
  28:	633d7570 	teqvs	sp, #112, 10	@ 0x1c000000
  2c:	6574726f 	ldrbvs	r7, [r4, #-623]!	@ 0xfffffd91
  30:	346d2d78 	strbtcc	r2, [sp], #-3448	@ 0xfffff288
  34:	746d2d20 	strbtvc	r2, [sp], #-3360	@ 0xfffff2e0
  38:	626d7568 	rsbvs	r7, sp, #104, 10	@ 0x1a000000
  3c:	746d2d20 	strbtvc	r2, [sp], #-3360	@ 0xfffff2e0
  40:	3d656e75 	stclcc	14, cr6, [r5, #-468]!	@ 0xfffffe2c
  44:	74726f63 	ldrbtvc	r6, [r2], #-3939	@ 0xfffff09d
  48:	6d2d7865 	stcvs	8, cr7, [sp, #-404]!	@ 0xfffffe6c
  4c:	6d2d2034 	stcvs	0, cr2, [sp, #-208]!	@ 0xffffff30
  50:	616f6c66 	cmnvs	pc, r6, ror #24
  54:	62612d74 	rsbvs	r2, r1, #116, 26	@ 0x1d00
  58:	6f733d69 	svcvs	0x00733d69
  5c:	2d207466 	cfstrscs	mvf7, [r0, #-408]!	@ 0xfffffe68
  60:	6372616d 	cmnvs	r2, #1073741851	@ 0x4000001b
  64:	72613d68 	rsbvc	r3, r1, #104, 26	@ 0x1a00
  68:	6537766d 	ldrvs	r7, [r7, #-1645]!	@ 0xfffff993
  6c:	2d206d2d 	stccs	13, cr6, [r0, #-180]!	@ 0xffffff4c
  70:	62646767 	rsbvs	r6, r4, #27000832	@ 0x19c0000
  74:	674f2d20 	strbvs	r2, [pc, -r0, lsr #26]
  78:	66662d20 	strbtvs	r2, [r6], -r0, lsr #26
  7c:	73656572 	cmnvc	r5, #478150656	@ 0x1c800000
  80:	646e6174 	strbtvs	r6, [lr], #-372	@ 0xfffffe8c
  84:	00676e69 	rsbeq	r6, r7, r9, ror #28
  88:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ ffffffd4 <_STACK_TOP_+0xdfff7fd8>
  8c:	63652f65 	cmnvs	r5, #404	@ 0x194
  90:	652f6674 	strvs	r6, [pc, #-1652]!	@ fffffa24 <_STACK_TOP_+0xdfff7a28>
  94:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
  98:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
  9c:	2f72656e 	svccs	0x0072656e
  a0:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
  a4:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
  a8:	73656d2f 	cmnvc	r5, #3008	@ 0xbc0
  ac:	00632e67 	rsbeq	r2, r3, r7, ror #28
  b0:	76677261 	strbtvc	r7, [r7], -r1, ror #4
  b4:	6d6f6300 	stclvs	3, cr6, [pc, #-0]	@ bc <vector_table+0xbc>
  b8:	646e616d 	strbtvs	r6, [lr], #-365	@ 0xfffffe93
  bc:	6d6f6300 	stclvs	3, cr6, [pc, #-0]	@ c4 <vector_table+0xc4>
  c0:	646e616d 	strbtvs	r6, [lr], #-365	@ 0xfffffe93
  c4:	6d616e5f 	stclvs	14, cr6, [r1, #-380]!	@ 0xfffffe84
  c8:	765f0065 	ldrbvc	r0, [pc], -r5, rrx
  cc:	61637261 	cmnvs	r3, r1, ror #4
  d0:	656d5f72 	strbvs	r5, [sp, #-3954]!	@ 0xfffff08e
  d4:	75006773 	strvc	r6, [r0, #-1907]	@ 0xfffff88d
  d8:	6769736e 	strbvs	r7, [r9, -lr, ror #6]!
  dc:	2064656e 	rsbcs	r6, r4, lr, ror #10
  e0:	72616863 	rsbvc	r6, r1, #6488064	@ 0x630000
  e4:	6f687300 	svcvs	0x00687300
  e8:	75207472 	strvc	r7, [r0, #-1138]!	@ 0xfffffb8e
  ec:	6769736e 	strbvs	r7, [r9, -lr, ror #6]!
  f0:	2064656e 	rsbcs	r6, r4, lr, ror #10
  f4:	00746e69 	rsbseq	r6, r4, r9, ror #28
  f8:	676e6f6c 	strbvs	r6, [lr, -ip, ror #30]!
  fc:	6e6f6c20 	cdpvs	12, 6, cr6, cr15, cr0, {1}
 100:	6e752067 	cdpvs	0, 7, cr2, cr5, cr7, {3}
 104:	6e676973 			@ <UNDEFINED> instruction: 0x6e676973
 108:	69206465 	stmdbvs	r0!, {r0, r2, r5, r6, sl, sp, lr}
 10c:	7300746e 	movwvc	r7, #1134	@ 0x46e
 110:	6d637274 	sfmvs	f7, 2, [r3, #-464]!	@ 0xfffffe30
 114:	6f6c0070 	svcvs	0x006c0070
 118:	6c20676e 	stcvs	7, cr6, [r0], #-440	@ 0xfffffe48
 11c:	20676e6f 	rsbcs	r6, r7, pc, ror #28
 120:	00746e69 	rsbseq	r6, r4, r9, ror #28
 124:	6e697270 	mcrvs	2, 3, r7, cr9, cr0, {3}
 128:	73006674 	movwvc	r6, #1652	@ 0x674
 12c:	74726f68 	ldrbtvc	r6, [r2], #-3944	@ 0xfffff098
 130:	746e6920 	strbtvc	r6, [lr], #-2336	@ 0xfffff6e0
 134:	67726100 	ldrbvs	r6, [r2, -r0, lsl #2]!
 138:	682f0063 	stmdavs	pc!, {r0, r1, r5, r6}	@ <UNPREDICTABLE>
 13c:	2f656d6f 	svccs	0x00656d6f
 140:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
 144:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
 148:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
 14c:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
 150:	63652f72 	cmnvs	r5, #456	@ 0x1c8
 154:	662f6674 			@ <UNDEFINED> instruction: 0x662f6674
 158:	6300626f 	movwvs	r6, #623	@ 0x26f
 15c:	745f646d 	ldrbvc	r6, [pc], #-1133	@ 164 <vector_table+0x164>
 160:	6e6f6c00 	cdpvs	12, 6, cr6, cr15, cr0, {0}
 164:	6f642067 	svcvs	0x00642067
 168:	656c6275 	strbvs	r6, [ip, #-629]!	@ 0xfffffd8b
 16c:	6e697500 	cdpvs	5, 6, cr7, cr9, cr0, {0}
 170:	5f323374 	svcpl	0x00323374
 174:	65720074 	ldrbvs	r0, [r2, #-116]!	@ 0xffffff8c
 178:	5f746573 	svcpl	0x00746573
 17c:	646e6168 	strbtvs	r6, [lr], #-360	@ 0xfffffe98
 180:	0072656c 	rsbseq	r6, r2, ip, ror #10
 184:	61666564 	cmnvs	r6, r4, ror #10
 188:	5f746c75 	svcpl	0x00746c75
 18c:	646e6168 	strbtvs	r6, [lr], #-360	@ 0xfffffe98
 190:	0072656c 	rsbseq	r6, r2, ip, ror #10
 194:	4154535f 	cmpmi	r4, pc, asr r3
 198:	545f4b43 	ldrbpl	r4, [pc], #-2883	@ 1a0 <vector_table+0x1a0>
 19c:	005f504f 	subseq	r5, pc, pc, asr #32
 1a0:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ ec <vector_table+0xec>
 1a4:	63652f65 	cmnvs	r5, #404	@ 0x194
 1a8:	652f6674 	strvs	r6, [pc, #-1652]!	@ fffffb3c <_STACK_TOP_+0xdfff7b40>
 1ac:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
 1b0:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
 1b4:	2f72656e 	svccs	0x0072656e
 1b8:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
 1bc:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
 1c0:	616c702f 	cmnvs	ip, pc, lsr #32
 1c4:	726f6674 	rsbvc	r6, pc, #116, 12	@ 0x7400000
 1c8:	65762f6d 	ldrbvs	r2, [r6, #-3949]!	@ 0xfffff093
 1cc:	726f7463 	rsbvc	r7, pc, #1660944384	@ 0x63000000
 1d0:	6261745f 	rsbvs	r7, r1, #1593835520	@ 0x5f000000
 1d4:	632e656c 			@ <UNDEFINED> instruction: 0x632e656c
 1d8:	63657600 	cmnvs	r5, #0, 12
 1dc:	5f726f74 	svcpl	0x00726f74
 1e0:	6c626174 	stfvse	f6, [r2], #-464	@ 0xfffffe30
 1e4:	61750065 	cmnvs	r5, r5, rrx
 1e8:	695f7472 	ldmdbvs	pc, {r1, r4, r5, r6, sl, ip, sp, lr}^	@ <UNPREDICTABLE>
 1ec:	0074696e 	rsbseq	r6, r4, lr, ror #18
 1f0:	74656775 	strbtvc	r6, [r5], #-1909	@ 0xfffff88b
 1f4:	70750063 	rsbsvc	r0, r5, r3, rrx
 1f8:	00637475 	rsbeq	r7, r3, r5, ror r4
 1fc:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 148 <vector_table+0x148>
 200:	63652f65 	cmnvs	r5, #404	@ 0x194
 204:	652f6674 	strvs	r6, [pc, #-1652]!	@ fffffb98 <_STACK_TOP_+0xdfff7b9c>
 208:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
 20c:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
 210:	2f72656e 	svccs	0x0072656e
 214:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
 218:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
 21c:	616c702f 	cmnvs	ip, pc, lsr #32
 220:	726f6674 	rsbvc	r6, pc, #116, 12	@ 0x7400000
 224:	61752f6d 	cmnvs	r5, sp, ror #30
 228:	752f7472 	strvc	r7, [pc, #-1138]!	@ fffffdbe <_STACK_TOP_+0xdfff7dc2>
 22c:	2e747261 	cdpcs	2, 7, cr7, cr4, cr1, {3}
 230:	61750063 	cmnvs	r5, r3, rrx
 234:	5f327472 	svcpl	0x00327472
 238:	74696e69 	strbtvc	r6, [r9], #-3689	@ 0xfffff197
 23c:	70327500 	eorsvc	r7, r2, r0, lsl #10
 240:	00637475 	rsbeq	r7, r3, r5, ror r4
 244:	65673275 	strbvs	r3, [r7, #-629]!	@ 0xfffffd8b
 248:	2f006374 	svccs	0x00006374
 24c:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
 250:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
 254:	63652f66 	cmnvs	r5, #408	@ 0x198
 258:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
 25c:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
 260:	652f7265 	strvs	r7, [pc, #-613]!	@ 3 <vector_table+0x3>
 264:	2f667463 	svccs	0x00667463
 268:	2f626f66 	svccs	0x00626f66
 26c:	74616c70 	strbtvc	r6, [r1], #-3184	@ 0xfffff390
 270:	6d726f66 	ldclvs	15, cr6, [r2, #-408]!	@ 0xfffffe68
 274:	7261752f 	rsbvc	r7, r1, #197132288	@ 0xbc00000
 278:	61752f74 	cmnvs	r5, r4, ror pc
 27c:	2e327472 	mrccs	4, 1, r7, cr2, cr2, {3}
 280:	682f0063 	stmdavs	pc!, {r0, r1, r5, r6}	@ <UNPREDICTABLE>
 284:	2f656d6f 	svccs	0x00656d6f
 288:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
 28c:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
 290:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
 294:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
 298:	63652f72 	cmnvs	r5, #456	@ 0x1c8
 29c:	662f6674 			@ <UNDEFINED> instruction: 0x662f6674
 2a0:	702f626f 	eorvc	r6, pc, pc, ror #4
 2a4:	6674616c 	ldrbtvs	r6, [r4], -ip, ror #2
 2a8:	2f6d726f 	svccs	0x006d726f
 2ac:	74616c70 	strbtvc	r6, [r1], #-3184	@ 0xfffff390
 2b0:	6d726f66 	ldclvs	15, cr6, [r2, #-408]!	@ 0xfffffe68
 2b4:	7000632e 	andvc	r6, r0, lr, lsr #6
 2b8:	735f6e69 	cmpvc	pc, #1680	@ 0x690
 2bc:	70757465 	rsbsvc	r7, r5, r5, ror #8
 2c0:	74657300 	strbtvc	r7, [r5], #-768	@ 0xfffffd00
 2c4:	6165725f 	cmnvs	r5, pc, asr r2
 2c8:	68635f64 	stmdavs	r3!, {r2, r5, r6, r8, r9, sl, fp, ip, lr}^
 2cc:	00327261 	eorseq	r7, r2, r1, ror #4
 2d0:	5f746573 	svcpl	0x00746573
 2d4:	74697277 	strbtvc	r7, [r9], #-631	@ 0xfffffd89
 2d8:	68635f65 	stmdavs	r3!, {r0, r2, r5, r6, r8, r9, sl, fp, ip, lr}^
 2dc:	73007261 	movwvc	r7, #609	@ 0x261
 2e0:	775f7465 	ldrbvc	r7, [pc, -r5, ror #8]
 2e4:	65746972 	ldrbvs	r6, [r4, #-2418]!	@ 0xfffff68e
 2e8:	6168635f 	cmnvs	r8, pc, asr r3
 2ec:	73003272 	movwvc	r3, #626	@ 0x272
 2f0:	725f7465 	subsvc	r7, pc, #1694498816	@ 0x65000000
 2f4:	5f646165 	svcpl	0x00646165
 2f8:	72616863 	rsbvc	r6, r1, #6488064	@ 0x630000
 2fc:	616c7000 	cmnvs	ip, r0
 300:	726f6674 	rsbvc	r6, pc, #116, 12	@ 0x7400000
 304:	6e695f6d 	cdpvs	15, 6, cr5, cr9, cr13, {3}
 308:	5f007469 	svcpl	0x00007469
 30c:	70726176 	rsbsvc	r6, r2, r6, ror r1
 310:	00726961 	rsbseq	r6, r2, r1, ror #18
 314:	6e697270 	mcrvs	2, 3, r7, cr9, cr0, {3}
 318:	00326674 	eorseq	r6, r2, r4, ror r6
 31c:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 268 <vector_table+0x268>
 320:	63652f65 	cmnvs	r5, #404	@ 0x194
 324:	652f6674 	strvs	r6, [pc, #-1652]!	@ fffffcb8 <_STACK_TOP_+0xdfff7cbc>
 328:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
 32c:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
 330:	2f72656e 	svccs	0x0072656e
 334:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
 338:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
 33c:	6961702f 	stmdbvs	r1!, {r0, r1, r2, r3, r5, ip, sp, lr}^
 340:	00632e72 	rsbeq	r2, r3, r2, ror lr
 344:	5f534541 	svcpl	0x00534541
 348:	5f424345 	svcpl	0x00424345
 34c:	72636e65 	rsbvc	r6, r3, #1616	@ 0x650
 350:	00747079 	rsbseq	r7, r4, r9, ror r0
 354:	5f534541 	svcpl	0x00534541
 358:	5f424345 	svcpl	0x00424345
 35c:	72636564 	rsbvc	r6, r3, #100, 10	@ 0x19000000
 360:	00747079 	rsbseq	r7, r4, r9, ror r0
 364:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 2b0 <vector_table+0x2b0>
 368:	63652f65 	cmnvs	r5, #404	@ 0x194
 36c:	652f6674 	strvs	r6, [pc, #-1652]!	@ fffffd00 <_STACK_TOP_+0xdfff7d04>
 370:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
 374:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
 378:	2f72656e 	svccs	0x0072656e
 37c:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
 380:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
 384:	7365612f 	cmnvc	r5, #-1073741813	@ 0xc000000b
 388:	6200632e 	andvs	r6, r0, #-1207959552	@ 0xb8000000
 38c:	65743436 	ldrbvs	r3, [r4, #-1078]!	@ 0xfffffbca
 390:	5f007478 	svcpl	0x00007478
 394:	61726176 	cmnvs	r2, r6, ror r1
 398:	75007365 	strvc	r7, [r0, #-869]	@ 0xfffffc9b
 39c:	38746e69 	ldmdacc	r4!, {r0, r3, r5, r6, r9, sl, fp, sp, lr}^
 3a0:	4100745f 	tstmi	r0, pc, asr r4
 3a4:	635f5345 	cmpvs	pc, #335544321	@ 0x14000001
 3a8:	41007874 	tstmi	r0, r4, ror r8
 3ac:	695f5345 	ldmdbvs	pc, {r0, r2, r6, r8, r9, ip, lr}^	@ <UNPREDICTABLE>
 3b0:	5f74696e 	svcpl	0x0074696e
 3b4:	00787463 	rsbseq	r7, r8, r3, ror #8
 3b8:	6f636e65 	svcvs	0x00636e65
 3bc:	625f6564 	subsvs	r6, pc, #100, 10	@ 0x19000000
int car_mesg(int argc, char** argv) {
 3c0:	36657361 	strbtcc	r7, [r5], -r1, ror #6
 3c4:	69730034 	ldmdbvs	r3!, {r2, r4, r5}^
    printf("Received the message:");
 3c8:	745f657a 	ldrbvc	r6, [pc], #-1402	@ 3d0 <car_mesg+0x10>
    for (ctr = 1; ctr < argc; ctr++) {
 3cc:	63656400 	cmnvs	r5, #0, 8
        printf(" %s", argv[ctr]);
 3d0:	5f65646f 	svcpl	0x0065646f
 3d4:	65736162 	ldrbvs	r6, [r3, #-354]!	@ 0xfffffe9e
 3d8:	5f003436 	svcpl	0x00003436
    for (ctr = 1; ctr < argc; ctr++) {
 3dc:	64726176 	ldrbtvs	r6, [r2], #-374	@ 0xfffffe8a
    printf("\n");
 3e0:	646f6365 	strbtvs	r6, [pc], #-869	@ 3e8 <car_mesg+0x28>
 3e4:	00343665 	eorseq	r3, r4, r5, ror #12
    if (argc > 0) {
 3e8:	69616c70 	stmdbvs	r1!, {r4, r5, r6, sl, fp, sp, lr}^
}
 3ec:	7865746e 	stmdavc	r5!, {r1, r2, r3, r5, r6, sl, ip, sp, lr}^
        if (strcmp(argv[1], "PING_REPLY") == 0) {
 3f0:	74730074 	ldrbtvc	r0, [r3], #-116	@ 0xffffff8c
 3f4:	6e656c72 	mcrvs	12, 3, r6, cr5, cr2, {3}
            printf("Got a ping reply.\n");
 3f8:	636e6500 	cmnvs	lr, #0, 10
 3fc:	6465646f 	strbtvs	r6, [r5], #-1135	@ 0xfffffb91
            printf("Didn't know how to handle %s\n", argv[1]);
 400:	6f682f00 	svcvs	0x00682f00
 404:	652f656d 	strvs	r6, [pc, #-1389]!	@ fffffe9f <_STACK_TOP_+0xdfff7ea3>
 408:	2f667463 	svccs	0x00667463
 40c:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
 410:	6172742d 	cmnvs	r2, sp, lsr #8
 414:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
 418:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
 41c:	6f662f66 	svcvs	0x00662f66
 420:	61622f62 	cmnvs	r2, r2, ror #30
 424:	34366573 	ldrtcc	r6, [r6], #-1395	@ 0xfffffa8d
void uputc(char c) {
 428:	5f00632e 	svcpl	0x0000632e
  while ((UARTFR >> 5) & 1)
 42c:	65726176 	ldrbvs	r6, [r2, #-374]!	@ 0xfffffe8a
 430:	646f636e 	strbtvs	r6, [pc], #-878	@ 438 <uputc+0x10>
  UART_DR = c;
 434:	00343665 	eorseq	r3, r4, r5, ror #12
  if (c == '\n')
 438:	7261765f 	rsbvc	r7, r1, #99614720	@ 0x5f00000
}
 43c:	646e6573 	strbtvs	r6, [lr], #-1395	@ 0xfffffa8d
    uputc('\r');
 440:	6e69705f 	mcrvs	0, 3, r7, cr9, cr15, {2}
}
 444:	682f0067 	stmdavs	pc!, {r0, r1, r2, r5, r6}	@ <UNPREDICTABLE>
 448:	2f656d6f 	svccs	0x00656d6f
  if (!((UARTFR >> 4) & 1)) return UART_DR;
 44c:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
 450:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
 454:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
 458:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
  return -1;
 45c:	63652f72 	cmnvs	r5, #456	@ 0x1c8
}
 460:	662f6674 			@ <UNDEFINED> instruction: 0x662f6674
 464:	702f626f 	eorvc	r6, pc, pc, ror #4
  UARTCTL = 0;
 468:	2e676e69 	cdpcs	14, 6, cr6, cr7, cr9, {3}
 46c:	61700063 	cmnvs	r0, r3, rrx
  UARTIBRD = 8;
 470:	5f657372 	svcpl	0x00657372
  UARTFBRD = 44;
 474:	656e696c 	strbvs	r6, [lr, #-2412]!	@ 0xfffff694
  UARTCC = 0;
 478:	61686300 	cmnvs	r8, r0, lsl #6
  UARTLCRH = 0x60;
 47c:	6f635f72 	svcvs	0x00635f72
  UARTCTL = 0x301;
 480:	00746e75 	rsbseq	r6, r4, r5, ror lr
}
 484:	72775f5f 	rsbsvc	r5, r7, #380	@ 0x17c
 488:	5f657469 	svcpl	0x00657469
void u2putc(char c) {
 48c:	72616863 	rsbvc	r6, r1, #6488064	@ 0x630000
  while ((UART2FR >> 5) & 1)
 490:	005f5f32 	subseq	r5, pc, r2, lsr pc	@ <UNPREDICTABLE>
 494:	6164655f 	cmnvs	r4, pc, asr r5
  UART2_DR = c;
 498:	5f006174 	svcpl	0x00006174
  if (c == '\n')
 49c:	73726176 	cmnvc	r2, #-2147483619	@ 0x8000001d
}
 4a0:	5f776f68 	svcpl	0x00776f68
    u2putc('\r');
 4a4:	74736968 	ldrbtvc	r6, [r3], #-2408	@ 0xfffff698
}
 4a8:	0079726f 	rsbseq	r7, r9, pc, ror #4
 4ac:	69746361 	ldmdbvs	r4!, {r0, r5, r6, r8, r9, sp, lr}^
  if (!((UART2FR >> 4) & 1)) return UART2_DR;
 4b0:	705f6576 	subsvc	r6, pc, r6, ror r5	@ <UNPREDICTABLE>
 4b4:	706d6f72 	rsbvc	r6, sp, r2, ror pc
 4b8:	5f5f0074 	svcpl	0x005f0074
 4bc:	5f646d63 	svcpl	0x00646d63
  return -1;
 4c0:	63657865 	cmnvs	r5, #6619136	@ 0x650000
}
 4c4:	6174735f 	cmnvs	r4, pc, asr r3
 4c8:	00737574 	rsbseq	r7, r3, r4, ror r5
  UART2CTL = 0;
 4cc:	62726576 	rsbsvs	r6, r2, #494927872	@ 0x1d800000
 4d0:	0065736f 	rsbeq	r7, r5, pc, ror #6
  UART2IBRD = 8;
 4d4:	7261765f 	rsbvc	r7, r1, #99614720	@ 0x5f00000
  UART2FBRD = 44;
 4d8:	5f646d63 	svcpl	0x00646d63
  UART2CC = 0;
 4dc:	63657865 	cmnvs	r5, #6619136	@ 0x650000
  UART2LCRH = 0x60;
 4e0:	6174735f 	cmnvs	r4, pc, asr r3
  UART2CTL = 0x301;
 4e4:	00737574 	rsbseq	r7, r3, r4, ror r5
}
 4e8:	65725f5f 	ldrbvs	r5, [r2, #-3935]!	@ 0xfffff0a1
 4ec:	635f6461 	cmpvs	pc, #1627389952	@ 0x61000000
  RCGCUART |= 3;
 4f0:	5f726168 	svcpl	0x00726168
 4f4:	6e69005f 	mcrvs	0, 3, r0, cr9, cr15, {2}
 4f8:	61697469 	cmnvs	r9, r9, ror #8
 4fc:	65735f6c 	ldrbvs	r5, [r3, #-3948]!	@ 0xfffff094
  RCGCGPIO |= 3;
 500:	00707574 	rsbseq	r7, r0, r4, ror r5
 504:	636d656d 	cmnvs	sp, #457179136	@ 0x1b400000
 508:	5f007970 	svcpl	0x00007970
  GPIODEN = 0x03;
 50c:	68726176 	ldmdavs	r2!, {r1, r2, r4, r5, r6, r8, sp, lr}^
 510:	00706c65 	rsbseq	r6, r0, r5, ror #24
  GPIOAFSEL = 0x03;
 514:	646e6168 	strbtvs	r6, [lr], #-360	@ 0xfffffe98
  GPIOPCTL |= 0x00000011;
 518:	745f656c 	ldrbvc	r6, [pc], #-1388	@ 520 <pin_setup+0x30>
 51c:	61006261 	tstvs	r0, r1, ror #4
 520:	5f6f7475 	svcpl	0x006f7475
  GPIODEN2 = 0x03;
 524:	64616f6c 	strbtvs	r6, [r1], #-3948	@ 0xfffff094
 528:	656c6300 	strbvs	r6, [ip, #-768]!	@ 0xfffffd00
  GPIOAFSEL2 = 0x03;
 52c:	705f7261 	subsvc	r7, pc, r1, ror #4
  GPIOPCTL2 |= 0x00000011;
 530:	706d6f72 	rsbvc	r6, sp, r2, ror pc
 534:	6d630074 	stclvs	0, cr0, [r3, #-464]!	@ 0xfffffe30
 538:	69685f64 	stmdbvs	r8!, {r2, r5, r6, r8, r9, sl, fp, ip, lr}^
}
 53c:	726f7473 	rsbvc	r7, pc, #1929379840	@ 0x73000000
 540:	682f0079 	stmdavs	pc!, {r0, r3, r4, r5, r6}	@ <UNPREDICTABLE>
void platform_init() {
 544:	2f656d6f 	svccs	0x00656d6f
    pin_setup();
 548:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    uart_init();
 54c:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
    uart2_init();
 550:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
    set_read_char(ugetc);
 554:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
    set_read_char2(u2getc);
 558:	68732f72 	ldmdavs	r3!, {r1, r4, r5, r6, r8, r9, sl, fp, sp}^
 55c:	2f6c6c65 	svccs	0x006c6c65
    set_write_char(uputc);
 560:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
    set_write_char2(u2putc);
 564:	68732f6c 	ldmdavs	r3!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
 568:	2e6c6c65 	cdpcs	12, 6, cr6, cr12, cr5, {3}
}
 56c:	6d630063 	stclvs	0, cr0, [r3, #-396]!	@ 0xfffffe74
 570:	74735f64 	ldrbtvc	r5, [r3], #-3940	@ 0xfffff09c
 574:	61680072 	smcvs	32770	@ 0x8002
 578:	656c646e 	strbvs	r6, [ip, #-1134]!	@ 0xfffffb92
int pair(int argc, char** argv) {
 57c:	5f70755f 	svcpl	0x0070755f
    printf("Sending a pair request.\n");
 580:	6f727261 	svcvs	0x00727261
    printf2("FOB_MESG PAIR\n");
 584:	78650077 	stmdavc	r5!, {r0, r1, r2, r4, r5, r6}^
 588:	66006365 	strvs	r6, [r0], -r5, ror #6
}
 58c:	00636e75 	rsbeq	r6, r3, r5, ror lr
 590:	7362655f 	cmnvc	r2, #398458880	@ 0x17c00000
 594:	656d0073 	strbvs	r0, [sp, #-115]!	@ 0xffffff8d
int aes(int argc, char** argv) {
 598:	7465736d 	strbtvc	r7, [r5], #-877	@ 0xfffffc93
    uint8_t key[16] = {0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,
 59c:	435f5f00 	cmpmi	pc, #0, 30
 5a0:	545f444d 	ldrbpl	r4, [pc], #-1101	@ 5a8 <aes+0x10>
 5a4:	454c4241 	strbmi	r4, [ip, #-577]	@ 0xfffffdbf
    uint8_t text[16] = "0123456789abcdef";
 5a8:	4154535f 	cmpmi	r4, pc, asr r3
 5ac:	5f5f5452 	svcpl	0x005f5452
 5b0:	6e696c00 	cdpvs	12, 6, cr6, cr9, cr0, {0}
    AES_init_ctx(&ctx, key);
 5b4:	75625f65 	strbvc	r5, [r2, #-3941]!	@ 0xfffff09b
 5b8:	5f006666 	svcpl	0x00006666
    printf("Encrypting %s using AES\n", text);
 5bc:	61746164 	cmnvs	r4, r4, ror #2
 5c0:	65687300 	strbvs	r7, [r8, #-768]!	@ 0xfffffd00
    AES_ECB_encrypt(&ctx, text);
 5c4:	61006c6c 	tstvs	r0, ip, ror #24
 5c8:	635f6464 	cmpvs	pc, #100, 8	@ 0x64000000
    printf("Encrypted is %s\n", text);
 5cc:	616d6d6f 	cmnvs	sp, pc, ror #26
 5d0:	745f646e 	ldrbvc	r6, [pc], #-1134	@ 5d8 <aes+0x40>
    len = encode_base64(text, 16, b64text);
 5d4:	69685f6f 	stmdbvs	r8!, {r0, r1, r2, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
 5d8:	726f7473 	rsbvc	r7, pc, #1929379840	@ 0x73000000
 5dc:	65670079 	strbvs	r0, [r7, #-121]!	@ 0xffffff87
    b64text[len] = '\n';
 5e0:	75665f74 	strbvc	r5, [r6, #-3956]!	@ 0xfffff08c
 5e4:	6974636e 	ldmdbvs	r4!, {r1, r2, r3, r5, r6, r8, r9, sp, lr}^
 5e8:	615f6e6f 	cmpvs	pc, pc, ror #28
    printf("Encrypted is %s\n", text);
 5ec:	00726464 	rsbseq	r6, r2, r4, ror #8
 5f0:	61746f74 	cmnvs	r4, r4, ror pc
    printf2("FOB_MESG AESB64 %s\n", b64text);
 5f4:	756e5f6c 	strbvc	r5, [lr, #-3948]!	@ 0xfffff094
 5f8:	6f635f6d 	svcvs	0x00635f6d
    AES_ECB_decrypt(&ctx, text);
 5fc:	6e616d6d 	cdpvs	13, 6, cr6, cr1, cr13, {3}
 600:	63007364 	movwvs	r7, #868	@ 0x364
    printf("Which should decrypt to %s \n", text);
 604:	655f646d 	ldrbvs	r6, [pc, #-1133]	@ 19f <vector_table+0x19f>
 608:	005f646e 	subseq	r6, pc, lr, ror #8
}
 60c:	55415f5f 	strbpl	r5, [r1, #-3935]	@ 0xfffff0a1
 610:	545f4f54 	ldrbpl	r4, [pc], #-3924	@ 618 <aes+0x80>
 614:	454c4241 	strbmi	r4, [ip, #-577]	@ 0xfffffdbf
 618:	4154535f 	cmpmi	r4, pc, asr r3
 61c:	5f5f5452 	svcpl	0x005f5452
 620:	6f6f6c00 	svcvs	0x006f6c00
 624:	70730070 	rsbsvc	r0, r3, r0, ror r0
 628:	61696365 	cmnvs	r9, r5, ror #6
int encode64(int argc, char** argv) {
 62c:	656b5f6c 	strbvs	r5, [fp, #-3948]!	@ 0xfffff094
    if (argc > 1) {
 630:	6d630079 	stclvs	0, cr0, [r3, #-484]!	@ 0xfffffe1c
 634:	75625f64 	strbvc	r5, [r2, #-3940]!	@ 0xfffff09c
        len = strlen(argv[1]);
 638:	5f006666 	svcpl	0x00006666
 63c:	62726176 	rsbsvs	r6, r2, #-2147483619	@ 0x8000001d
        if (len < MAX64LENGTH) {
 640:	646c6975 	strbtvs	r6, [ip], #-2421	@ 0xfffff68b
            len = encode_base64(argv[1], len, encoded);
 644:	666e695f 			@ <UNDEFINED> instruction: 0x666e695f
 648:	7270006f 	rsbsvc	r0, r0, #111	@ 0x6f
            printf("Encoded %s as %s with %d characters\n", argv[1], encoded, len);
 64c:	78696665 	stmdavc	r9!, {r0, r2, r5, r6, r9, sl, sp, lr}^
 650:	74616d5f 	strbtvc	r6, [r1], #-3423	@ 0xfffff2a1
 654:	5f006863 	svcpl	0x00006863
            printf("String exceeds max length of %d characters", MAX64LENGTH);
 658:	6c6f6f42 	stclvs	15, cr6, [pc], #-264	@ 558 <platform_init+0x14>
 65c:	73616c00 	cmnvc	r1, #0, 24
 660:	616d5f74 	smcvs	54772	@ 0xd5f4
        printf("Usage is 'encode64 string'\n");
 664:	00686374 	rsbeq	r6, r8, r4, ror r3
}
 668:	70657270 	rsbvc	r7, r5, r0, ror r2
 66c:	5f646e65 	svcpl	0x00646e65
 670:	6d6f7270 	sfmvs	f7, 2, [pc, #-448]!	@ 4b8 <u2getc+0x8>
 674:	64007470 	strvs	r7, [r0], #-1136	@ 0xfffffb90
 678:	74656c65 	strbtvc	r6, [r5], #-3173	@ 0xfffff39b
int decode64(int argc, char** argv) {
 67c:	5f5f0065 	svcpl	0x005f0065
    if (argc > 1) {
 680:	74697277 	strbtvc	r7, [r9], #-631	@ 0xfffffd89
 684:	68635f65 	stmdavs	r3!, {r0, r2, r5, r6, r8, r9, sl, fp, ip, lr}^
        int len = strlen(argv[1]);
 688:	5f5f7261 	svcpl	0x005f7261
 68c:	6e616800 	cdpvs	8, 6, cr6, cr1, cr0, {0}
        if (len < MAX64LENGTH-1) {
 690:	5f656c64 	svcpl	0x00656c64
                printf("encoded string is %d characters\n", len);
 694:	6e776f64 	cdpvs	15, 7, cr6, cr7, cr4, {3}
 698:	7272615f 	rsbsvc	r6, r2, #-1073741801	@ 0xc0000017
                len = decode_base64(argv[1], len, plaintext);
 69c:	6d00776f 	stcvs	7, cr7, [r0, #-444]	@ 0xfffffe44
 6a0:	68637461 	stmdavs	r3!, {r0, r5, r6, sl, ip, sp, lr}^
 6a4:	756f665f 	strbvc	r6, [pc, #-1631]!	@ 4d <vector_table+0x4d>
                printf("decoded string is %d characters\n", len);
 6a8:	6d00646e 	cfstrsvs	mvf6, [r0, #-440]	@ 0xfffffe48
 6ac:	68637461 	stmdavs	r3!, {r0, r5, r6, sl, ip, sp, lr}^
                printf("Adding NULL at the end of decoded string\n");
 6b0:	756f635f 	strbvc	r6, [pc, #-863]!	@ 359 <vector_table+0x359>
                plaintext[len] = '\n';
 6b4:	6500746e 	strvs	r7, [r0, #-1134]	@ 0xfffffb92
 6b8:	5f636578 	svcpl	0x00636578
 6bc:	6f747561 	svcvs	0x00747561
 6c0:	646d635f 	strbtvs	r6, [sp], #-863	@ 0xfffffca1
                printf("Decoded %s as: %s\n", argv[1], plaintext);
 6c4:	75630073 	strbvc	r0, [r3, #-115]!	@ 0xffffff8d
 6c8:	635f7272 	cmpvs	pc, #536870919	@ 0x20000007
 6cc:	616d6d6f 	cmnvs	sp, pc, ror #26
            printf("String exceeds max length of %d characters", MAX64LENGTH);
 6d0:	705f646e 	subsvc	r6, pc, lr, ror #8
 6d4:	65007274 	strvs	r7, [r0, #-628]	@ 0xfffffd8c
        printf("Usage is 'decode64 string'\n");
 6d8:	695f646e 	ldmdbvs	pc, {r1, r2, r3, r5, r6, sl, sp, lr}^	@ <UNPREDICTABLE>
 6dc:	7865646e 	stmdavc	r5!, {r1, r2, r3, r5, r6, sl, sp, lr}^
}
 6e0:	65786500 	ldrbvs	r6, [r8, #-1280]!	@ 0xfffffb00
 6e4:	65747563 	ldrbvs	r7, [r4, #-1379]!	@ 0xfffffa9d
 6e8:	67726100 	ldrbvs	r6, [r2, -r0, lsl #2]!
 6ec:	6e656d75 	mcrvs	13, 3, r6, cr5, cr5, {3}
 6f0:	69735f74 	ldmdbvs	r3!, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
 6f4:	5f00657a 	svcpl	0x0000657a
 6f8:	6863655f 	stmdavs	r3!, {r0, r1, r2, r3, r4, r6, r8, sl, sp, lr}^
int send_ping(int argc, char** argv) {
 6fc:	6562006f 	strbvs	r0, [r2, #-111]!	@ 0xffffff91
    printf("Pinging the car.\n");
 700:	6e695f67 	cdpvs	15, 6, cr5, cr9, cr7, {3}
    printf2("FOB_MESG PING\n");
 704:	00786564 	rsbseq	r6, r8, r4, ror #10
 708:	65725f5f 	ldrbvs	r5, [r2, #-3935]!	@ 0xfffff0a1
}
 70c:	635f6461 	cmpvs	pc, #1627389952	@ 0x61000000
 710:	32726168 	rsbscc	r6, r2, #104, 2
 714:	5f005f5f 	svcpl	0x00005f5f
void __attribute__((optimize("O0"), weak)) initial_setup(void) {
 718:	78657465 	stmdavc	r5!, {r0, r2, r5, r6, sl, ip, sp, lr}^
 71c:	625f0074 	subsvs	r0, pc, #116	@ 0x74
  char *src = &_etext, *dst = &_data;
 720:	66007373 			@ <UNDEFINED> instruction: 0x66007373
 724:	5f6c6c75 	svcpl	0x006c6c75
  if (dst != src)
 728:	73746573 	cmnvc	r4, #482344960	@ 0x1cc00000
 72c:	73616200 	cmnvc	r1, #0, 4
    while (dst < &_edata) *(dst++) = *(src++);
 730:	5f343665 	svcpl	0x00343665
 734:	625f6f74 	subsvs	r6, pc, #116, 30	@ 0x1d0
 738:	72616e69 	rsbvc	r6, r1, #1680	@ 0x690
 73c:	756f0079 	strbvc	r0, [pc, #-121]!	@ 6cb <decode64+0x4f>
 740:	74757074 	ldrbtvc	r7, [r5], #-116	@ 0xffffff8c
 744:	706e6900 	rsbvc	r6, lr, r0, lsl #18
  for (dst = &_bss; dst < &_ebss; dst++) *dst = 0;
 748:	6c5f7475 	cfldrdvs	mvd7, [pc], {117}	@ 0x75
 74c:	74676e65 	strbtvc	r6, [r7], #-3685	@ 0xfffff19b
 750:	6e650068 	cdpvs	0, 6, cr0, cr5, cr8, {3}
 754:	65646f63 	strbvs	r6, [r4, #-3939]!	@ 0xfffff09d
 758:	7361625f 	cmnvc	r1, #-268435451	@ 0xf0000005
 75c:	5f343665 	svcpl	0x00343665
 760:	676e656c 	strbvs	r6, [lr, -ip, ror #10]!
  platform_init();
 764:	6f006874 	svcvs	0x00006874
}
 768:	75707475 	ldrbvc	r7, [r0, #-1141]!	@ 0xfffffb8b
 76c:	656c5f74 	strbvs	r5, [ip, #-3956]!	@ 0xfffff08c
 770:	6874676e 	ldmdavs	r4!, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}^
 774:	706e6900 	rsbvc	r6, lr, r0, lsl #18
 778:	2f007475 	svccs	0x00007475
 77c:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
 780:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
static void delete(void) {
 784:	63652f66 	cmnvs	r5, #408	@ 0x198
  __write_char__(BACK_SPACE);
 788:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
 78c:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
  __write_char__(SPACE);
 790:	732f7265 			@ <UNDEFINED> instruction: 0x732f7265
  __write_char__(BACK_SPACE);
 794:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
 798:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
}
 79c:	7361622f 	cmnvc	r1, #-268435454	@ 0xf0000002
static void clear_prompt(int char_count) {
 7a0:	2f343665 	svccs	0x00343665
  while (char_count) {
 7a4:	65736162 	ldrbvs	r6, [r3, #-354]!	@ 0xfffffe9e
    delete ();
 7a8:	632e3436 			@ <UNDEFINED> instruction: 0x632e3436
  while (char_count) {
 7ac:	6e696200 	cdpvs	2, 6, cr6, cr9, cr0, {0}
}
 7b0:	5f797261 	svcpl	0x00797261
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
 7b4:	625f6f74 	subsvs	r6, pc, #116, 30	@ 0x1d0
    auto_load[i].command(0, NULL);
 7b8:	36657361 	strbtcc	r7, [r5], -r1, ror #6
 7bc:	74730034 	ldrbtvc	r0, [r3], #-52	@ 0xffffffcc
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
 7c0:	00747261 	rsbseq	r7, r4, r1, ror #4
 7c4:	6f636564 	svcvs	0x00636564
 7c8:	625f6564 	subsvs	r6, pc, #100, 10	@ 0x19000000
 7cc:	36657361 	strbtcc	r7, [r5], -r1, ror #6
 7d0:	656c5f34 	strbvs	r5, [ip, #-3892]!	@ 0xfffff0cc
}
 7d4:	6874676e 	ldmdavs	r4!, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}^
static int show_history(int argc, char **argv) {
 7d8:	675f5f00 	ldrbvs	r5, [pc, -r0, lsl #30]
  uint32_t end_index = total_num_commands-1;
 7dc:	5f63756e 	svcpl	0x0063756e
  if (total_num_commands > NUM_HISTORY_ENTRIES) {
 7e0:	6c5f6176 	ldfvse	f6, [pc], {118}	@ 0x76
 7e4:	00747369 	rsbseq	r7, r4, r9, ror #6
    beg_index = total_num_commands - NUM_HISTORY_ENTRIES;
 7e8:	7374756f 	cmnvc	r4, #465567744	@ 0x1bc00000
 7ec:	6c007274 	sfmvs	f7, 4, [r0], {116}	@ 0x74
  uint32_t beg_index = 0;
 7f0:	69646165 	stmdbvs	r4!, {r0, r2, r5, r6, r8, sp, lr}^
    printf("%s\n", cmd_history[index % NUM_HISTORY_ENTRIES]);
 7f4:	7a5f676e 	bvc	17da5b4 <__ROM_SIZE__+0x179a5b4>
 7f8:	5f6f7265 	svcpl	0x006f7265
 7fc:	6f6e6769 	svcvs	0x006e6769
 800:	00646572 	rsbeq	r6, r4, r2, ror r5
  for (uint32_t index = beg_index; index <= end_index; ++index) {
 804:	53524150 	cmppl	r2, #80, 2
}
 808:	4d465f45 	stclmi	15, cr5, [r6, #-276]	@ 0xfffffeec
 80c:	54535f54 	ldrbpl	r5, [r3], #-3924	@ 0xfffff0ac
 810:	65680052 	strbvs	r0, [r8, #-82]!	@ 0xffffffae
 814:	62617478 	rsbvs	r7, r1, #120, 8	@ 0x78000000
int cmd_exec_status(int argc, char **argv) {
 818:	6e00656c 	cfsh32vs	mvfx6, mvfx0, #60
  printf("%d\n", __cmd_exec_status);
 81c:	6c5f6d75 	mrrcvs	13, 7, r6, pc, cr5	@ <UNPREDICTABLE>
 820:	6c006e65 	stcvs	14, cr6, [r0], {101}	@ 0x65
 824:	756f635f 	strbvc	r6, [pc, #-863]!	@ 4cd <uart2_init+0x1>
}
 828:	5f00746e 	svcpl	0x0000746e
 82c:	5f61765f 	svcpl	0x0061765f
 830:	7473696c 	ldrbtvc	r6, [r3], #-2412	@ 0xfffff694
static int build_info(int argc, char **argv) {
 834:	69727000 	ldmdbvs	r2!, {ip, sp, lr}^
  printf("Build: [" SHELL_VERSION ":" USER_REPO_VERSION "] - [" BUILD_USER
 838:	5f66746e 	svcpl	0x0066746e
}
 83c:	74617473 	strbtvc	r7, [r1], #-1139	@ 0xfffffb8d
 840:	74730065 	ldrbtvc	r0, [r3], #-101	@ 0xffffff9b
static void execute(int argc, char **argv) {
 844:	5f747261 	svcpl	0x00747261
 848:	00746962 	rsbseq	r6, r4, r2, ror #18
  for (int i = 0; table[i].command_name != NULL; i++) {
 84c:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 798 <delete+0x14>
 850:	63652f65 	cmnvs	r5, #404	@ 0x194
 854:	652f6674 	strvs	r6, [pc, #-1652]!	@ 1e8 <vector_table+0x1e8>
 858:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
 85c:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
    if (strcmp(argv[0], table[i].command_name) == 0) {
 860:	2f72656e 	svccs	0x0072656e
 864:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
      __cmd_exec_status = table[i].command(argc, &argv[0]);
 868:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
 86c:	72702f62 	rsbsvc	r2, r0, #392	@ 0x188
 870:	66746e69 	ldrbtvs	r6, [r4], -r9, ror #28
 874:	6972702f 	ldmdbvs	r2!, {r0, r1, r2, r3, r5, ip, sp, lr}^
 878:	2e66746e 	cdpcs	4, 6, cr7, cr6, cr14, {3}
    printf("\"%s\": command not found. Use \"help\" to list all command.\n",
 87c:	61760063 	cmnvs	r6, r3, rrx
 880:	0065756c 	rsbeq	r7, r5, ip, ror #10
    __cmd_exec_status = -1;
 884:	6e697270 	mcrvs	2, 3, r7, cr9, cr0, {3}
 888:	6e5f6674 	mrcvs	6, 2, r6, cr15, cr4, {3}
 88c:	65626d75 	strbvs	r6, [r2, #-3445]!	@ 0xfffff28b
}
 890:	43007372 	movwmi	r7, #882	@ 0x372
 894:	4b434548 	blmi	10d1dbc <__ROM_SIZE__+0x1091dbc>
 898:	0048435f 	subeq	r4, r8, pc, asr r3
 89c:	73677261 	cmnvc	r7, #268435462	@ 0x10000006
int help(int argc, char **argv) {
 8a0:	615f5f00 	cmpvs	pc, r0, lsl #30
  if (argc > 1 && (strcmp(argv[1], "-l")==0)) {
 8a4:	72700070 	rsbsvc	r0, r0, #112	@ 0x70
 8a8:	66746e69 	ldrbtvs	r6, [r4], -r9, ror #28
 8ac:	74735f32 	ldrbtvc	r5, [r3], #-3890	@ 0xfffff0ce
 8b0:	00657461 	rsbeq	r7, r5, r1, ror #8
    printf("use: help -l for list only.\n\n");
 8b4:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 800 <show_history+0x28>
  bool verbose = true;
 8b8:	63652f65 	cmnvs	r5, #404	@ 0x194
    verbose = false;
 8bc:	652f6674 	strvs	r6, [pc, #-1652]!	@ 250 <vector_table+0x250>
    printf("\n");
 8c0:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
    i++;
 8c4:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
  while (table[i].command_name != NULL) {
 8c8:	2f72656e 	svccs	0x0072656e
 8cc:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
 8d0:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
    printf(table[i].command_name);
 8d4:	72702f62 	rsbsvc	r2, r0, #392	@ 0x188
    if (verbose) {
 8d8:	66746e69 	ldrbtvs	r6, [r4], -r9, ror #28
      printf("\n\t");
 8dc:	6972702f 	ldmdbvs	r2!, {r0, r1, r2, r3, r5, ip, sp, lr}^
      printf(table[i].command_help);
 8e0:	3266746e 	rsbcc	r7, r6, #1845493760	@ 0x6e000000
 8e4:	7000632e 	andvc	r6, r0, lr, lsr #6
 8e8:	746e6972 	strbtvc	r6, [lr], #-2418	@ 0xfffff68e
    verbose = false;
 8ec:	6e5f3266 	cdpvs	2, 5, cr3, cr15, cr6, {3}
}
 8f0:	65626d75 	strbvs	r6, [r2, #-3445]!	@ 0xfffff28b
 8f4:	68007372 	stmdavs	r0, {r1, r4, r5, r6, r8, r9, ip, sp, lr}
 8f8:	61747865 	cmnvs	r4, r5, ror #16
 8fc:	32656c62 	rsbcc	r6, r5, #25088	@ 0x6200
 900:	74756f00 	ldrbtvc	r6, [r5], #-3840	@ 0xfffff100
 904:	32727473 	rsbscc	r7, r2, #1929379840	@ 0x73000000
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
 908:	61765f00 	cmnvs	r6, r0, lsl #30
static void add_command_to_history(const char *cmd_str) {
 90c:	32337772 	eorscc	r7, r3, #29884416	@ 0x1c80000
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
 910:	7469625f 	strbtvc	r6, [r9], #-607	@ 0xfffffda1
 914:	6f682f00 	svcvs	0x00682f00
  int index = total_num_commands % NUM_HISTORY_ENTRIES;
 918:	652f656d 	strvs	r6, [pc, #-1389]!	@ 3b3 <vector_table+0x3b3>
 91c:	2f667463 	svccs	0x00667463
 920:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
 924:	6172742d 	cmnvs	r2, sp, lsr #8
  memcpy(&cmd_history[index], cmd_str, LINE_BUFF_SIZE);
 928:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
 92c:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
 930:	6c2f6c6c 	stcvs	12, cr6, [pc], #-432	@ 788 <delete+0x4>
 934:	752f6269 	strvc	r6, [pc, #-617]!	@ 6d3 <decode64+0x57>
  total_num_commands++;
 938:	736c6974 	cmnvc	ip, #116, 18	@ 0x1d0000
  curr_command_ptr = total_num_commands;
 93c:	6974752f 	ldmdbvs	r4!, {r0, r1, r2, r3, r5, r8, sl, ip, sp, lr}^
 940:	632e736c 			@ <UNDEFINED> instruction: 0x632e736c
 944:	6e697500 	cdpvs	5, 6, cr7, cr9, cr0, {0}
 948:	72747074 	rsbsvc	r7, r4, #116	@ 0x74
 94c:	5f00745f 	svcpl	0x0000745f
static int parse_line(char **argv, char *line_buff, int argument_size) {
 950:	72726176 	rsbsvc	r6, r2, #-2147483619	@ 0x8000001d
 954:	5f646165 	svcpl	0x00646165
  int length = strlen(line_buff);
 958:	006d656d 	rsbeq	r6, sp, sp, ror #10
 95c:	7261765f 	rsbvc	r7, r1, #99614720	@ 0x5f00000
  int argc = 0;
 960:	00323377 	eorseq	r3, r2, r7, ror r3
         pos++)
 964:	5f746962 	svcpl	0x00746962
    for (; line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
 968:	00636f6c 	rsbeq	r6, r3, ip, ror #30
 96c:	5f746962 	svcpl	0x00746962
 970:	006c6176 	rsbeq	r6, ip, r6, ror r1
 974:	67617375 			@ <UNDEFINED> instruction: 0x67617375
    if (line_buff[pos] == '\t' || line_buff[pos] == SPACE)
 978:	765f0065 	ldrbvc	r0, [pc], -r5, rrx
 97c:	33727261 	cmncc	r2, #268435462	@ 0x10000006
      line_buff[pos] = END_OF_LINE;
 980:	765f0032 			@ <UNDEFINED> instruction: 0x765f0032
  while (pos <= length) {
 984:	33727261 	cmncc	r2, #268435462	@ 0x10000006
    if (line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
 988:	69625f32 	stmdbvs	r2!, {r1, r4, r5, r8, r9, sl, fp, ip, lr}^
 98c:	74610074 	strbtvc	r0, [r1], #-116	@ 0xffffff8c
 990:	6100686f 	tstvs	r0, pc, ror #16
 994:	00696f74 	rsbeq	r6, r9, r4, ror pc
      argv[argc++] = &line_buff[pos];
 998:	5f534541 	svcpl	0x00534541
 99c:	74696e69 	strbtvc	r6, [r9], #-3689	@ 0xfffff197
}
 9a0:	7874635f 	ldmdavc	r4!, {r0, r1, r2, r3, r4, r6, r8, r9, sp, lr}^
static int prefix_match(char *sub, int len, const char *str) {
 9a4:	0076695f 	rsbseq	r6, r6, pc, asr r9
 9a8:	6d697478 	cfstrdvs	mvd7, [r9, #-480]!	@ 0xfffffe20
  if (sub == NULL || str == NULL || len <= 0 || len > strlen(str)) {
 9ac:	65740065 	ldrbvs	r0, [r4, #-101]!	@ 0xffffff9b
 9b0:	0061706d 	rsbeq	r7, r1, sp, rrx
 9b4:	706d6574 	rsbvc	r6, sp, r4, ror r5
 9b8:	6f747300 	svcvs	0x00747300
  for (int i = 0; i<len; ++i) {
 9bc:	654e6572 	strbvs	r6, [lr, #-1394]	@ 0xfffffa8e
 9c0:	76497478 			@ <UNDEFINED> instruction: 0x76497478
    if (sub[i] != str[i]) {
 9c4:	62737200 	rsbsvs	r7, r3, #0, 4
 9c8:	4100786f 	tstmi	r0, pc, ror #16
  for (int i = 0; i<len; ++i) {
 9cc:	435f5345 	cmpmi	pc, #335544321	@ 0x14000001
}
 9d0:	655f4342 	ldrbvs	r4, [pc, #-834]	@ 696 <decode64+0x1a>
  return TRUE;
 9d4:	7972636e 	ldmdbvc	r2!, {r1, r2, r3, r5, r6, r8, r9, sp, lr}^
      return FALSE;
 9d8:	625f7470 	subsvs	r7, pc, #112, 8	@ 0x70000000
}
 9dc:	65666675 	strbvs	r6, [r6, #-1653]!	@ 0xfffff98b
static void handle_up_arrow(char *cmd_buff, int *char_count) {
 9e0:	682f0072 	stmdavs	pc!, {r1, r4, r5, r6}	@ <UNPREDICTABLE>
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
 9e4:	2f656d6f 	svccs	0x00656d6f
 9e8:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
 9ec:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
 9f0:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
      curr_command_ptr == 0) {
 9f4:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
 9f8:	68732f72 	ldmdavs	r3!, {r1, r4, r5, r6, r8, r9, sl, fp, sp}^
    printf("%s", cmd_buff);
 9fc:	2f6c6c65 	svccs	0x006c6c65
 a00:	2f62696c 	svccs	0x0062696c
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
 a04:	796e6974 	stmdbvc	lr!, {r2, r4, r5, r6, r8, fp, sp, lr}^
 a08:	7365612d 	cmnvc	r5, #1073741835	@ 0x4000000b
  curr_command_ptr--;
 a0c:	7365612f 	cmnvc	r5, #-1073741813	@ 0xc000000b
 a10:	4900632e 	stmdbmi	r0, {r1, r2, r3, r5, r8, r9, sp, lr}
 a14:	6943766e 	stmdbvs	r3, {r1, r2, r3, r5, r6, r9, sl, ip, sp, lr}^
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
 a18:	72656870 	rsbvc	r6, r5, #112, 16	@ 0x700000
 a1c:	74387500 	ldrtvc	r7, [r8], #-1280	@ 0xfffffb00
 a20:	7300706d 	movwvc	r7, #109	@ 0x6d
 a24:	65746174 	ldrbvs	r6, [r4, #-372]!	@ 0xfffffe8c
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
 a28:	4100745f 	tstmi	r0, pc, asr r4
 a2c:	435f5345 	cmpmi	pc, #335544321	@ 0x14000001
 a30:	645f4342 	ldrbvs	r4, [pc], #-834	@ a38 <handle_up_arrow+0x5a>
  *char_count = strlen(cmd_buff);
 a34:	79726365 	ldmdbvc	r2!, {r0, r2, r5, r6, r8, r9, sp, lr}^
 a38:	625f7470 	subsvs	r7, pc, #112, 8	@ 0x70000000
  printf("%s", cmd_buff);
 a3c:	65666675 	strbvs	r6, [r6, #-1653]!	@ 0xfffff98b
 a40:	6e490072 	mcrvs	0, 2, r0, cr9, cr2, {3}
 a44:	78694d76 	stmdavc	r9!, {r1, r2, r4, r5, r6, r8, sl, fp, lr}^
 a48:	756c6f43 	strbvc	r6, [ip, #-3907]!	@ 0xfffff0bd
 a4c:	00736e6d 	rsbseq	r6, r3, sp, ror #28
static void handle_down_arrow(char *cmd_buff, int *char_count) {
 a50:	52646441 	rsbpl	r6, r4, #1090519040	@ 0x41000000
 a54:	646e756f 	strbtvs	r7, [lr], #-1391	@ 0xfffffa91
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
 a58:	0079654b 	rsbseq	r6, r9, fp, asr #10
 a5c:	5f534541 	svcpl	0x00534541
  *char_count = 0;
 a60:	5f525443 	svcpl	0x00525443
  if (curr_command_ptr == total_num_commands) return;
 a64:	79726378 	ldmdbvc	r2!, {r3, r4, r5, r6, r8, r9, sp, lr}^
 a68:	625f7470 	subsvs	r7, pc, #112, 8	@ 0x70000000
 a6c:	65666675 	strbvs	r6, [r6, #-1653]!	@ 0xfffff98b
  curr_command_ptr++;
 a70:	6f720072 	svcvs	0x00720072
 a74:	00646e75 	rsbeq	r6, r4, r5, ror lr
 a78:	6e6f6352 	mcrvs	3, 3, r6, cr15, cr2, {2}
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
 a7c:	53454100 	movtpl	r4, #20736	@ 0x5100
 a80:	7874635f 	ldmdavc	r4!, {r0, r1, r2, r3, r4, r6, r8, r9, sp, lr}^
 a84:	7465735f 	strbtvc	r7, [r5], #-863	@ 0xfffffca1
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
 a88:	0076695f 	rsbseq	r6, r6, pc, asr r9
 a8c:	53766e49 	cmnpl	r6, #1168	@ 0x490
 a90:	74666968 	strbtvc	r6, [r6], #-2408	@ 0xfffff698
 a94:	73776f52 	cmnvc	r7, #328	@ 0x148
  *char_count = strlen(cmd_buff);
 a98:	79654b00 	stmdbvc	r5!, {r8, r9, fp, lr}^
 a9c:	61707845 	cmnvs	r0, r5, asr #16
  printf("%s", cmd_buff);
 aa0:	6f69736e 	svcvs	0x0069736e
 aa4:	6e49006e 	cdpvs	0, 4, cr0, cr9, cr14, {3}
}
 aa8:	62755376 	rsbsvs	r5, r5, #-671088639	@ 0xd8000001
 aac:	65747942 	ldrbvs	r7, [r4, #-2370]!	@ 0xfffff6be
void set_read_char(int (*func)(void)) { __read_char__ = func; }
 ab0:	6f580073 	svcvs	0x00580073
 ab4:	74695772 	strbtvc	r5, [r9], #-1906	@ 0xfffff88e
 ab8:	00764968 	rsbseq	r4, r6, r8, ror #18
void set_read_char2(int (*func)(void)) { __read_char2__ = func; }
 abc:	78706d74 	ldmdavc	r0!, {r2, r4, r5, r6, r8, sl, fp, sp, lr}^
 ac0:	706d7400 	rsbvc	r7, sp, r0, lsl #8
 ac4:	66670079 			@ <UNDEFINED> instruction: 0x66670079
void set_write_char(void (*func)(char)) { __write_char__ = func; }
 ac8:	696f7032 	stmdbvs	pc!, {r1, r4, r5, ip, sp, lr}^	@ <UNPREDICTABLE>
 acc:	735f746e 	cmpvc	pc, #1845493760	@ 0x6e000000
 ad0:	7a5f7465 	bvc	17ddc6c <__ROM_SIZE__+0x179dc6c>
void set_write_char2(void (*func)(char)) { __write_char2__ = func; }
 ad4:	006f7265 	rsbeq	r7, pc, r5, ror #4
 ad8:	796c6f70 	stmdbvc	ip!, {r4, r5, r6, r8, r9, sl, fp, sp, lr}^
 adc:	696d6f6e 	stmdbvs	sp!, {r1, r2, r3, r5, r6, r8, r9, sl, fp, sp, lr}^
}
 ae0:	6e006c61 	cdpvs	12, 0, cr6, cr0, cr1, {3}
}
 ae4:	64726f77 	ldrbtvs	r6, [r2], #-3959	@ 0xfffff089
  if (cmd_buff == NULL || char_count <= 0) {
 ae8:	66670073 			@ <UNDEFINED> instruction: 0x66670073
static void handle_tab(char *cmd_buff, int *char_count) {
 aec:	656c6532 	strbvs	r6, [ip, #-1330]!	@ 0xffffface
 af0:	00745f6d 	rsbseq	r5, r4, sp, ror #30
  int last_match = -1;
 af4:	76746962 	ldrbtvc	r6, [r4], -r2, ror #18
  int match_count = 0;
 af8:	655f6365 	ldrbvs	r6, [pc, #-869]	@ 79b <delete+0x17>
  int i = 0;
 afc:	6c617571 	cfstr64vs	mvdx7, [r1], #-452	@ 0xfffffe3c
    i++;
 b00:	32666700 	rsbcc	r6, r6, #0, 14
  while (table[i].command_name != NULL) { //loop over all commands
 b04:	6e696f70 	mcrvs	15, 3, r6, cr9, cr0, {3}
 b08:	6f645f74 	svcvs	0x00645f74
 b0c:	656c6275 	strbvs	r6, [ip, #-629]!	@ 0xfffffd8b
    if (prefix_match(cmd_buff, *char_count, table[i].command_name)) {
 b10:	32666700 	rsbcc	r6, r6, #0, 14
 b14:	6c656966 			@ <UNDEFINED> instruction: 0x6c656966
 b18:	6e695f64 	cdpvs	15, 6, cr5, cr9, cr4, {3}
      match_count++;
 b1c:	61620063 	cmnvs	r2, r3, rrx
      printf("\n%s", table[i].command_name);
 b20:	6f5f6573 	svcvs	0x005f6573
 b24:	72656472 	rsbvc	r6, r5, #1912602624	@ 0x72000000
      last_match = i;
 b28:	74696200 	strbtvc	r6, [r9], #-512	@ 0xfffffe00
  if (match_count == 1) {
 b2c:	5f636576 	svcpl	0x00636576
 b30:	79706f63 	ldmdbvc	r0!, {r0, r1, r5, r6, r8, r9, sl, fp, sp, lr}^
  if (match_count) {
 b34:	74696200 	strbtvc	r6, [r9], #-512	@ 0xfffffe00
}
 b38:	5f636576 	svcpl	0x00636576
    memcpy(cmd_buff, table[last_match].command_name, LINE_BUFF_SIZE);
 b3c:	7a5f7369 	bvc	17dd8e8 <__ROM_SIZE__+0x179d8e8>
 b40:	006f7265 	rsbeq	r7, pc, r5, ror #4
 b44:	66326667 	ldrtvs	r6, [r2], -r7, ror #12
 b48:	646c6569 	strbtvs	r6, [ip], #-1385	@ 0xfffffa97
    *char_count = strlen(cmd_buff);
 b4c:	766e695f 			@ <UNDEFINED> instruction: 0x766e695f
 b50:	32666700 	rsbcc	r6, r6, #0, 14
 b54:	6e696f70 	mcrvs	15, 3, r6, cr9, cr0, {3}
    printf("\n");
 b58:	6e6f5f74 	mcrvs	15, 3, r5, cr15, cr4, {3}
 b5c:	7275635f 	rsbsvc	r6, r5, #2080374785	@ 0x7c000001
    prepend_prompt();
 b60:	6e006576 	cfrshl64vs	mvdx0, mvdx6, r6
    printf(PROMPT);
 b64:	73746962 	cmnvc	r4, #1605632	@ 0x188000
 b68:	74696200 	strbtvc	r6, [r9], #-512	@ 0xfffffe00
    printf("%s", cmd_buff);
 b6c:	5f636576 	svcpl	0x00636576
 b70:	5f746567 	svcpl	0x00746567
 b74:	00746962 	rsbseq	r6, r4, r2, ror #18
 b78:	76746962 	ldrbtvc	r6, [r4], -r2, ror #18
 b7c:	6c5f6365 	mrrcvs	3, 6, r6, pc, cr5	@ <UNPREDICTABLE>
 b80:	66696873 			@ <UNDEFINED> instruction: 0x66696873
 b84:	746f0074 	strbtvc	r0, [pc], #-116	@ b8c <shell>
__attribute__((weak)) int active_prompt() { return TRUE; }
 b88:	73726568 	cmnvc	r2, #104, 10	@ 0x1a000000
static void shell(void) {
 b8c:	6275705f 	rsbsvs	r7, r5, #95	@ 0x5f
  int count = 0;
 b90:	74696200 	strbtvc	r6, [r9], #-512	@ 0xfffffe00
  for (int i = 0; i < LINE_BUFF_SIZE; i++) line_buff[i] = 0;
 b94:	5f636576 	svcpl	0x00636576
 b98:	72676564 	rsbvc	r6, r7, #100, 10	@ 0x19000000
 b9c:	70006565 	andvc	r6, r0, r5, ror #10
 ba0:	696c6275 	stmdbvs	ip!, {r0, r2, r4, r5, r6, r9, sp, lr}^
 ba4:	656b5f63 	strbvs	r5, [fp, #-3939]!	@ 0xfffff09d
  for (int i = 0; i < MAX_ARG_COUNT; i++) argv[i] = NULL;
 ba8:	72700079 	rsbsvc	r0, r0, #121	@ 0x79
 bac:	74617669 	strbtvc	r7, [r1], #-1641	@ 0xfffff997
 bb0:	656b5f65 	strbvs	r5, [fp, #-3941]!	@ 0xfffff09b
 bb4:	66670079 			@ <UNDEFINED> instruction: 0x66670079
 bb8:	65696632 	strbvs	r6, [r9, #-1586]!	@ 0xfffff9ce
  prepend_prompt();
 bbc:	695f646c 	ldmdbvs	pc, {r2, r3, r5, r6, sl, sp, lr}^	@ <UNPREDICTABLE>
  printf(PROMPT);
 bc0:	6e6f5f73 	mcrvs	15, 3, r5, cr15, cr3, {3}
  int special_key = 0;
 bc4:	66670065 	strbtvs	r0, [r7], -r5, rrx
        special_key = 1;
 bc8:	65696632 	strbvs	r6, [r9, #-1586]!	@ 0xfffff9ce
    if (s == -1) { s = __read_char2__();}
 bcc:	615f646c 	cmpvs	pc, ip, ror #8
 bd0:	67006464 	strvs	r6, [r0, -r4, ror #8]
    if (s != -1) {
 bd4:	6f703266 	svcvs	0x00703266
 bd8:	5f746e69 	svcpl	0x00746e69
      loop();
 bdc:	7a5f7369 	bvc	17dd988 <__ROM_SIZE__+0x179d988>
        line_buff[count] = END_OF_LINE;
 be0:	006f7265 	rsbeq	r7, pc, r5, ror #4
 be4:	76746962 	ldrbtvc	r6, [r4], -r2, ror #18
 be8:	735f6365 	cmpvc	pc, #-1811939327	@ 0x94000001
 bec:	00706177 	rsbseq	r6, r0, r7, ror r1
        __write_char__(NEW_LINE);
 bf0:	76746962 	ldrbtvc	r6, [r4], -r2, ror #18
 bf4:	745f6365 	ldrbvc	r6, [pc], #-869	@ bfc <shell+0x70>
  add_command_to_history(line_buff);
 bf8:	74696200 	strbtvc	r6, [r9], #-512	@ 0xfffffe00
  argc = parse_line(argv, line_buff, MAX_ARG_COUNT);
 bfc:	5f636576 	svcpl	0x00636576
 c00:	5f746573 	svcpl	0x00746573
 c04:	6f72657a 	svcvs	0x0072657a
  if (argc > 0) execute(argc, argv);
 c08:	32666700 	rsbcc	r6, r6, #0, 14
}
 c0c:	6c656966 			@ <UNDEFINED> instruction: 0x6c656966
        if (!__echo) {
 c10:	756d5f64 	strbvc	r5, [sp, #-3940]!	@ 0xfffff09c
 c14:	6667006c 	strbtvs	r0, [r7], -ip, rrx
        if (count == 0) continue;
 c18:	696f7032 	stmdbvs	pc!, {r1, r4, r5, ip, sp, lr}^	@ <UNPREDICTABLE>
        count--;
 c1c:	615f746e 	cmpvs	pc, lr, ror #8
        line_buff[count] = END_OF_LINE;
 c20:	62006464 	andvs	r6, r0, #100, 8	@ 0x64000000
 c24:	5f657361 	svcpl	0x00657361
 c28:	61620078 	smcvs	8200	@ 0x2008
        delete ();
 c2c:	795f6573 	ldmdbvc	pc, {r0, r1, r4, r5, r6, r8, sl, sp, lr}^	@ <UNPREDICTABLE>
      if (__echo) {
 c30:	32666700 	rsbcc	r6, r6, #0, 14
        __write_char__(c);
 c34:	6c656966 			@ <UNDEFINED> instruction: 0x6c656966
 c38:	65735f64 	ldrbvs	r5, [r3, #-3940]!	@ 0xfffff09c
    if (!active_prompt()) {
 c3c:	6e6f5f74 	mcrvs	15, 3, r5, cr15, cr4, {3}
 c40:	66670065 	strbtvs	r0, [r7], -r5, rrx
    s = __read_char__();
 c44:	696f7032 	stmdbvs	pc!, {r1, r4, r5, ip, sp, lr}^	@ <UNPREDICTABLE>
 c48:	635f746e 	cmpvs	pc, #1845493760	@ 0x6e000000
    if (s == -1) { s = __read_char2__();}
 c4c:	0079706f 	rsbseq	r7, r9, pc, rrx
 c50:	66656f63 	strbtvs	r6, [r5], -r3, ror #30
      if (c == CARRIAGE_RETURN || c == NEW_LINE) {
 c54:	00625f66 	rsbeq	r5, r2, r6, ror #30
 c58:	70326667 	eorsvc	r6, r2, r7, ror #12
      if (c == DELETE || c == BACK_SPACE) {
 c5c:	746e696f 	strbtvc	r6, [lr], #-2415	@ 0xfffff691
 c60:	6c756d5f 	ldclvs	13, cr6, [r5], #-380	@ 0xfffffe84
      } else if (c == ESCAPE) {
 c64:	32337500 	eorscc	r7, r3, #0, 10
      } else if (c == SQUARE_BRACKET_OPEN && special_key == 1) {
 c68:	6b73616d 	blvs	1cd9224 <__ROM_SIZE__+0x1c99224>
      } else if ((c == 'C' || c == 'D') && special_key != 0) {
 c6c:	6f682f00 	svcvs	0x00682f00
 c70:	652f656d 	strvs	r6, [pc, #-1389]!	@ 70b <send_ping+0xf>
 c74:	2f667463 	svccs	0x00667463
      } else if ((c == 'A' || c == 'B') && special_key == 2) {
 c78:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
 c7c:	6172742d 	cmnvs	r2, sp, lsr #8
      else if (c == TAB) {
 c80:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
        line_buff[count] = c;
 c84:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
 c88:	6c2f6c6c 	stcvs	12, cr6, [pc], #-432	@ ae0 <setup>
 c8c:	742f6269 	strtvc	r6, [pc], #-617	@ c94 <shell+0x108>
        count++;
 c90:	2d796e69 	ldclcs	14, cr6, [r9, #-420]!	@ 0xfffffe5c
 c94:	68646365 	stmdavs	r4!, {r0, r2, r5, r6, r8, r9, sp, lr}^
          delete ();
 c98:	6463652f 	strbtvs	r6, [r3], #-1327	@ 0xfffffad1
          delete ();
 c9c:	00632e68 	rsbeq	r2, r3, r8, ror #28
      } else if (c == SQUARE_BRACKET_OPEN && special_key == 1) {
 ca0:	76746962 	ldrbtvc	r6, [r4], -r2, ror #18
        special_key = 2;
 ca4:	635f6365 	cmpvs	pc, #-1811939327	@ 0x94000001
      } else if ((c == 'C' || c == 'D') && special_key != 0) {
 ca8:	625f726c 	subsvs	r7, pc, #108, 4	@ 0xc0000006
        special_key = 0;
 cac:	65007469 	strvs	r7, [r0, #-1129]	@ 0xfffffb97
      } else if ((c == 'A' || c == 'B') && special_key == 2) {
 cb0:	5f686463 	svcpl	0x00686463
        if (!__echo) {
 cb4:	656e6567 	strbvs	r6, [lr, #-1383]!	@ 0xfffffa99
 cb8:	65746172 	ldrbvs	r6, [r4, #-370]!	@ 0xfffffe8e
          clear_prompt(count + 4);
 cbc:	79656b5f 	stmdbvc	r5!, {r0, r1, r2, r3, r4, r6, r8, r9, fp, sp, lr}^
 cc0:	63650073 	cmnvs	r5, #115	@ 0x73
        if (c == 'A') {
 cc4:	735f6864 	cmpvc	pc, #100, 16	@ 0x640000
          handle_down_arrow(line_buff, &count);
 cc8:	65726168 	ldrbvs	r6, [r2, #-360]!	@ 0xfffffe98
 ccc:	65735f64 	ldrbvs	r5, [r3, #-3940]!	@ 0xfffff09c
        continue;
 cd0:	74657263 	strbtvc	r7, [r5], #-611	@ 0xfffffd9d
          clear_prompt(count);
 cd4:	6f682f00 	svcvs	0x00682f00
 cd8:	652f656d 	strvs	r6, [pc, #-1389]!	@ 773 <initial_setup+0x5b>
          handle_up_arrow(line_buff, &count);
 cdc:	2f667463 	svccs	0x00667463
 ce0:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
        handle_tab(line_buff, &count);
 ce4:	6172742d 	cmnvs	r2, sp, lsr #8
 ce8:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
        continue;
 cec:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
  if (argc > 0) execute(argc, argv);
 cf0:	6c2f6c6c 	stcvs	12, cr6, [pc], #-432	@ b48 <handle_tab+0x62>
}
 cf4:	612f6269 			@ <UNDEFINED> instruction: 0x612f6269
 cf8:	612f6932 			@ <UNDEFINED> instruction: 0x612f6932
 cfc:	632e6932 			@ <UNDEFINED> instruction: 0x632e6932
 d00:	6e677200 	cdpvs	2, 6, cr7, cr7, cr0, {0}
void prompt() {
 d04:	666e695f 			@ <UNDEFINED> instruction: 0x666e695f
  initial_setup();
 d08:	00745f6f 	rsbseq	r5, r4, pc, ror #30
  exec_auto_cmds();
 d0c:	5f6e6772 	svcpl	0x006e6772
  setup();
 d10:	6f666e69 	svcvs	0x00666e69
    shell();
 d14:	74756f00 	ldrbtvc	r6, [r5], #-3840	@ 0xfffff100
int exec(char *cmd_str) {
 d18:	6675625f 			@ <UNDEFINED> instruction: 0x6675625f
 d1c:	6e67725f 	mcrvs	2, 3, r7, cr7, cr15, {2}
  argc = parse_line(argv, cmd_str, MAX_ARG_COUNT);
 d20:	6c657300 	stclvs	3, cr7, [r5], #-0
 d24:	65746365 	ldrbvs	r6, [r4, #-869]!	@ 0xfffffc9b
  if (argc > 0) execute(argc, argv);
 d28:	6f6d5f64 	svcvs	0x006d5f64
  return __cmd_exec_status;
 d2c:	6d006564 	cfstr32vs	mvfx6, [r0, #-400]	@ 0xfffffe70
}
 d30:	6f6c6d65 	svcvs	0x006c6d65
 d34:	75705f67 	ldrbvc	r5, [r0, #-3943]!	@ 0xfffff099
  if (argc > 0) execute(argc, argv);
 d38:	63006374 	movwvs	r6, #884	@ 0x374
 d3c:	5f727275 	svcpl	0x00727275
 d40:	65646e69 	strbvs	r6, [r4, #-3689]!	@ 0xfffff197
cmd get_function_addr(char *cmd_str) {
 d44:	682f0078 	stmdavs	pc!, {r3, r4, r5, r6}	@ <UNPREDICTABLE>
  for (int i = 0; table[i].command_name != NULL; i++) {
 d48:	2f656d6f 	svccs	0x00656d6f
 d4c:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
 d50:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
 d54:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
 d58:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
    if (strcmp(cmd_str, table[i].command_name) == 0) {
 d5c:	68732f72 	ldmdavs	r3!, {r1, r4, r5, r6, r8, r9, sl, fp, sp}^
 d60:	2f6c6c65 	svccs	0x006c6c65
      return table[i].command;
 d64:	2f62696c 	svccs	0x0062696c
 d68:	6c6d656d 	cfstr64vs	mvdx6, [sp], #-436	@ 0xfffffe4c
  return NULL;
 d6c:	6d2f676f 	stcvs	7, cr6, [pc, #-444]!	@ bb8 <shell+0x2c>
}
 d70:	6f6c6d65 	svcvs	0x006c6d65
  if(v < 26) return v + 'A';
 d74:	00632e67 	rsbeq	r2, r3, r7, ror #28
  if(v < 52) return v + 71;
 d78:	5f706e69 	svcpl	0x00706e69
  if(v < 62) return v - 4;
 d7c:	5f667562 	svcpl	0x00667562
  if(v == 62) return '+';
 d80:	006e6772 	rsbeq	r6, lr, r2, ror r7
  if(v == 63) return '/';
 d84:	454e4f4e 	strbmi	r4, [lr, #-3918]	@ 0xfffff0b2
  return 64;
 d88:	6d656d00 	stclvs	13, cr6, [r5, #-0]
  if(v < 26) return v + 'A';
 d8c:	5f676f6c 	svcpl	0x00676f6c
 d90:	74696e69 	strbtvc	r6, [r9], #-3689	@ 0xfffff197
  if(v < 52) return v + 71;
 d94:	6d656d00 	stclvs	13, cr6, [r5, #-0]
  if(v < 62) return v - 4;
 d98:	5f676f6c 	svcpl	0x00676f6c
 d9c:	63746567 	cmnvs	r4, #432013312	@ 0x19c00000
  if(v == 62) return '+';
 da0:	504e4900 	subpl	r4, lr, r0, lsl #18
}
 da4:	54554f5f 	ldrbpl	r4, [r5], #-3935	@ 0xfffff0a1
  if('A' <= c && c <= 'Z') return c - 'A';
 da8:	646f6d00 	strbtvs	r6, [pc], #-3328	@ db0 <base64_to_binary+0xa>
 dac:	00745f65 	rsbseq	r5, r4, r5, ror #30
  if('a' <= c && c <= 'z') return c - 71;
 db0:	74736564 	ldrbtvc	r6, [r3], #-1380	@ 0xfffffa9c
 db4:	72747300 	rsbsvc	r7, r4, #0, 6
 db8:	00797063 	rsbseq	r7, r9, r3, rrx
  if('0' <= c && c <= '9') return c + 4;
 dbc:	31727473 	cmncc	r2, r3, ror r4
 dc0:	73656400 	cmnvc	r5, #0, 8
  if(c == '+') return 62;
 dc4:	68635f74 	stmdavs	r3!, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
  if(c == '/') return 63;
 dc8:	73007261 	movwvc	r7, #609	@ 0x261
  return 255;
 dcc:	635f6372 	cmpvs	pc, #-939524095	@ 0xc8000001
  if('a' <= c && c <= 'z') return c - 71;
 dd0:	00726168 	rsbseq	r6, r2, r8, ror #2
 dd4:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ d20 <exec+0x8>
  if('0' <= c && c <= '9') return c + 4;
 dd8:	63652f65 	cmnvs	r5, #404	@ 0x194
  if(c == '+') return 62;
 ddc:	652f6674 	strvs	r6, [pc, #-1652]!	@ 770 <initial_setup+0x58>
  if(c == '/') return 63;
 de0:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
  return (input_length + 2)/3*4;
 de4:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
 de8:	2f72656e 	svccs	0x0072656e
 dec:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
}
 df0:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
 df4:	74732f62 	ldrbtvc	r2, [r3], #-3938	@ 0xfffff09e
unsigned int decode_base64_length(unsigned char input[], unsigned int input_length) {
 df8:	676e6972 			@ <UNDEFINED> instruction: 0x676e6972
 dfc:	7274732f 	rsbsvc	r7, r4, #-1140850688	@ 0xbc000000
  while(base64_to_binary(input[0]) < 64 && (unsigned int) (input - start) < input_length) {
 e00:	2e676e69 	cdpcs	14, 6, cr6, cr7, cr9, {3}
 e04:	Address 0xe04 is out of bounds.


Disassembly of section .comment:

00000000 <.comment>:
   0:	3a434347 	bcc	10d0d24 <__ROM_SIZE__+0x1090d24>
   4:	72412820 	subvc	r2, r1, #32, 16	@ 0x200000
   8:	4e47206d 	cdpmi	0, 4, cr2, cr7, cr13, {3}
   c:	6f542055 	svcvs	0x00542055
  10:	68636c6f 	stmdavs	r3!, {r0, r1, r2, r3, r5, r6, sl, fp, sp, lr}^
  14:	206e6961 	rsbcs	r6, lr, r1, ror #18
  18:	322e3231 	eorcc	r3, lr, #268435459	@ 0x10000003
  1c:	41504d2e 	cmpmi	r0, lr, lsr #26
  20:	49544243 	ldmdbmi	r4, {r0, r1, r6, r9, lr}^
  24:	6c65522d 	sfmvs	f5, 2, [r5], #-180	@ 0xffffff4c
  28:	42282031 	eormi	r2, r8, #49	@ 0x31
  2c:	646c6975 	strbtvs	r6, [ip], #-2421	@ 0xfffff68b
  30:	6d726120 	ldfvse	f6, [r2, #-128]!	@ 0xffffff80
  34:	2d32312d 	ldfcss	f3, [r2, #-180]!	@ 0xffffff4c
  38:	6361706d 	cmnvs	r1, #109	@ 0x6d
  3c:	2e697462 	cdpcs	4, 6, cr7, cr9, cr2, {3}
  40:	29293433 	stmdbcs	r9!, {r0, r1, r4, r5, sl, ip, sp}
  44:	2e323120 	rsfcssp	f3, f2, f0
  48:	20312e32 	eorscs	r2, r1, r2, lsr lr
  4c:	33323032 	teqcc	r2, #50	@ 0x32
  50:	34313230 	ldrtcc	r3, [r1], #-560	@ 0xfffffdd0
	...

Disassembly of section .ARM.attributes:

00000000 <.ARM.attributes>:
   0:	00002b41 	andeq	r2, r0, r1, asr #22
   4:	61656100 	cmnvs	r5, r0, lsl #2
   8:	01006962 	tsteq	r0, r2, ror #18
   c:	00000021 	andeq	r0, r0, r1, lsr #32
  10:	2d453705 	stclcs	7, cr3, [r5, #-20]	@ 0xffffffec
  14:	0d06004d 	stceq	0, cr0, [r6, #-308]	@ 0xfffffecc
  18:	02094d07 	andeq	r4, r9, #448	@ 0x1c0
  1c:	01140412 	tsteq	r4, r2, lsl r4
  20:	03170115 	tsteq	r7, #1073741829	@ 0x40000005
  24:	011a0118 	tsteq	sl, r8, lsl r1
  28:	0122011e 			@ <UNDEFINED> instruction: 0x0122011e

Disassembly of section .debug_frame:

00000000 <.debug_frame>:
   0:	0000000c 	andeq	r0, r0, ip
   4:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
   8:	7c020001 	stcvc	0, cr0, [r2], {1}
   c:	000d0c0e 	andeq	r0, sp, lr, lsl #24
  10:	00000018 	andeq	r0, r0, r8, lsl r0
  14:	00000000 	andeq	r0, r0, r0
  18:	000003c0 	andeq	r0, r0, r0, asr #7
  1c:	00000064 	andeq	r0, r0, r4, rrx
  20:	84100e41 	ldrhi	r0, [r0], #-3649	@ 0xfffff1bf
  24:	86038504 	strhi	r8, [r3], -r4, lsl #10
  28:	00018e02 	andeq	r8, r1, r2, lsl #28
  2c:	0000000c 	andeq	r0, r0, ip
  30:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
  34:	7c020001 	stcvc	0, cr0, [r2], {1}
  38:	000d0c0e 	andeq	r0, sp, lr, lsl #24
  3c:	0000000c 	andeq	r0, r0, ip
  40:	0000002c 	andeq	r0, r0, ip, lsr #32
  44:	00000424 	andeq	r0, r0, r4, lsr #8
  48:	00000002 	andeq	r0, r0, r2
  4c:	0000000c 	andeq	r0, r0, ip
  50:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
  54:	7c020001 	stcvc	0, cr0, [r2], {1}
  58:	000d0c0e 	andeq	r0, sp, lr, lsl #24
  5c:	00000014 	andeq	r0, r0, r4, lsl r0
  60:	0000004c 	andeq	r0, r0, ip, asr #32
  64:	00000428 	andeq	r0, r0, r8, lsr #8
  68:	00000024 	andeq	r0, r0, r4, lsr #32
  6c:	83080e41 	movwhi	r0, #36417	@ 0x8e41
  70:	00018e02 	andeq	r8, r1, r2, lsl #28
  74:	0000000c 	andeq	r0, r0, ip
  78:	0000004c 	andeq	r0, r0, ip, asr #32
  7c:	0000044c 	andeq	r0, r0, ip, asr #8
  80:	0000001c 	andeq	r0, r0, ip, lsl r0
  84:	0000000c 	andeq	r0, r0, ip
  88:	0000004c 	andeq	r0, r0, ip, asr #32
  8c:	00000468 	andeq	r0, r0, r8, ror #8
  90:	00000024 	andeq	r0, r0, r4, lsr #32
  94:	0000000c 	andeq	r0, r0, ip
  98:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
  9c:	7c020001 	stcvc	0, cr0, [r2], {1}
  a0:	000d0c0e 	andeq	r0, sp, lr, lsl #24
  a4:	00000014 	andeq	r0, r0, r4, lsl r0
  a8:	00000094 	muleq	r0, r4, r0
  ac:	0000048c 	andeq	r0, r0, ip, lsl #9
  b0:	00000024 	andeq	r0, r0, r4, lsr #32
  b4:	83080e41 	movwhi	r0, #36417	@ 0x8e41
  b8:	00018e02 	andeq	r8, r1, r2, lsl #28
  bc:	0000000c 	andeq	r0, r0, ip
  c0:	00000094 	muleq	r0, r4, r0
  c4:	000004b0 			@ <UNDEFINED> instruction: 0x000004b0
  c8:	0000001c 	andeq	r0, r0, ip, lsl r0
  cc:	0000000c 	andeq	r0, r0, ip
  d0:	00000094 	muleq	r0, r4, r0
  d4:	000004cc 	andeq	r0, r0, ip, asr #9
  d8:	00000024 	andeq	r0, r0, r4, lsr #32
  dc:	0000000c 	andeq	r0, r0, ip
  e0:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
  e4:	7c020001 	stcvc	0, cr0, [r2], {1}
  e8:	000d0c0e 	andeq	r0, sp, lr, lsl #24
  ec:	0000000c 	andeq	r0, r0, ip
  f0:	000000dc 	ldrdeq	r0, [r0], -ip
  f4:	000004f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
  f8:	00000054 	andeq	r0, r0, r4, asr r0
  fc:	00000014 	andeq	r0, r0, r4, lsl r0
 100:	000000dc 	ldrdeq	r0, [r0], -ip
 104:	00000544 	andeq	r0, r0, r4, asr #10
 108:	00000038 	andeq	r0, r0, r8, lsr r0
 10c:	83080e41 	movwhi	r0, #36417	@ 0x8e41
 110:	00018e02 	andeq	r8, r1, r2, lsl #28
 114:	0000000c 	andeq	r0, r0, ip
 118:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 11c:	7c020001 	stcvc	0, cr0, [r2], {1}
 120:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 124:	00000014 	andeq	r0, r0, r4, lsl r0
 128:	00000114 	andeq	r0, r0, r4, lsl r1
 12c:	0000057c 	andeq	r0, r0, ip, ror r5
 130:	0000001c 	andeq	r0, r0, ip, lsl r0
 134:	83080e41 	movwhi	r0, #36417	@ 0x8e41
 138:	00018e02 	andeq	r8, r1, r2, lsl #28
 13c:	0000000c 	andeq	r0, r0, ip
 140:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 144:	7c020001 	stcvc	0, cr0, [r2], {1}
 148:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 14c:	0000001c 	andeq	r0, r0, ip, lsl r0
 150:	0000013c 	andeq	r0, r0, ip, lsr r1
 154:	00000598 	muleq	r0, r8, r5
 158:	00000094 	muleq	r0, r4, r0
 15c:	840c0e41 	strhi	r0, [ip], #-3649	@ 0xfffff1bf
 160:	8e028503 	cfsh32hi	mvfx8, mvfx2, #3
 164:	880e4101 	stmdahi	lr, {r0, r8, lr}
 168:	0c0e7a02 			@ <UNDEFINED> instruction: 0x0c0e7a02
 16c:	0000000c 	andeq	r0, r0, ip
 170:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 174:	7c020001 	stcvc	0, cr0, [r2], {1}
 178:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 17c:	0000001c 	andeq	r0, r0, ip, lsl r0
 180:	0000016c 	andeq	r0, r0, ip, ror #2
 184:	0000062c 	andeq	r0, r0, ip, lsr #12
 188:	00000050 	andeq	r0, r0, r0, asr r0
 18c:	84080e41 	strhi	r0, [r8], #-3649	@ 0xfffff1bf
 190:	41018e02 	tstmi	r1, r2, lsl #28
 194:	0e5e700e 	cdpeq	0, 5, cr7, cr14, cr14, {0}
 198:	00000008 	andeq	r0, r0, r8
 19c:	0000001c 	andeq	r0, r0, ip, lsl r0
 1a0:	0000016c 	andeq	r0, r0, ip, ror #2
 1a4:	0000067c 	andeq	r0, r0, ip, ror r6
 1a8:	00000080 	andeq	r0, r0, r0, lsl #1
 1ac:	840c0e41 	strhi	r0, [ip], #-3649	@ 0xfffff1bf
 1b0:	8e028503 	cfsh32hi	mvfx8, mvfx2, #3
 1b4:	780e4101 	stmdavc	lr, {r0, r8, lr}
 1b8:	000c0e71 	andeq	r0, ip, r1, ror lr
 1bc:	0000000c 	andeq	r0, r0, ip
 1c0:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 1c4:	7c020001 	stcvc	0, cr0, [r2], {1}
 1c8:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 1cc:	00000014 	andeq	r0, r0, r4, lsl r0
 1d0:	000001bc 			@ <UNDEFINED> instruction: 0x000001bc
 1d4:	000006fc 	strdeq	r0, [r0], -ip
 1d8:	0000001c 	andeq	r0, r0, ip, lsl r0
 1dc:	83080e41 	movwhi	r0, #36417	@ 0x8e41
 1e0:	00018e02 	andeq	r8, r1, r2, lsl #28
 1e4:	0000000c 	andeq	r0, r0, ip
 1e8:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 1ec:	7c020001 	stcvc	0, cr0, [r2], {1}
 1f0:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 1f4:	00000020 	andeq	r0, r0, r0, lsr #32
 1f8:	000001e4 	andeq	r0, r0, r4, ror #3
 1fc:	00000718 	andeq	r0, r0, r8, lsl r7
 200:	0000006c 	andeq	r0, r0, ip, rrx
 204:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 208:	41018e02 	tstmi	r1, r2, lsl #28
 20c:	0d41100e 	stcleq	0, cr1, [r1, #-56]	@ 0xffffffc8
 210:	080e6607 	stmdaeq	lr, {r0, r1, r2, r9, sl, sp, lr}
 214:	000d0d41 	andeq	r0, sp, r1, asr #26
 218:	00000014 	andeq	r0, r0, r4, lsl r0
 21c:	000001e4 	andeq	r0, r0, r4, ror #3
 220:	00000784 	andeq	r0, r0, r4, lsl #15
 224:	0000001c 	andeq	r0, r0, ip, lsl r0
 228:	84080e41 	strhi	r0, [r8], #-3649	@ 0xfffff1bf
 22c:	00018e02 	andeq	r8, r1, r2, lsl #28
 230:	00000014 	andeq	r0, r0, r4, lsl r0
 234:	000001e4 	andeq	r0, r0, r4, ror #3
 238:	000007a0 	andeq	r0, r0, r0, lsr #15
 23c:	00000012 	andeq	r0, r0, r2, lsl r0
 240:	84080e41 	strhi	r0, [r8], #-3649	@ 0xfffff1bf
 244:	00018e02 	andeq	r8, r1, r2, lsl #28
 248:	00000014 	andeq	r0, r0, r4, lsl r0
 24c:	000001e4 	andeq	r0, r0, r4, ror #3
 250:	000007b2 			@ <UNDEFINED> instruction: 0x000007b2
 254:	00000026 	andeq	r0, r0, r6, lsr #32
 258:	84080e41 	strhi	r0, [r8], #-3649	@ 0xfffff1bf
 25c:	00018e02 	andeq	r8, r1, r2, lsl #28
 260:	00000018 	andeq	r0, r0, r8, lsl r0
 264:	000001e4 	andeq	r0, r0, r4, ror #3
 268:	000007d8 	ldrdeq	r0, [r0], -r8
 26c:	00000040 	andeq	r0, r0, r0, asr #32
 270:	83100e41 	tsthi	r0, #1040	@ 0x410
 274:	85038404 	strhi	r8, [r3, #-1028]	@ 0xfffffbfc
 278:	00018e02 	andeq	r8, r1, r2, lsl #28
 27c:	00000014 	andeq	r0, r0, r4, lsl r0
 280:	000001e4 	andeq	r0, r0, r4, ror #3
 284:	00000818 	andeq	r0, r0, r8, lsl r8
 288:	0000001c 	andeq	r0, r0, ip, lsl r0
 28c:	83080e41 	movwhi	r0, #36417	@ 0x8e41
 290:	00018e02 	andeq	r8, r1, r2, lsl #28
 294:	00000014 	andeq	r0, r0, r4, lsl r0
 298:	000001e4 	andeq	r0, r0, r4, ror #3
 29c:	00000834 	andeq	r0, r0, r4, lsr r8
 2a0:	00000010 	andeq	r0, r0, r0, lsl r0
 2a4:	83080e41 	movwhi	r0, #36417	@ 0x8e41
 2a8:	00018e02 	andeq	r8, r1, r2, lsl #28
 2ac:	0000001c 	andeq	r0, r0, ip, lsl r0
 2b0:	000001e4 	andeq	r0, r0, r4, ror #3
 2b4:	00000844 	andeq	r0, r0, r4, asr #16
 2b8:	0000005c 	andeq	r0, r0, ip, asr r0
 2bc:	83180e42 	tsthi	r8, #1056	@ 0x420
 2c0:	85058406 	strhi	r8, [r5, #-1030]	@ 0xfffffbfa
 2c4:	88038604 	stmdahi	r3, {r2, r9, sl, pc}
 2c8:	00018e02 	andeq	r8, r1, r2, lsl #28
 2cc:	00000018 	andeq	r0, r0, r8, lsl r0
 2d0:	000001e4 	andeq	r0, r0, r4, ror #3
 2d4:	000008a0 	andeq	r0, r0, r0, lsr #17
 2d8:	00000068 	andeq	r0, r0, r8, rrx
 2dc:	84100e41 	ldrhi	r0, [r0], #-3649	@ 0xfffff1bf
 2e0:	86038504 	strhi	r8, [r3], -r4, lsl #10
 2e4:	00018e02 	andeq	r8, r1, r2, lsl #28
 2e8:	00000020 	andeq	r0, r0, r0, lsr #32
 2ec:	000001e4 	andeq	r0, r0, r4, ror #3
 2f0:	00000908 	andeq	r0, r0, r8, lsl #18
 2f4:	00000048 	andeq	r0, r0, r8, asr #32
 2f8:	83100e42 	tsthi	r0, #1056	@ 0x420
 2fc:	85038404 	strhi	r8, [r3, #-1028]	@ 0xfffffbfc
 300:	5c018e02 	stcpl	14, cr8, [r1], {2}
 304:	c4c3000e 	strbgt	r0, [r3], #14
 308:	0000cec5 	andeq	ip, r0, r5, asr #29
 30c:	00000018 	andeq	r0, r0, r8, lsl r0
 310:	000001e4 	andeq	r0, r0, r4, ror #3
 314:	00000950 	andeq	r0, r0, r0, asr r9
 318:	00000052 	andeq	r0, r0, r2, asr r0
 31c:	83100e41 	tsthi	r0, #1040	@ 0x410
 320:	85038404 	strhi	r8, [r3, #-1028]	@ 0xfffffbfc
 324:	00018e02 	andeq	r8, r1, r2, lsl #28
 328:	00000020 	andeq	r0, r0, r0, lsr #32
 32c:	000001e4 	andeq	r0, r0, r4, ror #3
 330:	000009a2 	andeq	r0, r0, r2, lsr #19
 334:	0000003c 	andeq	r0, r0, ip, lsr r0
 338:	84100e42 	ldrhi	r0, [r0], #-3650	@ 0xfffff1be
 33c:	86038504 	strhi	r8, [r3], -r4, lsl #10
 340:	5a018e02 	bpl	63b50 <__ROM_SIZE__+0x23b50>
 344:	c5c4000e 	strbgt	r0, [r4, #14]
 348:	0000cec6 	andeq	ip, r0, r6, asr #29
 34c:	00000018 	andeq	r0, r0, r8, lsl r0
 350:	000001e4 	andeq	r0, r0, r4, ror #3
 354:	000009de 	ldrdeq	r0, [r0], -lr
 358:	00000072 	andeq	r0, r0, r2, ror r0
 35c:	83100e41 	tsthi	r0, #1040	@ 0x410
 360:	85038404 	strhi	r8, [r3, #-1028]	@ 0xfffffbfc
 364:	00018e02 	andeq	r8, r1, r2, lsl #28
 368:	00000018 	andeq	r0, r0, r8, lsl r0
 36c:	000001e4 	andeq	r0, r0, r4, ror #3
 370:	00000a50 	andeq	r0, r0, r0, asr sl
 374:	00000060 	andeq	r0, r0, r0, rrx
 378:	83100e41 	tsthi	r0, #1040	@ 0x410
 37c:	85038404 	strhi	r8, [r3, #-1028]	@ 0xfffffbfc
 380:	00018e02 	andeq	r8, r1, r2, lsl #28
 384:	0000000c 	andeq	r0, r0, ip
 388:	000001e4 	andeq	r0, r0, r4, ror #3
 38c:	00000ab0 			@ <UNDEFINED> instruction: 0x00000ab0
 390:	0000000c 	andeq	r0, r0, ip
 394:	0000000c 	andeq	r0, r0, ip
 398:	000001e4 	andeq	r0, r0, r4, ror #3
 39c:	00000abc 			@ <UNDEFINED> instruction: 0x00000abc
 3a0:	0000000c 	andeq	r0, r0, ip
 3a4:	0000000c 	andeq	r0, r0, ip
 3a8:	000001e4 	andeq	r0, r0, r4, ror #3
 3ac:	00000ac8 	andeq	r0, r0, r8, asr #21
 3b0:	0000000c 	andeq	r0, r0, ip
 3b4:	0000000c 	andeq	r0, r0, ip
 3b8:	000001e4 	andeq	r0, r0, r4, ror #3
 3bc:	00000ad4 	ldrdeq	r0, [r0], -r4
int car_mesg(int argc, char** argv) {
 3c0:	0000000c 	andeq	r0, r0, ip
 3c4:	0000000c 	andeq	r0, r0, ip
    printf("Received the message:");
 3c8:	000001e4 	andeq	r0, r0, r4, ror #3
    for (ctr = 1; ctr < argc; ctr++) {
 3cc:	00000ae0 	andeq	r0, r0, r0, ror #21
        printf(" %s", argv[ctr]);
 3d0:	00000002 	andeq	r0, r0, r2
 3d4:	0000000c 	andeq	r0, r0, ip
 3d8:	000001e4 	andeq	r0, r0, r4, ror #3
    for (ctr = 1; ctr < argc; ctr++) {
 3dc:	00000ae2 	andeq	r0, r0, r2, ror #21
    printf("\n");
 3e0:	00000002 	andeq	r0, r0, r2
 3e4:	0000000c 	andeq	r0, r0, ip
    if (argc > 0) {
 3e8:	000001e4 	andeq	r0, r0, r4, ror #3
}
 3ec:	00000ae4 	andeq	r0, r0, r4, ror #21
        if (strcmp(argv[1], "PING_REPLY") == 0) {
 3f0:	00000002 	andeq	r0, r0, r2
 3f4:	0000002c 	andeq	r0, r0, ip, lsr #32
            printf("Got a ping reply.\n");
 3f8:	000001e4 	andeq	r0, r0, r4, ror #3
 3fc:	00000ae6 	andeq	r0, r0, r6, ror #21
            printf("Didn't know how to handle %s\n", argv[1]);
 400:	000000a2 	andeq	r0, r0, r2, lsr #1
 404:	83200e44 			@ <UNDEFINED> instruction: 0x83200e44
 408:	85078408 	strhi	r8, [r7, #-1032]	@ 0xfffffbf8
 40c:	88058606 	stmdahi	r5, {r1, r2, r9, sl, pc}
 410:	8a038904 	bhi	e2828 <__ROM_SIZE__+0xa2828>
 414:	02018e02 	andeq	r8, r1, #2, 28
 418:	c3000e45 	movwgt	r0, #3653	@ 0xe45
 41c:	c8c6c5c4 	stmiagt	r6, {r2, r6, r7, r8, sl, lr, pc}^
 420:	00cecac9 	sbceq	ip, lr, r9, asr #21
 424:	0000000c 	andeq	r0, r0, ip
void uputc(char c) {
 428:	000001e4 	andeq	r0, r0, r4, ror #3
  while ((UARTFR >> 5) & 1)
 42c:	00000b88 	andeq	r0, r0, r8, lsl #23
 430:	00000004 	andeq	r0, r0, r4
  UART_DR = c;
 434:	00000020 	andeq	r0, r0, r0, lsr #32
  if (c == '\n')
 438:	000001e4 	andeq	r0, r0, r4, ror #3
}
 43c:	00000b8c 	andeq	r0, r0, ip, lsl #23
    uputc('\r');
 440:	00000178 	andeq	r0, r0, r8, ror r1
}
 444:	840c0e41 	strhi	r0, [ip], #-3649	@ 0xfffff1bf
 448:	8e028503 	cfsh32hi	mvfx8, mvfx2, #3
  if (!((UARTFR >> 4) & 1)) return UART_DR;
 44c:	980e4101 	stmdals	lr, {r0, r8, lr}
 450:	0e0a7e03 	cdpeq	14, 0, cr7, cr10, cr3, {0}
 454:	000b410c 	andeq	r4, fp, ip, lsl #2
 458:	00000014 	andeq	r0, r0, r4, lsl r0
  return -1;
 45c:	000001e4 	andeq	r0, r0, r4, ror #3
}
 460:	00000d04 	andeq	r0, r0, r4, lsl #26
 464:	00000014 	andeq	r0, r0, r4, lsl r0
  UARTCTL = 0;
 468:	83080e41 	movwhi	r0, #36417	@ 0x8e41
 46c:	00018e02 	andeq	r8, r1, r2, lsl #28
  UARTIBRD = 8;
 470:	0000001c 	andeq	r0, r0, ip, lsl r0
  UARTFBRD = 44;
 474:	000001e4 	andeq	r0, r0, r4, ror #3
  UARTCC = 0;
 478:	00000d18 	andeq	r0, r0, r8, lsl sp
  UARTLCRH = 0x60;
 47c:	0000002c 	andeq	r0, r0, ip, lsr #32
  UARTCTL = 0x301;
 480:	8e040e41 	cdphi	14, 0, cr0, cr4, cr1, {2}
}
 484:	880e4101 	stmdahi	lr, {r0, r8, lr}
 488:	0e0a4b02 	vmlaeq.f64	d4, d10, d2
void u2putc(char c) {
 48c:	000b4204 	andeq	r4, fp, r4, lsl #4
  while ((UART2FR >> 5) & 1)
 490:	00000018 	andeq	r0, r0, r8, lsl r0
 494:	000001e4 	andeq	r0, r0, r4, ror #3
  UART2_DR = c;
 498:	00000d44 	andeq	r0, r0, r4, asr #26
  if (c == '\n')
 49c:	00000030 	andeq	r0, r0, r0, lsr r0
}
 4a0:	84100e41 	ldrhi	r0, [r0], #-3649	@ 0xfffff1bf
    u2putc('\r');
 4a4:	86038504 	strhi	r8, [r3], -r4, lsl #10
}
 4a8:	00018e02 	andeq	r8, r1, r2, lsl #28
 4ac:	0000000c 	andeq	r0, r0, ip
  if (!((UART2FR >> 4) & 1)) return UART2_DR;
 4b0:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 4b4:	7c020001 	stcvc	0, cr0, [r2], {1}
 4b8:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 4bc:	0000000c 	andeq	r0, r0, ip
  return -1;
 4c0:	000004ac 	andeq	r0, r0, ip, lsr #9
}
 4c4:	00000d74 	andeq	r0, r0, r4, ror sp
 4c8:	00000032 	andeq	r0, r0, r2, lsr r0
  UART2CTL = 0;
 4cc:	0000000c 	andeq	r0, r0, ip
 4d0:	000004ac 	andeq	r0, r0, ip, lsr #9
  UART2IBRD = 8;
 4d4:	00000da6 	andeq	r0, r0, r6, lsr #27
  UART2FBRD = 44;
 4d8:	0000003e 	andeq	r0, r0, lr, lsr r0
  UART2CC = 0;
 4dc:	0000000c 	andeq	r0, r0, ip
  UART2LCRH = 0x60;
 4e0:	000004ac 	andeq	r0, r0, ip, lsr #9
  UART2CTL = 0x301;
 4e4:	00000de4 	andeq	r0, r0, r4, ror #27
}
 4e8:	00000014 	andeq	r0, r0, r4, lsl r0
 4ec:	00000018 	andeq	r0, r0, r8, lsl r0
  RCGCUART |= 3;
 4f0:	000004ac 	andeq	r0, r0, ip, lsr #9
 4f4:	00000df8 	strdeq	r0, [r0], -r8
 4f8:	00000034 	andeq	r0, r0, r4, lsr r0
 4fc:	84100e41 	ldrhi	r0, [r0], #-3649	@ 0xfffff1bf
  RCGCGPIO |= 3;
 500:	86038504 	strhi	r8, [r3], -r4, lsl #10
 504:	00018e02 	andeq	r8, r1, r2, lsl #28
 508:	0000001c 	andeq	r0, r0, ip, lsl r0
  GPIODEN = 0x03;
 50c:	000004ac 	andeq	r0, r0, ip, lsr #9
 510:	00000e2c 	andeq	r0, r0, ip, lsr #28
  GPIOAFSEL = 0x03;
 514:	000000e8 	andeq	r0, r0, r8, ror #1
  GPIOPCTL |= 0x00000011;
 518:	84180e42 	ldrhi	r0, [r8], #-3650	@ 0xfffff1be
 51c:	86058506 	strhi	r8, [r5], -r6, lsl #10
 520:	88038704 	stmdahi	r3, {r2, r8, r9, sl, pc}
  GPIODEN2 = 0x03;
 524:	00018e02 	andeq	r8, r1, r2, lsl #28
 528:	0000001c 	andeq	r0, r0, ip, lsl r0
  GPIOAFSEL2 = 0x03;
 52c:	000004ac 	andeq	r0, r0, ip, lsr #9
  GPIOPCTL2 |= 0x00000011;
 530:	00000f14 	andeq	r0, r0, r4, lsl pc
 534:	000000bc 	strheq	r0, [r0], -ip
 538:	84180e42 	ldrhi	r0, [r8], #-3650	@ 0xfffff1be
}
 53c:	86058506 	strhi	r8, [r5], -r6, lsl #10
 540:	88038704 	stmdahi	r3, {r2, r8, r9, sl, pc}
void platform_init() {
 544:	00018e02 	andeq	r8, r1, r2, lsl #28
    pin_setup();
 548:	0000000c 	andeq	r0, r0, ip
    uart_init();
 54c:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
    uart2_init();
 550:	7c020001 	stcvc	0, cr0, [r2], {1}
    set_read_char(ugetc);
 554:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    set_read_char2(u2getc);
 558:	00000014 	andeq	r0, r0, r4, lsl r0
 55c:	00000548 	andeq	r0, r0, r8, asr #10
    set_write_char(uputc);
 560:	00000fd0 	ldrdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
    set_write_char2(u2putc);
 564:	0000001c 	andeq	r0, r0, ip, lsl r0
 568:	84080e41 	strhi	r0, [r8], #-3649	@ 0xfffff1bf
}
 56c:	00018e02 	andeq	r8, r1, r2, lsl #28
 570:	00000020 	andeq	r0, r0, r0, lsr #32
 574:	00000548 	andeq	r0, r0, r8, asr #10
 578:	00000fec 	andeq	r0, r0, ip, ror #31
int pair(int argc, char** argv) {
 57c:	00000140 	andeq	r0, r0, r0, asr #2
    printf("Sending a pair request.\n");
 580:	840c0e41 	strhi	r0, [ip], #-3649	@ 0xfffff1bf
    printf2("FOB_MESG PAIR\n");
 584:	8e028503 	cfsh32hi	mvfx8, mvfx2, #3
 588:	200e4101 	andcs	r4, lr, r1, lsl #2
}
 58c:	0c0e0a60 			@ <UNDEFINED> instruction: 0x0c0e0a60
 590:	00000b41 	andeq	r0, r0, r1, asr #22
 594:	00000038 	andeq	r0, r0, r8, lsr r0
int aes(int argc, char** argv) {
 598:	00000548 	andeq	r0, r0, r8, asr #10
    uint8_t key[16] = {0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,
 59c:	0000112c 	andeq	r1, r0, ip, lsr #2
 5a0:	000000dc 	ldrdeq	r0, [r0], -ip
 5a4:	80100e41 	andshi	r0, r0, r1, asr #28
    uint8_t text[16] = "0123456789abcdef";
 5a8:	82038104 	andhi	r8, r3, #4, 2
 5ac:	41018302 	tstmi	r1, r2, lsl #6
 5b0:	07841c0e 	streq	r1, [r4, lr, lsl #24]
    AES_init_ctx(&ctx, key);
 5b4:	058e0685 	streq	r0, [lr, #1669]	@ 0x685
 5b8:	02280e41 	eoreq	r0, r8, #1040	@ 0x410
    printf("Encrypting %s using AES\n", text);
 5bc:	1c0e0a61 			@ <UNDEFINED> instruction: 0x1c0e0a61
 5c0:	c4c5ce42 	strbgt	ip, [r5], #3650	@ 0xe42
    AES_ECB_encrypt(&ctx, text);
 5c4:	c341100e 	movtgt	r1, #4110	@ 0x100e
 5c8:	0ec0c1c2 	acseqdm	f4, f2
    printf("Encrypted is %s\n", text);
 5cc:	000b4100 	andeq	r4, fp, r0, lsl #2
 5d0:	0000000c 	andeq	r0, r0, ip
    len = encode_base64(text, 16, b64text);
 5d4:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 5d8:	7c020001 	stcvc	0, cr0, [r2], {1}
 5dc:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    b64text[len] = '\n';
 5e0:	00000014 	andeq	r0, r0, r4, lsl r0
 5e4:	000005d0 	ldrdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
 5e8:	00001208 	andeq	r1, r0, r8, lsl #4
    printf("Encrypted is %s\n", text);
 5ec:	0000001c 	andeq	r0, r0, ip, lsl r0
 5f0:	84080e41 	strhi	r0, [r8], #-3649	@ 0xfffff1bf
    printf2("FOB_MESG AESB64 %s\n", b64text);
 5f4:	00018e02 	andeq	r8, r1, r2, lsl #28
 5f8:	00000020 	andeq	r0, r0, r0, lsr #32
    AES_ECB_decrypt(&ctx, text);
 5fc:	000005d0 	ldrdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
 600:	00001224 	andeq	r1, r0, r4, lsr #4
    printf("Which should decrypt to %s \n", text);
 604:	00000140 	andeq	r0, r0, r0, asr #2
 608:	840c0e41 	strhi	r0, [ip], #-3649	@ 0xfffff1bf
}
 60c:	8e028503 	cfsh32hi	mvfx8, mvfx2, #3
 610:	200e4101 	andcs	r4, lr, r1, lsl #2
 614:	0c0e0a60 			@ <UNDEFINED> instruction: 0x0c0e0a60
 618:	00000b41 	andeq	r0, r0, r1, asr #22
 61c:	00000038 	andeq	r0, r0, r8, lsr r0
 620:	000005d0 	ldrdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
 624:	00001364 	andeq	r1, r0, r4, ror #6
 628:	000000dc 	ldrdeq	r0, [r0], -ip
int encode64(int argc, char** argv) {
 62c:	80100e41 	andshi	r0, r0, r1, asr #28
    if (argc > 1) {
 630:	82038104 	andhi	r8, r3, #4, 2
 634:	41018302 	tstmi	r1, r2, lsl #6
        len = strlen(argv[1]);
 638:	07841c0e 	streq	r1, [r4, lr, lsl #24]
 63c:	058e0685 	streq	r0, [lr, #1669]	@ 0x685
        if (len < MAX64LENGTH) {
 640:	02280e41 	eoreq	r0, r8, #1040	@ 0x410
            len = encode_base64(argv[1], len, encoded);
 644:	1c0e0a61 			@ <UNDEFINED> instruction: 0x1c0e0a61
 648:	c4c5ce42 	strbgt	ip, [r5], #3650	@ 0xe42
            printf("Encoded %s as %s with %d characters\n", argv[1], encoded, len);
 64c:	c341100e 	movtgt	r1, #4110	@ 0x100e
 650:	0ec0c1c2 	acseqdm	f4, f2
 654:	000b4100 	andeq	r4, fp, r0, lsl #2
            printf("String exceeds max length of %d characters", MAX64LENGTH);
 658:	0000000c 	andeq	r0, r0, ip
 65c:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 660:	7c020001 	stcvc	0, cr0, [r2], {1}
        printf("Usage is 'encode64 string'\n");
 664:	000d0c0e 	andeq	r0, sp, lr, lsl #24
}
 668:	00000014 	andeq	r0, r0, r4, lsl r0
 66c:	00000658 	andeq	r0, r0, r8, asr r6
 670:	00001440 	andeq	r1, r0, r0, asr #8
 674:	00000030 	andeq	r0, r0, r0, lsr r0
 678:	83080e41 	movwhi	r0, #36417	@ 0x8e41
int decode64(int argc, char** argv) {
 67c:	00018e02 	andeq	r8, r1, r2, lsl #28
    if (argc > 1) {
 680:	00000018 	andeq	r0, r0, r8, lsl r0
 684:	00000658 	andeq	r0, r0, r8, asr r6
        int len = strlen(argv[1]);
 688:	00001470 	andeq	r1, r0, r0, ror r4
 68c:	00000030 	andeq	r0, r0, r0, lsr r0
        if (len < MAX64LENGTH-1) {
 690:	83100e41 	tsthi	r0, #1040	@ 0x410
                printf("encoded string is %d characters\n", len);
 694:	85038404 	strhi	r8, [r3, #-1028]	@ 0xfffffbfc
 698:	00018e02 	andeq	r8, r1, r2, lsl #28
                len = decode_base64(argv[1], len, plaintext);
 69c:	00000018 	andeq	r0, r0, r8, lsl r0
 6a0:	00000658 	andeq	r0, r0, r8, asr r6
 6a4:	000014a0 	andeq	r1, r0, r0, lsr #9
                printf("decoded string is %d characters\n", len);
 6a8:	00000048 	andeq	r0, r0, r8, asr #32
 6ac:	84100e41 	ldrhi	r0, [r0], #-3649	@ 0xfffff1bf
                printf("Adding NULL at the end of decoded string\n");
 6b0:	86038504 	strhi	r8, [r3], -r4, lsl #10
                plaintext[len] = '\n';
 6b4:	00018e02 	andeq	r8, r1, r2, lsl #28
 6b8:	00000018 	andeq	r0, r0, r8, lsl r0
 6bc:	00000658 	andeq	r0, r0, r8, asr r6
 6c0:	000014e8 	andeq	r1, r0, r8, ror #9
                printf("Decoded %s as: %s\n", argv[1], plaintext);
 6c4:	00000068 	andeq	r0, r0, r8, rrx
 6c8:	84100e41 	ldrhi	r0, [r0], #-3649	@ 0xfffff1bf
 6cc:	86038504 	strhi	r8, [r3], -r4, lsl #10
            printf("String exceeds max length of %d characters", MAX64LENGTH);
 6d0:	00018e02 	andeq	r8, r1, r2, lsl #28
 6d4:	00000018 	andeq	r0, r0, r8, lsl r0
        printf("Usage is 'decode64 string'\n");
 6d8:	00000658 	andeq	r0, r0, r8, asr r6
 6dc:	00001550 	andeq	r1, r0, r0, asr r5
}
 6e0:	00000050 	andeq	r0, r0, r0, asr r0
 6e4:	83100e41 	tsthi	r0, #1040	@ 0x410
 6e8:	85038404 	strhi	r8, [r3, #-1028]	@ 0xfffffbfc
 6ec:	00018e02 	andeq	r8, r1, r2, lsl #28
 6f0:	0000000c 	andeq	r0, r0, ip
 6f4:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 6f8:	7c020001 	stcvc	0, cr0, [r2], {1}
int send_ping(int argc, char** argv) {
 6fc:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    printf("Pinging the car.\n");
 700:	0000001c 	andeq	r0, r0, ip, lsl r0
    printf2("FOB_MESG PING\n");
 704:	000006f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
 708:	000015a0 	andeq	r1, r0, r0, lsr #11
}
 70c:	000000f4 	strdeq	r0, [r0], -r4
 710:	84080e41 	strhi	r0, [r8], #-3649	@ 0xfffff1bf
 714:	41018e02 	tstmi	r1, r2, lsl #28
void __attribute__((optimize("O0"), weak)) initial_setup(void) {
 718:	7502100e 	strvc	r1, [r2, #-14]
 71c:	0000080e 	andeq	r0, r0, lr, lsl #16
  char *src = &_etext, *dst = &_data;
 720:	00000018 	andeq	r0, r0, r8, lsl r0
 724:	000006f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
  if (dst != src)
 728:	00001694 	muleq	r0, r4, r6
 72c:	00000038 	andeq	r0, r0, r8, lsr r0
    while (dst < &_edata) *(dst++) = *(src++);
 730:	840c0e41 	strhi	r0, [ip], #-3649	@ 0xfffff1bf
 734:	8e028503 	cfsh32hi	mvfx8, mvfx2, #3
 738:	00000001 	andeq	r0, r0, r1
 73c:	00000018 	andeq	r0, r0, r8, lsl r0
 740:	000006f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
 744:	000016cc 	andeq	r1, r0, ip, asr #13
  for (dst = &_bss; dst < &_ebss; dst++) *dst = 0;
 748:	00000044 	andeq	r0, r0, r4, asr #32
 74c:	84040e47 	strhi	r0, [r4], #-3655	@ 0xfffff1b9
 750:	0ec45401 	cdpeq	4, 12, cr5, cr4, cr1, {0}
 754:	00000000 	andeq	r0, r0, r0
 758:	0000000c 	andeq	r0, r0, ip
 75c:	000006f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
 760:	00001710 	andeq	r1, r0, r0, lsl r7
  platform_init();
 764:	00000032 	andeq	r0, r0, r2, lsr r0
}
 768:	0000000c 	andeq	r0, r0, ip
 76c:	000006f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
 770:	00001742 	andeq	r1, r0, r2, asr #14
 774:	00000012 	andeq	r0, r0, r2, lsl r0
 778:	00000024 	andeq	r0, r0, r4, lsr #32
 77c:	000006f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
 780:	00001754 	andeq	r1, r0, r4, asr r7
static void delete(void) {
 784:	00000076 	andeq	r0, r0, r6, ror r0
  __write_char__(BACK_SPACE);
 788:	83280e42 			@ <UNDEFINED> instruction: 0x83280e42
 78c:	8509840a 	strhi	r8, [r9, #-1034]	@ 0xfffffbf6
  __write_char__(SPACE);
 790:	87078608 	strhi	r8, [r7, -r8, lsl #12]
  __write_char__(BACK_SPACE);
 794:	89058806 	stmdbhi	r5, {r1, r2, fp, pc}
 798:	8b038a04 	blhi	e2fb0 <__ROM_SIZE__+0xa2fb0>
}
 79c:	00018e02 	andeq	r8, r1, r2, lsl #28
static void clear_prompt(int char_count) {
 7a0:	00000028 	andeq	r0, r0, r8, lsr #32
  while (char_count) {
 7a4:	000006f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
    delete ();
 7a8:	000017ca 	andeq	r1, r0, sl, asr #15
  while (char_count) {
 7ac:	0000015a 	andeq	r0, r0, sl, asr r1
}
 7b0:	84240e42 	strthi	r0, [r4], #-3650	@ 0xfffff1be
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
 7b4:	86088509 	strhi	r8, [r8], -r9, lsl #10
    auto_load[i].command(0, NULL);
 7b8:	88068707 	stmdahi	r6, {r0, r1, r2, r8, r9, sl, pc}
 7bc:	8a048905 	bhi	122bd8 <__ROM_SIZE__+0xe2bd8>
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
 7c0:	8e028b03 	vmlahi.f64	d8, d2, d3
 7c4:	500e4101 	andpl	r4, lr, r1, lsl #2
 7c8:	240ea802 	strcs	sl, [lr], #-2050	@ 0xfffff7fe
 7cc:	00000018 	andeq	r0, r0, r8, lsl r0
 7d0:	000006f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
}
 7d4:	00001924 	andeq	r1, r0, r4, lsr #18
static int show_history(int argc, char **argv) {
 7d8:	00000048 	andeq	r0, r0, r8, asr #32
  uint32_t end_index = total_num_commands-1;
 7dc:	8e040e47 	cdphi	14, 0, cr0, cr4, cr7, {2}
  if (total_num_commands > NUM_HISTORY_ENTRIES) {
 7e0:	000e5601 	andeq	r5, lr, r1, lsl #12
 7e4:	000000ce 	andeq	r0, r0, lr, asr #1
    beg_index = total_num_commands - NUM_HISTORY_ENTRIES;
 7e8:	0000000c 	andeq	r0, r0, ip
 7ec:	000006f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
  uint32_t beg_index = 0;
 7f0:	0000196c 	andeq	r1, r0, ip, ror #18
    printf("%s\n", cmd_history[index % NUM_HISTORY_ENTRIES]);
 7f4:	00000032 	andeq	r0, r0, r2, lsr r0
 7f8:	00000018 	andeq	r0, r0, r8, lsl r0
 7fc:	000006f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
 800:	0000199e 	muleq	r0, lr, r9
  for (uint32_t index = beg_index; index <= end_index; ++index) {
 804:	00000044 	andeq	r0, r0, r4, asr #32
}
 808:	84100e41 	ldrhi	r0, [r0], #-3649	@ 0xfffff1bf
 80c:	86038504 	strhi	r8, [r3], -r4, lsl #10
 810:	00018e02 	andeq	r8, r1, r2, lsl #28
 814:	00000018 	andeq	r0, r0, r8, lsl r0
int cmd_exec_status(int argc, char **argv) {
 818:	000006f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
  printf("%d\n", __cmd_exec_status);
 81c:	000019e2 	andeq	r1, r0, r2, ror #19
 820:	0000003a 	andeq	r0, r0, sl, lsr r0
 824:	84100e41 	ldrhi	r0, [r0], #-3649	@ 0xfffff1bf
}
 828:	86038504 	strhi	r8, [r3], -r4, lsl #10
 82c:	00018e02 	andeq	r8, r1, r2, lsl #28
 830:	0000000c 	andeq	r0, r0, ip
static int build_info(int argc, char **argv) {
 834:	000006f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
  printf("Build: [" SHELL_VERSION ":" USER_REPO_VERSION "] - [" BUILD_USER
 838:	00001a1c 	andeq	r1, r0, ip, lsl sl
}
 83c:	0000001a 	andeq	r0, r0, sl, lsl r0
 840:	00000014 	andeq	r0, r0, r4, lsl r0
static void execute(int argc, char **argv) {
 844:	000006f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
 848:	00001a36 	andeq	r1, r0, r6, lsr sl
  for (int i = 0; table[i].command_name != NULL; i++) {
 84c:	00000008 	andeq	r0, r0, r8
 850:	83080e41 	movwhi	r0, #36417	@ 0x8e41
 854:	00018e02 	andeq	r8, r1, r2, lsl #28
 858:	00000018 	andeq	r0, r0, r8, lsl r0
 85c:	000006f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
    if (strcmp(argv[0], table[i].command_name) == 0) {
 860:	00001a3e 	andeq	r1, r0, lr, lsr sl
 864:	00000018 	andeq	r0, r0, r8, lsl r0
      __cmd_exec_status = table[i].command(argc, &argv[0]);
 868:	83100e41 	tsthi	r0, #1040	@ 0x410
 86c:	85038404 	strhi	r8, [r3, #-1028]	@ 0xfffffbfc
 870:	00018e02 	andeq	r8, r1, r2, lsl #28
 874:	00000014 	andeq	r0, r0, r4, lsl r0
 878:	000006f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
    printf("\"%s\": command not found. Use \"help\" to list all command.\n",
 87c:	00001a56 	andeq	r1, r0, r6, asr sl
 880:	0000000c 	andeq	r0, r0, ip
    __cmd_exec_status = -1;
 884:	83080e41 	movwhi	r0, #36417	@ 0x8e41
 888:	00018e02 	andeq	r8, r1, r2, lsl #28
 88c:	00000014 	andeq	r0, r0, r4, lsl r0
}
 890:	000006f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
 894:	00001a62 	andeq	r1, r0, r2, ror #20
 898:	0000000e 	andeq	r0, r0, lr
 89c:	83080e41 	movwhi	r0, #36417	@ 0x8e41
int help(int argc, char **argv) {
 8a0:	00018e02 	andeq	r8, r1, r2, lsl #28
  if (argc > 1 && (strcmp(argv[1], "-l")==0)) {
 8a4:	00000014 	andeq	r0, r0, r4, lsl r0
 8a8:	000006f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
 8ac:	00001a70 	andeq	r1, r0, r0, ror sl
 8b0:	0000000e 	andeq	r0, r0, lr
    printf("use: help -l for list only.\n\n");
 8b4:	83080e41 	movwhi	r0, #36417	@ 0x8e41
  bool verbose = true;
 8b8:	00018e02 	andeq	r8, r1, r2, lsl #28
    verbose = false;
 8bc:	0000001c 	andeq	r0, r0, ip, lsl r0
    printf("\n");
 8c0:	000006f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
    i++;
 8c4:	00001a7e 	andeq	r1, r0, lr, ror sl
  while (table[i].command_name != NULL) {
 8c8:	00000038 	andeq	r0, r0, r8, lsr r0
 8cc:	84180e42 	ldrhi	r0, [r8], #-3650	@ 0xfffff1be
 8d0:	86058506 	strhi	r8, [r5], -r6, lsl #10
    printf(table[i].command_name);
 8d4:	88038704 	stmdahi	r3, {r2, r8, r9, sl, pc}
    if (verbose) {
 8d8:	00018e02 	andeq	r8, r1, r2, lsl #28
      printf("\n\t");
 8dc:	00000024 	andeq	r0, r0, r4, lsr #32
      printf(table[i].command_help);
 8e0:	000006f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
 8e4:	00001ab6 			@ <UNDEFINED> instruction: 0x00001ab6
 8e8:	00000046 	andeq	r0, r0, r6, asr #32
    verbose = false;
 8ec:	84180e42 	ldrhi	r0, [r8], #-3650	@ 0xfffff1be
}
 8f0:	86058506 	strhi	r8, [r5], -r6, lsl #10
 8f4:	88038704 	stmdahi	r3, {r2, r8, r9, sl, pc}
 8f8:	41018e02 	tstmi	r1, r2, lsl #28
 8fc:	0e5e280e 	cdpeq	8, 5, cr2, cr14, cr14, {0}
 900:	00000018 	andeq	r0, r0, r8, lsl r0
 904:	00000020 	andeq	r0, r0, r0, lsr #32
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
 908:	000006f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
static void add_command_to_history(const char *cmd_str) {
 90c:	00001afc 	strdeq	r1, [r0], -ip
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
 910:	00000074 	andeq	r0, r0, r4, ror r0
 914:	84140e41 	ldrhi	r0, [r4], #-3649	@ 0xfffff1bf
  int index = total_num_commands % NUM_HISTORY_ENTRIES;
 918:	86048505 	strhi	r8, [r4], -r5, lsl #10
 91c:	8e028703 	cdphi	7, 0, cr8, cr2, cr3, {0}
 920:	280e4101 	stmdacs	lr, {r0, r8, lr}
 924:	00140e77 	andseq	r0, r4, r7, ror lr
  memcpy(&cmd_history[index], cmd_str, LINE_BUFF_SIZE);
 928:	0000000c 	andeq	r0, r0, ip
 92c:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 930:	7c020001 	stcvc	0, cr0, [r2], {1}
 934:	000d0c0e 	andeq	r0, sp, lr, lsl #24
  total_num_commands++;
 938:	0000000c 	andeq	r0, r0, ip
  curr_command_ptr = total_num_commands;
 93c:	00000928 	andeq	r0, r0, r8, lsr #18
 940:	00001b70 	andeq	r1, r0, r0, ror fp
 944:	00000012 	andeq	r0, r0, r2, lsl r0
 948:	0000000c 	andeq	r0, r0, ip
 94c:	00000928 	andeq	r0, r0, r8, lsr #18
static int parse_line(char **argv, char *line_buff, int argument_size) {
 950:	00001b82 	andeq	r1, r0, r2, lsl #23
 954:	0000001a 	andeq	r0, r0, sl, lsl r0
  int length = strlen(line_buff);
 958:	0000000c 	andeq	r0, r0, ip
 95c:	00000928 	andeq	r0, r0, r8, lsr #18
  int argc = 0;
 960:	00001b9c 	muleq	r0, ip, fp
         pos++)
 964:	00000014 	andeq	r0, r0, r4, lsl r0
    for (; line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
 968:	0000001c 	andeq	r0, r0, ip, lsl r0
 96c:	00000928 	andeq	r0, r0, r8, lsr #18
 970:	00001bb0 			@ <UNDEFINED> instruction: 0x00001bb0
 974:	00000024 	andeq	r0, r0, r4, lsr #32
    if (line_buff[pos] == '\t' || line_buff[pos] == SPACE)
 978:	840c0e41 	strhi	r0, [ip], #-3649	@ 0xfffff1bf
 97c:	8e028503 	cfsh32hi	mvfx8, mvfx2, #3
      line_buff[pos] = END_OF_LINE;
 980:	280e4101 	stmdacs	lr, {r0, r8, lr}
  while (pos <= length) {
 984:	000c0e4f 	andeq	r0, ip, pc, asr #28
    if (line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
 988:	0000000c 	andeq	r0, r0, ip
 98c:	00000928 	andeq	r0, r0, r8, lsr #18
 990:	00001bd4 	ldrdeq	r1, [r0], -r4
 994:	0000001e 	andeq	r0, r0, lr, lsl r0
      argv[argc++] = &line_buff[pos];
 998:	0000000c 	andeq	r0, r0, ip
 99c:	00000928 	andeq	r0, r0, r8, lsr #18
}
 9a0:	00001bf2 	strdeq	r1, [r0], -r2
static int prefix_match(char *sub, int len, const char *str) {
 9a4:	00000012 	andeq	r0, r0, r2, lsl r0
 9a8:	0000000c 	andeq	r0, r0, ip
  if (sub == NULL || str == NULL || len <= 0 || len > strlen(str)) {
 9ac:	00000928 	andeq	r0, r0, r8, lsr #18
 9b0:	00001c04 	andeq	r1, r0, r4, lsl #24
 9b4:	0000001a 	andeq	r0, r0, sl, lsl r0
 9b8:	0000000c 	andeq	r0, r0, ip
  for (int i = 0; i<len; ++i) {
 9bc:	00000928 	andeq	r0, r0, r8, lsr #18
 9c0:	00001c1e 	andeq	r1, r0, lr, lsl ip
    if (sub[i] != str[i]) {
 9c4:	0000002a 	andeq	r0, r0, sl, lsr #32
 9c8:	00000018 	andeq	r0, r0, r8, lsl r0
  for (int i = 0; i<len; ++i) {
 9cc:	00000928 	andeq	r0, r0, r8, lsr #18
}
 9d0:	00001c48 	andeq	r1, r0, r8, asr #24
  return TRUE;
 9d4:	00000074 	andeq	r0, r0, r4, ror r0
      return FALSE;
 9d8:	84040e41 	strhi	r0, [r4], #-3649	@ 0xfffff1bf
}
 9dc:	c40a6001 	strgt	r6, [sl], #-1
static void handle_up_arrow(char *cmd_buff, int *char_count) {
 9e0:	0b41000e 	bleq	1040a20 <__ROM_SIZE__+0x1000a20>
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
 9e4:	0000000c 	andeq	r0, r0, ip
 9e8:	00000928 	andeq	r0, r0, r8, lsr #18
 9ec:	00001cbc 			@ <UNDEFINED> instruction: 0x00001cbc
 9f0:	00000014 	andeq	r0, r0, r4, lsl r0
      curr_command_ptr == 0) {
 9f4:	0000000c 	andeq	r0, r0, ip
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
 9f8:	00000928 	andeq	r0, r0, r8, lsr #18
    printf("%s", cmd_buff);
 9fc:	00001cd0 	ldrdeq	r1, [r0], -r0
 a00:	00000022 	andeq	r0, r0, r2, lsr #32
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
 a04:	00000018 	andeq	r0, r0, r8, lsl r0
 a08:	00000928 	andeq	r0, r0, r8, lsr #18
  curr_command_ptr--;
 a0c:	00001cf2 	strdeq	r1, [r0], -r2
 a10:	00000022 	andeq	r0, r0, r2, lsr #32
 a14:	84080e44 	strhi	r0, [r8], #-3652	@ 0xfffff1bc
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
 a18:	4b018502 	blmi	61e28 <__ROM_SIZE__+0x21e28>
 a1c:	000ec4c5 	andeq	ip, lr, r5, asr #9
 a20:	0000000c 	andeq	r0, r0, ip
 a24:	00000928 	andeq	r0, r0, r8, lsr #18
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
 a28:	00001d14 	andeq	r1, r0, r4, lsl sp
 a2c:	0000000a 	andeq	r0, r0, sl
 a30:	00000020 	andeq	r0, r0, r0, lsr #32
  *char_count = strlen(cmd_buff);
 a34:	00000928 	andeq	r0, r0, r8, lsr #18
 a38:	00001d1e 	andeq	r1, r0, lr, lsl sp
  printf("%s", cmd_buff);
 a3c:	00000076 	andeq	r0, r0, r6, ror r0
 a40:	84100e41 	ldrhi	r0, [r0], #-3649	@ 0xfffff1bf
 a44:	86038504 	strhi	r8, [r3], -r4, lsl #10
 a48:	41018e02 	tstmi	r1, r2, lsl #28
 a4c:	0e76280e 	cdpeq	8, 7, cr2, cr6, cr14, {0}
static void handle_down_arrow(char *cmd_buff, int *char_count) {
 a50:	00000010 	andeq	r0, r0, r0, lsl r0
 a54:	00000020 	andeq	r0, r0, r0, lsr #32
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
 a58:	00000928 	andeq	r0, r0, r8, lsr #18
 a5c:	00001d94 	muleq	r0, r4, sp
  *char_count = 0;
 a60:	00000084 	andeq	r0, r0, r4, lsl #1
  if (curr_command_ptr == total_num_commands) return;
 a64:	84140e41 	ldrhi	r0, [r4], #-3649	@ 0xfffff1bf
 a68:	86048505 	strhi	r8, [r4], -r5, lsl #10
 a6c:	8e028703 	cdphi	7, 0, cr8, cr2, cr3, {0}
  curr_command_ptr++;
 a70:	780e4101 	stmdavc	lr, {r0, r8, lr}
 a74:	00140e7c 	andseq	r0, r4, ip, ror lr
 a78:	00000018 	andeq	r0, r0, r8, lsl r0
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
 a7c:	00000928 	andeq	r0, r0, r8, lsr #18
 a80:	00001e18 	andeq	r1, r0, r8, lsl lr
 a84:	00000016 	andeq	r0, r0, r6, lsl r0
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
 a88:	83100e41 	tsthi	r0, #1040	@ 0x410
 a8c:	85038404 	strhi	r8, [r3, #-1028]	@ 0xfffffbfc
 a90:	00018e02 	andeq	r8, r1, r2, lsl #28
 a94:	00000014 	andeq	r0, r0, r4, lsl r0
  *char_count = strlen(cmd_buff);
 a98:	00000928 	andeq	r0, r0, r8, lsr #18
 a9c:	00001e2e 	andeq	r1, r0, lr, lsr #28
  printf("%s", cmd_buff);
 aa0:	00000010 	andeq	r0, r0, r0, lsl r0
 aa4:	84080e41 	strhi	r0, [r8], #-3649	@ 0xfffff1bf
}
 aa8:	00018e02 	andeq	r8, r1, r2, lsl #28
 aac:	00000014 	andeq	r0, r0, r4, lsl r0
void set_read_char(int (*func)(void)) { __read_char__ = func; }
 ab0:	00000928 	andeq	r0, r0, r8, lsr #18
 ab4:	00001e3e 	andeq	r1, r0, lr, lsr lr
 ab8:	00000016 	andeq	r0, r0, r6, lsl r0
void set_read_char2(int (*func)(void)) { __read_char2__ = func; }
 abc:	84080e41 	strhi	r0, [r8], #-3649	@ 0xfffff1bf
 ac0:	00018e02 	andeq	r8, r1, r2, lsl #28
 ac4:	00000020 	andeq	r0, r0, r0, lsr #32
void set_write_char(void (*func)(char)) { __write_char__ = func; }
 ac8:	00000928 	andeq	r0, r0, r8, lsr #18
 acc:	00001e54 	andeq	r1, r0, r4, asr lr
 ad0:	0000006e 	andeq	r0, r0, lr, rrx
void set_write_char2(void (*func)(char)) { __write_char2__ = func; }
 ad4:	840c0e41 	strhi	r0, [ip], #-3649	@ 0xfffff1bf
 ad8:	8e028503 	cfsh32hi	mvfx8, mvfx2, #3
 adc:	280e4101 	stmdacs	lr, {r0, r8, lr}
}
 ae0:	0c0e0a49 			@ <UNDEFINED> instruction: 0x0c0e0a49
}
 ae4:	00000b41 	andeq	r0, r0, r1, asr #22
  if (cmd_buff == NULL || char_count <= 0) {
 ae8:	00000024 	andeq	r0, r0, r4, lsr #32
static void handle_tab(char *cmd_buff, int *char_count) {
 aec:	00000928 	andeq	r0, r0, r8, lsr #18
 af0:	00001ec2 	andeq	r1, r0, r2, asr #29
  int last_match = -1;
 af4:	000000d4 	ldrdeq	r0, [r0], -r4
  int match_count = 0;
 af8:	84140e41 	ldrhi	r0, [r4], #-3649	@ 0xfffff1bf
  int i = 0;
 afc:	86048505 	strhi	r8, [r4], -r5, lsl #10
    i++;
 b00:	8e028703 	cdphi	7, 0, cr8, cr2, cr3, {0}
  while (table[i].command_name != NULL) { //loop over all commands
 b04:	780e4101 	stmdavc	lr, {r0, r8, lr}
 b08:	140e0a64 	strne	r0, [lr], #-2660	@ 0xfffff59c
 b0c:	00000b41 	andeq	r0, r0, r1, asr #22
    if (prefix_match(cmd_buff, *char_count, table[i].command_name)) {
 b10:	00000020 	andeq	r0, r0, r0, lsr #32
 b14:	00000928 	andeq	r0, r0, r8, lsr #18
 b18:	00001f96 	muleq	r0, r6, pc	@ <UNPREDICTABLE>
      match_count++;
 b1c:	00000056 	andeq	r0, r0, r6, asr r0
      printf("\n%s", table[i].command_name);
 b20:	84140e41 	ldrhi	r0, [r4], #-3649	@ 0xfffff1bf
 b24:	86048505 	strhi	r8, [r4], -r5, lsl #10
      last_match = i;
 b28:	8e028703 	cdphi	7, 0, cr8, cr2, cr3, {0}
  if (match_count == 1) {
 b2c:	480e4101 	stmdami	lr, {r0, r8, lr}
 b30:	00140e68 	andseq	r0, r4, r8, ror #28
  if (match_count) {
 b34:	00000020 	andeq	r0, r0, r0, lsr #32
}
 b38:	00000928 	andeq	r0, r0, r8, lsr #18
    memcpy(cmd_buff, table[last_match].command_name, LINE_BUFF_SIZE);
 b3c:	00001fec 	andeq	r1, r0, ip, ror #31
 b40:	00000068 	andeq	r0, r0, r8, rrx
 b44:	840c0e41 	strhi	r0, [ip], #-3649	@ 0xfffff1bf
 b48:	8e028503 	cfsh32hi	mvfx8, mvfx2, #3
    *char_count = strlen(cmd_buff);
 b4c:	400e4101 	andmi	r4, lr, r1, lsl #2
 b50:	0c0e0a47 			@ <UNDEFINED> instruction: 0x0c0e0a47
 b54:	00000b41 	andeq	r0, r0, r1, asr #22
    printf("\n");
 b58:	0000001c 	andeq	r0, r0, ip, lsl r0
 b5c:	00000928 	andeq	r0, r0, r8, lsr #18
    prepend_prompt();
 b60:	00002054 	andeq	r2, r0, r4, asr r0
    printf(PROMPT);
 b64:	00000054 	andeq	r0, r0, r4, asr r0
 b68:	83180e41 	tsthi	r8, #1040	@ 0x410
    printf("%s", cmd_buff);
 b6c:	85058406 	strhi	r8, [r5, #-1030]	@ 0xfffffbfa
 b70:	87038604 	strhi	r8, [r3, -r4, lsl #12]
 b74:	00018e02 	andeq	r8, r1, r2, lsl #28
 b78:	0000001c 	andeq	r0, r0, ip, lsl r0
 b7c:	00000928 	andeq	r0, r0, r8, lsr #18
 b80:	000020a8 	andeq	r2, r0, r8, lsr #1
 b84:	00000048 	andeq	r0, r0, r8, asr #32
__attribute__((weak)) int active_prompt() { return TRUE; }
 b88:	83180e41 	tsthi	r8, #1040	@ 0x410
static void shell(void) {
 b8c:	85058406 	strhi	r8, [r5, #-1030]	@ 0xfffffbfa
  int count = 0;
 b90:	87038604 	strhi	r8, [r3, -r4, lsl #12]
  for (int i = 0; i < LINE_BUFF_SIZE; i++) line_buff[i] = 0;
 b94:	00018e02 	andeq	r8, r1, r2, lsl #28
 b98:	0000000c 	andeq	r0, r0, ip
 b9c:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 ba0:	7c020001 	stcvc	0, cr0, [r2], {1}
 ba4:	000d0c0e 	andeq	r0, sp, lr, lsl #24
  for (int i = 0; i < MAX_ARG_COUNT; i++) argv[i] = NULL;
 ba8:	0000000c 	andeq	r0, r0, ip
 bac:	00000b98 	muleq	r0, r8, fp
 bb0:	000020f0 	strdeq	r2, [r0], -r0
 bb4:	0000001e 	andeq	r0, r0, lr, lsl r0
 bb8:	0000000c 	andeq	r0, r0, ip
  prepend_prompt();
 bbc:	00000b98 	muleq	r0, r8, fp
  printf(PROMPT);
 bc0:	0000210e 	andeq	r2, r0, lr, lsl #2
  int special_key = 0;
 bc4:	0000003e 	andeq	r0, r0, lr, lsr r0
        special_key = 1;
 bc8:	0000000c 	andeq	r0, r0, ip
    if (s == -1) { s = __read_char2__();}
 bcc:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 bd0:	7c020001 	stcvc	0, cr0, [r2], {1}
    if (s != -1) {
 bd4:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 bd8:	00000020 	andeq	r0, r0, r0, lsr #32
      loop();
 bdc:	00000bc8 	andeq	r0, r0, r8, asr #23
        line_buff[count] = END_OF_LINE;
 be0:	0000214c 	andeq	r2, r0, ip, asr #2
 be4:	00000040 	andeq	r0, r0, r0, asr #32
 be8:	84100e44 	ldrhi	r0, [r0], #-3652	@ 0xfffff1bc
 bec:	86038504 	strhi	r8, [r3], -r4, lsl #10
        __write_char__(NEW_LINE);
 bf0:	59018e02 	stmdbpl	r1, {r1, r9, sl, fp, pc}
 bf4:	c5c4000e 	strbgt	r0, [r4, #14]
  add_command_to_history(line_buff);
 bf8:	0000cec6 	andeq	ip, r0, r6, asr #29
  argc = parse_line(argv, line_buff, MAX_ARG_COUNT);
 bfc:	0000000c 	andeq	r0, r0, ip
 c00:	00000bc8 	andeq	r0, r0, r8, asr #23
 c04:	0000218c 	andeq	r2, r0, ip, lsl #3
  if (argc > 0) execute(argc, argv);
 c08:	00000040 	andeq	r0, r0, r0, asr #32
}
 c0c:	0000000c 	andeq	r0, r0, ip
        if (!__echo) {
 c10:	00000bc8 	andeq	r0, r0, r8, asr #23
 c14:	000021cc 	andeq	r2, r0, ip, asr #3
        if (count == 0) continue;
 c18:	0000002c 	andeq	r0, r0, ip, lsr #32
        count--;
 c1c:	0000000c 	andeq	r0, r0, ip
        line_buff[count] = END_OF_LINE;
 c20:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 c24:	7c020001 	stcvc	0, cr0, [r2], {1}
 c28:	000d0c0e 	andeq	r0, sp, lr, lsl #24
        delete ();
 c2c:	0000000c 	andeq	r0, r0, ip
      if (__echo) {
 c30:	00000c1c 	andeq	r0, r0, ip, lsl ip
        __write_char__(c);
 c34:	000021f8 	strdeq	r2, [r0], -r8
 c38:	00000010 	andeq	r0, r0, r0, lsl r0
    if (!active_prompt()) {
 c3c:	0000000c 	andeq	r0, r0, ip
 c40:	00000c1c 	andeq	r0, r0, ip, lsl ip
    s = __read_char__();
 c44:	00002208 	andeq	r2, r0, r8, lsl #4
 c48:	00000016 	andeq	r0, r0, r6, lsl r0
    if (s == -1) { s = __read_char2__();}
 c4c:	0000000c 	andeq	r0, r0, ip
 c50:	00000c1c 	andeq	r0, r0, ip, lsl ip
      if (c == CARRIAGE_RETURN || c == NEW_LINE) {
 c54:	0000221e 	andeq	r2, r0, lr, lsl r2
 c58:	00000014 	andeq	r0, r0, r4, lsl r0
      if (c == DELETE || c == BACK_SPACE) {
 c5c:	0000000c 	andeq	r0, r0, ip
 c60:	00000c1c 	andeq	r0, r0, ip, lsl ip
      } else if (c == ESCAPE) {
 c64:	00002232 	andeq	r2, r0, r2, lsr r2
      } else if (c == SQUARE_BRACKET_OPEN && special_key == 1) {
 c68:	00000016 	andeq	r0, r0, r6, lsl r0
      } else if ((c == 'C' || c == 'D') && special_key != 0) {
 c6c:	0000000c 	andeq	r0, r0, ip
 c70:	00000c1c 	andeq	r0, r0, ip, lsl ip
 c74:	00002248 	andeq	r2, r0, r8, asr #4
      } else if ((c == 'A' || c == 'B') && special_key == 2) {
 c78:	00000010 	andeq	r0, r0, r0, lsl r0

Disassembly of section .debug_rnglists:

00000000 <.debug_rnglists>:
   0:	00000013 	andeq	r0, r0, r3, lsl r0
   4:	00040005 	andeq	r0, r4, r5
   8:	00000000 	andeq	r0, r0, r0
   c:	b605a404 	strlt	sl, [r5], -r4, lsl #8
  10:	05bc0405 	ldreq	r0, [ip, #1029]!	@ 0x405
  14:	3e0005c2 	cfsh32cc	mvfx0, mvfx0, #-30
  18:	05000000 	streq	r0, [r0, #-0]
  1c:	00000400 	andeq	r0, r0, r0, lsl #8
  20:	04000000 	streq	r0, [r0], #-0
  24:	50044e30 	andpl	r4, r4, r0, lsr lr
  28:	01ca0452 	biceq	r0, sl, r2, asr r4
  2c:	9204028e 	andls	r0, r4, #-536870904	@ 0xe0000008
  30:	0402ba02 	streq	fp, [r2], #-2562	@ 0xfffff5fe
  34:	02dc02c2 	sbcseq	r0, ip, #536870924	@ 0x2000000c
  38:	02920400 	addseq	r0, r2, #0, 8
  3c:	a40402a0 	strge	r0, [r4], #-672	@ 0xfffffd60
  40:	0002b402 	andeq	fp, r2, r2, lsl #8
  44:	01c66204 	biceq	r6, r6, r4, lsl #4
  48:	c202be04 	andgt	fp, r2, #4, 28	@ 0x40
  4c:	ee040002 	cdp	0, 0, cr0, cr4, cr2, {0}
  50:	04048e03 	streq	r8, [r4], #-3587	@ 0xfffff1fd
  54:	04a2049e 	strteq	r0, [r2], #1182	@ 0x49e
  58:	00003e00 	andeq	r3, r0, r0, lsl #28
  5c:	04000500 	streq	r0, [r0], #-1280	@ 0xfffffb00
  60:	00000000 	andeq	r0, r0, r0
  64:	4e300400 	cfabssmi	mvf0, mvf0
  68:	04525004 	ldrbeq	r5, [r2], #-4
  6c:	028e01ca 	addeq	r0, lr, #-2147483598	@ 0x80000032
  70:	ba029204 	blt	a4888 <__ROM_SIZE__+0x64888>
  74:	02c20402 	sbceq	r0, r2, #33554432	@ 0x2000000
  78:	040002dc 	streq	r0, [r0], #-732	@ 0xfffffd24
  7c:	02a00292 	adceq	r0, r0, #536870921	@ 0x20000009
  80:	b402a404 	strlt	sl, [r2], #-1028	@ 0xfffffbfc
  84:	62040002 	andvs	r0, r4, #2
  88:	be0401c6 	adfltdm	f0, f4, f6
  8c:	0002c202 	andeq	ip, r2, r2, lsl #4
  90:	8e03ee04 	cdphi	14, 0, cr14, cr3, cr4, {0}
  94:	049e0404 	ldreq	r0, [lr], #1028	@ 0x404
  98:	110004a2 	smlatbne	r0, r2, r4, r0
  9c:	05000000 	streq	r0, [r0, #-0]
  a0:	00000400 	andeq	r0, r0, r0, lsl #8
  a4:	04000000 	streq	r0, [r0], #-0
  a8:	8a047c78 	bhi	11f290 <__ROM_SIZE__+0xdf290>
  ac:	00019c01 	andeq	r9, r1, r1, lsl #24
  b0:	0000001e 	andeq	r0, r0, lr, lsl r0
  b4:	00040005 	andeq	r0, r4, r5
  b8:	00000000 	andeq	r0, r0, r0
  bc:	d001c404 	andle	ip, r1, r4, lsl #8
  c0:	01d20401 	bicseq	r0, r2, r1, lsl #8
  c4:	040001d8 	streq	r0, [r0], #-472	@ 0xfffffe28
  c8:	02c6029c 	sbceq	r0, r6, #156, 4	@ 0xc0000009
  cc:	cc02c804 	stcgt	8, cr12, [r2], {4}
  d0:	00160002 	andseq	r0, r6, r2
  d4:	00050000 	andeq	r0, r5, r0
  d8:	00000004 	andeq	r0, r0, r4
  dc:	02040000 	andeq	r0, r4, #0
  e0:	1c060404 	cfstrsne	mvf0, [r6], {4}
  e4:	22200400 	eorcs	r0, r0, #0, 8
  e8:	005a2404 	subseq	r2, sl, r4, lsl #8
