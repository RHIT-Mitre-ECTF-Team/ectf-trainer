
shell.elf:     file format elf32-littlearm


Disassembly of section .data:

20000000 <__echo>:
20000000:	00000001 	andeq	r0, r0, r1

20000004 <AES_key_b64>:
int pairing_PIN = 123456;
int fob_ID = 1234;

// AES control struct and default key set here
struct AES_ctx ctx;
uint8_t AES_key_b64[44] = "3q2+796tvu/erb7v3q2+796tvu/erb7v3q2+796tvu8=";
20000004:	2b327133 	blcs	20c9c4d8 <_STACK_TOP_+0xc944dc>
20000008:	74363937 	ldrtvc	r3, [r6], #-2359	@ 0xfffff6c9
2000000c:	652f7576 	strvs	r7, [pc, #-1398]!	@ 1ffffa9e <__ROM_SIZE__+0x1ffbfa9e>
20000010:	76376272 			@ <UNDEFINED> instruction: 0x76376272
20000014:	2b327133 	blcs	20c9c4e8 <_STACK_TOP_+0xc944ec>
20000018:	74363937 	ldrtvc	r3, [r6], #-2359	@ 0xfffff6c9
2000001c:	652f7576 	strvs	r7, [pc, #-1398]!	@ 1ffffaae <__ROM_SIZE__+0x1ffbfaae>
20000020:	76376272 			@ <UNDEFINED> instruction: 0x76376272
20000024:	2b327133 	blcs	20c9c4f8 <_STACK_TOP_+0xc944fc>
20000028:	74363937 	ldrtvc	r3, [r6], #-2359	@ 0xfffff6c9
2000002c:	3d387576 	cfldr32cc	mvfx7, [r8, #-472]!	@ 0xfffffe28

20000030 <ECDH_privkey_b64>:
uint8_t AES_key[AES_KEYLEN];

uint8_t ECDH_privkey_b64[32] = "DeyvDeyvDeyvDeyvDeyvDeyvDeyvDeyv";
20000030:	76796544 	ldrbtvc	r6, [r9], -r4, asr #10
20000034:	76796544 	ldrbtvc	r6, [r9], -r4, asr #10
20000038:	76796544 	ldrbtvc	r6, [r9], -r4, asr #10
2000003c:	76796544 	ldrbtvc	r6, [r9], -r4, asr #10
20000040:	76796544 	ldrbtvc	r6, [r9], -r4, asr #10
20000044:	76796544 	ldrbtvc	r6, [r9], -r4, asr #10
20000048:	76796544 	ldrbtvc	r6, [r9], -r4, asr #10
2000004c:	76796544 	ldrbtvc	r6, [r9], -r4, asr #10

20000050 <fob_ID>:
int fob_ID = 1234;
20000050:	000004d2 	ldrdeq	r0, [r0], -r2

20000054 <pairing_PIN>:
int pairing_PIN = 123456;
20000054:	0001e240 	andeq	lr, r1, r0, asr #4

Disassembly of section .bss:

20000058 <__write_char__>:
20000058:	00000000 	andeq	r0, r0, r0

2000005c <total_num_commands>:
 * To reduce the shell size the history feature
 * is made optional. Skip history feature if
 * SHELL_NO_HISTORY is defined.
 */
#ifndef SHELL_NO_HISTORY
static volatile int total_num_commands = 0;
2000005c:	00000000 	andeq	r0, r0, r0

20000060 <cmd_history>:
	...

20000160 <__cmd_exec_status>:
static volatile int __cmd_exec_status;
20000160:	00000000 	andeq	r0, r0, r0

20000164 <curr_command_ptr>:
static volatile int curr_command_ptr = 0;
20000164:	00000000 	andeq	r0, r0, r0

20000168 <__read_char__>:
int (*__read_char__)(void);
20000168:	00000000 	andeq	r0, r0, r0

2000016c <__read_char2__>:
int (*__read_char2__)(void);
2000016c:	00000000 	andeq	r0, r0, r0

20000170 <__write_char2__>:
void (*__write_char2__)(char c);
20000170:	00000000 	andeq	r0, r0, r0

20000174 <AES_key>:
	...

20000194 <ctx>:
	...

20000294 <ECDH_AESkey>:
	...

200002b4 <ECDH_shared>:
	...

200002e4 <ECDH_pubkey>:
	...

20000314 <ECDH_privkey>:
	...

2000032c <selected_mode>:

#include "memlog.h"
#include "string.h"

static rgn_info_t inp_buf_rgn, out_buf_rgn;
static mode_t selected_mode = NONE;
2000032c:	00000000 	andeq	r0, r0, r0

20000330 <out_buf_rgn>:
	...

2000033c <inp_buf_rgn>:
	...

Disassembly of section .text:

00000000 <vector_table>:
       0:	20007ffc 	strdcs	r7, [r0], -ip
       4:	00002905 	andeq	r2, r0, r5, lsl #18
       8:	00000555 	andeq	r0, r0, r5, asr r5
       c:	00000555 	andeq	r0, r0, r5, asr r5
      10:	00000555 	andeq	r0, r0, r5, asr r5
      14:	00000555 	andeq	r0, r0, r5, asr r5
      18:	00000555 	andeq	r0, r0, r5, asr r5
	...
      2c:	00000555 	andeq	r0, r0, r5, asr r5
      30:	00000555 	andeq	r0, r0, r5, asr r5
      34:	00000555 	andeq	r0, r0, r5, asr r5
	...
      40:	00000555 	andeq	r0, r0, r5, asr r5
      44:	00000555 	andeq	r0, r0, r5, asr r5
      48:	00000555 	andeq	r0, r0, r5, asr r5
      4c:	00000555 	andeq	r0, r0, r5, asr r5
      50:	00000555 	andeq	r0, r0, r5, asr r5
      54:	00000555 	andeq	r0, r0, r5, asr r5
      58:	00000555 	andeq	r0, r0, r5, asr r5
      5c:	00000555 	andeq	r0, r0, r5, asr r5
      60:	00000555 	andeq	r0, r0, r5, asr r5
      64:	00000555 	andeq	r0, r0, r5, asr r5
      68:	00000555 	andeq	r0, r0, r5, asr r5
      6c:	00000555 	andeq	r0, r0, r5, asr r5
      70:	00000555 	andeq	r0, r0, r5, asr r5
      74:	00000555 	andeq	r0, r0, r5, asr r5
      78:	00000555 	andeq	r0, r0, r5, asr r5
      7c:	00000555 	andeq	r0, r0, r5, asr r5
      80:	00000555 	andeq	r0, r0, r5, asr r5
      84:	00000555 	andeq	r0, r0, r5, asr r5
      88:	00000555 	andeq	r0, r0, r5, asr r5
      8c:	00000555 	andeq	r0, r0, r5, asr r5
      90:	00000555 	andeq	r0, r0, r5, asr r5
      94:	00000555 	andeq	r0, r0, r5, asr r5
      98:	00000555 	andeq	r0, r0, r5, asr r5
      9c:	00000555 	andeq	r0, r0, r5, asr r5
      a0:	00000555 	andeq	r0, r0, r5, asr r5
      a4:	00000555 	andeq	r0, r0, r5, asr r5
      a8:	00000555 	andeq	r0, r0, r5, asr r5
      ac:	00000555 	andeq	r0, r0, r5, asr r5
      b0:	00000555 	andeq	r0, r0, r5, asr r5
      b4:	00000555 	andeq	r0, r0, r5, asr r5
      b8:	00000555 	andeq	r0, r0, r5, asr r5
      bc:	00000555 	andeq	r0, r0, r5, asr r5
      c0:	00000555 	andeq	r0, r0, r5, asr r5
      c4:	00000555 	andeq	r0, r0, r5, asr r5
      c8:	00000555 	andeq	r0, r0, r5, asr r5
      cc:	00000555 	andeq	r0, r0, r5, asr r5
      d0:	00000555 	andeq	r0, r0, r5, asr r5
      d4:	00000555 	andeq	r0, r0, r5, asr r5
      d8:	00000555 	andeq	r0, r0, r5, asr r5
      dc:	00000555 	andeq	r0, r0, r5, asr r5
      e0:	00000555 	andeq	r0, r0, r5, asr r5
      e4:	00000555 	andeq	r0, r0, r5, asr r5
      e8:	00000555 	andeq	r0, r0, r5, asr r5
      ec:	00000555 	andeq	r0, r0, r5, asr r5
      f0:	00000555 	andeq	r0, r0, r5, asr r5
      f4:	00000555 	andeq	r0, r0, r5, asr r5
      f8:	00000555 	andeq	r0, r0, r5, asr r5
      fc:	00000555 	andeq	r0, r0, r5, asr r5
     100:	00000555 	andeq	r0, r0, r5, asr r5
     104:	00000555 	andeq	r0, r0, r5, asr r5
     108:	00000555 	andeq	r0, r0, r5, asr r5
     10c:	00000555 	andeq	r0, r0, r5, asr r5
     110:	00000555 	andeq	r0, r0, r5, asr r5
     114:	00000555 	andeq	r0, r0, r5, asr r5
     118:	00000555 	andeq	r0, r0, r5, asr r5
     11c:	00000555 	andeq	r0, r0, r5, asr r5
     120:	00000555 	andeq	r0, r0, r5, asr r5
     124:	00000555 	andeq	r0, r0, r5, asr r5
     128:	00000555 	andeq	r0, r0, r5, asr r5
     12c:	00000555 	andeq	r0, r0, r5, asr r5
     130:	00000555 	andeq	r0, r0, r5, asr r5
     134:	00000555 	andeq	r0, r0, r5, asr r5
     138:	00000555 	andeq	r0, r0, r5, asr r5
     13c:	00000555 	andeq	r0, r0, r5, asr r5
     140:	00000555 	andeq	r0, r0, r5, asr r5
     144:	00000555 	andeq	r0, r0, r5, asr r5
     148:	00000555 	andeq	r0, r0, r5, asr r5
     14c:	00000555 	andeq	r0, r0, r5, asr r5
     150:	00000555 	andeq	r0, r0, r5, asr r5
     154:	00000555 	andeq	r0, r0, r5, asr r5
     158:	00000555 	andeq	r0, r0, r5, asr r5
     15c:	00000555 	andeq	r0, r0, r5, asr r5
     160:	00000555 	andeq	r0, r0, r5, asr r5
     164:	00000555 	andeq	r0, r0, r5, asr r5
     168:	00000555 	andeq	r0, r0, r5, asr r5
     16c:	00000555 	andeq	r0, r0, r5, asr r5
     170:	00000555 	andeq	r0, r0, r5, asr r5
     174:	00000555 	andeq	r0, r0, r5, asr r5
     178:	00000555 	andeq	r0, r0, r5, asr r5
     17c:	00000555 	andeq	r0, r0, r5, asr r5
     180:	00000555 	andeq	r0, r0, r5, asr r5
     184:	00000555 	andeq	r0, r0, r5, asr r5
     188:	00000555 	andeq	r0, r0, r5, asr r5
     18c:	00000555 	andeq	r0, r0, r5, asr r5
     190:	00000555 	andeq	r0, r0, r5, asr r5
     194:	00000555 	andeq	r0, r0, r5, asr r5
     198:	00000555 	andeq	r0, r0, r5, asr r5
     19c:	00000555 	andeq	r0, r0, r5, asr r5
     1a0:	00000555 	andeq	r0, r0, r5, asr r5
     1a4:	00000555 	andeq	r0, r0, r5, asr r5
     1a8:	00000555 	andeq	r0, r0, r5, asr r5
     1ac:	00000555 	andeq	r0, r0, r5, asr r5
     1b0:	00000555 	andeq	r0, r0, r5, asr r5
     1b4:	00000555 	andeq	r0, r0, r5, asr r5
     1b8:	00000555 	andeq	r0, r0, r5, asr r5
     1bc:	00000555 	andeq	r0, r0, r5, asr r5
     1c0:	00000555 	andeq	r0, r0, r5, asr r5
     1c4:	00000555 	andeq	r0, r0, r5, asr r5
     1c8:	00000555 	andeq	r0, r0, r5, asr r5
     1cc:	00000555 	andeq	r0, r0, r5, asr r5
     1d0:	00000555 	andeq	r0, r0, r5, asr r5
     1d4:	00000555 	andeq	r0, r0, r5, asr r5
     1d8:	00000555 	andeq	r0, r0, r5, asr r5
     1dc:	00000555 	andeq	r0, r0, r5, asr r5
     1e0:	00000555 	andeq	r0, r0, r5, asr r5
     1e4:	00000555 	andeq	r0, r0, r5, asr r5
     1e8:	00000555 	andeq	r0, r0, r5, asr r5
     1ec:	00000555 	andeq	r0, r0, r5, asr r5
     1f0:	00000555 	andeq	r0, r0, r5, asr r5
     1f4:	00000555 	andeq	r0, r0, r5, asr r5
     1f8:	00000555 	andeq	r0, r0, r5, asr r5
     1fc:	00000555 	andeq	r0, r0, r5, asr r5
     200:	00000555 	andeq	r0, r0, r5, asr r5
     204:	00000555 	andeq	r0, r0, r5, asr r5
     208:	00000555 	andeq	r0, r0, r5, asr r5
     20c:	00000555 	andeq	r0, r0, r5, asr r5
     210:	00000555 	andeq	r0, r0, r5, asr r5
     214:	00000555 	andeq	r0, r0, r5, asr r5
     218:	00000555 	andeq	r0, r0, r5, asr r5
     21c:	00000555 	andeq	r0, r0, r5, asr r5
     220:	00000555 	andeq	r0, r0, r5, asr r5
     224:	00000555 	andeq	r0, r0, r5, asr r5
     228:	00000555 	andeq	r0, r0, r5, asr r5
     22c:	00000555 	andeq	r0, r0, r5, asr r5
     230:	00000555 	andeq	r0, r0, r5, asr r5
     234:	00000555 	andeq	r0, r0, r5, asr r5
     238:	00000555 	andeq	r0, r0, r5, asr r5
     23c:	00000555 	andeq	r0, r0, r5, asr r5
     240:	00000555 	andeq	r0, r0, r5, asr r5
     244:	00000555 	andeq	r0, r0, r5, asr r5
     248:	00000555 	andeq	r0, r0, r5, asr r5
     24c:	00000555 	andeq	r0, r0, r5, asr r5
	...

000003c0 <finish_ecdhpair>:
// ADD_CMD(keyword, description, function name);
ADD_CMD(CAR_MESG, "Processes messages from the car", car_mesg);



int finish_ecdhpair(int argc, char** argv) {
     3c0:	b510      	push	{r4, lr}
     3c2:	b0a8      	sub	sp, #160	@ 0xa0

    if (argc == 4) {
     3c4:	2804      	cmp	r0, #4
     3c6:	d005      	beq.n	3d4 <finish_ecdhpair+0x14>

        // Reinitialize AES with new key
        AES_init_ctx(&ctx, ECDH_AESkey);

    }
    else printf("Incorrect number of arguments for PAIRECDH2\n");
     3c8:	4812      	ldr	r0, [pc, #72]	@ (414 <finish_ecdhpair+0x54>)
     3ca:	f001 f9ef 	bl	17ac <printf>
    return 0;
     3ce:	2000      	movs	r0, #0
     3d0:	b028      	add	sp, #160	@ 0xa0
     3d2:	bd10      	pop	{r4, pc}
     3d4:	460b      	mov	r3, r1
        decode_base64((uint8_t *)argv[3], 64, carpubkey);
     3d6:	466a      	mov	r2, sp
     3d8:	2140      	movs	r1, #64	@ 0x40
     3da:	68d8      	ldr	r0, [r3, #12]
     3dc:	f000 ff62 	bl	12a4 <decode_base64>
        ecdh_shared_secret(ECDH_privkey, carpubkey, ECDH_shared);
     3e0:	4c0d      	ldr	r4, [pc, #52]	@ (418 <finish_ecdhpair+0x58>)
     3e2:	4622      	mov	r2, r4
     3e4:	4669      	mov	r1, sp
     3e6:	480d      	ldr	r0, [pc, #52]	@ (41c <finish_ecdhpair+0x5c>)
     3e8:	f002 f9b4 	bl	2754 <ecdh_shared_secret>
        sha256_init(&shactx);
     3ec:	a80c      	add	r0, sp, #48	@ 0x30
     3ee:	f001 f871 	bl	14d4 <sha256_init>
	    sha256_update(&shactx, ECDH_shared, ECC_PUB_KEY_SIZE);
     3f2:	2230      	movs	r2, #48	@ 0x30
     3f4:	4621      	mov	r1, r4
     3f6:	eb0d 0002 	add.w	r0, sp, r2
     3fa:	f001 f895 	bl	1528 <sha256_update>
	    sha256_final(&shactx, ECDH_AESkey);
     3fe:	4c08      	ldr	r4, [pc, #32]	@ (420 <finish_ecdhpair+0x60>)
     400:	4621      	mov	r1, r4
     402:	a80c      	add	r0, sp, #48	@ 0x30
     404:	f001 f8b0 	bl	1568 <sha256_final>
        AES_init_ctx(&ctx, ECDH_AESkey);
     408:	4621      	mov	r1, r4
     40a:	4806      	ldr	r0, [pc, #24]	@ (424 <finish_ecdhpair+0x64>)
     40c:	f001 fe69 	bl	20e2 <AES_init_ctx>
     410:	e7dd      	b.n	3ce <finish_ecdhpair+0xe>
     412:	bf00      	nop
     414:	00002a58 	andeq	r2, r0, r8, asr sl
     418:	200002b4 			@ <UNDEFINED> instruction: 0x200002b4
     41c:	20000314 	andcs	r0, r0, r4, lsl r3
     420:	20000294 	mulcs	r0, r4, r2
     424:	20000194 	mulcs	r0, r4, r1

00000428 <car_mesg>:
int car_mesg(int argc, char** argv) {
     428:	b570      	push	{r4, r5, r6, lr}
     42a:	b09a      	sub	sp, #104	@ 0x68
     42c:	4605      	mov	r5, r0
     42e:	460e      	mov	r6, r1
    printf("Received a message from the car:");
     430:	4839      	ldr	r0, [pc, #228]	@ (518 <car_mesg+0xf0>)
     432:	f001 f9bb 	bl	17ac <printf>
    for (ctr = 1; ctr < argc; ctr++) {
     436:	2401      	movs	r4, #1
     438:	e005      	b.n	446 <car_mesg+0x1e>
        printf(" %s", argv[ctr]);
     43a:	f856 1024 	ldr.w	r1, [r6, r4, lsl #2]
     43e:	4837      	ldr	r0, [pc, #220]	@ (51c <car_mesg+0xf4>)
     440:	f001 f9b4 	bl	17ac <printf>
    for (ctr = 1; ctr < argc; ctr++) {
     444:	3401      	adds	r4, #1
     446:	42ac      	cmp	r4, r5
     448:	dbf7      	blt.n	43a <car_mesg+0x12>
    printf("\n");
     44a:	4835      	ldr	r0, [pc, #212]	@ (520 <car_mesg+0xf8>)
     44c:	f001 f9ae 	bl	17ac <printf>
    if (argc > 1) {
     450:	2d01      	cmp	r5, #1
     452:	dc02      	bgt.n	45a <car_mesg+0x32>
}
     454:	2000      	movs	r0, #0
     456:	b01a      	add	sp, #104	@ 0x68
     458:	bd70      	pop	{r4, r5, r6, pc}
        if (strcmp(argv[1], "PING_REPLY") == 0) {
     45a:	4932      	ldr	r1, [pc, #200]	@ (524 <car_mesg+0xfc>)
     45c:	6870      	ldr	r0, [r6, #4]
     45e:	f002 fa29 	bl	28b4 <strcmp>
     462:	b918      	cbnz	r0, 46c <car_mesg+0x44>
            printf("Got a ping reply.\n");
     464:	4830      	ldr	r0, [pc, #192]	@ (528 <car_mesg+0x100>)
     466:	f001 f9a1 	bl	17ac <printf>
     46a:	e7f3      	b.n	454 <car_mesg+0x2c>
        else if (strcmp(argv[1], "PAIRECDH2") == 0) {
     46c:	492f      	ldr	r1, [pc, #188]	@ (52c <car_mesg+0x104>)
     46e:	6870      	ldr	r0, [r6, #4]
     470:	f002 fa20 	bl	28b4 <strcmp>
     474:	b920      	cbnz	r0, 480 <car_mesg+0x58>
            finish_ecdhpair(argc, argv);
     476:	4631      	mov	r1, r6
     478:	4628      	mov	r0, r5
     47a:	f7ff ffa1 	bl	3c0 <finish_ecdhpair>
     47e:	e7e9      	b.n	454 <car_mesg+0x2c>
        else if (strcmp(argv[1], "AESB64") == 0) {
     480:	492b      	ldr	r1, [pc, #172]	@ (530 <car_mesg+0x108>)
     482:	6870      	ldr	r0, [r6, #4]
     484:	f002 fa16 	bl	28b4 <strcmp>
     488:	b9f8      	cbnz	r0, 4ca <car_mesg+0xa2>
            if (argc == 3) { 
     48a:	2d03      	cmp	r5, #3
     48c:	d003      	beq.n	496 <car_mesg+0x6e>
                printf("Missing AESB64 encoded message\n");
     48e:	4829      	ldr	r0, [pc, #164]	@ (534 <car_mesg+0x10c>)
     490:	f001 f98c 	bl	17ac <printf>
     494:	e7de      	b.n	454 <car_mesg+0x2c>
                len = decode_base64((uint8_t *) argv[2], strlen(argv[2]), decoded);
     496:	68b4      	ldr	r4, [r6, #8]
     498:	4620      	mov	r0, r4
     49a:	f002 fa03 	bl	28a4 <strlen>
     49e:	4601      	mov	r1, r0
     4a0:	aa01      	add	r2, sp, #4
     4a2:	4620      	mov	r0, r4
     4a4:	f000 fefe 	bl	12a4 <decode_base64>
     4a8:	4604      	mov	r4, r0
                AES_ECB_decrypt(&ctx, decoded);
     4aa:	a901      	add	r1, sp, #4
     4ac:	4822      	ldr	r0, [pc, #136]	@ (538 <car_mesg+0x110>)
     4ae:	f001 fe35 	bl	211c <AES_ECB_decrypt>
                decoded[len] = '\0';
     4b2:	f104 0368 	add.w	r3, r4, #104	@ 0x68
     4b6:	eb0d 0403 	add.w	r4, sp, r3
     4ba:	2300      	movs	r3, #0
     4bc:	f804 3c64 	strb.w	r3, [r4, #-100]
                printf("Decoded/decrypted as %s\n", decoded);
     4c0:	a901      	add	r1, sp, #4
     4c2:	481e      	ldr	r0, [pc, #120]	@ (53c <car_mesg+0x114>)
     4c4:	f001 f972 	bl	17ac <printf>
     4c8:	e7c4      	b.n	454 <car_mesg+0x2c>
        else if (strcmp(argv[1], "B64") == 0) {
     4ca:	491d      	ldr	r1, [pc, #116]	@ (540 <car_mesg+0x118>)
     4cc:	6870      	ldr	r0, [r6, #4]
     4ce:	f002 f9f1 	bl	28b4 <strcmp>
     4d2:	b9e0      	cbnz	r0, 50e <car_mesg+0xe6>
            if (argc == 3) { 
     4d4:	2d03      	cmp	r5, #3
     4d6:	d003      	beq.n	4e0 <car_mesg+0xb8>
                printf("Missing Base64 encoded message\n");
     4d8:	481a      	ldr	r0, [pc, #104]	@ (544 <car_mesg+0x11c>)
     4da:	f001 f967 	bl	17ac <printf>
     4de:	e7b9      	b.n	454 <car_mesg+0x2c>
                printf("Decoding Base64\n");
     4e0:	4819      	ldr	r0, [pc, #100]	@ (548 <car_mesg+0x120>)
     4e2:	f001 f963 	bl	17ac <printf>
                len = decode_base64((uint8_t *) argv[2], strlen(argv[2]), decoded);
     4e6:	68b4      	ldr	r4, [r6, #8]
     4e8:	4620      	mov	r0, r4
     4ea:	f002 f9db 	bl	28a4 <strlen>
     4ee:	4601      	mov	r1, r0
     4f0:	aa01      	add	r2, sp, #4
     4f2:	4620      	mov	r0, r4
     4f4:	f000 fed6 	bl	12a4 <decode_base64>
                decoded[len] = '\0';
     4f8:	f100 0368 	add.w	r3, r0, #104	@ 0x68
     4fc:	446b      	add	r3, sp
     4fe:	2200      	movs	r2, #0
     500:	f803 2c64 	strb.w	r2, [r3, #-100]
                printf("Decoded as %s", decoded);
     504:	a901      	add	r1, sp, #4
     506:	4811      	ldr	r0, [pc, #68]	@ (54c <car_mesg+0x124>)
     508:	f001 f950 	bl	17ac <printf>
     50c:	e7a2      	b.n	454 <car_mesg+0x2c>
            printf("Didn't know how to handle %s\n", argv[1]);
     50e:	6871      	ldr	r1, [r6, #4]
     510:	480f      	ldr	r0, [pc, #60]	@ (550 <car_mesg+0x128>)
     512:	f001 f94b 	bl	17ac <printf>
     516:	e79d      	b.n	454 <car_mesg+0x2c>
     518:	00002a88 	andeq	r2, r0, r8, lsl #21
     51c:	00002aac 	andeq	r2, r0, ip, lsr #21
     520:	000033c8 	andeq	r3, r0, r8, asr #7
     524:	00002ab0 			@ <UNDEFINED> instruction: 0x00002ab0
     528:	00002abc 			@ <UNDEFINED> instruction: 0x00002abc
     52c:	00002ad0 	ldrdeq	r2, [r0], -r0
     530:	00002adc 	ldrdeq	r2, [r0], -ip
     534:	00002b00 	andeq	r2, r0, r0, lsl #22
     538:	20000194 	mulcs	r0, r4, r1
     53c:	00002ae4 	andeq	r2, r0, r4, ror #21
     540:	00002b20 	andeq	r2, r0, r0, lsr #22
     544:	00002b48 	andeq	r2, r0, r8, asr #22
     548:	00002b24 	andeq	r2, r0, r4, lsr #22
     54c:	00002b38 	andeq	r2, r0, r8, lsr fp
     550:	00002b68 	andeq	r2, r0, r8, ror #22

00000554 <default_handler>:

extern int _STACK_TOP_;
extern void reset_handler(void);

void default_handler(void) {
  while (1)
     554:	e7fe      	b.n	554 <default_handler>
	...

00000558 <uputc>:
 * limitations under the License.
 **/

#include "uart.h"

void uputc(char c) {
     558:	b508      	push	{r3, lr}
  while ((UARTFR >> 5) & 1)
     55a:	4b07      	ldr	r3, [pc, #28]	@ (578 <uputc+0x20>)
     55c:	699b      	ldr	r3, [r3, #24]
     55e:	f013 0f20 	tst.w	r3, #32
     562:	d1fa      	bne.n	55a <uputc+0x2>
    ;

  UART_DR = c;
     564:	4b04      	ldr	r3, [pc, #16]	@ (578 <uputc+0x20>)
     566:	6018      	str	r0, [r3, #0]
  if (c == '\n')
     568:	280a      	cmp	r0, #10
     56a:	d000      	beq.n	56e <uputc+0x16>
    uputc('\r');
}
     56c:	bd08      	pop	{r3, pc}
    uputc('\r');
     56e:	200d      	movs	r0, #13
     570:	f7ff fff2 	bl	558 <uputc>
}
     574:	e7fa      	b.n	56c <uputc+0x14>
     576:	bf00      	nop
     578:	4000c000 	andmi	ip, r0, r0

0000057c <ugetc>:

int ugetc(void) {
  if (!((UARTFR >> 4) & 1)) return UART_DR;
     57c:	4b05      	ldr	r3, [pc, #20]	@ (594 <ugetc+0x18>)
     57e:	699b      	ldr	r3, [r3, #24]
     580:	f013 0f10 	tst.w	r3, #16
     584:	d102      	bne.n	58c <ugetc+0x10>
     586:	4b03      	ldr	r3, [pc, #12]	@ (594 <ugetc+0x18>)
     588:	6818      	ldr	r0, [r3, #0]
     58a:	4770      	bx	lr

  return -1;
     58c:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
}
     590:	4770      	bx	lr
     592:	bf00      	nop
     594:	4000c000 	andmi	ip, r0, r0

00000598 <uart_init>:

void uart_init(void) {
  /* Disable UART0 */
  UARTCTL = 0;
     598:	4b07      	ldr	r3, [pc, #28]	@ (5b8 <uart_init+0x20>)
     59a:	2200      	movs	r2, #0
     59c:	631a      	str	r2, [r3, #48]	@ 0x30

  /* Set the Baud to 115200 */
  UARTIBRD = 8;
     59e:	2108      	movs	r1, #8
     5a0:	6259      	str	r1, [r3, #36]	@ 0x24
  UARTFBRD = 44;
     5a2:	212c      	movs	r1, #44	@ 0x2c
     5a4:	6299      	str	r1, [r3, #40]	@ 0x28

  /* Use system clock for Uart */
  UARTCC = 0;
     5a6:	f8c3 2fc8 	str.w	r2, [r3, #4040]	@ 0xfc8

  /* 8n1 and no fifo */
  UARTLCRH = 0x60;
     5aa:	2260      	movs	r2, #96	@ 0x60
     5ac:	62da      	str	r2, [r3, #44]	@ 0x2c

  /* Enable UART0, TXE and RXE */
  UARTCTL = 0x301;
     5ae:	f240 3201 	movw	r2, #769	@ 0x301
     5b2:	631a      	str	r2, [r3, #48]	@ 0x30
}
     5b4:	4770      	bx	lr
     5b6:	bf00      	nop
     5b8:	4000c000 	andmi	ip, r0, r0

000005bc <u2putc>:
 * limitations under the License.
 **/

#include "uart2.h"

void u2putc(char c) {
     5bc:	b508      	push	{r3, lr}
  while ((UART2FR >> 5) & 1)
     5be:	4b07      	ldr	r3, [pc, #28]	@ (5dc <u2putc+0x20>)
     5c0:	699b      	ldr	r3, [r3, #24]
     5c2:	f013 0f20 	tst.w	r3, #32
     5c6:	d1fa      	bne.n	5be <u2putc+0x2>
    ;

  UART2_DR = c;
     5c8:	4b04      	ldr	r3, [pc, #16]	@ (5dc <u2putc+0x20>)
     5ca:	6018      	str	r0, [r3, #0]
  if (c == '\n')
     5cc:	280a      	cmp	r0, #10
     5ce:	d000      	beq.n	5d2 <u2putc+0x16>
    u2putc('\r');
}
     5d0:	bd08      	pop	{r3, pc}
    u2putc('\r');
     5d2:	200d      	movs	r0, #13
     5d4:	f7ff fff2 	bl	5bc <u2putc>
}
     5d8:	e7fa      	b.n	5d0 <u2putc+0x14>
     5da:	bf00      	nop
     5dc:	4000d000 	andmi	sp, r0, r0

000005e0 <u2getc>:

int u2getc(void) {
  if (!((UART2FR >> 4) & 1)) return UART2_DR;
     5e0:	4b05      	ldr	r3, [pc, #20]	@ (5f8 <u2getc+0x18>)
     5e2:	699b      	ldr	r3, [r3, #24]
     5e4:	f013 0f10 	tst.w	r3, #16
     5e8:	d102      	bne.n	5f0 <u2getc+0x10>
     5ea:	4b03      	ldr	r3, [pc, #12]	@ (5f8 <u2getc+0x18>)
     5ec:	6818      	ldr	r0, [r3, #0]
     5ee:	4770      	bx	lr

  return -1;
     5f0:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
}
     5f4:	4770      	bx	lr
     5f6:	bf00      	nop
     5f8:	4000d000 	andmi	sp, r0, r0

000005fc <uart2_init>:

void uart2_init(void) {
  /* Disable the UART */
  UART2CTL = 0;
     5fc:	4b07      	ldr	r3, [pc, #28]	@ (61c <uart2_init+0x20>)
     5fe:	2200      	movs	r2, #0
     600:	631a      	str	r2, [r3, #48]	@ 0x30

  /* Set the Baud to 115200 */
  UART2IBRD = 8;
     602:	2108      	movs	r1, #8
     604:	6259      	str	r1, [r3, #36]	@ 0x24
  UART2FBRD = 44;
     606:	212c      	movs	r1, #44	@ 0x2c
     608:	6299      	str	r1, [r3, #40]	@ 0x28

  /* Use system clock for Uart */
  UART2CC = 0;
     60a:	f8c3 2fc8 	str.w	r2, [r3, #4040]	@ 0xfc8

  /* 8n1 and no fifo */
  UART2LCRH = 0x60;
     60e:	2260      	movs	r2, #96	@ 0x60
     610:	62da      	str	r2, [r3, #44]	@ 0x2c

  /* Enable UART with TXE and RXE */
  UART2CTL = 0x301;
     612:	f240 3201 	movw	r2, #769	@ 0x301
     616:	631a      	str	r2, [r3, #48]	@ 0x30
}
     618:	4770      	bx	lr
     61a:	bf00      	nop
     61c:	4000d000 	andmi	sp, r0, r0

00000620 <pin_setup>:


void pin_setup() {
  /* Enable clock for UART0 and GPIO */
  // RCGCUART |= 1;
  RCGCUART |= 3;
     620:	4b13      	ldr	r3, [pc, #76]	@ (670 <pin_setup+0x50>)
     622:	f8d3 2618 	ldr.w	r2, [r3, #1560]	@ 0x618
     626:	f042 0203 	orr.w	r2, r2, #3
     62a:	f8c3 2618 	str.w	r2, [r3, #1560]	@ 0x618
   // RCGCGPIO |= 1;
  RCGCGPIO |= 3;
     62e:	f8d3 2608 	ldr.w	r2, [r3, #1544]	@ 0x608
     632:	f042 0203 	orr.w	r2, r2, #3
     636:	f8c3 2608 	str.w	r2, [r3, #1544]	@ 0x608

  /* Set PIN PA0 and PA1 as uart */
  GPIODEN = 0x03;
     63a:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
     63e:	2203      	movs	r2, #3
     640:	f8c3 251c 	str.w	r2, [r3, #1308]	@ 0x51c
  GPIOAFSEL = 0x03;
     644:	f8c3 2420 	str.w	r2, [r3, #1056]	@ 0x420
  GPIOPCTL |= 0x00000011;
     648:	f8d3 152c 	ldr.w	r1, [r3, #1324]	@ 0x52c
     64c:	f041 0111 	orr.w	r1, r1, #17
     650:	f8c3 152c 	str.w	r1, [r3, #1324]	@ 0x52c

    /* Set PIN PA0 and PA1 as uart */
  GPIODEN2 = 0x03;
     654:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
     658:	f8c3 251c 	str.w	r2, [r3, #1308]	@ 0x51c
  GPIOAFSEL2 = 0x03;
     65c:	f8c3 2420 	str.w	r2, [r3, #1056]	@ 0x420
  GPIOPCTL2 |= 0x00000011;
     660:	f8d3 252c 	ldr.w	r2, [r3, #1324]	@ 0x52c
     664:	f042 0211 	orr.w	r2, r2, #17
     668:	f8c3 252c 	str.w	r2, [r3, #1324]	@ 0x52c
}
     66c:	4770      	bx	lr
     66e:	bf00      	nop
     670:	400fe000 	andmi	lr, pc, r0

00000674 <platform_init>:

/**
 * @brief Inilialize the platform
 *
 */
void platform_init() {
     674:	b508      	push	{r3, lr}
    pin_setup();
     676:	f7ff ffd3 	bl	620 <pin_setup>
    uart_init();
     67a:	f7ff ff8d 	bl	598 <uart_init>
    uart2_init();
     67e:	f7ff ffbd 	bl	5fc <uart2_init>
    set_read_char(ugetc);
     682:	4806      	ldr	r0, [pc, #24]	@ (69c <platform_init+0x28>)
     684:	f000 fbca 	bl	e1c <set_read_char>
    set_read_char2(u2getc);
     688:	4805      	ldr	r0, [pc, #20]	@ (6a0 <platform_init+0x2c>)
     68a:	f000 fbcd 	bl	e28 <set_read_char2>
    set_write_char(uputc);
     68e:	4805      	ldr	r0, [pc, #20]	@ (6a4 <platform_init+0x30>)
     690:	f000 fbd0 	bl	e34 <set_write_char>
    set_write_char2(u2putc);
     694:	4804      	ldr	r0, [pc, #16]	@ (6a8 <platform_init+0x34>)
     696:	f000 fbd3 	bl	e40 <set_write_char2>
}
     69a:	bd08      	pop	{r3, pc}
     69c:	0000057d 	andeq	r0, r0, sp, ror r5
     6a0:	000005e1 	andeq	r0, r0, r1, ror #11
     6a4:	00000559 	andeq	r0, r0, r9, asr r5
     6a8:	000005bd 			@ <UNDEFINED> instruction: 0x000005bd

000006ac <aes_test>:

// AES variables set globally in shell.c
//extern struct AES_ctx ctx;
//extern uint8_t AES_key[];

int aes_test(int argc, char** argv) {
     6ac:	b570      	push	{r4, r5, r6, lr}
     6ae:	b092      	sub	sp, #72	@ 0x48
    
    uint8_t text[17] = "0123456789abcdef";
     6b0:	f10d 0c34 	add.w	ip, sp, #52	@ 0x34
     6b4:	4c1f      	ldr	r4, [pc, #124]	@ (734 <aes_test+0x88>)
     6b6:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
     6b8:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
     6bc:	6823      	ldr	r3, [r4, #0]
     6be:	f88c 3000 	strb.w	r3, [ip]
    text[16] = '\0';
    unsigned int len;

    printf("Plaintext is %s\n", text);
     6c2:	a90d      	add	r1, sp, #52	@ 0x34
     6c4:	481c      	ldr	r0, [pc, #112]	@ (738 <aes_test+0x8c>)
     6c6:	f001 f871 	bl	17ac <printf>
    AES_ECB_encrypt(&ctx, text);
     6ca:	4e1c      	ldr	r6, [pc, #112]	@ (73c <aes_test+0x90>)
     6cc:	a90d      	add	r1, sp, #52	@ 0x34
     6ce:	4630      	mov	r0, r6
     6d0:	f001 fd1d 	bl	210e <AES_ECB_encrypt>

    //Let's encode it in base64 so we can send it character-by-character over UART
    uint8_t b64text[25];
    len = encode_base64(text, 16, b64text);
     6d4:	aa06      	add	r2, sp, #24
     6d6:	2110      	movs	r1, #16
     6d8:	a80d      	add	r0, sp, #52	@ 0x34
     6da:	f000 fd6f 	bl	11bc <encode_base64>
     6de:	4604      	mov	r4, r0
    b64text[len] = '\0';
     6e0:	f100 0348 	add.w	r3, r0, #72	@ 0x48
     6e4:	446b      	add	r3, sp
     6e6:	2500      	movs	r5, #0
     6e8:	f803 5c30 	strb.w	r5, [r3, #-48]
    printf("Encrypted/encoded is %s\n", b64text);
     6ec:	a906      	add	r1, sp, #24
     6ee:	4814      	ldr	r0, [pc, #80]	@ (740 <aes_test+0x94>)
     6f0:	f001 f85c 	bl	17ac <printf>
    printf2("FOB_MESG AESB64 %s\n", b64text);
     6f4:	a906      	add	r1, sp, #24
     6f6:	4813      	ldr	r0, [pc, #76]	@ (744 <aes_test+0x98>)
     6f8:	f001 f974 	bl	19e4 <printf2>
    printf("Test the mesg handler with CAR_MESG AESB64 %s\n", b64text);
     6fc:	a906      	add	r1, sp, #24
     6fe:	4812      	ldr	r0, [pc, #72]	@ (748 <aes_test+0x9c>)
     700:	f001 f854 	bl	17ac <printf>

    uint8_t decoded[17];
    len = decode_base64(b64text, len, decoded);
     704:	aa01      	add	r2, sp, #4
     706:	4621      	mov	r1, r4
     708:	a806      	add	r0, sp, #24
     70a:	f000 fdcb 	bl	12a4 <decode_base64>
     70e:	4604      	mov	r4, r0
    AES_ECB_decrypt(&ctx, decoded);
     710:	a901      	add	r1, sp, #4
     712:	4630      	mov	r0, r6
     714:	f001 fd02 	bl	211c <AES_ECB_decrypt>
    decoded[len] = '\0';
     718:	f104 0348 	add.w	r3, r4, #72	@ 0x48
     71c:	eb0d 0403 	add.w	r4, sp, r3
     720:	f804 5c44 	strb.w	r5, [r4, #-68]

    printf("After encrypting->encoding->decoding->decrypting we recover %s\n", decoded);
     724:	a901      	add	r1, sp, #4
     726:	4809      	ldr	r0, [pc, #36]	@ (74c <aes_test+0xa0>)
     728:	f001 f840 	bl	17ac <printf>
    return 0;
}
     72c:	4628      	mov	r0, r5
     72e:	b012      	add	sp, #72	@ 0x48
     730:	bd70      	pop	{r4, r5, r6, pc}
     732:	bf00      	nop
     734:	00002c68 	andeq	r2, r0, r8, ror #24
     738:	00002bb4 			@ <UNDEFINED> instruction: 0x00002bb4
     73c:	20000194 	mulcs	r0, r4, r1
     740:	00002bc8 	andeq	r2, r0, r8, asr #23
     744:	00002be4 	andeq	r2, r0, r4, ror #23
     748:	00002bf8 	strdeq	r2, [r0], -r8
     74c:	00002c28 	andeq	r2, r0, r8, lsr #24

00000750 <pair1>:

#include "shell.h"

int pair1(int argc, char** argv) {
     750:	b508      	push	{r3, lr}
    printf("Sending a pair request.\n");
     752:	4806      	ldr	r0, [pc, #24]	@ (76c <pair1+0x1c>)
     754:	f001 f82a 	bl	17ac <printf>
    printf2("FOB_MESG PAIR %d %d\n", fob_ID, pairing_PIN);
     758:	4b05      	ldr	r3, [pc, #20]	@ (770 <pair1+0x20>)
     75a:	681a      	ldr	r2, [r3, #0]
     75c:	4b05      	ldr	r3, [pc, #20]	@ (774 <pair1+0x24>)
     75e:	6819      	ldr	r1, [r3, #0]
     760:	4805      	ldr	r0, [pc, #20]	@ (778 <pair1+0x28>)
     762:	f001 f93f 	bl	19e4 <printf2>
    return 0;
}
     766:	2000      	movs	r0, #0
     768:	bd08      	pop	{r3, pc}
     76a:	bf00      	nop
     76c:	00002ca8 	andeq	r2, r0, r8, lsr #25
     770:	20000054 	andcs	r0, r0, r4, asr r0
     774:	20000050 	andcs	r0, r0, r0, asr r0
     778:	00002cc4 	andeq	r2, r0, r4, asr #25

0000077c <pairchall>:

int pairchall(int argc, char** argv) {
     77c:	b508      	push	{r3, lr}
   
    printf("Sending a pair request with challenge/response.\n");
     77e:	4806      	ldr	r0, [pc, #24]	@ (798 <pairchall+0x1c>)
     780:	f001 f814 	bl	17ac <printf>
    printf2("FOB_MESG PAIRCR %d %d\n", fob_ID, pairing_PIN);
     784:	4b05      	ldr	r3, [pc, #20]	@ (79c <pairchall+0x20>)
     786:	681a      	ldr	r2, [r3, #0]
     788:	4b05      	ldr	r3, [pc, #20]	@ (7a0 <pairchall+0x24>)
     78a:	6819      	ldr	r1, [r3, #0]
     78c:	4805      	ldr	r0, [pc, #20]	@ (7a4 <pairchall+0x28>)
     78e:	f001 f929 	bl	19e4 <printf2>

    return 0;
}
     792:	2000      	movs	r0, #0
     794:	bd08      	pop	{r3, pc}
     796:	bf00      	nop
     798:	00002cdc 	ldrdeq	r2, [r0], -ip
     79c:	20000054 	andcs	r0, r0, r4, asr r0
     7a0:	20000050 	andcs	r0, r0, r0, asr r0
     7a4:	00002d10 	andeq	r2, r0, r0, lsl sp

000007a8 <pairecdh>:

int pairecdh(int argc, char** argv) {
     7a8:	b530      	push	{r4, r5, lr}
     7aa:	b093      	sub	sp, #76	@ 0x4c
    
    uint8_t pubkey_b64[65];
    
    printf("Starting EC Diffie-Hellman key exchange.\n");
     7ac:	4810      	ldr	r0, [pc, #64]	@ (7f0 <pairecdh+0x48>)
     7ae:	f000 fffd 	bl	17ac <printf>

    decode_base64(ECDH_privkey_b64, 32, ECDH_privkey);
     7b2:	4d10      	ldr	r5, [pc, #64]	@ (7f4 <pairecdh+0x4c>)
     7b4:	462a      	mov	r2, r5
     7b6:	2120      	movs	r1, #32
     7b8:	480f      	ldr	r0, [pc, #60]	@ (7f8 <pairecdh+0x50>)
     7ba:	f000 fd73 	bl	12a4 <decode_base64>
    ecdh_generate_keys(ECDH_pubkey, ECDH_privkey);
     7be:	4c0f      	ldr	r4, [pc, #60]	@ (7fc <pairecdh+0x54>)
     7c0:	4629      	mov	r1, r5
     7c2:	4620      	mov	r0, r4
     7c4:	f001 ff9c 	bl	2700 <ecdh_generate_keys>
    encode_base64(ECDH_pubkey, ECC_PUB_KEY_SIZE, pubkey_b64);
     7c8:	aa01      	add	r2, sp, #4
     7ca:	2130      	movs	r1, #48	@ 0x30
     7cc:	4620      	mov	r0, r4
     7ce:	f000 fcf5 	bl	11bc <encode_base64>
    pubkey_b64[64] = '\0';
     7d2:	2400      	movs	r4, #0
     7d4:	f88d 4044 	strb.w	r4, [sp, #68]	@ 0x44
    printf2("FOB_MESG PAIRECDH %d %d %s\n", fob_ID, pairing_PIN, pubkey_b64);
     7d8:	ab01      	add	r3, sp, #4
     7da:	4a09      	ldr	r2, [pc, #36]	@ (800 <pairecdh+0x58>)
     7dc:	6812      	ldr	r2, [r2, #0]
     7de:	4909      	ldr	r1, [pc, #36]	@ (804 <pairecdh+0x5c>)
     7e0:	6809      	ldr	r1, [r1, #0]
     7e2:	4809      	ldr	r0, [pc, #36]	@ (808 <pairecdh+0x60>)
     7e4:	f001 f8fe 	bl	19e4 <printf2>
    return 0;
}
     7e8:	4620      	mov	r0, r4
     7ea:	b013      	add	sp, #76	@ 0x4c
     7ec:	bd30      	pop	{r4, r5, pc}
     7ee:	bf00      	nop
     7f0:	00002d28 	andeq	r2, r0, r8, lsr #26
     7f4:	20000314 	andcs	r0, r0, r4, lsl r3
     7f8:	20000030 	andcs	r0, r0, r0, lsr r0
     7fc:	200002e4 	andcs	r0, r0, r4, ror #5
     800:	20000054 	andcs	r0, r0, r4, asr r0
     804:	20000050 	andcs	r0, r0, r0, asr r0
     808:	00002d54 	andeq	r2, r0, r4, asr sp

0000080c <encode64>:
// Your max length should be 4*ceil(n/3) where n is the length of
// the array to be encoded. e.g. 100 bytes are encoded in 128 characters
#define MAXARRAYLEN 100 
#define MAXBASE64LEN 128

int encode64(int argc, char** argv) {
     80c:	b510      	push	{r4, lr}
     80e:	b0a0      	sub	sp, #128	@ 0x80

    if (argc > 1) {
     810:	2801      	cmp	r0, #1
     812:	dd16      	ble.n	842 <encode64+0x36>
     814:	460c      	mov	r4, r1

        uint8_t encoded[MAXBASE64LEN];
        int len;

        len = strlen(argv[1]);
     816:	6848      	ldr	r0, [r1, #4]
     818:	f002 f844 	bl	28a4 <strlen>
     81c:	4601      	mov	r1, r0
        if (len < MAXARRAYLEN) {
     81e:	2863      	cmp	r0, #99	@ 0x63
     820:	dc0a      	bgt.n	838 <encode64+0x2c>
            len = encode_base64((uint8_t *) argv[1], len, encoded);
     822:	466a      	mov	r2, sp
     824:	6860      	ldr	r0, [r4, #4]
     826:	f000 fcc9 	bl	11bc <encode_base64>
     82a:	4603      	mov	r3, r0
            printf("Encoded %s as %s with %d characters\n", argv[1], encoded, len);
     82c:	466a      	mov	r2, sp
     82e:	6861      	ldr	r1, [r4, #4]
     830:	4807      	ldr	r0, [pc, #28]	@ (850 <encode64+0x44>)
     832:	f000 ffbb 	bl	17ac <printf>
     836:	e007      	b.n	848 <encode64+0x3c>
        }
        else {
            printf("String exceeds max length of %d characters", MAXARRAYLEN);
     838:	2164      	movs	r1, #100	@ 0x64
     83a:	4806      	ldr	r0, [pc, #24]	@ (854 <encode64+0x48>)
     83c:	f000 ffb6 	bl	17ac <printf>
     840:	e002      	b.n	848 <encode64+0x3c>
        }
    }
    else {
        printf("Usage is 'encode64 string'\n");
     842:	4805      	ldr	r0, [pc, #20]	@ (858 <encode64+0x4c>)
     844:	f000 ffb2 	bl	17ac <printf>
    }
        
    return 0;
}
     848:	2000      	movs	r0, #0
     84a:	b020      	add	sp, #128	@ 0x80
     84c:	bd10      	pop	{r4, pc}
     84e:	bf00      	nop
     850:	00002df0 	strdeq	r2, [r0], -r0
     854:	00002e18 	andeq	r2, r0, r8, lsl lr
     858:	00002e44 	andeq	r2, r0, r4, asr #28

0000085c <decode64>:

int decode64(int argc, char** argv) {
     85c:	b510      	push	{r4, lr}
     85e:	b09a      	sub	sp, #104	@ 0x68

    if (argc > 1) {
     860:	2801      	cmp	r0, #1
     862:	dd1c      	ble.n	89e <decode64+0x42>
     864:	460c      	mov	r4, r1

        int len = strlen(argv[1]);
     866:	6848      	ldr	r0, [r1, #4]
     868:	f002 f81c 	bl	28a4 <strlen>
     86c:	4601      	mov	r1, r0

        if (len < MAXBASE64LEN) {
     86e:	287f      	cmp	r0, #127	@ 0x7f
     870:	dc10      	bgt.n	894 <decode64+0x38>
                
                uint8_t plaintext[MAXARRAYLEN + 1];
                len = decode_base64((uint8_t *) argv[1], len, plaintext);
     872:	466a      	mov	r2, sp
     874:	6860      	ldr	r0, [r4, #4]
     876:	f000 fd15 	bl	12a4 <decode_base64>
                plaintext[len] = '\0';
     87a:	f100 0368 	add.w	r3, r0, #104	@ 0x68
     87e:	eb0d 0003 	add.w	r0, sp, r3
     882:	2300      	movs	r3, #0
     884:	f800 3c68 	strb.w	r3, [r0, #-104]
                printf("Decoded %s as: %s\n", argv[1], plaintext);
     888:	466a      	mov	r2, sp
     88a:	6861      	ldr	r1, [r4, #4]
     88c:	4807      	ldr	r0, [pc, #28]	@ (8ac <decode64+0x50>)
     88e:	f000 ff8d 	bl	17ac <printf>
     892:	e007      	b.n	8a4 <decode64+0x48>
        }
        else {
            printf("String exceeds max base64 string length of %d characters", MAXBASE64LEN);
     894:	2180      	movs	r1, #128	@ 0x80
     896:	4806      	ldr	r0, [pc, #24]	@ (8b0 <decode64+0x54>)
     898:	f000 ff88 	bl	17ac <printf>
     89c:	e002      	b.n	8a4 <decode64+0x48>
        }   
    }
    else {
        printf("Usage is 'decode64 string'\n");
     89e:	4805      	ldr	r0, [pc, #20]	@ (8b4 <decode64+0x58>)
     8a0:	f000 ff84 	bl	17ac <printf>
    }
        
    return 0;
}
     8a4:	2000      	movs	r0, #0
     8a6:	b01a      	add	sp, #104	@ 0x68
     8a8:	bd10      	pop	{r4, pc}
     8aa:	bf00      	nop
     8ac:	00002e60 	andeq	r2, r0, r0, ror #28
     8b0:	00002e74 	andeq	r2, r0, r4, ror lr
     8b4:	00002eb0 			@ <UNDEFINED> instruction: 0x00002eb0

000008b8 <ecdh_test>:
//extern uint8_t ECDH_AESkey[];
//extern uint8_t AES_key[];
//extern struct AES_ctx ctx;


int ecdh_test(int argc, char** argv) {
     8b8:	b570      	push	{r4, r5, r6, lr}
     8ba:	b0d0      	sub	sp, #320	@ 0x140

    uint8_t b64privkey2[32] = "wP/uwP/uwP/uwP/uwP/uwP/uwP/uwP/u";
     8bc:	f50d 7c90 	add.w	ip, sp, #288	@ 0x120
     8c0:	4c35      	ldr	r4, [pc, #212]	@ (998 <ecdh_test+0xe0>)
     8c2:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
     8c4:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
     8c8:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
     8cc:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
    uint8_t sharedsecret2[ECC_PRV_KEY_SIZE];
    uint8_t keytest[AES_KEYLEN];
    uint8_t b64test[45];
    int len = 0;

    printf("Testing the ecdh key exchange\n");
     8d0:	4832      	ldr	r0, [pc, #200]	@ (99c <ecdh_test+0xe4>)
     8d2:	f000 ff6b 	bl	17ac <printf>

    decode_base64(ECDH_privkey_b64, 32, ECDH_privkey);
     8d6:	4c32      	ldr	r4, [pc, #200]	@ (9a0 <ecdh_test+0xe8>)
     8d8:	4622      	mov	r2, r4
     8da:	2120      	movs	r1, #32
     8dc:	4831      	ldr	r0, [pc, #196]	@ (9a4 <ecdh_test+0xec>)
     8de:	f000 fce1 	bl	12a4 <decode_base64>
    decode_base64(b64privkey2, 32, privkey2);
     8e2:	aa42      	add	r2, sp, #264	@ 0x108
     8e4:	2120      	movs	r1, #32
     8e6:	a848      	add	r0, sp, #288	@ 0x120
     8e8:	f000 fcdc 	bl	12a4 <decode_base64>

    ecdh_generate_keys(ECDH_pubkey, ECDH_privkey);
     8ec:	4e2e      	ldr	r6, [pc, #184]	@ (9a8 <ecdh_test+0xf0>)
     8ee:	4621      	mov	r1, r4
     8f0:	4630      	mov	r0, r6
     8f2:	f001 ff05 	bl	2700 <ecdh_generate_keys>
    ecdh_generate_keys(pubkey2, privkey2);
     8f6:	a942      	add	r1, sp, #264	@ 0x108
     8f8:	a836      	add	r0, sp, #216	@ 0xd8
     8fa:	f001 ff01 	bl	2700 <ecdh_generate_keys>

    ecdh_shared_secret(ECDH_privkey, pubkey2, ECDH_shared);
     8fe:	4d2b      	ldr	r5, [pc, #172]	@ (9ac <ecdh_test+0xf4>)
     900:	462a      	mov	r2, r5
     902:	a936      	add	r1, sp, #216	@ 0xd8
     904:	4620      	mov	r0, r4
     906:	f001 ff25 	bl	2754 <ecdh_shared_secret>
    ecdh_shared_secret(privkey2, ECDH_pubkey, sharedsecret2);
     90a:	aa30      	add	r2, sp, #192	@ 0xc0
     90c:	4631      	mov	r1, r6
     90e:	a842      	add	r0, sp, #264	@ 0x108
     910:	f001 ff20 	bl	2754 <ecdh_shared_secret>

    SHA256_CTX shactx;
    sha256_init(&shactx);
     914:	4668      	mov	r0, sp
     916:	f000 fddd 	bl	14d4 <sha256_init>
	sha256_update(&shactx, ECDH_shared, ECC_PUB_KEY_SIZE);
     91a:	2230      	movs	r2, #48	@ 0x30
     91c:	4629      	mov	r1, r5
     91e:	4668      	mov	r0, sp
     920:	f000 fe02 	bl	1528 <sha256_update>
	sha256_final(&shactx, ECDH_AESkey);
     924:	4d22      	ldr	r5, [pc, #136]	@ (9b0 <ecdh_test+0xf8>)
     926:	4629      	mov	r1, r5
     928:	4668      	mov	r0, sp
     92a:	f000 fe1d 	bl	1568 <sha256_final>

    len = encode_base64(ECDH_AESkey, AES_KEYLEN, b64test);
     92e:	aa1c      	add	r2, sp, #112	@ 0x70
     930:	2120      	movs	r1, #32
     932:	4628      	mov	r0, r5
     934:	f000 fc42 	bl	11bc <encode_base64>
    b64test[len] = '\0';
     938:	f500 73a0 	add.w	r3, r0, #320	@ 0x140
     93c:	eb0d 0003 	add.w	r0, sp, r3
     940:	2400      	movs	r4, #0
     942:	f800 4cd0 	strb.w	r4, [r0, #-208]

    printf("First shared key is %s\n", b64test);
     946:	a91c      	add	r1, sp, #112	@ 0x70
     948:	481a      	ldr	r0, [pc, #104]	@ (9b4 <ecdh_test+0xfc>)
     94a:	f000 ff2f 	bl	17ac <printf>

    sha256_init(&shactx);
     94e:	4668      	mov	r0, sp
     950:	f000 fdc0 	bl	14d4 <sha256_init>
    sha256_update(&shactx, sharedsecret2, ECC_PUB_KEY_SIZE);
     954:	2230      	movs	r2, #48	@ 0x30
     956:	a930      	add	r1, sp, #192	@ 0xc0
     958:	4668      	mov	r0, sp
     95a:	f000 fde5 	bl	1528 <sha256_update>
	sha256_final(&shactx, keytest);
     95e:	a928      	add	r1, sp, #160	@ 0xa0
     960:	4668      	mov	r0, sp
     962:	f000 fe01 	bl	1568 <sha256_final>

    len = encode_base64(keytest, AES_KEYLEN, b64test);
     966:	aa1c      	add	r2, sp, #112	@ 0x70
     968:	2120      	movs	r1, #32
     96a:	a828      	add	r0, sp, #160	@ 0xa0
     96c:	f000 fc26 	bl	11bc <encode_base64>
    b64test[len] = '\0';
     970:	f500 73a0 	add.w	r3, r0, #320	@ 0x140
     974:	eb0d 0003 	add.w	r0, sp, r3
     978:	f800 4cd0 	strb.w	r4, [r0, #-208]
    printf("Should be same as %s\n", b64test);
     97c:	a91c      	add	r1, sp, #112	@ 0x70
     97e:	480e      	ldr	r0, [pc, #56]	@ (9b8 <ecdh_test+0x100>)
     980:	f000 ff14 	bl	17ac <printf>

    printf("Switching fob AES key to new value. Try AES tests now.\n");
     984:	480d      	ldr	r0, [pc, #52]	@ (9bc <ecdh_test+0x104>)
     986:	f000 ff11 	bl	17ac <printf>

    AES_init_ctx(&ctx, ECDH_AESkey);
     98a:	4629      	mov	r1, r5
     98c:	480c      	ldr	r0, [pc, #48]	@ (9c0 <ecdh_test+0x108>)
     98e:	f001 fba8 	bl	20e2 <AES_init_ctx>

    return 0;
}
     992:	4620      	mov	r0, r4
     994:	b050      	add	sp, #320	@ 0x140
     996:	bd70      	pop	{r4, r5, r6, pc}
     998:	00002f9c 	muleq	r0, ip, pc	@ <UNPREDICTABLE>
     99c:	00002f14 	andeq	r2, r0, r4, lsl pc
     9a0:	20000314 	andcs	r0, r0, r4, lsl r3
     9a4:	20000030 	andcs	r0, r0, r0, lsr r0
     9a8:	200002e4 	andcs	r0, r0, r4, ror #5
     9ac:	200002b4 			@ <UNDEFINED> instruction: 0x200002b4
     9b0:	20000294 	mulcs	r0, r4, r2
     9b4:	00002f34 	andeq	r2, r0, r4, lsr pc
     9b8:	00002f4c 	andeq	r2, r0, ip, asr #30
     9bc:	00002f64 	andeq	r2, r0, r4, ror #30
     9c0:	20000194 	mulcs	r0, r4, r1

000009c4 <send_ping>:

#include "shell.h"


int send_ping(int argc, char** argv) {
     9c4:	b508      	push	{r3, lr}
    printf("Pinging the car.\n");
     9c6:	4804      	ldr	r0, [pc, #16]	@ (9d8 <send_ping+0x14>)
     9c8:	f000 fef0 	bl	17ac <printf>
    printf2("FOB_MESG PING\n");
     9cc:	4803      	ldr	r0, [pc, #12]	@ (9dc <send_ping+0x18>)
     9ce:	f001 f809 	bl	19e4 <printf2>
    return 0;
}
     9d2:	2000      	movs	r0, #0
     9d4:	bd08      	pop	{r3, pc}
     9d6:	bf00      	nop
     9d8:	00002fe4 	andeq	r2, r0, r4, ror #31
     9dc:	00002ff8 	strdeq	r2, [r0], -r8

000009e0 <sha256_test>:
#include "shell.h"


int sha256_test(int argc, char** argv) {
     9e0:	b570      	push	{r4, r5, r6, lr}
     9e2:	b0d4      	sub	sp, #336	@ 0x150
    printf("Starting sha256 test\n");
     9e4:	4822      	ldr	r0, [pc, #136]	@ (a70 <sha256_test+0x90>)
     9e6:	f000 fee1 	bl	17ac <printf>

    SHA256_CTX shactx;
    BYTE text1[] = {"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"};
     9ea:	f10d 0ca4 	add.w	ip, sp, #164	@ 0xa4
     9ee:	4c21      	ldr	r4, [pc, #132]	@ (a74 <sha256_test+0x94>)
     9f0:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
     9f2:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
     9f6:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
     9f8:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
     9fc:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
     9fe:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
     a02:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
     a06:	e8ac 0003 	stmia.w	ip!, {r0, r1}
     a0a:	f88c 2000 	strb.w	r2, [ip]
    BYTE hash1[SHA256_BLOCK_SIZE] = {0x24,0x8d,0x6a,0x61,0xd2,0x06,0x38,0xb8,0xe5,0xc0,0x26,0x93,0x0c,0x3e,0x60,0x39,
     a0e:	ac21      	add	r4, sp, #132	@ 0x84
     a10:	4d19      	ldr	r5, [pc, #100]	@ (a78 <sha256_test+0x98>)
     a12:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
     a14:	c40f      	stmia	r4!, {r0, r1, r2, r3}
     a16:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
     a1a:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}

    uint8_t b64_hash1[45];
    uint8_t b64_buf[45];
    int len;

    sha256_init(&shactx);
     a1e:	a838      	add	r0, sp, #224	@ 0xe0
     a20:	f000 fd58 	bl	14d4 <sha256_init>
	sha256_update(&shactx, text1, strlen((char *)text1));
     a24:	a829      	add	r0, sp, #164	@ 0xa4
     a26:	f001 ff3d 	bl	28a4 <strlen>
     a2a:	4602      	mov	r2, r0
     a2c:	a929      	add	r1, sp, #164	@ 0xa4
     a2e:	a838      	add	r0, sp, #224	@ 0xe0
     a30:	f000 fd7a 	bl	1528 <sha256_update>
	sha256_final(&shactx, buf);
     a34:	a919      	add	r1, sp, #100	@ 0x64
     a36:	a838      	add	r0, sp, #224	@ 0xe0
     a38:	f000 fd96 	bl	1568 <sha256_final>

    len = encode_base64(hash1, SHA256_BLOCK_SIZE, b64_hash1);
     a3c:	ad0d      	add	r5, sp, #52	@ 0x34
     a3e:	462a      	mov	r2, r5
     a40:	2120      	movs	r1, #32
     a42:	a821      	add	r0, sp, #132	@ 0x84
     a44:	f000 fbba 	bl	11bc <encode_base64>
    b64_hash1[len] = '\0';
     a48:	2400      	movs	r4, #0
     a4a:	542c      	strb	r4, [r5, r0]

    len = encode_base64(buf, SHA256_BLOCK_SIZE, b64_buf);
     a4c:	ae01      	add	r6, sp, #4
     a4e:	4632      	mov	r2, r6
     a50:	2120      	movs	r1, #32
     a52:	a819      	add	r0, sp, #100	@ 0x64
     a54:	f000 fbb2 	bl	11bc <encode_base64>
    b64_buf[len] = '\0';
     a58:	5434      	strb	r4, [r6, r0]

    printf("Base64 of SHA-256 test is %s\n", b64_buf);
     a5a:	4631      	mov	r1, r6
     a5c:	4807      	ldr	r0, [pc, #28]	@ (a7c <sha256_test+0x9c>)
     a5e:	f000 fea5 	bl	17ac <printf>
    printf("Should be %s\n", b64_hash1);
     a62:	4629      	mov	r1, r5
     a64:	4806      	ldr	r0, [pc, #24]	@ (a80 <sha256_test+0xa0>)
     a66:	f000 fea1 	bl	17ac <printf>

    return 0;
}
     a6a:	4620      	mov	r0, r4
     a6c:	b054      	add	sp, #336	@ 0x150
     a6e:	bd70      	pop	{r4, r5, r6, pc}
     a70:	00003028 	andeq	r3, r0, r8, lsr #32
     a74:	00003070 	andeq	r3, r0, r0, ror r0
     a78:	000030ac 	andeq	r3, r0, ip, lsr #1
     a7c:	00003040 	andeq	r3, r0, r0, asr #32
     a80:	00003060 	andeq	r3, r0, r0, rrx

00000a84 <initial_setup>:
         "@" BUILD_HOST "] - " __DATE__ " - " __TIME__ "\n");
  return 0;
}


void __attribute__((optimize("O0"), weak)) initial_setup(void) {
     a84:	b580      	push	{r7, lr}
     a86:	b082      	sub	sp, #8
     a88:	af00      	add	r7, sp, #0
   * and zero the .bss section. This helps keep the user/custom
   * linker script and makefiles free from special variables to be declared.
   * Less burden on the user.
   */
  extern char _etext, _data, _edata, _bss, _ebss;
  char *src = &_etext, *dst = &_data;
     a8a:	4b14      	ldr	r3, [pc, #80]	@ (adc <initial_setup+0x58>)
     a8c:	607b      	str	r3, [r7, #4]
     a8e:	4b14      	ldr	r3, [pc, #80]	@ (ae0 <initial_setup+0x5c>)
     a90:	603b      	str	r3, [r7, #0]
  /**
   * Copy over the data section from ROM to RAM.
   * In case of RAM based target, we skip this since
   * src and dst would point to same location in RAM
   */
  if (dst != src)
     a92:	683a      	ldr	r2, [r7, #0]
     a94:	687b      	ldr	r3, [r7, #4]
     a96:	429a      	cmp	r2, r3
     a98:	d00c      	beq.n	ab4 <initial_setup+0x30>
    while (dst < &_edata) *(dst++) = *(src++);
     a9a:	e007      	b.n	aac <initial_setup+0x28>
     a9c:	687a      	ldr	r2, [r7, #4]
     a9e:	1c53      	adds	r3, r2, #1
     aa0:	607b      	str	r3, [r7, #4]
     aa2:	683b      	ldr	r3, [r7, #0]
     aa4:	1c59      	adds	r1, r3, #1
     aa6:	6039      	str	r1, [r7, #0]
     aa8:	7812      	ldrb	r2, [r2, #0]
     aaa:	701a      	strb	r2, [r3, #0]
     aac:	683b      	ldr	r3, [r7, #0]
     aae:	4a0d      	ldr	r2, [pc, #52]	@ (ae4 <initial_setup+0x60>)
     ab0:	4293      	cmp	r3, r2
     ab2:	d3f3      	bcc.n	a9c <initial_setup+0x18>

  /* Clear .bss*/
  for (dst = &_bss; dst < &_ebss; dst++) *dst = 0;
     ab4:	4b0c      	ldr	r3, [pc, #48]	@ (ae8 <initial_setup+0x64>)
     ab6:	603b      	str	r3, [r7, #0]
     ab8:	e005      	b.n	ac6 <initial_setup+0x42>
     aba:	683b      	ldr	r3, [r7, #0]
     abc:	2200      	movs	r2, #0
     abe:	701a      	strb	r2, [r3, #0]
     ac0:	683b      	ldr	r3, [r7, #0]
     ac2:	3301      	adds	r3, #1
     ac4:	603b      	str	r3, [r7, #0]
     ac6:	683b      	ldr	r3, [r7, #0]
     ac8:	4a08      	ldr	r2, [pc, #32]	@ (aec <initial_setup+0x68>)
     aca:	4293      	cmp	r3, r2
     acc:	d3f5      	bcc.n	aba <initial_setup+0x36>
   *   uart_init();
   *   set_read_char(uart_getchar);
   *   set_write_char(uart_putchar);
   * }
   */
  platform_init();
     ace:	f7ff fdd1 	bl	674 <platform_init>
}
     ad2:	bf00      	nop
     ad4:	3708      	adds	r7, #8
     ad6:	46bd      	mov	sp, r7
     ad8:	bd80      	pop	{r7, pc}
     ada:	bf00      	nop
     adc:	0000290c 	andeq	r2, r0, ip, lsl #18
     ae0:	20000000 	andcs	r0, r0, r0
     ae4:	20000058 	andcs	r0, r0, r8, asr r0
     ae8:	20000058 	andcs	r0, r0, r8, asr r0
     aec:	20000348 	andcs	r0, r0, r8, asr #6

00000af0 <delete>:
static void delete(void) {
     af0:	b510      	push	{r4, lr}
  __write_char__(BACK_SPACE);
     af2:	4c05      	ldr	r4, [pc, #20]	@ (b08 <delete+0x18>)
     af4:	6823      	ldr	r3, [r4, #0]
     af6:	2008      	movs	r0, #8
     af8:	4798      	blx	r3
  __write_char__(SPACE);
     afa:	6823      	ldr	r3, [r4, #0]
     afc:	2020      	movs	r0, #32
     afe:	4798      	blx	r3
  __write_char__(BACK_SPACE);
     b00:	6823      	ldr	r3, [r4, #0]
     b02:	2008      	movs	r0, #8
     b04:	4798      	blx	r3
}
     b06:	bd10      	pop	{r4, pc}
     b08:	20000058 	andcs	r0, r0, r8, asr r0

00000b0c <clear_prompt>:
static void clear_prompt(int char_count) {
     b0c:	b510      	push	{r4, lr}
     b0e:	4604      	mov	r4, r0
  while (char_count) {
     b10:	e002      	b.n	b18 <clear_prompt+0xc>
    delete ();
     b12:	f7ff ffed 	bl	af0 <delete>
    char_count--;
     b16:	3c01      	subs	r4, #1
  while (char_count) {
     b18:	2c00      	cmp	r4, #0
     b1a:	d1fa      	bne.n	b12 <clear_prompt+0x6>
}
     b1c:	bd10      	pop	{r4, pc}

00000b1e <exec_auto_cmds>:
static void exec_auto_cmds(void) {
     b1e:	b510      	push	{r4, lr}
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
     b20:	2400      	movs	r4, #0
     b22:	e004      	b.n	b2e <exec_auto_cmds+0x10>
    auto_load[i].command(0, NULL);
     b24:	688b      	ldr	r3, [r1, #8]
     b26:	2100      	movs	r1, #0
     b28:	4608      	mov	r0, r1
     b2a:	4798      	blx	r3
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
     b2c:	3401      	adds	r4, #1
     b2e:	eb04 0244 	add.w	r2, r4, r4, lsl #1
     b32:	0093      	lsls	r3, r2, #2
     b34:	4a02      	ldr	r2, [pc, #8]	@ (b40 <exec_auto_cmds+0x22>)
     b36:	1899      	adds	r1, r3, r2
     b38:	58d3      	ldr	r3, [r2, r3]
     b3a:	2b00      	cmp	r3, #0
     b3c:	d1f2      	bne.n	b24 <exec_auto_cmds+0x6>
}
     b3e:	bd10      	pop	{r4, pc}
     b40:	00002a40 	andeq	r2, r0, r0, asr #20

00000b44 <show_history>:
static int show_history(int argc, char **argv) {
     b44:	b538      	push	{r3, r4, r5, lr}
  uint32_t end_index = total_num_commands-1;
     b46:	4b0c      	ldr	r3, [pc, #48]	@ (b78 <show_history+0x34>)
     b48:	685d      	ldr	r5, [r3, #4]
     b4a:	3d01      	subs	r5, #1
  if (total_num_commands > NUM_HISTORY_ENTRIES) {
     b4c:	685b      	ldr	r3, [r3, #4]
     b4e:	2b02      	cmp	r3, #2
     b50:	dd03      	ble.n	b5a <show_history+0x16>
    beg_index = total_num_commands - NUM_HISTORY_ENTRIES;
     b52:	4b09      	ldr	r3, [pc, #36]	@ (b78 <show_history+0x34>)
     b54:	685c      	ldr	r4, [r3, #4]
     b56:	3c02      	subs	r4, #2
     b58:	e00a      	b.n	b70 <show_history+0x2c>
  uint32_t beg_index = 0;
     b5a:	2400      	movs	r4, #0
     b5c:	e008      	b.n	b70 <show_history+0x2c>
    printf("%s\n", cmd_history[index % NUM_HISTORY_ENTRIES]);
     b5e:	f004 0101 	and.w	r1, r4, #1
     b62:	4b06      	ldr	r3, [pc, #24]	@ (b7c <show_history+0x38>)
     b64:	eb03 11c1 	add.w	r1, r3, r1, lsl #7
     b68:	4805      	ldr	r0, [pc, #20]	@ (b80 <show_history+0x3c>)
     b6a:	f000 fe1f 	bl	17ac <printf>
  for (uint32_t index = beg_index; index <= end_index; ++index) {
     b6e:	3401      	adds	r4, #1
     b70:	42ac      	cmp	r4, r5
     b72:	d9f4      	bls.n	b5e <show_history+0x1a>
}
     b74:	2000      	movs	r0, #0
     b76:	bd38      	pop	{r3, r4, r5, pc}
     b78:	20000058 	andcs	r0, r0, r8, asr r0
     b7c:	20000060 	andcs	r0, r0, r0, rrx
     b80:	000030fc 	strdeq	r3, [r0], -ip

00000b84 <cmd_exec_status>:
  }

  return 0;
}

int cmd_exec_status(int argc, char **argv) {
     b84:	b508      	push	{r3, lr}
  printf("%d\n", __cmd_exec_status);
     b86:	4b04      	ldr	r3, [pc, #16]	@ (b98 <cmd_exec_status+0x14>)
     b88:	f8d3 1108 	ldr.w	r1, [r3, #264]	@ 0x108
     b8c:	4803      	ldr	r0, [pc, #12]	@ (b9c <cmd_exec_status+0x18>)
     b8e:	f000 fe0d 	bl	17ac <printf>
  return 0;
}
     b92:	2000      	movs	r0, #0
     b94:	bd08      	pop	{r3, pc}
     b96:	bf00      	nop
     b98:	20000058 	andcs	r0, r0, r8, asr r0
     b9c:	00003100 	andeq	r3, r0, r0, lsl #2

00000ba0 <build_info>:
static int build_info(int argc, char **argv) {
     ba0:	b508      	push	{r3, lr}
  printf("Build: [" SHELL_VERSION ":" USER_REPO_VERSION "] - [" BUILD_USER
     ba2:	4802      	ldr	r0, [pc, #8]	@ (bac <build_info+0xc>)
     ba4:	f000 fe02 	bl	17ac <printf>
}
     ba8:	2000      	movs	r0, #0
     baa:	bd08      	pop	{r3, pc}
     bac:	00003104 	andeq	r3, r0, r4, lsl #2

00000bb0 <execute>:
static void execute(int argc, char **argv) {
     bb0:	e92d 4178 	stmdb	sp!, {r3, r4, r5, r6, r8, lr}
     bb4:	4680      	mov	r8, r0
     bb6:	460e      	mov	r6, r1
  for (int i = 0; table[i].command_name != NULL; i++) {
     bb8:	2500      	movs	r5, #0
     bba:	e000      	b.n	bbe <execute+0xe>
     bbc:	3501      	adds	r5, #1
     bbe:	eb05 0445 	add.w	r4, r5, r5, lsl #1
     bc2:	00a4      	lsls	r4, r4, #2
     bc4:	4b0e      	ldr	r3, [pc, #56]	@ (c00 <execute+0x50>)
     bc6:	5919      	ldr	r1, [r3, r4]
     bc8:	b171      	cbz	r1, be8 <execute+0x38>
    if (strcmp(argv[0], table[i].command_name) == 0) {
     bca:	6830      	ldr	r0, [r6, #0]
     bcc:	f001 fe72 	bl	28b4 <strcmp>
     bd0:	2800      	cmp	r0, #0
     bd2:	d1f3      	bne.n	bbc <execute+0xc>
      __cmd_exec_status = table[i].command(argc, &argv[0]);
     bd4:	4b0a      	ldr	r3, [pc, #40]	@ (c00 <execute+0x50>)
     bd6:	4423      	add	r3, r4
     bd8:	689b      	ldr	r3, [r3, #8]
     bda:	4631      	mov	r1, r6
     bdc:	4640      	mov	r0, r8
     bde:	4798      	blx	r3
     be0:	4b08      	ldr	r3, [pc, #32]	@ (c04 <execute+0x54>)
     be2:	f8c3 0108 	str.w	r0, [r3, #264]	@ 0x108
  if (match_found == FALSE) {
     be6:	e008      	b.n	bfa <execute+0x4a>
    printf("\"%s\": command not found. Use \"help\" to list all command.\n",
     be8:	6831      	ldr	r1, [r6, #0]
     bea:	4807      	ldr	r0, [pc, #28]	@ (c08 <execute+0x58>)
     bec:	f000 fdde 	bl	17ac <printf>
    __cmd_exec_status = -1;
     bf0:	4b04      	ldr	r3, [pc, #16]	@ (c04 <execute+0x54>)
     bf2:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
     bf6:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
}
     bfa:	e8bd 8178 	ldmia.w	sp!, {r3, r4, r5, r6, r8, pc}
     bfe:	bf00      	nop
     c00:	00002968 	andeq	r2, r0, r8, ror #18
     c04:	20000058 	andcs	r0, r0, r8, asr r0
     c08:	00003150 	andeq	r3, r0, r0, asr r1

00000c0c <help>:
int help(int argc, char **argv) {
     c0c:	b570      	push	{r4, r5, r6, lr}
  if (argc > 1 && (strcmp(argv[1], "-l")==0)) {
     c0e:	2801      	cmp	r0, #1
     c10:	dd05      	ble.n	c1e <help+0x12>
     c12:	460b      	mov	r3, r1
     c14:	4912      	ldr	r1, [pc, #72]	@ (c60 <help+0x54>)
     c16:	6858      	ldr	r0, [r3, #4]
     c18:	f001 fe4c 	bl	28b4 <strcmp>
     c1c:	b1e0      	cbz	r0, c58 <help+0x4c>
    printf("use: help -l for list only.\n\n");
     c1e:	4811      	ldr	r0, [pc, #68]	@ (c64 <help+0x58>)
     c20:	f000 fdc4 	bl	17ac <printf>
  bool verbose = true;
     c24:	2601      	movs	r6, #1
    verbose = false;
     c26:	2500      	movs	r5, #0
     c28:	e003      	b.n	c32 <help+0x26>
    printf("\n");
     c2a:	480f      	ldr	r0, [pc, #60]	@ (c68 <help+0x5c>)
     c2c:	f000 fdbe 	bl	17ac <printf>
    i++;
     c30:	3501      	adds	r5, #1
  while (table[i].command_name != NULL) {
     c32:	eb05 0445 	add.w	r4, r5, r5, lsl #1
     c36:	00a4      	lsls	r4, r4, #2
     c38:	4b0c      	ldr	r3, [pc, #48]	@ (c6c <help+0x60>)
     c3a:	5918      	ldr	r0, [r3, r4]
     c3c:	b170      	cbz	r0, c5c <help+0x50>
    printf(table[i].command_name);
     c3e:	f000 fdb5 	bl	17ac <printf>
    if (verbose) {
     c42:	2e00      	cmp	r6, #0
     c44:	d0f1      	beq.n	c2a <help+0x1e>
      printf("\n\t");
     c46:	480a      	ldr	r0, [pc, #40]	@ (c70 <help+0x64>)
     c48:	f000 fdb0 	bl	17ac <printf>
      printf(table[i].command_help);
     c4c:	4b07      	ldr	r3, [pc, #28]	@ (c6c <help+0x60>)
     c4e:	4423      	add	r3, r4
     c50:	6858      	ldr	r0, [r3, #4]
     c52:	f000 fdab 	bl	17ac <printf>
     c56:	e7e8      	b.n	c2a <help+0x1e>
    verbose = false;
     c58:	2600      	movs	r6, #0
     c5a:	e7e4      	b.n	c26 <help+0x1a>
}
     c5c:	bd70      	pop	{r4, r5, r6, pc}
     c5e:	bf00      	nop
     c60:	0000318c 	andeq	r3, r0, ip, lsl #3
     c64:	00003190 	muleq	r0, r0, r1
     c68:	000031b4 			@ <UNDEFINED> instruction: 0x000031b4
     c6c:	00002968 	andeq	r2, r0, r8, ror #18
     c70:	000031b0 			@ <UNDEFINED> instruction: 0x000031b0

00000c74 <add_command_to_history>:
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
     c74:	b1e0      	cbz	r0, cb0 <add_command_to_history+0x3c>
static void add_command_to_history(const char *cmd_str) {
     c76:	b538      	push	{r3, r4, r5, lr}
     c78:	4605      	mov	r5, r0
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
     c7a:	490e      	ldr	r1, [pc, #56]	@ (cb4 <add_command_to_history+0x40>)
     c7c:	f001 fe1a 	bl	28b4 <strcmp>
     c80:	b900      	cbnz	r0, c84 <add_command_to_history+0x10>
}
     c82:	bd38      	pop	{r3, r4, r5, pc}
  int index = total_num_commands % NUM_HISTORY_ENTRIES;
     c84:	4c0c      	ldr	r4, [pc, #48]	@ (cb8 <add_command_to_history+0x44>)
     c86:	6860      	ldr	r0, [r4, #4]
     c88:	2800      	cmp	r0, #0
     c8a:	f000 0001 	and.w	r0, r0, #1
     c8e:	bfb8      	it	lt
     c90:	4240      	neglt	r0, r0
  memcpy(&cmd_history[index], cmd_str, LINE_BUFF_SIZE);
     c92:	f104 0308 	add.w	r3, r4, #8
     c96:	2280      	movs	r2, #128	@ 0x80
     c98:	4629      	mov	r1, r5
     c9a:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
     c9e:	f001 fe1e 	bl	28de <memcpy>
  total_num_commands++;
     ca2:	6863      	ldr	r3, [r4, #4]
     ca4:	3301      	adds	r3, #1
     ca6:	6063      	str	r3, [r4, #4]
  curr_command_ptr = total_num_commands;
     ca8:	6863      	ldr	r3, [r4, #4]
     caa:	f8c4 310c 	str.w	r3, [r4, #268]	@ 0x10c
     cae:	e7e8      	b.n	c82 <add_command_to_history+0xe>
     cb0:	4770      	bx	lr
     cb2:	bf00      	nop
     cb4:	000031b8 			@ <UNDEFINED> instruction: 0x000031b8
     cb8:	20000058 	andcs	r0, r0, r8, asr r0

00000cbc <parse_line>:
static int parse_line(char **argv, char *line_buff, int argument_size) {
     cbc:	b538      	push	{r3, r4, r5, lr}
     cbe:	4605      	mov	r5, r0
     cc0:	460c      	mov	r4, r1
  int length = strlen(line_buff);
     cc2:	4608      	mov	r0, r1
     cc4:	f001 fdee 	bl	28a4 <strlen>
     cc8:	4684      	mov	ip, r0
  int pos = 0;
     cca:	2300      	movs	r3, #0
  int argc = 0;
     ccc:	4618      	mov	r0, r3
  while (pos <= length) {
     cce:	e00f      	b.n	cf0 <parse_line+0x34>
         pos++)
     cd0:	3301      	adds	r3, #1
    for (; line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
     cd2:	18e1      	adds	r1, r4, r3
     cd4:	5ce2      	ldrb	r2, [r4, r3]
     cd6:	2a09      	cmp	r2, #9
     cd8:	d003      	beq.n	ce2 <parse_line+0x26>
     cda:	2a20      	cmp	r2, #32
     cdc:	d001      	beq.n	ce2 <parse_line+0x26>
     cde:	2a00      	cmp	r2, #0
     ce0:	d1f6      	bne.n	cd0 <parse_line+0x14>
    if (line_buff[pos] == '\t' || line_buff[pos] == SPACE)
     ce2:	2a09      	cmp	r2, #9
     ce4:	d001      	beq.n	cea <parse_line+0x2e>
     ce6:	2a20      	cmp	r2, #32
     ce8:	d101      	bne.n	cee <parse_line+0x32>
      line_buff[pos] = END_OF_LINE;
     cea:	2200      	movs	r2, #0
     cec:	700a      	strb	r2, [r1, #0]
    pos++;
     cee:	3301      	adds	r3, #1
  while (pos <= length) {
     cf0:	4563      	cmp	r3, ip
     cf2:	dc0b      	bgt.n	d0c <parse_line+0x50>
    if (line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
     cf4:	18e1      	adds	r1, r4, r3
     cf6:	5ce2      	ldrb	r2, [r4, r3]
     cf8:	2a09      	cmp	r2, #9
     cfa:	d0ea      	beq.n	cd2 <parse_line+0x16>
     cfc:	2a20      	cmp	r2, #32
     cfe:	d0e8      	beq.n	cd2 <parse_line+0x16>
     d00:	2a00      	cmp	r2, #0
     d02:	d0e6      	beq.n	cd2 <parse_line+0x16>
      argv[argc++] = &line_buff[pos];
     d04:	f845 1020 	str.w	r1, [r5, r0, lsl #2]
     d08:	3001      	adds	r0, #1
     d0a:	e7e2      	b.n	cd2 <parse_line+0x16>
}
     d0c:	bd38      	pop	{r3, r4, r5, pc}

00000d0e <prefix_match>:
  if (sub == NULL || str == NULL || len <= 0 || len > strlen(str)) {
     d0e:	b1d0      	cbz	r0, d46 <prefix_match+0x38>
static int prefix_match(char *sub, int len, const char *str) {
     d10:	b570      	push	{r4, r5, r6, lr}
     d12:	460d      	mov	r5, r1
     d14:	4614      	mov	r4, r2
     d16:	4606      	mov	r6, r0
  if (sub == NULL || str == NULL || len <= 0 || len > strlen(str)) {
     d18:	b17a      	cbz	r2, d3a <prefix_match+0x2c>
     d1a:	2900      	cmp	r1, #0
     d1c:	dd0d      	ble.n	d3a <prefix_match+0x2c>
     d1e:	4610      	mov	r0, r2
     d20:	f001 fdc0 	bl	28a4 <strlen>
     d24:	42a8      	cmp	r0, r5
     d26:	d308      	bcc.n	d3a <prefix_match+0x2c>
  for (int i = 0; i<len; ++i) {
     d28:	2300      	movs	r3, #0
     d2a:	42ab      	cmp	r3, r5
     d2c:	da07      	bge.n	d3e <prefix_match+0x30>
    if (sub[i] != str[i]) {
     d2e:	5cf1      	ldrb	r1, [r6, r3]
     d30:	5ce2      	ldrb	r2, [r4, r3]
     d32:	4291      	cmp	r1, r2
     d34:	d105      	bne.n	d42 <prefix_match+0x34>
  for (int i = 0; i<len; ++i) {
     d36:	3301      	adds	r3, #1
     d38:	e7f7      	b.n	d2a <prefix_match+0x1c>
    return FALSE;
     d3a:	2000      	movs	r0, #0
}
     d3c:	bd70      	pop	{r4, r5, r6, pc}
  return TRUE;
     d3e:	2001      	movs	r0, #1
     d40:	e7fc      	b.n	d3c <prefix_match+0x2e>
      return FALSE;
     d42:	2000      	movs	r0, #0
     d44:	e7fa      	b.n	d3c <prefix_match+0x2e>
    return FALSE;
     d46:	2000      	movs	r0, #0
}
     d48:	4770      	bx	lr

00000d4a <handle_up_arrow>:
static void handle_up_arrow(char *cmd_buff, int *char_count) {
     d4a:	b538      	push	{r3, r4, r5, lr}
     d4c:	4604      	mov	r4, r0
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
     d4e:	4a19      	ldr	r2, [pc, #100]	@ (db4 <handle_up_arrow+0x6a>)
     d50:	6853      	ldr	r3, [r2, #4]
     d52:	3b02      	subs	r3, #2
     d54:	f8d2 210c 	ldr.w	r2, [r2, #268]	@ 0x10c
     d58:	4293      	cmp	r3, r2
     d5a:	dc04      	bgt.n	d66 <handle_up_arrow+0x1c>
     d5c:	460d      	mov	r5, r1
      curr_command_ptr == 0) {
     d5e:	4b15      	ldr	r3, [pc, #84]	@ (db4 <handle_up_arrow+0x6a>)
     d60:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
     d64:	b923      	cbnz	r3, d70 <handle_up_arrow+0x26>
    printf("%s", cmd_buff);
     d66:	4621      	mov	r1, r4
     d68:	4813      	ldr	r0, [pc, #76]	@ (db8 <handle_up_arrow+0x6e>)
     d6a:	f000 fd1f 	bl	17ac <printf>
}
     d6e:	bd38      	pop	{r3, r4, r5, pc}
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
     d70:	2280      	movs	r2, #128	@ 0x80
     d72:	2100      	movs	r1, #0
     d74:	f001 fdbe 	bl	28f4 <memset>
  curr_command_ptr--;
     d78:	4b0e      	ldr	r3, [pc, #56]	@ (db4 <handle_up_arrow+0x6a>)
     d7a:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
     d7e:	3a01      	subs	r2, #1
     d80:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
     d84:	f8d3 110c 	ldr.w	r1, [r3, #268]	@ 0x10c
     d88:	2900      	cmp	r1, #0
     d8a:	f001 0101 	and.w	r1, r1, #1
     d8e:	bfb8      	it	lt
     d90:	4249      	neglt	r1, r1
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
     d92:	3308      	adds	r3, #8
     d94:	2280      	movs	r2, #128	@ 0x80
     d96:	eb03 11c1 	add.w	r1, r3, r1, lsl #7
     d9a:	4620      	mov	r0, r4
     d9c:	f001 fd9f 	bl	28de <memcpy>
  *char_count = strlen(cmd_buff);
     da0:	4620      	mov	r0, r4
     da2:	f001 fd7f 	bl	28a4 <strlen>
     da6:	6028      	str	r0, [r5, #0]
  printf("%s", cmd_buff);
     da8:	4621      	mov	r1, r4
     daa:	4803      	ldr	r0, [pc, #12]	@ (db8 <handle_up_arrow+0x6e>)
     dac:	f000 fcfe 	bl	17ac <printf>
     db0:	e7dd      	b.n	d6e <handle_up_arrow+0x24>
     db2:	bf00      	nop
     db4:	20000058 	andcs	r0, r0, r8, asr r0
     db8:	000031bc 			@ <UNDEFINED> instruction: 0x000031bc

00000dbc <handle_down_arrow>:
static void handle_down_arrow(char *cmd_buff, int *char_count) {
     dbc:	b538      	push	{r3, r4, r5, lr}
     dbe:	4604      	mov	r4, r0
     dc0:	460d      	mov	r5, r1
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
     dc2:	2280      	movs	r2, #128	@ 0x80
     dc4:	2100      	movs	r1, #0
     dc6:	f001 fd95 	bl	28f4 <memset>
  *char_count = 0;
     dca:	2300      	movs	r3, #0
     dcc:	602b      	str	r3, [r5, #0]
  if (curr_command_ptr == total_num_commands) return;
     dce:	4b11      	ldr	r3, [pc, #68]	@ (e14 <handle_down_arrow+0x58>)
     dd0:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
     dd4:	685b      	ldr	r3, [r3, #4]
     dd6:	429a      	cmp	r2, r3
     dd8:	d01b      	beq.n	e12 <handle_down_arrow+0x56>
  curr_command_ptr++;
     dda:	490e      	ldr	r1, [pc, #56]	@ (e14 <handle_down_arrow+0x58>)
     ddc:	f8d1 310c 	ldr.w	r3, [r1, #268]	@ 0x10c
     de0:	3301      	adds	r3, #1
     de2:	f8c1 310c 	str.w	r3, [r1, #268]	@ 0x10c
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
     de6:	f8d1 310c 	ldr.w	r3, [r1, #268]	@ 0x10c
     dea:	2b00      	cmp	r3, #0
     dec:	f003 0301 	and.w	r3, r3, #1
     df0:	bfb8      	it	lt
     df2:	425b      	neglt	r3, r3
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
     df4:	3108      	adds	r1, #8
     df6:	2280      	movs	r2, #128	@ 0x80
     df8:	eb01 11c3 	add.w	r1, r1, r3, lsl #7
     dfc:	4620      	mov	r0, r4
     dfe:	f001 fd6e 	bl	28de <memcpy>
  *char_count = strlen(cmd_buff);
     e02:	4620      	mov	r0, r4
     e04:	f001 fd4e 	bl	28a4 <strlen>
     e08:	6028      	str	r0, [r5, #0]
  printf("%s", cmd_buff);
     e0a:	4621      	mov	r1, r4
     e0c:	4802      	ldr	r0, [pc, #8]	@ (e18 <handle_down_arrow+0x5c>)
     e0e:	f000 fccd 	bl	17ac <printf>
}
     e12:	bd38      	pop	{r3, r4, r5, pc}
     e14:	20000058 	andcs	r0, r0, r8, asr r0
     e18:	000031bc 			@ <UNDEFINED> instruction: 0x000031bc

00000e1c <set_read_char>:
void set_read_char(int (*func)(void)) { __read_char__ = func; }
     e1c:	4b01      	ldr	r3, [pc, #4]	@ (e24 <set_read_char+0x8>)
     e1e:	f8c3 0110 	str.w	r0, [r3, #272]	@ 0x110
     e22:	4770      	bx	lr
     e24:	20000058 	andcs	r0, r0, r8, asr r0

00000e28 <set_read_char2>:
void set_read_char2(int (*func)(void)) { __read_char2__ = func; }
     e28:	4b01      	ldr	r3, [pc, #4]	@ (e30 <set_read_char2+0x8>)
     e2a:	f8c3 0114 	str.w	r0, [r3, #276]	@ 0x114
     e2e:	4770      	bx	lr
     e30:	20000058 	andcs	r0, r0, r8, asr r0

00000e34 <set_write_char>:
void set_write_char(void (*func)(char)) { __write_char__ = func; }
     e34:	4b01      	ldr	r3, [pc, #4]	@ (e3c <set_write_char+0x8>)
     e36:	6018      	str	r0, [r3, #0]
     e38:	4770      	bx	lr
     e3a:	bf00      	nop
     e3c:	20000058 	andcs	r0, r0, r8, asr r0

00000e40 <set_write_char2>:
void set_write_char2(void (*func)(char)) { __write_char2__ = func; }
     e40:	4b01      	ldr	r3, [pc, #4]	@ (e48 <set_write_char2+0x8>)
     e42:	f8c3 0118 	str.w	r0, [r3, #280]	@ 0x118
     e46:	4770      	bx	lr
     e48:	20000058 	andcs	r0, r0, r8, asr r0

00000e4c <setup>:
}
     e4c:	4770      	bx	lr

00000e4e <loop>:
}
     e4e:	4770      	bx	lr

00000e50 <prepend_prompt>:
}
     e50:	4770      	bx	lr

00000e52 <handle_tab>:
  if (cmd_buff == NULL || char_count <= 0) {
     e52:	2800      	cmp	r0, #0
     e54:	d046      	beq.n	ee4 <handle_tab+0x92>
static void handle_tab(char *cmd_buff, int *char_count) {
     e56:	e92d 4778 	stmdb	sp!, {r3, r4, r5, r6, r8, r9, sl, lr}
     e5a:	460e      	mov	r6, r1
     e5c:	4680      	mov	r8, r0
  if (cmd_buff == NULL || char_count <= 0) {
     e5e:	b309      	cbz	r1, ea4 <handle_tab+0x52>
  int last_match = -1;
     e60:	f04f 3aff 	mov.w	sl, #4294967295	@ 0xffffffff
  int match_count = 0;
     e64:	f04f 0900 	mov.w	r9, #0
  int i = 0;
     e68:	464d      	mov	r5, r9
     e6a:	e000      	b.n	e6e <handle_tab+0x1c>
    i++;
     e6c:	3501      	adds	r5, #1
  while (table[i].command_name != NULL) { //loop over all commands
     e6e:	eb05 0445 	add.w	r4, r5, r5, lsl #1
     e72:	00a4      	lsls	r4, r4, #2
     e74:	4b1c      	ldr	r3, [pc, #112]	@ (ee8 <handle_tab+0x96>)
     e76:	591a      	ldr	r2, [r3, r4]
     e78:	b172      	cbz	r2, e98 <handle_tab+0x46>
    if (prefix_match(cmd_buff, *char_count, table[i].command_name)) {
     e7a:	6831      	ldr	r1, [r6, #0]
     e7c:	4640      	mov	r0, r8
     e7e:	f7ff ff46 	bl	d0e <prefix_match>
     e82:	2800      	cmp	r0, #0
     e84:	d0f2      	beq.n	e6c <handle_tab+0x1a>
      match_count++;
     e86:	f109 0901 	add.w	r9, r9, #1
      printf("\n%s", table[i].command_name);
     e8a:	4b17      	ldr	r3, [pc, #92]	@ (ee8 <handle_tab+0x96>)
     e8c:	5919      	ldr	r1, [r3, r4]
     e8e:	4817      	ldr	r0, [pc, #92]	@ (eec <handle_tab+0x9a>)
     e90:	f000 fc8c 	bl	17ac <printf>
      last_match = i;
     e94:	46aa      	mov	sl, r5
     e96:	e7e9      	b.n	e6c <handle_tab+0x1a>
  if (match_count == 1) {
     e98:	f1b9 0f01 	cmp.w	r9, #1
     e9c:	d004      	beq.n	ea8 <handle_tab+0x56>
  if (match_count) {
     e9e:	f1b9 0f00 	cmp.w	r9, #0
     ea2:	d10e      	bne.n	ec2 <handle_tab+0x70>
}
     ea4:	e8bd 8778 	ldmia.w	sp!, {r3, r4, r5, r6, r8, r9, sl, pc}
    memcpy(cmd_buff, table[last_match].command_name, LINE_BUFF_SIZE);
     ea8:	eb0a 0a4a 	add.w	sl, sl, sl, lsl #1
     eac:	2280      	movs	r2, #128	@ 0x80
     eae:	f853 102a 	ldr.w	r1, [r3, sl, lsl #2]
     eb2:	4640      	mov	r0, r8
     eb4:	f001 fd13 	bl	28de <memcpy>
    *char_count = strlen(cmd_buff);
     eb8:	4640      	mov	r0, r8
     eba:	f001 fcf3 	bl	28a4 <strlen>
     ebe:	6030      	str	r0, [r6, #0]
     ec0:	e7ed      	b.n	e9e <handle_tab+0x4c>
    printf("\n");
     ec2:	4c0b      	ldr	r4, [pc, #44]	@ (ef0 <handle_tab+0x9e>)
     ec4:	f104 00b8 	add.w	r0, r4, #184	@ 0xb8
     ec8:	f000 fc70 	bl	17ac <printf>
    prepend_prompt();
     ecc:	f7ff ffc0 	bl	e50 <prepend_prompt>
    printf(PROMPT);
     ed0:	f104 00c8 	add.w	r0, r4, #200	@ 0xc8
     ed4:	f000 fc6a 	bl	17ac <printf>
    printf("%s", cmd_buff);
     ed8:	4641      	mov	r1, r8
     eda:	f104 00c0 	add.w	r0, r4, #192	@ 0xc0
     ede:	f000 fc65 	bl	17ac <printf>
     ee2:	e7df      	b.n	ea4 <handle_tab+0x52>
     ee4:	4770      	bx	lr
     ee6:	bf00      	nop
     ee8:	00002968 	andeq	r2, r0, r8, ror #18
     eec:	000031c0 	andeq	r3, r0, r0, asr #3
     ef0:	000030fc 	strdeq	r3, [r0], -ip

00000ef4 <active_prompt>:
__attribute__((weak)) int active_prompt() { return TRUE; }
     ef4:	2001      	movs	r0, #1
     ef6:	4770      	bx	lr

00000ef8 <shell>:
static void shell(void) {
     ef8:	b530      	push	{r4, r5, lr}
     efa:	b0e3      	sub	sp, #396	@ 0x18c
  int count = 0;
     efc:	2300      	movs	r3, #0
     efe:	9361      	str	r3, [sp, #388]	@ 0x184
  for (int i = 0; i < LINE_BUFF_SIZE; i++) line_buff[i] = 0;
     f00:	e006      	b.n	f10 <shell+0x18>
     f02:	f503 72c4 	add.w	r2, r3, #392	@ 0x188
     f06:	446a      	add	r2, sp
     f08:	2100      	movs	r1, #0
     f0a:	f802 1c84 	strb.w	r1, [r2, #-132]
     f0e:	3301      	adds	r3, #1
     f10:	2b7f      	cmp	r3, #127	@ 0x7f
     f12:	ddf6      	ble.n	f02 <shell+0xa>
  for (int i = 0; i < MAX_ARG_COUNT; i++) argv[i] = NULL;
     f14:	2300      	movs	r3, #0
     f16:	e004      	b.n	f22 <shell+0x2a>
     f18:	aa01      	add	r2, sp, #4
     f1a:	2100      	movs	r1, #0
     f1c:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
     f20:	3301      	adds	r3, #1
     f22:	2b3f      	cmp	r3, #63	@ 0x3f
     f24:	ddf8      	ble.n	f18 <shell+0x20>
  prepend_prompt();
     f26:	f7ff ff93 	bl	e50 <prepend_prompt>
  printf(PROMPT);
     f2a:	484e      	ldr	r0, [pc, #312]	@ (1064 <shell+0x16c>)
     f2c:	f000 fc3e 	bl	17ac <printf>
  int special_key = 0;
     f30:	2500      	movs	r5, #0
     f32:	e039      	b.n	fa8 <shell+0xb0>
        special_key = 1;
     f34:	2501      	movs	r5, #1
     f36:	e037      	b.n	fa8 <shell+0xb0>
    if (s == -1) { s = __read_char2__();}
     f38:	4b4b      	ldr	r3, [pc, #300]	@ (1068 <shell+0x170>)
     f3a:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
     f3e:	4798      	blx	r3
    if (s != -1) {
     f40:	f1b0 3fff 	cmp.w	r0, #4294967295	@ 0xffffffff
     f44:	d13b      	bne.n	fbe <shell+0xc6>
      loop();
     f46:	f7ff ff82 	bl	e4e <loop>
     f4a:	e02d      	b.n	fa8 <shell+0xb0>
        line_buff[count] = END_OF_LINE;
     f4c:	9b61      	ldr	r3, [sp, #388]	@ 0x184
     f4e:	f503 73c4 	add.w	r3, r3, #392	@ 0x188
     f52:	446b      	add	r3, sp
     f54:	2200      	movs	r2, #0
     f56:	f803 2c84 	strb.w	r2, [r3, #-132]
        __write_char__(NEW_LINE);
     f5a:	4b43      	ldr	r3, [pc, #268]	@ (1068 <shell+0x170>)
     f5c:	681b      	ldr	r3, [r3, #0]
     f5e:	200a      	movs	r0, #10
     f60:	4798      	blx	r3
  add_command_to_history(line_buff);
     f62:	a841      	add	r0, sp, #260	@ 0x104
     f64:	f7ff fe86 	bl	c74 <add_command_to_history>
  argc = parse_line(argv, line_buff, MAX_ARG_COUNT);
     f68:	2240      	movs	r2, #64	@ 0x40
     f6a:	a941      	add	r1, sp, #260	@ 0x104
     f6c:	a801      	add	r0, sp, #4
     f6e:	f7ff fea5 	bl	cbc <parse_line>
  if (argc > 0) execute(argc, argv);
     f72:	2800      	cmp	r0, #0
     f74:	dc71      	bgt.n	105a <shell+0x162>
}
     f76:	b063      	add	sp, #396	@ 0x18c
     f78:	bd30      	pop	{r4, r5, pc}
        if (!__echo) {
     f7a:	4b3c      	ldr	r3, [pc, #240]	@ (106c <shell+0x174>)
     f7c:	781b      	ldrb	r3, [r3, #0]
     f7e:	2b00      	cmp	r3, #0
     f80:	d03f      	beq.n	1002 <shell+0x10a>
        if (count == 0) continue;
     f82:	9b61      	ldr	r3, [sp, #388]	@ 0x184
     f84:	b183      	cbz	r3, fa8 <shell+0xb0>
        count--;
     f86:	3b01      	subs	r3, #1
     f88:	9361      	str	r3, [sp, #388]	@ 0x184
        line_buff[count] = END_OF_LINE;
     f8a:	f503 73c4 	add.w	r3, r3, #392	@ 0x188
     f8e:	446b      	add	r3, sp
     f90:	2200      	movs	r2, #0
     f92:	f803 2c84 	strb.w	r2, [r3, #-132]
        delete ();
     f96:	f7ff fdab 	bl	af0 <delete>
      if (__echo) {
     f9a:	4b34      	ldr	r3, [pc, #208]	@ (106c <shell+0x174>)
     f9c:	781b      	ldrb	r3, [r3, #0]
     f9e:	b11b      	cbz	r3, fa8 <shell+0xb0>
        __write_char__(c);
     fa0:	4b31      	ldr	r3, [pc, #196]	@ (1068 <shell+0x170>)
     fa2:	681b      	ldr	r3, [r3, #0]
     fa4:	4620      	mov	r0, r4
     fa6:	4798      	blx	r3
    if (!active_prompt()) {
     fa8:	f7ff ffa4 	bl	ef4 <active_prompt>
     fac:	2800      	cmp	r0, #0
     fae:	d0fb      	beq.n	fa8 <shell+0xb0>
    s = __read_char__();
     fb0:	4b2d      	ldr	r3, [pc, #180]	@ (1068 <shell+0x170>)
     fb2:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
     fb6:	4798      	blx	r3
    if (s == -1) { s = __read_char2__();}
     fb8:	f1b0 3fff 	cmp.w	r0, #4294967295	@ 0xffffffff
     fbc:	d0bc      	beq.n	f38 <shell+0x40>
      c = (char)s;
     fbe:	b2c4      	uxtb	r4, r0
      if (c == CARRIAGE_RETURN || c == NEW_LINE) {
     fc0:	2c0d      	cmp	r4, #13
     fc2:	d0c3      	beq.n	f4c <shell+0x54>
     fc4:	2c0a      	cmp	r4, #10
     fc6:	d0c1      	beq.n	f4c <shell+0x54>
      if (c == DELETE || c == BACK_SPACE) {
     fc8:	2c7f      	cmp	r4, #127	@ 0x7f
     fca:	d0d6      	beq.n	f7a <shell+0x82>
     fcc:	2c08      	cmp	r4, #8
     fce:	d0d4      	beq.n	f7a <shell+0x82>
      } else if (c == ESCAPE) {
     fd0:	2c1b      	cmp	r4, #27
     fd2:	d0af      	beq.n	f34 <shell+0x3c>
      } else if (c == SQUARE_BRACKET_OPEN && special_key == 1) {
     fd4:	2c5b      	cmp	r4, #91	@ 0x5b
     fd6:	d019      	beq.n	100c <shell+0x114>
      } else if ((c == 'C' || c == 'D') && special_key != 0) {
     fd8:	f1a4 0343 	sub.w	r3, r4, #67	@ 0x43
     fdc:	b2db      	uxtb	r3, r3
     fde:	2b01      	cmp	r3, #1
     fe0:	d918      	bls.n	1014 <shell+0x11c>
      } else if ((c == 'A' || c == 'B') && special_key == 2) {
     fe2:	f1a4 0341 	sub.w	r3, r4, #65	@ 0x41
     fe6:	b2db      	uxtb	r3, r3
     fe8:	2b01      	cmp	r3, #1
     fea:	d917      	bls.n	101c <shell+0x124>
      else if (c == TAB) {
     fec:	2c09      	cmp	r4, #9
     fee:	d02f      	beq.n	1050 <shell+0x158>
        line_buff[count] = c;
     ff0:	9b61      	ldr	r3, [sp, #388]	@ 0x184
     ff2:	f503 72c4 	add.w	r2, r3, #392	@ 0x188
     ff6:	446a      	add	r2, sp
     ff8:	f802 4c84 	strb.w	r4, [r2, #-132]
        count++;
     ffc:	3301      	adds	r3, #1
     ffe:	9361      	str	r3, [sp, #388]	@ 0x184
    1000:	e7cb      	b.n	f9a <shell+0xa2>
          delete ();
    1002:	f7ff fd75 	bl	af0 <delete>
          delete ();
    1006:	f7ff fd73 	bl	af0 <delete>
    100a:	e7ba      	b.n	f82 <shell+0x8a>
      } else if (c == SQUARE_BRACKET_OPEN && special_key == 1) {
    100c:	2d01      	cmp	r5, #1
    100e:	d1e3      	bne.n	fd8 <shell+0xe0>
        special_key = 2;
    1010:	2502      	movs	r5, #2
    1012:	e7c9      	b.n	fa8 <shell+0xb0>
      } else if ((c == 'C' || c == 'D') && special_key != 0) {
    1014:	2d00      	cmp	r5, #0
    1016:	d0e4      	beq.n	fe2 <shell+0xea>
        special_key = 0;
    1018:	2500      	movs	r5, #0
    101a:	e7c5      	b.n	fa8 <shell+0xb0>
      } else if ((c == 'A' || c == 'B') && special_key == 2) {
    101c:	2d02      	cmp	r5, #2
    101e:	d1e5      	bne.n	fec <shell+0xf4>
        if (!__echo) {
    1020:	4b12      	ldr	r3, [pc, #72]	@ (106c <shell+0x174>)
    1022:	781b      	ldrb	r3, [r3, #0]
    1024:	b95b      	cbnz	r3, 103e <shell+0x146>
          clear_prompt(count + 4);
    1026:	9861      	ldr	r0, [sp, #388]	@ 0x184
    1028:	3004      	adds	r0, #4
    102a:	f7ff fd6f 	bl	b0c <clear_prompt>
        if (c == 'A') {
    102e:	2c41      	cmp	r4, #65	@ 0x41
    1030:	d009      	beq.n	1046 <shell+0x14e>
          handle_down_arrow(line_buff, &count);
    1032:	a961      	add	r1, sp, #388	@ 0x184
    1034:	a841      	add	r0, sp, #260	@ 0x104
    1036:	f7ff fec1 	bl	dbc <handle_down_arrow>
        special_key = 0;
    103a:	2500      	movs	r5, #0
        continue;
    103c:	e7b4      	b.n	fa8 <shell+0xb0>
          clear_prompt(count);
    103e:	9861      	ldr	r0, [sp, #388]	@ 0x184
    1040:	f7ff fd64 	bl	b0c <clear_prompt>
    1044:	e7f3      	b.n	102e <shell+0x136>
          handle_up_arrow(line_buff, &count);
    1046:	a961      	add	r1, sp, #388	@ 0x184
    1048:	a841      	add	r0, sp, #260	@ 0x104
    104a:	f7ff fe7e 	bl	d4a <handle_up_arrow>
    104e:	e7f4      	b.n	103a <shell+0x142>
        handle_tab(line_buff, &count);
    1050:	a961      	add	r1, sp, #388	@ 0x184
    1052:	a841      	add	r0, sp, #260	@ 0x104
    1054:	f7ff fefd 	bl	e52 <handle_tab>
        continue;
    1058:	e7a6      	b.n	fa8 <shell+0xb0>
  if (argc > 0) execute(argc, argv);
    105a:	a901      	add	r1, sp, #4
    105c:	f7ff fda8 	bl	bb0 <execute>
}
    1060:	e789      	b.n	f76 <shell+0x7e>
    1062:	bf00      	nop
    1064:	000031c4 	andeq	r3, r0, r4, asr #3
    1068:	20000058 	andcs	r0, r0, r8, asr r0
    106c:	20000000 	andcs	r0, r0, r0

00001070 <prompt>:
void prompt() {
    1070:	b508      	push	{r3, lr}
  initial_setup();
    1072:	f7ff fd07 	bl	a84 <initial_setup>
  exec_auto_cmds();
    1076:	f7ff fd52 	bl	b1e <exec_auto_cmds>
  setup();
    107a:	f7ff fee7 	bl	e4c <setup>
  decode_base64(AES_key_b64, 44, AES_key);
    107e:	4c08      	ldr	r4, [pc, #32]	@ (10a0 <prompt+0x30>)
    1080:	f504 758e 	add.w	r5, r4, #284	@ 0x11c
    1084:	462a      	mov	r2, r5
    1086:	212c      	movs	r1, #44	@ 0x2c
    1088:	4806      	ldr	r0, [pc, #24]	@ (10a4 <prompt+0x34>)
    108a:	f000 f90b 	bl	12a4 <decode_base64>
  AES_init_ctx(&ctx, AES_key);
    108e:	4629      	mov	r1, r5
    1090:	f504 709e 	add.w	r0, r4, #316	@ 0x13c
    1094:	f001 f825 	bl	20e2 <AES_init_ctx>
    shell();
    1098:	f7ff ff2e 	bl	ef8 <shell>
  while (TRUE) {
    109c:	e7fc      	b.n	1098 <prompt+0x28>
    109e:	bf00      	nop
    10a0:	20000058 	andcs	r0, r0, r8, asr r0
    10a4:	20000004 	andcs	r0, r0, r4

000010a8 <exec>:
int exec(char *cmd_str) {
    10a8:	b500      	push	{lr}
    10aa:	b0c1      	sub	sp, #260	@ 0x104
    10ac:	4601      	mov	r1, r0
  argc = parse_line(argv, cmd_str, MAX_ARG_COUNT);
    10ae:	2240      	movs	r2, #64	@ 0x40
    10b0:	4668      	mov	r0, sp
    10b2:	f7ff fe03 	bl	cbc <parse_line>
  if (argc > 0) execute(argc, argv);
    10b6:	2800      	cmp	r0, #0
    10b8:	dc05      	bgt.n	10c6 <exec+0x1e>
  return __cmd_exec_status;
    10ba:	4b05      	ldr	r3, [pc, #20]	@ (10d0 <exec+0x28>)
    10bc:	f8d3 0108 	ldr.w	r0, [r3, #264]	@ 0x108
}
    10c0:	b041      	add	sp, #260	@ 0x104
    10c2:	f85d fb04 	ldr.w	pc, [sp], #4
  if (argc > 0) execute(argc, argv);
    10c6:	4669      	mov	r1, sp
    10c8:	f7ff fd72 	bl	bb0 <execute>
    10cc:	e7f5      	b.n	10ba <exec+0x12>
    10ce:	bf00      	nop
    10d0:	20000058 	andcs	r0, r0, r8, asr r0

000010d4 <get_function_addr>:
cmd get_function_addr(char *cmd_str) {
    10d4:	b570      	push	{r4, r5, r6, lr}
    10d6:	4606      	mov	r6, r0
  for (int i = 0; table[i].command_name != NULL; i++) {
    10d8:	2500      	movs	r5, #0
    10da:	e000      	b.n	10de <get_function_addr+0xa>
    10dc:	3501      	adds	r5, #1
    10de:	eb05 0445 	add.w	r4, r5, r5, lsl #1
    10e2:	00a4      	lsls	r4, r4, #2
    10e4:	4b06      	ldr	r3, [pc, #24]	@ (1100 <get_function_addr+0x2c>)
    10e6:	5919      	ldr	r1, [r3, r4]
    10e8:	b141      	cbz	r1, 10fc <get_function_addr+0x28>
    if (strcmp(cmd_str, table[i].command_name) == 0) {
    10ea:	4630      	mov	r0, r6
    10ec:	f001 fbe2 	bl	28b4 <strcmp>
    10f0:	2800      	cmp	r0, #0
    10f2:	d1f3      	bne.n	10dc <get_function_addr+0x8>
      return table[i].command;
    10f4:	4b02      	ldr	r3, [pc, #8]	@ (1100 <get_function_addr+0x2c>)
    10f6:	4423      	add	r3, r4
    10f8:	6898      	ldr	r0, [r3, #8]
    10fa:	e000      	b.n	10fe <get_function_addr+0x2a>
  return NULL;
    10fc:	2000      	movs	r0, #0
}
    10fe:	bd70      	pop	{r4, r5, r6, pc}
    1100:	00002968 	andeq	r2, r0, r8, ror #18

00001104 <binary_to_base64>:
#include "base64.h"

unsigned char binary_to_base64(unsigned char v) {
  // Capital letters - 'A' is ascii 65 and base64 0
  if(v < 26) return v + 'A';
    1104:	2819      	cmp	r0, #25
    1106:	d909      	bls.n	111c <binary_to_base64+0x18>
  
  // Lowercase letters - 'a' is ascii 97 and base64 26
  if(v < 52) return v + 71;
    1108:	2833      	cmp	r0, #51	@ 0x33
    110a:	d90a      	bls.n	1122 <binary_to_base64+0x1e>
  
  // Digits - '0' is ascii 48 and base64 52
  if(v < 62) return v - 4;
    110c:	283d      	cmp	r0, #61	@ 0x3d
    110e:	d90b      	bls.n	1128 <binary_to_base64+0x24>
  
  // '+' is ascii 43 and base64 62
  if(v == 62) return '+';
    1110:	283e      	cmp	r0, #62	@ 0x3e
    1112:	d00c      	beq.n	112e <binary_to_base64+0x2a>
  
  // '/' is ascii 47 and base64 63
  if(v == 63) return '/';
    1114:	283f      	cmp	r0, #63	@ 0x3f
    1116:	d00c      	beq.n	1132 <binary_to_base64+0x2e>
  
  return 64;
    1118:	2040      	movs	r0, #64	@ 0x40
    111a:	4770      	bx	lr
  if(v < 26) return v + 'A';
    111c:	3041      	adds	r0, #65	@ 0x41
    111e:	b2c0      	uxtb	r0, r0
    1120:	4770      	bx	lr
  if(v < 52) return v + 71;
    1122:	3047      	adds	r0, #71	@ 0x47
    1124:	b2c0      	uxtb	r0, r0
    1126:	4770      	bx	lr
  if(v < 62) return v - 4;
    1128:	3804      	subs	r0, #4
    112a:	b2c0      	uxtb	r0, r0
    112c:	4770      	bx	lr
  if(v == 62) return '+';
    112e:	202b      	movs	r0, #43	@ 0x2b
    1130:	4770      	bx	lr
  if(v == 63) return '/';
    1132:	202f      	movs	r0, #47	@ 0x2f
}
    1134:	4770      	bx	lr

00001136 <base64_to_binary>:

unsigned char base64_to_binary(unsigned char c) {
    1136:	4603      	mov	r3, r0
  // Capital letters - 'A' is ascii 65 and base64 0
  if('A' <= c && c <= 'Z') return c - 'A';
    1138:	3841      	subs	r0, #65	@ 0x41
    113a:	b2c0      	uxtb	r0, r0
    113c:	2819      	cmp	r0, #25
    113e:	d918      	bls.n	1172 <base64_to_binary+0x3c>
  
  // Lowercase letters - 'a' is ascii 97 and base64 26
  if('a' <= c && c <= 'z') return c - 71;
    1140:	f1a3 0261 	sub.w	r2, r3, #97	@ 0x61
    1144:	b2d2      	uxtb	r2, r2
    1146:	2a19      	cmp	r2, #25
    1148:	d90a      	bls.n	1160 <base64_to_binary+0x2a>
  
  // Digits - '0' is ascii 48 and base64 52
  if('0' <= c && c <= '9') return c + 4;
    114a:	f1a3 0230 	sub.w	r2, r3, #48	@ 0x30
    114e:	b2d2      	uxtb	r2, r2
    1150:	2a09      	cmp	r2, #9
    1152:	d908      	bls.n	1166 <base64_to_binary+0x30>
  
  // '+' is ascii 43 and base64 62
  if(c == '+') return 62;
    1154:	2b2b      	cmp	r3, #43	@ 0x2b
    1156:	d009      	beq.n	116c <base64_to_binary+0x36>
  
  // '/' is ascii 47 and base64 63
  if(c == '/') return 63;
    1158:	2b2f      	cmp	r3, #47	@ 0x2f
    115a:	d009      	beq.n	1170 <base64_to_binary+0x3a>
  
  return 255;
    115c:	20ff      	movs	r0, #255	@ 0xff
    115e:	4770      	bx	lr
  if('a' <= c && c <= 'z') return c - 71;
    1160:	3b47      	subs	r3, #71	@ 0x47
    1162:	b2d8      	uxtb	r0, r3
    1164:	4770      	bx	lr
  if('0' <= c && c <= '9') return c + 4;
    1166:	3304      	adds	r3, #4
    1168:	b2d8      	uxtb	r0, r3
    116a:	4770      	bx	lr
  if(c == '+') return 62;
    116c:	203e      	movs	r0, #62	@ 0x3e
    116e:	4770      	bx	lr
  if(c == '/') return 63;
    1170:	203f      	movs	r0, #63	@ 0x3f
}
    1172:	4770      	bx	lr

00001174 <encode_base64_length>:

unsigned int encode_base64_length(unsigned int input_length) {
  return (input_length + 2)/3*4;
    1174:	3002      	adds	r0, #2
    1176:	4b03      	ldr	r3, [pc, #12]	@ (1184 <encode_base64_length+0x10>)
    1178:	fba3 3000 	umull	r3, r0, r3, r0
    117c:	0840      	lsrs	r0, r0, #1
}
    117e:	0080      	lsls	r0, r0, #2
    1180:	4770      	bx	lr
    1182:	bf00      	nop
    1184:	aaaaaaab 	bge	feaabc38 <_STACK_TOP_+0xdeaa3c3c>

00001188 <decode_base64_length>:

unsigned int decode_base64_length(unsigned char input[], unsigned int input_length) {
    1188:	b570      	push	{r4, r5, r6, lr}
    118a:	4605      	mov	r5, r0
    118c:	460e      	mov	r6, r1
  unsigned char *start = input;
  
  while(base64_to_binary(input[0]) < 64 && (unsigned int) (input - start) < input_length) {
    118e:	4604      	mov	r4, r0
    1190:	e000      	b.n	1194 <decode_base64_length+0xc>
    ++input;
    1192:	3401      	adds	r4, #1
  while(base64_to_binary(input[0]) < 64 && (unsigned int) (input - start) < input_length) {
    1194:	7820      	ldrb	r0, [r4, #0]
    1196:	f7ff ffce 	bl	1136 <base64_to_binary>
    119a:	283f      	cmp	r0, #63	@ 0x3f
    119c:	d802      	bhi.n	11a4 <decode_base64_length+0x1c>
    119e:	1b63      	subs	r3, r4, r5
    11a0:	42b3      	cmp	r3, r6
    11a2:	d3f6      	bcc.n	1192 <decode_base64_length+0xa>
  }
  
  input_length = input - start;
    11a4:	1b64      	subs	r4, r4, r5
  return input_length/4*3 + (input_length % 4 ? input_length % 4 - 1 : 0);
    11a6:	08a0      	lsrs	r0, r4, #2
    11a8:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    11ac:	f014 0403 	ands.w	r4, r4, #3
    11b0:	d002      	beq.n	11b8 <decode_base64_length+0x30>
    11b2:	3c01      	subs	r4, #1
}
    11b4:	4420      	add	r0, r4
    11b6:	bd70      	pop	{r4, r5, r6, pc}
  return input_length/4*3 + (input_length % 4 ? input_length % 4 - 1 : 0);
    11b8:	2400      	movs	r4, #0
    11ba:	e7fb      	b.n	11b4 <decode_base64_length+0x2c>

000011bc <encode_base64>:

unsigned int encode_base64(unsigned char input[], unsigned int input_length, unsigned char output[]) {
    11bc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    11c0:	4604      	mov	r4, r0
    11c2:	4688      	mov	r8, r1
    11c4:	4615      	mov	r5, r2
  unsigned int full_sets = input_length/3;
    11c6:	4f36      	ldr	r7, [pc, #216]	@ (12a0 <encode_base64+0xe4>)
    11c8:	fba7 3701 	umull	r3, r7, r7, r1
    11cc:	087f      	lsrs	r7, r7, #1
  
  // While there are still full sets of 24 bits...
  for(unsigned int i = 0; i < full_sets; ++i) {
    11ce:	2600      	movs	r6, #0
    11d0:	e021      	b.n	1216 <encode_base64+0x5a>
    output[0] = binary_to_base64(                         input[0] >> 2);
    11d2:	7820      	ldrb	r0, [r4, #0]
    11d4:	0880      	lsrs	r0, r0, #2
    11d6:	f7ff ff95 	bl	1104 <binary_to_base64>
    11da:	7028      	strb	r0, [r5, #0]
    output[1] = binary_to_base64((input[0] & 0x03) << 4 | input[1] >> 4);
    11dc:	7823      	ldrb	r3, [r4, #0]
    11de:	011b      	lsls	r3, r3, #4
    11e0:	f003 0330 	and.w	r3, r3, #48	@ 0x30
    11e4:	7860      	ldrb	r0, [r4, #1]
    11e6:	ea43 1010 	orr.w	r0, r3, r0, lsr #4
    11ea:	f7ff ff8b 	bl	1104 <binary_to_base64>
    11ee:	7068      	strb	r0, [r5, #1]
    output[2] = binary_to_base64((input[1] & 0x0F) << 2 | input[2] >> 6);
    11f0:	7863      	ldrb	r3, [r4, #1]
    11f2:	009b      	lsls	r3, r3, #2
    11f4:	f003 033c 	and.w	r3, r3, #60	@ 0x3c
    11f8:	78a0      	ldrb	r0, [r4, #2]
    11fa:	ea43 1090 	orr.w	r0, r3, r0, lsr #6
    11fe:	f7ff ff81 	bl	1104 <binary_to_base64>
    1202:	70a8      	strb	r0, [r5, #2]
    output[3] = binary_to_base64( input[2] & 0x3F);
    1204:	78a0      	ldrb	r0, [r4, #2]
    1206:	f000 003f 	and.w	r0, r0, #63	@ 0x3f
    120a:	f7ff ff7b 	bl	1104 <binary_to_base64>
    120e:	70e8      	strb	r0, [r5, #3]
    
    input += 3;
    1210:	3403      	adds	r4, #3
    output += 4;
    1212:	3504      	adds	r5, #4
  for(unsigned int i = 0; i < full_sets; ++i) {
    1214:	3601      	adds	r6, #1
    1216:	42be      	cmp	r6, r7
    1218:	d3db      	bcc.n	11d2 <encode_base64+0x16>
  }
  
  switch(input_length % 3) {
    121a:	4a21      	ldr	r2, [pc, #132]	@ (12a0 <encode_base64+0xe4>)
    121c:	fba2 3208 	umull	r3, r2, r2, r8
    1220:	f022 0301 	bic.w	r3, r2, #1
    1224:	eb03 0352 	add.w	r3, r3, r2, lsr #1
    1228:	eba8 0303 	sub.w	r3, r8, r3
    122c:	2b01      	cmp	r3, #1
    122e:	d009      	beq.n	1244 <encode_base64+0x88>
    1230:	2b02      	cmp	r3, #2
    1232:	d019      	beq.n	1268 <encode_base64+0xac>
    1234:	b123      	cbz	r3, 1240 <encode_base64+0x84>
      output[3] = '=';
      output[4] = '\0';
      break;
  }
  
  return encode_base64_length(input_length);
    1236:	4640      	mov	r0, r8
    1238:	f7ff ff9c 	bl	1174 <encode_base64_length>
}
    123c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      output[0] = '\0';
    1240:	702b      	strb	r3, [r5, #0]
      break;
    1242:	e7f8      	b.n	1236 <encode_base64+0x7a>
      output[0] = binary_to_base64(                         input[0] >> 2);
    1244:	7820      	ldrb	r0, [r4, #0]
    1246:	0880      	lsrs	r0, r0, #2
    1248:	f7ff ff5c 	bl	1104 <binary_to_base64>
    124c:	7028      	strb	r0, [r5, #0]
      output[1] = binary_to_base64((input[0] & 0x03) << 4);
    124e:	7820      	ldrb	r0, [r4, #0]
    1250:	0100      	lsls	r0, r0, #4
    1252:	f000 0030 	and.w	r0, r0, #48	@ 0x30
    1256:	f7ff ff55 	bl	1104 <binary_to_base64>
    125a:	7068      	strb	r0, [r5, #1]
      output[2] = '=';
    125c:	233d      	movs	r3, #61	@ 0x3d
    125e:	70ab      	strb	r3, [r5, #2]
      output[3] = '=';
    1260:	70eb      	strb	r3, [r5, #3]
      output[4] = '\0';
    1262:	2300      	movs	r3, #0
    1264:	712b      	strb	r3, [r5, #4]
      break;
    1266:	e7e6      	b.n	1236 <encode_base64+0x7a>
      output[0] = binary_to_base64(                         input[0] >> 2);
    1268:	7820      	ldrb	r0, [r4, #0]
    126a:	0880      	lsrs	r0, r0, #2
    126c:	f7ff ff4a 	bl	1104 <binary_to_base64>
    1270:	7028      	strb	r0, [r5, #0]
      output[1] = binary_to_base64((input[0] & 0x03) << 4 | input[1] >> 4);
    1272:	7823      	ldrb	r3, [r4, #0]
    1274:	011b      	lsls	r3, r3, #4
    1276:	f003 0330 	and.w	r3, r3, #48	@ 0x30
    127a:	7860      	ldrb	r0, [r4, #1]
    127c:	ea43 1010 	orr.w	r0, r3, r0, lsr #4
    1280:	f7ff ff40 	bl	1104 <binary_to_base64>
    1284:	7068      	strb	r0, [r5, #1]
      output[2] = binary_to_base64((input[1] & 0x0F) << 2);
    1286:	7860      	ldrb	r0, [r4, #1]
    1288:	0080      	lsls	r0, r0, #2
    128a:	f000 003c 	and.w	r0, r0, #60	@ 0x3c
    128e:	f7ff ff39 	bl	1104 <binary_to_base64>
    1292:	70a8      	strb	r0, [r5, #2]
      output[3] = '=';
    1294:	233d      	movs	r3, #61	@ 0x3d
    1296:	70eb      	strb	r3, [r5, #3]
      output[4] = '\0';
    1298:	2300      	movs	r3, #0
    129a:	712b      	strb	r3, [r5, #4]
      break;
    129c:	e7cb      	b.n	1236 <encode_base64+0x7a>
    129e:	bf00      	nop
    12a0:	aaaaaaab 	bge	feaabd54 <_STACK_TOP_+0xdeaa3d58>

000012a4 <decode_base64>:


unsigned int decode_base64(unsigned char input[], unsigned int input_length, unsigned char output[]) {
    12a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    12a8:	4604      	mov	r4, r0
    12aa:	4616      	mov	r6, r2
  unsigned int output_length = decode_base64_length(input, input_length);
    12ac:	f7ff ff6c 	bl	1188 <decode_base64_length>
    12b0:	4680      	mov	r8, r0
  
  // While there are still full sets of 24 bits...
  for(unsigned int i = 2; i < output_length; i += 3) {
    12b2:	2702      	movs	r7, #2
    12b4:	e01f      	b.n	12f6 <decode_base64+0x52>
    output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
    12b6:	7820      	ldrb	r0, [r4, #0]
    12b8:	f7ff ff3d 	bl	1136 <base64_to_binary>
    12bc:	0085      	lsls	r5, r0, #2
    12be:	7860      	ldrb	r0, [r4, #1]
    12c0:	f7ff ff39 	bl	1136 <base64_to_binary>
    12c4:	ea45 1510 	orr.w	r5, r5, r0, lsr #4
    12c8:	7035      	strb	r5, [r6, #0]
    output[1] = base64_to_binary(input[1]) << 4 | base64_to_binary(input[2]) >> 2;
    12ca:	7860      	ldrb	r0, [r4, #1]
    12cc:	f7ff ff33 	bl	1136 <base64_to_binary>
    12d0:	0105      	lsls	r5, r0, #4
    12d2:	78a0      	ldrb	r0, [r4, #2]
    12d4:	f7ff ff2f 	bl	1136 <base64_to_binary>
    12d8:	ea45 0590 	orr.w	r5, r5, r0, lsr #2
    12dc:	7075      	strb	r5, [r6, #1]
    output[2] = base64_to_binary(input[2]) << 6 | base64_to_binary(input[3]);
    12de:	78a0      	ldrb	r0, [r4, #2]
    12e0:	f7ff ff29 	bl	1136 <base64_to_binary>
    12e4:	0185      	lsls	r5, r0, #6
    12e6:	78e0      	ldrb	r0, [r4, #3]
    12e8:	f7ff ff25 	bl	1136 <base64_to_binary>
    12ec:	4328      	orrs	r0, r5
    12ee:	70b0      	strb	r0, [r6, #2]
    
    input += 4;
    12f0:	3404      	adds	r4, #4
    output += 3;
    12f2:	3603      	adds	r6, #3
  for(unsigned int i = 2; i < output_length; i += 3) {
    12f4:	3703      	adds	r7, #3
    12f6:	4547      	cmp	r7, r8
    12f8:	d3dd      	bcc.n	12b6 <decode_base64+0x12>
  }
  
  switch(output_length % 3) {
    12fa:	4a18      	ldr	r2, [pc, #96]	@ (135c <decode_base64+0xb8>)
    12fc:	fba2 3208 	umull	r3, r2, r2, r8
    1300:	f022 0301 	bic.w	r3, r2, #1
    1304:	eb03 0352 	add.w	r3, r3, r2, lsr #1
    1308:	eba8 0303 	sub.w	r3, r8, r3
    130c:	2b01      	cmp	r3, #1
    130e:	d004      	beq.n	131a <decode_base64+0x76>
    1310:	2b02      	cmp	r3, #2
    1312:	d00d      	beq.n	1330 <decode_base64+0x8c>
      output[1] = base64_to_binary(input[1]) << 4 | base64_to_binary(input[2]) >> 2;
      break;
  }
  
  return output_length;
    1314:	4640      	mov	r0, r8
    1316:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
    131a:	7820      	ldrb	r0, [r4, #0]
    131c:	f7ff ff0b 	bl	1136 <base64_to_binary>
    1320:	0085      	lsls	r5, r0, #2
    1322:	7860      	ldrb	r0, [r4, #1]
    1324:	f7ff ff07 	bl	1136 <base64_to_binary>
    1328:	ea45 1510 	orr.w	r5, r5, r0, lsr #4
    132c:	7035      	strb	r5, [r6, #0]
      break;
    132e:	e7f1      	b.n	1314 <decode_base64+0x70>
      output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
    1330:	7820      	ldrb	r0, [r4, #0]
    1332:	f7ff ff00 	bl	1136 <base64_to_binary>
    1336:	0085      	lsls	r5, r0, #2
    1338:	7860      	ldrb	r0, [r4, #1]
    133a:	f7ff fefc 	bl	1136 <base64_to_binary>
    133e:	ea45 1510 	orr.w	r5, r5, r0, lsr #4
    1342:	7035      	strb	r5, [r6, #0]
      output[1] = base64_to_binary(input[1]) << 4 | base64_to_binary(input[2]) >> 2;
    1344:	7860      	ldrb	r0, [r4, #1]
    1346:	f7ff fef6 	bl	1136 <base64_to_binary>
    134a:	0105      	lsls	r5, r0, #4
    134c:	78a0      	ldrb	r0, [r4, #2]
    134e:	f7ff fef2 	bl	1136 <base64_to_binary>
    1352:	ea45 0590 	orr.w	r5, r5, r0, lsr #2
    1356:	7075      	strb	r5, [r6, #1]
  return output_length;
    1358:	e7dc      	b.n	1314 <decode_base64+0x70>
    135a:	bf00      	nop
    135c:	aaaaaaab 	bge	feaabe10 <_STACK_TOP_+0xdeaa3e14>

00001360 <sha256_transform>:
	0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2
};

/*********************** FUNCTION DEFINITIONS ***********************/
void sha256_transform(SHA256_CTX *ctx, const BYTE data[])
{
    1360:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1364:	b0c9      	sub	sp, #292	@ 0x124
    1366:	4681      	mov	r9, r0
	WORD a, b, c, d, e, f, g, h, i, j, t1, t2, m[64];

	for (i = 0, j = 0; i < 16; ++i, j += 4)
    1368:	2000      	movs	r0, #0
    136a:	4602      	mov	r2, r0
    136c:	e00f      	b.n	138e <sha256_transform+0x2e>
		m[i] = (data[j] << 24) | (data[j + 1] << 16) | (data[j + 2] << 8) | (data[j + 3]);
    136e:	5c0d      	ldrb	r5, [r1, r0]
    1370:	180c      	adds	r4, r1, r0
    1372:	7863      	ldrb	r3, [r4, #1]
    1374:	041b      	lsls	r3, r3, #16
    1376:	ea43 6305 	orr.w	r3, r3, r5, lsl #24
    137a:	78a5      	ldrb	r5, [r4, #2]
    137c:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
    1380:	78e4      	ldrb	r4, [r4, #3]
    1382:	4323      	orrs	r3, r4
    1384:	ac08      	add	r4, sp, #32
    1386:	f844 3022 	str.w	r3, [r4, r2, lsl #2]
	for (i = 0, j = 0; i < 16; ++i, j += 4)
    138a:	3201      	adds	r2, #1
    138c:	3004      	adds	r0, #4
    138e:	2a0f      	cmp	r2, #15
    1390:	d9ed      	bls.n	136e <sha256_transform+0xe>
    1392:	e022      	b.n	13da <sha256_transform+0x7a>
	for ( ; i < 64; ++i)
		m[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16];
    1394:	1e93      	subs	r3, r2, #2
    1396:	a908      	add	r1, sp, #32
    1398:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
    139c:	ea4f 43f1 	mov.w	r3, r1, ror #19
    13a0:	ea83 4371 	eor.w	r3, r3, r1, ror #17
    13a4:	ea83 2391 	eor.w	r3, r3, r1, lsr #10
    13a8:	1fd1      	subs	r1, r2, #7
    13aa:	a808      	add	r0, sp, #32
    13ac:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
    13b0:	440b      	add	r3, r1
    13b2:	f1a2 010f 	sub.w	r1, r2, #15
    13b6:	f850 0021 	ldr.w	r0, [r0, r1, lsl #2]
    13ba:	ea4f 41b0 	mov.w	r1, r0, ror #18
    13be:	ea81 11f0 	eor.w	r1, r1, r0, ror #7
    13c2:	ea81 01d0 	eor.w	r1, r1, r0, lsr #3
    13c6:	440b      	add	r3, r1
    13c8:	f1a2 0110 	sub.w	r1, r2, #16
    13cc:	a808      	add	r0, sp, #32
    13ce:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
    13d2:	440b      	add	r3, r1
    13d4:	f840 3022 	str.w	r3, [r0, r2, lsl #2]
	for ( ; i < 64; ++i)
    13d8:	3201      	adds	r2, #1
    13da:	2a3f      	cmp	r2, #63	@ 0x3f
    13dc:	d9da      	bls.n	1394 <sha256_transform+0x34>

	a = ctx->state[0];
    13de:	f8d9 a050 	ldr.w	sl, [r9, #80]	@ 0x50
	b = ctx->state[1];
    13e2:	f8d9 b054 	ldr.w	fp, [r9, #84]	@ 0x54
	c = ctx->state[2];
    13e6:	f8d9 1058 	ldr.w	r1, [r9, #88]	@ 0x58
	d = ctx->state[3];
    13ea:	f8d9 305c 	ldr.w	r3, [r9, #92]	@ 0x5c
	e = ctx->state[4];
    13ee:	f8d9 2060 	ldr.w	r2, [r9, #96]	@ 0x60
    13f2:	9201      	str	r2, [sp, #4]
	f = ctx->state[5];
    13f4:	f8d9 7064 	ldr.w	r7, [r9, #100]	@ 0x64
    13f8:	9702      	str	r7, [sp, #8]
	g = ctx->state[6];
    13fa:	f8d9 6068 	ldr.w	r6, [r9, #104]	@ 0x68
    13fe:	9603      	str	r6, [sp, #12]
	h = ctx->state[7];
    1400:	f8d9 006c 	ldr.w	r0, [r9, #108]	@ 0x6c
    1404:	9004      	str	r0, [sp, #16]
    1406:	4686      	mov	lr, r0
	d = ctx->state[3];
    1408:	4698      	mov	r8, r3
	c = ctx->state[2];
    140a:	460c      	mov	r4, r1
	b = ctx->state[1];
    140c:	465d      	mov	r5, fp
	a = ctx->state[0];
    140e:	46d4      	mov	ip, sl

	for (i = 0; i < 64; ++i) {
    1410:	2000      	movs	r0, #0
    1412:	f8cd a014 	str.w	sl, [sp, #20]
    1416:	f8cd b018 	str.w	fp, [sp, #24]
    141a:	9107      	str	r1, [sp, #28]
    141c:	e030      	b.n	1480 <sha256_transform+0x120>
		t1 = h + EP1(e) + CH(e,f,g) + k[i] + m[i];
    141e:	ea4f 21f2 	mov.w	r1, r2, ror #11
    1422:	ea81 11b2 	eor.w	r1, r1, r2, ror #6
    1426:	ea81 6172 	eor.w	r1, r1, r2, ror #25
    142a:	4471      	add	r1, lr
    142c:	ea02 0e07 	and.w	lr, r2, r7
    1430:	ea26 0a02 	bic.w	sl, r6, r2
    1434:	ea8e 0e0a 	eor.w	lr, lr, sl
    1438:	448e      	add	lr, r1
    143a:	4925      	ldr	r1, [pc, #148]	@ (14d0 <sha256_transform+0x170>)
    143c:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
    1440:	eb0e 0a01 	add.w	sl, lr, r1
    1444:	a908      	add	r1, sp, #32
    1446:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
    144a:	448a      	add	sl, r1
		t2 = EP0(a) + MAJ(a,b,c);
    144c:	ea4f 3e7c 	mov.w	lr, ip, ror #13
    1450:	ea8e 0ebc 	eor.w	lr, lr, ip, ror #2
    1454:	ea8e 5ebc 	eor.w	lr, lr, ip, ror #22
    1458:	ea85 0104 	eor.w	r1, r5, r4
    145c:	ea01 010c 	and.w	r1, r1, ip
    1460:	ea05 0b04 	and.w	fp, r5, r4
    1464:	ea81 010b 	eor.w	r1, r1, fp
    1468:	4471      	add	r1, lr
	for (i = 0; i < 64; ++i) {
    146a:	3001      	adds	r0, #1
		h = g;
    146c:	46b6      	mov	lr, r6
		g = f;
    146e:	463e      	mov	r6, r7
		f = e;
    1470:	4617      	mov	r7, r2
		e = d + t1;
    1472:	eb08 020a 	add.w	r2, r8, sl
		d = c;
    1476:	46a0      	mov	r8, r4
		c = b;
    1478:	462c      	mov	r4, r5
		b = a;
    147a:	4665      	mov	r5, ip
		a = t1 + t2;
    147c:	eb0a 0c01 	add.w	ip, sl, r1
	for (i = 0; i < 64; ++i) {
    1480:	283f      	cmp	r0, #63	@ 0x3f
    1482:	d9cc      	bls.n	141e <sha256_transform+0xbe>
	}

	ctx->state[0] += a;
    1484:	f8dd a014 	ldr.w	sl, [sp, #20]
    1488:	f8dd b018 	ldr.w	fp, [sp, #24]
    148c:	9907      	ldr	r1, [sp, #28]
    148e:	eb0c 000a 	add.w	r0, ip, sl
    1492:	f8c9 0050 	str.w	r0, [r9, #80]	@ 0x50
	ctx->state[1] += b;
    1496:	445d      	add	r5, fp
    1498:	f8c9 5054 	str.w	r5, [r9, #84]	@ 0x54
	ctx->state[2] += c;
    149c:	440c      	add	r4, r1
    149e:	f8c9 4058 	str.w	r4, [r9, #88]	@ 0x58
	ctx->state[3] += d;
    14a2:	4443      	add	r3, r8
    14a4:	f8c9 305c 	str.w	r3, [r9, #92]	@ 0x5c
	ctx->state[4] += e;
    14a8:	9b01      	ldr	r3, [sp, #4]
    14aa:	441a      	add	r2, r3
    14ac:	f8c9 2060 	str.w	r2, [r9, #96]	@ 0x60
	ctx->state[5] += f;
    14b0:	9b02      	ldr	r3, [sp, #8]
    14b2:	441f      	add	r7, r3
    14b4:	f8c9 7064 	str.w	r7, [r9, #100]	@ 0x64
	ctx->state[6] += g;
    14b8:	9b03      	ldr	r3, [sp, #12]
    14ba:	441e      	add	r6, r3
    14bc:	f8c9 6068 	str.w	r6, [r9, #104]	@ 0x68
	ctx->state[7] += h;
    14c0:	9b04      	ldr	r3, [sp, #16]
    14c2:	4473      	add	r3, lr
    14c4:	f8c9 306c 	str.w	r3, [r9, #108]	@ 0x6c
}
    14c8:	b049      	add	sp, #292	@ 0x124
    14ca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    14ce:	bf00      	nop
    14d0:	0000326c 	andeq	r3, r0, ip, ror #4

000014d4 <sha256_init>:

void sha256_init(SHA256_CTX *ctx)
{
	ctx->datalen = 0;
    14d4:	2300      	movs	r3, #0
    14d6:	6403      	str	r3, [r0, #64]	@ 0x40
	ctx->bitlen = 0;
    14d8:	2200      	movs	r2, #0
    14da:	2300      	movs	r3, #0
    14dc:	e9c0 2312 	strd	r2, r3, [r0, #72]	@ 0x48
	ctx->state[0] = 0x6a09e667;
    14e0:	4b0a      	ldr	r3, [pc, #40]	@ (150c <sha256_init+0x38>)
    14e2:	6503      	str	r3, [r0, #80]	@ 0x50
	ctx->state[1] = 0xbb67ae85;
    14e4:	4b0a      	ldr	r3, [pc, #40]	@ (1510 <sha256_init+0x3c>)
    14e6:	6543      	str	r3, [r0, #84]	@ 0x54
	ctx->state[2] = 0x3c6ef372;
    14e8:	4b0a      	ldr	r3, [pc, #40]	@ (1514 <sha256_init+0x40>)
    14ea:	6583      	str	r3, [r0, #88]	@ 0x58
	ctx->state[3] = 0xa54ff53a;
    14ec:	4b0a      	ldr	r3, [pc, #40]	@ (1518 <sha256_init+0x44>)
    14ee:	65c3      	str	r3, [r0, #92]	@ 0x5c
	ctx->state[4] = 0x510e527f;
    14f0:	4b0a      	ldr	r3, [pc, #40]	@ (151c <sha256_init+0x48>)
    14f2:	6603      	str	r3, [r0, #96]	@ 0x60
	ctx->state[5] = 0x9b05688c;
    14f4:	4b0a      	ldr	r3, [pc, #40]	@ (1520 <sha256_init+0x4c>)
    14f6:	6643      	str	r3, [r0, #100]	@ 0x64
	ctx->state[6] = 0x1f83d9ab;
    14f8:	4b0a      	ldr	r3, [pc, #40]	@ (1524 <sha256_init+0x50>)
    14fa:	6683      	str	r3, [r0, #104]	@ 0x68
	ctx->state[7] = 0x5be0cd19;
    14fc:	f103 5374 	add.w	r3, r3, #1023410176	@ 0x3d000000
    1500:	f5a3 0323 	sub.w	r3, r3, #10682368	@ 0xa30000
    1504:	f6a3 4392 	subw	r3, r3, #3218	@ 0xc92
    1508:	66c3      	str	r3, [r0, #108]	@ 0x6c
}
    150a:	4770      	bx	lr
    150c:	6a09e667 	bvs	27aeb0 <__ROM_SIZE__+0x23aeb0>
    1510:	bb67ae85 	bllt	19ecf2c <__ROM_SIZE__+0x19acf2c>
    1514:	3c6ef372 	stclcc	3, cr15, [lr], #-456	@ 0xfffffe38
    1518:	a54ff53a 	strbge	pc, [pc, #-1338]	@ fe6 <shell+0xee>	@ <UNPREDICTABLE>
    151c:	510e527f 	tstpl	lr, pc, ror r2
    1520:	9b05688c 	blls	15b758 <__ROM_SIZE__+0x11b758>
    1524:	1f83d9ab 	svcne	0x0083d9ab

00001528 <sha256_update>:

void sha256_update(SHA256_CTX *ctx, const BYTE data[], size_t len)
{
    1528:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    152a:	4604      	mov	r4, r0
    152c:	460f      	mov	r7, r1
    152e:	4616      	mov	r6, r2
	WORD i;

	for (i = 0; i < len; ++i) {
    1530:	2500      	movs	r5, #0
    1532:	e000      	b.n	1536 <sha256_update+0xe>
    1534:	3501      	adds	r5, #1
    1536:	42b5      	cmp	r5, r6
    1538:	d215      	bcs.n	1566 <sha256_update+0x3e>
		ctx->data[ctx->datalen] = data[i];
    153a:	6c23      	ldr	r3, [r4, #64]	@ 0x40
    153c:	5d78      	ldrb	r0, [r7, r5]
    153e:	54e0      	strb	r0, [r4, r3]
		ctx->datalen++;
    1540:	3301      	adds	r3, #1
    1542:	6423      	str	r3, [r4, #64]	@ 0x40
		if (ctx->datalen == 64) {
    1544:	2b40      	cmp	r3, #64	@ 0x40
    1546:	d1f5      	bne.n	1534 <sha256_update+0xc>
			sha256_transform(ctx, ctx->data);
    1548:	4621      	mov	r1, r4
    154a:	4620      	mov	r0, r4
    154c:	f7ff ff08 	bl	1360 <sha256_transform>
			ctx->bitlen += 512;
    1550:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
    1552:	6ce2      	ldr	r2, [r4, #76]	@ 0x4c
    1554:	f513 7300 	adds.w	r3, r3, #512	@ 0x200
    1558:	f142 0200 	adc.w	r2, r2, #0
    155c:	64a3      	str	r3, [r4, #72]	@ 0x48
    155e:	64e2      	str	r2, [r4, #76]	@ 0x4c
			ctx->datalen = 0;
    1560:	2300      	movs	r3, #0
    1562:	6423      	str	r3, [r4, #64]	@ 0x40
    1564:	e7e6      	b.n	1534 <sha256_update+0xc>
		}
	}
}
    1566:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00001568 <sha256_final>:

void sha256_final(SHA256_CTX *ctx, BYTE hash[])
{
    1568:	b538      	push	{r3, r4, r5, lr}
    156a:	4604      	mov	r4, r0
    156c:	460d      	mov	r5, r1
	WORD i;

	i = ctx->datalen;
    156e:	6c02      	ldr	r2, [r0, #64]	@ 0x40

	// Pad whatever data is left in the buffer.
	if (ctx->datalen < 56) {
    1570:	2a37      	cmp	r2, #55	@ 0x37
    1572:	d82d      	bhi.n	15d0 <sha256_final+0x68>
		ctx->data[i++] = 0x80;
    1574:	1c53      	adds	r3, r2, #1
    1576:	2180      	movs	r1, #128	@ 0x80
    1578:	5481      	strb	r1, [r0, r2]
		while (i < 56)
    157a:	e002      	b.n	1582 <sha256_final+0x1a>
			ctx->data[i++] = 0x00;
    157c:	2200      	movs	r2, #0
    157e:	54e2      	strb	r2, [r4, r3]
    1580:	3301      	adds	r3, #1
		while (i < 56)
    1582:	2b37      	cmp	r3, #55	@ 0x37
    1584:	d9fa      	bls.n	157c <sha256_final+0x14>
		sha256_transform(ctx, ctx->data);
		memset(ctx->data, 0, 56);
	}

	// Append to the padding the total message's length in bits and transform.
	ctx->bitlen += ctx->datalen * 8;
    1586:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
    1588:	6ce2      	ldr	r2, [r4, #76]	@ 0x4c
    158a:	6c21      	ldr	r1, [r4, #64]	@ 0x40
    158c:	00c9      	lsls	r1, r1, #3
    158e:	185b      	adds	r3, r3, r1
    1590:	f142 0200 	adc.w	r2, r2, #0
    1594:	64a3      	str	r3, [r4, #72]	@ 0x48
    1596:	64e2      	str	r2, [r4, #76]	@ 0x4c
	ctx->data[63] = ctx->bitlen;
    1598:	f884 303f 	strb.w	r3, [r4, #63]	@ 0x3f
	ctx->data[62] = ctx->bitlen >> 8;
    159c:	0a19      	lsrs	r1, r3, #8
    159e:	f884 103e 	strb.w	r1, [r4, #62]	@ 0x3e
	ctx->data[61] = ctx->bitlen >> 16;
    15a2:	0c19      	lsrs	r1, r3, #16
    15a4:	f884 103d 	strb.w	r1, [r4, #61]	@ 0x3d
	ctx->data[60] = ctx->bitlen >> 24;
    15a8:	0e1b      	lsrs	r3, r3, #24
    15aa:	f884 303c 	strb.w	r3, [r4, #60]	@ 0x3c
	ctx->data[59] = ctx->bitlen >> 32;
    15ae:	f884 203b 	strb.w	r2, [r4, #59]	@ 0x3b
	ctx->data[58] = ctx->bitlen >> 40;
    15b2:	0a13      	lsrs	r3, r2, #8
    15b4:	f884 303a 	strb.w	r3, [r4, #58]	@ 0x3a
	ctx->data[57] = ctx->bitlen >> 48;
    15b8:	0c13      	lsrs	r3, r2, #16
    15ba:	f884 3039 	strb.w	r3, [r4, #57]	@ 0x39
	ctx->data[56] = ctx->bitlen >> 56;
    15be:	0e12      	lsrs	r2, r2, #24
    15c0:	f884 2038 	strb.w	r2, [r4, #56]	@ 0x38
	sha256_transform(ctx, ctx->data);
    15c4:	4621      	mov	r1, r4
    15c6:	4620      	mov	r0, r4
    15c8:	f7ff feca 	bl	1360 <sha256_transform>

	// Since this implementation uses little endian byte ordering and SHA uses big endian,
	// reverse all the bytes when copying the final state to the output hash.
	for (i = 0; i < 4; ++i) {
    15cc:	2300      	movs	r3, #0
    15ce:	e03b      	b.n	1648 <sha256_final+0xe0>
		ctx->data[i++] = 0x80;
    15d0:	1c53      	adds	r3, r2, #1
    15d2:	2180      	movs	r1, #128	@ 0x80
    15d4:	5481      	strb	r1, [r0, r2]
		while (i < 64)
    15d6:	e002      	b.n	15de <sha256_final+0x76>
			ctx->data[i++] = 0x00;
    15d8:	2200      	movs	r2, #0
    15da:	54e2      	strb	r2, [r4, r3]
    15dc:	3301      	adds	r3, #1
		while (i < 64)
    15de:	2b3f      	cmp	r3, #63	@ 0x3f
    15e0:	d9fa      	bls.n	15d8 <sha256_final+0x70>
		sha256_transform(ctx, ctx->data);
    15e2:	4621      	mov	r1, r4
    15e4:	4620      	mov	r0, r4
    15e6:	f7ff febb 	bl	1360 <sha256_transform>
		memset(ctx->data, 0, 56);
    15ea:	2238      	movs	r2, #56	@ 0x38
    15ec:	2100      	movs	r1, #0
    15ee:	4620      	mov	r0, r4
    15f0:	f001 f980 	bl	28f4 <memset>
    15f4:	e7c7      	b.n	1586 <sha256_final+0x1e>
		hash[i]      = (ctx->state[0] >> (24 - i * 8)) & 0x000000ff;
    15f6:	6d21      	ldr	r1, [r4, #80]	@ 0x50
    15f8:	f1c3 0203 	rsb	r2, r3, #3
    15fc:	00d2      	lsls	r2, r2, #3
    15fe:	40d1      	lsrs	r1, r2
    1600:	54e9      	strb	r1, [r5, r3]
		hash[i + 4]  = (ctx->state[1] >> (24 - i * 8)) & 0x000000ff;
    1602:	6d61      	ldr	r1, [r4, #84]	@ 0x54
    1604:	40d1      	lsrs	r1, r2
    1606:	1d18      	adds	r0, r3, #4
    1608:	5429      	strb	r1, [r5, r0]
		hash[i + 8]  = (ctx->state[2] >> (24 - i * 8)) & 0x000000ff;
    160a:	6da1      	ldr	r1, [r4, #88]	@ 0x58
    160c:	40d1      	lsrs	r1, r2
    160e:	f103 0008 	add.w	r0, r3, #8
    1612:	5429      	strb	r1, [r5, r0]
		hash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0x000000ff;
    1614:	6de1      	ldr	r1, [r4, #92]	@ 0x5c
    1616:	40d1      	lsrs	r1, r2
    1618:	f103 000c 	add.w	r0, r3, #12
    161c:	5429      	strb	r1, [r5, r0]
		hash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0x000000ff;
    161e:	6e21      	ldr	r1, [r4, #96]	@ 0x60
    1620:	40d1      	lsrs	r1, r2
    1622:	f103 0010 	add.w	r0, r3, #16
    1626:	5429      	strb	r1, [r5, r0]
		hash[i + 20] = (ctx->state[5] >> (24 - i * 8)) & 0x000000ff;
    1628:	6e61      	ldr	r1, [r4, #100]	@ 0x64
    162a:	40d1      	lsrs	r1, r2
    162c:	f103 0014 	add.w	r0, r3, #20
    1630:	5429      	strb	r1, [r5, r0]
		hash[i + 24] = (ctx->state[6] >> (24 - i * 8)) & 0x000000ff;
    1632:	6ea1      	ldr	r1, [r4, #104]	@ 0x68
    1634:	40d1      	lsrs	r1, r2
    1636:	f103 0018 	add.w	r0, r3, #24
    163a:	5429      	strb	r1, [r5, r0]
		hash[i + 28] = (ctx->state[7] >> (24 - i * 8)) & 0x000000ff;
    163c:	6ee1      	ldr	r1, [r4, #108]	@ 0x6c
    163e:	40d1      	lsrs	r1, r2
    1640:	f103 021c 	add.w	r2, r3, #28
    1644:	54a9      	strb	r1, [r5, r2]
	for (i = 0; i < 4; ++i) {
    1646:	3301      	adds	r3, #1
    1648:	2b03      	cmp	r3, #3
    164a:	d9d4      	bls.n	15f6 <sha256_final+0x8e>
	}
}
    164c:	bd38      	pop	{r3, r4, r5, pc}
    164e:	bf00      	nop

00001650 <outstr>:
} printf_state;

static char hextable[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                          '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

static void outstr(const char *str) {
    1650:	b510      	push	{r4, lr}
    1652:	4604      	mov	r4, r0
  while (*str != '\0') {
    1654:	e003      	b.n	165e <outstr+0xe>
    __write_char__(*str);
    1656:	4b04      	ldr	r3, [pc, #16]	@ (1668 <outstr+0x18>)
    1658:	681b      	ldr	r3, [r3, #0]
    165a:	4798      	blx	r3
    str++;
    165c:	3401      	adds	r4, #1
  while (*str != '\0') {
    165e:	7820      	ldrb	r0, [r4, #0]
    1660:	2800      	cmp	r0, #0
    1662:	d1f8      	bne.n	1656 <outstr+0x6>
  }
}
    1664:	bd10      	pop	{r4, pc}
    1666:	bf00      	nop
    1668:	20000058 	andcs	r0, r0, r8, asr r0

0000166c <printf_numbers>:

static bool printf_numbers(const char fmt, va_list *args, int l_count) {
    166c:	b530      	push	{r4, r5, lr}
    166e:	b085      	sub	sp, #20
    1670:	4614      	mov	r4, r2
  char num[MAX_DIGITS];
  int num_len = 0;

  switch (fmt) {
    1672:	2864      	cmp	r0, #100	@ 0x64
    1674:	d01d      	beq.n	16b2 <printf_numbers+0x46>
    1676:	d914      	bls.n	16a2 <printf_numbers+0x36>
    1678:	2875      	cmp	r0, #117	@ 0x75
    167a:	d001      	beq.n	1680 <printf_numbers+0x14>
    167c:	2878      	cmp	r0, #120	@ 0x78
    167e:	d112      	bne.n	16a6 <printf_numbers+0x3a>
#ifndef SHELL_NO_PRINTF_LL
      long long unsigned int value = 0;
#else
      unsigned int value = 0;
#endif  // SHELL_NO_PRINTF_LL
      if (l_count == 0) {
    1680:	2c00      	cmp	r4, #0
    1682:	f040 8086 	bne.w	1792 <printf_numbers+0x126>
        value = va_arg(*args, unsigned int);
    1686:	680b      	ldr	r3, [r1, #0]
    1688:	1d1a      	adds	r2, r3, #4
    168a:	600a      	str	r2, [r1, #0]
    168c:	681d      	ldr	r5, [r3, #0]
#endif  // SHELL_NO_PRINTF_LL
      } else {
        return false;
      }

      if (fmt == 'u') {
    168e:	2875      	cmp	r0, #117	@ 0x75
    1690:	d043      	beq.n	171a <printf_numbers+0xae>

        while (num_len > 0) {
          __write_char__(num[--num_len]);
        };
      } else {
        if (value == 0) {
    1692:	2d00      	cmp	r5, #0
    1694:	d176      	bne.n	1784 <printf_numbers+0x118>
          __write_char__(hextable[0]);
    1696:	4b40      	ldr	r3, [pc, #256]	@ (1798 <printf_numbers+0x12c>)
    1698:	681b      	ldr	r3, [r3, #0]
    169a:	2030      	movs	r0, #48	@ 0x30
    169c:	4798      	blx	r3
    }
    default:
      outstr("\nprintf-error\n");
      return false;
  }
  return true;
    169e:	2001      	movs	r0, #1
    16a0:	e005      	b.n	16ae <printf_numbers+0x42>
  switch (fmt) {
    16a2:	2858      	cmp	r0, #88	@ 0x58
    16a4:	d0ec      	beq.n	1680 <printf_numbers+0x14>
      outstr("\nprintf-error\n");
    16a6:	483d      	ldr	r0, [pc, #244]	@ (179c <printf_numbers+0x130>)
    16a8:	f7ff ffd2 	bl	1650 <outstr>
      return false;
    16ac:	2000      	movs	r0, #0
}
    16ae:	b005      	add	sp, #20
    16b0:	bd30      	pop	{r4, r5, pc}
      if (l_count == 0) {
    16b2:	2a00      	cmp	r2, #0
    16b4:	d16b      	bne.n	178e <printf_numbers+0x122>
        value = va_arg(*args, int);
    16b6:	680b      	ldr	r3, [r1, #0]
    16b8:	1d1a      	adds	r2, r3, #4
    16ba:	600a      	str	r2, [r1, #0]
    16bc:	681d      	ldr	r5, [r3, #0]
      if (value < 0) {
    16be:	2d00      	cmp	r5, #0
    16c0:	db17      	blt.n	16f2 <printf_numbers+0x86>
        num[num_len++] = hextable[value % 10];
    16c2:	4a37      	ldr	r2, [pc, #220]	@ (17a0 <printf_numbers+0x134>)
    16c4:	fb82 3205 	smull	r3, r2, r2, r5
    16c8:	17eb      	asrs	r3, r5, #31
    16ca:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
    16ce:	4619      	mov	r1, r3
    16d0:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    16d4:	eba5 0343 	sub.w	r3, r5, r3, lsl #1
    16d8:	4832      	ldr	r0, [pc, #200]	@ (17a4 <printf_numbers+0x138>)
    16da:	5cc0      	ldrb	r0, [r0, r3]
    16dc:	4623      	mov	r3, r4
    16de:	3310      	adds	r3, #16
    16e0:	446b      	add	r3, sp
    16e2:	3401      	adds	r4, #1
    16e4:	f803 0c0c 	strb.w	r0, [r3, #-12]
        value = value / 10;
    16e8:	462b      	mov	r3, r5
    16ea:	460d      	mov	r5, r1
      } while (value > 0);
    16ec:	2b09      	cmp	r3, #9
    16ee:	dce8      	bgt.n	16c2 <printf_numbers+0x56>
    16f0:	e00f      	b.n	1712 <printf_numbers+0xa6>
        __write_char__('-');
    16f2:	4b29      	ldr	r3, [pc, #164]	@ (1798 <printf_numbers+0x12c>)
    16f4:	681b      	ldr	r3, [r3, #0]
    16f6:	202d      	movs	r0, #45	@ 0x2d
    16f8:	4798      	blx	r3
        value = -value;
    16fa:	426d      	negs	r5, r5
    16fc:	e7e1      	b.n	16c2 <printf_numbers+0x56>
        __write_char__(num[--num_len]);
    16fe:	3c01      	subs	r4, #1
    1700:	f104 0310 	add.w	r3, r4, #16
    1704:	eb0d 0203 	add.w	r2, sp, r3
    1708:	4b23      	ldr	r3, [pc, #140]	@ (1798 <printf_numbers+0x12c>)
    170a:	681b      	ldr	r3, [r3, #0]
    170c:	f812 0c0c 	ldrb.w	r0, [r2, #-12]
    1710:	4798      	blx	r3
      while (num_len > 0) {
    1712:	2c00      	cmp	r4, #0
    1714:	dcf3      	bgt.n	16fe <printf_numbers+0x92>
  return true;
    1716:	2001      	movs	r0, #1
    1718:	e7c9      	b.n	16ae <printf_numbers+0x42>
          num[num_len++] = hextable[value % 10];
    171a:	4b23      	ldr	r3, [pc, #140]	@ (17a8 <printf_numbers+0x13c>)
    171c:	fba3 2305 	umull	r2, r3, r3, r5
    1720:	08db      	lsrs	r3, r3, #3
    1722:	4619      	mov	r1, r3
    1724:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    1728:	eba5 0343 	sub.w	r3, r5, r3, lsl #1
    172c:	481d      	ldr	r0, [pc, #116]	@ (17a4 <printf_numbers+0x138>)
    172e:	5cc0      	ldrb	r0, [r0, r3]
    1730:	4623      	mov	r3, r4
    1732:	3310      	adds	r3, #16
    1734:	446b      	add	r3, sp
    1736:	3401      	adds	r4, #1
    1738:	f803 0c0c 	strb.w	r0, [r3, #-12]
          value = value / 10;
    173c:	462b      	mov	r3, r5
    173e:	460d      	mov	r5, r1
        } while (value > 0);
    1740:	2b09      	cmp	r3, #9
    1742:	d8ea      	bhi.n	171a <printf_numbers+0xae>
        while (num_len > 0) {
    1744:	2c00      	cmp	r4, #0
    1746:	dd0a      	ble.n	175e <printf_numbers+0xf2>
          __write_char__(num[--num_len]);
    1748:	3c01      	subs	r4, #1
    174a:	f104 0310 	add.w	r3, r4, #16
    174e:	eb0d 0203 	add.w	r2, sp, r3
    1752:	4b11      	ldr	r3, [pc, #68]	@ (1798 <printf_numbers+0x12c>)
    1754:	681b      	ldr	r3, [r3, #0]
    1756:	f812 0c0c 	ldrb.w	r0, [r2, #-12]
    175a:	4798      	blx	r3
    175c:	e7f2      	b.n	1744 <printf_numbers+0xd8>
  return true;
    175e:	2001      	movs	r0, #1
    1760:	e7a5      	b.n	16ae <printf_numbers+0x42>
              __write_char__(hextable[val]);
    1762:	4a0d      	ldr	r2, [pc, #52]	@ (1798 <printf_numbers+0x12c>)
    1764:	6812      	ldr	r2, [r2, #0]
    1766:	490f      	ldr	r1, [pc, #60]	@ (17a4 <printf_numbers+0x138>)
    1768:	5cc8      	ldrb	r0, [r1, r3]
    176a:	4790      	blx	r2
              leading_zero_ignored = true;
    176c:	2201      	movs	r2, #1
            start_bit -= 4;
    176e:	3c04      	subs	r4, #4
          while (start_bit >= 0) {
    1770:	2c00      	cmp	r4, #0
    1772:	db0a      	blt.n	178a <printf_numbers+0x11e>
            int val = (value >> start_bit) & 0xF;
    1774:	fa25 f304 	lsr.w	r3, r5, r4
            if (val || leading_zero_ignored) {
    1778:	f013 030f 	ands.w	r3, r3, #15
    177c:	d1f1      	bne.n	1762 <printf_numbers+0xf6>
    177e:	2a00      	cmp	r2, #0
    1780:	d0f5      	beq.n	176e <printf_numbers+0x102>
    1782:	e7ee      	b.n	1762 <printf_numbers+0xf6>
          bool leading_zero_ignored = false;
    1784:	2200      	movs	r2, #0
          int start_bit = LAST_NIBBLE_FIRST_BIT;
    1786:	241c      	movs	r4, #28
    1788:	e7f2      	b.n	1770 <printf_numbers+0x104>
  return true;
    178a:	2001      	movs	r0, #1
    178c:	e78f      	b.n	16ae <printf_numbers+0x42>
        return false;
    178e:	2000      	movs	r0, #0
    1790:	e78d      	b.n	16ae <printf_numbers+0x42>
        return false;
    1792:	2000      	movs	r0, #0
    1794:	e78b      	b.n	16ae <printf_numbers+0x42>
    1796:	bf00      	nop
    1798:	20000058 	andcs	r0, r0, r8, asr r0
    179c:	0000336c 	andeq	r3, r0, ip, ror #6
    17a0:	66666667 	strbtvs	r6, [r6], -r7, ror #12
    17a4:	0000337c 	andeq	r3, r0, ip, ror r3
    17a8:	cccccccd 	stclgt	12, cr12, [ip], {205}	@ 0xcd

000017ac <printf>:

int printf(const char *fmt, ...) {
    17ac:	b40f      	push	{r0, r1, r2, r3}
    17ae:	b530      	push	{r4, r5, lr}
    17b0:	b083      	sub	sp, #12
    17b2:	ab06      	add	r3, sp, #24
    17b4:	f853 4b04 	ldr.w	r4, [r3], #4
  printf_state state = CHECK_CH;
  va_list args;

  va_start(args, fmt);
    17b8:	9301      	str	r3, [sp, #4]
  printf_state state = CHECK_CH;
    17ba:	2500      	movs	r5, #0

  while (*fmt) {
    17bc:	e005      	b.n	17ca <printf+0x1e>
    switch (state) {
      case CHECK_CH: {
        if (*fmt == '%') {
    17be:	2825      	cmp	r0, #37	@ 0x25
    17c0:	d00a      	beq.n	17d8 <printf+0x2c>
          state = PARSE_FMT_STR;
          fmt++;
          continue;
        }
        __write_char__(*fmt);
    17c2:	4b30      	ldr	r3, [pc, #192]	@ (1884 <printf+0xd8>)
    17c4:	681b      	ldr	r3, [r3, #0]
    17c6:	4798      	blx	r3
        fmt++;
    17c8:	3401      	adds	r4, #1
  while (*fmt) {
    17ca:	7820      	ldrb	r0, [r4, #0]
    17cc:	2800      	cmp	r0, #0
    17ce:	d050      	beq.n	1872 <printf+0xc6>
    switch (state) {
    17d0:	2d00      	cmp	r5, #0
    17d2:	d0f4      	beq.n	17be <printf+0x12>
    17d4:	b925      	cbnz	r5, 17e0 <printf+0x34>
    17d6:	e7f8      	b.n	17ca <printf+0x1e>
          fmt++;
    17d8:	3401      	adds	r4, #1
          state = PARSE_FMT_STR;
    17da:	2501      	movs	r5, #1
          continue;
    17dc:	e7f5      	b.n	17ca <printf+0x1e>
        break;
      }
      case PARSE_FMT_STR: {
        // Support only basic format specifiers
        while (*fmt && ((*fmt >= '0' && *fmt <= '9') || *fmt == '-')) {
          fmt++;
    17de:	3401      	adds	r4, #1
        while (*fmt && ((*fmt >= '0' && *fmt <= '9') || *fmt == '-')) {
    17e0:	7820      	ldrb	r0, [r4, #0]
    17e2:	b130      	cbz	r0, 17f2 <printf+0x46>
    17e4:	f1a0 0330 	sub.w	r3, r0, #48	@ 0x30
    17e8:	b2db      	uxtb	r3, r3
    17ea:	2b09      	cmp	r3, #9
    17ec:	d9f7      	bls.n	17de <printf+0x32>
    17ee:	282d      	cmp	r0, #45	@ 0x2d
    17f0:	d0f5      	beq.n	17de <printf+0x32>
        }

        switch (*fmt) {
    17f2:	2863      	cmp	r0, #99	@ 0x63
    17f4:	d019      	beq.n	182a <printf+0x7e>
    17f6:	d80b      	bhi.n	1810 <printf+0x64>
    17f8:	2843      	cmp	r0, #67	@ 0x43
    17fa:	d016      	beq.n	182a <printf+0x7e>
    17fc:	2853      	cmp	r0, #83	@ 0x53
    17fe:	d00b      	beq.n	1818 <printf+0x6c>
    1800:	2825      	cmp	r0, #37	@ 0x25
    1802:	d12c      	bne.n	185e <printf+0xb2>
          case '%':
            __write_char__(*fmt);
    1804:	4b1f      	ldr	r3, [pc, #124]	@ (1884 <printf+0xd8>)
    1806:	681b      	ldr	r3, [r3, #0]
    1808:	4798      	blx	r3
            fmt++;
    180a:	3401      	adds	r4, #1
            state = CHECK_CH;
    180c:	2500      	movs	r5, #0
            break;
    180e:	e7dc      	b.n	17ca <printf+0x1e>
    1810:	286c      	cmp	r0, #108	@ 0x6c
    1812:	d014      	beq.n	183e <printf+0x92>
    1814:	2873      	cmp	r0, #115	@ 0x73
    1816:	d122      	bne.n	185e <printf+0xb2>
            fmt++;
            state = CHECK_CH;
            break;
          case 's':
          case 'S':
            outstr(va_arg(args, const char *));
    1818:	9b01      	ldr	r3, [sp, #4]
    181a:	1d1a      	adds	r2, r3, #4
    181c:	9201      	str	r2, [sp, #4]
    181e:	6818      	ldr	r0, [r3, #0]
    1820:	f7ff ff16 	bl	1650 <outstr>
            fmt++;
    1824:	3401      	adds	r4, #1
            state = CHECK_CH;
    1826:	2500      	movs	r5, #0
            break;
    1828:	e7cf      	b.n	17ca <printf+0x1e>
            __write_char__(va_arg(args, int));
    182a:	4b16      	ldr	r3, [pc, #88]	@ (1884 <printf+0xd8>)
    182c:	681a      	ldr	r2, [r3, #0]
    182e:	9b01      	ldr	r3, [sp, #4]
    1830:	1d19      	adds	r1, r3, #4
    1832:	9101      	str	r1, [sp, #4]
    1834:	7818      	ldrb	r0, [r3, #0]
    1836:	4790      	blx	r2
            fmt++;
    1838:	3401      	adds	r4, #1
            state = CHECK_CH;
    183a:	2500      	movs	r5, #0
            break;
    183c:	e7c5      	b.n	17ca <printf+0x1e>
          case 'l': {
            int l_count = 1;
            fmt++;
    183e:	1c65      	adds	r5, r4, #1
            if (*fmt == 'l') {
    1840:	7863      	ldrb	r3, [r4, #1]
    1842:	2b6c      	cmp	r3, #108	@ 0x6c
    1844:	d008      	beq.n	1858 <printf+0xac>
            int l_count = 1;
    1846:	2201      	movs	r2, #1
              l_count++;
              fmt++;
            }
            if (printf_numbers(*fmt, &args, l_count)) {
    1848:	a901      	add	r1, sp, #4
    184a:	7828      	ldrb	r0, [r5, #0]
    184c:	f7ff ff0e 	bl	166c <printf_numbers>
    1850:	b168      	cbz	r0, 186e <printf+0xc2>
              state = CHECK_CH;
              fmt++;
    1852:	1c6c      	adds	r4, r5, #1
              state = CHECK_CH;
    1854:	2500      	movs	r5, #0
              break;
    1856:	e7b8      	b.n	17ca <printf+0x1e>
              fmt++;
    1858:	1ca5      	adds	r5, r4, #2
              l_count++;
    185a:	2202      	movs	r2, #2
    185c:	e7f4      	b.n	1848 <printf+0x9c>
            }
            return -1;
          }
          default: {
            if (printf_numbers(*fmt, &args, 0)) {
    185e:	2200      	movs	r2, #0
    1860:	a901      	add	r1, sp, #4
    1862:	f7ff ff03 	bl	166c <printf_numbers>
    1866:	b148      	cbz	r0, 187c <printf+0xd0>
              state = CHECK_CH;
              fmt++;
    1868:	3401      	adds	r4, #1
              state = CHECK_CH;
    186a:	2500      	movs	r5, #0
              break;
    186c:	e7ad      	b.n	17ca <printf+0x1e>
            return -1;
    186e:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    }
  }

  va_end(args);
  return 0;
}
    1872:	b003      	add	sp, #12
    1874:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    1878:	b004      	add	sp, #16
    187a:	4770      	bx	lr
            return -1;
    187c:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    1880:	e7f7      	b.n	1872 <printf+0xc6>
    1882:	bf00      	nop
    1884:	20000058 	andcs	r0, r0, r8, asr r0

00001888 <outstr2>:
} printf2_state;

static char hextable2[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                          '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

static void outstr2(const char *str) {
    1888:	b510      	push	{r4, lr}
    188a:	4604      	mov	r4, r0
  while (*str != '\0') {
    188c:	e003      	b.n	1896 <outstr2+0xe>
    __write_char2__(*str);
    188e:	4b04      	ldr	r3, [pc, #16]	@ (18a0 <outstr2+0x18>)
    1890:	681b      	ldr	r3, [r3, #0]
    1892:	4798      	blx	r3
    str++;
    1894:	3401      	adds	r4, #1
  while (*str != '\0') {
    1896:	7820      	ldrb	r0, [r4, #0]
    1898:	2800      	cmp	r0, #0
    189a:	d1f8      	bne.n	188e <outstr2+0x6>
  }
}
    189c:	bd10      	pop	{r4, pc}
    189e:	bf00      	nop
    18a0:	20000170 	andcs	r0, r0, r0, ror r1

000018a4 <printf2_numbers>:

static bool printf2_numbers(const char fmt, va_list *args, int l_count) {
    18a4:	b530      	push	{r4, r5, lr}
    18a6:	b085      	sub	sp, #20
    18a8:	4614      	mov	r4, r2
  char num[MAX_DIGITS];
  int num_len = 0;

  switch (fmt) {
    18aa:	2864      	cmp	r0, #100	@ 0x64
    18ac:	d01d      	beq.n	18ea <printf2_numbers+0x46>
    18ae:	d914      	bls.n	18da <printf2_numbers+0x36>
    18b0:	2875      	cmp	r0, #117	@ 0x75
    18b2:	d001      	beq.n	18b8 <printf2_numbers+0x14>
    18b4:	2878      	cmp	r0, #120	@ 0x78
    18b6:	d112      	bne.n	18de <printf2_numbers+0x3a>
#ifndef SHELL_NO_PRINTF_LL
      long long unsigned int value = 0;
#else
      unsigned int value = 0;
#endif  // SHELL_NO_PRINTF_LL
      if (l_count == 0) {
    18b8:	2c00      	cmp	r4, #0
    18ba:	f040 8086 	bne.w	19ca <printf2_numbers+0x126>
        value = va_arg(*args, unsigned int);
    18be:	680b      	ldr	r3, [r1, #0]
    18c0:	1d1a      	adds	r2, r3, #4
    18c2:	600a      	str	r2, [r1, #0]
    18c4:	681d      	ldr	r5, [r3, #0]
#endif  // SHELL_NO_PRINTF_LL
      } else {
        return false;
      }

      if (fmt == 'u') {
    18c6:	2875      	cmp	r0, #117	@ 0x75
    18c8:	d043      	beq.n	1952 <printf2_numbers+0xae>

        while (num_len > 0) {
          __write_char2__(num[--num_len]);
        };
      } else {
        if (value == 0) {
    18ca:	2d00      	cmp	r5, #0
    18cc:	d176      	bne.n	19bc <printf2_numbers+0x118>
          __write_char2__(hextable2[0]);
    18ce:	4b40      	ldr	r3, [pc, #256]	@ (19d0 <printf2_numbers+0x12c>)
    18d0:	681b      	ldr	r3, [r3, #0]
    18d2:	2030      	movs	r0, #48	@ 0x30
    18d4:	4798      	blx	r3
    }
    default:
      outstr2("\nprintf2-error\n");
      return false;
  }
  return true;
    18d6:	2001      	movs	r0, #1
    18d8:	e005      	b.n	18e6 <printf2_numbers+0x42>
  switch (fmt) {
    18da:	2858      	cmp	r0, #88	@ 0x58
    18dc:	d0ec      	beq.n	18b8 <printf2_numbers+0x14>
      outstr2("\nprintf2-error\n");
    18de:	483d      	ldr	r0, [pc, #244]	@ (19d4 <printf2_numbers+0x130>)
    18e0:	f7ff ffd2 	bl	1888 <outstr2>
      return false;
    18e4:	2000      	movs	r0, #0
}
    18e6:	b005      	add	sp, #20
    18e8:	bd30      	pop	{r4, r5, pc}
      if (l_count == 0) {
    18ea:	2a00      	cmp	r2, #0
    18ec:	d16b      	bne.n	19c6 <printf2_numbers+0x122>
        value = va_arg(*args, int);
    18ee:	680b      	ldr	r3, [r1, #0]
    18f0:	1d1a      	adds	r2, r3, #4
    18f2:	600a      	str	r2, [r1, #0]
    18f4:	681d      	ldr	r5, [r3, #0]
      if (value < 0) {
    18f6:	2d00      	cmp	r5, #0
    18f8:	db17      	blt.n	192a <printf2_numbers+0x86>
        num[num_len++] = hextable2[value % 10];
    18fa:	4a37      	ldr	r2, [pc, #220]	@ (19d8 <printf2_numbers+0x134>)
    18fc:	fb82 3205 	smull	r3, r2, r2, r5
    1900:	17eb      	asrs	r3, r5, #31
    1902:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
    1906:	4619      	mov	r1, r3
    1908:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    190c:	eba5 0343 	sub.w	r3, r5, r3, lsl #1
    1910:	4832      	ldr	r0, [pc, #200]	@ (19dc <printf2_numbers+0x138>)
    1912:	5cc0      	ldrb	r0, [r0, r3]
    1914:	4623      	mov	r3, r4
    1916:	3310      	adds	r3, #16
    1918:	446b      	add	r3, sp
    191a:	3401      	adds	r4, #1
    191c:	f803 0c0c 	strb.w	r0, [r3, #-12]
        value = value / 10;
    1920:	462b      	mov	r3, r5
    1922:	460d      	mov	r5, r1
      } while (value > 0);
    1924:	2b09      	cmp	r3, #9
    1926:	dce8      	bgt.n	18fa <printf2_numbers+0x56>
    1928:	e00f      	b.n	194a <printf2_numbers+0xa6>
        __write_char2__('-');
    192a:	4b29      	ldr	r3, [pc, #164]	@ (19d0 <printf2_numbers+0x12c>)
    192c:	681b      	ldr	r3, [r3, #0]
    192e:	202d      	movs	r0, #45	@ 0x2d
    1930:	4798      	blx	r3
        value = -value;
    1932:	426d      	negs	r5, r5
    1934:	e7e1      	b.n	18fa <printf2_numbers+0x56>
        __write_char2__(num[--num_len]);
    1936:	3c01      	subs	r4, #1
    1938:	f104 0310 	add.w	r3, r4, #16
    193c:	eb0d 0203 	add.w	r2, sp, r3
    1940:	4b23      	ldr	r3, [pc, #140]	@ (19d0 <printf2_numbers+0x12c>)
    1942:	681b      	ldr	r3, [r3, #0]
    1944:	f812 0c0c 	ldrb.w	r0, [r2, #-12]
    1948:	4798      	blx	r3
      while (num_len > 0) {
    194a:	2c00      	cmp	r4, #0
    194c:	dcf3      	bgt.n	1936 <printf2_numbers+0x92>
  return true;
    194e:	2001      	movs	r0, #1
    1950:	e7c9      	b.n	18e6 <printf2_numbers+0x42>
          num[num_len++] = hextable2[value % 10];
    1952:	4b23      	ldr	r3, [pc, #140]	@ (19e0 <printf2_numbers+0x13c>)
    1954:	fba3 2305 	umull	r2, r3, r3, r5
    1958:	08db      	lsrs	r3, r3, #3
    195a:	4619      	mov	r1, r3
    195c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    1960:	eba5 0343 	sub.w	r3, r5, r3, lsl #1
    1964:	481d      	ldr	r0, [pc, #116]	@ (19dc <printf2_numbers+0x138>)
    1966:	5cc0      	ldrb	r0, [r0, r3]
    1968:	4623      	mov	r3, r4
    196a:	3310      	adds	r3, #16
    196c:	446b      	add	r3, sp
    196e:	3401      	adds	r4, #1
    1970:	f803 0c0c 	strb.w	r0, [r3, #-12]
          value = value / 10;
    1974:	462b      	mov	r3, r5
    1976:	460d      	mov	r5, r1
        } while (value > 0);
    1978:	2b09      	cmp	r3, #9
    197a:	d8ea      	bhi.n	1952 <printf2_numbers+0xae>
        while (num_len > 0) {
    197c:	2c00      	cmp	r4, #0
    197e:	dd0a      	ble.n	1996 <printf2_numbers+0xf2>
          __write_char2__(num[--num_len]);
    1980:	3c01      	subs	r4, #1
    1982:	f104 0310 	add.w	r3, r4, #16
    1986:	eb0d 0203 	add.w	r2, sp, r3
    198a:	4b11      	ldr	r3, [pc, #68]	@ (19d0 <printf2_numbers+0x12c>)
    198c:	681b      	ldr	r3, [r3, #0]
    198e:	f812 0c0c 	ldrb.w	r0, [r2, #-12]
    1992:	4798      	blx	r3
    1994:	e7f2      	b.n	197c <printf2_numbers+0xd8>
  return true;
    1996:	2001      	movs	r0, #1
    1998:	e7a5      	b.n	18e6 <printf2_numbers+0x42>
              __write_char2__(hextable2[val]);
    199a:	4a0d      	ldr	r2, [pc, #52]	@ (19d0 <printf2_numbers+0x12c>)
    199c:	6812      	ldr	r2, [r2, #0]
    199e:	490f      	ldr	r1, [pc, #60]	@ (19dc <printf2_numbers+0x138>)
    19a0:	5cc8      	ldrb	r0, [r1, r3]
    19a2:	4790      	blx	r2
              leading_zero_ignored = true;
    19a4:	2201      	movs	r2, #1
            start_bit -= 4;
    19a6:	3c04      	subs	r4, #4
          while (start_bit >= 0) {
    19a8:	2c00      	cmp	r4, #0
    19aa:	db0a      	blt.n	19c2 <printf2_numbers+0x11e>
            int val = (value >> start_bit) & 0xF;
    19ac:	fa25 f304 	lsr.w	r3, r5, r4
            if (val || leading_zero_ignored) {
    19b0:	f013 030f 	ands.w	r3, r3, #15
    19b4:	d1f1      	bne.n	199a <printf2_numbers+0xf6>
    19b6:	2a00      	cmp	r2, #0
    19b8:	d0f5      	beq.n	19a6 <printf2_numbers+0x102>
    19ba:	e7ee      	b.n	199a <printf2_numbers+0xf6>
          bool leading_zero_ignored = false;
    19bc:	2200      	movs	r2, #0
          int start_bit = LAST_NIBBLE_FIRST_BIT;
    19be:	241c      	movs	r4, #28
    19c0:	e7f2      	b.n	19a8 <printf2_numbers+0x104>
  return true;
    19c2:	2001      	movs	r0, #1
    19c4:	e78f      	b.n	18e6 <printf2_numbers+0x42>
        return false;
    19c6:	2000      	movs	r0, #0
    19c8:	e78d      	b.n	18e6 <printf2_numbers+0x42>
        return false;
    19ca:	2000      	movs	r0, #0
    19cc:	e78b      	b.n	18e6 <printf2_numbers+0x42>
    19ce:	bf00      	nop
    19d0:	20000170 	andcs	r0, r0, r0, ror r1
    19d4:	0000338c 	andeq	r3, r0, ip, lsl #7
    19d8:	66666667 	strbtvs	r6, [r6], -r7, ror #12
    19dc:	0000339c 	muleq	r0, ip, r3
    19e0:	cccccccd 	stclgt	12, cr12, [ip], {205}	@ 0xcd

000019e4 <printf2>:

int printf2(const char *fmt, ...) {
    19e4:	b40f      	push	{r0, r1, r2, r3}
    19e6:	b530      	push	{r4, r5, lr}
    19e8:	b083      	sub	sp, #12
    19ea:	ab06      	add	r3, sp, #24
    19ec:	f853 4b04 	ldr.w	r4, [r3], #4
  printf2_state state = CHECK_CH;
  va_list args;

  va_start(args, fmt);
    19f0:	9301      	str	r3, [sp, #4]
  printf2_state state = CHECK_CH;
    19f2:	2500      	movs	r5, #0

  while (*fmt) {
    19f4:	e005      	b.n	1a02 <printf2+0x1e>
    switch (state) {
      case CHECK_CH: {
        if (*fmt == '%') {
    19f6:	2825      	cmp	r0, #37	@ 0x25
    19f8:	d00a      	beq.n	1a10 <printf2+0x2c>
          state = PARSE_FMT_STR;
          fmt++;
          continue;
        }
        __write_char2__(*fmt);
    19fa:	4b30      	ldr	r3, [pc, #192]	@ (1abc <printf2+0xd8>)
    19fc:	681b      	ldr	r3, [r3, #0]
    19fe:	4798      	blx	r3
        fmt++;
    1a00:	3401      	adds	r4, #1
  while (*fmt) {
    1a02:	7820      	ldrb	r0, [r4, #0]
    1a04:	2800      	cmp	r0, #0
    1a06:	d050      	beq.n	1aaa <printf2+0xc6>
    switch (state) {
    1a08:	2d00      	cmp	r5, #0
    1a0a:	d0f4      	beq.n	19f6 <printf2+0x12>
    1a0c:	b925      	cbnz	r5, 1a18 <printf2+0x34>
    1a0e:	e7f8      	b.n	1a02 <printf2+0x1e>
          fmt++;
    1a10:	3401      	adds	r4, #1
          state = PARSE_FMT_STR;
    1a12:	2501      	movs	r5, #1
          continue;
    1a14:	e7f5      	b.n	1a02 <printf2+0x1e>
        break;
      }
      case PARSE_FMT_STR: {
        // Support only basic format specifiers
        while (*fmt && ((*fmt >= '0' && *fmt <= '9') || *fmt == '-')) {
          fmt++;
    1a16:	3401      	adds	r4, #1
        while (*fmt && ((*fmt >= '0' && *fmt <= '9') || *fmt == '-')) {
    1a18:	7820      	ldrb	r0, [r4, #0]
    1a1a:	b130      	cbz	r0, 1a2a <printf2+0x46>
    1a1c:	f1a0 0330 	sub.w	r3, r0, #48	@ 0x30
    1a20:	b2db      	uxtb	r3, r3
    1a22:	2b09      	cmp	r3, #9
    1a24:	d9f7      	bls.n	1a16 <printf2+0x32>
    1a26:	282d      	cmp	r0, #45	@ 0x2d
    1a28:	d0f5      	beq.n	1a16 <printf2+0x32>
        }

        switch (*fmt) {
    1a2a:	2863      	cmp	r0, #99	@ 0x63
    1a2c:	d019      	beq.n	1a62 <printf2+0x7e>
    1a2e:	d80b      	bhi.n	1a48 <printf2+0x64>
    1a30:	2843      	cmp	r0, #67	@ 0x43
    1a32:	d016      	beq.n	1a62 <printf2+0x7e>
    1a34:	2853      	cmp	r0, #83	@ 0x53
    1a36:	d00b      	beq.n	1a50 <printf2+0x6c>
    1a38:	2825      	cmp	r0, #37	@ 0x25
    1a3a:	d12c      	bne.n	1a96 <printf2+0xb2>
          case '%':
            __write_char2__(*fmt);
    1a3c:	4b1f      	ldr	r3, [pc, #124]	@ (1abc <printf2+0xd8>)
    1a3e:	681b      	ldr	r3, [r3, #0]
    1a40:	4798      	blx	r3
            fmt++;
    1a42:	3401      	adds	r4, #1
            state = CHECK_CH;
    1a44:	2500      	movs	r5, #0
            break;
    1a46:	e7dc      	b.n	1a02 <printf2+0x1e>
    1a48:	286c      	cmp	r0, #108	@ 0x6c
    1a4a:	d014      	beq.n	1a76 <printf2+0x92>
    1a4c:	2873      	cmp	r0, #115	@ 0x73
    1a4e:	d122      	bne.n	1a96 <printf2+0xb2>
            fmt++;
            state = CHECK_CH;
            break;
          case 's':
          case 'S':
            outstr2(va_arg(args, const char *));
    1a50:	9b01      	ldr	r3, [sp, #4]
    1a52:	1d1a      	adds	r2, r3, #4
    1a54:	9201      	str	r2, [sp, #4]
    1a56:	6818      	ldr	r0, [r3, #0]
    1a58:	f7ff ff16 	bl	1888 <outstr2>
            fmt++;
    1a5c:	3401      	adds	r4, #1
            state = CHECK_CH;
    1a5e:	2500      	movs	r5, #0
            break;
    1a60:	e7cf      	b.n	1a02 <printf2+0x1e>
            __write_char2__(va_arg(args, int));
    1a62:	4b16      	ldr	r3, [pc, #88]	@ (1abc <printf2+0xd8>)
    1a64:	681a      	ldr	r2, [r3, #0]
    1a66:	9b01      	ldr	r3, [sp, #4]
    1a68:	1d19      	adds	r1, r3, #4
    1a6a:	9101      	str	r1, [sp, #4]
    1a6c:	7818      	ldrb	r0, [r3, #0]
    1a6e:	4790      	blx	r2
            fmt++;
    1a70:	3401      	adds	r4, #1
            state = CHECK_CH;
    1a72:	2500      	movs	r5, #0
            break;
    1a74:	e7c5      	b.n	1a02 <printf2+0x1e>
          case 'l': {
            int l_count = 1;
            fmt++;
    1a76:	1c65      	adds	r5, r4, #1
            if (*fmt == 'l') {
    1a78:	7863      	ldrb	r3, [r4, #1]
    1a7a:	2b6c      	cmp	r3, #108	@ 0x6c
    1a7c:	d008      	beq.n	1a90 <printf2+0xac>
            int l_count = 1;
    1a7e:	2201      	movs	r2, #1
              l_count++;
              fmt++;
            }
            if (printf2_numbers(*fmt, &args, l_count)) {
    1a80:	a901      	add	r1, sp, #4
    1a82:	7828      	ldrb	r0, [r5, #0]
    1a84:	f7ff ff0e 	bl	18a4 <printf2_numbers>
    1a88:	b168      	cbz	r0, 1aa6 <printf2+0xc2>
              state = CHECK_CH;
              fmt++;
    1a8a:	1c6c      	adds	r4, r5, #1
              state = CHECK_CH;
    1a8c:	2500      	movs	r5, #0
              break;
    1a8e:	e7b8      	b.n	1a02 <printf2+0x1e>
              fmt++;
    1a90:	1ca5      	adds	r5, r4, #2
              l_count++;
    1a92:	2202      	movs	r2, #2
    1a94:	e7f4      	b.n	1a80 <printf2+0x9c>
            }
            return -1;
          }
          default: {
            if (printf2_numbers(*fmt, &args, 0)) {
    1a96:	2200      	movs	r2, #0
    1a98:	a901      	add	r1, sp, #4
    1a9a:	f7ff ff03 	bl	18a4 <printf2_numbers>
    1a9e:	b148      	cbz	r0, 1ab4 <printf2+0xd0>
              state = CHECK_CH;
              fmt++;
    1aa0:	3401      	adds	r4, #1
              state = CHECK_CH;
    1aa2:	2500      	movs	r5, #0
              break;
    1aa4:	e7ad      	b.n	1a02 <printf2+0x1e>
            return -1;
    1aa6:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    }
  }

  va_end(args);
  return 0;
}
    1aaa:	b003      	add	sp, #12
    1aac:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    1ab0:	b004      	add	sp, #16
    1ab2:	4770      	bx	lr
            return -1;
    1ab4:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    1ab8:	e7f7      	b.n	1aaa <printf2+0xc6>
    1aba:	bf00      	nop
    1abc:	20000170 	andcs	r0, r0, r0, ror r1

00001ac0 <r32>:
/*
 * Memory manipulation utilities can be skipped to reduce
 * final binary size. Skip if SHELL_NO_UTILS is defined.
 */
#ifndef SHELL_NO_UTILS
int r32(int argc, char *argv[]) {
    1ac0:	b508      	push	{r3, lr}
  if (argc < 2) {
    1ac2:	2801      	cmp	r0, #1
    1ac4:	dd09      	ble.n	1ada <r32+0x1a>
    printf("Usage: %s <address> (in hex)\n", argv[0]);
    return -1;
  }

  uint32_t addr = atoh(argv[1]);
    1ac6:	6848      	ldr	r0, [r1, #4]
    1ac8:	f000 fe77 	bl	27ba <atoh>
    1acc:	4601      	mov	r1, r0
  uint32_t data;

  data = reg32(addr);
    1ace:	6802      	ldr	r2, [r0, #0]

  printf("0x%x: 0x%x\n", addr, data);
    1ad0:	4805      	ldr	r0, [pc, #20]	@ (1ae8 <r32+0x28>)
    1ad2:	f7ff fe6b 	bl	17ac <printf>
  return 0;
    1ad6:	2000      	movs	r0, #0
}
    1ad8:	bd08      	pop	{r3, pc}
    printf("Usage: %s <address> (in hex)\n", argv[0]);
    1ada:	6809      	ldr	r1, [r1, #0]
    1adc:	4803      	ldr	r0, [pc, #12]	@ (1aec <r32+0x2c>)
    1ade:	f7ff fe65 	bl	17ac <printf>
    return -1;
    1ae2:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    1ae6:	e7f7      	b.n	1ad8 <r32+0x18>
    1ae8:	000033cc 	andeq	r3, r0, ip, asr #7
    1aec:	000033ac 	andeq	r3, r0, ip, lsr #7

00001af0 <w32>:

int w32(int argc, char *argv[]) {
    1af0:	b538      	push	{r3, r4, r5, lr}
    1af2:	460c      	mov	r4, r1
  if (argc < 3) {
    1af4:	2802      	cmp	r0, #2
    1af6:	dd09      	ble.n	1b0c <w32+0x1c>
    printf("Usage: %s <address> (in hex) <value> (in hex)\n", argv[0]);
    return -1;
  }
  uint32_t addr = atoh(argv[1]);
    1af8:	6848      	ldr	r0, [r1, #4]
    1afa:	f000 fe5e 	bl	27ba <atoh>
    1afe:	4605      	mov	r5, r0
  uint32_t data = atoh(argv[2]);
    1b00:	68a0      	ldr	r0, [r4, #8]
    1b02:	f000 fe5a 	bl	27ba <atoh>
  reg32(addr) = data;
    1b06:	6028      	str	r0, [r5, #0]

  return 0;
    1b08:	2000      	movs	r0, #0
}
    1b0a:	bd38      	pop	{r3, r4, r5, pc}
    printf("Usage: %s <address> (in hex) <value> (in hex)\n", argv[0]);
    1b0c:	6809      	ldr	r1, [r1, #0]
    1b0e:	4803      	ldr	r0, [pc, #12]	@ (1b1c <w32+0x2c>)
    1b10:	f7ff fe4c 	bl	17ac <printf>
    return -1;
    1b14:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    1b18:	e7f7      	b.n	1b0a <w32+0x1a>
    1b1a:	bf00      	nop
    1b1c:	000033d8 	ldrdeq	r3, [r0], -r8

00001b20 <read_mem>:

int read_mem(int argc, char *argv[]) {
    1b20:	b570      	push	{r4, r5, r6, lr}
    1b22:	460d      	mov	r5, r1
  if (argc < 3) {
    1b24:	2802      	cmp	r0, #2
    1b26:	dd09      	ble.n	1b3c <read_mem+0x1c>
    printf("Usage: %s <address> (in hex) <num_words> (in decimal)\n", argv[0]);
    return -1;
  }

  uint32_t addr = atoh(argv[1]);
    1b28:	6848      	ldr	r0, [r1, #4]
    1b2a:	f000 fe46 	bl	27ba <atoh>
    1b2e:	4604      	mov	r4, r0
  uint32_t length = atoi(argv[2]);
    1b30:	68a8      	ldr	r0, [r5, #8]
    1b32:	f000 fe33 	bl	279c <atoi>
    1b36:	4606      	mov	r6, r0

  for (uint32_t i = 0, data = 0; i < length; i++) {
    1b38:	2500      	movs	r5, #0
    1b3a:	e00d      	b.n	1b58 <read_mem+0x38>
    printf("Usage: %s <address> (in hex) <num_words> (in decimal)\n", argv[0]);
    1b3c:	6809      	ldr	r1, [r1, #0]
    1b3e:	4808      	ldr	r0, [pc, #32]	@ (1b60 <read_mem+0x40>)
    1b40:	f7ff fe34 	bl	17ac <printf>
    return -1;
    1b44:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    1b48:	e009      	b.n	1b5e <read_mem+0x3e>
    data = reg32(addr);
    1b4a:	6822      	ldr	r2, [r4, #0]
    printf("0x%x: 0x%x\n", addr, data);
    1b4c:	4621      	mov	r1, r4
    1b4e:	4805      	ldr	r0, [pc, #20]	@ (1b64 <read_mem+0x44>)
    1b50:	f7ff fe2c 	bl	17ac <printf>

    addr += 4;
    1b54:	3404      	adds	r4, #4
  for (uint32_t i = 0, data = 0; i < length; i++) {
    1b56:	3501      	adds	r5, #1
    1b58:	42b5      	cmp	r5, r6
    1b5a:	d3f6      	bcc.n	1b4a <read_mem+0x2a>
  }

  return 0;
    1b5c:	2000      	movs	r0, #0
}
    1b5e:	bd70      	pop	{r4, r5, r6, pc}
    1b60:	00003408 	andeq	r3, r0, r8, lsl #8
    1b64:	000033cc 	andeq	r3, r0, ip, asr #7

00001b68 <w32_bit>:

#ifndef SHELL_NO_BIT_UTILS
int w32_bit(int argc, char *argv[])
{
    1b68:	b570      	push	{r4, r5, r6, lr}
    1b6a:	460c      	mov	r4, r1
  if (argc < 4) {
    1b6c:	2803      	cmp	r0, #3
    1b6e:	dd22      	ble.n	1bb6 <w32_bit+0x4e>
    goto usage;
  }

  uint32_t addr = atoh(argv[1]);
    1b70:	6848      	ldr	r0, [r1, #4]
    1b72:	f000 fe22 	bl	27ba <atoh>
    1b76:	4606      	mov	r6, r0
  uint32_t bit_loc = atoi(argv[2]);
    1b78:	68a0      	ldr	r0, [r4, #8]
    1b7a:	f000 fe0f 	bl	279c <atoi>
    1b7e:	4605      	mov	r5, r0
  uint32_t bit_val = atoi(argv[3]);
    1b80:	68e0      	ldr	r0, [r4, #12]
    1b82:	f000 fe0b 	bl	279c <atoi>

  if (bit_loc > 31) {
    1b86:	2d1f      	cmp	r5, #31
    1b88:	d80e      	bhi.n	1ba8 <w32_bit+0x40>
    printf("Error: Invalid bit location argument\n");
    goto usage;
  }

  if (bit_val != 0 && bit_val != 1) {
    1b8a:	2801      	cmp	r0, #1
    1b8c:	d810      	bhi.n	1bb0 <w32_bit+0x48>
    printf("Error: Invalid bit value argument\n");
    goto usage;
  }

  uint32_t data = reg32(addr);
    1b8e:	6832      	ldr	r2, [r6, #0]
  data = data | (bit_val << bit_loc);
    1b90:	fa00 f305 	lsl.w	r3, r0, r5
    1b94:	431a      	orrs	r2, r3
  data = data & ~(!bit_val << bit_loc);
    1b96:	fab0 f380 	clz	r3, r0
    1b9a:	095b      	lsrs	r3, r3, #5
    1b9c:	40ab      	lsls	r3, r5
    1b9e:	ea22 0303 	bic.w	r3, r2, r3
  reg32(addr) = data;
    1ba2:	6033      	str	r3, [r6, #0]

  return 0;
    1ba4:	2000      	movs	r0, #0
usage:
  printf("Usage: %s <address_in_hex(32-bits)> <bit_location_in_decimal(0 to 31)> <bit_value(0 or 1)>\n", argv[0]);
  return -1;
}
    1ba6:	bd70      	pop	{r4, r5, r6, pc}
    printf("Error: Invalid bit location argument\n");
    1ba8:	4806      	ldr	r0, [pc, #24]	@ (1bc4 <w32_bit+0x5c>)
    1baa:	f7ff fdff 	bl	17ac <printf>
    goto usage;
    1bae:	e002      	b.n	1bb6 <w32_bit+0x4e>
    printf("Error: Invalid bit value argument\n");
    1bb0:	4805      	ldr	r0, [pc, #20]	@ (1bc8 <w32_bit+0x60>)
    1bb2:	f7ff fdfb 	bl	17ac <printf>
  printf("Usage: %s <address_in_hex(32-bits)> <bit_location_in_decimal(0 to 31)> <bit_value(0 or 1)>\n", argv[0]);
    1bb6:	6821      	ldr	r1, [r4, #0]
    1bb8:	4804      	ldr	r0, [pc, #16]	@ (1bcc <w32_bit+0x64>)
    1bba:	f7ff fdf7 	bl	17ac <printf>
  return -1;
    1bbe:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    1bc2:	e7f0      	b.n	1ba6 <w32_bit+0x3e>
    1bc4:	00003440 	andeq	r3, r0, r0, asr #8
    1bc8:	00003468 	andeq	r3, r0, r8, ror #8
    1bcc:	0000348c 	andeq	r3, r0, ip, lsl #9

00001bd0 <r32_bit>:

int r32_bit(int argc, char *argv[])
{
    1bd0:	b538      	push	{r3, r4, r5, lr}
    1bd2:	460c      	mov	r4, r1
  if (argc < 3) {
    1bd4:	2802      	cmp	r0, #2
    1bd6:	dd16      	ble.n	1c06 <r32_bit+0x36>
    goto usage;
  }

  uint32_t addr = atoh(argv[1]);
    1bd8:	6848      	ldr	r0, [r1, #4]
    1bda:	f000 fdee 	bl	27ba <atoh>
    1bde:	4605      	mov	r5, r0
  uint32_t bit_loc = atoi(argv[2]);
    1be0:	68a0      	ldr	r0, [r4, #8]
    1be2:	f000 fddb 	bl	279c <atoi>
    1be6:	4601      	mov	r1, r0

  if (bit_loc > 31) {
    1be8:	281f      	cmp	r0, #31
    1bea:	d809      	bhi.n	1c00 <r32_bit+0x30>
    printf("Error: Invalid bit location argument\n");
    goto usage;
  }

  uint32_t data = reg32(addr);
    1bec:	682b      	ldr	r3, [r5, #0]
  uint32_t bit_val = (data >> bit_loc) & 0x1;
    1bee:	40c3      	lsrs	r3, r0
  printf("Bit %u @ 0x%08x: %u\n", bit_loc, addr, bit_val);
    1bf0:	f003 0301 	and.w	r3, r3, #1
    1bf4:	462a      	mov	r2, r5
    1bf6:	4807      	ldr	r0, [pc, #28]	@ (1c14 <r32_bit+0x44>)
    1bf8:	f7ff fdd8 	bl	17ac <printf>
  return 0;
    1bfc:	2000      	movs	r0, #0

usage:
  printf("Usage: %s <address_in_hex(32-bits)> <bit_location_in_decimal(0 to 31)\n", argv[0]);
  return -1;
}
    1bfe:	bd38      	pop	{r3, r4, r5, pc}
    printf("Error: Invalid bit location argument\n");
    1c00:	4805      	ldr	r0, [pc, #20]	@ (1c18 <r32_bit+0x48>)
    1c02:	f7ff fdd3 	bl	17ac <printf>
  printf("Usage: %s <address_in_hex(32-bits)> <bit_location_in_decimal(0 to 31)\n", argv[0]);
    1c06:	6821      	ldr	r1, [r4, #0]
    1c08:	4804      	ldr	r0, [pc, #16]	@ (1c1c <r32_bit+0x4c>)
    1c0a:	f7ff fdcf 	bl	17ac <printf>
  return -1;
    1c0e:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    1c12:	e7f4      	b.n	1bfe <r32_bit+0x2e>
    1c14:	000034e8 	andeq	r3, r0, r8, ror #9
    1c18:	00003440 	andeq	r3, r0, r0, asr #8
    1c1c:	00003500 	andeq	r3, r0, r0, lsl #10

00001c20 <KeyExpansion>:
*/
#define getSBoxValue(num) (sbox[(num)])

// This function produces Nb(Nr+1) round keys. The round keys are used in each round to decrypt the states. 
static void KeyExpansion(uint8_t* RoundKey, const uint8_t* Key)
{
    1c20:	b530      	push	{r4, r5, lr}
    1c22:	b083      	sub	sp, #12
  unsigned i, j, k;
  uint8_t tempa[4]; // Used for the column/row operations
  
  // The first round key is the key itself.
  for (i = 0; i < Nk; ++i)
    1c24:	2200      	movs	r2, #0
    1c26:	e00e      	b.n	1c46 <KeyExpansion+0x26>
  {
    RoundKey[(i * 4) + 0] = Key[(i * 4) + 0];
    1c28:	0093      	lsls	r3, r2, #2
    1c2a:	f811 4022 	ldrb.w	r4, [r1, r2, lsl #2]
    1c2e:	f800 4022 	strb.w	r4, [r0, r2, lsl #2]
    RoundKey[(i * 4) + 1] = Key[(i * 4) + 1];
    1c32:	1c5c      	adds	r4, r3, #1
    1c34:	5d0d      	ldrb	r5, [r1, r4]
    1c36:	5505      	strb	r5, [r0, r4]
    RoundKey[(i * 4) + 2] = Key[(i * 4) + 2];
    1c38:	1c9c      	adds	r4, r3, #2
    1c3a:	5d0d      	ldrb	r5, [r1, r4]
    1c3c:	5505      	strb	r5, [r0, r4]
    RoundKey[(i * 4) + 3] = Key[(i * 4) + 3];
    1c3e:	3303      	adds	r3, #3
    1c40:	5ccc      	ldrb	r4, [r1, r3]
    1c42:	54c4      	strb	r4, [r0, r3]
  for (i = 0; i < Nk; ++i)
    1c44:	3201      	adds	r2, #1
    1c46:	2a07      	cmp	r2, #7
    1c48:	d9ee      	bls.n	1c28 <KeyExpansion+0x8>
  }

  // All other round keys are found from the previous round keys.
  for (i = Nk; i < Nb * (Nr + 1); ++i)
    1c4a:	2308      	movs	r3, #8
    1c4c:	e027      	b.n	1c9e <KeyExpansion+0x7e>
      }

      tempa[0] = tempa[0] ^ Rcon[i/Nk];
    }
#if defined(AES256) && (AES256 == 1)
    if (i % Nk == 4)
    1c4e:	2d04      	cmp	r5, #4
    1c50:	d05b      	beq.n	1d0a <KeyExpansion+0xea>
        tempa[2] = getSBoxValue(tempa[2]);
        tempa[3] = getSBoxValue(tempa[3]);
      }
    }
#endif
    j = i * 4; k=(i - Nk) * 4;
    1c52:	0099      	lsls	r1, r3, #2
    1c54:	f1a3 0208 	sub.w	r2, r3, #8
    RoundKey[j + 0] = RoundKey[k + 0] ^ tempa[0];
    1c58:	f810 c022 	ldrb.w	ip, [r0, r2, lsl #2]
    1c5c:	f89d 4004 	ldrb.w	r4, [sp, #4]
    1c60:	ea8c 0c04 	eor.w	ip, ip, r4
    1c64:	f800 c023 	strb.w	ip, [r0, r3, lsl #2]
    RoundKey[j + 1] = RoundKey[k + 1] ^ tempa[1];
    1c68:	eb00 0282 	add.w	r2, r0, r2, lsl #2
    1c6c:	f892 c001 	ldrb.w	ip, [r2, #1]
    1c70:	f89d e005 	ldrb.w	lr, [sp, #5]
    1c74:	1c4c      	adds	r4, r1, #1
    1c76:	ea8c 0c0e 	eor.w	ip, ip, lr
    1c7a:	f800 c004 	strb.w	ip, [r0, r4]
    RoundKey[j + 2] = RoundKey[k + 2] ^ tempa[2];
    1c7e:	f892 c002 	ldrb.w	ip, [r2, #2]
    1c82:	f89d e006 	ldrb.w	lr, [sp, #6]
    1c86:	1c8c      	adds	r4, r1, #2
    1c88:	ea8c 0c0e 	eor.w	ip, ip, lr
    1c8c:	f800 c004 	strb.w	ip, [r0, r4]
    RoundKey[j + 3] = RoundKey[k + 3] ^ tempa[3];
    1c90:	78d2      	ldrb	r2, [r2, #3]
    1c92:	f89d 4007 	ldrb.w	r4, [sp, #7]
    1c96:	3103      	adds	r1, #3
    1c98:	4062      	eors	r2, r4
    1c9a:	5442      	strb	r2, [r0, r1]
  for (i = Nk; i < Nb * (Nr + 1); ++i)
    1c9c:	3301      	adds	r3, #1
    1c9e:	2b3b      	cmp	r3, #59	@ 0x3b
    1ca0:	d849      	bhi.n	1d36 <KeyExpansion+0x116>
      k = (i - 1) * 4;
    1ca2:	1e5a      	subs	r2, r3, #1
      tempa[0]=RoundKey[k + 0];
    1ca4:	f810 1022 	ldrb.w	r1, [r0, r2, lsl #2]
    1ca8:	f88d 1004 	strb.w	r1, [sp, #4]
      tempa[1]=RoundKey[k + 1];
    1cac:	eb00 0282 	add.w	r2, r0, r2, lsl #2
    1cb0:	7854      	ldrb	r4, [r2, #1]
    1cb2:	f88d 4005 	strb.w	r4, [sp, #5]
      tempa[2]=RoundKey[k + 2];
    1cb6:	f892 e002 	ldrb.w	lr, [r2, #2]
    1cba:	f88d e006 	strb.w	lr, [sp, #6]
      tempa[3]=RoundKey[k + 3];
    1cbe:	f892 c003 	ldrb.w	ip, [r2, #3]
    1cc2:	f88d c007 	strb.w	ip, [sp, #7]
    if (i % Nk == 0)
    1cc6:	f013 0507 	ands.w	r5, r3, #7
    1cca:	d1c0      	bne.n	1c4e <KeyExpansion+0x2e>
        tempa[0] = tempa[1];
    1ccc:	f88d 4004 	strb.w	r4, [sp, #4]
        tempa[1] = tempa[2];
    1cd0:	f88d e005 	strb.w	lr, [sp, #5]
        tempa[2] = tempa[3];
    1cd4:	f88d c006 	strb.w	ip, [sp, #6]
        tempa[3] = u8tmp;
    1cd8:	f88d 1007 	strb.w	r1, [sp, #7]
        tempa[0] = getSBoxValue(tempa[0]);
    1cdc:	4a17      	ldr	r2, [pc, #92]	@ (1d3c <KeyExpansion+0x11c>)
    1cde:	5d14      	ldrb	r4, [r2, r4]
    1ce0:	f88d 4004 	strb.w	r4, [sp, #4]
        tempa[1] = getSBoxValue(tempa[1]);
    1ce4:	f812 e00e 	ldrb.w	lr, [r2, lr]
    1ce8:	f88d e005 	strb.w	lr, [sp, #5]
        tempa[2] = getSBoxValue(tempa[2]);
    1cec:	f812 c00c 	ldrb.w	ip, [r2, ip]
    1cf0:	f88d c006 	strb.w	ip, [sp, #6]
        tempa[3] = getSBoxValue(tempa[3]);
    1cf4:	5c51      	ldrb	r1, [r2, r1]
    1cf6:	f88d 1007 	strb.w	r1, [sp, #7]
      tempa[0] = tempa[0] ^ Rcon[i/Nk];
    1cfa:	eb02 02d3 	add.w	r2, r2, r3, lsr #3
    1cfe:	f892 2100 	ldrb.w	r2, [r2, #256]	@ 0x100
    1d02:	4054      	eors	r4, r2
    1d04:	f88d 4004 	strb.w	r4, [sp, #4]
    1d08:	e7a1      	b.n	1c4e <KeyExpansion+0x2e>
        tempa[0] = getSBoxValue(tempa[0]);
    1d0a:	f89d 1004 	ldrb.w	r1, [sp, #4]
    1d0e:	4a0b      	ldr	r2, [pc, #44]	@ (1d3c <KeyExpansion+0x11c>)
    1d10:	5c51      	ldrb	r1, [r2, r1]
    1d12:	f88d 1004 	strb.w	r1, [sp, #4]
        tempa[1] = getSBoxValue(tempa[1]);
    1d16:	f89d 1005 	ldrb.w	r1, [sp, #5]
    1d1a:	5c51      	ldrb	r1, [r2, r1]
    1d1c:	f88d 1005 	strb.w	r1, [sp, #5]
        tempa[2] = getSBoxValue(tempa[2]);
    1d20:	f89d 1006 	ldrb.w	r1, [sp, #6]
    1d24:	5c51      	ldrb	r1, [r2, r1]
    1d26:	f88d 1006 	strb.w	r1, [sp, #6]
        tempa[3] = getSBoxValue(tempa[3]);
    1d2a:	f89d 1007 	ldrb.w	r1, [sp, #7]
    1d2e:	5c52      	ldrb	r2, [r2, r1]
    1d30:	f88d 2007 	strb.w	r2, [sp, #7]
    1d34:	e78d      	b.n	1c52 <KeyExpansion+0x32>
  }
}
    1d36:	b003      	add	sp, #12
    1d38:	bd30      	pop	{r4, r5, pc}
    1d3a:	bf00      	nop
    1d3c:	00003614 	andeq	r3, r0, r4, lsl r6

00001d40 <AddRoundKey>:
#endif

// This function adds the round key to state.
// The round key is added to the state by an XOR function.
static void AddRoundKey(uint8_t round, state_t* state, const uint8_t* RoundKey)
{
    1d40:	b530      	push	{r4, r5, lr}
  uint8_t i,j;
  for (i = 0; i < 4; ++i)
    1d42:	2400      	movs	r4, #0
    1d44:	e013      	b.n	1d6e <AddRoundKey+0x2e>
  {
    for (j = 0; j < 4; ++j)
    {
      (*state)[i][j] ^= RoundKey[(round * Nb * 4) + (i * Nb) + j];
    1d46:	eb01 0584 	add.w	r5, r1, r4, lsl #2
    1d4a:	f815 c003 	ldrb.w	ip, [r5, r3]
    1d4e:	eb04 0e80 	add.w	lr, r4, r0, lsl #2
    1d52:	eb03 0e8e 	add.w	lr, r3, lr, lsl #2
    1d56:	f812 e00e 	ldrb.w	lr, [r2, lr]
    1d5a:	ea8c 0c0e 	eor.w	ip, ip, lr
    1d5e:	f805 c003 	strb.w	ip, [r5, r3]
    for (j = 0; j < 4; ++j)
    1d62:	3301      	adds	r3, #1
    1d64:	b2db      	uxtb	r3, r3
    1d66:	2b03      	cmp	r3, #3
    1d68:	d9ed      	bls.n	1d46 <AddRoundKey+0x6>
  for (i = 0; i < 4; ++i)
    1d6a:	3401      	adds	r4, #1
    1d6c:	b2e4      	uxtb	r4, r4
    1d6e:	2c03      	cmp	r4, #3
    1d70:	d801      	bhi.n	1d76 <AddRoundKey+0x36>
    for (j = 0; j < 4; ++j)
    1d72:	2300      	movs	r3, #0
    1d74:	e7f7      	b.n	1d66 <AddRoundKey+0x26>
    }
  }
}
    1d76:	bd30      	pop	{r4, r5, pc}

00001d78 <SubBytes>:
// The SubBytes Function Substitutes the values in the
// state matrix with values in an S-box.
static void SubBytes(state_t* state)
{
  uint8_t i, j;
  for (i = 0; i < 4; ++i)
    1d78:	2200      	movs	r2, #0
    1d7a:	2a03      	cmp	r2, #3
    1d7c:	d81b      	bhi.n	1db6 <SubBytes+0x3e>
  {
    for (j = 0; j < 4; ++j)
    1d7e:	2300      	movs	r3, #0
    1d80:	2b03      	cmp	r3, #3
    1d82:	d815      	bhi.n	1db0 <SubBytes+0x38>
{
    1d84:	b410      	push	{r4}
    {
      (*state)[j][i] = getSBoxValue((*state)[j][i]);
    1d86:	eb00 0183 	add.w	r1, r0, r3, lsl #2
    1d8a:	f811 c002 	ldrb.w	ip, [r1, r2]
    1d8e:	4c0a      	ldr	r4, [pc, #40]	@ (1db8 <SubBytes+0x40>)
    1d90:	f814 c00c 	ldrb.w	ip, [r4, ip]
    1d94:	f801 c002 	strb.w	ip, [r1, r2]
    for (j = 0; j < 4; ++j)
    1d98:	3301      	adds	r3, #1
    1d9a:	b2db      	uxtb	r3, r3
    1d9c:	2b03      	cmp	r3, #3
    1d9e:	d9f2      	bls.n	1d86 <SubBytes+0xe>
  for (i = 0; i < 4; ++i)
    1da0:	3201      	adds	r2, #1
    1da2:	b2d2      	uxtb	r2, r2
    1da4:	2a03      	cmp	r2, #3
    1da6:	d801      	bhi.n	1dac <SubBytes+0x34>
    for (j = 0; j < 4; ++j)
    1da8:	2300      	movs	r3, #0
    1daa:	e7f7      	b.n	1d9c <SubBytes+0x24>
    }
  }
}
    1dac:	bc10      	pop	{r4}
    1dae:	4770      	bx	lr
  for (i = 0; i < 4; ++i)
    1db0:	3201      	adds	r2, #1
    1db2:	b2d2      	uxtb	r2, r2
    1db4:	e7e1      	b.n	1d7a <SubBytes+0x2>
    1db6:	4770      	bx	lr
    1db8:	00003614 	andeq	r3, r0, r4, lsl r6

00001dbc <ShiftRows>:
static void ShiftRows(state_t* state)
{
  uint8_t temp;

  // Rotate first row 1 columns to left  
  temp           = (*state)[0][1];
    1dbc:	7843      	ldrb	r3, [r0, #1]
  (*state)[0][1] = (*state)[1][1];
    1dbe:	7942      	ldrb	r2, [r0, #5]
    1dc0:	7042      	strb	r2, [r0, #1]
  (*state)[1][1] = (*state)[2][1];
    1dc2:	7a42      	ldrb	r2, [r0, #9]
    1dc4:	7142      	strb	r2, [r0, #5]
  (*state)[2][1] = (*state)[3][1];
    1dc6:	7b42      	ldrb	r2, [r0, #13]
    1dc8:	7242      	strb	r2, [r0, #9]
  (*state)[3][1] = temp;
    1dca:	7343      	strb	r3, [r0, #13]

  // Rotate second row 2 columns to left  
  temp           = (*state)[0][2];
    1dcc:	7883      	ldrb	r3, [r0, #2]
  (*state)[0][2] = (*state)[2][2];
    1dce:	7a82      	ldrb	r2, [r0, #10]
    1dd0:	7082      	strb	r2, [r0, #2]
  (*state)[2][2] = temp;
    1dd2:	7283      	strb	r3, [r0, #10]

  temp           = (*state)[1][2];
    1dd4:	7983      	ldrb	r3, [r0, #6]
  (*state)[1][2] = (*state)[3][2];
    1dd6:	7b82      	ldrb	r2, [r0, #14]
    1dd8:	7182      	strb	r2, [r0, #6]
  (*state)[3][2] = temp;
    1dda:	7383      	strb	r3, [r0, #14]

  // Rotate third row 3 columns to left
  temp           = (*state)[0][3];
    1ddc:	78c3      	ldrb	r3, [r0, #3]
  (*state)[0][3] = (*state)[3][3];
    1dde:	7bc2      	ldrb	r2, [r0, #15]
    1de0:	70c2      	strb	r2, [r0, #3]
  (*state)[3][3] = (*state)[2][3];
    1de2:	7ac2      	ldrb	r2, [r0, #11]
    1de4:	73c2      	strb	r2, [r0, #15]
  (*state)[2][3] = (*state)[1][3];
    1de6:	79c2      	ldrb	r2, [r0, #7]
    1de8:	72c2      	strb	r2, [r0, #11]
  (*state)[1][3] = temp;
    1dea:	71c3      	strb	r3, [r0, #7]
}
    1dec:	4770      	bx	lr

00001dee <xtime>:

static uint8_t xtime(uint8_t x)
{
  return ((x<<1) ^ (((x>>7) & 1) * 0x1b));
    1dee:	09c3      	lsrs	r3, r0, #7
    1df0:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    1df4:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
    1df8:	ea83 0040 	eor.w	r0, r3, r0, lsl #1
}
    1dfc:	b2c0      	uxtb	r0, r0
    1dfe:	4770      	bx	lr

00001e00 <MixColumns>:

// MixColumns function mixes the columns of the state matrix
static void MixColumns(state_t* state)
{
    1e00:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1e04:	4681      	mov	r9, r0
  uint8_t i;
  uint8_t Tmp, Tm, t;
  for (i = 0; i < 4; ++i)
    1e06:	2500      	movs	r5, #0
    1e08:	e031      	b.n	1e6e <MixColumns+0x6e>
  {  
    t   = (*state)[i][0];
    1e0a:	f819 a025 	ldrb.w	sl, [r9, r5, lsl #2]
    Tmp = (*state)[i][0] ^ (*state)[i][1] ^ (*state)[i][2] ^ (*state)[i][3] ;
    1e0e:	eb09 0685 	add.w	r6, r9, r5, lsl #2
    1e12:	f896 b001 	ldrb.w	fp, [r6, #1]
    1e16:	ea8b 000a 	eor.w	r0, fp, sl
    1e1a:	f896 8002 	ldrb.w	r8, [r6, #2]
    1e1e:	78f7      	ldrb	r7, [r6, #3]
    1e20:	ea80 0408 	eor.w	r4, r0, r8
    1e24:	407c      	eors	r4, r7
    Tm  = (*state)[i][0] ^ (*state)[i][1] ; Tm = xtime(Tm);  (*state)[i][0] ^= Tm ^ Tmp ;
    1e26:	f7ff ffe2 	bl	1dee <xtime>
    1e2a:	4060      	eors	r0, r4
    1e2c:	ea8a 0000 	eor.w	r0, sl, r0
    1e30:	f809 0025 	strb.w	r0, [r9, r5, lsl #2]
    Tm  = (*state)[i][1] ^ (*state)[i][2] ; Tm = xtime(Tm);  (*state)[i][1] ^= Tm ^ Tmp ;
    1e34:	ea8b 0008 	eor.w	r0, fp, r8
    1e38:	f7ff ffd9 	bl	1dee <xtime>
    1e3c:	4060      	eors	r0, r4
    1e3e:	ea8b 0b00 	eor.w	fp, fp, r0
    1e42:	f886 b001 	strb.w	fp, [r6, #1]
    Tm  = (*state)[i][2] ^ (*state)[i][3] ; Tm = xtime(Tm);  (*state)[i][2] ^= Tm ^ Tmp ;
    1e46:	ea88 0007 	eor.w	r0, r8, r7
    1e4a:	f7ff ffd0 	bl	1dee <xtime>
    1e4e:	4060      	eors	r0, r4
    1e50:	ea88 0800 	eor.w	r8, r8, r0
    1e54:	f886 8002 	strb.w	r8, [r6, #2]
    Tm  = (*state)[i][3] ^ t ;              Tm = xtime(Tm);  (*state)[i][3] ^= Tm ^ Tmp ;
    1e58:	ea87 000a 	eor.w	r0, r7, sl
    1e5c:	f7ff ffc7 	bl	1dee <xtime>
    1e60:	ea84 0300 	eor.w	r3, r4, r0
    1e64:	ea87 0403 	eor.w	r4, r7, r3
    1e68:	70f4      	strb	r4, [r6, #3]
  for (i = 0; i < 4; ++i)
    1e6a:	3501      	adds	r5, #1
    1e6c:	b2ed      	uxtb	r5, r5
    1e6e:	2d03      	cmp	r5, #3
    1e70:	d9cb      	bls.n	1e0a <MixColumns+0xa>
  }
}
    1e72:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

00001e76 <InvMixColumns>:

// MixColumns function mixes the columns of the state matrix.
// The method used to multiply may be difficult to understand for the inexperienced.
// Please use the references to gain more information.
static void InvMixColumns(state_t* state)
{
    1e76:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1e7a:	b08b      	sub	sp, #44	@ 0x2c
    1e7c:	9000      	str	r0, [sp, #0]
  int i;
  uint8_t a, b, c, d;
  for (i = 0; i < 4; ++i)
    1e7e:	2400      	movs	r4, #0
    1e80:	e0a0      	b.n	1fc4 <InvMixColumns+0x14e>
  { 
    a = (*state)[i][0];
    1e82:	9b00      	ldr	r3, [sp, #0]
    1e84:	f813 b024 	ldrb.w	fp, [r3, r4, lsl #2]
    b = (*state)[i][1];
    1e88:	eb03 0884 	add.w	r8, r3, r4, lsl #2
    1e8c:	f898 a001 	ldrb.w	sl, [r8, #1]
    c = (*state)[i][2];
    1e90:	f898 9002 	ldrb.w	r9, [r8, #2]
    d = (*state)[i][3];
    1e94:	f898 5003 	ldrb.w	r5, [r8, #3]

    (*state)[i][0] = Multiply(a, 0x0e) ^ Multiply(b, 0x0b) ^ Multiply(c, 0x0d) ^ Multiply(d, 0x09);
    1e98:	4658      	mov	r0, fp
    1e9a:	f7ff ffa8 	bl	1dee <xtime>
    1e9e:	9007      	str	r0, [sp, #28]
    1ea0:	f7ff ffa5 	bl	1dee <xtime>
    1ea4:	9001      	str	r0, [sp, #4]
    1ea6:	f7ff ffa2 	bl	1dee <xtime>
    1eaa:	9008      	str	r0, [sp, #32]
    1eac:	4650      	mov	r0, sl
    1eae:	f7ff ff9e 	bl	1dee <xtime>
    1eb2:	9002      	str	r0, [sp, #8]
    1eb4:	f7ff ff9b 	bl	1dee <xtime>
    1eb8:	9003      	str	r0, [sp, #12]
    1eba:	f7ff ff98 	bl	1dee <xtime>
    1ebe:	4607      	mov	r7, r0
    1ec0:	4648      	mov	r0, r9
    1ec2:	f7ff ff94 	bl	1dee <xtime>
    1ec6:	9009      	str	r0, [sp, #36]	@ 0x24
    1ec8:	f7ff ff91 	bl	1dee <xtime>
    1ecc:	9004      	str	r0, [sp, #16]
    1ece:	f7ff ff8e 	bl	1dee <xtime>
    1ed2:	4606      	mov	r6, r0
    1ed4:	4628      	mov	r0, r5
    1ed6:	f7ff ff8a 	bl	1dee <xtime>
    1eda:	9005      	str	r0, [sp, #20]
    1edc:	f7ff ff87 	bl	1dee <xtime>
    1ee0:	9006      	str	r0, [sp, #24]
    1ee2:	f7ff ff84 	bl	1dee <xtime>
    1ee6:	f8dd e01c 	ldr.w	lr, [sp, #28]
    1eea:	9a01      	ldr	r2, [sp, #4]
    1eec:	ea8e 0302 	eor.w	r3, lr, r2
    1ef0:	b2db      	uxtb	r3, r3
    1ef2:	9908      	ldr	r1, [sp, #32]
    1ef4:	404b      	eors	r3, r1
    1ef6:	b2db      	uxtb	r3, r3
    1ef8:	f8dd c008 	ldr.w	ip, [sp, #8]
    1efc:	ea8c 020a 	eor.w	r2, ip, sl
    1f00:	b2d2      	uxtb	r2, r2
    1f02:	407a      	eors	r2, r7
    1f04:	b2d2      	uxtb	r2, r2
    1f06:	4053      	eors	r3, r2
    1f08:	9a04      	ldr	r2, [sp, #16]
    1f0a:	ea82 0209 	eor.w	r2, r2, r9
    1f0e:	b2d2      	uxtb	r2, r2
    1f10:	4072      	eors	r2, r6
    1f12:	b2d2      	uxtb	r2, r2
    1f14:	4053      	eors	r3, r2
    1f16:	ea80 0205 	eor.w	r2, r0, r5
    1f1a:	b2d2      	uxtb	r2, r2
    1f1c:	4053      	eors	r3, r2
    1f1e:	f8dd c000 	ldr.w	ip, [sp]
    1f22:	f80c 3024 	strb.w	r3, [ip, r4, lsl #2]
    (*state)[i][1] = Multiply(a, 0x09) ^ Multiply(b, 0x0e) ^ Multiply(c, 0x0b) ^ Multiply(d, 0x0d);
    1f26:	ea81 030b 	eor.w	r3, r1, fp
    1f2a:	b2da      	uxtb	r2, r3
    1f2c:	f8dd c008 	ldr.w	ip, [sp, #8]
    1f30:	9b03      	ldr	r3, [sp, #12]
    1f32:	ea8c 0303 	eor.w	r3, ip, r3
    1f36:	b2db      	uxtb	r3, r3
    1f38:	407b      	eors	r3, r7
    1f3a:	b2db      	uxtb	r3, r3
    1f3c:	4053      	eors	r3, r2
    1f3e:	f8dd c024 	ldr.w	ip, [sp, #36]	@ 0x24
    1f42:	ea8c 0209 	eor.w	r2, ip, r9
    1f46:	b2d2      	uxtb	r2, r2
    1f48:	4072      	eors	r2, r6
    1f4a:	b2d2      	uxtb	r2, r2
    1f4c:	4053      	eors	r3, r2
    1f4e:	9a06      	ldr	r2, [sp, #24]
    1f50:	406a      	eors	r2, r5
    1f52:	b2d2      	uxtb	r2, r2
    1f54:	4042      	eors	r2, r0
    1f56:	b2d2      	uxtb	r2, r2
    1f58:	4053      	eors	r3, r2
    1f5a:	f888 3001 	strb.w	r3, [r8, #1]
    (*state)[i][2] = Multiply(a, 0x0d) ^ Multiply(b, 0x09) ^ Multiply(c, 0x0e) ^ Multiply(d, 0x0b);
    1f5e:	9b01      	ldr	r3, [sp, #4]
    1f60:	ea83 030b 	eor.w	r3, r3, fp
    1f64:	b2db      	uxtb	r3, r3
    1f66:	404b      	eors	r3, r1
    1f68:	b2db      	uxtb	r3, r3
    1f6a:	ea87 020a 	eor.w	r2, r7, sl
    1f6e:	b2d2      	uxtb	r2, r2
    1f70:	4053      	eors	r3, r2
    1f72:	9a04      	ldr	r2, [sp, #16]
    1f74:	ea8c 0202 	eor.w	r2, ip, r2
    1f78:	b2d2      	uxtb	r2, r2
    1f7a:	4072      	eors	r2, r6
    1f7c:	b2d2      	uxtb	r2, r2
    1f7e:	4053      	eors	r3, r2
    1f80:	9a05      	ldr	r2, [sp, #20]
    1f82:	4055      	eors	r5, r2
    1f84:	b2ed      	uxtb	r5, r5
    1f86:	4045      	eors	r5, r0
    1f88:	b2ed      	uxtb	r5, r5
    1f8a:	406b      	eors	r3, r5
    1f8c:	f888 3002 	strb.w	r3, [r8, #2]
    (*state)[i][3] = Multiply(a, 0x0b) ^ Multiply(b, 0x0d) ^ Multiply(c, 0x09) ^ Multiply(d, 0x0e);
    1f90:	ea8e 030b 	eor.w	r3, lr, fp
    1f94:	b2db      	uxtb	r3, r3
    1f96:	404b      	eors	r3, r1
    1f98:	b2db      	uxtb	r3, r3
    1f9a:	9903      	ldr	r1, [sp, #12]
    1f9c:	ea81 020a 	eor.w	r2, r1, sl
    1fa0:	b2d2      	uxtb	r2, r2
    1fa2:	4057      	eors	r7, r2
    1fa4:	b2ff      	uxtb	r7, r7
    1fa6:	407b      	eors	r3, r7
    1fa8:	ea86 0609 	eor.w	r6, r6, r9
    1fac:	b2f6      	uxtb	r6, r6
    1fae:	4073      	eors	r3, r6
    1fb0:	9905      	ldr	r1, [sp, #20]
    1fb2:	9a06      	ldr	r2, [sp, #24]
    1fb4:	404a      	eors	r2, r1
    1fb6:	b2d2      	uxtb	r2, r2
    1fb8:	4050      	eors	r0, r2
    1fba:	b2c0      	uxtb	r0, r0
    1fbc:	4043      	eors	r3, r0
    1fbe:	f888 3003 	strb.w	r3, [r8, #3]
  for (i = 0; i < 4; ++i)
    1fc2:	3401      	adds	r4, #1
    1fc4:	2c03      	cmp	r4, #3
    1fc6:	f77f af5c 	ble.w	1e82 <InvMixColumns+0xc>
  }
}
    1fca:	b00b      	add	sp, #44	@ 0x2c
    1fcc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00001fd0 <InvSubBytes>:
// The SubBytes Function Substitutes the values in the
// state matrix with values in an S-box.
static void InvSubBytes(state_t* state)
{
  uint8_t i, j;
  for (i = 0; i < 4; ++i)
    1fd0:	2100      	movs	r1, #0
    1fd2:	2903      	cmp	r1, #3
    1fd4:	d81c      	bhi.n	2010 <InvSubBytes+0x40>
  {
    for (j = 0; j < 4; ++j)
    1fd6:	2300      	movs	r3, #0
    1fd8:	2b03      	cmp	r3, #3
    1fda:	d816      	bhi.n	200a <InvSubBytes+0x3a>
{
    1fdc:	b500      	push	{lr}
    {
      (*state)[j][i] = getSBoxInvert((*state)[j][i]);
    1fde:	eb00 0c83 	add.w	ip, r0, r3, lsl #2
    1fe2:	f81c e001 	ldrb.w	lr, [ip, r1]
    1fe6:	4a0b      	ldr	r2, [pc, #44]	@ (2014 <InvSubBytes+0x44>)
    1fe8:	4472      	add	r2, lr
    1fea:	f892 210c 	ldrb.w	r2, [r2, #268]	@ 0x10c
    1fee:	f80c 2001 	strb.w	r2, [ip, r1]
    for (j = 0; j < 4; ++j)
    1ff2:	3301      	adds	r3, #1
    1ff4:	b2db      	uxtb	r3, r3
    1ff6:	2b03      	cmp	r3, #3
    1ff8:	d9f1      	bls.n	1fde <InvSubBytes+0xe>
  for (i = 0; i < 4; ++i)
    1ffa:	3101      	adds	r1, #1
    1ffc:	b2c9      	uxtb	r1, r1
    1ffe:	2903      	cmp	r1, #3
    2000:	d801      	bhi.n	2006 <InvSubBytes+0x36>
    for (j = 0; j < 4; ++j)
    2002:	2300      	movs	r3, #0
    2004:	e7f7      	b.n	1ff6 <InvSubBytes+0x26>
    }
  }
}
    2006:	f85d fb04 	ldr.w	pc, [sp], #4
  for (i = 0; i < 4; ++i)
    200a:	3101      	adds	r1, #1
    200c:	b2c9      	uxtb	r1, r1
    200e:	e7e0      	b.n	1fd2 <InvSubBytes+0x2>
    2010:	4770      	bx	lr
    2012:	bf00      	nop
    2014:	00003614 	andeq	r3, r0, r4, lsl r6

00002018 <InvShiftRows>:
static void InvShiftRows(state_t* state)
{
  uint8_t temp;

  // Rotate first row 1 columns to right  
  temp = (*state)[3][1];
    2018:	7b43      	ldrb	r3, [r0, #13]
  (*state)[3][1] = (*state)[2][1];
    201a:	7a42      	ldrb	r2, [r0, #9]
    201c:	7342      	strb	r2, [r0, #13]
  (*state)[2][1] = (*state)[1][1];
    201e:	7942      	ldrb	r2, [r0, #5]
    2020:	7242      	strb	r2, [r0, #9]
  (*state)[1][1] = (*state)[0][1];
    2022:	7842      	ldrb	r2, [r0, #1]
    2024:	7142      	strb	r2, [r0, #5]
  (*state)[0][1] = temp;
    2026:	7043      	strb	r3, [r0, #1]

  // Rotate second row 2 columns to right 
  temp = (*state)[0][2];
    2028:	7883      	ldrb	r3, [r0, #2]
  (*state)[0][2] = (*state)[2][2];
    202a:	7a82      	ldrb	r2, [r0, #10]
    202c:	7082      	strb	r2, [r0, #2]
  (*state)[2][2] = temp;
    202e:	7283      	strb	r3, [r0, #10]

  temp = (*state)[1][2];
    2030:	7983      	ldrb	r3, [r0, #6]
  (*state)[1][2] = (*state)[3][2];
    2032:	7b82      	ldrb	r2, [r0, #14]
    2034:	7182      	strb	r2, [r0, #6]
  (*state)[3][2] = temp;
    2036:	7383      	strb	r3, [r0, #14]

  // Rotate third row 3 columns to right
  temp = (*state)[0][3];
    2038:	78c3      	ldrb	r3, [r0, #3]
  (*state)[0][3] = (*state)[1][3];
    203a:	79c2      	ldrb	r2, [r0, #7]
    203c:	70c2      	strb	r2, [r0, #3]
  (*state)[1][3] = (*state)[2][3];
    203e:	7ac2      	ldrb	r2, [r0, #11]
    2040:	71c2      	strb	r2, [r0, #7]
  (*state)[2][3] = (*state)[3][3];
    2042:	7bc2      	ldrb	r2, [r0, #15]
    2044:	72c2      	strb	r2, [r0, #11]
  (*state)[3][3] = temp;
    2046:	73c3      	strb	r3, [r0, #15]
}
    2048:	4770      	bx	lr

0000204a <Cipher>:
#endif // #if (defined(CBC) && CBC == 1) || (defined(ECB) && ECB == 1)

// Cipher is the main function that encrypts the PlainText.
static void Cipher(state_t* state, const uint8_t* RoundKey)
{
    204a:	b570      	push	{r4, r5, r6, lr}
    204c:	4605      	mov	r5, r0
    204e:	460e      	mov	r6, r1
  uint8_t round = 0;

  // Add the First round key to the state before starting the rounds.
  AddRoundKey(0, state, RoundKey);
    2050:	460a      	mov	r2, r1
    2052:	4601      	mov	r1, r0
    2054:	2000      	movs	r0, #0
    2056:	f7ff fe73 	bl	1d40 <AddRoundKey>

  // There will be Nr rounds.
  // The first Nr-1 rounds are identical.
  // These Nr rounds are executed in the loop below.
  // Last one without MixColumns()
  for (round = 1; ; ++round)
    205a:	2401      	movs	r4, #1
    205c:	e009      	b.n	2072 <Cipher+0x28>
    SubBytes(state);
    ShiftRows(state);
    if (round == Nr) {
      break;
    }
    MixColumns(state);
    205e:	4628      	mov	r0, r5
    2060:	f7ff fece 	bl	1e00 <MixColumns>
    AddRoundKey(round, state, RoundKey);
    2064:	4632      	mov	r2, r6
    2066:	4629      	mov	r1, r5
    2068:	4620      	mov	r0, r4
    206a:	f7ff fe69 	bl	1d40 <AddRoundKey>
  for (round = 1; ; ++round)
    206e:	3401      	adds	r4, #1
    2070:	b2e4      	uxtb	r4, r4
    SubBytes(state);
    2072:	4628      	mov	r0, r5
    2074:	f7ff fe80 	bl	1d78 <SubBytes>
    ShiftRows(state);
    2078:	4628      	mov	r0, r5
    207a:	f7ff fe9f 	bl	1dbc <ShiftRows>
    if (round == Nr) {
    207e:	2c0e      	cmp	r4, #14
    2080:	d1ed      	bne.n	205e <Cipher+0x14>
  }
  // Add round key to last round
  AddRoundKey(Nr, state, RoundKey);
    2082:	4632      	mov	r2, r6
    2084:	4629      	mov	r1, r5
    2086:	200e      	movs	r0, #14
    2088:	f7ff fe5a 	bl	1d40 <AddRoundKey>
}
    208c:	bd70      	pop	{r4, r5, r6, pc}

0000208e <InvCipher>:

#if (defined(CBC) && CBC == 1) || (defined(ECB) && ECB == 1)
static void InvCipher(state_t* state, const uint8_t* RoundKey)
{
    208e:	b570      	push	{r4, r5, r6, lr}
    2090:	4605      	mov	r5, r0
    2092:	460e      	mov	r6, r1
  uint8_t round = 0;

  // Add the First round key to the state before starting the rounds.
  AddRoundKey(Nr, state, RoundKey);
    2094:	460a      	mov	r2, r1
    2096:	4601      	mov	r1, r0
    2098:	200e      	movs	r0, #14
    209a:	f7ff fe51 	bl	1d40 <AddRoundKey>

  // There will be Nr rounds.
  // The first Nr-1 rounds are identical.
  // These Nr rounds are executed in the loop below.
  // Last one without InvMixColumn()
  for (round = (Nr - 1); ; --round)
    209e:	240d      	movs	r4, #13
    20a0:	e004      	b.n	20ac <InvCipher+0x1e>
    InvSubBytes(state);
    AddRoundKey(round, state, RoundKey);
    if (round == 0) {
      break;
    }
    InvMixColumns(state);
    20a2:	4628      	mov	r0, r5
    20a4:	f7ff fee7 	bl	1e76 <InvMixColumns>
  for (round = (Nr - 1); ; --round)
    20a8:	3c01      	subs	r4, #1
    20aa:	b2e4      	uxtb	r4, r4
    InvShiftRows(state);
    20ac:	4628      	mov	r0, r5
    20ae:	f7ff ffb3 	bl	2018 <InvShiftRows>
    InvSubBytes(state);
    20b2:	4628      	mov	r0, r5
    20b4:	f7ff ff8c 	bl	1fd0 <InvSubBytes>
    AddRoundKey(round, state, RoundKey);
    20b8:	4632      	mov	r2, r6
    20ba:	4629      	mov	r1, r5
    20bc:	4620      	mov	r0, r4
    20be:	f7ff fe3f 	bl	1d40 <AddRoundKey>
    if (round == 0) {
    20c2:	2c00      	cmp	r4, #0
    20c4:	d1ed      	bne.n	20a2 <InvCipher+0x14>
  }

}
    20c6:	bd70      	pop	{r4, r5, r6, pc}

000020c8 <XorWithIv>:


static void XorWithIv(uint8_t* buf, const uint8_t* Iv)
{
  uint8_t i;
  for (i = 0; i < AES_BLOCKLEN; ++i) // The block in AES is always 128bit no matter the key size
    20c8:	2300      	movs	r3, #0
    20ca:	e007      	b.n	20dc <XorWithIv+0x14>
  {
    buf[i] ^= Iv[i];
    20cc:	5cc2      	ldrb	r2, [r0, r3]
    20ce:	f811 c003 	ldrb.w	ip, [r1, r3]
    20d2:	ea82 020c 	eor.w	r2, r2, ip
    20d6:	54c2      	strb	r2, [r0, r3]
  for (i = 0; i < AES_BLOCKLEN; ++i) // The block in AES is always 128bit no matter the key size
    20d8:	3301      	adds	r3, #1
    20da:	b2db      	uxtb	r3, r3
    20dc:	2b0f      	cmp	r3, #15
    20de:	d9f5      	bls.n	20cc <XorWithIv+0x4>
  }
}
    20e0:	4770      	bx	lr

000020e2 <AES_init_ctx>:
{
    20e2:	b508      	push	{r3, lr}
  KeyExpansion(ctx->RoundKey, key);
    20e4:	f7ff fd9c 	bl	1c20 <KeyExpansion>
}
    20e8:	bd08      	pop	{r3, pc}

000020ea <AES_init_ctx_iv>:
{
    20ea:	b538      	push	{r3, r4, r5, lr}
    20ec:	4604      	mov	r4, r0
    20ee:	4615      	mov	r5, r2
  KeyExpansion(ctx->RoundKey, key);
    20f0:	f7ff fd96 	bl	1c20 <KeyExpansion>
  memcpy (ctx->Iv, iv, AES_BLOCKLEN);
    20f4:	2210      	movs	r2, #16
    20f6:	4629      	mov	r1, r5
    20f8:	f104 00f0 	add.w	r0, r4, #240	@ 0xf0
    20fc:	f000 fbef 	bl	28de <memcpy>
}
    2100:	bd38      	pop	{r3, r4, r5, pc}

00002102 <AES_ctx_set_iv>:
{
    2102:	b508      	push	{r3, lr}
  memcpy (ctx->Iv, iv, AES_BLOCKLEN);
    2104:	2210      	movs	r2, #16
    2106:	30f0      	adds	r0, #240	@ 0xf0
    2108:	f000 fbe9 	bl	28de <memcpy>
}
    210c:	bd08      	pop	{r3, pc}

0000210e <AES_ECB_encrypt>:
{
    210e:	b508      	push	{r3, lr}
    2110:	460b      	mov	r3, r1
  Cipher((state_t*)buf, ctx->RoundKey);
    2112:	4601      	mov	r1, r0
    2114:	4618      	mov	r0, r3
    2116:	f7ff ff98 	bl	204a <Cipher>
}
    211a:	bd08      	pop	{r3, pc}

0000211c <AES_ECB_decrypt>:
{
    211c:	b508      	push	{r3, lr}
    211e:	460b      	mov	r3, r1
  InvCipher((state_t*)buf, ctx->RoundKey);
    2120:	4601      	mov	r1, r0
    2122:	4618      	mov	r0, r3
    2124:	f7ff ffb3 	bl	208e <InvCipher>
}
    2128:	bd08      	pop	{r3, pc}

0000212a <AES_CBC_encrypt_buffer>:

void AES_CBC_encrypt_buffer(struct AES_ctx *ctx, uint8_t* buf, size_t length)
{
    212a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    212e:	4606      	mov	r6, r0
    2130:	460c      	mov	r4, r1
    2132:	4617      	mov	r7, r2
  size_t i;
  uint8_t *Iv = ctx->Iv;
    2134:	f100 08f0 	add.w	r8, r0, #240	@ 0xf0
    2138:	4641      	mov	r1, r8
  for (i = 0; i < length; i += AES_BLOCKLEN)
    213a:	2500      	movs	r5, #0
    213c:	e009      	b.n	2152 <AES_CBC_encrypt_buffer+0x28>
  {
    XorWithIv(buf, Iv);
    213e:	4620      	mov	r0, r4
    2140:	f7ff ffc2 	bl	20c8 <XorWithIv>
    Cipher((state_t*)buf, ctx->RoundKey);
    2144:	4631      	mov	r1, r6
    2146:	4620      	mov	r0, r4
    2148:	f7ff ff7f 	bl	204a <Cipher>
  for (i = 0; i < length; i += AES_BLOCKLEN)
    214c:	3510      	adds	r5, #16
    Iv = buf;
    214e:	4621      	mov	r1, r4
    buf += AES_BLOCKLEN;
    2150:	3410      	adds	r4, #16
  for (i = 0; i < length; i += AES_BLOCKLEN)
    2152:	42bd      	cmp	r5, r7
    2154:	d3f3      	bcc.n	213e <AES_CBC_encrypt_buffer+0x14>
  }
  /* store Iv in ctx for next call */
  memcpy(ctx->Iv, Iv, AES_BLOCKLEN);
    2156:	2210      	movs	r2, #16
    2158:	4640      	mov	r0, r8
    215a:	f000 fbc0 	bl	28de <memcpy>
}
    215e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00002162 <AES_CBC_decrypt_buffer>:

void AES_CBC_decrypt_buffer(struct AES_ctx* ctx, uint8_t* buf, size_t length)
{
    2162:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    2166:	b084      	sub	sp, #16
    2168:	4607      	mov	r7, r0
    216a:	460c      	mov	r4, r1
    216c:	4690      	mov	r8, r2
  size_t i;
  uint8_t storeNextIv[AES_BLOCKLEN];
  for (i = 0; i < length; i += AES_BLOCKLEN)
    216e:	2500      	movs	r5, #0
    2170:	e015      	b.n	219e <AES_CBC_decrypt_buffer+0x3c>
  {
    memcpy(storeNextIv, buf, AES_BLOCKLEN);
    2172:	2210      	movs	r2, #16
    2174:	4621      	mov	r1, r4
    2176:	4668      	mov	r0, sp
    2178:	f000 fbb1 	bl	28de <memcpy>
    InvCipher((state_t*)buf, ctx->RoundKey);
    217c:	4639      	mov	r1, r7
    217e:	4620      	mov	r0, r4
    2180:	f7ff ff85 	bl	208e <InvCipher>
    XorWithIv(buf, ctx->Iv);
    2184:	f107 06f0 	add.w	r6, r7, #240	@ 0xf0
    2188:	4631      	mov	r1, r6
    218a:	4620      	mov	r0, r4
    218c:	f7ff ff9c 	bl	20c8 <XorWithIv>
    memcpy(ctx->Iv, storeNextIv, AES_BLOCKLEN);
    2190:	2210      	movs	r2, #16
    2192:	4669      	mov	r1, sp
    2194:	4630      	mov	r0, r6
    2196:	f000 fba2 	bl	28de <memcpy>
    buf += AES_BLOCKLEN;
    219a:	3410      	adds	r4, #16
  for (i = 0; i < length; i += AES_BLOCKLEN)
    219c:	3510      	adds	r5, #16
    219e:	4545      	cmp	r5, r8
    21a0:	d3e7      	bcc.n	2172 <AES_CBC_decrypt_buffer+0x10>
  }

}
    21a2:	b004      	add	sp, #16
    21a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000021a8 <AES_CTR_xcrypt_buffer>:

#if defined(CTR) && (CTR == 1)

/* Symmetrical operation: same function for encrypting as for decrypting. Note any IV/nonce should never be reused with the same key */
void AES_CTR_xcrypt_buffer(struct AES_ctx* ctx, uint8_t* buf, size_t length)
{
    21a8:	b5f0      	push	{r4, r5, r6, r7, lr}
    21aa:	b085      	sub	sp, #20
    21ac:	4607      	mov	r7, r0
    21ae:	460d      	mov	r5, r1
    21b0:	4616      	mov	r6, r2
  uint8_t buffer[AES_BLOCKLEN];
  
  size_t i;
  int bi;
  for (i = 0, bi = AES_BLOCKLEN; i < length; ++i, ++bi)
    21b2:	2310      	movs	r3, #16
    21b4:	2400      	movs	r4, #0
    21b6:	e013      	b.n	21e0 <AES_CTR_xcrypt_buffer+0x38>
      for (bi = (AES_BLOCKLEN - 1); bi >= 0; --bi)
      {
	/* inc will overflow */
        if (ctx->Iv[bi] == 255)
	{
          ctx->Iv[bi] = 0;
    21b8:	18fa      	adds	r2, r7, r3
    21ba:	2100      	movs	r1, #0
    21bc:	f882 10f0 	strb.w	r1, [r2, #240]	@ 0xf0
      for (bi = (AES_BLOCKLEN - 1); bi >= 0; --bi)
    21c0:	3b01      	subs	r3, #1
    21c2:	e01c      	b.n	21fe <AES_CTR_xcrypt_buffer+0x56>
          continue;
        } 
        ctx->Iv[bi] += 1;
        break;   
      }
      bi = 0;
    21c4:	2300      	movs	r3, #0
    }

    buf[i] = (buf[i] ^ buffer[bi]);
    21c6:	f815 c004 	ldrb.w	ip, [r5, r4]
    21ca:	f103 0210 	add.w	r2, r3, #16
    21ce:	446a      	add	r2, sp
    21d0:	f812 ec10 	ldrb.w	lr, [r2, #-16]
    21d4:	ea8c 0c0e 	eor.w	ip, ip, lr
    21d8:	f805 c004 	strb.w	ip, [r5, r4]
  for (i = 0, bi = AES_BLOCKLEN; i < length; ++i, ++bi)
    21dc:	3401      	adds	r4, #1
    21de:	3301      	adds	r3, #1
    21e0:	42b4      	cmp	r4, r6
    21e2:	d219      	bcs.n	2218 <AES_CTR_xcrypt_buffer+0x70>
    if (bi == AES_BLOCKLEN) /* we need to regen xor compliment in buffer */
    21e4:	2b10      	cmp	r3, #16
    21e6:	d1ee      	bne.n	21c6 <AES_CTR_xcrypt_buffer+0x1e>
      memcpy(buffer, ctx->Iv, AES_BLOCKLEN);
    21e8:	2210      	movs	r2, #16
    21ea:	f107 01f0 	add.w	r1, r7, #240	@ 0xf0
    21ee:	4668      	mov	r0, sp
    21f0:	f000 fb75 	bl	28de <memcpy>
      Cipher((state_t*)buffer,ctx->RoundKey);
    21f4:	4639      	mov	r1, r7
    21f6:	4668      	mov	r0, sp
    21f8:	f7ff ff27 	bl	204a <Cipher>
      for (bi = (AES_BLOCKLEN - 1); bi >= 0; --bi)
    21fc:	230f      	movs	r3, #15
    21fe:	2b00      	cmp	r3, #0
    2200:	dbe0      	blt.n	21c4 <AES_CTR_xcrypt_buffer+0x1c>
        if (ctx->Iv[bi] == 255)
    2202:	18fa      	adds	r2, r7, r3
    2204:	f892 20f0 	ldrb.w	r2, [r2, #240]	@ 0xf0
    2208:	2aff      	cmp	r2, #255	@ 0xff
    220a:	d0d5      	beq.n	21b8 <AES_CTR_xcrypt_buffer+0x10>
        ctx->Iv[bi] += 1;
    220c:	443b      	add	r3, r7
    220e:	3201      	adds	r2, #1
    2210:	f883 20f0 	strb.w	r2, [r3, #240]	@ 0xf0
      bi = 0;
    2214:	2300      	movs	r3, #0
        break;   
    2216:	e7d6      	b.n	21c6 <AES_CTR_xcrypt_buffer+0x1e>
  }
}
    2218:	b005      	add	sp, #20
    221a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000221c <bitvec_get_bit>:


/* some basic bit-manipulation routines that act on bit-vectors follow */
static int bitvec_get_bit(const bitvec_t x, const uint32_t idx)
{
  return ((x[idx / 32U] >> (idx & 31U) & 1U));
    221c:	094b      	lsrs	r3, r1, #5
    221e:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
    2222:	f001 011f 	and.w	r1, r1, #31
    2226:	40c8      	lsrs	r0, r1
}
    2228:	f000 0001 	and.w	r0, r0, #1
    222c:	4770      	bx	lr

0000222e <bitvec_clr_bit>:

static void bitvec_clr_bit(bitvec_t x, const uint32_t idx)
{
  x[idx / 32U] &= ~(1U << (idx & 31U));
    222e:	ea4f 1c51 	mov.w	ip, r1, lsr #5
    2232:	f850 302c 	ldr.w	r3, [r0, ip, lsl #2]
    2236:	f001 011f 	and.w	r1, r1, #31
    223a:	2201      	movs	r2, #1
    223c:	408a      	lsls	r2, r1
    223e:	ea23 0302 	bic.w	r3, r3, r2
    2242:	f840 302c 	str.w	r3, [r0, ip, lsl #2]
}
    2246:	4770      	bx	lr

00002248 <bitvec_copy>:

static void bitvec_copy(bitvec_t x, const bitvec_t y)
{
  int i;
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2248:	2300      	movs	r3, #0
    224a:	e004      	b.n	2256 <bitvec_copy+0xe>
  {
    x[i] = y[i];
    224c:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
    2250:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2254:	3301      	adds	r3, #1
    2256:	2b05      	cmp	r3, #5
    2258:	ddf8      	ble.n	224c <bitvec_copy+0x4>
  }
}
    225a:	4770      	bx	lr

0000225c <bitvec_swap>:

static void bitvec_swap(bitvec_t x, bitvec_t y)
{
    225c:	b530      	push	{r4, r5, lr}
    225e:	b087      	sub	sp, #28
    2260:	4605      	mov	r5, r0
    2262:	460c      	mov	r4, r1
  bitvec_t tmp;
  bitvec_copy(tmp, x);
    2264:	4601      	mov	r1, r0
    2266:	4668      	mov	r0, sp
    2268:	f7ff ffee 	bl	2248 <bitvec_copy>
  bitvec_copy(x, y);
    226c:	4621      	mov	r1, r4
    226e:	4628      	mov	r0, r5
    2270:	f7ff ffea 	bl	2248 <bitvec_copy>
  bitvec_copy(y, tmp);
    2274:	4669      	mov	r1, sp
    2276:	4620      	mov	r0, r4
    2278:	f7ff ffe6 	bl	2248 <bitvec_copy>
}
    227c:	b007      	add	sp, #28
    227e:	bd30      	pop	{r4, r5, pc}

00002280 <bitvec_equal>:
#if defined(CONST_TIME) && (CONST_TIME == 0)
/* fast version of equality test */
static int bitvec_equal(const bitvec_t x, const bitvec_t y)
{
  int i;
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2280:	2300      	movs	r3, #0
    2282:	2b05      	cmp	r3, #5
    2284:	dc07      	bgt.n	2296 <bitvec_equal+0x16>
  {
    if (x[i] != y[i])
    2286:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
    228a:	f850 c023 	ldr.w	ip, [r0, r3, lsl #2]
    228e:	4594      	cmp	ip, r2
    2290:	d103      	bne.n	229a <bitvec_equal+0x1a>
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2292:	3301      	adds	r3, #1
    2294:	e7f5      	b.n	2282 <bitvec_equal+0x2>
    {
      return 0;
    }
  }
  return 1;
    2296:	2001      	movs	r0, #1
    2298:	4770      	bx	lr
      return 0;
    229a:	2000      	movs	r0, #0
}
    229c:	4770      	bx	lr

0000229e <bitvec_set_zero>:
#endif

static void bitvec_set_zero(bitvec_t x)
{
  int i;
  for (i = 0; i < BITVEC_NWORDS; ++i)
    229e:	2300      	movs	r3, #0
    22a0:	e003      	b.n	22aa <bitvec_set_zero+0xc>
  {
    x[i] = 0;
    22a2:	2200      	movs	r2, #0
    22a4:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
  for (i = 0; i < BITVEC_NWORDS; ++i)
    22a8:	3301      	adds	r3, #1
    22aa:	2b05      	cmp	r3, #5
    22ac:	ddf9      	ble.n	22a2 <bitvec_set_zero+0x4>
  }
}
    22ae:	4770      	bx	lr

000022b0 <bitvec_is_zero>:

#if defined(CONST_TIME) && (CONST_TIME == 0)
/* fast implementation */
static int bitvec_is_zero(const bitvec_t x)
{
  uint32_t i = 0;
    22b0:	2300      	movs	r3, #0
  while (i < BITVEC_NWORDS)
    22b2:	2b05      	cmp	r3, #5
    22b4:	d804      	bhi.n	22c0 <bitvec_is_zero+0x10>
  {
    if (x[i] != 0)
    22b6:	f850 2023 	ldr.w	r2, [r0, r3, lsl #2]
    22ba:	b90a      	cbnz	r2, 22c0 <bitvec_is_zero+0x10>
    {
      break;
    }
    i += 1;
    22bc:	3301      	adds	r3, #1
    22be:	e7f8      	b.n	22b2 <bitvec_is_zero+0x2>
  }
  return (i == BITVEC_NWORDS);
}
    22c0:	2b06      	cmp	r3, #6
    22c2:	bf14      	ite	ne
    22c4:	2000      	movne	r0, #0
    22c6:	2001      	moveq	r0, #1
    22c8:	4770      	bx	lr

000022ca <bitvec_degree>:
static int bitvec_degree(const bitvec_t x)
{
  int i = BITVEC_NWORDS * 32;

  /* Start at the back of the vector (MSB) */
  x += BITVEC_NWORDS;
    22ca:	f100 0318 	add.w	r3, r0, #24
  int i = BITVEC_NWORDS * 32;
    22ce:	20c0      	movs	r0, #192	@ 0xc0

  /* Skip empty / zero words */
  while (    (i > 0)
          && (*(--x)) == 0)
    22d0:	2800      	cmp	r0, #0
    22d2:	dd04      	ble.n	22de <bitvec_degree+0x14>
    22d4:	f853 2d04 	ldr.w	r2, [r3, #-4]!
    22d8:	b90a      	cbnz	r2, 22de <bitvec_degree+0x14>
  {
    i -= 32;
    22da:	3820      	subs	r0, #32
    22dc:	e7f8      	b.n	22d0 <bitvec_degree+0x6>
  }
  /* Run through rest if count is not multiple of bitsize of DTYPE */
  if (i != 0)
    22de:	b930      	cbnz	r0, 22ee <bitvec_degree+0x24>
    22e0:	4770      	bx	lr
  {
    uint32_t u32mask = ((uint32_t)1 << 31);
    while (((*x) & u32mask) == 0)
    {
      u32mask >>= 1;
    22e2:	0852      	lsrs	r2, r2, #1
      i -= 1;
    22e4:	3801      	subs	r0, #1
    while (((*x) & u32mask) == 0)
    22e6:	6819      	ldr	r1, [r3, #0]
    22e8:	4211      	tst	r1, r2
    22ea:	d0fa      	beq.n	22e2 <bitvec_degree+0x18>
    }
  }
  return i;
}
    22ec:	4770      	bx	lr
    uint32_t u32mask = ((uint32_t)1 << 31);
    22ee:	f04f 4200 	mov.w	r2, #2147483648	@ 0x80000000
    22f2:	e7f8      	b.n	22e6 <bitvec_degree+0x1c>

000022f4 <bitvec_lshift>:

/* left-shift by 'count' digits */
static void bitvec_lshift(bitvec_t x, const bitvec_t y, int nbits)
{
    22f4:	b410      	push	{r4}
  int nwords = (nbits / 32);
    22f6:	4694      	mov	ip, r2
    22f8:	2a00      	cmp	r2, #0
    22fa:	db03      	blt.n	2304 <bitvec_lshift+0x10>
    22fc:	ea4f 1c6c 	mov.w	ip, ip, asr #5

  /* Shift whole words first if nwords > 0 */
  int i,j;
  for (i = 0; i < nwords; ++i)
    2300:	2300      	movs	r3, #0
    2302:	e006      	b.n	2312 <bitvec_lshift+0x1e>
  int nwords = (nbits / 32);
    2304:	f102 0c1f 	add.w	ip, r2, #31
    2308:	e7f8      	b.n	22fc <bitvec_lshift+0x8>
  {
    /* Zero-initialize from least-significant word until offset reached */
    x[i] = 0;
    230a:	2400      	movs	r4, #0
    230c:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
  for (i = 0; i < nwords; ++i)
    2310:	3301      	adds	r3, #1
    2312:	4563      	cmp	r3, ip
    2314:	dbf9      	blt.n	230a <bitvec_lshift+0x16>
  }
  j = 0;
    2316:	f04f 0c00 	mov.w	ip, #0
    231a:	e006      	b.n	232a <bitvec_lshift+0x36>
  /* Copy to x output */
  while (i < BITVEC_NWORDS)
  {
    x[i] = y[j];
    231c:	f851 402c 	ldr.w	r4, [r1, ip, lsl #2]
    2320:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
    i += 1;
    2324:	3301      	adds	r3, #1
    j += 1;
    2326:	f10c 0c01 	add.w	ip, ip, #1
  while (i < BITVEC_NWORDS)
    232a:	2b05      	cmp	r3, #5
    232c:	ddf6      	ble.n	231c <bitvec_lshift+0x28>
  }

  /* Shift the rest if count was not multiple of bitsize of DTYPE */
  nbits &= 31;
  if (nbits != 0)
    232e:	f012 021f 	ands.w	r2, r2, #31
    2332:	d117      	bne.n	2364 <bitvec_lshift+0x70>
    {
      x[i]  = (x[i] << nbits) | (x[i - 1] >> (32 - nbits));
    }
    x[0] <<= nbits;
  }
}
    2334:	bc10      	pop	{r4}
    2336:	4770      	bx	lr
      x[i]  = (x[i] << nbits) | (x[i - 1] >> (32 - nbits));
    2338:	f850 1023 	ldr.w	r1, [r0, r3, lsl #2]
    233c:	4091      	lsls	r1, r2
    233e:	f103 4480 	add.w	r4, r3, #1073741824	@ 0x40000000
    2342:	3c01      	subs	r4, #1
    2344:	f850 4024 	ldr.w	r4, [r0, r4, lsl #2]
    2348:	f1c2 0c20 	rsb	ip, r2, #32
    234c:	fa24 f40c 	lsr.w	r4, r4, ip
    2350:	4321      	orrs	r1, r4
    2352:	f840 1023 	str.w	r1, [r0, r3, lsl #2]
    for (i = (BITVEC_NWORDS - 1); i > 0; --i)
    2356:	3b01      	subs	r3, #1
    2358:	2b00      	cmp	r3, #0
    235a:	dced      	bgt.n	2338 <bitvec_lshift+0x44>
    x[0] <<= nbits;
    235c:	6803      	ldr	r3, [r0, #0]
    235e:	4093      	lsls	r3, r2
    2360:	6003      	str	r3, [r0, #0]
}
    2362:	e7e7      	b.n	2334 <bitvec_lshift+0x40>
    for (i = (BITVEC_NWORDS - 1); i > 0; --i)
    2364:	2305      	movs	r3, #5
    2366:	e7f7      	b.n	2358 <bitvec_lshift+0x64>

00002368 <gf2field_set_one>:


static void gf2field_set_one(gf2elem_t x)
{
  /* Set first word to one */
  x[0] = 1;
    2368:	2301      	movs	r3, #1
    236a:	6003      	str	r3, [r0, #0]
  /* .. and the rest to zero */
  int i;
  for (i = 1; i < BITVEC_NWORDS; ++i)
    236c:	e003      	b.n	2376 <gf2field_set_one+0xe>
  {
    x[i] = 0;
    236e:	2200      	movs	r2, #0
    2370:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
  for (i = 1; i < BITVEC_NWORDS; ++i)
    2374:	3301      	adds	r3, #1
    2376:	2b05      	cmp	r3, #5
    2378:	ddf9      	ble.n	236e <gf2field_set_one+0x6>
  }
}
    237a:	4770      	bx	lr

0000237c <gf2field_is_one>:
#if defined(CONST_TIME) && (CONST_TIME == 0)
/* fastest check if x == 1 */
static int gf2field_is_one(const gf2elem_t x) 
{
  /* Check if first word == 1 */
  if (x[0] != 1)
    237c:	6803      	ldr	r3, [r0, #0]
    237e:	2b01      	cmp	r3, #1
    2380:	d10b      	bne.n	239a <gf2field_is_one+0x1e>
  {
    return 0;
  }
  /* ...and if rest of words == 0 */
  int i;
  for (i = 1; i < BITVEC_NWORDS; ++i)
    2382:	2b05      	cmp	r3, #5
    2384:	dc04      	bgt.n	2390 <gf2field_is_one+0x14>
  {
    if (x[i] != 0)
    2386:	f850 2023 	ldr.w	r2, [r0, r3, lsl #2]
    238a:	b90a      	cbnz	r2, 2390 <gf2field_is_one+0x14>
  for (i = 1; i < BITVEC_NWORDS; ++i)
    238c:	3301      	adds	r3, #1
    238e:	e7f8      	b.n	2382 <gf2field_is_one+0x6>
    {
      break;
    }
  }
  return (i == BITVEC_NWORDS);
    2390:	2b06      	cmp	r3, #6
    2392:	bf14      	ite	ne
    2394:	2000      	movne	r0, #0
    2396:	2001      	moveq	r0, #1
    2398:	4770      	bx	lr
    return 0;
    239a:	2000      	movs	r0, #0
}
    239c:	4770      	bx	lr

0000239e <gf2field_add>:

/* galois field(2^m) addition is modulo 2, so XOR is used instead - 'z := a + b' */
static void gf2field_add(gf2elem_t z, const gf2elem_t x, const gf2elem_t y)
{
  int i;
  for (i = 0; i < BITVEC_NWORDS; ++i)
    239e:	2300      	movs	r3, #0
    23a0:	2b05      	cmp	r3, #5
    23a2:	dc0c      	bgt.n	23be <gf2field_add+0x20>
{
    23a4:	b430      	push	{r4, r5}
  {
    z[i] = (x[i] ^ y[i]);
    23a6:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
    23aa:	f851 5023 	ldr.w	r5, [r1, r3, lsl #2]
    23ae:	406c      	eors	r4, r5
    23b0:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
  for (i = 0; i < BITVEC_NWORDS; ++i)
    23b4:	3301      	adds	r3, #1
    23b6:	2b05      	cmp	r3, #5
    23b8:	ddf5      	ble.n	23a6 <gf2field_add+0x8>
  }
}
    23ba:	bc30      	pop	{r4, r5}
    23bc:	4770      	bx	lr
    23be:	4770      	bx	lr

000023c0 <gf2field_inc>:

/* increment element */
static void gf2field_inc(gf2elem_t x)
{
  x[0] ^= 1;
    23c0:	6803      	ldr	r3, [r0, #0]
    23c2:	f083 0301 	eor.w	r3, r3, #1
    23c6:	6003      	str	r3, [r0, #0]
}
    23c8:	4770      	bx	lr

000023ca <gf2field_mul>:


/* field multiplication 'z := (x * y)' */
static void gf2field_mul(gf2elem_t z, const gf2elem_t x, const gf2elem_t y)
{
    23ca:	b570      	push	{r4, r5, r6, lr}
    23cc:	b086      	sub	sp, #24
    23ce:	4606      	mov	r6, r0
    23d0:	460c      	mov	r4, r1
    23d2:	4615      	mov	r5, r2
#if defined(CONST_TIME) && (CONST_TIME == 1)
  gf2elem_t blind;
  bitvec_set_zero(blind);
#endif

  bitvec_copy(tmp, x);
    23d4:	4668      	mov	r0, sp
    23d6:	f7ff ff37 	bl	2248 <bitvec_copy>

  /* LSB set? Then start with x */
  if (bitvec_get_bit(y, 0) != 0)
    23da:	2100      	movs	r1, #0
    23dc:	4628      	mov	r0, r5
    23de:	f7ff ff1d 	bl	221c <bitvec_get_bit>
    23e2:	b128      	cbz	r0, 23f0 <gf2field_mul+0x26>
  {
    bitvec_copy(z, x);
    23e4:	4621      	mov	r1, r4
    23e6:	4630      	mov	r0, r6
    23e8:	f7ff ff2e 	bl	2248 <bitvec_copy>
{
    23ec:	2401      	movs	r4, #1
    23ee:	e00a      	b.n	2406 <gf2field_mul+0x3c>
  }
  else /* .. or else start with zero */
  {
    bitvec_set_zero(z);
    23f0:	4630      	mov	r0, r6
    23f2:	f7ff ff54 	bl	229e <bitvec_set_zero>
    23f6:	e7f9      	b.n	23ec <gf2field_mul+0x22>
    bitvec_lshift(tmp, tmp, 1);

    /* Modulo reduction polynomial if degree(tmp) > CURVE_DEGREE */
    if (bitvec_get_bit(tmp, CURVE_DEGREE))
    {
      gf2field_add(tmp, tmp, polynomial);
    23f8:	4a10      	ldr	r2, [pc, #64]	@ (243c <gf2field_mul+0x72>)
    23fa:	4669      	mov	r1, sp
    23fc:	4668      	mov	r0, sp
    23fe:	f7ff ffce 	bl	239e <gf2field_add>
    2402:	e00d      	b.n	2420 <gf2field_mul+0x56>
  for (i = 1; i < CURVE_DEGREE; ++i)
    2404:	3401      	adds	r4, #1
    2406:	2ca2      	cmp	r4, #162	@ 0xa2
    2408:	dc16      	bgt.n	2438 <gf2field_mul+0x6e>
    bitvec_lshift(tmp, tmp, 1);
    240a:	2201      	movs	r2, #1
    240c:	4669      	mov	r1, sp
    240e:	4668      	mov	r0, sp
    2410:	f7ff ff70 	bl	22f4 <bitvec_lshift>
    if (bitvec_get_bit(tmp, CURVE_DEGREE))
    2414:	21a3      	movs	r1, #163	@ 0xa3
    2416:	4668      	mov	r0, sp
    2418:	f7ff ff00 	bl	221c <bitvec_get_bit>
    241c:	2800      	cmp	r0, #0
    241e:	d1eb      	bne.n	23f8 <gf2field_mul+0x2e>
      gf2field_add(tmp, tmp, blind);
    }
#endif

    /* Add 2^i * tmp if this factor in y is non-zero */
    if (bitvec_get_bit(y, i))
    2420:	4621      	mov	r1, r4
    2422:	4628      	mov	r0, r5
    2424:	f7ff fefa 	bl	221c <bitvec_get_bit>
    2428:	2800      	cmp	r0, #0
    242a:	d0eb      	beq.n	2404 <gf2field_mul+0x3a>
    {
      gf2field_add(z, z, tmp);
    242c:	466a      	mov	r2, sp
    242e:	4631      	mov	r1, r6
    2430:	4630      	mov	r0, r6
    2432:	f7ff ffb4 	bl	239e <gf2field_add>
    2436:	e7e5      	b.n	2404 <gf2field_mul+0x3a>
    {
      gf2field_add(z, z, blind);
    }
#endif
  }
}
    2438:	b006      	add	sp, #24
    243a:	bd70      	pop	{r4, r5, r6, pc}
    243c:	00003820 	andeq	r3, r0, r0, lsr #16

00002440 <gf2field_inv>:

/* field inversion 'z := 1/x' */
static void gf2field_inv(gf2elem_t z, const gf2elem_t x)
{
    2440:	b5f0      	push	{r4, r5, r6, r7, lr}
    2442:	b099      	sub	sp, #100	@ 0x64
    2444:	4607      	mov	r7, r0
  gf2elem_t u, v, g, h;
  int i;

  bitvec_copy(u, x);
    2446:	a812      	add	r0, sp, #72	@ 0x48
    2448:	f7ff fefe 	bl	2248 <bitvec_copy>
  bitvec_copy(v, polynomial);
    244c:	491c      	ldr	r1, [pc, #112]	@ (24c0 <gf2field_inv+0x80>)
    244e:	a80c      	add	r0, sp, #48	@ 0x30
    2450:	f7ff fefa 	bl	2248 <bitvec_copy>
  bitvec_set_zero(g);
    2454:	a806      	add	r0, sp, #24
    2456:	f7ff ff22 	bl	229e <bitvec_set_zero>
  gf2field_set_one(z);
    245a:	4638      	mov	r0, r7
    245c:	f7ff ff84 	bl	2368 <gf2field_set_one>
  
  while (!gf2field_is_one(u))
    2460:	e013      	b.n	248a <gf2field_inv+0x4a>
    {
      bitvec_swap(u, v);
      bitvec_swap(v, u);
    }
#endif
    bitvec_lshift(h, v, i);
    2462:	4632      	mov	r2, r6
    2464:	a90c      	add	r1, sp, #48	@ 0x30
    2466:	4668      	mov	r0, sp
    2468:	f7ff ff44 	bl	22f4 <bitvec_lshift>
    gf2field_add(u, u, h);
    246c:	466a      	mov	r2, sp
    246e:	a912      	add	r1, sp, #72	@ 0x48
    2470:	4608      	mov	r0, r1
    2472:	f7ff ff94 	bl	239e <gf2field_add>
    bitvec_lshift(h, g, i);
    2476:	4632      	mov	r2, r6
    2478:	a906      	add	r1, sp, #24
    247a:	4668      	mov	r0, sp
    247c:	f7ff ff3a 	bl	22f4 <bitvec_lshift>
    gf2field_add(z, z, h);
    2480:	466a      	mov	r2, sp
    2482:	4639      	mov	r1, r7
    2484:	4638      	mov	r0, r7
    2486:	f7ff ff8a 	bl	239e <gf2field_add>
  while (!gf2field_is_one(u))
    248a:	a812      	add	r0, sp, #72	@ 0x48
    248c:	f7ff ff76 	bl	237c <gf2field_is_one>
    2490:	b998      	cbnz	r0, 24ba <gf2field_inv+0x7a>
    i = (bitvec_degree(u) - bitvec_degree(v));
    2492:	a812      	add	r0, sp, #72	@ 0x48
    2494:	f7ff ff19 	bl	22ca <bitvec_degree>
    2498:	4604      	mov	r4, r0
    249a:	a80c      	add	r0, sp, #48	@ 0x30
    249c:	f7ff ff15 	bl	22ca <bitvec_degree>
    24a0:	4605      	mov	r5, r0
    if (i < 0)
    24a2:	1a26      	subs	r6, r4, r0
    24a4:	d5dd      	bpl.n	2462 <gf2field_inv+0x22>
      bitvec_swap(u, v);
    24a6:	a90c      	add	r1, sp, #48	@ 0x30
    24a8:	a812      	add	r0, sp, #72	@ 0x48
    24aa:	f7ff fed7 	bl	225c <bitvec_swap>
      bitvec_swap(g, z);
    24ae:	4639      	mov	r1, r7
    24b0:	a806      	add	r0, sp, #24
    24b2:	f7ff fed3 	bl	225c <bitvec_swap>
      i = -i;
    24b6:	1b2e      	subs	r6, r5, r4
    24b8:	e7d3      	b.n	2462 <gf2field_inv+0x22>
  }
}
    24ba:	b019      	add	sp, #100	@ 0x64
    24bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    24be:	bf00      	nop
    24c0:	00003820 	andeq	r3, r0, r0, lsr #16

000024c4 <gf2point_copy>:
*/
/*************************************************************************************************/


static void gf2point_copy(gf2elem_t x1, gf2elem_t y1, const gf2elem_t x2, const gf2elem_t y2)
{
    24c4:	b538      	push	{r3, r4, r5, lr}
    24c6:	460c      	mov	r4, r1
    24c8:	461d      	mov	r5, r3
  bitvec_copy(x1, x2);
    24ca:	4611      	mov	r1, r2
    24cc:	f7ff febc 	bl	2248 <bitvec_copy>
  bitvec_copy(y1, y2);
    24d0:	4629      	mov	r1, r5
    24d2:	4620      	mov	r0, r4
    24d4:	f7ff feb8 	bl	2248 <bitvec_copy>
}
    24d8:	bd38      	pop	{r3, r4, r5, pc}

000024da <gf2point_set_zero>:

static void gf2point_set_zero(gf2elem_t x, gf2elem_t y)
{
    24da:	b510      	push	{r4, lr}
    24dc:	460c      	mov	r4, r1
  bitvec_set_zero(x);
    24de:	f7ff fede 	bl	229e <bitvec_set_zero>
  bitvec_set_zero(y);
    24e2:	4620      	mov	r0, r4
    24e4:	f7ff fedb 	bl	229e <bitvec_set_zero>
}
    24e8:	bd10      	pop	{r4, pc}

000024ea <gf2point_is_zero>:

static int gf2point_is_zero(const gf2elem_t x, const gf2elem_t y)
{
    24ea:	b510      	push	{r4, lr}
    24ec:	460c      	mov	r4, r1
  return (    bitvec_is_zero(x)
    24ee:	f7ff fedf 	bl	22b0 <bitvec_is_zero>
           && bitvec_is_zero(y));
    24f2:	b120      	cbz	r0, 24fe <gf2point_is_zero+0x14>
    24f4:	4620      	mov	r0, r4
    24f6:	f7ff fedb 	bl	22b0 <bitvec_is_zero>
    24fa:	b100      	cbz	r0, 24fe <gf2point_is_zero+0x14>
    24fc:	2001      	movs	r0, #1
}
    24fe:	bd10      	pop	{r4, pc}

00002500 <gf2point_double>:

/* double the point (x,y) */
static void gf2point_double(gf2elem_t x, gf2elem_t y)
{
    2500:	b530      	push	{r4, r5, lr}
    2502:	b087      	sub	sp, #28
    2504:	4604      	mov	r4, r0
    2506:	460d      	mov	r5, r1
  /* iff P = O (zero or infinity): 2 * P = P */
  if (bitvec_is_zero(x))
    2508:	f7ff fed2 	bl	22b0 <bitvec_is_zero>
    250c:	b120      	cbz	r0, 2518 <gf2point_double+0x18>
  {
    bitvec_set_zero(y);
    250e:	4628      	mov	r0, r5
    2510:	f7ff fec5 	bl	229e <bitvec_set_zero>
#endif
    gf2field_add(x, x, l);
    gf2field_mul(l, l, x);
    gf2field_add(y, y, l);
  }
}
    2514:	b007      	add	sp, #28
    2516:	bd30      	pop	{r4, r5, pc}
    gf2field_inv(l, x);
    2518:	4621      	mov	r1, r4
    251a:	4668      	mov	r0, sp
    251c:	f7ff ff90 	bl	2440 <gf2field_inv>
    gf2field_mul(l, l, y);
    2520:	462a      	mov	r2, r5
    2522:	4669      	mov	r1, sp
    2524:	4668      	mov	r0, sp
    2526:	f7ff ff50 	bl	23ca <gf2field_mul>
    gf2field_add(l, l, x);
    252a:	4622      	mov	r2, r4
    252c:	4669      	mov	r1, sp
    252e:	4668      	mov	r0, sp
    2530:	f7ff ff35 	bl	239e <gf2field_add>
    gf2field_mul(y, x, x);
    2534:	4622      	mov	r2, r4
    2536:	4621      	mov	r1, r4
    2538:	4628      	mov	r0, r5
    253a:	f7ff ff46 	bl	23ca <gf2field_mul>
    gf2field_mul(x, l, l);
    253e:	466a      	mov	r2, sp
    2540:	4669      	mov	r1, sp
    2542:	4620      	mov	r0, r4
    2544:	f7ff ff41 	bl	23ca <gf2field_mul>
    gf2field_inc(l);
    2548:	4668      	mov	r0, sp
    254a:	f7ff ff39 	bl	23c0 <gf2field_inc>
    gf2field_add(x, x, l);
    254e:	466a      	mov	r2, sp
    2550:	4621      	mov	r1, r4
    2552:	4620      	mov	r0, r4
    2554:	f7ff ff23 	bl	239e <gf2field_add>
    gf2field_mul(l, l, x);
    2558:	4622      	mov	r2, r4
    255a:	4669      	mov	r1, sp
    255c:	4668      	mov	r0, sp
    255e:	f7ff ff34 	bl	23ca <gf2field_mul>
    gf2field_add(y, y, l);
    2562:	466a      	mov	r2, sp
    2564:	4629      	mov	r1, r5
    2566:	4628      	mov	r0, r5
    2568:	f7ff ff19 	bl	239e <gf2field_add>
}
    256c:	e7d2      	b.n	2514 <gf2point_double+0x14>

0000256e <gf2point_add>:


/* add two points together (x1, y1) := (x1, y1) + (x2, y2) */
static void gf2point_add(gf2elem_t x1, gf2elem_t y1, const gf2elem_t x2, const gf2elem_t y2)
{
    256e:	b5f0      	push	{r4, r5, r6, r7, lr}
    2570:	b099      	sub	sp, #100	@ 0x64
    2572:	4604      	mov	r4, r0
    2574:	460f      	mov	r7, r1
    2576:	4615      	mov	r5, r2
    2578:	461e      	mov	r6, r3
  if (!gf2point_is_zero(x2, y2))
    257a:	4619      	mov	r1, r3
    257c:	4610      	mov	r0, r2
    257e:	f7ff ffb4 	bl	24ea <gf2point_is_zero>
    2582:	b9c8      	cbnz	r0, 25b8 <gf2point_add+0x4a>
  {
    if (gf2point_is_zero(x1, y1))
    2584:	4639      	mov	r1, r7
    2586:	4620      	mov	r0, r4
    2588:	f7ff ffaf 	bl	24ea <gf2point_is_zero>
    258c:	b970      	cbnz	r0, 25ac <gf2point_add+0x3e>
    {
      gf2point_copy(x1, y1, x2, y2);
    }
    else
    {
      if (bitvec_equal(x1, x2))
    258e:	4629      	mov	r1, r5
    2590:	4620      	mov	r0, r4
    2592:	f7ff fe75 	bl	2280 <bitvec_equal>
    2596:	b1b0      	cbz	r0, 25c6 <gf2point_add+0x58>
      {
        if (bitvec_equal(y1, y2))
    2598:	4631      	mov	r1, r6
    259a:	4638      	mov	r0, r7
    259c:	f7ff fe70 	bl	2280 <bitvec_equal>
    25a0:	b160      	cbz	r0, 25bc <gf2point_add+0x4e>
        {
          gf2point_double(x1, y1);
    25a2:	4639      	mov	r1, r7
    25a4:	4620      	mov	r0, r4
    25a6:	f7ff ffab 	bl	2500 <gf2point_double>
    25aa:	e005      	b.n	25b8 <gf2point_add+0x4a>
      gf2point_copy(x1, y1, x2, y2);
    25ac:	4633      	mov	r3, r6
    25ae:	462a      	mov	r2, r5
    25b0:	4639      	mov	r1, r7
    25b2:	4620      	mov	r0, r4
    25b4:	f7ff ff86 	bl	24c4 <gf2point_copy>
        gf2field_add(y1, y1, a);
        bitvec_copy(x1, d);
      }
    }
  }
}
    25b8:	b019      	add	sp, #100	@ 0x64
    25ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
          gf2point_set_zero(x1, y1);
    25bc:	4639      	mov	r1, r7
    25be:	4620      	mov	r0, r4
    25c0:	f7ff ff8b 	bl	24da <gf2point_set_zero>
    25c4:	e7f8      	b.n	25b8 <gf2point_add+0x4a>
        gf2field_add(a, y1, y2);
    25c6:	4632      	mov	r2, r6
    25c8:	4639      	mov	r1, r7
    25ca:	4668      	mov	r0, sp
    25cc:	f7ff fee7 	bl	239e <gf2field_add>
        gf2field_add(b, x1, x2);
    25d0:	462a      	mov	r2, r5
    25d2:	4621      	mov	r1, r4
    25d4:	a806      	add	r0, sp, #24
    25d6:	f7ff fee2 	bl	239e <gf2field_add>
        gf2field_inv(c, b);
    25da:	a906      	add	r1, sp, #24
    25dc:	a80c      	add	r0, sp, #48	@ 0x30
    25de:	f7ff ff2f 	bl	2440 <gf2field_inv>
        gf2field_mul(c, c, a);
    25e2:	466a      	mov	r2, sp
    25e4:	a90c      	add	r1, sp, #48	@ 0x30
    25e6:	4608      	mov	r0, r1
    25e8:	f7ff feef 	bl	23ca <gf2field_mul>
        gf2field_mul(d, c, c);
    25ec:	aa0c      	add	r2, sp, #48	@ 0x30
    25ee:	4611      	mov	r1, r2
    25f0:	a812      	add	r0, sp, #72	@ 0x48
    25f2:	f7ff feea 	bl	23ca <gf2field_mul>
        gf2field_add(d, d, c);
    25f6:	aa0c      	add	r2, sp, #48	@ 0x30
    25f8:	a912      	add	r1, sp, #72	@ 0x48
    25fa:	4608      	mov	r0, r1
    25fc:	f7ff fecf 	bl	239e <gf2field_add>
        gf2field_add(d, d, b);
    2600:	aa06      	add	r2, sp, #24
    2602:	a912      	add	r1, sp, #72	@ 0x48
    2604:	4608      	mov	r0, r1
    2606:	f7ff feca 	bl	239e <gf2field_add>
        gf2field_inc(d);
    260a:	a812      	add	r0, sp, #72	@ 0x48
    260c:	f7ff fed8 	bl	23c0 <gf2field_inc>
        gf2field_add(x1, x1, d);
    2610:	aa12      	add	r2, sp, #72	@ 0x48
    2612:	4621      	mov	r1, r4
    2614:	4620      	mov	r0, r4
    2616:	f7ff fec2 	bl	239e <gf2field_add>
        gf2field_mul(a, x1, c);
    261a:	aa0c      	add	r2, sp, #48	@ 0x30
    261c:	4621      	mov	r1, r4
    261e:	4668      	mov	r0, sp
    2620:	f7ff fed3 	bl	23ca <gf2field_mul>
        gf2field_add(a, a, d);
    2624:	aa12      	add	r2, sp, #72	@ 0x48
    2626:	4669      	mov	r1, sp
    2628:	4668      	mov	r0, sp
    262a:	f7ff feb8 	bl	239e <gf2field_add>
        gf2field_add(y1, y1, a);
    262e:	466a      	mov	r2, sp
    2630:	4639      	mov	r1, r7
    2632:	4638      	mov	r0, r7
    2634:	f7ff feb3 	bl	239e <gf2field_add>
        bitvec_copy(x1, d);
    2638:	a912      	add	r1, sp, #72	@ 0x48
    263a:	4620      	mov	r0, r4
    263c:	f7ff fe04 	bl	2248 <bitvec_copy>
}
    2640:	e7ba      	b.n	25b8 <gf2point_add+0x4a>

00002642 <gf2point_mul>:


#if defined(CONST_TIME) && (CONST_TIME == 0)
/* point multiplication via double-and-add algorithm */
static void gf2point_mul(gf2elem_t x, gf2elem_t y, const scalar_t exp)
{
    2642:	b5f0      	push	{r4, r5, r6, r7, lr}
    2644:	b08d      	sub	sp, #52	@ 0x34
    2646:	4606      	mov	r6, r0
    2648:	460f      	mov	r7, r1
    264a:	4615      	mov	r5, r2
  gf2elem_t tmpx, tmpy;
  int i;
  int nbits = bitvec_degree(exp);
    264c:	4610      	mov	r0, r2
    264e:	f7ff fe3c 	bl	22ca <bitvec_degree>
    2652:	4604      	mov	r4, r0

  gf2point_set_zero(tmpx, tmpy);
    2654:	4669      	mov	r1, sp
    2656:	a806      	add	r0, sp, #24
    2658:	f7ff ff3f 	bl	24da <gf2point_set_zero>

  for (i = (nbits - 1); i >= 0; --i)
    265c:	3c01      	subs	r4, #1
    265e:	e000      	b.n	2662 <gf2point_mul+0x20>
    2660:	3c01      	subs	r4, #1
    2662:	2c00      	cmp	r4, #0
    2664:	db10      	blt.n	2688 <gf2point_mul+0x46>
  {
    gf2point_double(tmpx, tmpy);
    2666:	4669      	mov	r1, sp
    2668:	a806      	add	r0, sp, #24
    266a:	f7ff ff49 	bl	2500 <gf2point_double>
    if (bitvec_get_bit(exp, i))
    266e:	4621      	mov	r1, r4
    2670:	4628      	mov	r0, r5
    2672:	f7ff fdd3 	bl	221c <bitvec_get_bit>
    2676:	2800      	cmp	r0, #0
    2678:	d0f2      	beq.n	2660 <gf2point_mul+0x1e>
    {
      gf2point_add(tmpx, tmpy, x, y);
    267a:	463b      	mov	r3, r7
    267c:	4632      	mov	r2, r6
    267e:	4669      	mov	r1, sp
    2680:	a806      	add	r0, sp, #24
    2682:	f7ff ff74 	bl	256e <gf2point_add>
    2686:	e7eb      	b.n	2660 <gf2point_mul+0x1e>
    }
  }
  gf2point_copy(x, y, tmpx, tmpy);
    2688:	466b      	mov	r3, sp
    268a:	aa06      	add	r2, sp, #24
    268c:	4639      	mov	r1, r7
    268e:	4630      	mov	r0, r6
    2690:	f7ff ff18 	bl	24c4 <gf2point_copy>
}
    2694:	b00d      	add	sp, #52	@ 0x34
    2696:	bdf0      	pop	{r4, r5, r6, r7, pc}

00002698 <gf2point_on_curve>:



/* check if y^2 + x*y = x^3 + a*x^2 + coeff_b holds */
static int gf2point_on_curve(const gf2elem_t x, const gf2elem_t y)
{
    2698:	b530      	push	{r4, r5, lr}
    269a:	b08d      	sub	sp, #52	@ 0x34
    269c:	4604      	mov	r4, r0
    269e:	460d      	mov	r5, r1
  gf2elem_t a, b;

  if (gf2point_is_zero(x, y))
    26a0:	f7ff ff23 	bl	24ea <gf2point_is_zero>
    26a4:	b110      	cbz	r0, 26ac <gf2point_on_curve+0x14>
  {
    return 1;
    26a6:	2001      	movs	r0, #1
    gf2field_add(a, a, b);
    gf2field_mul(b, x, y);

    return bitvec_equal(a, b);
  }
}
    26a8:	b00d      	add	sp, #52	@ 0x34
    26aa:	bd30      	pop	{r4, r5, pc}
    gf2field_mul(a, x, x);
    26ac:	4622      	mov	r2, r4
    26ae:	4621      	mov	r1, r4
    26b0:	a806      	add	r0, sp, #24
    26b2:	f7ff fe8a 	bl	23ca <gf2field_mul>
    gf2field_mul(b, a, x);
    26b6:	4622      	mov	r2, r4
    26b8:	a906      	add	r1, sp, #24
    26ba:	4668      	mov	r0, sp
    26bc:	f7ff fe85 	bl	23ca <gf2field_mul>
    gf2field_add(a, a, b);
    26c0:	466a      	mov	r2, sp
    26c2:	a906      	add	r1, sp, #24
    26c4:	4608      	mov	r0, r1
    26c6:	f7ff fe6a 	bl	239e <gf2field_add>
    gf2field_add(a, a, coeff_b);
    26ca:	4a0c      	ldr	r2, [pc, #48]	@ (26fc <gf2point_on_curve+0x64>)
    26cc:	a906      	add	r1, sp, #24
    26ce:	4608      	mov	r0, r1
    26d0:	f7ff fe65 	bl	239e <gf2field_add>
    gf2field_mul(b, y, y);
    26d4:	462a      	mov	r2, r5
    26d6:	4629      	mov	r1, r5
    26d8:	4668      	mov	r0, sp
    26da:	f7ff fe76 	bl	23ca <gf2field_mul>
    gf2field_add(a, a, b);
    26de:	466a      	mov	r2, sp
    26e0:	a906      	add	r1, sp, #24
    26e2:	4608      	mov	r0, r1
    26e4:	f7ff fe5b 	bl	239e <gf2field_add>
    gf2field_mul(b, x, y);
    26e8:	462a      	mov	r2, r5
    26ea:	4621      	mov	r1, r4
    26ec:	4668      	mov	r0, sp
    26ee:	f7ff fe6c 	bl	23ca <gf2field_mul>
    return bitvec_equal(a, b);
    26f2:	4669      	mov	r1, sp
    26f4:	a806      	add	r0, sp, #24
    26f6:	f7ff fdc3 	bl	2280 <bitvec_equal>
    26fa:	e7d5      	b.n	26a8 <gf2point_on_curve+0x10>
    26fc:	00003838 	andeq	r3, r0, r8, lsr r8

00002700 <ecdh_generate_keys>:



/* NOTE: private should contain random data a-priori! */
int ecdh_generate_keys(uint8_t* public_key, uint8_t* private_key)
{
    2700:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2702:	4606      	mov	r6, r0
    2704:	460d      	mov	r5, r1
  /* Get copy of "base" point 'G' */
  gf2point_copy((uint32_t*)public_key, (uint32_t*)(public_key + BITVEC_NBYTES), base_x, base_y);
    2706:	f100 0718 	add.w	r7, r0, #24
    270a:	4a10      	ldr	r2, [pc, #64]	@ (274c <ecdh_generate_keys+0x4c>)
    270c:	f102 0330 	add.w	r3, r2, #48	@ 0x30
    2710:	3248      	adds	r2, #72	@ 0x48
    2712:	4639      	mov	r1, r7
    2714:	f7ff fed6 	bl	24c4 <gf2point_copy>

  /* Abort key generation if random number is too small */
  if (bitvec_degree((uint32_t*)private_key) < (CURVE_DEGREE / 2))
    2718:	4628      	mov	r0, r5
    271a:	f7ff fdd6 	bl	22ca <bitvec_degree>
    271e:	2850      	cmp	r0, #80	@ 0x50
    2720:	dd12      	ble.n	2748 <ecdh_generate_keys+0x48>
    return 0;
  }
  else
  {
    /* Clear bits > CURVE_DEGREE in highest word to satisfy constraint 1 <= exp < n. */
    int nbits = bitvec_degree(base_order);
    2722:	480b      	ldr	r0, [pc, #44]	@ (2750 <ecdh_generate_keys+0x50>)
    2724:	f7ff fdd1 	bl	22ca <bitvec_degree>
    int i;

    for (i = (nbits - 1); i < (BITVEC_NWORDS * 32); ++i)
    2728:	1e44      	subs	r4, r0, #1
    272a:	e004      	b.n	2736 <ecdh_generate_keys+0x36>
    {
      bitvec_clr_bit((uint32_t*)private_key, i);
    272c:	4621      	mov	r1, r4
    272e:	4628      	mov	r0, r5
    2730:	f7ff fd7d 	bl	222e <bitvec_clr_bit>
    for (i = (nbits - 1); i < (BITVEC_NWORDS * 32); ++i)
    2734:	3401      	adds	r4, #1
    2736:	2cbf      	cmp	r4, #191	@ 0xbf
    2738:	ddf8      	ble.n	272c <ecdh_generate_keys+0x2c>
    }

    /* Multiply base-point with scalar (private-key) */
    gf2point_mul((uint32_t*)public_key, (uint32_t*)(public_key + BITVEC_NBYTES), (uint32_t*)private_key);
    273a:	462a      	mov	r2, r5
    273c:	4639      	mov	r1, r7
    273e:	4630      	mov	r0, r6
    2740:	f7ff ff7f 	bl	2642 <gf2point_mul>

    return 1;
    2744:	2001      	movs	r0, #1
  }
}
    2746:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return 0;
    2748:	2000      	movs	r0, #0
    274a:	e7fc      	b.n	2746 <ecdh_generate_keys+0x46>
    274c:	00003820 	andeq	r3, r0, r0, lsr #16
    2750:	00003880 	andeq	r3, r0, r0, lsl #17

00002754 <ecdh_shared_secret>:



int ecdh_shared_secret(const uint8_t* private_key, const uint8_t* others_pub, uint8_t* output)
{
    2754:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2756:	4606      	mov	r6, r0
    2758:	460c      	mov	r4, r1
    275a:	4615      	mov	r5, r2
  /* Do some basic validation of other party's public key */
  if (    !gf2point_is_zero ((uint32_t*)others_pub, (uint32_t*)(others_pub + BITVEC_NBYTES))
    275c:	f101 0718 	add.w	r7, r1, #24
    2760:	4639      	mov	r1, r7
    2762:	4620      	mov	r0, r4
    2764:	f7ff fec1 	bl	24ea <gf2point_is_zero>
    2768:	b108      	cbz	r0, 276e <ecdh_shared_secret+0x1a>
    
    return 1;
  }
  else
  {
    return 0;
    276a:	2000      	movs	r0, #0
  }
}
    276c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
       &&  gf2point_on_curve((uint32_t*)others_pub, (uint32_t*)(others_pub + BITVEC_NBYTES)) )
    276e:	4639      	mov	r1, r7
    2770:	4620      	mov	r0, r4
    2772:	f7ff ff91 	bl	2698 <gf2point_on_curve>
    2776:	2800      	cmp	r0, #0
    2778:	d0f7      	beq.n	276a <ecdh_shared_secret+0x16>
    for (i = 0; i < (BITVEC_NBYTES * 2); ++i)
    277a:	2300      	movs	r3, #0
    277c:	e004      	b.n	2788 <ecdh_shared_secret+0x34>
      output[i] = others_pub[i];
    277e:	f814 c003 	ldrb.w	ip, [r4, r3]
    2782:	f805 c003 	strb.w	ip, [r5, r3]
    for (i = 0; i < (BITVEC_NBYTES * 2); ++i)
    2786:	3301      	adds	r3, #1
    2788:	2b2f      	cmp	r3, #47	@ 0x2f
    278a:	d9f8      	bls.n	277e <ecdh_shared_secret+0x2a>
    gf2point_mul((uint32_t*)output,(uint32_t*)(output + BITVEC_NBYTES), (const uint32_t*)private_key);
    278c:	4632      	mov	r2, r6
    278e:	f105 0118 	add.w	r1, r5, #24
    2792:	4628      	mov	r0, r5
    2794:	f7ff ff55 	bl	2642 <gf2point_mul>
    return 1;
    2798:	2001      	movs	r0, #1
    279a:	e7e7      	b.n	276c <ecdh_shared_secret+0x18>

0000279c <atoi>:
 * limitations under the License.
 **/

#include "a2i.h"

int atoi(const char* str) {
    279c:	4601      	mov	r1, r0
  int res = 0;
  for (int i = 0; str[i] != '\0'; ++i) {
    279e:	2200      	movs	r2, #0
  int res = 0;
    27a0:	4610      	mov	r0, r2
  for (int i = 0; str[i] != '\0'; ++i) {
    27a2:	e006      	b.n	27b2 <atoi+0x16>
    res = res * 10 + str[i] - '0';
    27a4:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    27a8:	eb03 0340 	add.w	r3, r3, r0, lsl #1
    27ac:	f1a3 0030 	sub.w	r0, r3, #48	@ 0x30
  for (int i = 0; str[i] != '\0'; ++i) {
    27b0:	3201      	adds	r2, #1
    27b2:	5c8b      	ldrb	r3, [r1, r2]
    27b4:	2b00      	cmp	r3, #0
    27b6:	d1f5      	bne.n	27a4 <atoi+0x8>
  }
  return res;
}
    27b8:	4770      	bx	lr

000027ba <atoh>:

uint32_t atoh(const char* str) {
    27ba:	4684      	mov	ip, r0
  uint32_t hex = 0;
  uint32_t value = 0;

  for (uint32_t i = 0; str[i] != '\0'; i++) {
    27bc:	2100      	movs	r1, #0
  uint32_t hex = 0;
    27be:	4608      	mov	r0, r1
  for (uint32_t i = 0; str[i] != '\0'; i++) {
    27c0:	e008      	b.n	27d4 <atoh+0x1a>
    if (str[i] >= '0' && str[i] <= '9') {
      value = str[i] - '0';
    } else if (str[i] >= 'a' && str[i] <= 'f') {
    27c2:	f1a3 0261 	sub.w	r2, r3, #97	@ 0x61
    27c6:	b2d2      	uxtb	r2, r2
    27c8:	2a05      	cmp	r2, #5
    27ca:	d80d      	bhi.n	27e8 <atoh+0x2e>
      value = str[i] - 'a' + 10;
    27cc:	3b57      	subs	r3, #87	@ 0x57
      continue;
    }

    // make space for the new nibble on the right
    hex = hex << 4;
    hex |= value;
    27ce:	ea43 1000 	orr.w	r0, r3, r0, lsl #4
  for (uint32_t i = 0; str[i] != '\0'; i++) {
    27d2:	3101      	adds	r1, #1
    27d4:	f81c 3001 	ldrb.w	r3, [ip, r1]
    27d8:	b16b      	cbz	r3, 27f6 <atoh+0x3c>
    if (str[i] >= '0' && str[i] <= '9') {
    27da:	f1a3 0230 	sub.w	r2, r3, #48	@ 0x30
    27de:	b2d2      	uxtb	r2, r2
    27e0:	2a09      	cmp	r2, #9
    27e2:	d8ee      	bhi.n	27c2 <atoh+0x8>
      value = str[i] - '0';
    27e4:	3b30      	subs	r3, #48	@ 0x30
    27e6:	e7f2      	b.n	27ce <atoh+0x14>
    } else if (str[i] >= 'A' && str[i] <= 'F') {
    27e8:	f1a3 0241 	sub.w	r2, r3, #65	@ 0x41
    27ec:	b2d2      	uxtb	r2, r2
    27ee:	2a05      	cmp	r2, #5
    27f0:	d8ef      	bhi.n	27d2 <atoh+0x18>
      value = str[i] - 'A' + 10;
    27f2:	3b37      	subs	r3, #55	@ 0x37
    27f4:	e7eb      	b.n	27ce <atoh+0x14>
  }

  return hex;
}
    27f6:	4770      	bx	lr

000027f8 <memlog_init>:

void memlog_init(uint8_t *addr, uint32_t size, mode_t mode) {
  selected_mode = mode;
    27f8:	4b0e      	ldr	r3, [pc, #56]	@ (2834 <memlog_init+0x3c>)
    27fa:	701a      	strb	r2, [r3, #0]

  if (selected_mode == NONE) {
    27fc:	b1ca      	cbz	r2, 2832 <memlog_init+0x3a>
void memlog_init(uint8_t *addr, uint32_t size, mode_t mode) {
    27fe:	b570      	push	{r4, r5, r6, lr}
    return;
  }

  out_buf_rgn.addr = addr;
    2800:	6058      	str	r0, [r3, #4]
  out_buf_rgn.size = size / 2;
    2802:	084c      	lsrs	r4, r1, #1
    2804:	609c      	str	r4, [r3, #8]
  out_buf_rgn.curr_index = 0;
    2806:	2500      	movs	r5, #0
    2808:	60dd      	str	r5, [r3, #12]

  inp_buf_rgn.addr = addr + size / 2;
    280a:	1906      	adds	r6, r0, r4
    280c:	611e      	str	r6, [r3, #16]
  inp_buf_rgn.size = size / 2;
    280e:	615c      	str	r4, [r3, #20]
  inp_buf_rgn.curr_index = 0;
    2810:	619d      	str	r5, [r3, #24]

  if (!(selected_mode & INP)) {
    2812:	f012 0f01 	tst.w	r2, #1
    2816:	d105      	bne.n	2824 <memlog_init+0x2c>
    // No input, use the extra memory for output.

    out_buf_rgn.size = size;
    2818:	6099      	str	r1, [r3, #8]

    inp_buf_rgn.addr = addr;
    inp_buf_rgn.size = size;
  }

  memset(addr, 0, size);
    281a:	460a      	mov	r2, r1
    281c:	2100      	movs	r1, #0
    281e:	f000 f869 	bl	28f4 <memset>
}
    2822:	bd70      	pop	{r4, r5, r6, pc}
  } else if (!(selected_mode & OUT)) {
    2824:	f012 0f02 	tst.w	r2, #2
    2828:	d1f7      	bne.n	281a <memlog_init+0x22>
    inp_buf_rgn.addr = addr;
    282a:	4b02      	ldr	r3, [pc, #8]	@ (2834 <memlog_init+0x3c>)
    282c:	6118      	str	r0, [r3, #16]
    inp_buf_rgn.size = size;
    282e:	6159      	str	r1, [r3, #20]
    2830:	e7f3      	b.n	281a <memlog_init+0x22>
    2832:	4770      	bx	lr
    2834:	2000032c 	andcs	r0, r0, ip, lsr #6

00002838 <memlog_getc>:

int memlog_getc() {
  if (!(selected_mode & INP)) {
    2838:	4b0e      	ldr	r3, [pc, #56]	@ (2874 <memlog_getc+0x3c>)
    283a:	781b      	ldrb	r3, [r3, #0]
    283c:	f013 0f01 	tst.w	r3, #1
    2840:	d012      	beq.n	2868 <memlog_getc+0x30>
    return -1;
  }

  if (inp_buf_rgn.addr[inp_buf_rgn.curr_index] == 0) {
    2842:	4b0c      	ldr	r3, [pc, #48]	@ (2874 <memlog_getc+0x3c>)
    2844:	691a      	ldr	r2, [r3, #16]
    2846:	699b      	ldr	r3, [r3, #24]
    2848:	5cd1      	ldrb	r1, [r2, r3]
    284a:	b181      	cbz	r1, 286e <memlog_getc+0x36>
    return -1;
  }

  int val = inp_buf_rgn.addr[inp_buf_rgn.curr_index];
    284c:	5cd0      	ldrb	r0, [r2, r3]
    284e:	b2c0      	uxtb	r0, r0
  inp_buf_rgn.addr[inp_buf_rgn.curr_index] = 0;
    2850:	2100      	movs	r1, #0
    2852:	54d1      	strb	r1, [r2, r3]
  inp_buf_rgn.curr_index++;
    2854:	3301      	adds	r3, #1
    2856:	4a07      	ldr	r2, [pc, #28]	@ (2874 <memlog_getc+0x3c>)
    2858:	6193      	str	r3, [r2, #24]

  if (inp_buf_rgn.curr_index == inp_buf_rgn.size) {
    285a:	6952      	ldr	r2, [r2, #20]
    285c:	4293      	cmp	r3, r2
    285e:	d000      	beq.n	2862 <memlog_getc+0x2a>
    inp_buf_rgn.curr_index = 0;
  }

  return val;
}
    2860:	4770      	bx	lr
    inp_buf_rgn.curr_index = 0;
    2862:	4b04      	ldr	r3, [pc, #16]	@ (2874 <memlog_getc+0x3c>)
    2864:	6199      	str	r1, [r3, #24]
    2866:	4770      	bx	lr
    return -1;
    2868:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    286c:	4770      	bx	lr
    return -1;
    286e:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    2872:	e7f5      	b.n	2860 <memlog_getc+0x28>
    2874:	2000032c 	andcs	r0, r0, ip, lsr #6

00002878 <memlog_putc>:

void memlog_putc(char c) {
  if (!(selected_mode & OUT) || c == 0) {
    2878:	4b09      	ldr	r3, [pc, #36]	@ (28a0 <memlog_putc+0x28>)
    287a:	781b      	ldrb	r3, [r3, #0]
    287c:	f013 0f02 	tst.w	r3, #2
    2880:	d009      	beq.n	2896 <memlog_putc+0x1e>
    2882:	b140      	cbz	r0, 2896 <memlog_putc+0x1e>
    return;
  }

  out_buf_rgn.addr[out_buf_rgn.curr_index] = (uint8_t) c;
    2884:	4a06      	ldr	r2, [pc, #24]	@ (28a0 <memlog_putc+0x28>)
    2886:	6851      	ldr	r1, [r2, #4]
    2888:	68d3      	ldr	r3, [r2, #12]
    288a:	54c8      	strb	r0, [r1, r3]
  out_buf_rgn.curr_index++;
    288c:	3301      	adds	r3, #1
    288e:	60d3      	str	r3, [r2, #12]

  if (out_buf_rgn.curr_index == out_buf_rgn.size) {
    2890:	6892      	ldr	r2, [r2, #8]
    2892:	4293      	cmp	r3, r2
    2894:	d000      	beq.n	2898 <memlog_putc+0x20>
    out_buf_rgn.curr_index = 0;
  }
}
    2896:	4770      	bx	lr
    out_buf_rgn.curr_index = 0;
    2898:	4b01      	ldr	r3, [pc, #4]	@ (28a0 <memlog_putc+0x28>)
    289a:	2200      	movs	r2, #0
    289c:	60da      	str	r2, [r3, #12]
    289e:	e7fa      	b.n	2896 <memlog_putc+0x1e>
    28a0:	2000032c 	andcs	r0, r0, ip, lsr #6

000028a4 <strlen>:
 * limitations under the License.
 **/

#include "string.h"

size_t strlen(const char *str) {
    28a4:	4602      	mov	r2, r0
  size_t len = 0;
    28a6:	2000      	movs	r0, #0
  while (str[len]) {
    28a8:	e000      	b.n	28ac <strlen+0x8>
    len++;
    28aa:	3001      	adds	r0, #1
  while (str[len]) {
    28ac:	5c13      	ldrb	r3, [r2, r0]
    28ae:	2b00      	cmp	r3, #0
    28b0:	d1fb      	bne.n	28aa <strlen+0x6>
  }
  return len;
}
    28b2:	4770      	bx	lr

000028b4 <strcmp>:

int strcmp(const char *str1, const char *str2) {
  while (*str1 && (*str1 == *str2)) {
    28b4:	e001      	b.n	28ba <strcmp+0x6>
    str1++;
    28b6:	3001      	adds	r0, #1
    str2++;
    28b8:	3101      	adds	r1, #1
  while (*str1 && (*str1 == *str2)) {
    28ba:	7803      	ldrb	r3, [r0, #0]
    28bc:	b113      	cbz	r3, 28c4 <strcmp+0x10>
    28be:	780a      	ldrb	r2, [r1, #0]
    28c0:	4293      	cmp	r3, r2
    28c2:	d0f8      	beq.n	28b6 <strcmp+0x2>
  }
  return *str1 - *str2;
    28c4:	7808      	ldrb	r0, [r1, #0]
}
    28c6:	1a18      	subs	r0, r3, r0
    28c8:	4770      	bx	lr

000028ca <strcpy>:

char *strcpy(char *str1, const char *str2) {
  while (*str2) {
    28ca:	e002      	b.n	28d2 <strcpy+0x8>
    *(str1++) = *(str2++);
    28cc:	3101      	adds	r1, #1
    28ce:	f800 3b01 	strb.w	r3, [r0], #1
  while (*str2) {
    28d2:	780b      	ldrb	r3, [r1, #0]
    28d4:	2b00      	cmp	r3, #0
    28d6:	d1f9      	bne.n	28cc <strcpy+0x2>
  }
  *str1 = '\0';
    28d8:	7003      	strb	r3, [r0, #0]
  return 0;
}
    28da:	4618      	mov	r0, r3
    28dc:	4770      	bx	lr

000028de <memcpy>:

void *memcpy(void *dest, const void *src, size_t size) {
  size_t i;
  char *src_char = (char *)src;
  char *dest_char = (char *)dest;
  for (i = 0; i < size; i++) {
    28de:	2300      	movs	r3, #0
    28e0:	e004      	b.n	28ec <memcpy+0xe>
    dest_char[i] = src_char[i];
    28e2:	f811 c003 	ldrb.w	ip, [r1, r3]
    28e6:	f800 c003 	strb.w	ip, [r0, r3]
  for (i = 0; i < size; i++) {
    28ea:	3301      	adds	r3, #1
    28ec:	4293      	cmp	r3, r2
    28ee:	d3f8      	bcc.n	28e2 <memcpy+0x4>
  }
  return 0;
}
    28f0:	2000      	movs	r0, #0
    28f2:	4770      	bx	lr

000028f4 <memset>:

void *memset(void *dest, int val, size_t size) {
  size_t i;
  char *dest_char = (char *)dest;
  for (i = 0; i < size; i++) {
    28f4:	2300      	movs	r3, #0
    28f6:	e001      	b.n	28fc <memset+0x8>
    dest_char[i] = val;
    28f8:	54c1      	strb	r1, [r0, r3]
  for (i = 0; i < size; i++) {
    28fa:	3301      	adds	r3, #1
    28fc:	4293      	cmp	r3, r2
    28fe:	d3fb      	bcc.n	28f8 <memset+0x4>
  }

  return 0;
}
    2900:	2000      	movs	r0, #0
    2902:	4770      	bx	lr

00002904 <reset_handler>:
    2904:	f7fe fbb4 	bl	1070 <prompt>
    2908:	f7ff fffe 	bl	2908 <reset_handler+0x4>

Disassembly of section .rodata:

00002964 <_varcar_mesg-0x4>:
    2964:	00000000 	andeq	r0, r0, r0

00002968 <_varcar_mesg>:
    2968:	00002b88 	andeq	r2, r0, r8, lsl #23
    296c:	00002b94 	muleq	r0, r4, fp
    2970:	00000429 	andeq	r0, r0, r9, lsr #8

00002974 <_varaes_test>:

// ADD_CMD(command, description, function name);
    2974:	00002c7c 	andeq	r2, r0, ip, ror ip
    2978:	00002c88 	andeq	r2, r0, r8, lsl #25
    297c:	000006ad 	andeq	r0, r0, sp, lsr #13

00002980 <_varpair1>:

// ADD_CMD(keyword, description, function name);
ADD_CMD(pair3, "Pairs using EC Diffie-Hellman key exchange.", pairecdh);
ADD_CMD(pair2, "Pairs using challenge response", pairchall);
ADD_CMD(pair1, "Easy pairing with a car.", pair1);
    2980:	00002d70 	andeq	r2, r0, r0, ror sp
    2984:	00002d78 	andeq	r2, r0, r8, ror sp
    2988:	00000751 	andeq	r0, r0, r1, asr r7

0000298c <_varpairchall>:
ADD_CMD(pair2, "Pairs using challenge response", pairchall);
    298c:	00002d94 	muleq	r0, r4, sp
    2990:	00002d9c 	muleq	r0, ip, sp
    2994:	0000077d 	andeq	r0, r0, sp, ror r7

00002998 <_varpairecdh>:
ADD_CMD(pair3, "Pairs using EC Diffie-Hellman key exchange.", pairecdh);
    2998:	00002dbc 			@ <UNDEFINED> instruction: 0x00002dbc
    299c:	00002dc4 	andeq	r2, r0, r4, asr #27
    29a0:	000007a9 	andeq	r0, r0, r9, lsr #15

000029a4 <_vardecode64>:

// ADD_CMD(command, description, function name);
ADD_CMD(encode64, "Base64 encodes a string", encode64);
    29a4:	00002ecc 	andeq	r2, r0, ip, asr #29
    29a8:	00002ed8 	ldrdeq	r2, [r0], -r8
    29ac:	0000085d 	andeq	r0, r0, sp, asr r8

000029b0 <_varencode64>:
ADD_CMD(encode64, "Base64 encodes a string", encode64);
    29b0:	00002ef0 	strdeq	r2, [r0], -r0
    29b4:	00002efc 	strdeq	r2, [r0], -ip
    29b8:	0000080d 	andeq	r0, r0, sp, lsl #16

000029bc <_varecdh_test>:

// ADD_CMD(command, description, function name);
ADD_CMD(ecdh_test, "Tests ECDH functions", ecdh_test);
    29bc:	00002fc0 	andeq	r2, r0, r0, asr #31
    29c0:	00002fcc 	andeq	r2, r0, ip, asr #31
    29c4:	000008b9 			@ <UNDEFINED> instruction: 0x000008b9

000029c8 <_varsend_ping>:

// ADD_CMD(command, description, function name);
ADD_CMD(ping, "Pings the other board", send_ping);
    29c8:	00003008 	andeq	r3, r0, r8
    29cc:	00003010 	andeq	r3, r0, r0, lsl r0
    29d0:	000009c5 	andeq	r0, r0, r5, asr #19

000029d4 <_varsha256_test>:

// ADD_CMD(keyword, description, function name);
    29d4:	000030d0 	ldrdeq	r3, [r0], -r0
    29d8:	000030dc 	ldrdeq	r3, [r0], -ip
    29dc:	000009e1 	andeq	r0, r0, r1, ror #19

000029e0 <_varcmd_exec_status>:

// DO NOT REMOVE THESE
AUTO_CMD(version, "Prints details of the build", build_info);
ADD_CMD(help, "Prints all available commands", help);
ADD_CMD(status, "Returns exit status of last executed command",
    29e0:	000031c8 	andeq	r3, r0, r8, asr #3
    29e4:	000031d0 	ldrdeq	r3, [r0], -r0
    29e8:	00000b85 	andeq	r0, r0, r5, lsl #23

000029ec <_varhelp>:
ADD_CMD(help, "Prints all available commands", help);
    29ec:	00003200 	andeq	r3, r0, r0, lsl #4
    29f0:	00003208 	andeq	r3, r0, r8, lsl #4
    29f4:	00000c0d 	andeq	r0, r0, sp, lsl #24

000029f8 <_varshow_history>:
ADD_CMD(history, "Show command history", show_history);
    29f8:	0000324c 	andeq	r3, r0, ip, asr #4
    29fc:	00003254 	andeq	r3, r0, r4, asr r2
    2a00:	00000b45 	andeq	r0, r0, r5, asr #22

00002a04 <_varread_mem>:
ADD_CMD(rb, "reads a bit from memory location", r32_bit);
#endif //SHELL_NO_BIT_UTILS

ADD_CMD(r32, "reads a 32 bit memory location", r32);
ADD_CMD(w32, "writes a 32 bit value to a memory location", w32);
ADD_CMD(read, "Reads number of bytes from memory", read_mem);
    2a04:	00003548 	andeq	r3, r0, r8, asr #10
    2a08:	00003550 	andeq	r3, r0, r0, asr r5
    2a0c:	00001b21 	andeq	r1, r0, r1, lsr #22

00002a10 <_varw32>:
ADD_CMD(w32, "writes a 32 bit value to a memory location", w32);
    2a10:	00003574 	andeq	r3, r0, r4, ror r5
    2a14:	00003578 	andeq	r3, r0, r8, ror r5
    2a18:	00001af1 	strdeq	r1, [r0], -r1	@ <UNPREDICTABLE>

00002a1c <_varr32>:
ADD_CMD(r32, "reads a 32 bit memory location", r32);
    2a1c:	000035a4 	andeq	r3, r0, r4, lsr #11
    2a20:	000035a8 	andeq	r3, r0, r8, lsr #11
    2a24:	00001ac1 	andeq	r1, r0, r1, asr #21

00002a28 <_varr32_bit>:
ADD_CMD(rb, "reads a bit from memory location", r32_bit);
    2a28:	000035c8 	andeq	r3, r0, r8, asr #11
    2a2c:	000035cc 	andeq	r3, r0, ip, asr #11
    2a30:	00001bd1 	ldrdeq	r1, [r0], -r1	@ <UNPREDICTABLE>

00002a34 <_varw32_bit>:
ADD_CMD(wb, "write a bit to memory location", w32_bit);
    2a34:	000035f0 	strdeq	r3, [r0], -r0
    2a38:	000035f4 	strdeq	r3, [r0], -r4
    2a3c:	00001b69 	andeq	r1, r0, r9, ror #22

00002a40 <_varbuild_info>:
AUTO_CMD(version, "Prints details of the build", build_info);
    2a40:	00003228 	andeq	r3, r0, r8, lsr #4
    2a44:	00003230 	andeq	r3, r0, r0, lsr r2
    2a48:	00000ba1 	andeq	r0, r0, r1, lsr #23

00002a4c <cmd_end_>:
	...
    2a58:	6f636e49 	svcvs	0x00636e49
    2a5c:	63657272 	cmnvs	r5, #536870919	@ 0x20000007
    2a60:	756e2074 	strbvc	r2, [lr, #-116]!	@ 0xffffff8c
    2a64:	7265626d 	rsbvc	r6, r5, #-805306362	@ 0xd0000006
    2a68:	20666f20 	rsbcs	r6, r6, r0, lsr #30
    2a6c:	75677261 	strbvc	r7, [r7, #-609]!	@ 0xfffffd9f
    2a70:	746e656d 	strbtvc	r6, [lr], #-1389	@ 0xfffffa93
    2a74:	6f662073 	svcvs	0x00662073
    2a78:	41502072 	cmpmi	r0, r2, ror r0
    2a7c:	43455249 	movtmi	r5, #21065	@ 0x5249
    2a80:	0a324844 	beq	c94b98 <__ROM_SIZE__+0xc54b98>
    2a84:	00000000 	andeq	r0, r0, r0
    2a88:	65636552 	strbvs	r6, [r3, #-1362]!	@ 0xfffffaae
    2a8c:	64657669 	strbtvs	r7, [r5], #-1641	@ 0xfffff997
    2a90:	6d206120 	stfvss	f6, [r0, #-128]!	@ 0xffffff80
    2a94:	61737365 	cmnvs	r3, r5, ror #6
    2a98:	66206567 	strtvs	r6, [r0], -r7, ror #10
    2a9c:	206d6f72 	rsbcs	r6, sp, r2, ror pc
    2aa0:	20656874 	rsbcs	r6, r5, r4, ror r8
    2aa4:	3a726163 	bcc	1c9b038 <__ROM_SIZE__+0x1c5b038>
    2aa8:	00000000 	andeq	r0, r0, r0
    2aac:	00732520 	rsbseq	r2, r3, r0, lsr #10
    2ab0:	474e4950 	smlsldmi	r4, lr, r0, r9
    2ab4:	5045525f 	subpl	r5, r5, pc, asr r2
    2ab8:	0000594c 	andeq	r5, r0, ip, asr #18
    2abc:	20746f47 	rsbscs	r6, r4, r7, asr #30
    2ac0:	69702061 	ldmdbvs	r0!, {r0, r5, r6, sp}^
    2ac4:	7220676e 	eorvc	r6, r0, #28835840	@ 0x1b80000
    2ac8:	796c7065 	stmdbvc	ip!, {r0, r2, r5, r6, ip, sp, lr}^
    2acc:	00000a2e 	andeq	r0, r0, lr, lsr #20
    2ad0:	52494150 	subpl	r4, r9, #80, 2
    2ad4:	48444345 	stmdami	r4, {r0, r2, r6, r8, r9, lr}^
    2ad8:	00000032 	andeq	r0, r0, r2, lsr r0
    2adc:	42534541 	subsmi	r4, r3, #272629760	@ 0x10400000
    2ae0:	00003436 	andeq	r3, r0, r6, lsr r4
    2ae4:	6f636544 	svcvs	0x00636544
    2ae8:	2f646564 	svccs	0x00646564
    2aec:	72636564 	rsbvc	r6, r3, #100, 10	@ 0x19000000
    2af0:	65747079 	ldrbvs	r7, [r4, #-121]!	@ 0xffffff87
    2af4:	73612064 	cmnvc	r1, #100	@ 0x64
    2af8:	0a732520 	beq	1ccbf80 <__ROM_SIZE__+0x1c8bf80>
    2afc:	00000000 	andeq	r0, r0, r0
    2b00:	7373694d 	cmnvc	r3, #1261568	@ 0x134000
    2b04:	20676e69 	rsbcs	r6, r7, r9, ror #28
    2b08:	42534541 	subsmi	r4, r3, #272629760	@ 0x10400000
    2b0c:	65203436 	strvs	r3, [r0, #-1078]!	@ 0xfffffbca
    2b10:	646f636e 	strbtvs	r6, [pc], #-878	@ 2b18 <cmd_end_+0xcc>
    2b14:	6d206465 	cfstrsvs	mvf6, [r0, #-404]!	@ 0xfffffe6c
    2b18:	61737365 	cmnvs	r3, r5, ror #6
    2b1c:	000a6567 	andeq	r6, sl, r7, ror #10
    2b20:	00343642 	eorseq	r3, r4, r2, asr #12
    2b24:	6f636544 	svcvs	0x00636544
    2b28:	676e6964 	strbvs	r6, [lr, -r4, ror #18]!
    2b2c:	73614220 	cmnvc	r1, #32, 4
    2b30:	0a343665 	beq	d104cc <__ROM_SIZE__+0xcd04cc>
    2b34:	00000000 	andeq	r0, r0, r0
    2b38:	6f636544 	svcvs	0x00636544
    2b3c:	20646564 	rsbcs	r6, r4, r4, ror #10
    2b40:	25207361 	strcs	r7, [r0, #-865]!	@ 0xfffffc9f
    2b44:	00000073 	andeq	r0, r0, r3, ror r0
    2b48:	7373694d 	cmnvc	r3, #1261568	@ 0x134000
    2b4c:	20676e69 	rsbcs	r6, r7, r9, ror #28
    2b50:	65736142 	ldrbvs	r6, [r3, #-322]!	@ 0xfffffebe
    2b54:	65203436 	strvs	r3, [r0, #-1078]!	@ 0xfffffbca
    2b58:	646f636e 	strbtvs	r6, [pc], #-878	@ 2b60 <cmd_end_+0x114>
    2b5c:	6d206465 	cfstrsvs	mvf6, [r0, #-404]!	@ 0xfffffe6c
    2b60:	61737365 	cmnvs	r3, r5, ror #6
    2b64:	000a6567 	andeq	r6, sl, r7, ror #10
    2b68:	6e646944 	vnmulvs.f16	s13, s8, s8	@ <UNPREDICTABLE>
    2b6c:	6b207427 	blvs	81fc10 <__ROM_SIZE__+0x7dfc10>
    2b70:	20776f6e 	rsbscs	r6, r7, lr, ror #30
    2b74:	20776f68 	rsbscs	r6, r7, r8, ror #30
    2b78:	68206f74 	stmdavs	r0!, {r2, r4, r5, r6, r8, r9, sl, fp, sp, lr}
    2b7c:	6c646e61 	stclvs	14, cr6, [r4], #-388	@ 0xfffffe7c
    2b80:	73252065 			@ <UNDEFINED> instruction: 0x73252065
    2b84:	0000000a 	andeq	r0, r0, sl
    2b88:	5f524143 	svcpl	0x00524143
    2b8c:	4753454d 	ldrbmi	r4, [r3, -sp, asr #10]
    2b90:	00000000 	andeq	r0, r0, r0
    2b94:	636f7250 	cmnvs	pc, #80, 4
    2b98:	65737365 	ldrbvs	r7, [r3, #-869]!	@ 0xfffffc9b
    2b9c:	656d2073 	strbvs	r2, [sp, #-115]!	@ 0xffffff8d
    2ba0:	67617373 			@ <UNDEFINED> instruction: 0x67617373
    2ba4:	66207365 	strtvs	r7, [r0], -r5, ror #6
    2ba8:	206d6f72 	rsbcs	r6, sp, r2, ror pc
    2bac:	20656874 	rsbcs	r6, r5, r4, ror r8
    2bb0:	00726163 	rsbseq	r6, r2, r3, ror #2
    2bb4:	69616c50 	stmdbvs	r1!, {r4, r6, sl, fp, sp, lr}^
    2bb8:	7865746e 	stmdavc	r5!, {r1, r2, r3, r5, r6, sl, ip, sp, lr}^
    2bbc:	73692074 	cmnvc	r9, #116	@ 0x74
    2bc0:	0a732520 	beq	1ccc048 <__ROM_SIZE__+0x1c8c048>
    2bc4:	00000000 	andeq	r0, r0, r0
    2bc8:	72636e45 	rsbvc	r6, r3, #1104	@ 0x450
    2bcc:	65747079 	ldrbvs	r7, [r4, #-121]!	@ 0xffffff87
    2bd0:	6e652f64 	cdpvs	15, 6, cr2, cr5, cr4, {3}
    2bd4:	65646f63 	strbvs	r6, [r4, #-3939]!	@ 0xfffff09d
    2bd8:	73692064 	cmnvc	r9, #100	@ 0x64
    2bdc:	0a732520 	beq	1ccc064 <__ROM_SIZE__+0x1c8c064>
    2be0:	00000000 	andeq	r0, r0, r0
    2be4:	5f424f46 	svcpl	0x00424f46
    2be8:	4753454d 	ldrbmi	r4, [r3, -sp, asr #10]
    2bec:	53454120 	movtpl	r4, #20768	@ 0x5120
    2bf0:	20343642 	eorscs	r3, r4, r2, asr #12
    2bf4:	000a7325 	andeq	r7, sl, r5, lsr #6
    2bf8:	74736554 	ldrbtvc	r6, [r3], #-1364	@ 0xfffffaac
    2bfc:	65687420 	strbvs	r7, [r8, #-1056]!	@ 0xfffffbe0
    2c00:	73656d20 	cmnvc	r5, #32, 26	@ 0x800
    2c04:	61682067 	cmnvs	r8, r7, rrx
    2c08:	656c646e 	strbvs	r6, [ip, #-1134]!	@ 0xfffffb92
    2c0c:	69772072 	ldmdbvs	r7!, {r1, r4, r5, r6, sp}^
    2c10:	43206874 			@ <UNDEFINED> instruction: 0x43206874
    2c14:	4d5f5241 	lfmmi	f5, 2, [pc, #-260]	@ 2b18 <cmd_end_+0xcc>
    2c18:	20475345 	subcs	r5, r7, r5, asr #6
    2c1c:	42534541 	subsmi	r4, r3, #272629760	@ 0x10400000
    2c20:	25203436 	strcs	r3, [r0, #-1078]!	@ 0xfffffbca
    2c24:	00000a73 	andeq	r0, r0, r3, ror sl
    2c28:	65746641 	ldrbvs	r6, [r4, #-1601]!	@ 0xfffff9bf
    2c2c:	6e652072 	mcrvs	0, 3, r2, cr5, cr2, {3}
    2c30:	70797263 	rsbsvc	r7, r9, r3, ror #4
    2c34:	676e6974 			@ <UNDEFINED> instruction: 0x676e6974
    2c38:	6e653e2d 	cdpvs	14, 6, cr3, cr5, cr13, {1}
    2c3c:	69646f63 	stmdbvs	r4!, {r0, r1, r5, r6, r8, r9, sl, fp, sp, lr}^
    2c40:	3e2d676e 	cdpcc	7, 2, cr6, cr13, cr14, {3}
    2c44:	6f636564 	svcvs	0x00636564
    2c48:	676e6964 	strbvs	r6, [lr, -r4, ror #18]!
    2c4c:	65643e2d 	strbvs	r3, [r4, #-3629]!	@ 0xfffff1d3
    2c50:	70797263 	rsbsvc	r7, r9, r3, ror #4
    2c54:	676e6974 			@ <UNDEFINED> instruction: 0x676e6974
    2c58:	20657720 	rsbcs	r7, r5, r0, lsr #14
    2c5c:	6f636572 	svcvs	0x00636572
    2c60:	20726576 	rsbscs	r6, r2, r6, ror r5
    2c64:	000a7325 	andeq	r7, sl, r5, lsr #6
    2c68:	33323130 	teqcc	r2, #48, 2
    2c6c:	37363534 			@ <UNDEFINED> instruction: 0x37363534
    2c70:	62613938 	rsbvs	r3, r1, #56, 18	@ 0xe0000
    2c74:	66656463 	strbtvs	r6, [r5], -r3, ror #8
    2c78:	00000000 	andeq	r0, r0, r0
    2c7c:	5f736561 	svcpl	0x00736561
    2c80:	74736574 	ldrbtvc	r6, [r3], #-1396	@ 0xfffffa8c
    2c84:	00000000 	andeq	r0, r0, r0
    2c88:	74736554 	ldrbtvc	r6, [r3], #-1364	@ 0xfffffaac
    2c8c:	45412073 	strbmi	r2, [r1, #-115]	@ 0xffffff8d
    2c90:	61422f53 	cmpvs	r2, r3, asr pc
    2c94:	34366573 	ldrtcc	r6, [r6], #-1395	@ 0xfffffa8d
    2c98:	706d6920 	rsbvc	r6, sp, r0, lsr #18
    2c9c:	656d656c 	strbvs	r6, [sp, #-1388]!	@ 0xfffffa94
    2ca0:	7461746e 	strbtvc	r7, [r1], #-1134	@ 0xfffffb92
    2ca4:	006e6f69 	rsbeq	r6, lr, r9, ror #30
    2ca8:	646e6553 	strbtvs	r6, [lr], #-1363	@ 0xfffffaad
    2cac:	20676e69 	rsbcs	r6, r7, r9, ror #28
    2cb0:	61702061 	cmnvs	r0, r1, rrx
    2cb4:	72207269 	eorvc	r7, r0, #-1879048186	@ 0x90000006
    2cb8:	65757165 	ldrbvs	r7, [r5, #-357]!	@ 0xfffffe9b
    2cbc:	0a2e7473 	beq	b9fe90 <__ROM_SIZE__+0xb5fe90>
    2cc0:	00000000 	andeq	r0, r0, r0
    2cc4:	5f424f46 	svcpl	0x00424f46
    2cc8:	4753454d 	ldrbmi	r4, [r3, -sp, asr #10]
    2ccc:	49415020 	stmdbmi	r1, {r5, ip, lr}^
    2cd0:	64252052 	strtvs	r2, [r5], #-82	@ 0xffffffae
    2cd4:	0a642520 	beq	190c15c <__ROM_SIZE__+0x18cc15c>
    2cd8:	00000000 	andeq	r0, r0, r0
    2cdc:	646e6553 	strbtvs	r6, [lr], #-1363	@ 0xfffffaad
    2ce0:	20676e69 	rsbcs	r6, r7, r9, ror #28
    2ce4:	61702061 	cmnvs	r0, r1, rrx
    2ce8:	72207269 	eorvc	r7, r0, #-1879048186	@ 0x90000006
    2cec:	65757165 	ldrbvs	r7, [r5, #-357]!	@ 0xfffffe9b
    2cf0:	77207473 			@ <UNDEFINED> instruction: 0x77207473
    2cf4:	20687469 	rsbcs	r7, r8, r9, ror #8
    2cf8:	6c616863 	stclvs	8, cr6, [r1], #-396	@ 0xfffffe74
    2cfc:	676e656c 	strbvs	r6, [lr, -ip, ror #10]!
    2d00:	65722f65 	ldrbvs	r2, [r2, #-3941]!	@ 0xfffff09b
    2d04:	6e6f7073 	mcrvs	0, 3, r7, cr15, cr3, {3}
    2d08:	0a2e6573 	beq	b9c2dc <__ROM_SIZE__+0xb5c2dc>
    2d0c:	00000000 	andeq	r0, r0, r0
    2d10:	5f424f46 	svcpl	0x00424f46
    2d14:	4753454d 	ldrbmi	r4, [r3, -sp, asr #10]
    2d18:	49415020 	stmdbmi	r1, {r5, ip, lr}^
    2d1c:	20524352 	subscs	r4, r2, r2, asr r3
    2d20:	25206425 	strcs	r6, [r0, #-1061]!	@ 0xfffffbdb
    2d24:	00000a64 	andeq	r0, r0, r4, ror #20
    2d28:	72617453 	rsbvc	r7, r1, #1392508928	@ 0x53000000
    2d2c:	676e6974 			@ <UNDEFINED> instruction: 0x676e6974
    2d30:	20434520 	subcs	r4, r3, r0, lsr #10
    2d34:	66666944 	strbtvs	r6, [r6], -r4, asr #18
    2d38:	482d6569 	stmdami	sp!, {r0, r3, r5, r6, r8, sl, sp, lr}
    2d3c:	6d6c6c65 	stclvs	12, cr6, [ip, #-404]!	@ 0xfffffe6c
    2d40:	6b206e61 	blvs	81e6cc <__ROM_SIZE__+0x7de6cc>
    2d44:	65207965 	strvs	r7, [r0, #-2405]!	@ 0xfffff69b
    2d48:	61686378 	smcvs	34360	@ 0x8638
    2d4c:	2e65676e 	cdpcs	7, 6, cr6, cr5, cr14, {3}
    2d50:	0000000a 	andeq	r0, r0, sl
    2d54:	5f424f46 	svcpl	0x00424f46
    2d58:	4753454d 	ldrbmi	r4, [r3, -sp, asr #10]
    2d5c:	49415020 	stmdbmi	r1, {r5, ip, lr}^
    2d60:	44434552 	strbmi	r4, [r3], #-1362	@ 0xfffffaae
    2d64:	64252048 	strtvs	r2, [r5], #-72	@ 0xffffffb8
    2d68:	20642520 	rsbcs	r2, r4, r0, lsr #10
    2d6c:	000a7325 	andeq	r7, sl, r5, lsr #6
    2d70:	72696170 	rsbvc	r6, r9, #112, 2
    2d74:	00000031 	andeq	r0, r0, r1, lsr r0
    2d78:	79736145 	ldmdbvc	r3!, {r0, r2, r6, r8, sp, lr}^
    2d7c:	69617020 	stmdbvs	r1!, {r5, ip, sp, lr}^
    2d80:	676e6972 			@ <UNDEFINED> instruction: 0x676e6972
    2d84:	74697720 	strbtvc	r7, [r9], #-1824	@ 0xfffff8e0
    2d88:	20612068 	rsbcs	r2, r1, r8, rrx
    2d8c:	2e726163 	rpwcssz	f6, f2, f3
    2d90:	00000000 	andeq	r0, r0, r0
    2d94:	72696170 	rsbvc	r6, r9, #112, 2
    2d98:	00000032 	andeq	r0, r0, r2, lsr r0
    2d9c:	72696150 	rsbvc	r6, r9, #80, 2
    2da0:	73752073 	cmnvc	r5, #115	@ 0x73
    2da4:	20676e69 	rsbcs	r6, r7, r9, ror #28
    2da8:	6c616863 	stclvs	8, cr6, [r1], #-396	@ 0xfffffe74
    2dac:	676e656c 	strbvs	r6, [lr, -ip, ror #10]!
    2db0:	65722065 	ldrbvs	r2, [r2, #-101]!	@ 0xffffff9b
    2db4:	6e6f7073 	mcrvs	0, 3, r7, cr15, cr3, {3}
    2db8:	00006573 	andeq	r6, r0, r3, ror r5
    2dbc:	72696170 	rsbvc	r6, r9, #112, 2
    2dc0:	00000033 	andeq	r0, r0, r3, lsr r0
    2dc4:	72696150 	rsbvc	r6, r9, #80, 2
    2dc8:	73752073 	cmnvc	r5, #115	@ 0x73
    2dcc:	20676e69 	rsbcs	r6, r7, r9, ror #28
    2dd0:	44204345 	strtmi	r4, [r0], #-837	@ 0xfffffcbb
    2dd4:	69666669 	stmdbvs	r6!, {r0, r3, r5, r6, r9, sl, sp, lr}^
    2dd8:	65482d65 	strbvs	r2, [r8, #-3429]	@ 0xfffff29b
    2ddc:	616d6c6c 	cmnvs	sp, ip, ror #24
    2de0:	656b206e 	strbvs	r2, [fp, #-110]!	@ 0xffffff92
    2de4:	78652079 	stmdavc	r5!, {r0, r3, r4, r5, r6, sp}^
    2de8:	6e616863 	cdpvs	8, 6, cr6, cr1, cr3, {3}
    2dec:	002e6567 	eoreq	r6, lr, r7, ror #10
    2df0:	6f636e45 	svcvs	0x00636e45
    2df4:	20646564 	rsbcs	r6, r4, r4, ror #10
    2df8:	61207325 			@ <UNDEFINED> instruction: 0x61207325
    2dfc:	73252073 			@ <UNDEFINED> instruction: 0x73252073
    2e00:	74697720 	strbtvc	r7, [r9], #-1824	@ 0xfffff8e0
    2e04:	64252068 	strtvs	r2, [r5], #-104	@ 0xffffff98
    2e08:	61686320 	cmnvs	r8, r0, lsr #6
    2e0c:	74636172 	strbtvc	r6, [r3], #-370	@ 0xfffffe8e
    2e10:	0a737265 	beq	1cdf7ac <__ROM_SIZE__+0x1c9f7ac>
    2e14:	00000000 	andeq	r0, r0, r0
    2e18:	69727453 	ldmdbvs	r2!, {r0, r1, r4, r6, sl, ip, sp, lr}^
    2e1c:	6520676e 	strvs	r6, [r0, #-1902]!	@ 0xfffff892
    2e20:	65656378 	strbvs	r6, [r5, #-888]!	@ 0xfffffc88
    2e24:	6d207364 	stcvs	3, cr7, [r0, #-400]!	@ 0xfffffe70
    2e28:	6c207861 	stcvs	8, cr7, [r0], #-388	@ 0xfffffe7c
    2e2c:	74676e65 	strbtvc	r6, [r7], #-3685	@ 0xfffff19b
    2e30:	666f2068 	strbtvs	r2, [pc], -r8, rrx
    2e34:	20642520 	rsbcs	r2, r4, r0, lsr #10
    2e38:	72616863 	rsbvc	r6, r1, #6488064	@ 0x630000
    2e3c:	65746361 	ldrbvs	r6, [r4, #-865]!	@ 0xfffffc9f
    2e40:	00007372 	andeq	r7, r0, r2, ror r3
    2e44:	67617355 			@ <UNDEFINED> instruction: 0x67617355
    2e48:	73692065 	cmnvc	r9, #101	@ 0x65
    2e4c:	6e652720 	cdpvs	7, 6, cr2, cr5, cr0, {1}
    2e50:	65646f63 	strbvs	r6, [r4, #-3939]!	@ 0xfffff09d
    2e54:	73203436 			@ <UNDEFINED> instruction: 0x73203436
    2e58:	6e697274 	mcrvs	2, 3, r7, cr9, cr4, {3}
    2e5c:	000a2767 	andeq	r2, sl, r7, ror #14
    2e60:	6f636544 	svcvs	0x00636544
    2e64:	20646564 	rsbcs	r6, r4, r4, ror #10
    2e68:	61207325 			@ <UNDEFINED> instruction: 0x61207325
    2e6c:	25203a73 	strcs	r3, [r0, #-2675]!	@ 0xfffff58d
    2e70:	00000a73 	andeq	r0, r0, r3, ror sl
    2e74:	69727453 	ldmdbvs	r2!, {r0, r1, r4, r6, sl, ip, sp, lr}^
    2e78:	6520676e 	strvs	r6, [r0, #-1902]!	@ 0xfffff892
    2e7c:	65656378 	strbvs	r6, [r5, #-888]!	@ 0xfffffc88
    2e80:	6d207364 	stcvs	3, cr7, [r0, #-400]!	@ 0xfffffe70
    2e84:	62207861 	eorvs	r7, r0, #6356992	@ 0x610000
    2e88:	36657361 	strbtcc	r7, [r5], -r1, ror #6
    2e8c:	74732034 	ldrbtvc	r2, [r3], #-52	@ 0xffffffcc
    2e90:	676e6972 			@ <UNDEFINED> instruction: 0x676e6972
    2e94:	6e656c20 	cdpvs	12, 6, cr6, cr5, cr0, {1}
    2e98:	20687467 	rsbcs	r7, r8, r7, ror #8
    2e9c:	2520666f 	strcs	r6, [r0, #-1647]!	@ 0xfffff991
    2ea0:	68632064 	stmdavs	r3!, {r2, r5, r6, sp}^
    2ea4:	63617261 	cmnvs	r1, #268435462	@ 0x10000006
    2ea8:	73726574 	cmnvc	r2, #116, 10	@ 0x1d000000
    2eac:	00000000 	andeq	r0, r0, r0
    2eb0:	67617355 			@ <UNDEFINED> instruction: 0x67617355
    2eb4:	73692065 	cmnvc	r9, #101	@ 0x65
    2eb8:	65642720 	strbvs	r2, [r4, #-1824]!	@ 0xfffff8e0
    2ebc:	65646f63 	strbvs	r6, [r4, #-3939]!	@ 0xfffff09d
    2ec0:	73203436 			@ <UNDEFINED> instruction: 0x73203436
    2ec4:	6e697274 	mcrvs	2, 3, r7, cr9, cr4, {3}
    2ec8:	000a2767 	andeq	r2, sl, r7, ror #14
    2ecc:	6f636564 	svcvs	0x00636564
    2ed0:	34366564 	ldrtcc	r6, [r6], #-1380	@ 0xfffffa9c
    2ed4:	00000000 	andeq	r0, r0, r0
    2ed8:	65736142 	ldrbvs	r6, [r3, #-322]!	@ 0xfffffebe
    2edc:	64203436 	strtvs	r3, [r0], #-1078	@ 0xfffffbca
    2ee0:	646f6365 	strbtvs	r6, [pc], #-869	@ 2ee8 <cmd_end_+0x49c>
    2ee4:	61207365 			@ <UNDEFINED> instruction: 0x61207365
    2ee8:	72747320 	rsbsvc	r7, r4, #32, 6	@ 0x80000000
    2eec:	00676e69 	rsbeq	r6, r7, r9, ror #28
    2ef0:	6f636e65 	svcvs	0x00636e65
    2ef4:	34366564 	ldrtcc	r6, [r6], #-1380	@ 0xfffffa9c
    2ef8:	00000000 	andeq	r0, r0, r0
    2efc:	65736142 	ldrbvs	r6, [r3, #-322]!	@ 0xfffffebe
    2f00:	65203436 	strvs	r3, [r0, #-1078]!	@ 0xfffffbca
    2f04:	646f636e 	strbtvs	r6, [pc], #-878	@ 2f0c <cmd_end_+0x4c0>
    2f08:	61207365 			@ <UNDEFINED> instruction: 0x61207365
    2f0c:	72747320 	rsbsvc	r7, r4, #32, 6	@ 0x80000000
    2f10:	00676e69 	rsbeq	r6, r7, r9, ror #28
    2f14:	74736554 	ldrbtvc	r6, [r3], #-1364	@ 0xfffffaac
    2f18:	20676e69 	rsbcs	r6, r7, r9, ror #28
    2f1c:	20656874 	rsbcs	r6, r5, r4, ror r8
    2f20:	68646365 	stmdavs	r4!, {r0, r2, r5, r6, r8, r9, sp, lr}^
    2f24:	79656b20 	stmdbvc	r5!, {r5, r8, r9, fp, sp, lr}^
    2f28:	63786520 	cmnvs	r8, #32, 10	@ 0x8000000
    2f2c:	676e6168 	strbvs	r6, [lr, -r8, ror #2]!
    2f30:	00000a65 	andeq	r0, r0, r5, ror #20
    2f34:	73726946 	cmnvc	r2, #1146880	@ 0x118000
    2f38:	68732074 	ldmdavs	r3!, {r2, r4, r5, r6, sp}^
    2f3c:	64657261 	strbtvs	r7, [r5], #-609	@ 0xfffffd9f
    2f40:	79656b20 	stmdbvc	r5!, {r5, r8, r9, fp, sp, lr}^
    2f44:	20736920 	rsbscs	r6, r3, r0, lsr #18
    2f48:	000a7325 	andeq	r7, sl, r5, lsr #6
    2f4c:	756f6853 	strbvc	r6, [pc, #-2131]!	@ 2701 <ecdh_generate_keys+0x1>
    2f50:	6220646c 	eorvs	r6, r0, #108, 8	@ 0x6c000000
    2f54:	61732065 	cmnvs	r3, r5, rrx
    2f58:	6120656d 			@ <UNDEFINED> instruction: 0x6120656d
    2f5c:	73252073 			@ <UNDEFINED> instruction: 0x73252073
    2f60:	0000000a 	andeq	r0, r0, sl
    2f64:	74697753 	strbtvc	r7, [r9], #-1875	@ 0xfffff8ad
    2f68:	6e696863 	cdpvs	8, 6, cr6, cr9, cr3, {3}
    2f6c:	6f662067 	svcvs	0x00662067
    2f70:	45412062 	strbmi	r2, [r1, #-98]	@ 0xffffff9e
    2f74:	656b2053 	strbvs	r2, [fp, #-83]!	@ 0xffffffad
    2f78:	6f742079 	svcvs	0x00742079
    2f7c:	77656e20 	strbvc	r6, [r5, -r0, lsr #28]!
    2f80:	6c617620 	stclvs	6, cr7, [r1], #-128	@ 0xffffff80
    2f84:	202e6575 	eorcs	r6, lr, r5, ror r5
    2f88:	20797254 	rsbscs	r7, r9, r4, asr r2
    2f8c:	20534541 	subscs	r4, r3, r1, asr #10
    2f90:	74736574 	ldrbtvc	r6, [r3], #-1396	@ 0xfffffa8c
    2f94:	6f6e2073 	svcvs	0x006e2073
    2f98:	000a2e77 	andeq	r2, sl, r7, ror lr
    2f9c:	752f5077 	strvc	r5, [pc, #-119]!	@ 2f2d <cmd_end_+0x4e1>
    2fa0:	752f5077 	strvc	r5, [pc, #-119]!	@ 2f31 <cmd_end_+0x4e5>
    2fa4:	752f5077 	strvc	r5, [pc, #-119]!	@ 2f35 <cmd_end_+0x4e9>
    2fa8:	752f5077 	strvc	r5, [pc, #-119]!	@ 2f39 <cmd_end_+0x4ed>
    2fac:	752f5077 	strvc	r5, [pc, #-119]!	@ 2f3d <cmd_end_+0x4f1>
    2fb0:	752f5077 	strvc	r5, [pc, #-119]!	@ 2f41 <cmd_end_+0x4f5>
    2fb4:	752f5077 	strvc	r5, [pc, #-119]!	@ 2f45 <cmd_end_+0x4f9>
    2fb8:	752f5077 	strvc	r5, [pc, #-119]!	@ 2f49 <cmd_end_+0x4fd>
    2fbc:	00000000 	andeq	r0, r0, r0
    2fc0:	68646365 	stmdavs	r4!, {r0, r2, r5, r6, r8, r9, sp, lr}^
    2fc4:	7365745f 	cmnvc	r5, #1593835520	@ 0x5f000000
    2fc8:	00000074 	andeq	r0, r0, r4, ror r0
    2fcc:	74736554 	ldrbtvc	r6, [r3], #-1364	@ 0xfffffaac
    2fd0:	43452073 	movtmi	r2, #20595	@ 0x5073
    2fd4:	66204844 	strtvs	r4, [r0], -r4, asr #16
    2fd8:	74636e75 	strbtvc	r6, [r3], #-3701	@ 0xfffff18b
    2fdc:	736e6f69 	cmnvc	lr, #420	@ 0x1a4
    2fe0:	00000000 	andeq	r0, r0, r0
    2fe4:	676e6950 			@ <UNDEFINED> instruction: 0x676e6950
    2fe8:	20676e69 	rsbcs	r6, r7, r9, ror #28
    2fec:	20656874 	rsbcs	r6, r5, r4, ror r8
    2ff0:	2e726163 	rpwcssz	f6, f2, f3
    2ff4:	0000000a 	andeq	r0, r0, sl
    2ff8:	5f424f46 	svcpl	0x00424f46
    2ffc:	4753454d 	ldrbmi	r4, [r3, -sp, asr #10]
    3000:	4e495020 	cdpmi	0, 4, cr5, cr9, cr0, {1}
    3004:	00000a47 	andeq	r0, r0, r7, asr #20
    3008:	676e6970 			@ <UNDEFINED> instruction: 0x676e6970
    300c:	00000000 	andeq	r0, r0, r0
    3010:	676e6950 			@ <UNDEFINED> instruction: 0x676e6950
    3014:	68742073 	ldmdavs	r4!, {r0, r1, r4, r5, r6, sp}^
    3018:	746f2065 	strbtvc	r2, [pc], #-101	@ 3020 <cmd_end_+0x5d4>
    301c:	20726568 	rsbscs	r6, r2, r8, ror #10
    3020:	72616f62 	rsbvc	r6, r1, #392	@ 0x188
    3024:	00000064 	andeq	r0, r0, r4, rrx
    3028:	72617453 	rsbvc	r7, r1, #1392508928	@ 0x53000000
    302c:	676e6974 			@ <UNDEFINED> instruction: 0x676e6974
    3030:	61687320 	cmnvs	r8, r0, lsr #6
    3034:	20363532 	eorscs	r3, r6, r2, lsr r5
    3038:	74736574 	ldrbtvc	r6, [r3], #-1396	@ 0xfffffa8c
    303c:	0000000a 	andeq	r0, r0, sl
    3040:	65736142 	ldrbvs	r6, [r3, #-322]!	@ 0xfffffebe
    3044:	6f203436 	svcvs	0x00203436
    3048:	48532066 	ldmdami	r3, {r1, r2, r5, r6, sp}^
    304c:	35322d41 	ldrcc	r2, [r2, #-3393]!	@ 0xfffff2bf
    3050:	65742036 	ldrbvs	r2, [r4, #-54]!	@ 0xffffffca
    3054:	69207473 	stmdbvs	r0!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}
    3058:	73252073 			@ <UNDEFINED> instruction: 0x73252073
    305c:	0000000a 	andeq	r0, r0, sl
    3060:	756f6853 	strbvc	r6, [pc, #-2131]!	@ 2815 <memlog_init+0x1d>
    3064:	6220646c 	eorvs	r6, r0, #108, 8	@ 0x6c000000
    3068:	73252065 			@ <UNDEFINED> instruction: 0x73252065
    306c:	0000000a 	andeq	r0, r0, sl
    3070:	64636261 	strbtvs	r6, [r3], #-609	@ 0xfffffd9f
    3074:	65646362 	strbvs	r6, [r4, #-866]!	@ 0xfffffc9e
    3078:	66656463 	strbtvs	r6, [r5], -r3, ror #8
    307c:	67666564 	strbvs	r6, [r6, -r4, ror #10]!
    3080:	68676665 	stmdavs	r7!, {r0, r2, r5, r6, r9, sl, sp, lr}^
    3084:	69686766 	stmdbvs	r8!, {r1, r2, r5, r6, r8, r9, sl, sp, lr}^
    3088:	6a696867 	bvs	1a5d22c <__ROM_SIZE__+0x1a1d22c>
    308c:	6b6a6968 	blvs	1a9d634 <__ROM_SIZE__+0x1a5d634>
    3090:	6c6b6a69 			@ <UNDEFINED> instruction: 0x6c6b6a69
    3094:	6d6c6b6a 	vstmdbvs	ip!, {d22-<overflow reg d74>}
    3098:	6e6d6c6b 	cdpvs	12, 6, cr6, cr13, cr11, {3}
    309c:	6f6e6d6c 	svcvs	0x006e6d6c
    30a0:	706f6e6d 	rsbvc	r6, pc, sp, ror #28
    30a4:	71706f6e 	cmnvc	r0, lr, ror #30
    30a8:	00000000 	andeq	r0, r0, r0
    30ac:	616a8d24 	cmnvs	sl, r4, lsr #26
    30b0:	b83806d2 	ldmdalt	r8!, {r1, r4, r6, r7, r9, sl}
    30b4:	9326c0e5 			@ <UNDEFINED> instruction: 0x9326c0e5
    30b8:	39603e0c 	stmdbcc	r0!, {r2, r3, r9, sl, fp, ip, sp}^
    30bc:	59e43ca3 	stmibpl	r4!, {r0, r1, r5, r7, sl, fp, ip, sp}^
    30c0:	6721ff64 	strvs	pc, [r1, -r4, ror #30]!
    30c4:	d4edecf6 	strbtle	lr, [sp], #3318	@ 0xcf6
    30c8:	c106db19 	tstgt	r6, r9, lsl fp
    30cc:	00000000 	andeq	r0, r0, r0
    30d0:	32616873 	rsbcc	r6, r1, #7536640	@ 0x730000
    30d4:	745f3635 	ldrbvc	r3, [pc], #-1589	@ 30dc <cmd_end_+0x690>
    30d8:	00747365 	rsbseq	r7, r4, r5, ror #6
    30dc:	74736554 	ldrbtvc	r6, [r3], #-1364	@ 0xfffffaac
    30e0:	68742073 	ldmdavs	r4!, {r0, r1, r4, r5, r6, sp}^
    30e4:	68732065 	ldmdavs	r3!, {r0, r2, r5, r6, sp}^
    30e8:	36353261 	ldrtcc	r3, [r5], -r1, ror #4
    30ec:	706d6920 	rsbvc	r6, sp, r0, lsr #18
    30f0:	656d656c 	strbvs	r6, [sp, #-1388]!	@ 0xfffffa94
    30f4:	7461746e 	strbtvc	r7, [r1], #-1134	@ 0xfffffb92
    30f8:	006e6f69 	rsbeq	r6, lr, r9, ror #30
    30fc:	000a7325 	andeq	r7, sl, r5, lsr #6
    3100:	000a6425 	andeq	r6, sl, r5, lsr #8
    3104:	6c697542 	cfstr64vs	mvdx7, [r9], #-264	@ 0xfffffef8
    3108:	5b203a64 	blpl	811aa0 <__ROM_SIZE__+0x7d1aa0>
    310c:	62343939 	eorsvs	r3, r4, #933888	@ 0xe4000
    3110:	3a306136 	bcc	c1b5f0 <__ROM_SIZE__+0xbdb5f0>
    3114:	62343939 	eorsvs	r3, r4, #933888	@ 0xe4000
    3118:	5d306136 	ldfpls	f6, [r0, #-216]!	@ 0xffffff28
    311c:	5b202d20 	blpl	80e5a4 <__ROM_SIZE__+0x7ce5a4>
    3120:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    3124:	49485240 	stmdbmi	r8, {r6, r9, ip, lr}^
    3128:	39522d54 	ldmdbcc	r2, {r2, r4, r6, r8, sl, fp, sp}^
    312c:	325a5830 	subscc	r5, sl, #48, 16	@ 0x300000
    3130:	205d4450 	subscs	r4, sp, r0, asr r4
    3134:	7041202d 	subvc	r2, r1, sp, lsr #32
    3138:	34322072 	ldrtcc	r2, [r2], #-114	@ 0xffffff8e
    313c:	32303220 	eorscc	r3, r0, #32, 4
    3140:	202d2033 	eorcs	r2, sp, r3, lsr r0
    3144:	343a3131 	ldrtcc	r3, [sl], #-305	@ 0xfffffecf
    3148:	31333a36 	teqcc	r3, r6, lsr sl
    314c:	0000000a 	andeq	r0, r0, sl
    3150:	22732522 	rsbscs	r2, r3, #142606336	@ 0x8800000
    3154:	6f63203a 	svcvs	0x0063203a
    3158:	6e616d6d 	cdpvs	13, 6, cr6, cr1, cr13, {3}
    315c:	6f6e2064 	svcvs	0x006e2064
    3160:	6f662074 	svcvs	0x00662074
    3164:	2e646e75 	mcrcs	14, 3, r6, cr4, cr5, {3}
    3168:	65735520 	ldrbvs	r5, [r3, #-1312]!	@ 0xfffffae0
    316c:	65682220 	strbvs	r2, [r8, #-544]!	@ 0xfffffde0
    3170:	2022706c 	eorcs	r7, r2, ip, rrx
    3174:	6c206f74 	stcvs	15, cr6, [r0], #-464	@ 0xfffffe30
    3178:	20747369 	rsbscs	r7, r4, r9, ror #6
    317c:	206c6c61 	rsbcs	r6, ip, r1, ror #24
    3180:	6d6d6f63 	stclvs	15, cr6, [sp, #-396]!	@ 0xfffffe74
    3184:	2e646e61 	cdpcs	14, 6, cr6, cr4, cr1, {3}
    3188:	0000000a 	andeq	r0, r0, sl
    318c:	00006c2d 	andeq	r6, r0, sp, lsr #24
    3190:	3a657375 	bcc	195ff6c <__ROM_SIZE__+0x191ff6c>
    3194:	6c656820 	stclvs	8, cr6, [r5], #-128	@ 0xffffff80
    3198:	6c2d2070 	stcvs	0, cr2, [sp], #-448	@ 0xfffffe40
    319c:	726f6620 	rsbvc	r6, pc, #32, 12	@ 0x2000000
    31a0:	73696c20 	cmnvc	r9, #32, 24	@ 0x2000
    31a4:	6e6f2074 	mcrvs	0, 3, r2, cr15, cr4, {3}
    31a8:	0a2e796c 	beq	ba1760 <__ROM_SIZE__+0xb61760>
    31ac:	0000000a 	andeq	r0, r0, sl
    31b0:	0000090a 	andeq	r0, r0, sl, lsl #18
    31b4:	0000000a 	andeq	r0, r0, sl
    31b8:	00000000 	andeq	r0, r0, r0
    31bc:	00007325 	andeq	r7, r0, r5, lsr #6
    31c0:	0073250a 	rsbseq	r2, r3, sl, lsl #10
    31c4:	00002023 	andeq	r2, r0, r3, lsr #32
    31c8:	74617473 	strbtvc	r7, [r1], #-1139	@ 0xfffffb8d
    31cc:	00007375 	andeq	r7, r0, r5, ror r3
    31d0:	75746552 	ldrbvc	r6, [r4, #-1362]!	@ 0xfffffaae
    31d4:	20736e72 	rsbscs	r6, r3, r2, ror lr
    31d8:	74697865 	strbtvc	r7, [r9], #-2149	@ 0xfffff79b
    31dc:	61747320 	cmnvs	r4, r0, lsr #6
    31e0:	20737574 	rsbscs	r7, r3, r4, ror r5
    31e4:	6c20666f 	stcvs	6, cr6, [r0], #-444	@ 0xfffffe44
    31e8:	20747361 	rsbscs	r7, r4, r1, ror #6
    31ec:	63657865 	cmnvs	r5, #6619136	@ 0x650000
    31f0:	64657475 	strbtvs	r7, [r5], #-1141	@ 0xfffffb8b
    31f4:	6d6f6320 	stclvs	3, cr6, [pc, #-128]!	@ 317c <cmd_end_+0x730>
    31f8:	646e616d 	strbtvs	r6, [lr], #-365	@ 0xfffffe93
    31fc:	00000000 	andeq	r0, r0, r0
    3200:	706c6568 	rsbvc	r6, ip, r8, ror #10
    3204:	00000000 	andeq	r0, r0, r0
    3208:	6e697250 	mcrvs	2, 3, r7, cr9, cr0, {2}
    320c:	61207374 			@ <UNDEFINED> instruction: 0x61207374
    3210:	61206c6c 			@ <UNDEFINED> instruction: 0x61206c6c
    3214:	6c696176 	stfvse	f6, [r9], #-472	@ 0xfffffe28
    3218:	656c6261 	strbvs	r6, [ip, #-609]!	@ 0xfffffd9f
    321c:	6d6f6320 	stclvs	3, cr6, [pc, #-128]!	@ 31a4 <cmd_end_+0x758>
    3220:	646e616d 	strbtvs	r6, [lr], #-365	@ 0xfffffe93
    3224:	00000073 	andeq	r0, r0, r3, ror r0
    3228:	73726576 	cmnvc	r2, #494927872	@ 0x1d800000
    322c:	006e6f69 	rsbeq	r6, lr, r9, ror #30
    3230:	6e697250 	mcrvs	2, 3, r7, cr9, cr0, {2}
    3234:	64207374 	strtvs	r7, [r0], #-884	@ 0xfffffc8c
    3238:	69617465 	stmdbvs	r1!, {r0, r2, r5, r6, sl, ip, sp, lr}^
    323c:	6f20736c 	svcvs	0x0020736c
    3240:	68742066 	ldmdavs	r4!, {r1, r2, r5, r6, sp}^
    3244:	75622065 	strbvc	r2, [r2, #-101]!	@ 0xffffff9b
    3248:	00646c69 	rsbeq	r6, r4, r9, ror #24
    324c:	74736968 	ldrbtvc	r6, [r3], #-2408	@ 0xfffff698
    3250:	0079726f 	rsbseq	r7, r9, pc, ror #4
    3254:	776f6853 			@ <UNDEFINED> instruction: 0x776f6853
    3258:	6d6f6320 	stclvs	3, cr6, [pc, #-128]!	@ 31e0 <cmd_end_+0x794>
    325c:	646e616d 	strbtvs	r6, [lr], #-365	@ 0xfffffe93
    3260:	73696820 	cmnvc	r9, #32, 16	@ 0x200000
    3264:	79726f74 	ldmdbvc	r2!, {r2, r4, r5, r6, r8, r9, sl, fp, sp, lr}^
    3268:	00000000 	andeq	r0, r0, r0

0000326c <k>:
static const WORD k[64] = {
    326c:	428a2f98 	addmi	r2, sl, #152, 30	@ 0x260
    3270:	71374491 	teqvc	r7, r1	@ <illegal shifter operand>
    3274:	b5c0fbcf 	strblt	pc, [r0, #3023]	@ 0xbcf	@ <UNPREDICTABLE>
    3278:	e9b5dba5 	ldmib	r5!, {r0, r2, r5, r7, r8, r9, fp, ip, lr, pc}
    327c:	3956c25b 	ldmdbcc	r6, {r0, r1, r3, r4, r6, r9, lr, pc}^
    3280:	59f111f1 	ldmibpl	r1!, {r0, r4, r5, r6, r7, r8, ip}^
    3284:	923f82a4 	eorsls	r8, pc, #164, 4	@ 0x4000000a
    3288:	ab1c5ed5 	blge	71ade4 <__ROM_SIZE__+0x6dade4>
    328c:	d807aa98 	stmdale	r7, {r3, r4, r7, r9, fp, sp, pc}
    3290:	12835b01 	addne	r5, r3, #1024	@ 0x400
    3294:	243185be 	ldrtcs	r8, [r1], #-1470	@ 0xfffffa42
    3298:	550c7dc3 	strpl	r7, [ip, #-3523]	@ 0xfffff23d
    329c:	72be5d74 	adcsvc	r5, lr, #116, 26	@ 0x1d00
    32a0:	80deb1fe 	ldrshhi	fp, [lr], #30
    32a4:	9bdc06a7 	blls	ff704d48 <_STACK_TOP_+0xdf6fcd4c>
    32a8:	c19bf174 	orrsgt	pc, fp, r4, ror r1	@ <UNPREDICTABLE>
    32ac:	e49b69c1 	ldr	r6, [fp], #2497	@ 0x9c1
    32b0:	efbe4786 	svc	0x00be4786
    32b4:	0fc19dc6 	svceq	0x00c19dc6
    32b8:	240ca1cc 	strcs	sl, [ip], #-460	@ 0xfffffe34
    32bc:	2de92c6f 	stclcs	12, cr2, [r9, #444]!	@ 0x1bc
    32c0:	4a7484aa 	bmi	1d24570 <__ROM_SIZE__+0x1ce4570>
    32c4:	5cb0a9dc 			@ <UNDEFINED> instruction: 0x5cb0a9dc
    32c8:	76f988da 	usatvc	r8, #25, sl, asr #17
    32cc:	983e5152 	ldmdals	lr!, {r1, r4, r6, r8, ip, lr}
    32d0:	a831c66d 	ldmdage	r1!, {r0, r2, r3, r5, r6, r9, sl, lr, pc}
    32d4:	b00327c8 	andlt	r2, r3, r8, asr #15
    32d8:	bf597fc7 	svclt	0x00597fc7
    32dc:	c6e00bf3 			@ <UNDEFINED> instruction: 0xc6e00bf3
    32e0:	d5a79147 	strle	r9, [r7, #327]!	@ 0x147
    32e4:	06ca6351 			@ <UNDEFINED> instruction: 0x06ca6351
    32e8:	14292967 	strtne	r2, [r9], #-2407	@ 0xfffff699
    32ec:	27b70a85 	ldrcs	r0, [r7, r5, lsl #21]!
    32f0:	2e1b2138 	mrccs	1, 0, r2, cr11, cr8, {1}
    32f4:	4d2c6dfc 	stcmi	13, cr6, [ip, #-1008]!	@ 0xfffffc10
    32f8:	53380d13 	teqpl	r8, #1216	@ 0x4c0
    32fc:	650a7354 	strvs	r7, [sl, #-852]	@ 0xfffffcac
    3300:	766a0abb 			@ <UNDEFINED> instruction: 0x766a0abb
    3304:	81c2c92e 	bichi	ip, r2, lr, lsr #18
    3308:	92722c85 	rsbsls	r2, r2, #34048	@ 0x8500
    330c:	a2bfe8a1 	adcsge	lr, pc, #10551296	@ 0xa10000
    3310:	a81a664b 	ldmdage	sl, {r0, r1, r3, r6, r9, sl, sp, lr}
    3314:	c24b8b70 	subgt	r8, fp, #112, 22	@ 0x1c000
    3318:	c76c51a3 	strbgt	r5, [ip, -r3, lsr #3]!
    331c:	d192e819 	orrsle	lr, r2, r9, lsl r8
    3320:	d6990624 	ldrle	r0, [r9], r4, lsr #12
    3324:	f40e3585 	vst3.32	{d3,d5,d7}, [lr], r5
    3328:	106aa070 	rsbne	sl, sl, r0, ror r0
    332c:	19a4c116 	stmibne	r4!, {r1, r2, r4, r8, lr, pc}
    3330:	1e376c08 	cdpne	12, 3, cr6, cr7, cr8, {0}
    3334:	2748774c 	strbcs	r7, [r8, -ip, asr #14]
    3338:	34b0bcb5 	ldrtcc	fp, [r0], #3253	@ 0xcb5
    333c:	391c0cb3 	ldmdbcc	ip, {r0, r1, r4, r5, r7, sl, fp}
    3340:	4ed8aa4a 	vfnmami.f32	s21, s16, s20
    3344:	5b9cca4f 	blpl	fe735c88 <_STACK_TOP_+0xde72dc8c>
    3348:	682e6ff3 	stmdavs	lr!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, fp, sp, lr}
    334c:	748f82ee 	strvc	r8, [pc], #750	@ 3354 <k+0xe8>
    3350:	78a5636f 	stmiavc	r5!, {r0, r1, r2, r3, r5, r6, r8, r9, sp, lr}
    3354:	84c87814 	strbhi	r7, [r8], #2068	@ 0x814
    3358:	8cc70208 	sfmhi	f0, 2, [r7], {8}
    335c:	90befffa 	ldrshtls	pc, [lr], sl	@ <UNPREDICTABLE>
    3360:	a4506ceb 	ldrbge	r6, [r0], #-3307	@ 0xfffff315
    3364:	bef9a3f7 	mrclt	3, 7, sl, cr9, cr7, {7}
    3368:	c67178f2 			@ <UNDEFINED> instruction: 0xc67178f2
    336c:	6972700a 	ldmdbvs	r2!, {r1, r3, ip, sp, lr}^
    3370:	2d66746e 	cfstrdcs	mvd7, [r6, #-440]!	@ 0xfffffe48
    3374:	6f727265 	svcvs	0x00727265
    3378:	00000a72 	andeq	r0, r0, r2, ror sl

0000337c <hextable>:
static char hextable[] = {'0', '1', '2', '3', '4', '5', '6', '7',
    337c:	33323130 	teqcc	r2, #48, 2
    3380:	37363534 			@ <UNDEFINED> instruction: 0x37363534
    3384:	42413938 	submi	r3, r1, #56, 18	@ 0xe0000
    3388:	46454443 	strbmi	r4, [r5], -r3, asr #8
    338c:	6972700a 	ldmdbvs	r2!, {r1, r3, ip, sp, lr}^
    3390:	3266746e 	rsbcc	r7, r6, #1845493760	@ 0x6e000000
    3394:	7272652d 	rsbsvc	r6, r2, #188743680	@ 0xb400000
    3398:	000a726f 	andeq	r7, sl, pc, ror #4

0000339c <hextable2>:
static char hextable2[] = {'0', '1', '2', '3', '4', '5', '6', '7',
    339c:	33323130 	teqcc	r2, #48, 2
    33a0:	37363534 			@ <UNDEFINED> instruction: 0x37363534
    33a4:	42413938 	submi	r3, r1, #56, 18	@ 0xe0000
    33a8:	46454443 	strbmi	r4, [r5], -r3, asr #8
    33ac:	67617355 			@ <UNDEFINED> instruction: 0x67617355
    33b0:	25203a65 	strcs	r3, [r0, #-2661]!	@ 0xfffff59b
    33b4:	613c2073 	teqvs	ip, r3, ror r0
    33b8:	65726464 	ldrbvs	r6, [r2, #-1124]!	@ 0xfffffb9c
    33bc:	203e7373 	eorscs	r7, lr, r3, ror r3
    33c0:	206e6928 	rsbcs	r6, lr, r8, lsr #18
    33c4:	29786568 	ldmdbcs	r8!, {r3, r5, r6, r8, sl, sp, lr}^
    33c8:	0000000a 	andeq	r0, r0, sl
    33cc:	78257830 	stmdavc	r5!, {r4, r5, fp, ip, sp, lr}
    33d0:	7830203a 	ldmdavc	r0!, {r1, r3, r4, r5, sp}
    33d4:	000a7825 	andeq	r7, sl, r5, lsr #16
    33d8:	67617355 			@ <UNDEFINED> instruction: 0x67617355
    33dc:	25203a65 	strcs	r3, [r0, #-2661]!	@ 0xfffff59b
    33e0:	613c2073 	teqvs	ip, r3, ror r0
    33e4:	65726464 	ldrbvs	r6, [r2, #-1124]!	@ 0xfffffb9c
    33e8:	203e7373 	eorscs	r7, lr, r3, ror r3
    33ec:	206e6928 	rsbcs	r6, lr, r8, lsr #18
    33f0:	29786568 	ldmdbcs	r8!, {r3, r5, r6, r8, sl, sp, lr}^
    33f4:	61763c20 	cmnvs	r6, r0, lsr #24
    33f8:	3e65756c 	cdpcc	5, 6, cr7, cr5, cr12, {3}
    33fc:	6e692820 	cdpvs	8, 6, cr2, cr9, cr0, {1}
    3400:	78656820 	stmdavc	r5!, {r5, fp, sp, lr}^
    3404:	00000a29 	andeq	r0, r0, r9, lsr #20
    3408:	67617355 			@ <UNDEFINED> instruction: 0x67617355
    340c:	25203a65 	strcs	r3, [r0, #-2661]!	@ 0xfffff59b
    3410:	613c2073 	teqvs	ip, r3, ror r0
    3414:	65726464 	ldrbvs	r6, [r2, #-1124]!	@ 0xfffffb9c
    3418:	203e7373 	eorscs	r7, lr, r3, ror r3
    341c:	206e6928 	rsbcs	r6, lr, r8, lsr #18
    3420:	29786568 	ldmdbcs	r8!, {r3, r5, r6, r8, sl, sp, lr}^
    3424:	756e3c20 	strbvc	r3, [lr, #-3104]!	@ 0xfffff3e0
    3428:	6f775f6d 	svcvs	0x00775f6d
    342c:	3e736472 	mrccc	4, 3, r6, cr3, cr2, {3}
    3430:	6e692820 	cdpvs	8, 6, cr2, cr9, cr0, {1}
    3434:	63656420 	cmnvs	r5, #32, 8	@ 0x20000000
    3438:	6c616d69 	stclvs	13, cr6, [r1], #-420	@ 0xfffffe5c
    343c:	00000a29 	andeq	r0, r0, r9, lsr #20
    3440:	6f727245 	svcvs	0x00727245
    3444:	49203a72 	stmdbmi	r0!, {r1, r4, r5, r6, r9, fp, ip, sp}
    3448:	6c61766e 	stclvs	6, cr7, [r1], #-440	@ 0xfffffe48
    344c:	62206469 	eorvs	r6, r0, #1761607680	@ 0x69000000
    3450:	6c207469 	cfstrsvs	mvf7, [r0], #-420	@ 0xfffffe5c
    3454:	7461636f 	strbtvc	r6, [r1], #-879	@ 0xfffffc91
    3458:	206e6f69 	rsbcs	r6, lr, r9, ror #30
    345c:	75677261 	strbvc	r7, [r7, #-609]!	@ 0xfffffd9f
    3460:	746e656d 	strbtvc	r6, [lr], #-1389	@ 0xfffffa93
    3464:	0000000a 	andeq	r0, r0, sl
    3468:	6f727245 	svcvs	0x00727245
    346c:	49203a72 	stmdbmi	r0!, {r1, r4, r5, r6, r9, fp, ip, sp}
    3470:	6c61766e 	stclvs	6, cr7, [r1], #-440	@ 0xfffffe48
    3474:	62206469 	eorvs	r6, r0, #1761607680	@ 0x69000000
    3478:	76207469 	strtvc	r7, [r0], -r9, ror #8
    347c:	65756c61 	ldrbvs	r6, [r5, #-3169]!	@ 0xfffff39f
    3480:	67726120 	ldrbvs	r6, [r2, -r0, lsr #2]!
    3484:	6e656d75 	mcrvs	13, 3, r6, cr5, cr5, {3}
    3488:	00000a74 	andeq	r0, r0, r4, ror sl
    348c:	67617355 			@ <UNDEFINED> instruction: 0x67617355
    3490:	25203a65 	strcs	r3, [r0, #-2661]!	@ 0xfffff59b
    3494:	613c2073 	teqvs	ip, r3, ror r0
    3498:	65726464 	ldrbvs	r6, [r2, #-1124]!	@ 0xfffffb9c
    349c:	695f7373 	ldmdbvs	pc, {r0, r1, r4, r5, r6, r8, r9, ip, sp, lr}^	@ <UNPREDICTABLE>
    34a0:	65685f6e 	strbvs	r5, [r8, #-3950]!	@ 0xfffff092
    34a4:	32332878 	eorscc	r2, r3, #120, 16	@ 0x780000
    34a8:	7469622d 	strbtvc	r6, [r9], #-557	@ 0xfffffdd3
    34ac:	203e2973 	eorscs	r2, lr, r3, ror r9
    34b0:	7469623c 	strbtvc	r6, [r9], #-572	@ 0xfffffdc4
    34b4:	636f6c5f 	cmnvs	pc, #24320	@ 0x5f00
    34b8:	6f697461 	svcvs	0x00697461
    34bc:	6e695f6e 	cdpvs	15, 6, cr5, cr9, cr14, {3}
    34c0:	6365645f 	cmnvs	r5, #1593835520	@ 0x5f000000
    34c4:	6c616d69 	stclvs	13, cr6, [r1], #-420	@ 0xfffffe5c
    34c8:	74203028 	strtvc	r3, [r0], #-40	@ 0xffffffd8
    34cc:	3133206f 	teqcc	r3, pc, rrx
    34d0:	3c203e29 	stccc	14, cr3, [r0], #-164	@ 0xffffff5c
    34d4:	5f746962 	svcpl	0x00746962
    34d8:	756c6176 	strbvc	r6, [ip, #-374]!	@ 0xfffffe8a
    34dc:	20302865 	eorscs	r2, r0, r5, ror #16
    34e0:	3120726f 			@ <UNDEFINED> instruction: 0x3120726f
    34e4:	000a3e29 	andeq	r3, sl, r9, lsr #28
    34e8:	20746942 	rsbscs	r6, r4, r2, asr #18
    34ec:	40207525 	eormi	r7, r0, r5, lsr #10
    34f0:	25783020 	ldrbcs	r3, [r8, #-32]!	@ 0xffffffe0
    34f4:	3a783830 	bcc	1e115bc <__ROM_SIZE__+0x1dd15bc>
    34f8:	0a752520 	beq	1d4c980 <__ROM_SIZE__+0x1d0c980>
    34fc:	00000000 	andeq	r0, r0, r0
    3500:	67617355 			@ <UNDEFINED> instruction: 0x67617355
    3504:	25203a65 	strcs	r3, [r0, #-2661]!	@ 0xfffff59b
    3508:	613c2073 	teqvs	ip, r3, ror r0
    350c:	65726464 	ldrbvs	r6, [r2, #-1124]!	@ 0xfffffb9c
    3510:	695f7373 	ldmdbvs	pc, {r0, r1, r4, r5, r6, r8, r9, ip, sp, lr}^	@ <UNPREDICTABLE>
    3514:	65685f6e 	strbvs	r5, [r8, #-3950]!	@ 0xfffff092
    3518:	32332878 	eorscc	r2, r3, #120, 16	@ 0x780000
    351c:	7469622d 	strbtvc	r6, [r9], #-557	@ 0xfffffdd3
    3520:	203e2973 	eorscs	r2, lr, r3, ror r9
    3524:	7469623c 	strbtvc	r6, [r9], #-572	@ 0xfffffdc4
    3528:	636f6c5f 	cmnvs	pc, #24320	@ 0x5f00
    352c:	6f697461 	svcvs	0x00697461
    3530:	6e695f6e 	cdpvs	15, 6, cr5, cr9, cr14, {3}
    3534:	6365645f 	cmnvs	r5, #1593835520	@ 0x5f000000
    3538:	6c616d69 	stclvs	13, cr6, [r1], #-420	@ 0xfffffe5c
    353c:	74203028 	strtvc	r3, [r0], #-40	@ 0xffffffd8
    3540:	3133206f 	teqcc	r3, pc, rrx
    3544:	00000a29 	andeq	r0, r0, r9, lsr #20
    3548:	64616572 	strbtvs	r6, [r1], #-1394	@ 0xfffffa8e
    354c:	00000000 	andeq	r0, r0, r0
    3550:	64616552 	strbtvs	r6, [r1], #-1362	@ 0xfffffaae
    3554:	756e2073 	strbvc	r2, [lr, #-115]!	@ 0xffffff8d
    3558:	7265626d 	rsbvc	r6, r5, #-805306362	@ 0xd0000006
    355c:	20666f20 	rsbcs	r6, r6, r0, lsr #30
    3560:	65747962 	ldrbvs	r7, [r4, #-2402]!	@ 0xfffff69e
    3564:	72662073 	rsbvc	r2, r6, #115	@ 0x73
    3568:	6d206d6f 	stcvs	13, cr6, [r0, #-444]!	@ 0xfffffe44
    356c:	726f6d65 	rsbvc	r6, pc, #6464	@ 0x1940
    3570:	00000079 	andeq	r0, r0, r9, ror r0
    3574:	00323377 	eorseq	r3, r2, r7, ror r3
    3578:	74697277 	strbtvc	r7, [r9], #-631	@ 0xfffffd89
    357c:	61207365 			@ <UNDEFINED> instruction: 0x61207365
    3580:	20323320 	eorscs	r3, r2, r0, lsr #6
    3584:	20746962 	rsbscs	r6, r4, r2, ror #18
    3588:	756c6176 	strbvc	r6, [ip, #-374]!	@ 0xfffffe8a
    358c:	6f742065 	svcvs	0x00742065
    3590:	6d206120 	stfvss	f6, [r0, #-128]!	@ 0xffffff80
    3594:	726f6d65 	rsbvc	r6, pc, #6464	@ 0x1940
    3598:	6f6c2079 	svcvs	0x006c2079
    359c:	69746163 	ldmdbvs	r4!, {r0, r1, r5, r6, r8, sp, lr}^
    35a0:	00006e6f 	andeq	r6, r0, pc, ror #28
    35a4:	00323372 	eorseq	r3, r2, r2, ror r3
    35a8:	64616572 	strbtvs	r6, [r1], #-1394	@ 0xfffffa8e
    35ac:	20612073 	rsbcs	r2, r1, r3, ror r0
    35b0:	62203233 	eorvs	r3, r0, #805306371	@ 0x30000003
    35b4:	6d207469 	cfstrsvs	mvf7, [r0, #-420]!	@ 0xfffffe5c
    35b8:	726f6d65 	rsbvc	r6, pc, #6464	@ 0x1940
    35bc:	6f6c2079 	svcvs	0x006c2079
    35c0:	69746163 	ldmdbvs	r4!, {r0, r1, r5, r6, r8, sp, lr}^
    35c4:	00006e6f 	andeq	r6, r0, pc, ror #28
    35c8:	00006272 	andeq	r6, r0, r2, ror r2
    35cc:	64616572 	strbtvs	r6, [r1], #-1394	@ 0xfffffa8e
    35d0:	20612073 	rsbcs	r2, r1, r3, ror r0
    35d4:	20746962 	rsbscs	r6, r4, r2, ror #18
    35d8:	6d6f7266 	sfmvs	f7, 2, [pc, #-408]!	@ 3448 <hextable2+0xac>
    35dc:	6d656d20 	stclvs	13, cr6, [r5, #-128]!	@ 0xffffff80
    35e0:	2079726f 	rsbscs	r7, r9, pc, ror #4
    35e4:	61636f6c 	cmnvs	r3, ip, ror #30
    35e8:	6e6f6974 			@ <UNDEFINED> instruction: 0x6e6f6974
    35ec:	00000000 	andeq	r0, r0, r0
    35f0:	00006277 	andeq	r6, r0, r7, ror r2
    35f4:	74697277 	strbtvc	r7, [r9], #-631	@ 0xfffffd89
    35f8:	20612065 	rsbcs	r2, r1, r5, rrx
    35fc:	20746962 	rsbscs	r6, r4, r2, ror #18
    3600:	6d206f74 	stcvs	15, cr6, [r0, #-464]!	@ 0xfffffe30
    3604:	726f6d65 	rsbvc	r6, pc, #6464	@ 0x1940
    3608:	6f6c2079 	svcvs	0x006c2079
    360c:	69746163 	ldmdbvs	r4!, {r0, r1, r5, r6, r8, sp, lr}^
    3610:	00006e6f 	andeq	r6, r0, pc, ror #28

00003614 <sbox>:
static const uint8_t sbox[256] = {
    3614:	7b777c63 	blvc	1de27a8 <__ROM_SIZE__+0x1da27a8>
    3618:	c56f6bf2 	strbgt	r6, [pc, #-3058]!	@ 2a2e <_varr32_bit+0x6>
    361c:	2b670130 	blcs	19c3ae4 <__ROM_SIZE__+0x1983ae4>
    3620:	76abd7fe 			@ <UNDEFINED> instruction: 0x76abd7fe
    3624:	7dc982ca 	sfmvc	f0, 3, [r9, #808]	@ 0x328
    3628:	f04759fa 			@ <UNDEFINED> instruction: 0xf04759fa
    362c:	afa2d4ad 	svcge	0x00a2d4ad
    3630:	c072a49c 			@ <UNDEFINED> instruction: 0xc072a49c
    3634:	2693fdb7 			@ <UNDEFINED> instruction: 0x2693fdb7
    3638:	ccf73f36 	ldclgt	15, cr3, [r7], #216	@ 0xd8
    363c:	f1e5a534 			@ <UNDEFINED> instruction: 0xf1e5a534
    3640:	1531d871 	ldrne	sp, [r1, #-2161]!	@ 0xfffff78f
    3644:	c323c704 			@ <UNDEFINED> instruction: 0xc323c704
    3648:	9a059618 	bls	168eb0 <__ROM_SIZE__+0x128eb0>
    364c:	e2801207 	add	r1, r0, #1879048192	@ 0x70000000
    3650:	75b227eb 	ldrvc	r2, [r2, #2027]!	@ 0x7eb
    3654:	1a2c8309 	bne	b24280 <__ROM_SIZE__+0xae4280>
    3658:	a05a6e1b 	subsge	r6, sl, fp, lsl lr
    365c:	b3d63b52 	bicslt	r3, r6, #83968	@ 0x14800
    3660:	842fe329 	strthi	lr, [pc], #-809	@ 3668 <sbox+0x54>
    3664:	ed00d153 	stfd	f5, [r0, #-332]	@ 0xfffffeb4
    3668:	5bb1fc20 	blpl	fec826f0 <_STACK_TOP_+0xdec7a6f4>
    366c:	39becb6a 	ldmibcc	lr!, {r1, r3, r5, r6, r8, r9, fp, lr, pc}
    3670:	cf584c4a 	svcgt	0x00584c4a
    3674:	fbaaefd0 	blx	feabf5be <_STACK_TOP_+0xdeab75c2>
    3678:	85334d43 	ldrhi	r4, [r3, #-3395]!	@ 0xfffff2bd
    367c:	7f02f945 	svcvc	0x0002f945
    3680:	a89f3c50 	ldmge	pc, {r4, r6, sl, fp, ip, sp}	@ <UNPREDICTABLE>
    3684:	8f40a351 	svchi	0x0040a351
    3688:	f5389d92 			@ <UNDEFINED> instruction: 0xf5389d92
    368c:	21dab6bc 	ldrhcs	fp, [sl, #108]	@ 0x6c
    3690:	d2f3ff10 	rscsle	pc, r3, #16, 30	@ 0x40
    3694:	ec130ccd 	ldc	12, cr0, [r3], {205}	@ 0xcd
    3698:	1744975f 	smlsldne	r9, r4, pc, r7	@ <UNPREDICTABLE>
    369c:	3d7ea7c4 	ldclcc	7, cr10, [lr, #-784]!	@ 0xfffffcf0
    36a0:	73195d64 	tstvc	r9, #100, 26	@ 0x1900
    36a4:	dc4f8160 	stflep	f0, [pc], {96}	@ 0x60
    36a8:	88902a22 	ldmhi	r0, {r1, r5, r9, fp, sp}
    36ac:	14b8ee46 	ldrtne	lr, [r8], #3654	@ 0xe46
    36b0:	db0b5ede 	blle	2db230 <__ROM_SIZE__+0x29b230>
    36b4:	0a3a32e0 	beq	e9023c <__ROM_SIZE__+0xe5023c>
    36b8:	5c240649 	stcpl	6, cr0, [r4], #-292	@ 0xfffffedc
    36bc:	62acd3c2 	adcvs	sp, ip, #134217731	@ 0x8000003
    36c0:	79e49591 	stmibvc	r4!, {r0, r4, r7, r8, sl, ip, pc}^
    36c4:	6d37c8e7 	ldcvs	8, cr12, [r7, #-924]!	@ 0xfffffc64
    36c8:	a94ed58d 	stmdbge	lr, {r0, r2, r3, r7, r8, sl, ip, lr, pc}^
    36cc:	eaf4566c 	b	ffd19084 <_STACK_TOP_+0xdfd11088>
    36d0:	08ae7a65 	stmiaeq	lr!, {r0, r2, r5, r6, r9, fp, ip, sp, lr}
    36d4:	2e2578ba 	mcrcs	8, 1, r7, cr5, cr10, {5}
    36d8:	c6b4a61c 	ssatgt	sl, #21, ip, lsl #12
    36dc:	1f74dde8 	svcne	0x0074dde8
    36e0:	8a8bbd4b 	bhi	fe2f2c14 <_STACK_TOP_+0xde2eac18>
    36e4:	66b53e70 			@ <UNDEFINED> instruction: 0x66b53e70
    36e8:	0ef60348 	cdpeq	3, 15, cr0, cr6, cr8, {2}
    36ec:	b9573561 	ldmdblt	r7, {r0, r5, r6, r8, sl, ip, sp}^
    36f0:	9e1dc186 	mnfls<illegal precision>	f4, f6
    36f4:	1198f8e1 	orrsne	pc, r8, r1, ror #17
    36f8:	948ed969 	strls	sp, [lr], #2409	@ 0x969
    36fc:	e9871e9b 	stmib	r7, {r0, r1, r3, r4, r7, r9, sl, fp, ip}
    3700:	df2855ce 	svcle	0x002855ce
    3704:	0d89a18c 	stfeqd	f2, [r9, #560]	@ 0x230
    3708:	6842e6bf 	stmdavs	r2, {r0, r1, r2, r3, r4, r5, r7, r9, sl, sp, lr, pc}^
    370c:	0f2d9941 	svceq	0x002d9941
    3710:	16bb54b0 			@ <UNDEFINED> instruction: 0x16bb54b0

00003714 <Rcon>:
static const uint8_t Rcon[11] = {
    3714:	0402018d 	streq	r0, [r2], #-397	@ 0xfffffe73
    3718:	40201008 	eormi	r1, r0, r8
    371c:	00361b80 	eorseq	r1, r6, r0, lsl #23

00003720 <rsbox>:
static const uint8_t rsbox[256] = {
    3720:	d56a0952 	strble	r0, [sl, #-2386]!	@ 0xfffff6ae
    3724:	38a53630 	stmiacc	r5!, {r4, r5, r9, sl, ip, sp}
    3728:	9ea340bf 	mcrls	0, 5, r4, cr3, cr15, {5}
    372c:	fbd7f381 	blx	ff60053a <_STACK_TOP_+0xdf5f853e>
    3730:	8239e37c 	eorshi	lr, r9, #124, 6	@ 0xf0000001
    3734:	87ff2f9b 			@ <UNDEFINED> instruction: 0x87ff2f9b
    3738:	44438e34 	strbmi	r8, [r3], #-3636	@ 0xfffff1cc
    373c:	cbe9dec4 	blgt	ffa7b254 <_STACK_TOP_+0xdfa73258>
    3740:	32947b54 	addscc	r7, r4, #84, 22	@ 0x15000
    3744:	3d23c2a6 	sfmcc	f4, 1, [r3, #-664]!	@ 0xfffffd68
    3748:	0b954cee 	bleq	fe556b08 <_STACK_TOP_+0xde54eb0c>
    374c:	4ec3fa42 			@ <UNDEFINED> instruction: 0x4ec3fa42
    3750:	66a12e08 	strtvs	r2, [r1], r8, lsl #28
    3754:	b224d928 	eorlt	sp, r4, #40, 18	@ 0xa0000
    3758:	49a25b76 	stmibmi	r2!, {r1, r2, r4, r5, r6, r8, r9, fp, ip, lr}
    375c:	25d18b6d 	ldrbcs	r8, [r1, #2925]	@ 0xb6d
    3760:	64f6f872 	ldrbtvs	pc, [r6], #2162	@ 0x872	@ <UNPREDICTABLE>
    3764:	16986886 	ldrne	r6, [r8], r6, lsl #17
    3768:	cc5ca4d4 	cfldrdgt	mvd10, [ip], {212}	@ 0xd4
    376c:	92b6655d 	adcsls	r6, r6, #390070272	@ 0x17400000
    3770:	5048706c 	subpl	r7, r8, ip, rrx
    3774:	dab9edfd 	ble	fee7ef70 <_STACK_TOP_+0xdee76f74>
    3778:	5746155e 	smlsldpl	r1, r6, lr, r5
    377c:	849d8da7 	ldrhi	r8, [sp], #3495	@ 0xda7
    3780:	00abd890 	umlaleq	sp, fp, r0, r8
    3784:	0ad3bc8c 	beq	ff4f29bc <_STACK_TOP_+0xdf4ea9c0>
    3788:	0558e4f7 	ldrbeq	lr, [r8, #-1271]	@ 0xfffffb09
    378c:	0645b3b8 			@ <UNDEFINED> instruction: 0x0645b3b8
    3790:	8f1e2cd0 	svchi	0x001e2cd0
    3794:	020f3fca 	andeq	r3, pc, #808	@ 0x328
    3798:	03bdafc1 			@ <UNDEFINED> instruction: 0x03bdafc1
    379c:	6b8a1301 	blvs	fe2883a8 <_STACK_TOP_+0xde2803ac>
    37a0:	4111913a 	tstmi	r1, sl, lsr r1
    37a4:	eadc674f 	b	ff71d4e8 <_STACK_TOP_+0xdf7154ec>
    37a8:	cecff297 	mcrgt	2, 6, pc, cr15, cr7, {4}	@ <UNPREDICTABLE>
    37ac:	73e6b4f0 	mvnvc	fp, #240, 8	@ 0xf0000000
    37b0:	2274ac96 	rsbscs	sl, r4, #38400	@ 0x9600
    37b4:	8535ade7 	ldrhi	sl, [r5, #-3559]!	@ 0xfffff219
    37b8:	e837f9e2 	ldmda	r7!, {r1, r5, r6, r7, r8, fp, ip, sp, lr, pc}
    37bc:	6edf751c 	mrcvs	5, 6, r7, cr15, cr12, {0}
    37c0:	711af147 	tstvc	sl, r7, asr #2	@ <UNPREDICTABLE>
    37c4:	89c5291d 	stmibhi	r5, {r0, r2, r3, r4, r8, fp, sp}^
    37c8:	0e62b76f 	cdpeq	7, 6, cr11, cr2, cr15, {3}
    37cc:	1bbe18aa 	blne	fef89a7c <_STACK_TOP_+0xdef81a80>
    37d0:	4b3e56fc 	blmi	f993c8 <__ROM_SIZE__+0xf593c8>
    37d4:	2079d2c6 	rsbscs	sp, r9, r6, asr #5
    37d8:	fec0db9a 	mcr2	11, 6, sp, cr0, cr10, {4}	@ <UNPREDICTABLE>
    37dc:	f45acd78 			@ <UNDEFINED> instruction: 0xf45acd78
    37e0:	33a8dd1f 			@ <UNDEFINED> instruction: 0x33a8dd1f
    37e4:	31c70788 	biccc	r0, r7, r8, lsl #15
    37e8:	591012b1 	ldmdbpl	r0, {r0, r4, r5, r7, r9, ip}
    37ec:	5fec8027 	svcpl	0x00ec8027
    37f0:	a97f5160 	ldmdbge	pc!, {r5, r6, r8, ip, lr}^	@ <UNPREDICTABLE>
    37f4:	0d4ab519 	cfstr64eq	mvdx11, [sl, #-100]	@ 0xffffff9c
    37f8:	9f7ae52d 	svcls	0x007ae52d
    37fc:	ef9cc993 	svc	0x009cc993
    3800:	4d3be0a0 	ldcmi	0, cr14, [fp, #-640]!	@ 0xfffffd80
    3804:	b0f52aae 	rscslt	r2, r5, lr, lsr #21
    3808:	3cbbebc8 	vldmiacc	fp!, {d14-<overflow reg d49>}
    380c:	61995383 	orrsvs	r5, r9, r3, lsl #7
    3810:	7e042b17 	vmovvc.32	d4[0], r2
    3814:	26d677ba 			@ <UNDEFINED> instruction: 0x26d677ba
    3818:	631469e1 	tstvs	r4, #3686400	@ 0x384000
    381c:	7d0c2155 	stfvcs	f2, [ip, #-340]	@ 0xfffffeac

00003820 <polynomial>:
const gf2elem_t polynomial = { 0x000000c9, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000008 }; 
    3820:	000000c9 	andeq	r0, r0, r9, asr #1
	...
    3834:	00000008 	andeq	r0, r0, r8

00003838 <coeff_b>:
const gf2elem_t coeff_b    = { 0x4a3205fd, 0x512f7874, 0x1481eb10, 0xb8c953ca, 0x0a601907, 0x00000002 }; 
    3838:	4a3205fd 	bmi	c85034 <__ROM_SIZE__+0xc45034>
    383c:	512f7874 			@ <UNDEFINED> instruction: 0x512f7874
    3840:	1481eb10 	strne	lr, [r1], #2832	@ 0xb10
    3844:	b8c953ca 	stmialt	r9, {r1, r3, r6, r7, r8, r9, ip, lr}^
    3848:	0a601907 	beq	1809c6c <__ROM_SIZE__+0x17c9c6c>
    384c:	00000002 	andeq	r0, r0, r2

00003850 <base_y>:
const gf2elem_t base_y     = { 0x797324f1, 0xb11c5c0c, 0xa2cdd545, 0x71a0094f, 0xd51fbc6c, 0x00000000 }; 
    3850:	797324f1 	ldmdbvc	r3!, {r0, r4, r5, r6, r7, sl, sp}^
    3854:	b11c5c0c 	tstlt	ip, ip, lsl #24
    3858:	a2cdd545 	sbcge	sp, sp, #289406976	@ 0x11400000
    385c:	71a0094f 	asrvc	r0, pc, #18
    3860:	d51fbc6c 	ldrle	fp, [pc, #-3180]	@ 2bfc <cmd_end_+0x1b0>
    3864:	00000000 	andeq	r0, r0, r0

00003868 <base_x>:
const gf2elem_t base_x     = { 0xe8343e36, 0xd4994637, 0xa0991168, 0x86a2d57e, 0xf0eba162, 0x00000003 }; 
    3868:	e8343e36 	ldmda	r4!, {r1, r2, r4, r5, r9, sl, fp, ip, sp}
    386c:	d4994637 	ldrle	r4, [r9], #1591	@ 0x637
    3870:	a0991168 	addsge	r1, r9, r8, ror #2
    3874:	86a2d57e 			@ <UNDEFINED> instruction: 0x86a2d57e
    3878:	f0eba162 			@ <UNDEFINED> instruction: 0xf0eba162
    387c:	00000003 	andeq	r0, r0, r3

00003880 <base_order>:
const scalar_t  base_order = { 0xa4234c33, 0x77e70c12, 0x000292fe, 0x00000000, 0x00000000, 0x00000004 }; 
    3880:	a4234c33 	strtge	r4, [r3], #-3123	@ 0xfffff3cd
    3884:	77e70c12 			@ <UNDEFINED> instruction: 0x77e70c12
    3888:	000292fe 	strdeq	r9, [r2], -lr
	...
    3894:	00000004 	andeq	r0, r0, r4

Disassembly of section .debug_info:

00000000 <.debug_info>:
       0:	000006f3 	strdeq	r0, [r0], -r3
       4:	04010005 	streq	r0, [r1], #-5
       8:	00000000 	andeq	r0, r0, r0
       c:	00004615 	andeq	r4, r0, r5, lsl r6
      10:	01f91d00 	mvnseq	r1, r0, lsl #26
      14:	00140000 	andseq	r0, r4, r0
      18:	03c00000 	biceq	r0, r0, #0
      1c:	01940000 	orrseq	r0, r4, r0
      20:	00000000 	andeq	r0, r0, r0
      24:	01050000 	mrseq	r0, (UNDEF: 5)
      28:	00012d06 	andeq	r2, r1, r6, lsl #26
      2c:	05020500 	streq	r0, [r2, #-1280]	@ 0xfffffb00
      30:	000001e3 	andeq	r0, r0, r3, ror #3
      34:	c7050405 	strgt	r0, [r5, -r5, lsl #8]
      38:	05000001 	streq	r0, [r0, #-1]
      3c:	01c20508 	biceq	r0, r2, r8, lsl #10
      40:	88070000 	stmdahi	r7, {}	@ <UNPREDICTABLE>
      44:	02000001 	andeq	r0, r0, #1
      48:	0053182e 	subseq	r1, r3, lr, lsr #16
      4c:	420d0000 	andmi	r0, sp, #0
      50:	05000000 	streq	r0, [r0, #-0]
      54:	012b0801 			@ <UNDEFINED> instruction: 0x012b0801
      58:	02050000 	andeq	r0, r5, #0
      5c:	00013907 	andeq	r3, r1, r7, lsl #18
      60:	07040500 	streq	r0, [r4, -r0, lsl #10]
      64:	00000176 	andeq	r0, r0, r6, ror r1
      68:	71070805 	tstvc	r7, r5, lsl #16
      6c:	16000001 	strne	r0, [r0], -r1
      70:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
      74:	04050074 	streq	r0, [r5], #-116	@ 0xffffff8c
      78:	00017b07 	andeq	r7, r1, r7, lsl #22
      7c:	000d0700 	andeq	r0, sp, r0, lsl #14
      80:	d6030000 	strle	r0, [r3], -r0
      84:	00007617 	andeq	r7, r0, r7, lsl r6
      88:	04080500 	streq	r0, [r8], #-1280	@ 0xfffffb00
      8c:	00000225 	andeq	r0, r0, r5, lsr #4
      90:	0001a017 	andeq	sl, r1, r7, lsl r0
      94:	05010000 	streq	r0, [r1, #-0]
      98:	00b8082c 	adcseq	r0, r8, ip, lsr #16
      9c:	96060000 	strls	r0, [r6], -r0
      a0:	0500000c 	streq	r0, [r0, #-12]
      a4:	00bd0b2e 	adcseq	r0, sp, lr, lsr #22
      a8:	18000000 	stmdane	r0, {}	@ <UNPREDICTABLE>
      ac:	05007649 	streq	r7, [r0, #-1609]	@ 0xfffff9b7
      b0:	00cd0b30 	sbceq	r0, sp, r0, lsr fp
      b4:	00f00000 	rscseq	r0, r0, r0
      b8:	0000900d 	andeq	r9, r0, sp
      bc:	00420800 	subeq	r0, r2, r0, lsl #16
      c0:	00cd0000 	sbceq	r0, sp, r0
      c4:	76090000 	strvc	r0, [r9], -r0
      c8:	ef000000 	svc	0x00000000
      cc:	00420800 	subeq	r0, r2, r0, lsl #16
      d0:	00dd0000 	sbcseq	r0, sp, r0
      d4:	76090000 	strvc	r0, [r9], -r0
      d8:	0f000000 	svceq	0x00000000
      dc:	00e20700 	rsceq	r0, r2, r0, lsl #14
      e0:	13040000 	movwne	r0, #16384	@ 0x4000
      e4:	00005317 	andeq	r5, r0, r7, lsl r3
      e8:	00dd0d00 	sbcseq	r0, sp, r0, lsl #26
      ec:	c9070000 	stmdbgt	r7, {}	@ <UNPREDICTABLE>
      f0:	04000000 	streq	r0, [r0], #-0
      f4:	00761714 	rsbseq	r1, r6, r4, lsl r7
      f8:	70130000 	andsvc	r0, r3, r0
      fc:	01371604 	teqeq	r7, r4, lsl #12
     100:	90060000 	andls	r0, r6, r0
     104:	04000007 	streq	r0, [r0], #-7
     108:	01370717 	teqeq	r7, r7, lsl r7
     10c:	06000000 	streq	r0, [r0], -r0
     110:	000000c1 	andeq	r0, r0, r1, asr #1
     114:	ee071804 	cdp	8, 0, cr1, cr7, cr4, {0}
     118:	40000000 	andmi	r0, r0, r0
     11c:	00015f06 	andeq	r5, r1, r6, lsl #30
     120:	15190400 	ldrne	r0, [r9, #-1024]	@ 0xfffffc00
     124:	00000068 	andeq	r0, r0, r8, rrx
     128:	0b2e0648 	bleq	b81a50 <__ROM_SIZE__+0xb41a50>
     12c:	1a040000 	bne	100134 <__ROM_SIZE__+0xc0134>
     130:	00014707 	andeq	r4, r1, r7, lsl #14
     134:	08005000 	stmdaeq	r0, {ip, lr}
     138:	000000dd 	ldrdeq	r0, [r0], -sp
     13c:	00000147 	andeq	r0, r0, r7, asr #2
     140:	00007609 	andeq	r7, r0, r9, lsl #12
     144:	08003f00 	stmdaeq	r0, {r8, r9, sl, fp, ip, sp}
     148:	000000ee 	andeq	r0, r0, lr, ror #1
     14c:	00000157 	andeq	r0, r0, r7, asr r1
     150:	00007609 	andeq	r7, r0, r9, lsl #12
     154:	07000700 	streq	r0, [r0, -r0, lsl #14]
     158:	00000166 	andeq	r0, r0, r6, ror #2
     15c:	fa031b04 	blx	c6d74 <__ROM_SIZE__+0x86d74>
     160:	19000000 	stmdbne	r0, {}	@ <UNPREDICTABLE>
     164:	00787463 	rsbseq	r7, r8, r3, ror #8
     168:	90172506 	andsls	r2, r7, r6, lsl #10
     16c:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
     170:	00000042 	andeq	r0, r0, r2, asr #32
     174:	0000017a 	andeq	r0, r0, sl, ror r1
     178:	3910001a 	ldmdbcc	r0, {r1, r3, r4}
     17c:	29000000 	stmdbcs	r0, {}	@ <UNPREDICTABLE>
     180:	0000016f 	andeq	r0, r0, pc, ror #2
     184:	0001d010 	andeq	sp, r1, r0, lsl r0
     188:	016f2c00 	cmneq	pc, r0, lsl #24
     18c:	ce100000 	cdpgt	0, 1, cr0, cr0, cr0, {0}
     190:	2d000000 	stccs	0, cr0, [r0, #-0]
     194:	0000016f 	andeq	r0, r0, pc, ror #2
     198:	646d631b 	strbtvs	r6, [sp], #-795	@ 0xfffffce5
     19c:	0f3b0600 	svceq	0x003b0600
     1a0:	000001a4 	andeq	r0, r0, r4, lsr #3
     1a4:	0001a904 	andeq	sl, r1, r4, lsl #18
     1a8:	006f1c00 	rsbeq	r1, pc, r0, lsl #24
     1ac:	01bd0000 			@ <UNDEFINED> instruction: 0x01bd0000
     1b0:	6f020000 	svcvs	0x00020000
     1b4:	02000000 	andeq	r0, r0, #0
     1b8:	000001bd 			@ <UNDEFINED> instruction: 0x000001bd
     1bc:	01c20400 	biceq	r0, r2, r0, lsl #8
     1c0:	c7040000 	strgt	r0, [r4, -r0]
     1c4:	05000001 	streq	r0, [r0, #-1]
     1c8:	01340801 	teqeq	r4, r1, lsl #16
     1cc:	c70d0000 	strgt	r0, [sp, -r0]
     1d0:	13000001 	movwne	r0, #1
     1d4:	0344060c 	movteq	r0, #17932	@ 0x460c
     1d8:	06000002 	streq	r0, [r0], -r2
     1dc:	0000025d 	andeq	r0, r0, sp, asr r2
     1e0:	030f4506 	movweq	r4, #62726	@ 0xf506
     1e4:	00000002 	andeq	r0, r0, r2
     1e8:	00000006 	andeq	r0, r0, r6
     1ec:	0f460600 	svceq	0x00460600
     1f0:	00000203 	andeq	r0, r0, r3, lsl #4
     1f4:	00da0604 	sbcseq	r0, sl, r4, lsl #12
     1f8:	47060000 	strmi	r0, [r6, -r0]
     1fc:	00019807 	andeq	r9, r1, r7, lsl #16
     200:	04000800 	streq	r0, [r0], #-2048	@ 0xfffff800
     204:	000001ce 	andeq	r0, r0, lr, asr #3
     208:	0001bc07 	andeq	fp, r1, r7, lsl #24
     20c:	03480600 	movteq	r0, #34304	@ 0x8600
     210:	000001d3 	ldrdeq	r0, [r0], -r3
     214:	0001121d 	andeq	r1, r1, sp, lsl r2
     218:	013b0100 	teqeq	fp, r0, lsl #2
     21c:	00000208 	andeq	r0, r0, r8, lsl #4
     220:	29680305 	stmdbcs	r8!, {r0, r2, r8, r9}^
     224:	a80a0000 	stmdage	sl, {}	@ <UNPREDICTABLE>
     228:	05000001 	streq	r0, [r0, #-1]
     22c:	00023c34 	andeq	r3, r2, r4, lsr ip
     230:	023c0200 	eorseq	r0, ip, #0, 4
     234:	41020000 	mrsmi	r0, (UNDEF: 2)
     238:	00000002 	andeq	r0, r0, r2
     23c:	00009004 	andeq	r9, r0, r4
     240:	004e0400 	subeq	r0, lr, r0, lsl #8
     244:	050a0000 	streq	r0, [sl, #-0]
     248:	04000001 	streq	r0, [r0], #-1
     24c:	00025c20 	andeq	r5, r2, r0, lsr #24
     250:	025c0200 	subseq	r0, ip, #0, 4
     254:	61020000 	mrsvs	r0, (UNDEF: 2)
     258:	00000002 	andeq	r0, r0, r2
     25c:	00015704 	andeq	r5, r1, r4, lsl #14
     260:	00dd0400 	sbcseq	r0, sp, r0, lsl #8
     264:	4c0a0000 	stcmi	0, cr0, [sl], {-0}
     268:	04000001 	streq	r0, [r0], #-1
     26c:	0002811f 	andeq	r8, r2, pc, lsl r1
     270:	025c0200 	subseq	r0, ip, #0, 4
     274:	81020000 	mrshi	r0, (UNDEF: 2)
     278:	02000002 	andeq	r0, r0, #2
     27c:	0000007d 	andeq	r0, r0, sp, ror r0
     280:	00e90400 	rsceq	r0, r9, r0, lsl #8
     284:	1f0a0000 	svcne	0x000a0000
     288:	04000001 	streq	r0, [r0], #-1
     28c:	0002971e 	andeq	r9, r2, lr, lsl r7
     290:	025c0200 	subseq	r0, ip, #0, 4
     294:	0b000000 	bleq	29c <vector_table+0x29c>
     298:	00000231 	andeq	r0, r0, r1, lsr r2
     29c:	6f056107 	svcvs	0x00056107
     2a0:	b7000000 	strlt	r0, [r0, -r0]
     2a4:	02000002 	andeq	r0, r0, #2
     2a8:	00000241 	andeq	r0, r0, r1, asr #4
     2ac:	00024102 	andeq	r4, r2, r2, lsl #2
     2b0:	02b70200 	adcseq	r0, r7, #0, 4
     2b4:	04000000 	streq	r0, [r0], #-0
     2b8:	00000042 	andeq	r0, r0, r2, asr #32
     2bc:	0000f50a 	andeq	pc, r0, sl, lsl #10
     2c0:	d23f0500 	eorsle	r0, pc, #0, 10
     2c4:	02000002 	andeq	r0, r0, #2
     2c8:	000002d2 	ldrdeq	r0, [r0], -r2
     2cc:	0002b702 	andeq	fp, r2, r2, lsl #14
     2d0:	b8040000 	stmdalt	r4, {}	@ <UNPREDICTABLE>
     2d4:	0b000000 	bleq	2dc <vector_table+0x2dc>
     2d8:	000000e7 	andeq	r0, r0, r7, ror #1
     2dc:	760e4a08 	strvc	r4, [lr], -r8, lsl #20
     2e0:	f7000000 			@ <UNDEFINED> instruction: 0xf7000000
     2e4:	02000002 	andeq	r0, r0, #2
     2e8:	000002f7 	strdeq	r0, [r0], -r7
     2ec:	00007602 	andeq	r7, r0, r2, lsl #12
     2f0:	02f70200 	rscseq	r0, r7, #0, 4
     2f4:	04000000 	streq	r0, [r0], #-0
     2f8:	00000053 	andeq	r0, r0, r3, asr r0
     2fc:	00024e0b 	andeq	r4, r2, fp, lsl #28
     300:	081f0900 	ldmdaeq	pc, {r8, fp}	@ <UNPREDICTABLE>
     304:	0000007d 	andeq	r0, r0, sp, ror r0
     308:	00000312 	andeq	r0, r0, r2, lsl r3
     30c:	00020302 	andeq	r0, r2, r2, lsl #6
     310:	b50b0000 	strlt	r0, [fp, #-0]
     314:	09000001 	stmdbeq	r0, {r0}
     318:	006f0527 	rsbeq	r0, pc, r7, lsr #10
     31c:	032d0000 			@ <UNDEFINED> instruction: 0x032d0000
     320:	03020000 	movweq	r0, #8192	@ 0x2000
     324:	02000002 	andeq	r0, r0, #2
     328:	00000203 	andeq	r0, r0, r3, lsl #4
     32c:	01dc0b00 	bicseq	r0, ip, r0, lsl #22
     330:	2c0a0000 	stccs	0, cr0, [sl], {-0}
     334:	00006f05 	andeq	r6, r0, r5, lsl #30
     338:	00034400 	andeq	r4, r3, r0, lsl #8
     33c:	02030200 	andeq	r0, r3, #0, 4
     340:	001e0000 	andseq	r0, lr, r0
     344:	00019014 	andeq	r9, r1, r4, lsl r0
     348:	006f3f00 	rsbeq	r3, pc, r0, lsl #30
     34c:	03c00000 	biceq	r0, r0, #0
     350:	00680000 	rsbeq	r0, r8, r0
     354:	9c010000 	stcls	0, cr0, [r1], {-0}
     358:	00000457 	andeq	r0, r0, r7, asr r4
     35c:	0001ed0e 	andeq	lr, r1, lr, lsl #26
     360:	6f193f00 	svcvs	0x00193f00
     364:	14000000 	strne	r0, [r0], #-0
     368:	0c000000 	stceq	0, cr0, [r0], {-0}
     36c:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
     370:	0000015a 	andeq	r0, r0, sl, asr r1
     374:	01bd263f 			@ <UNDEFINED> instruction: 0x01bd263f
     378:	00390000 	eorseq	r0, r9, r0
     37c:	002f0000 	eoreq	r0, pc, r0
     380:	d6110000 	ldrle	r0, [r1], -r0
     384:	3a000003 	bcc	398 <vector_table+0x398>
     388:	43000000 	movwmi	r0, #0
     38c:	0f000004 	svceq	0x00000004
     390:	00000244 	andeq	r0, r0, r4, asr #4
     394:	04571142 	ldrbeq	r1, [r7], #-322	@ 0xfffffebe
     398:	91030000 	mrsls	r0, (UNDEF: 3)
     39c:	f20f7ed8 			@ <UNDEFINED> instruction: 0xf20f7ed8
     3a0:	48000001 	stmdami	r0, {r0}
     3a4:	00015714 	andeq	r5, r1, r4, lsl r7
     3a8:	88910300 	ldmhi	r1, {r8, r9}
     3ac:	03e0037f 	mvneq	r0, #-67108863	@ 0xfc000001
     3b0:	02d70000 	sbcseq	r0, r7, #0
     3b4:	03c70000 	biceq	r0, r7, #0
     3b8:	01010000 	mrseq	r0, (UNDEF: 1)
     3bc:	40080251 	andmi	r0, r8, r1, asr r2
int finish_ecdhpair(int argc, char** argv) {
     3c0:	02520101 	subseq	r0, r2, #1073741824	@ 0x40000000
    if (argc == 4) {
     3c4:	0300007d 	movweq	r0, #125	@ 0x7d
    else printf("Incorrect number of arguments for PAIRECDH2\n");
     3c8:	000003ec 	andeq	r0, r0, ip, ror #7
     3cc:	00000297 	muleq	r0, r7, r2
     3d0:	000003e1 	andeq	r0, r0, r1, ror #7
     3d4:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
        decode_base64((uint8_t *)argv[3], 64, carpubkey);
     3d8:	0101007d 	tsteq	r1, sp, ror r0
     3dc:	00740252 	rsbseq	r0, r4, r2, asr r2
        ecdh_shared_secret(ECDH_privkey, carpubkey, ECDH_shared);
     3e0:	03f20300 	mvnseq	r0, #0, 6
     3e4:	02860000 	addeq	r0, r6, #0
     3e8:	03f60000 	mvnseq	r0, #0
        sha256_init(&shactx);
     3ec:	01010000 	mrseq	r0, (UNDEF: 1)
     3f0:	88910350 	ldmhi	r1, {r4, r6, r8, r9}
	    sha256_update(&shactx, ECDH_shared, ECC_PUB_KEY_SIZE);
     3f4:	fe03007f 	mcr2	0, 0, r0, cr3, cr15, {3}
     3f8:	66000003 	strvs	r0, [r0], -r3
     3fc:	17000002 	strne	r0, [r0, -r2]
	    sha256_final(&shactx, ECDH_AESkey);
     400:	01000004 	tsteq	r0, r4
     404:	91035001 	tstls	r3, r1
        AES_init_ctx(&ctx, ECDH_AESkey);
     408:	01017f88 	smlabbeq	r1, r8, pc, r7	@ <UNPREDICTABLE>
     40c:	00740251 	rsbseq	r0, r4, r1, asr r2
     410:	02520101 	subseq	r0, r2, #1073741824	@ 0x40000000
     414:	03003008 	movweq	r3, #8
     418:	00000408 	andeq	r0, r0, r8, lsl #8
     41c:	00000246 	andeq	r0, r0, r6, asr #4
     420:	00000432 	andeq	r0, r0, r2, lsr r4
     424:	03500101 	cmpeq	r0, #1073741824	@ 0x40000000
int car_mesg(int argc, char** argv) {
     428:	017f8891 			@ <UNDEFINED> instruction: 0x017f8891
     42c:	74025101 	strvc	r5, [r2], #-257	@ 0xfffffeff
    printf("Received a message from the car:");
     430:	100c0000 	andne	r0, ip, r0
     434:	26000004 	strcs	r0, [r0], -r4
    for (ctr = 1; ctr < argc; ctr++) {
     438:	01000002 	tsteq	r0, r2
        printf(" %s", argv[ctr]);
     43c:	74025101 	strvc	r5, [r2], #-257	@ 0xfffffeff
     440:	0c000000 	stceq	0, cr0, [r0], {-0}
    for (ctr = 1; ctr < argc; ctr++) {
     444:	000003ce 	andeq	r0, r0, lr, asr #7
     448:	0000032d 	andeq	r0, r0, sp, lsr #6
    printf("\n");
     44c:	05500101 	ldrbeq	r0, [r0, #-257]	@ 0xfffffeff
    if (argc > 1) {
     450:	002a5803 	eoreq	r5, sl, r3, lsl #16
}
     454:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
     458:	00000042 	andeq	r0, r0, r2, asr #32
        if (strcmp(argv[1], "PING_REPLY") == 0) {
     45c:	00000467 	andeq	r0, r0, r7, ror #8
     460:	00007609 	andeq	r7, r0, r9, lsl #12
            printf("Got a ping reply.\n");
     464:	14002f00 	strne	r2, [r0], #-3840	@ 0xfffff100
     468:	00000116 	andeq	r0, r0, r6, lsl r1
        else if (strcmp(argv[1], "PAIRECDH2") == 0) {
     46c:	00006f07 	andeq	r6, r0, r7, lsl #30
     470:	00042800 	andeq	r2, r4, r0, lsl #16
     474:	00012c00 	andeq	r2, r1, r0, lsl #24
            finish_ecdhpair(argc, argv);
     478:	ea9c0100 	b	fe700880 <_STACK_TOP_+0xde6f8884>
     47c:	0e000006 	cdpeq	0, 0, cr0, cr0, cr6, {0}
        else if (strcmp(argv[1], "AESB64") == 0) {
     480:	000001ed 	andeq	r0, r0, sp, ror #3
     484:	006f1207 	rsbeq	r1, pc, r7, lsl #4
     488:	005d0000 	subseq	r0, sp, r0
            if (argc == 3) { 
     48c:	00590000 	subseq	r0, r9, r0
                printf("Missing AESB64 encoded message\n");
     490:	5a0e0000 	bpl	380498 <__ROM_SIZE__+0x340498>
     494:	07000001 	streq	r0, [r0, -r1]
                len = decode_base64((uint8_t *) argv[2], strlen(argv[2]), decoded);
     498:	0001bd1f 	andeq	fp, r1, pc, lsl sp
     49c:	00006d00 	andeq	r6, r0, r0, lsl #26
     4a0:	00006900 	andeq	r6, r0, r0, lsl #18
     4a4:	74631200 	strbtvc	r1, [r3], #-512	@ 0xfffffe00
     4a8:	09080072 	stmdbeq	r8, {r1, r4, r5, r6}
                AES_ECB_decrypt(&ctx, decoded);
     4ac:	0000006f 	andeq	r0, r0, pc, rrx
     4b0:	00000083 	andeq	r0, r0, r3, lsl #1
                decoded[len] = '\0';
     4b4:	00000079 	andeq	r0, r0, r9, ror r0
     4b8:	00049611 	andeq	r9, r4, r1, lsl r6
     4bc:	00003200 	andeq	r3, r0, r0, lsl #4
                printf("Decoded/decrypted as %s\n", decoded);
     4c0:	00054600 	andeq	r4, r5, r0, lsl #12
     4c4:	02550f00 	subseq	r0, r5, #0, 30
     4c8:	191a0000 	ldmdbne	sl, {}	@ <UNPREDICTABLE>
        else if (strcmp(argv[1], "B64") == 0) {
     4cc:	000006ea 	andeq	r0, r0, sl, ror #13
     4d0:	7f8c9103 	svcvc	0x008c9103
            if (argc == 3) { 
     4d4:	6e656c12 	mcrvs	12, 3, r6, cr5, cr2, {0}
                printf("Missing Base64 encoded message\n");
     4d8:	6f151b00 	svcvs	0x00151b00
     4dc:	ab000000 	blge	4e4 <car_mesg+0xbc>
                printf("Decoding Base64\n");
     4e0:	a5000000 	strge	r0, [r0, #-0]
     4e4:	03000000 	movweq	r0, #0
                len = decode_base64((uint8_t *) argv[2], strlen(argv[2]), decoded);
     4e8:	0000049e 	muleq	r0, lr, r4
     4ec:	000002fc 	strdeq	r0, [r0], -ip
     4f0:	000004fb 	strdeq	r0, [r0], -fp
     4f4:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
                decoded[len] = '\0';
     4f8:	03000074 	movweq	r0, #116	@ 0x74
     4fc:	000004a8 	andeq	r0, r0, r8, lsr #9
     500:	000002d7 	ldrdeq	r0, [r0], -r7
                printf("Decoded as %s", decoded);
     504:	00000516 	andeq	r0, r0, r6, lsl r5
     508:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
     50c:	01010074 	tsteq	r1, r4, ror r0
            printf("Didn't know how to handle %s\n", argv[1]);
     510:	8c910352 	ldchi	3, cr0, [r1], {82}	@ 0x52
     514:	b203007f 	andlt	r0, r3, #127	@ 0x7f
     518:	bc000004 	stclt	0, cr0, [r0], {4}
     51c:	2b000002 	blcs	52c <car_mesg+0x104>
     520:	01000005 	tsteq	r0, r5
     524:	91035101 	tstls	r3, r1, lsl #2
     528:	0c007f8c 	stceq	15, cr7, [r0], {140}	@ 0x8c
     52c:	000004c8 	andeq	r0, r0, r8, asr #9
     530:	0000032d 	andeq	r0, r0, sp, lsr #6
     534:	05500101 	ldrbeq	r0, [r0, #-257]	@ 0xfffffeff
     538:	002ae403 	eoreq	lr, sl, r3, lsl #8
     53c:	51010100 	mrspl	r0, (UNDEF: 17)
     540:	7f8c9103 	svcvc	0x008c9103
     544:	e0110000 	ands	r0, r1, r0
     548:	2c000004 	stccs	0, cr0, [r0], {4}
     54c:	d6000000 	strle	r0, [r0], -r0
     550:	0f000005 	svceq	0x00000005
     554:	00000255 	andeq	r0, r0, r5, asr r2
void uputc(char c) {
     558:	06ea1928 	strbteq	r1, [sl], r8, lsr #18
  while ((UARTFR >> 5) & 1)
     55c:	91030000 	mrsls	r0, (UNDEF: 3)
     560:	6c127f8c 	ldcvs	15, cr7, [r2], {140}	@ 0x8c
  UART_DR = c;
     564:	29006e65 	stmdbcs	r0, {r0, r2, r5, r6, r9, sl, fp, sp, lr}
  if (c == '\n')
     568:	00006f15 	andeq	r6, r0, r5, lsl pc
}
     56c:	0000c600 	andeq	ip, r0, r0, lsl #12
    uputc('\r');
     570:	0000c400 	andeq	ip, r0, r0, lsl #8
}
     574:	04e60300 	strbteq	r0, [r6], #768	@ 0x300
     578:	032d0000 			@ <UNDEFINED> instruction: 0x032d0000
  if (!((UARTFR >> 4) & 1)) return UART_DR;
     57c:	058c0000 	streq	r0, [ip]
     580:	01010000 	mrseq	r0, (UNDEF: 1)
     584:	24030550 	strcs	r0, [r3], #-1360	@ 0xfffffab0
     588:	0000002b 	andeq	r0, r0, fp, lsr #32
  return -1;
     58c:	0004ee03 	andeq	lr, r4, r3, lsl #28
}
     590:	0002fc00 	andeq	pc, r2, r0, lsl #24
     594:	0005a000 	andeq	sl, r5, r0
  UARTCTL = 0;
     598:	50010100 	andpl	r0, r1, r0, lsl #2
     59c:	00007402 	andeq	r7, r0, r2, lsl #8
  UARTIBRD = 8;
     5a0:	0004f803 	andeq	pc, r4, r3, lsl #16
  UARTFBRD = 44;
     5a4:	0002d700 	andeq	sp, r2, r0, lsl #14
  UARTCC = 0;
     5a8:	0005bb00 	andeq	fp, r5, r0, lsl #22
  UARTLCRH = 0x60;
     5ac:	50010100 	andpl	r0, r1, r0, lsl #2
  UARTCTL = 0x301;
     5b0:	01007402 	tsteq	r0, r2, lsl #8
}
     5b4:	91035201 	tstls	r3, r1, lsl #4
     5b8:	0c007f8c 	stceq	15, cr7, [r0], {140}	@ 0x8c
void u2putc(char c) {
     5bc:	0000050c 	andeq	r0, r0, ip, lsl #10
  while ((UART2FR >> 5) & 1)
     5c0:	0000032d 	andeq	r0, r0, sp, lsr #6
     5c4:	05500101 	ldrbeq	r0, [r0, #-257]	@ 0xfffffeff
  UART2_DR = c;
     5c8:	002b3803 	eoreq	r3, fp, r3, lsl #16
  if (c == '\n')
     5cc:	51010100 	mrspl	r0, (UNDEF: 17)
}
     5d0:	7f8c9103 	svcvc	0x008c9103
    u2putc('\r');
     5d4:	36030000 	strcc	r0, [r3], -r0
}
     5d8:	2d000004 	stccs	0, cr0, [r0, #-16]
     5dc:	ed000003 	stc	0, cr0, [r0, #-12]
  if (!((UART2FR >> 4) & 1)) return UART2_DR;
     5e0:	01000005 	tsteq	r0, r5
     5e4:	03055001 	movweq	r5, #20481	@ 0x5001
     5e8:	00002a88 	andeq	r2, r0, r8, lsl #21
     5ec:	04440300 	strbeq	r0, [r4], #-768	@ 0xfffffd00
  return -1;
     5f0:	032d0000 			@ <UNDEFINED> instruction: 0x032d0000
}
     5f4:	06040000 	streq	r0, [r4], -r0
     5f8:	01010000 	mrseq	r0, (UNDEF: 1)
  UART2CTL = 0;
     5fc:	ac030550 	cfstr32ge	mvfx0, [r3], {80}	@ 0x50
     600:	0000002a 	andeq	r0, r0, sl, lsr #32
  UART2IBRD = 8;
     604:	00045003 	andeq	r5, r4, r3
  UART2FBRD = 44;
     608:	00032d00 	andeq	r2, r3, r0, lsl #26
  UART2CC = 0;
     60c:	00061b00 	andeq	r1, r6, r0, lsl #22
  UART2LCRH = 0x60;
     610:	50010100 	andpl	r0, r1, r0, lsl #2
  UART2CTL = 0x301;
     614:	33c80305 	biccc	r0, r8, #335544320	@ 0x14000000
}
     618:	03000000 	movweq	r0, #0
     61c:	00000462 	andeq	r0, r0, r2, ror #8
  RCGCUART |= 3;
     620:	00000312 	andeq	r0, r0, r2, lsl r3
     624:	00000632 	andeq	r0, r0, r2, lsr r6
     628:	05510101 	ldrbeq	r0, [r1, #-257]	@ 0xfffffeff
     62c:	002ab003 	eoreq	fp, sl, r3
  RCGCGPIO |= 3;
     630:	6a030000 	bvs	c0638 <__ROM_SIZE__+0x80638>
     634:	2d000004 	stccs	0, cr0, [r0, #-16]
     638:	49000003 	stmdbmi	r0, {r0, r1}
  GPIODEN = 0x03;
     63c:	01000006 	tsteq	r0, r6
     640:	03055001 	movweq	r5, #20481	@ 0x5001
  GPIOAFSEL = 0x03;
     644:	00002abc 			@ <UNDEFINED> instruction: 0x00002abc
  GPIOPCTL |= 0x00000011;
     648:	04740300 	ldrbteq	r0, [r4], #-768	@ 0xfffffd00
     64c:	03120000 	tsteq	r2, #0
     650:	06600000 	strbteq	r0, [r0], -r0
  GPIODEN2 = 0x03;
     654:	01010000 	mrseq	r0, (UNDEF: 1)
     658:	d0030551 	andle	r0, r3, r1, asr r5
  GPIOAFSEL2 = 0x03;
     65c:	0000002a 	andeq	r0, r0, sl, lsr #32
  GPIOPCTL2 |= 0x00000011;
     660:	00047e03 	andeq	r7, r4, r3, lsl #28
     664:	00034400 	andeq	r4, r3, r0, lsl #8
     668:	00067a00 	andeq	r7, r6, r0, lsl #20
}
     66c:	50010100 	andpl	r0, r1, r0, lsl #2
     670:	01007502 	tsteq	r0, r2, lsl #10
void platform_init() {
     674:	76025101 	strvc	r5, [r2], -r1, lsl #2
    pin_setup();
     678:	88030000 	stmdahi	r3, {}	@ <UNPREDICTABLE>
    uart_init();
     67c:	12000004 	andne	r0, r0, #4
    uart2_init();
     680:	91000003 	tstls	r0, r3
    set_read_char(ugetc);
     684:	01000006 	tsteq	r0, r6
    set_read_char2(u2getc);
     688:	03055101 	movweq	r5, #20737	@ 0x5101
     68c:	00002adc 	ldrdeq	r2, [r0], -ip
    set_write_char(uputc);
     690:	04940300 	ldreq	r0, [r4], #768	@ 0x300
    set_write_char2(u2putc);
     694:	032d0000 			@ <UNDEFINED> instruction: 0x032d0000
     698:	06a80000 	strteq	r0, [r8], r0
}
     69c:	01010000 	mrseq	r0, (UNDEF: 1)
     6a0:	00030550 	andeq	r0, r3, r0, asr r5
     6a4:	0000002b 	andeq	r0, r0, fp, lsr #32
     6a8:	0004d203 	andeq	sp, r4, r3, lsl #4
int aes_test(int argc, char** argv) {
     6ac:	00031200 	andeq	r1, r3, r0, lsl #4
    uint8_t text[17] = "0123456789abcdef";
     6b0:	0006bf00 	andeq	fp, r6, r0, lsl #30
     6b4:	51010100 	mrspl	r0, (UNDEF: 17)
     6b8:	2b200305 	blcs	8012d4 <__ROM_SIZE__+0x7c12d4>
     6bc:	03000000 	movweq	r0, #0
     6c0:	000004de 	ldrdeq	r0, [r0], -lr
    printf("Plaintext is %s\n", text);
     6c4:	0000032d 	andeq	r0, r0, sp, lsr #6
     6c8:	000006d6 	ldrdeq	r0, [r0], -r6
    AES_ECB_encrypt(&ctx, text);
     6cc:	05500101 	ldrbeq	r0, [r0, #-257]	@ 0xfffffeff
     6d0:	002b4803 	eoreq	r4, fp, r3, lsl #16
    len = encode_base64(text, 16, b64text);
     6d4:	160c0000 	strne	r0, [ip], -r0
     6d8:	2d000005 	stccs	0, cr0, [r0, #-20]	@ 0xffffffec
     6dc:	01000003 	tsteq	r0, r3
    b64text[len] = '\0';
     6e0:	03055001 	movweq	r5, #20481	@ 0x5001
     6e4:	00002b68 	andeq	r2, r0, r8, ror #22
     6e8:	421f0000 	andsmi	r0, pc, #0
    printf("Encrypted/encoded is %s\n", b64text);
     6ec:	09000000 	stmdbeq	r0, {}	@ <UNPREDICTABLE>
     6f0:	00000076 	andeq	r0, r0, r6, ror r0
    printf2("FOB_MESG AESB64 %s\n", b64text);
     6f4:	bd000063 	stclt	0, cr0, [r0, #-396]	@ 0xfffffe74
     6f8:	05000000 	streq	r0, [r0, #-0]
    printf("Test the mesg handler with CAR_MESG AESB64 %s\n", b64text);
     6fc:	bc040100 	stflts	f0, [r4], {-0}
     700:	02000001 	andeq	r0, r0, #1
    len = decode_base64(b64text, len, decoded);
     704:	00000046 	andeq	r0, r0, r6, asr #32
     708:	00029d1d 	andeq	r9, r2, sp, lsl sp
     70c:	00001400 	andeq	r1, r0, r0, lsl #8
    AES_ECB_decrypt(&ctx, decoded);
     710:	00055400 	andeq	r5, r5, r0, lsl #8
     714:	00000200 	andeq	r0, r0, r0, lsl #4
    decoded[len] = '\0';
     718:	00033600 	andeq	r3, r3, r0, lsl #12
     71c:	06010100 	streq	r0, [r1], -r0, lsl #2
     720:	0000012d 	andeq	r0, r0, sp, lsr #2
    printf("After encrypting->encoding->decoding->decrypting we recover %s\n", decoded);
     724:	e3050201 	movw	r0, #20993	@ 0x5201
     728:	01000001 	tsteq	r0, r1
}
     72c:	01c70504 	biceq	r0, r7, r4, lsl #10
     730:	08010000 	stmdaeq	r1, {}	@ <UNPREDICTABLE>
     734:	0001c205 	andeq	ip, r1, r5, lsl #4
     738:	08010100 	stmdaeq	r1, {r8}
     73c:	0000012b 	andeq	r0, r0, fp, lsr #2
     740:	39070201 	stmdbcc	r7, {r0, r9}
     744:	03000001 	movweq	r0, #1
     748:	0000026a 	andeq	r0, r0, sl, ror #4
     74c:	5c193402 	cfldrspl	mvf3, [r9], {2}
int pair1(int argc, char** argv) {
     750:	01000000 	mrseq	r0, (UNDEF: 0)
    printf("Sending a pair request.\n");
     754:	01760704 	cmneq	r6, r4, lsl #14
    printf2("FOB_MESG PAIR %d %d\n", fob_ID, pairing_PIN);
     758:	08010000 	stmdaeq	r1, {}	@ <UNPREDICTABLE>
     75c:	00017107 	andeq	r7, r1, r7, lsl #2
     760:	05040400 	streq	r0, [r4, #-1024]	@ 0xfffffc00
     764:	00746e69 	rsbseq	r6, r4, r9, ror #28
}
     768:	7b070401 	blvc	1c1774 <__ROM_SIZE__+0x181774>
     76c:	05000001 	streq	r0, [r0, #-1]
     770:	00000291 	muleq	r0, r1, r2
     774:	6a0c1401 	bvs	305780 <__ROM_SIZE__+0x2c5780>
     778:	06000000 	streq	r0, [r0], -r0
int pairchall(int argc, char** argv) {
     77c:	00000050 	andeq	r0, r0, r0, asr r0
    printf("Sending a pair request with challenge/response.\n");
     780:	00000094 	muleq	r0, r4, r0
    printf2("FOB_MESG PAIRCR %d %d\n", fob_ID, pairing_PIN);
     784:	00007107 	andeq	r7, r0, r7, lsl #2
     788:	0800ef00 	stmdaeq	r0, {r8, r9, sl, fp, sp, lr, pc}
     78c:	000002da 	ldrdeq	r0, [r0], -sl
     790:	840a1c01 	strhi	r1, [sl], #-3073	@ 0xfffff3ff
}
     794:	05000000 	streq	r0, [r0, #-0]
     798:	00000003 	andeq	r0, r0, r3
     79c:	02730900 	rsbseq	r0, r3, #0, 18
     7a0:	15010000 	strne	r0, [r1, #-0]
     7a4:	02810a0d 	addeq	r0, r1, #53248	@ 0xd000
int pairecdh(int argc, char** argv) {
     7a8:	17010000 	strne	r0, [r1, -r0]
    printf("Starting EC Diffie-Hellman key exchange.\n");
     7ac:	00055406 	andeq	r5, r5, r6, lsl #8
     7b0:	00000200 	andeq	r0, r0, r0, lsl #4
    decode_base64(ECDH_privkey_b64, 32, ECDH_privkey);
     7b4:	009c0100 	addseq	r0, ip, r0, lsl #2
     7b8:	00000091 	muleq	r0, r1, r0
     7bc:	04010005 	streq	r0, [r1], #-5
    ecdh_generate_keys(ECDH_pubkey, ECDH_privkey);
     7c0:	00000259 	andeq	r0, r0, r9, asr r2
     7c4:	00004601 	andeq	r4, r0, r1, lsl #12
    encode_base64(ECDH_pubkey, ECC_PUB_KEY_SIZE, pubkey_b64);
     7c8:	02f71d00 	rscseq	r1, r7, #0, 26
     7cc:	00140000 	andseq	r0, r4, r0
     7d0:	05580000 	ldrbeq	r0, [r8, #-0]
    pubkey_b64[64] = '\0';
     7d4:	00640000 	rsbeq	r0, r4, r0
    printf2("FOB_MESG PAIRECDH %d %d %s\n", fob_ID, pairing_PIN, pubkey_b64);
     7d8:	03fe0000 	mvnseq	r0, #0
     7dc:	e7020000 	str	r0, [r2, -r0]
     7e0:	01000002 	tsteq	r0, r2
     7e4:	05980622 	ldreq	r0, [r8, #1570]	@ 0x622
}
     7e8:	00240000 	eoreq	r0, r4, r0
     7ec:	9c010000 	stcls	0, cr0, [r1], {-0}
     7f0:	0002f103 	andeq	pc, r2, r3, lsl #2
     7f4:	051c0100 	ldreq	r0, [ip, #-256]	@ 0xffffff00
     7f8:	0000004e 	andeq	r0, r0, lr, asr #32
     7fc:	0000057c 	andeq	r0, r0, ip, ror r5
     800:	0000001c 	andeq	r0, r0, ip, lsl r0
     804:	04049c01 	streq	r9, [r4], #-3073	@ 0xfffff3ff
     808:	746e6905 	strbtvc	r6, [lr], #-2309	@ 0xfffff6fb
int encode64(int argc, char** argv) {
     80c:	03310500 	teqeq	r1, #0, 10
    if (argc > 1) {
     810:	13010000 	movwne	r0, #4096	@ 0x1000
     814:	00055806 	andeq	r5, r5, r6, lsl #16
        len = strlen(argv[1]);
     818:	00002400 	andeq	r2, r0, r0, lsl #8
     81c:	8d9c0100 	ldfhis	f0, [ip]
        if (len < MAXARRAYLEN) {
     820:	06000000 	streq	r0, [r0], -r0
            len = encode_base64((uint8_t *) argv[1], len, encoded);
     824:	13010063 	movwne	r0, #4195	@ 0x1063
     828:	00008d11 	andeq	r8, r0, r1, lsl sp
            printf("Encoded %s as %s with %d characters\n", argv[1], encoded, len);
     82c:	0000e200 	andeq	lr, r0, r0, lsl #4
     830:	0000da00 	andeq	sp, r0, r0, lsl #20
     834:	05740700 	ldrbeq	r0, [r4, #-1792]!	@ 0xfffff900
            printf("String exceeds max length of %d characters", MAXARRAYLEN);
     838:	00550000 	subseq	r0, r5, r0
     83c:	01080000 	mrseq	r0, (UNDEF: 8)
     840:	003d0150 	eorseq	r0, sp, r0, asr r1
        printf("Usage is 'encode64 string'\n");
     844:	08010900 	stmdaeq	r1, {r8, fp}
}
     848:	00000134 	andeq	r0, r0, r4, lsr r1
     84c:	00009100 	andeq	r9, r0, r0, lsl #2
     850:	01000500 	tsteq	r0, r0, lsl #10
     854:	0002f804 	andeq	pc, r2, r4, lsl #16
     858:	00460100 	subeq	r0, r6, r0, lsl #2
int decode64(int argc, char** argv) {
     85c:	3e1d0000 	cdpcc	0, 1, cr0, cr13, cr0, {0}
    if (argc > 1) {
     860:	14000003 	strne	r0, [r0], #-3
     864:	bc000000 	stclt	0, cr0, [r0], {-0}
        int len = strlen(argv[1]);
     868:	64000005 	strvs	r0, [r0], #-5
     86c:	ff000000 			@ <UNDEFINED> instruction: 0xff000000
        if (len < MAXBASE64LEN) {
     870:	02000004 	andeq	r0, r0, #4
                len = decode_base64((uint8_t *) argv[1], len, plaintext);
     874:	00000380 	andeq	r0, r0, r0, lsl #7
     878:	fc062201 	stc2	2, cr2, [r6], {1}
                plaintext[len] = '\0';
     87c:	24000005 	strcs	r0, [r0], #-5
     880:	01000000 	mrseq	r0, (UNDEF: 0)
     884:	0379039c 	cmneq	r9, #156, 6	@ 0x70000002
                printf("Decoded %s as: %s\n", argv[1], plaintext);
     888:	1c010000 	stcne	0, cr0, [r1], {-0}
     88c:	00004e05 	andeq	r4, r0, r5, lsl #28
     890:	0005e000 	andeq	lr, r5, r0
            printf("String exceeds max base64 string length of %d characters", MAXBASE64LEN);
     894:	00001c00 	andeq	r1, r0, r0, lsl #24
     898:	049c0100 	ldreq	r0, [ip], #256	@ 0x100
     89c:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
        printf("Usage is 'decode64 string'\n");
     8a0:	37050074 	smlsdxcc	r5, r4, r0, r0
}
     8a4:	01000003 	tsteq	r0, r3
     8a8:	05bc0613 	ldreq	r0, [ip, #1555]!	@ 0x613
     8ac:	00240000 	eoreq	r0, r4, r0
     8b0:	9c010000 	stcls	0, cr0, [r1], {-0}
     8b4:	0000008d 	andeq	r0, r0, sp, lsl #1
int ecdh_test(int argc, char** argv) {
     8b8:	01006306 	tsteq	r0, r6, lsl #6
    uint8_t b64privkey2[32] = "wP/uwP/uwP/uwP/uwP/uwP/uwP/uwP/u";
     8bc:	008d1213 	addeq	r1, sp, r3, lsl r2
     8c0:	01110000 	tsteq	r1, r0
     8c4:	01090000 	mrseq	r0, (UNDEF: 9)
     8c8:	d8070000 	stmdale	r7, {}	@ <UNPREDICTABLE>
     8cc:	55000005 	strpl	r0, [r0, #-5]
    printf("Testing the ecdh key exchange\n");
     8d0:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
     8d4:	3d015001 	stccc	0, cr5, [r1, #-4]
    decode_base64(ECDH_privkey_b64, 32, ECDH_privkey);
     8d8:	01090000 	mrseq	r0, (UNDEF: 9)
     8dc:	00013408 	andeq	r3, r1, r8, lsl #8
     8e0:	017f0000 	cmneq	pc, r0
    decode_base64(b64privkey2, 32, privkey2);
     8e4:	00050000 	andeq	r0, r5, r0
     8e8:	03970401 	orrseq	r0, r7, #16777216	@ 0x1000000
    ecdh_generate_keys(ECDH_pubkey, ECDH_privkey);
     8ec:	46080000 	strmi	r0, [r8], -r0
     8f0:	1d000000 	stcne	0, cr0, [r0, #-0]
     8f4:	000003d1 	ldrdeq	r0, [r0], -r1
    ecdh_generate_keys(pubkey2, privkey2);
     8f8:	00000014 	andeq	r0, r0, r4, lsl r0
     8fc:	00000620 	andeq	r0, r0, r0, lsr #12
    ecdh_shared_secret(ECDH_privkey, pubkey2, ECDH_shared);
     900:	0000008c 	andeq	r0, r0, ip, lsl #1
     904:	00000601 	andeq	r0, r0, r1, lsl #12
     908:	2d060101 	stfcss	f0, [r6, #-4]
    ecdh_shared_secret(privkey2, ECDH_pubkey, sharedsecret2);
     90c:	01000001 	tsteq	r0, r1
     910:	01e30502 	mvneq	r0, r2, lsl #10
    sha256_init(&shactx);
     914:	04010000 	streq	r0, [r1], #-0
     918:	0001c705 	andeq	ip, r1, r5, lsl #14
	sha256_update(&shactx, ECDH_shared, ECC_PUB_KEY_SIZE);
     91c:	05080100 	streq	r0, [r8, #-256]	@ 0xffffff00
     920:	000001c2 	andeq	r0, r0, r2, asr #3
	sha256_final(&shactx, ECDH_AESkey);
     924:	2b080101 	blcs	200d30 <__ROM_SIZE__+0x1c0d30>
     928:	01000001 	tsteq	r0, r1
     92c:	01390702 	teqeq	r9, r2, lsl #14
    len = encode_base64(ECDH_AESkey, AES_KEYLEN, b64test);
     930:	04010000 	streq	r0, [r1], #-0
     934:	00017607 	andeq	r7, r1, r7, lsl #12
    b64test[len] = '\0';
     938:	07080100 	streq	r0, [r8, -r0, lsl #2]
     93c:	00000171 	andeq	r0, r0, r1, ror r1
     940:	69050409 	stmdbvs	r5, {r0, r3, sl}
     944:	0100746e 	tsteq	r0, lr, ror #8
    printf("First shared key is %s\n", b64test);
     948:	017b0704 	cmneq	fp, r4, lsl #14
     94c:	08010000 	stmdaeq	r1, {}	@ <UNPREDICTABLE>
    sha256_init(&shactx);
     950:	00022504 	andeq	r2, r2, r4, lsl #10
    sha256_update(&shactx, sharedsecret2, ECC_PUB_KEY_SIZE);
     954:	08010100 	stmdaeq	r1, {r8}
     958:	00000134 	andeq	r0, r0, r4, lsr r1
     95c:	00033704 	andeq	r3, r3, r4, lsl #14
	sha256_final(&shactx, keytest);
     960:	8b220200 	blhi	881168 <__ROM_SIZE__+0x841168>
     964:	02000000 	andeq	r0, r0, #0
    len = encode_base64(keytest, AES_KEYLEN, b64test);
     968:	00000073 	andeq	r0, r0, r3, ror r0
     96c:	03b30400 			@ <UNDEFINED> instruction: 0x03b30400
    b64test[len] = '\0';
     970:	84030000 	strhi	r0, [r3], #-0
     974:	0000009c 	muleq	r0, ip, r0
     978:	00009c02 	andeq	r9, r0, r2, lsl #24
    printf("Should be same as %s\n", b64test);
     97c:	a1050000 	mrsge	r0, (UNDEF: 5)
     980:	0a000000 	beq	988 <ecdh_test+0xd0>
    printf("Switching fob AES key to new value. Try AES tests now.\n");
     984:	000000ac 	andeq	r0, r0, ip, lsr #1
     988:	00007302 	andeq	r7, r0, r2, lsl #6
    AES_init_ctx(&ctx, ECDH_AESkey);
     98c:	31040000 	mrscc	r0, (UNDEF: 4)
     990:	04000003 	streq	r0, [r0], #-3
}
     994:	0000bd22 	andeq	fp, r0, r2, lsr #26
     998:	00730200 	rsbseq	r0, r3, r0, lsl #4
     99c:	04000000 	streq	r0, [r0], #-0
     9a0:	000003a4 	andeq	r0, r0, r4, lsr #7
     9a4:	00ce8303 	sbceq	r8, lr, r3, lsl #6
     9a8:	9c020000 	stcls	0, cr0, [r2], {-0}
     9ac:	00000000 	andeq	r0, r0, r0
     9b0:	00037906 	andeq	r7, r3, r6, lsl #18
     9b4:	005e0200 	subseq	r0, lr, r0, lsl #4
     9b8:	95040000 	strls	r0, [r4, #-0]
     9bc:	03000003 	movweq	r0, #3
     9c0:	0000e977 	andeq	lr, r0, r7, ror r9
int send_ping(int argc, char** argv) {
     9c4:	00e90200 	rsceq	r0, r9, r0, lsl #4
    printf("Pinging the car.\n");
     9c8:	05000000 	streq	r0, [r0, #-0]
    printf2("FOB_MESG PING\n");
     9cc:	000000ee 	andeq	r0, r0, lr, ror #1
     9d0:	00005e0b 	andeq	r5, r0, fp, lsl #28
}
     9d4:	02f10600 	rscseq	r0, r1, #0, 12
     9d8:	5e040000 	cdppl	0, 0, cr0, cr4, cr0, {0}
     9dc:	04000000 	streq	r0, [r0], #-0
int sha256_test(int argc, char** argv) {
     9e0:	000003c3 	andeq	r0, r0, r3, asr #7
    printf("Starting sha256 test\n");
     9e4:	010e7603 	tsteq	lr, r3, lsl #12
     9e8:	e9020000 	stmdb	r2, {}	@ <UNPREDICTABLE>
    BYTE text1[] = {"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"};
     9ec:	00000000 	andeq	r0, r0, r0
     9f0:	00038007 	andeq	r8, r3, r7
     9f4:	e7070200 	str	r0, [r7, -r0, lsl #4]
     9f8:	04000002 	streq	r0, [r0], #-2
     9fc:	00040a0c 	andeq	r0, r4, ip, lsl #20
     a00:	06380100 	ldrteq	r0, [r8], -r0, lsl #2
     a04:	00000674 	andeq	r0, r0, r4, ror r6
     a08:	00000038 	andeq	r0, r0, r8, lsr r0
     a0c:	01709c01 	cmneq	r0, r1, lsl #24
    BYTE hash1[SHA256_BLOCK_SIZE] = {0x24,0x8d,0x6a,0x61,0xd2,0x06,0x38,0xb8,0xe5,0xc0,0x26,0x93,0x0c,0x3e,0x60,0x39,
     a10:	7a030000 	bvc	c0a18 <__ROM_SIZE__+0x80a18>
     a14:	70000006 	andvc	r0, r0, r6
     a18:	03000001 	movweq	r0, #1
     a1c:	0000067e 	andeq	r0, r0, lr, ror r6
    sha256_init(&shactx);
     a20:	00000114 	andeq	r0, r0, r4, lsl r1
	sha256_update(&shactx, text1, strlen((char *)text1));
     a24:	00068203 	andeq	r8, r6, r3, lsl #4
     a28:	00010e00 	andeq	r0, r1, r0, lsl #28
     a2c:	06880300 	streq	r0, [r8], r0, lsl #6
     a30:	00fd0000 	rscseq	r0, sp, r0
	sha256_final(&shactx, buf);
     a34:	8e030000 	cdphi	0, 0, cr0, cr3, cr0, {0}
     a38:	d8000006 	stmdale	r0, {r1, r2}
    len = encode_base64(hash1, SHA256_BLOCK_SIZE, b64_hash1);
     a3c:	03000000 	movweq	r0, #0
     a40:	00000694 	muleq	r0, r4, r6
     a44:	000000bd 	strheq	r0, [r0], -sp
    b64_hash1[len] = '\0';
     a48:	00069a03 	andeq	r9, r6, r3, lsl #20
    len = encode_base64(buf, SHA256_BLOCK_SIZE, b64_buf);
     a4c:	00008b00 	andeq	r8, r0, r0, lsl #22
     a50:	8b0d0000 	blhi	340a58 <__ROM_SIZE__+0x300a58>
     a54:	01000003 	tsteq	r0, r3
    b64_buf[len] = '\0';
     a58:	06200622 	strteq	r0, [r0], -r2, lsr #12
    printf("Base64 of SHA-256 test is %s\n", b64_buf);
     a5c:	00540000 	subseq	r0, r4, r0
     a60:	9c010000 	stcls	0, cr0, [r1], {-0}
    printf("Should be %s\n", b64_hash1);
     a64:	0003a500 	andeq	sl, r3, r0, lsl #10
     a68:	01000500 	tsteq	r0, r0, lsl #10
}
     a6c:	00046104 	andeq	r6, r4, r4, lsl #2
     a70:	00461000 	subeq	r1, r6, r0
     a74:	281d0000 	ldmdacs	sp, {}	@ <UNPREDICTABLE>
     a78:	14000004 	strne	r0, [r0], #-4
     a7c:	ac000000 	stcge	0, cr0, [r0], {-0}
     a80:	a4000006 	strge	r0, [r0], #-6
void __attribute__((optimize("O0"), weak)) initial_setup(void) {
     a84:	39000000 	stmdbcc	r0, {}	@ <UNPREDICTABLE>
     a88:	03000007 	movweq	r0, #7
  char *src = &_etext, *dst = &_data;
     a8c:	012d0601 			@ <UNDEFINED> instruction: 0x012d0601
     a90:	02030000 	andeq	r0, r3, #0
  if (dst != src)
     a94:	0001e305 	andeq	lr, r1, r5, lsl #6
     a98:	05040300 	streq	r0, [r4, #-768]	@ 0xfffffd00
    while (dst < &_edata) *(dst++) = *(src++);
     a9c:	000001c7 	andeq	r0, r0, r7, asr #3
     aa0:	c2050803 	andgt	r0, r5, #196608	@ 0x30000
     aa4:	0b000001 	bleq	ab0 <initial_setup+0x2c>
     aa8:	00000188 	andeq	r0, r0, r8, lsl #3
     aac:	4e182e04 	cdpmi	14, 1, cr2, cr8, cr4, {0}
     ab0:	03000000 	movweq	r0, #0
  for (dst = &_bss; dst < &_ebss; dst++) *dst = 0;
     ab4:	012b0801 			@ <UNDEFINED> instruction: 0x012b0801
     ab8:	02030000 	andeq	r0, r3, #0
     abc:	00013907 	andeq	r3, r1, r7, lsl #18
     ac0:	07040300 	streq	r0, [r4, -r0, lsl #6]
     ac4:	00000176 	andeq	r0, r0, r6, ror r1
     ac8:	71070803 	tstvc	r7, r3, lsl #16
     acc:	11000001 	tstne	r0, r1
  platform_init();
     ad0:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
}
     ad4:	04030074 	streq	r0, [r3], #-116	@ 0xffffff8c
     ad8:	00017b07 	andeq	r7, r1, r7, lsl #22
     adc:	04080300 	streq	r0, [r8], #-768	@ 0xfffffd00
     ae0:	00000225 	andeq	r0, r0, r5, lsr #4
     ae4:	0001a012 	andeq	sl, r1, r2, lsl r0
     ae8:	02010000 	andeq	r0, r1, #0
     aec:	00a7082c 	adceq	r0, r7, ip, lsr #16
static void delete(void) {
     af0:	96060000 	strls	r0, [r6], -r0
  __write_char__(BACK_SPACE);
     af4:	0200000c 	andeq	r0, r0, #12
     af8:	00ac0b2e 	adceq	r0, ip, lr, lsr #22
  __write_char__(SPACE);
     afc:	13000000 	movwne	r0, #0
  __write_char__(BACK_SPACE);
     b00:	02007649 	andeq	r7, r0, #76546048	@ 0x4900000
     b04:	00bc0b30 	adcseq	r0, ip, r0, lsr fp
}
     b08:	00f00000 	rscseq	r0, r0, r0
static void clear_prompt(int char_count) {
     b0c:	00007f0c 	andeq	r7, r0, ip, lsl #30
  while (char_count) {
     b10:	00420900 	subeq	r0, r2, r0, lsl #18
    delete ();
     b14:	00bc0000 	adcseq	r0, ip, r0
  while (char_count) {
     b18:	71070000 	mrsvc	r0, (UNDEF: 7)
}
     b1c:	ef000000 	svc	0x00000000
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
     b20:	00420900 	subeq	r0, r2, r0, lsl #18
    auto_load[i].command(0, NULL);
     b24:	00cc0000 	sbceq	r0, ip, r0
     b28:	71070000 	mrsvc	r0, (UNDEF: 7)
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
     b2c:	0f000000 	svceq	0x00000000
     b30:	74631400 	strbtvc	r1, [r3], #-1024	@ 0xfffffc00
     b34:	25030078 	strcs	r0, [r3, #-120]	@ 0xffffff88
     b38:	00007f17 	andeq	r7, r0, r7, lsl pc
     b3c:	6d631500 	cfstr64vs	mvdx1, [r3, #-0]
}
     b40:	3b030064 	blcc	c0cd8 <__ROM_SIZE__+0x80cd8>
static int show_history(int argc, char **argv) {
     b44:	0000e40f 	andeq	lr, r0, pc, lsl #8
  uint32_t end_index = total_num_commands-1;
     b48:	00e90500 	rsceq	r0, r9, r0, lsl #10
  if (total_num_commands > NUM_HISTORY_ENTRIES) {
     b4c:	6a160000 	bvs	580b54 <__ROM_SIZE__+0x540b54>
     b50:	fd000000 	stc2	0, cr0, [r0, #-0]
    beg_index = total_num_commands - NUM_HISTORY_ENTRIES;
     b54:	02000000 	andeq	r0, r0, #0
     b58:	0000006a 	andeq	r0, r0, sl, rrx
  uint32_t beg_index = 0;
     b5c:	0000fd02 	andeq	pc, r0, r2, lsl #26
    printf("%s\n", cmd_history[index % NUM_HISTORY_ENTRIES]);
     b60:	02050000 	andeq	r0, r5, #0
     b64:	05000001 	streq	r0, [r0, #-1]
     b68:	00000107 	andeq	r0, r0, r7, lsl #2
     b6c:	34080103 	strcc	r0, [r8], #-259	@ 0xfffffefd
  for (uint32_t index = beg_index; index <= end_index; ++index) {
     b70:	0c000001 	stceq	0, cr0, [r0], {1}
}
     b74:	00000107 	andeq	r0, r0, r7, lsl #2
     b78:	44030c17 	strmi	r0, [r3], #-3095	@ 0xfffff3e9
     b7c:	00014409 	andeq	r4, r1, r9, lsl #8
     b80:	025d0600 	subseq	r0, sp, #0, 12
int cmd_exec_status(int argc, char **argv) {
     b84:	45030000 	strmi	r0, [r3, #-0]
  printf("%d\n", __cmd_exec_status);
     b88:	0001440f 	andeq	r4, r1, pc, lsl #8
     b8c:	00060000 	andeq	r0, r6, r0
     b90:	03000000 	movweq	r0, #0
}
     b94:	01440f46 	cmpeq	r4, r6, asr #30
     b98:	06040000 	streq	r0, [r4], -r0
     b9c:	000000da 	ldrdeq	r0, [r0], -sl
static int build_info(int argc, char **argv) {
     ba0:	d8074703 	stmdale	r7, {r0, r1, r8, r9, sl, lr}
  printf("Build: [" SHELL_VERSION ":" USER_REPO_VERSION "] - [" BUILD_USER
     ba4:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
}
     ba8:	010e0500 	tsteq	lr, r0, lsl #10
     bac:	bc0b0000 	stclt	0, cr0, [fp], {-0}
static void execute(int argc, char **argv) {
     bb0:	03000001 	movweq	r0, #1
     bb4:	01130348 	tsteq	r3, r8, asr #6
  for (int i = 0; table[i].command_name != NULL; i++) {
     bb8:	76180000 	ldrvc	r0, [r8], -r0
     bbc:	01000004 	tsteq	r0, r4
     bc0:	01490122 	cmpeq	r9, r2, lsr #2
     bc4:	03050000 	movweq	r0, #20480	@ 0x5000
     bc8:	00002974 	andeq	r2, r0, r4, ror r9
    if (strcmp(argv[0], table[i].command_name) == 0) {
     bcc:	0000f50d 	andeq	pc, r0, sp, lsl #10
     bd0:	017c3f00 	cmneq	ip, r0, lsl #30
      __cmd_exec_status = table[i].command(argc, &argv[0]);
     bd4:	7c020000 	stcvc	0, cr0, [r2], {-0}
     bd8:	02000001 	andeq	r0, r0, #1
     bdc:	00000181 	andeq	r0, r0, r1, lsl #3
     be0:	00a70500 	adceq	r0, r7, r0, lsl #10
     be4:	42050000 	andmi	r0, r5, #0
    printf("\"%s\": command not found. Use \"help\" to list all command.\n",
     be8:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
     bec:	000000e7 	andeq	r0, r0, r7, ror #1
    __cmd_exec_status = -1;
     bf0:	710e4a05 	tstvc	lr, r5, lsl #20
     bf4:	a6000000 	strge	r0, [r0], -r0
     bf8:	02000001 	andeq	r0, r0, #1
}
     bfc:	000001a6 	andeq	r0, r0, r6, lsr #3
     c00:	00007102 	andeq	r7, r0, r2, lsl #2
     c04:	01a60200 			@ <UNDEFINED> instruction: 0x01a60200
     c08:	05000000 	streq	r0, [r0, #-0]
int help(int argc, char **argv) {
     c0c:	0000004e 	andeq	r0, r0, lr, asr #32
  if (argc > 1 && (strcmp(argv[1], "-l")==0)) {
     c10:	00045808 	andeq	r5, r4, r8, lsl #16
     c14:	052d0600 	streq	r0, [sp, #-1536]!	@ 0xfffffa00
     c18:	0000006a 	andeq	r0, r0, sl, rrx
     c1c:	000001c2 	andeq	r0, r0, r2, asr #3
    printf("use: help -l for list only.\n\n");
     c20:	00014402 	andeq	r4, r1, r2, lsl #8
  bool verbose = true;
     c24:	08000e00 	stmdaeq	r0, {r9, sl, fp}
    verbose = false;
     c28:	00000468 	andeq	r0, r0, r8, ror #8
    printf("\n");
     c2c:	710e3d05 	tstvc	lr, r5, lsl #26
    i++;
     c30:	e2000000 	and	r0, r0, #0
  while (table[i].command_name != NULL) {
     c34:	02000001 	andeq	r0, r0, #1
     c38:	000001a6 	andeq	r0, r0, r6, lsr #3
     c3c:	00007102 	andeq	r7, r0, r2, lsl #2
    printf(table[i].command_name);
     c40:	01a60200 			@ <UNDEFINED> instruction: 0x01a60200
    if (verbose) {
     c44:	0d000000 	stceq	0, cr0, [r0, #-0]
      printf("\n\t");
     c48:	00000418 	andeq	r0, r0, r8, lsl r4
      printf(table[i].command_help);
     c4c:	0001f73e 	andeq	pc, r1, lr, lsr r7	@ <UNPREDICTABLE>
     c50:	017c0200 	cmneq	ip, r0, lsl #4
     c54:	81020000 	mrshi	r0, (UNDEF: 2)
    verbose = false;
     c58:	00000001 	andeq	r0, r0, r1
}
     c5c:	0001dc08 	andeq	sp, r1, r8, lsl #24
     c60:	052c0600 	streq	r0, [ip, #-1536]!	@ 0xfffffa00
     c64:	0000006a 	andeq	r0, r0, sl, rrx
     c68:	0000020e 	andeq	r0, r0, lr, lsl #4
     c6c:	00014402 	andeq	r4, r1, r2, lsl #8
     c70:	19000e00 	stmdbne	r0, {r9, sl, fp}
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
     c74:	0000047a 	andeq	r0, r0, sl, ror r4
static void add_command_to_history(const char *cmd_str) {
     c78:	6a050701 	bvs	142884 <__ROM_SIZE__+0x102884>
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
     c7c:	ac000000 	stcge	0, cr0, [r0], {-0}
     c80:	a4000006 	strge	r0, [r0], #-6
  int index = total_num_commands % NUM_HISTORY_ENTRIES;
     c84:	01000000 	mrseq	r0, (UNDEF: 0)
     c88:	00038c9c 	muleq	r3, ip, ip
     c8c:	01ed0f00 	mvneq	r0, r0, lsl #30
     c90:	6a120000 	bvs	480c98 <__ROM_SIZE__+0x440c98>
  memcpy(&cmd_history[index], cmd_str, LINE_BUFF_SIZE);
     c94:	3c000000 	stccc	0, cr0, [r0], {-0}
     c98:	38000001 	stmdacc	r0, {r0}
     c9c:	0f000001 	svceq	0x00000001
     ca0:	0000015a 	andeq	r0, r0, sl, asr r1
  total_num_commands++;
     ca4:	0000fd1f 	andeq	pc, r0, pc, lsl sp	@ <UNPREDICTABLE>
  curr_command_ptr = total_num_commands;
     ca8:	00014f00 	andeq	r4, r1, r0, lsl #30
     cac:	00014b00 	andeq	r4, r1, r0, lsl #22
     cb0:	04630a00 	strbteq	r0, [r3], #-2560	@ 0xfffff600
     cb4:	8c090000 	stchi	0, cr0, [r9], {-0}
     cb8:	02000003 	andeq	r0, r0, #3
static int parse_line(char **argv, char *line_buff, int argument_size) {
     cbc:	6c1a5c91 	ldcvs	12, cr5, [sl], {145}	@ 0x91
     cc0:	01006e65 	tsteq	r0, r5, ror #28
  int length = strlen(line_buff);
     cc4:	0071120b 	rsbseq	r1, r1, fp, lsl #4
     cc8:	01680000 	cmneq	r8, r0
  int argc = 0;
     ccc:	015e0000 	cmpeq	lr, r0
         pos++)
     cd0:	600a0000 	andvs	r0, sl, r0
    for (; line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
     cd4:	11000004 	tstne	r0, r4
     cd8:	0000039c 	muleq	r0, ip, r3
     cdc:	0a409102 	beq	10250ec <__ROM_SIZE__+0xfe50ec>
     ce0:	00000255 	andeq	r0, r0, r5, asr r2
    if (line_buff[pos] == '\t' || line_buff[pos] == SPACE)
     ce4:	00038c18 	andeq	r8, r3, r8, lsl ip
     ce8:	ac910300 	ldcge	3, cr0, [r1], {0}
      line_buff[pos] = END_OF_LINE;
     cec:	06ca047f 	uxtab16eq	r0, sl, pc, ror #8	@ <UNPREDICTABLE>
  while (pos <= length) {
     cf0:	01f70000 	mvnseq	r0, r0
    if (line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
     cf4:	02a50000 	adceq	r0, r5, #0
     cf8:	01010000 	mrseq	r0, (UNDEF: 1)
     cfc:	b4030550 	strlt	r0, [r3], #-1360	@ 0xfffffab0
     d00:	0100002b 	tsteq	r0, fp, lsr #32
      argv[argc++] = &line_buff[pos];
     d04:	91025101 	tstls	r2, r1, lsl #2
     d08:	d404005c 	strle	r0, [r4], #-92	@ 0xffffffa4
}
     d0c:	e2000006 	and	r0, r0, #6
static int prefix_match(char *sub, int len, const char *str) {
     d10:	bf000001 	svclt	0x00000001
     d14:	01000002 	tsteq	r0, r2
  if (sub == NULL || str == NULL || len <= 0 || len > strlen(str)) {
     d18:	76025001 	strvc	r5, [r2], -r1
     d1c:	51010100 	mrspl	r0, (UNDEF: 17)
     d20:	005c9102 	subseq	r9, ip, r2, lsl #2
     d24:	0006de04 	andeq	sp, r6, r4, lsl #28
  for (int i = 0; i<len; ++i) {
     d28:	0001c200 	andeq	ip, r1, r0, lsl #4
     d2c:	0002de00 	andeq	sp, r2, r0, lsl #28
    if (sub[i] != str[i]) {
     d30:	50010100 	andpl	r0, r1, r0, lsl #2
     d34:	015c9102 	cmpeq	ip, r2, lsl #2
  for (int i = 0; i<len; ++i) {
     d38:	40015101 	andmi	r5, r1, r1, lsl #2
}
     d3c:	02520101 	subseq	r0, r2, #1073741824	@ 0x40000000
  return TRUE;
     d40:	04004091 	streq	r4, [r0], #-145	@ 0xffffff6f
      return FALSE;
     d44:	000006f4 	strdeq	r0, [r0], -r4
}
     d48:	000001f7 	strdeq	r0, [r0], -r7
static void handle_up_arrow(char *cmd_buff, int *char_count) {
     d4c:	000002fb 	strdeq	r0, [r0], -fp
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
     d50:	05500101 	ldrbeq	r0, [r0, #-257]	@ 0xfffffeff
     d54:	002bc803 	eoreq	ip, fp, r3, lsl #16
     d58:	51010100 	mrspl	r0, (UNDEF: 17)
     d5c:	00409102 	subeq	r9, r0, r2, lsl #2
      curr_command_ptr == 0) {
     d60:	0006fc04 	andeq	pc, r6, r4, lsl #24
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
     d64:	0001ab00 	andeq	sl, r1, r0, lsl #22
    printf("%s", cmd_buff);
     d68:	00031800 	andeq	r1, r3, r0, lsl #16
     d6c:	50010100 	andpl	r0, r1, r0, lsl #2
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
     d70:	2be40305 	blcs	ff90198c <_STACK_TOP_+0xdf8f9990>
     d74:	01010000 	mrseq	r0, (UNDEF: 1)
  curr_command_ptr--;
     d78:	40910251 	addsmi	r0, r1, r1, asr r2
     d7c:	07040400 	streq	r0, [r4, -r0, lsl #8]
     d80:	01f70000 	mvnseq	r0, r0
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
     d84:	03350000 	teqeq	r5, #0
     d88:	01010000 	mrseq	r0, (UNDEF: 1)
     d8c:	f8030550 			@ <UNDEFINED> instruction: 0xf8030550
     d90:	0100002b 	tsteq	r0, fp, lsr #32
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
     d94:	91025101 	tstls	r2, r1, lsl #2
     d98:	0e040040 	cdpeq	0, 0, cr0, cr4, cr0, {2}
     d9c:	86000007 	strhi	r0, [r0], -r7
  *char_count = strlen(cmd_buff);
     da0:	56000001 	strpl	r0, [r0], -r1
     da4:	01000003 	tsteq	r0, r3
  printf("%s", cmd_buff);
     da8:	91025001 	tstls	r2, r1
     dac:	51010140 	tstpl	r1, r0, asr #2
     db0:	01007402 	tsteq	r0, r2, lsl #8
     db4:	91035201 	tstls	r3, r1, lsl #4
     db8:	04007fac 	streq	r7, [r0], #-4012	@ 0xfffff054
static void handle_down_arrow(char *cmd_buff, int *char_count) {
     dbc:	00000718 	andeq	r0, r0, r8, lsl r7
     dc0:	00000167 	andeq	r0, r0, r7, ror #2
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
     dc4:	00000371 	andeq	r0, r0, r1, ror r3
     dc8:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
  *char_count = 0;
     dcc:	01010076 	tsteq	r1, r6, ror r0
  if (curr_command_ptr == total_num_commands) return;
     dd0:	ac910351 	ldcge	3, cr0, [r1], {81}	@ 0x51
     dd4:	2c1b007f 	ldccs	0, cr0, [fp], {127}	@ 0x7f
     dd8:	f7000007 			@ <UNDEFINED> instruction: 0xf7000007
  curr_command_ptr++;
     ddc:	01000001 	tsteq	r0, r1
     de0:	03055001 	movweq	r5, #20481	@ 0x5001
     de4:	00002c28 	andeq	r2, r0, r8, lsr #24
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
     de8:	03510101 	cmpeq	r1, #1073741824	@ 0x40000000
     dec:	007fac91 			@ <UNDEFINED> instruction: 0x007fac91
     df0:	00420900 	subeq	r0, r2, r0, lsl #18
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
     df4:	039c0000 	orrseq	r0, ip, #0
     df8:	71070000 	mrsvc	r0, (UNDEF: 7)
     dfc:	10000000 	andne	r0, r0, r0
     e00:	00421c00 	subeq	r1, r2, r0, lsl #24
  *char_count = strlen(cmd_buff);
     e04:	71070000 	mrsvc	r0, (UNDEF: 7)
     e08:	18000000 	stmdane	r0, {}	@ <UNPREDICTABLE>
  printf("%s", cmd_buff);
     e0c:	03b00000 	movseq	r0, #0
     e10:	00050000 	andeq	r0, r5, r0
}
     e14:	05f70401 	ldrbeq	r0, [r7, #1025]!	@ 0x401
     e18:	46100000 	ldrmi	r0, [r0], -r0
void set_read_char(int (*func)(void)) { __read_char__ = func; }
     e1c:	1d000000 	stcne	0, cr0, [r0, #-0]
     e20:	000004b8 			@ <UNDEFINED> instruction: 0x000004b8
     e24:	00000014 	andeq	r0, r0, r4, lsl r0
void set_read_char2(int (*func)(void)) { __read_char2__ = func; }
     e28:	00000750 	andeq	r0, r0, r0, asr r7
     e2c:	000000bc 	strheq	r0, [r0], -ip
     e30:	00000906 	andeq	r0, r0, r6, lsl #18
void set_write_char(void (*func)(char)) { __write_char__ = func; }
     e34:	2d060103 	stfcss	f0, [r6, #-12]
     e38:	03000001 	movweq	r0, #1
     e3c:	01e30502 	mvneq	r0, r2, lsl #10
void set_write_char2(void (*func)(char)) { __write_char2__ = func; }
     e40:	04030000 	streq	r0, [r3], #-0
     e44:	0001c705 	andeq	ip, r1, r5, lsl #14
     e48:	05080300 	streq	r0, [r8, #-768]	@ 0xfffffd00
}
     e4c:	000001c2 	andeq	r0, r0, r2, asr #3
}
     e50:	0001880c 	andeq	r8, r1, ip, lsl #16
  if (cmd_buff == NULL || char_count <= 0) {
     e54:	182e0300 	stmdane	lr!, {r8, r9}
static void handle_tab(char *cmd_buff, int *char_count) {
     e58:	0000004e 	andeq	r0, r0, lr, asr #32
     e5c:	2b080103 	blcs	201270 <__ROM_SIZE__+0x1c1270>
  int last_match = -1;
     e60:	03000001 	movweq	r0, #1
  int match_count = 0;
     e64:	01390702 	teqeq	r9, r2, lsl #14
  int i = 0;
     e68:	04030000 	streq	r0, [r3], #-0
    i++;
     e6c:	00017607 	andeq	r7, r1, r7, lsl #12
  while (table[i].command_name != NULL) { //loop over all commands
     e70:	07080300 	streq	r0, [r8, -r0, lsl #6]
     e74:	00000171 	andeq	r0, r0, r1, ror r1
     e78:	69050411 	stmdbvs	r5, {r0, r4, sl}
    if (prefix_match(cmd_buff, *char_count, table[i].command_name)) {
     e7c:	0300746e 	movweq	r7, #1134	@ 0x46e
     e80:	017b0704 	cmneq	fp, r4, lsl #14
     e84:	08030000 	stmdaeq	r3, {}	@ <UNPREDICTABLE>
      match_count++;
     e88:	00022504 	andeq	r2, r2, r4, lsl #10
      printf("\n%s", table[i].command_name);
     e8c:	04ef0700 	strbteq	r0, [pc], #1792	@ e94 <handle_tab+0x42>
     e90:	0c230000 	stceq	0, cr0, [r3], #-0
      last_match = i;
     e94:	0000006a 	andeq	r0, r0, sl, rrx
  if (match_count == 1) {
     e98:	00048307 	andeq	r8, r4, r7, lsl #6
     e9c:	6a0c2400 	bvs	309ea4 <__ROM_SIZE__+0x2c9ea4>
  if (match_count) {
     ea0:	0d000000 	stceq	0, cr0, [r0, #-0]
}
     ea4:	00000042 	andeq	r0, r0, r2, asr #32
    memcpy(cmd_buff, table[last_match].command_name, LINE_BUFF_SIZE);
     ea8:	000000a0 	andeq	r0, r0, r0, lsr #1
     eac:	fb070012 	blx	1c0efe <__ROM_SIZE__+0x180efe>
     eb0:	28000004 	stmdacs	r0, {r2}
     eb4:	00009510 	andeq	r9, r0, r0, lsl r5
    *char_count = strlen(cmd_buff);
     eb8:	00390700 	eorseq	r0, r9, r0, lsl #14
     ebc:	10290000 	eorne	r0, r9, r0
     ec0:	00000095 	muleq	r0, r5, r0
    printf("\n");
     ec4:	00051607 	andeq	r1, r5, r7, lsl #12
     ec8:	95102a00 	ldrls	r2, [r0, #-2560]	@ 0xfffff600
    prepend_prompt();
     ecc:	13000000 	movwne	r0, #0
    printf(PROMPT);
     ed0:	00646d63 	rsbeq	r6, r4, r3, ror #26
     ed4:	cd0f3b02 	vstrgt	d3, [pc, #-8]	@ ed4 <handle_tab+0x82>
    printf("%s", cmd_buff);
     ed8:	04000000 	streq	r0, [r0], #-0
     edc:	000000d2 	ldrdeq	r0, [r0], -r2
     ee0:	00006a14 	andeq	r6, r0, r4, lsl sl
     ee4:	0000e600 	andeq	lr, r0, r0, lsl #12
     ee8:	006a0200 	rsbeq	r0, sl, r0, lsl #4
     eec:	e6020000 	str	r0, [r2], -r0
     ef0:	00000000 	andeq	r0, r0, r0
__attribute__((weak)) int active_prompt() { return TRUE; }
     ef4:	0000eb04 	andeq	lr, r0, r4, lsl #22
static void shell(void) {
     ef8:	00f00400 	rscseq	r0, r0, r0, lsl #8
  int count = 0;
     efc:	01030000 	mrseq	r0, (UNDEF: 3)
  for (int i = 0; i < LINE_BUFF_SIZE; i++) line_buff[i] = 0;
     f00:	00013408 	andeq	r3, r1, r8, lsl #8
     f04:	00f01500 	rscseq	r1, r0, r0, lsl #10
     f08:	0c160000 	ldceq	0, cr0, [r6], {-0}
     f0c:	2a094402 	bcs	251f1c <__ROM_SIZE__+0x211f1c>
     f10:	09000001 	stmdbeq	r0, {r0}
  for (int i = 0; i < MAX_ARG_COUNT; i++) argv[i] = NULL;
     f14:	0000025d 	andeq	r0, r0, sp, asr r2
     f18:	012a0f45 			@ <UNDEFINED> instruction: 0x012a0f45
     f1c:	09000000 	stmdbeq	r0, {}	@ <UNPREDICTABLE>
     f20:	00000000 	andeq	r0, r0, r0
     f24:	012a0f46 			@ <UNDEFINED> instruction: 0x012a0f46
  prepend_prompt();
     f28:	09040000 	stmdbeq	r4, {}	@ <UNPREDICTABLE>
  printf(PROMPT);
     f2c:	000000da 	ldrdeq	r0, [r0], -sl
  int special_key = 0;
     f30:	00c10747 	sbceq	r0, r1, r7, asr #14
        special_key = 1;
     f34:	00080000 	andeq	r0, r8, r0
    if (s == -1) { s = __read_char2__();}
     f38:	0000f704 	andeq	pc, r0, r4, lsl #14
     f3c:	01bc0c00 			@ <UNDEFINED> instruction: 0x01bc0c00
    if (s != -1) {
     f40:	48020000 	stmdami	r2, {}	@ <UNPREDICTABLE>
     f44:	0000fc03 	andeq	pc, r0, r3, lsl #24
      loop();
     f48:	049d0a00 	ldreq	r0, [sp], #2560	@ 0xa00
        line_buff[count] = END_OF_LINE;
     f4c:	2f210000 	svccs	0x00210000
     f50:	05000001 	streq	r0, [r0, #-1]
     f54:	00299803 	eoreq	r9, r9, r3, lsl #16
     f58:	04aa0a00 	strteq	r0, [sl], #2560	@ 0xa00
        __write_char__(NEW_LINE);
     f5c:	2f220000 	svccs	0x00220000
     f60:	05000001 	streq	r0, [r0, #-1]
  add_command_to_history(line_buff);
     f64:	00298c03 	eoreq	r8, r9, r3, lsl #24
  argc = parse_line(argv, line_buff, MAX_ARG_COUNT);
     f68:	050c0a00 	streq	r0, [ip, #-2560]	@ 0xfffff600
     f6c:	2f230000 	svccs	0x00230000
     f70:	05000001 	streq	r0, [r0, #-1]
  if (argc > 0) execute(argc, argv);
     f74:	00298003 	eoreq	r8, r9, r3
}
     f78:	04680800 	strbteq	r0, [r8], #-2048	@ 0xfffff800
        if (!__echo) {
     f7c:	3d040000 	stccc	0, cr0, [r4, #-0]
     f80:	0000710e 	andeq	r7, r0, lr, lsl #2
        if (count == 0) continue;
     f84:	00018b00 	andeq	r8, r1, r0, lsl #22
        count--;
     f88:	018b0200 	orreq	r0, fp, r0, lsl #4
        line_buff[count] = END_OF_LINE;
     f8c:	71020000 	mrsvc	r0, (UNDEF: 2)
     f90:	02000000 	andeq	r0, r0, #0
     f94:	0000018b 	andeq	r0, r0, fp, lsl #3
        delete ();
     f98:	004e0400 	subeq	r0, lr, r0, lsl #8
      if (__echo) {
     f9c:	8a080000 	bhi	200fa4 <__ROM_SIZE__+0x1c0fa4>
        __write_char__(c);
     fa0:	05000004 	streq	r0, [r0, #-4]
     fa4:	006a055e 	rsbeq	r0, sl, lr, asr r5
    if (!active_prompt()) {
     fa8:	01ab0000 			@ <UNDEFINED> instruction: 0x01ab0000
     fac:	ab020000 	blge	80fb4 <__ROM_SIZE__+0x40fb4>
    s = __read_char__();
     fb0:	02000001 	andeq	r0, r0, #1
     fb4:	000001ab 	andeq	r0, r0, fp, lsr #3
    if (s == -1) { s = __read_char2__();}
     fb8:	00420400 	subeq	r0, r2, r0, lsl #8
     fbc:	e7080000 	str	r0, [r8, -r0]
      if (c == CARRIAGE_RETURN || c == NEW_LINE) {
     fc0:	04000000 	streq	r0, [r0], #-0
     fc4:	00710e4a 	rsbseq	r0, r1, sl, asr #28
      if (c == DELETE || c == BACK_SPACE) {
     fc8:	01d00000 	bicseq	r0, r0, r0
     fcc:	8b020000 	blhi	80fd4 <__ROM_SIZE__+0x40fd4>
      } else if (c == ESCAPE) {
     fd0:	02000001 	andeq	r0, r0, #1
      } else if (c == SQUARE_BRACKET_OPEN && special_key == 1) {
     fd4:	00000071 	andeq	r0, r0, r1, ror r0
      } else if ((c == 'C' || c == 'D') && special_key != 0) {
     fd8:	00018b02 	andeq	r8, r1, r2, lsl #22
     fdc:	58080000 	stmdapl	r8, {}	@ <UNPREDICTABLE>
     fe0:	06000004 	streq	r0, [r0], -r4
      } else if ((c == 'A' || c == 'B') && special_key == 2) {
     fe4:	006a052d 	rsbeq	r0, sl, sp, lsr #10
     fe8:	01e70000 	mvneq	r0, r0
      else if (c == TAB) {
     fec:	2a020000 	bcs	80ff4 <__ROM_SIZE__+0x40ff4>
        line_buff[count] = c;
     ff0:	0e000001 	cdpeq	0, 0, cr0, cr0, cr1, {0}
     ff4:	01dc0800 	bicseq	r0, ip, r0, lsl #16
     ff8:	2c060000 	stccs	0, cr0, [r6], {-0}
        count++;
     ffc:	00006a05 	andeq	r6, r0, r5, lsl #20
    1000:	0001fe00 	andeq	pc, r1, r0, lsl #28
          delete ();
    1004:	012a0200 			@ <UNDEFINED> instruction: 0x012a0200
          delete ();
    1008:	000e0000 	andeq	r0, lr, r0
      } else if (c == SQUARE_BRACKET_OPEN && special_key == 1) {
    100c:	0004a10f 	andeq	sl, r4, pc, lsl #2
        special_key = 2;
    1010:	006a1200 	rsbeq	r1, sl, r0, lsl #4
      } else if ((c == 'C' || c == 'D') && special_key != 0) {
    1014:	07a80000 	streq	r0, [r8, r0]!
        special_key = 0;
    1018:	00640000 	rsbeq	r0, r4, r0
      } else if ((c == 'A' || c == 'B') && special_key == 2) {
    101c:	9c010000 	stcls	0, cr0, [r1], {-0}
        if (!__echo) {
    1020:	000002d3 	ldrdeq	r0, [r0], -r3
    1024:	0001ed05 	andeq	lr, r1, r5, lsl #26
          clear_prompt(count + 4);
    1028:	6a121200 	bvs	485830 <__ROM_SIZE__+0x445830>
    102c:	95000000 	strls	r0, [r0, #-0]
        if (c == 'A') {
    1030:	91000001 	tstls	r0, r1
          handle_down_arrow(line_buff, &count);
    1034:	05000001 	streq	r0, [r0, #-1]
    1038:	0000015a 	andeq	r0, r0, sl, asr r1
        continue;
    103c:	00e61f12 	rsceq	r1, r6, r2, lsl pc
          clear_prompt(count);
    1040:	01a80000 			@ <UNDEFINED> instruction: 0x01a80000
    1044:	01a40000 			@ <UNDEFINED> instruction: 0x01a40000
          handle_up_arrow(line_buff, &count);
    1048:	e4170000 	ldr	r0, [r7], #-0
    104c:	01000004 	tsteq	r0, r4
        handle_tab(line_buff, &count);
    1050:	02d30d14 	sbcseq	r0, r3, #20, 26	@ 0x500
    1054:	91030000 	mrsls	r0, (UNDEF: 3)
        continue;
    1058:	b2067fac 	andlt	r7, r6, #172, 30	@ 0x2b0
  if (argc > 0) execute(argc, argv);
    105c:	e7000007 	str	r0, [r0, -r7]
}
    1060:	63000001 	movwvs	r0, #1
    1064:	01000002 	tsteq	r0, r2
    1068:	03055001 	movweq	r5, #20481	@ 0x5001
    106c:	00002d28 	andeq	r2, r0, r8, lsr #26
void prompt() {
    1070:	07be0600 	ldreq	r0, [lr, r0, lsl #12]!
  initial_setup();
    1074:	01b00000 	movseq	r0, r0
  exec_auto_cmds();
    1078:	027d0000 	rsbseq	r0, sp, #0
  setup();
    107c:	01010000 	mrseq	r0, (UNDEF: 1)
  decode_base64(AES_key_b64, 44, AES_key);
    1080:	20080251 	andcs	r0, r8, r1, asr r2
    1084:	02520101 	subseq	r0, r2, #1073741824	@ 0x40000000
    1088:	06000075 			@ <UNDEFINED> instruction: 0x06000075
    108c:	000007c8 	andeq	r0, r0, r8, asr #15
  AES_init_ctx(&ctx, AES_key);
    1090:	00000190 	muleq	r0, r0, r1
    1094:	00000297 	muleq	r0, r7, r2
    shell();
    1098:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
  while (TRUE) {
    109c:	01010074 	tsteq	r1, r4, ror r0
    10a0:	00750251 	rsbseq	r0, r5, r1, asr r2
    10a4:	07d20600 	ldrbeq	r0, [r2, r0, lsl #12]
int exec(char *cmd_str) {
    10a8:	016b0000 	cmneq	fp, r0
    10ac:	02b80000 	adcseq	r0, r8, #0
  argc = parse_line(argv, cmd_str, MAX_ARG_COUNT);
    10b0:	01010000 	mrseq	r0, (UNDEF: 1)
    10b4:	00740250 	rsbseq	r0, r4, r0, asr r2
  if (argc > 0) execute(argc, argv);
    10b8:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
  return __cmd_exec_status;
    10bc:	01013008 	tsteq	r1, r8
}
    10c0:	ac910352 	ldcge	3, cr0, [r1], {82}	@ 0x52
    10c4:	e80b007f 	stmda	fp, {r0, r1, r2, r3, r4, r5, r6}
  if (argc > 0) execute(argc, argv);
    10c8:	d0000007 	andle	r0, r0, r7
    10cc:	01000001 	tsteq	r0, r1
    10d0:	03055001 	movweq	r5, #20481	@ 0x5001
cmd get_function_addr(char *cmd_str) {
    10d4:	00002d54 	andeq	r2, r0, r4, asr sp
  for (int i = 0; table[i].command_name != NULL; i++) {
    10d8:	03530101 	cmpeq	r3, #1073741824	@ 0x40000000
    10dc:	007fac91 			@ <UNDEFINED> instruction: 0x007fac91
    10e0:	00420d00 	subeq	r0, r2, r0, lsl #26
    10e4:	02e30000 	rsceq	r0, r3, #0
    10e8:	71180000 	tstvc	r8, r0
    if (strcmp(cmd_str, table[i].command_name) == 0) {
    10ec:	40000000 	andmi	r0, r0, r0
    10f0:	04ae0f00 	strteq	r0, [lr], #3840	@ 0xf00
      return table[i].command;
    10f4:	6a0a0000 	bvs	2810fc <__ROM_SIZE__+0x2410fc>
    10f8:	7c000000 	stcvc	0, cr0, [r0], {-0}
  return NULL;
    10fc:	2c000007 	stccs	0, cr0, [r0], {7}
}
    1100:	01000000 	mrseq	r0, (UNDEF: 0)
  if(v < 26) return v + 'A';
    1104:	00034c9c 	muleq	r3, ip, ip
  if(v < 52) return v + 71;
    1108:	01ed0500 	mvneq	r0, r0, lsl #10
  if(v < 62) return v - 4;
    110c:	130a0000 	movwne	r0, #40960	@ 0xa000
  if(v == 62) return '+';
    1110:	0000006a 	andeq	r0, r0, sl, rrx
  if(v == 63) return '/';
    1114:	000001bb 			@ <UNDEFINED> instruction: 0x000001bb
  return 64;
    1118:	000001b7 			@ <UNDEFINED> instruction: 0x000001b7
  if(v < 26) return v + 'A';
    111c:	00015a05 	andeq	r5, r1, r5, lsl #20
    1120:	e6200a00 	strt	r0, [r0], -r0, lsl #20
  if(v < 52) return v + 71;
    1124:	cd000000 	stcgt	0, cr0, [r0, #-0]
  if(v < 62) return v - 4;
    1128:	c9000001 	stmdbgt	r0, {r0}
    112c:	06000001 	streq	r0, [r0], -r1
  if(v == 62) return '+';
    1130:	00000784 	andeq	r0, r0, r4, lsl #15
}
    1134:	000001e7 	andeq	r0, r0, r7, ror #3
  if('A' <= c && c <= 'Z') return c - 'A';
    1138:	00000338 	andeq	r0, r0, r8, lsr r3
    113c:	05500101 	ldrbeq	r0, [r0, #-257]	@ 0xfffffeff
  if('a' <= c && c <= 'z') return c - 71;
    1140:	002cdc03 	eoreq	sp, ip, r3, lsl #24
    1144:	920b0000 	andls	r0, fp, #0
    1148:	d0000007 	andle	r0, r0, r7
  if('0' <= c && c <= '9') return c + 4;
    114c:	01000001 	tsteq	r0, r1
    1150:	03055001 	movweq	r5, #20481	@ 0x5001
  if(c == '+') return 62;
    1154:	00002d10 	andeq	r2, r0, r0, lsl sp
  if(c == '/') return 63;
    1158:	10190000 	andsne	r0, r9, r0
  return 255;
    115c:	01000005 	tsteq	r0, r5
  if('a' <= c && c <= 'z') return c - 71;
    1160:	006a0504 	rsbeq	r0, sl, r4, lsl #10
    1164:	07500000 	ldrbeq	r0, [r0, -r0]
  if('0' <= c && c <= '9') return c + 4;
    1168:	002c0000 	eoreq	r0, ip, r0
  if(c == '+') return 62;
    116c:	9c010000 	stcls	0, cr0, [r1], {-0}
  if(c == '/') return 63;
    1170:	0001ed05 	andeq	lr, r1, r5, lsl #26
  return (input_length + 2)/3*4;
    1174:	6a0f0400 	bvs	3c217c <__ROM_SIZE__+0x38217c>
    1178:	df000000 	svcle	0x00000000
    117c:	db000001 	blle	1188 <decode_base64_length>
}
    1180:	05000001 	streq	r0, [r0, #-1]
    1184:	0000015a 	andeq	r0, r0, sl, asr r1
unsigned int decode_base64_length(unsigned char input[], unsigned int input_length) {
    1188:	00e61c04 	rsceq	r1, r6, r4, lsl #24
    118c:	01f10000 	mvnseq	r0, r0
  while(base64_to_binary(input[0]) < 64 && (unsigned int) (input - start) < input_length) {
    1190:	01ed0000 	mvneq	r0, r0
    1194:	58060000 	stmdapl	r6, {}	@ <UNPREDICTABLE>
    1198:	e7000007 	str	r0, [r0, -r7]
    119c:	9f000001 	svcls	0x00000001
    11a0:	01000003 	tsteq	r0, r3
  input_length = input - start;
    11a4:	03055001 	movweq	r5, #20481	@ 0x5001
  return input_length/4*3 + (input_length % 4 ? input_length % 4 - 1 : 0);
    11a8:	00002ca8 	andeq	r2, r0, r8, lsr #25
    11ac:	07660b00 	strbeq	r0, [r6, -r0, lsl #22]!
    11b0:	01d00000 	bicseq	r0, r0, r0
}
    11b4:	01010000 	mrseq	r0, (UNDEF: 1)
  return input_length/4*3 + (input_length % 4 ? input_length % 4 - 1 : 0);
    11b8:	c4030550 	strgt	r0, [r3], #-1360	@ 0xfffffab0
unsigned int encode_base64(unsigned char input[], unsigned int input_length, unsigned char output[]) {
    11bc:	0000002c 	andeq	r0, r0, ip, lsr #32
    11c0:	03620000 	cmneq	r2, #0
    11c4:	00050000 	andeq	r0, r5, r0
  unsigned int full_sets = input_length/3;
    11c8:	075c0401 	ldrbeq	r0, [ip, -r1, lsl #8]
    11cc:	46120000 	ldrmi	r0, [r2], -r0
  for(unsigned int i = 0; i < full_sets; ++i) {
    11d0:	1d000000 	stcne	0, cr0, [r0, #-0]
    output[0] = binary_to_base64(                         input[0] >> 2);
    11d4:	00000541 	andeq	r0, r0, r1, asr #10
    11d8:	00000014 	andeq	r0, r0, r4, lsl r0
    output[1] = binary_to_base64((input[0] & 0x03) << 4 | input[1] >> 4);
    11dc:	0000080c 	andeq	r0, r0, ip, lsl #16
    11e0:	000000ac 	andeq	r0, r0, ip, lsr #1
    11e4:	00000adb 	ldrdeq	r0, [r0], -fp
    11e8:	2d060102 	stfcss	f0, [r6, #-8]
    11ec:	02000001 	andeq	r0, r0, #1
    output[2] = binary_to_base64((input[1] & 0x0F) << 2 | input[2] >> 6);
    11f0:	01e30502 	mvneq	r0, r2, lsl #10
    11f4:	04020000 	streq	r0, [r2], #-0
    11f8:	0001c705 	andeq	ip, r1, r5, lsl #14
    11fc:	05080200 	streq	r0, [r8, #-512]	@ 0xfffffe00
    1200:	000001c2 	andeq	r0, r0, r2, asr #3
    output[3] = binary_to_base64( input[2] & 0x3F);
    1204:	00018808 	andeq	r8, r1, r8, lsl #16
    1208:	182e0200 	stmdane	lr!, {r9}
    120c:	0000004e 	andeq	r0, r0, lr, asr #32
    input += 3;
    1210:	2b080102 	blcs	201620 <__ROM_SIZE__+0x1c1620>
  for(unsigned int i = 0; i < full_sets; ++i) {
    1214:	02000001 	andeq	r0, r0, #1
    1218:	01390702 	teqeq	r9, r2, lsl #14
  switch(input_length % 3) {
    121c:	04020000 	streq	r0, [r2], #-0
    1220:	00017607 	andeq	r7, r1, r7, lsl #12
    1224:	07080200 	streq	r0, [r8, -r0, lsl #4]
    1228:	00000171 	andeq	r0, r0, r1, ror r1
    122c:	69050413 	stmdbvs	r5, {r0, r1, r4, sl}
    1230:	0200746e 	andeq	r7, r0, #1845493760	@ 0x6e000000
    1234:	017b0704 	cmneq	fp, r4, lsl #14
  return encode_base64_length(input_length);
    1238:	0d080000 	stceq	0, cr0, [r8, #-0]
}
    123c:	03000000 	movweq	r0, #0
      output[0] = '\0';
    1240:	007117d6 	ldrsbteq	r1, [r1], #-118	@ 0xffffff8a
      output[0] = binary_to_base64(                         input[0] >> 2);
    1244:	08020000 	stmdaeq	r2, {}	@ <UNPREDICTABLE>
    1248:	00022504 	andeq	r2, r2, r4, lsl #10
    124c:	6d631400 	cfstrdvs	mvd1, [r3, #-0]
      output[1] = binary_to_base64((input[0] & 0x03) << 4);
    1250:	3b040064 	blcc	1013e8 <__ROM_SIZE__+0xc13e8>
    1254:	0000970f 	andeq	r9, r0, pc, lsl #14
    1258:	009c0400 	addseq	r0, ip, r0, lsl #8
      output[2] = '=';
    125c:	6a150000 	bvs	541264 <__ROM_SIZE__+0x501264>
      output[3] = '=';
    1260:	b0000000 	andlt	r0, r0, r0
      output[4] = '\0';
    1264:	03000000 	movweq	r0, #0
      output[0] = binary_to_base64(                         input[0] >> 2);
    1268:	0000006a 	andeq	r0, r0, sl, rrx
    126c:	0000b003 	andeq	fp, r0, r3
    1270:	b5040000 	strlt	r0, [r4, #-0]
      output[1] = binary_to_base64((input[0] & 0x03) << 4 | input[1] >> 4);
    1274:	04000000 	streq	r0, [r0], #-0
    1278:	000000ba 	strheq	r0, [r0], -sl
    127c:	34080102 	strcc	r0, [r8], #-258	@ 0xfffffefe
    1280:	16000001 	strne	r0, [r0], -r1
    1284:	000000ba 	strheq	r0, [r0], -sl
      output[2] = binary_to_base64((input[1] & 0x0F) << 2);
    1288:	44040c17 	strmi	r0, [r4], #-3095	@ 0xfffff3e9
    128c:	0000f409 	andeq	pc, r0, r9, lsl #8
    1290:	025d0900 	subseq	r0, sp, #0, 18
      output[3] = '=';
    1294:	0f450000 	svceq	0x00450000
      output[4] = '\0';
    1298:	000000f4 	strdeq	r0, [r0], -r4
      break;
    129c:	00000900 	andeq	r0, r0, r0, lsl #18
    12a0:	0f460000 	svceq	0x00460000
unsigned int decode_base64(unsigned char input[], unsigned int input_length, unsigned char output[]) {
    12a4:	000000f4 	strdeq	r0, [r0], -r4
    12a8:	00da0904 	sbcseq	r0, sl, r4, lsl #18
  unsigned int output_length = decode_base64_length(input, input_length);
    12ac:	07470000 	strbeq	r0, [r7, -r0]
    12b0:	0000008b 	andeq	r0, r0, fp, lsl #1
  for(unsigned int i = 2; i < output_length; i += 3) {
    12b4:	c1040008 	tstgt	r4, r8
    output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
    12b8:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
    12bc:	000001bc 			@ <UNDEFINED> instruction: 0x000001bc
    12c0:	c6034804 	strgt	r4, [r3], -r4, lsl #16
    12c4:	0c000000 	stceq	0, cr0, [r0], {-0}
    12c8:	0000056f 	andeq	r0, r0, pc, ror #10
    output[1] = base64_to_binary(input[1]) << 4 | base64_to_binary(input[2]) >> 2;
    12cc:	0000f939 	andeq	pc, r0, r9, lsr r9	@ <UNPREDICTABLE>
    12d0:	b0030500 	andlt	r0, r3, r0, lsl #10
    12d4:	0c000029 	stceq	0, cr0, [r0], {41}	@ 0x29
    12d8:	00000522 	andeq	r0, r0, r2, lsr #10
    12dc:	0000f93a 	andeq	pc, r0, sl, lsr r9	@ <UNPREDICTABLE>
    output[2] = base64_to_binary(input[2]) << 6 | base64_to_binary(input[3]);
    12e0:	a4030500 	strge	r0, [r3], #-1280	@ 0xfffffb00
    12e4:	06000029 	streq	r0, [r0], -r9, lsr #32
    12e8:	000000e7 	andeq	r0, r0, r7, ror #1
    12ec:	710e4a05 	tstvc	lr, r5, lsl #20
    input += 4;
    12f0:	45000000 	strmi	r0, [r0, #-0]
  for(unsigned int i = 2; i < output_length; i += 3) {
    12f4:	03000001 	movweq	r0, #1
    12f8:	00000145 	andeq	r0, r0, r5, asr #2
  switch(output_length % 3) {
    12fc:	00007103 	andeq	r7, r0, r3, lsl #2
    1300:	01450300 	mrseq	r0, (UNDEF: 117)
    1304:	04000000 	streq	r0, [r0], #-0
    1308:	0000004e 	andeq	r0, r0, lr, asr #32
    130c:	0001dc06 	andeq	sp, r1, r6, lsl #24
    1310:	052c0600 	streq	r0, [ip, #-1536]!	@ 0xfffffa00
    1314:	0000006a 	andeq	r0, r0, sl, rrx
    1318:	00000161 	andeq	r0, r0, r1, ror #2
      output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
    131c:	0000f403 	andeq	pc, r0, r3, lsl #8
    1320:	06001800 	streq	r1, [r0], -r0, lsl #16
    1324:	00000468 	andeq	r0, r0, r8, ror #8
    1328:	710e3d05 	tstvc	lr, r5, lsl #26
    132c:	81000000 	mrshi	r0, (UNDEF: 0)
      output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
    1330:	03000001 	movweq	r0, #1
    1334:	00000145 	andeq	r0, r0, r5, asr #2
    1338:	00007103 	andeq	r7, r0, r3, lsl #2
    133c:	01450300 	mrseq	r0, (UNDEF: 117)
    1340:	06000000 	streq	r0, [r0], -r0
      output[1] = base64_to_binary(input[1]) << 4 | base64_to_binary(input[2]) >> 2;
    1344:	0000024e 	andeq	r0, r0, lr, asr #4
    1348:	78081f07 	stmdavc	r8, {r0, r1, r2, r8, r9, sl, fp, ip}
    134c:	97000000 	strls	r0, [r0, -r0]
    1350:	03000001 	movweq	r0, #1
    1354:	000000f4 	strdeq	r0, [r0], -r4
  return output_length;
    1358:	05260d00 	streq	r0, [r6, #-3328]!	@ 0xfffff300
    135c:	6a200000 	bvs	801364 <__ROM_SIZE__+0x7c1364>
{
    1360:	5c000000 	stcpl	0, cr0, [r0], {-0}
    1364:	5c000008 	stcpl	0, cr0, [r0], {8}
	for (i = 0, j = 0; i < 16; ++i, j += 4)
    1368:	01000000 	mrseq	r0, (UNDEF: 0)
    136c:	0002759c 	muleq	r2, ip, r5
		m[i] = (data[j] << 24) | (data[j + 1] << 16) | (data[j + 2] << 8) | (data[j + 3]);
    1370:	01ed0700 	mvneq	r0, r0, lsl #14
    1374:	12200000 	eorne	r0, r0, #0
    1378:	0000006a 	andeq	r0, r0, sl, rrx
    137c:	00000213 	andeq	r0, r0, r3, lsl r2
    1380:	0000020b 	andeq	r0, r0, fp, lsl #4
    1384:	00015a07 	andeq	r5, r1, r7, lsl #20
    1388:	b01f2000 	andslt	r2, pc, r0
	for (i = 0, j = 0; i < 16; ++i, j += 4)
    138c:	3b000000 	blcc	1394 <sha256_transform+0x34>
    1390:	33000002 	movwcc	r0, #2
		m[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16];
    1394:	0a000002 	beq	13a4 <sha256_transform+0x44>
    1398:	00000866 	andeq	r0, r0, r6, ror #16
    139c:	00000038 	andeq	r0, r0, r8, lsr r0
    13a0:	00000261 	andeq	r0, r0, r1, ror #4
    13a4:	6e656c0e 	cdpvs	12, 6, cr6, cr5, cr14, {0}
    13a8:	006a2400 	rsbeq	r2, sl, r0, lsl #8
    13ac:	02620000 	rsbeq	r0, r2, #0
    13b0:	02580000 	subseq	r0, r8, #0
    13b4:	720a0000 	andvc	r0, sl, #0
    13b8:	20000008 	andcs	r0, r0, r8
    13bc:	3e000000 	cdpcc	0, 0, cr0, cr0, cr0, {0}
    13c0:	0f000002 	svceq	0x00000002
    13c4:	0000052f 	andeq	r0, r0, pc, lsr #10
    13c8:	02751928 	rsbseq	r1, r5, #40, 18	@ 0xa0000
    13cc:	91030000 	mrsls	r0, (UNDEF: 3)
    13d0:	7a0b7f90 	bvc	2e1218 <__ROM_SIZE__+0x2a1218>
    13d4:	25000008 	strcs	r0, [r0, #-8]
	for ( ; i < 64; ++i)
    13d8:	24000001 	strcs	r0, [r0], #-1
    13dc:	01000002 	tsteq	r0, r2
	a = ctx->state[0];
    13e0:	7d025201 	sfmvc	f5, 4, [r2, #-4]
	b = ctx->state[1];
    13e4:	92050000 	andls	r0, r5, #0
	c = ctx->state[2];
    13e8:	4a000008 	bmi	1410 <sha256_transform+0xb0>
	d = ctx->state[3];
    13ec:	01000001 	tsteq	r0, r1
	e = ctx->state[4];
    13f0:	03055001 	movweq	r5, #20481	@ 0x5001
	f = ctx->state[5];
    13f4:	00002e60 	andeq	r2, r0, r0, ror #28
    13f8:	02520101 	subseq	r0, r2, #1073741824	@ 0x40000000
	g = ctx->state[6];
    13fc:	0000007d 	andeq	r0, r0, sp, ror r0
	h = ctx->state[7];
    1400:	00086c10 	andeq	r6, r8, r0, lsl ip
    1404:	00018100 	andeq	r8, r1, r0, lsl #2
	d = ctx->state[3];
    1408:	089c0500 	ldmeq	ip, {r8, sl}
	b = ctx->state[1];
    140c:	014a0000 	mrseq	r0, (UNDEF: 74)
	for (i = 0; i < 64; ++i) {
    1410:	01010000 	mrseq	r0, (UNDEF: 1)
    1414:	74030550 	strvc	r0, [r3], #-1360	@ 0xfffffab0
    1418:	0100002e 	tsteq	r0, lr, lsr #32
    141c:	08025101 	stmdaeq	r2, {r0, r8, ip, lr}
		t1 = h + EP1(e) + CH(e,f,g) + k[i] + m[i];
    1420:	05000080 	streq	r0, [r0, #-128]	@ 0xffffff80
    1424:	000008a4 	andeq	r0, r0, r4, lsr #17
    1428:	0000014a 	andeq	r0, r0, sl, asr #2
    142c:	05500101 	ldrbeq	r0, [r0, #-257]	@ 0xfffffeff
    1430:	002eb003 	eoreq	fp, lr, r3
    1434:	19000000 	stmdbne	r0, {}	@ <UNPREDICTABLE>
    1438:	00000042 	andeq	r0, r0, r2, asr #32
    143c:	00000285 	andeq	r0, r0, r5, lsl #5
    1440:	00007111 	andeq	r7, r0, r1, lsl r1
    1444:	0d006400 	cfstrseq	mvf6, [r0, #-0]
    1448:	00000573 	andeq	r0, r0, r3, ror r5
		t2 = EP0(a) + MAJ(a,b,c);
    144c:	00006a09 	andeq	r6, r0, r9, lsl #20
    1450:	00080c00 	andeq	r0, r8, r0, lsl #24
    1454:	00005000 	andeq	r5, r0, r0
    1458:	599c0100 	ldmibpl	ip, {r8}
    145c:	07000003 	streq	r0, [r0, -r3]
    1460:	000001ed 	andeq	r0, r0, sp, ror #3
    1464:	006a1209 	rsbeq	r1, sl, r9, lsl #4
    1468:	02890000 	addeq	r0, r9, #0
		h = g;
    146c:	02810000 	addeq	r0, r1, #0
		f = e;
    1470:	5a070000 	bpl	1c1478 <__ROM_SIZE__+0x181478>
		e = d + t1;
    1474:	09000001 	stmdbeq	r0, {r0}
		c = b;
    1478:	0000b01f 	andeq	fp, r0, pc, lsl r0
		a = t1 + t2;
    147c:	0002ac00 	andeq	sl, r2, r0, lsl #24
	for (i = 0; i < 64; ++i) {
    1480:	0002a400 	andeq	sl, r2, r0, lsl #8
	ctx->state[0] += a;
    1484:	08160a00 	ldmdaeq	r6, {r9, fp}
    1488:	002c0000 	eoreq	r0, ip, r0
    148c:	03450000 	movteq	r0, #20480	@ 0x5000
    1490:	390f0000 	stmdbcc	pc, {}	@ <UNPREDICTABLE>
    1494:	0d000005 	stceq	0, cr0, [r0, #-20]	@ 0xffffffec
	ctx->state[1] += b;
    1498:	00035911 	andeq	r5, r3, r1, lsl r9
	ctx->state[2] += c;
    149c:	f8910300 			@ <UNDEFINED> instruction: 0xf8910300
    14a0:	656c0e7e 	strbvs	r0, [ip, #-3710]!	@ 0xfffff182
	ctx->state[3] += d;
    14a4:	6a0e006e 	bvs	381664 <__ROM_SIZE__+0x341664>
	ctx->state[4] += e;
    14a8:	ce000000 	cdpgt	0, 0, cr0, cr0, cr0, {0}
    14ac:	c4000002 	strgt	r0, [r0], #-2
	ctx->state[5] += f;
    14b0:	10000002 	andne	r0, r0, r2
    14b4:	0000081c 	andeq	r0, r0, ip, lsl r8
	ctx->state[6] += g;
    14b8:	00000181 	andeq	r0, r0, r1, lsl #3
    14bc:	00082a0b 	andeq	r2, r8, fp, lsl #20
	ctx->state[7] += h;
    14c0:	00016100 	andeq	r6, r1, r0, lsl #2
    14c4:	00030e00 	andeq	r0, r3, r0, lsl #28
}
    14c8:	52010100 	andpl	r0, r1, #0, 2
    14cc:	00007d02 	andeq	r7, r0, r2, lsl #26
    14d0:	0008360b 	andeq	r3, r8, fp, lsl #12
	ctx->datalen = 0;
    14d4:	00014a00 	andeq	r4, r1, r0, lsl #20
	ctx->bitlen = 0;
    14d8:	00032b00 	andeq	r2, r3, r0, lsl #22
    14dc:	50010100 	andpl	r0, r1, r0, lsl #2
	ctx->state[0] = 0x6a09e667;
    14e0:	2df00305 	ldclcs	3, cr0, [r0, #20]!
	ctx->state[1] = 0xbb67ae85;
    14e4:	01010000 	mrseq	r0, (UNDEF: 1)
	ctx->state[2] = 0x3c6ef372;
    14e8:	007d0252 	rsbseq	r0, sp, r2, asr r2
	ctx->state[3] = 0xa54ff53a;
    14ec:	08400500 	stmdaeq	r0, {r8, sl}^
	ctx->state[4] = 0x510e527f;
    14f0:	014a0000 	mrseq	r0, (UNDEF: 74)
	ctx->state[5] = 0x9b05688c;
    14f4:	01010000 	mrseq	r0, (UNDEF: 1)
	ctx->state[6] = 0x1f83d9ab;
    14f8:	18030550 	stmdane	r3, {r4, r6, r8, sl}
	ctx->state[7] = 0x5be0cd19;
    14fc:	0100002e 	tsteq	r0, lr, lsr #32
    1500:	08025101 	stmdaeq	r2, {r0, r8, ip, lr}
    1504:	05000064 	streq	r0, [r0, #-100]	@ 0xffffff9c
    1508:	00000848 	andeq	r0, r0, r8, asr #16
}
    150c:	0000014a 	andeq	r0, r0, sl, asr #2
    1510:	05500101 	ldrbeq	r0, [r0, #-257]	@ 0xfffffeff
    1514:	002e4403 	eoreq	r4, lr, r3, lsl #8
    1518:	1a000000 	bne	1520 <sha256_init+0x4c>
    151c:	00000042 	andeq	r0, r0, r2, asr #32
    1520:	00007111 	andeq	r7, r0, r1, lsl r1
    1524:	00007f00 	andeq	r7, r0, r0, lsl #30
{
    1528:	00000645 	andeq	r0, r0, r5, asr #12
    152c:	04010005 	streq	r0, [r1], #-5
	for (i = 0; i < len; ++i) {
    1530:	000008bf 			@ <UNDEFINED> instruction: 0x000008bf
    1534:	00004611 	andeq	r4, r0, r1, lsl r6
    1538:	058c1d00 	streq	r1, [ip, #3328]	@ 0xd00
		ctx->data[ctx->datalen] = data[i];
    153c:	00140000 	andseq	r0, r4, r0
		ctx->datalen++;
    1540:	08b80000 	ldmeq	r8!, {}	@ <UNPREDICTABLE>
		if (ctx->datalen == 64) {
    1544:	010c0000 	mrseq	r0, (UNDEF: 12)
			sha256_transform(ctx, ctx->data);
    1548:	0d030000 	stceq	0, cr0, [r3, #-0]
    154c:	01040000 	mrseq	r0, (UNDEF: 4)
			ctx->bitlen += 512;
    1550:	00012d06 	andeq	r2, r1, r6, lsl #26
    1554:	05020400 	streq	r0, [r2, #-1024]	@ 0xfffffc00
    1558:	000001e3 	andeq	r0, r0, r3, ror #3
    155c:	c7050404 	strgt	r0, [r5, -r4, lsl #8]
			ctx->datalen = 0;
    1560:	04000001 	streq	r0, [r0], #-1
    1564:	01c20508 	biceq	r0, r2, r8, lsl #10
{
    1568:	880a0000 	stmdahi	sl, {}	@ <UNPREDICTABLE>
    156c:	02000001 	andeq	r0, r0, #1
	if (ctx->datalen < 56) {
    1570:	0053182e 	subseq	r1, r3, lr, lsr #16
		ctx->data[i++] = 0x80;
    1574:	420e0000 	andmi	r0, lr, #0
    1578:	04000000 	streq	r0, [r0], #-0
			ctx->data[i++] = 0x00;
    157c:	012b0801 			@ <UNDEFINED> instruction: 0x012b0801
    1580:	02040000 	andeq	r0, r4, #0
		while (i < 56)
    1584:	00013907 	andeq	r3, r1, r7, lsl #18
	ctx->bitlen += ctx->datalen * 8;
    1588:	07040400 	streq	r0, [r4, -r0, lsl #8]
    158c:	00000176 	andeq	r0, r0, r6, ror r1
    1590:	71070804 	tstvc	r7, r4, lsl #16
    1594:	12000001 	andne	r0, r0, #1
	ctx->data[63] = ctx->bitlen;
    1598:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
	ctx->data[62] = ctx->bitlen >> 8;
    159c:	04040074 	streq	r0, [r4], #-116	@ 0xffffff8c
    15a0:	00017b07 	andeq	r7, r1, r7, lsl #22
	ctx->data[61] = ctx->bitlen >> 16;
    15a4:	000d0a00 	andeq	r0, sp, r0, lsl #20
	ctx->data[60] = ctx->bitlen >> 24;
    15a8:	d6030000 	strle	r0, [r3], -r0
    15ac:	00007617 	andeq	r7, r0, r7, lsl r6
	ctx->data[59] = ctx->bitlen >> 32;
    15b0:	04080400 	streq	r0, [r8], #-1024	@ 0xfffffc00
	ctx->data[58] = ctx->bitlen >> 40;
    15b4:	00000225 	andeq	r0, r0, r5, lsr #4
	ctx->data[57] = ctx->bitlen >> 48;
    15b8:	0001a013 	andeq	sl, r1, r3, lsl r0
    15bc:	05010000 	streq	r0, [r1, #-0]
	ctx->data[56] = ctx->bitlen >> 56;
    15c0:	00b8082c 	adcseq	r0, r8, ip, lsr #16
	sha256_transform(ctx, ctx->data);
    15c4:	96060000 	strls	r0, [r6], -r0
    15c8:	0500000c 	streq	r0, [r0, #-12]
	for (i = 0; i < 4; ++i) {
    15cc:	00b80b2e 	adcseq	r0, r8, lr, lsr #22
		ctx->data[i++] = 0x80;
    15d0:	14000000 	strne	r0, [r0], #-0
    15d4:	05007649 	streq	r7, [r0, #-1609]	@ 0xfffff9b7
			ctx->data[i++] = 0x00;
    15d8:	00c80b30 	sbceq	r0, r8, r0, lsr fp
    15dc:	00f00000 	rscseq	r0, r0, r0
		while (i < 64)
    15e0:	00004207 	andeq	r4, r0, r7, lsl #4
		sha256_transform(ctx, ctx->data);
    15e4:	0000c800 	andeq	ip, r0, r0, lsl #16
    15e8:	00760800 	rsbseq	r0, r6, r0, lsl #16
		memset(ctx->data, 0, 56);
    15ec:	00ef0000 	rsceq	r0, pc, r0
    15f0:	00004207 	andeq	r4, r0, r7, lsl #4
    15f4:	0000d800 	andeq	sp, r0, r0, lsl #16
		hash[i]      = (ctx->state[0] >> (24 - i * 8)) & 0x000000ff;
    15f8:	00760800 	rsbseq	r0, r6, r0, lsl #16
    15fc:	000f0000 	andeq	r0, pc, r0
    1600:	0000e20a 	andeq	lr, r0, sl, lsl #4
		hash[i + 4]  = (ctx->state[1] >> (24 - i * 8)) & 0x000000ff;
    1604:	17130400 	ldrne	r0, [r3, -r0, lsl #8]
    1608:	00000053 	andeq	r0, r0, r3, asr r0
		hash[i + 8]  = (ctx->state[2] >> (24 - i * 8)) & 0x000000ff;
    160c:	0000d80e 	andeq	sp, r0, lr, lsl #16
    1610:	00c90a00 	sbceq	r0, r9, r0, lsl #20
		hash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0x000000ff;
    1614:	14040000 	strne	r0, [r4], #-0
    1618:	00007617 	andeq	r7, r0, r7, lsl r6
    161c:	04700f00 	ldrbteq	r0, [r0], #-3840	@ 0xfffff100
		hash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0x000000ff;
    1620:	00013216 	andeq	r3, r1, r6, lsl r2
    1624:	07900600 	ldreq	r0, [r0, r0, lsl #12]
		hash[i + 20] = (ctx->state[5] >> (24 - i * 8)) & 0x000000ff;
    1628:	17040000 	strne	r0, [r4, -r0]
    162c:	00013207 	andeq	r3, r1, r7, lsl #4
    1630:	c1060000 	mrsgt	r0, (UNDEF: 6)
		hash[i + 24] = (ctx->state[6] >> (24 - i * 8)) & 0x000000ff;
    1634:	04000000 	streq	r0, [r0], #-0
    1638:	00e90718 	rsceq	r0, r9, r8, lsl r7
		hash[i + 28] = (ctx->state[7] >> (24 - i * 8)) & 0x000000ff;
    163c:	06400000 	strbeq	r0, [r0], -r0
    1640:	0000015f 	andeq	r0, r0, pc, asr r1
    1644:	68151904 	ldmdavs	r5, {r2, r8, fp, ip}
	for (i = 0; i < 4; ++i) {
    1648:	48000000 	stmdami	r0, {}	@ <UNPREDICTABLE>
}
    164c:	000b2e06 	andeq	r2, fp, r6, lsl #28
static void outstr(const char *str) {
    1650:	071a0400 	ldreq	r0, [sl, -r0, lsl #8]
  while (*str != '\0') {
    1654:	00000142 	andeq	r0, r0, r2, asr #2
    __write_char__(*str);
    1658:	d8070050 	stmdale	r7, {r4, r6}
    str++;
    165c:	42000000 	andmi	r0, r0, #0
  while (*str != '\0') {
    1660:	08000001 	stmdaeq	r0, {r0}
}
    1664:	00000076 	andeq	r0, r0, r6, ror r0
    1668:	e907003f 	stmdb	r7, {r0, r1, r2, r3, r4, r5}
static bool printf_numbers(const char fmt, va_list *args, int l_count) {
    166c:	52000000 	andpl	r0, r0, #0
    1670:	08000001 	stmdaeq	r0, {r0}
  switch (fmt) {
    1674:	00000076 	andeq	r0, r0, r6, ror r0
    1678:	660a0007 	strvs	r0, [sl], -r7
    167c:	04000001 	streq	r0, [r0], #-1
      if (l_count == 0) {
    1680:	00f5031b 	rscseq	r0, r5, fp, lsl r3
    1684:	63150000 	tstvs	r5, #0
        value = va_arg(*args, unsigned int);
    1688:	06007874 			@ <UNDEFINED> instruction: 0x06007874
    168c:	00901725 	addseq	r1, r0, r5, lsr #14
      if (fmt == 'u') {
    1690:	42070000 	andmi	r0, r7, #0
        if (value == 0) {
    1694:	75000000 	strvc	r0, [r0, #-0]
          __write_char__(hextable[0]);
    1698:	16000001 	strne	r0, [r0], -r1
    169c:	04fb0b00 	ldrbteq	r0, [fp], #2816	@ 0xb00
  return true;
    16a0:	6a280000 	bvs	a016a8 <__ROM_SIZE__+0x9c16a8>
  switch (fmt) {
    16a4:	0b000001 	bleq	16b0 <printf_numbers+0x44>
      outstr("\nprintf-error\n");
    16a8:	00000039 	andeq	r0, r0, r9, lsr r0
      return false;
    16ac:	00016a29 	andeq	r6, r1, r9, lsr #20
}
    16b0:	05160b00 	ldreq	r0, [r6, #-2816]	@ 0xfffff500
      if (l_count == 0) {
    16b4:	6a2a0000 	bvs	a816bc <__ROM_SIZE__+0xa416bc>
        value = va_arg(*args, int);
    16b8:	0b000001 	bleq	16c4 <printf_numbers+0x58>
    16bc:	000001d0 	ldrdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
      if (value < 0) {
    16c0:	00016a2c 	andeq	r6, r1, ip, lsr #20
        num[num_len++] = hextable[value % 10];
    16c4:	00ce0b00 	sbceq	r0, lr, r0, lsl #22
    16c8:	6a2d0000 	bvs	b416d0 <__ROM_SIZE__+0xb016d0>
    16cc:	17000001 	strne	r0, [r0, -r1]
    16d0:	00646d63 	rsbeq	r6, r4, r3, ror #26
    16d4:	b30f3b06 	movwlt	r3, #64262	@ 0xfb06
    16d8:	05000001 	streq	r0, [r0, #-1]
    16dc:	000001b8 			@ <UNDEFINED> instruction: 0x000001b8
    16e0:	00006f18 	andeq	r6, r0, r8, lsl pc
    16e4:	0001cc00 	andeq	ip, r1, r0, lsl #24
        value = value / 10;
    16e8:	006f0200 	rsbeq	r0, pc, r0, lsl #4
      } while (value > 0);
    16ec:	cc020000 	stcgt	0, cr0, [r2], {-0}
    16f0:	00000001 	andeq	r0, r0, r1
        __write_char__('-');
    16f4:	0001d105 	andeq	sp, r1, r5, lsl #2
    16f8:	01d60500 	bicseq	r0, r6, r0, lsl #10
        value = -value;
    16fc:	01040000 	mrseq	r0, (UNDEF: 4)
        __write_char__(num[--num_len]);
    1700:	00013408 	andeq	r3, r1, r8, lsl #8
    1704:	01d60e00 	bicseq	r0, r6, r0, lsl #28
    1708:	0c0f0000 	stceq	0, cr0, [pc], {-0}
    170c:	02124406 	andseq	r4, r2, #100663296	@ 0x6000000
    1710:	5d060000 	stcpl	0, cr0, [r6, #-0]
      while (num_len > 0) {
    1714:	06000002 	streq	r0, [r0], -r2
  return true;
    1718:	02120f45 	andseq	r0, r2, #276	@ 0x114
          num[num_len++] = hextable[value % 10];
    171c:	06000000 	streq	r0, [r0], -r0
    1720:	00000000 	andeq	r0, r0, r0
    1724:	120f4606 	andne	r4, pc, #6291456	@ 0x600000
    1728:	04000002 	streq	r0, [r0], #-2
    172c:	0000da06 	andeq	sp, r0, r6, lsl #20
    1730:	07470600 	strbeq	r0, [r7, -r0, lsl #12]
    1734:	000001a7 	andeq	r0, r0, r7, lsr #3
    1738:	dd050008 	stcle	0, cr0, [r5, #-32]	@ 0xffffffe0
          value = value / 10;
    173c:	0a000001 	beq	1748 <printf_numbers+0xdc>
        } while (value > 0);
    1740:	000001bc 			@ <UNDEFINED> instruction: 0x000001bc
        while (num_len > 0) {
    1744:	e2034806 	and	r4, r3, #393216	@ 0x60000
          __write_char__(num[--num_len]);
    1748:	19000001 	stmdbne	r0, {r0}
    174c:	000005df 	ldrdeq	r0, [r0], -pc	@ <UNPREDICTABLE>
    1750:	17013b01 	strne	r3, [r1, -r1, lsl #22]
    1754:	05000002 	streq	r0, [r0, #-2]
    1758:	0029bc03 	eoreq	fp, r9, r3, lsl #24
    175c:	01a80d00 			@ <UNDEFINED> instruction: 0x01a80d00
  return true;
    1760:	34050000 	strcc	r0, [r5], #-0
              __write_char__(hextable[val]);
    1764:	0000024b 	andeq	r0, r0, fp, asr #4
    1768:	00024b02 	andeq	r4, r2, r2, lsl #22
              leading_zero_ignored = true;
    176c:	02500200 	subseq	r0, r0, #0, 4
          while (start_bit >= 0) {
    1770:	05000000 	streq	r0, [r0, #-0]
            int val = (value >> start_bit) & 0xF;
    1774:	00000090 	muleq	r0, r0, r0
            if (val || leading_zero_ignored) {
    1778:	00004e05 	andeq	r4, r0, r5, lsl #28
    177c:	04680c00 	strbteq	r0, [r8], #-3072	@ 0xfffff400
    1780:	3d070000 	stccc	0, cr0, [r7, #-0]
          bool leading_zero_ignored = false;
    1784:	0000760e 	andeq	r7, r0, lr, lsl #12
          int start_bit = LAST_NIBBLE_FIRST_BIT;
    1788:	00027500 	andeq	r7, r2, r0, lsl #10
  return true;
    178c:	02750200 	rsbseq	r0, r5, #0, 4
        return false;
    1790:	76020000 	strvc	r0, [r2], -r0
        return false;
    1794:	02000000 	andeq	r0, r0, #0
    1798:	00000275 	andeq	r0, r0, r5, ror r2
    179c:	00530500 	subseq	r0, r3, r0, lsl #10
    17a0:	050d0000 	streq	r0, [sp, #-0]
    17a4:	04000001 	streq	r0, [r0], #-1
    17a8:	00029020 	andeq	r9, r2, r0, lsr #32
int printf(const char *fmt, ...) {
    17ac:	02900200 	addseq	r0, r0, #0, 4
    17b0:	95020000 	strls	r0, [r2, #-0]
    17b4:	00000002 	andeq	r0, r0, r2
  va_start(args, fmt);
    17b8:	00015205 	andeq	r5, r1, r5, lsl #4
  while (*fmt) {
    17bc:	00d80500 	sbcseq	r0, r8, r0, lsl #10
        if (*fmt == '%') {
    17c0:	4c0d0000 	stcmi	0, cr0, [sp], {-0}
        __write_char__(*fmt);
    17c4:	04000001 	streq	r0, [r0], #-1
        fmt++;
    17c8:	0002b51f 	andeq	fp, r2, pc, lsl r5
  while (*fmt) {
    17cc:	02900200 	addseq	r0, r0, #0, 4
    switch (state) {
    17d0:	b5020000 	strlt	r0, [r2, #-0]
    17d4:	02000002 	andeq	r0, r0, #2
          fmt++;
    17d8:	0000007d 	andeq	r0, r0, sp, ror r0
          continue;
    17dc:	00e40500 	rsceq	r0, r4, r0, lsl #10
        while (*fmt && ((*fmt >= '0' && *fmt <= '9') || *fmt == '-')) {
    17e0:	1f0d0000 	svcne	0x000d0000
    17e4:	04000001 	streq	r0, [r0], #-1
    17e8:	0002cb1e 	andeq	ip, r2, lr, lsl fp
    17ec:	02900200 	addseq	r0, r0, #0, 4
    17f0:	0c000000 	stceq	0, cr0, [r0], {-0}
        switch (*fmt) {
    17f4:	00000231 	andeq	r0, r0, r1, lsr r2
    17f8:	6f056108 	svcvs	0x00056108
    17fc:	eb000000 	bl	1804 <printf+0x58>
    1800:	02000002 	andeq	r0, r0, #2
            __write_char__(*fmt);
    1804:	00000250 	andeq	r0, r0, r0, asr r2
    1808:	00025002 	andeq	r5, r2, r2
            state = CHECK_CH;
    180c:	02eb0200 	rsceq	r0, fp, #0, 4
            break;
    1810:	05000000 	streq	r0, [r0, #-0]
    1814:	00000042 	andeq	r0, r0, r2, asr #32
            outstr(va_arg(args, const char *));
    1818:	00048a0c 	andeq	r8, r4, ip, lsl #20
    181c:	055e0800 	ldrbeq	r0, [lr, #-2048]	@ 0xfffff800
    1820:	0000006f 	andeq	r0, r0, pc, rrx
            fmt++;
    1824:	0000030b 	andeq	r0, r0, fp, lsl #6
            break;
    1828:	0002eb02 	andeq	lr, r2, r2, lsl #22
            __write_char__(va_arg(args, int));
    182c:	02eb0200 	rsceq	r0, fp, #0, 4
    1830:	0c000000 	stceq	0, cr0, [r0], {-0}
    1834:	000000e7 	andeq	r0, r0, r7, ror #1
            fmt++;
    1838:	760e4a07 	strvc	r4, [lr], -r7, lsl #20
            break;
    183c:	2b000000 	blcs	1844 <printf+0x98>
            if (*fmt == 'l') {
    1840:	02000003 	andeq	r0, r0, #3
    1844:	00000275 	andeq	r0, r0, r5, ror r2
            if (printf_numbers(*fmt, &args, l_count)) {
    1848:	00007602 	andeq	r7, r0, r2, lsl #12
    184c:	02750200 	rsbseq	r0, r5, #0, 4
    1850:	0c000000 	stceq	0, cr0, [r0], {-0}
              state = CHECK_CH;
    1854:	000001dc 	ldrdeq	r0, [r0], -ip
              fmt++;
    1858:	6f052c09 	svcvs	0x00052c09
              l_count++;
    185c:	42000000 	andmi	r0, r0, #0
            if (printf_numbers(*fmt, &args, 0)) {
    1860:	02000003 	andeq	r0, r0, #3
    1864:	00000212 	andeq	r0, r0, r2, lsl r2
              fmt++;
    1868:	e31b001a 	tst	fp, #26
              break;
    186c:	01000005 	tsteq	r0, r5
            return -1;
    1870:	006f050c 	rsbeq	r0, pc, ip, lsl #10
}
    1874:	08b80000 	ldmeq	r8!, {}	@ <UNPREDICTABLE>
    1878:	010c0000 	mrseq	r0, (UNDEF: 12)
            return -1;
    187c:	9c010000 	stcls	0, cr0, [r1], {-0}
    1880:	0000060c 	andeq	r0, r0, ip, lsl #12
    1884:	0001ed10 	andeq	lr, r1, r0, lsl sp
static void outstr2(const char *str) {
    1888:	006f1300 	rsbeq	r1, pc, r0, lsl #6
  while (*str != '\0') {
    188c:	02f80000 	rscseq	r0, r8, #0
    __write_char2__(*str);
    1890:	02f40000 	rscseq	r0, r4, #0
    str++;
    1894:	5a100000 	bpl	40189c <__ROM_SIZE__+0x3c189c>
  while (*str != '\0') {
    1898:	20000001 	andcs	r0, r0, r1
}
    189c:	000001cc 	andeq	r0, r0, ip, asr #3
    18a0:	0000030b 	andeq	r0, r0, fp, lsl #6
static bool printf2_numbers(const char fmt, va_list *args, int l_count) {
    18a4:	00000307 	andeq	r0, r0, r7, lsl #6
    18a8:	0005cb09 	andeq	ip, r5, r9, lsl #22
  switch (fmt) {
    18ac:	0c0d0e00 	stceq	14, cr0, [sp], {-0}
    18b0:	02000006 	andeq	r0, r0, #6
    18b4:	ce095091 	mcrgt	0, 0, r5, cr9, cr1, {4}
      if (l_count == 0) {
    18b8:	0f000005 	svceq	0x00000005
    18bc:	00061c0d 	andeq	r1, r6, sp, lsl #24
        value = va_arg(*args, unsigned int);
    18c0:	b8910300 	ldmlt	r1, {r8, r9}
    18c4:	0584097f 	streq	r0, [r4, #2431]	@ 0x97f
      if (fmt == 'u') {
    18c8:	0d100000 	ldceq	0, cr0, [r0, #-0]
        if (value == 0) {
    18cc:	0000062c 	andeq	r0, r0, ip, lsr #12
          __write_char2__(hextable2[0]);
    18d0:	7f889103 	svcvc	0x00889103
    18d4:	0005bd09 	andeq	fp, r5, r9, lsl #26
  return true;
    18d8:	1c0d1100 	stfnes	f1, [sp], {-0}
  switch (fmt) {
    18dc:	03000006 	movweq	r0, #6
      outstr2("\nprintf2-error\n");
    18e0:	097ef091 	ldmdbeq	lr!, {r0, r4, r7, ip, sp, lr, pc}^
      return false;
    18e4:	000005d7 	ldrdeq	r0, [r0], -r7
}
    18e8:	060c0d12 			@ <UNDEFINED> instruction: 0x060c0d12
      if (l_count == 0) {
    18ec:	91030000 	mrsls	r0, (UNDEF: 3)
        value = va_arg(*args, int);
    18f0:	7c097ed0 	stcvc	14, cr7, [r9], {208}	@ 0xd0
    18f4:	13000005 	movwne	r0, #5
      if (value < 0) {
    18f8:	00063c0d 	andeq	r3, r6, sp, lsl #24
        num[num_len++] = hextable2[value % 10];
    18fc:	a0910300 	addsge	r0, r1, r0, lsl #6
    1900:	656c1c7e 	strbvs	r1, [ip, #-3198]!	@ 0xfffff382
    1904:	1401006e 	strne	r0, [r1], #-110	@ 0xffffff92
    1908:	00006f09 	andeq	r6, r0, r9, lsl #30
    190c:	00032400 	andeq	r2, r3, r0, lsl #8
    1910:	00031a00 	andeq	r1, r3, r0, lsl #20
    1914:	01f20900 	mvnseq	r0, r0, lsl #18
    1918:	10210000 	eorne	r0, r1, r0
    191c:	00000152 	andeq	r0, r0, r2, asr r1
        value = value / 10;
    1920:	7db09103 	ldfvcd	f1, [r0, #12]!
      } while (value > 0);
    1924:	0008d603 	andeq	sp, r8, r3, lsl #12
    1928:	00032b00 	andeq	r2, r3, r0, lsl #22
        __write_char2__('-');
    192c:	00041300 	andeq	r1, r4, r0, lsl #6
    1930:	50010100 	andpl	r0, r1, r0, lsl #2
        value = -value;
    1934:	2f140305 	svccs	0x00140305
        __write_char2__(num[--num_len]);
    1938:	03000000 	movweq	r0, #0
    193c:	000008e2 	andeq	r0, r0, r2, ror #17
    1940:	0000030b 	andeq	r0, r0, fp, lsl #6
    1944:	0000042d 	andeq	r0, r0, sp, lsr #8
    1948:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
      while (num_len > 0) {
    194c:	01012008 	tsteq	r1, r8
  return true;
    1950:	00740252 	rsbseq	r0, r4, r2, asr r2
          num[num_len++] = hextable2[value % 10];
    1954:	08ec0300 	stmiaeq	ip!, {r8, r9}^
    1958:	030b0000 	movweq	r0, #45056	@ 0xb000
    195c:	044e0000 	strbeq	r0, [lr], #-0
    1960:	01010000 	mrseq	r0, (UNDEF: 1)
    1964:	50910250 	addspl	r0, r1, r0, asr r2
    1968:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    196c:	01012008 	tsteq	r1, r8
    1970:	b8910352 	ldmlt	r1, {r1, r4, r6, r8, r9}
          value = value / 10;
    1974:	f603007f 			@ <UNDEFINED> instruction: 0xf603007f
        } while (value > 0);
    1978:	f0000008 			@ <UNDEFINED> instruction: 0xf0000008
        while (num_len > 0) {
    197c:	68000002 	stmdavs	r0, {r1}
          __write_char2__(num[--num_len]);
    1980:	01000004 	tsteq	r0, r4
    1984:	76025001 	strvc	r5, [r2], -r1
    1988:	51010100 	mrspl	r0, (UNDEF: 17)
    198c:	00007402 	andeq	r7, r0, r2, lsl #8
    1990:	0008fe03 	andeq	pc, r8, r3, lsl #28
    1994:	0002f000 	andeq	pc, r2, r0
  return true;
    1998:	00048400 	andeq	r8, r4, r0, lsl #8
              __write_char2__(hextable2[val]);
    199c:	50010100 	andpl	r0, r1, r0, lsl #2
    19a0:	7f889103 	svcvc	0x00889103
              leading_zero_ignored = true;
    19a4:	03510101 	cmpeq	r1, #1073741824	@ 0x40000000
          while (start_bit >= 0) {
    19a8:	007fb891 			@ <UNDEFINED> instruction: 0x007fb891
            int val = (value >> start_bit) & 0xF;
    19ac:	00090a03 	andeq	r0, r9, r3, lsl #20
            if (val || leading_zero_ignored) {
    19b0:	0002cb00 	andeq	ip, r2, r0, lsl #22
    19b4:	0004a500 	andeq	sl, r4, r0, lsl #10
    19b8:	50010100 	andpl	r0, r1, r0, lsl #2
          bool leading_zero_ignored = false;
    19bc:	01007402 	tsteq	r0, r2, lsl #8
          int start_bit = LAST_NIBBLE_FIRST_BIT;
    19c0:	91035101 	tstls	r3, r1, lsl #2
  return true;
    19c4:	01017f88 	smlabbeq	r1, r8, pc, r7	@ <UNPREDICTABLE>
        return false;
    19c8:	00750252 	rsbseq	r0, r5, r2, asr r2
        return false;
    19cc:	09140300 	ldmdbeq	r4, {r8, r9}
    19d0:	02cb0000 	sbceq	r0, fp, #0
    19d4:	04c70000 	strbeq	r0, [r7], #0
    19d8:	01010000 	mrseq	r0, (UNDEF: 1)
    19dc:	b8910350 	ldmlt	r1, {r4, r6, r8, r9}
    19e0:	5101017f 	tstpl	r1, pc, ror r1
int printf2(const char *fmt, ...) {
    19e4:	01007602 	tsteq	r0, r2, lsl #12
    19e8:	91035201 	tstls	r3, r1, lsl #4
    19ec:	03007ef0 	movweq	r7, #3824	@ 0xef0
  va_start(args, fmt);
    19f0:	0000091a 	andeq	r0, r0, sl, lsl r9
  while (*fmt) {
    19f4:	000002ba 			@ <UNDEFINED> instruction: 0x000002ba
        if (*fmt == '%') {
    19f8:	000004db 	ldrdeq	r0, [r0], -fp
        __write_char2__(*fmt);
    19fc:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
        fmt++;
    1a00:	0300007d 	movweq	r0, #125	@ 0x7d
  while (*fmt) {
    1a04:	00000924 	andeq	r0, r0, r4, lsr #18
    switch (state) {
    1a08:	0000029a 	muleq	r0, sl, r2
    1a0c:	000004fb 	strdeq	r0, [r0], -fp
          fmt++;
    1a10:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
          continue;
    1a14:	0101007d 	tsteq	r1, sp, ror r0
        while (*fmt && ((*fmt >= '0' && *fmt <= '9') || *fmt == '-')) {
    1a18:	00750251 	rsbseq	r0, r5, r1, asr r2
    1a1c:	02520101 	subseq	r0, r2, #1073741824	@ 0x40000000
    1a20:	03003008 	movweq	r3, #8
    1a24:	0000092e 	andeq	r0, r0, lr, lsr #18
    1a28:	0000027a 	andeq	r0, r0, sl, ror r2
        switch (*fmt) {
    1a2c:	00000515 	andeq	r0, r0, r5, lsl r5
    1a30:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    1a34:	0101007d 	tsteq	r1, sp, ror r0
    1a38:	00750251 	rsbseq	r0, r5, r1, asr r2
            __write_char2__(*fmt);
    1a3c:	09380300 	ldmdbeq	r8!, {r8, r9}
    1a40:	02550000 	subseq	r0, r5, #0
            state = CHECK_CH;
    1a44:	05360000 	ldreq	r0, [r6, #-0]!
            break;
    1a48:	01010000 	mrseq	r0, (UNDEF: 1)
    1a4c:	00750250 	rsbseq	r0, r5, r0, asr r2
            outstr2(va_arg(args, const char *));
    1a50:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    1a54:	01012008 	tsteq	r1, r8
    1a58:	a0910352 	addsge	r0, r1, r2, asr r3
            fmt++;
    1a5c:	4e03007e 	mcrmi	0, 0, r0, cr3, cr14, {3}
            break;
    1a60:	2b000009 	blcs	1a8c <printf2+0xa8>
            __write_char2__(va_arg(args, int));
    1a64:	54000003 	strpl	r0, [r0], #-3
    1a68:	01000005 	tsteq	r0, r5
    1a6c:	03055001 	movweq	r5, #20481	@ 0x5001
            fmt++;
    1a70:	00002f34 	andeq	r2, r0, r4, lsr pc
            break;
    1a74:	03510101 	cmpeq	r1, #1073741824	@ 0x40000000
            if (*fmt == 'l') {
    1a78:	007ea091 			@ <UNDEFINED> instruction: 0x007ea091
    1a7c:	00095403 	andeq	r5, r9, r3, lsl #8
            if (printf2_numbers(*fmt, &args, l_count)) {
    1a80:	0002ba00 	andeq	fp, r2, r0, lsl #20
    1a84:	00056800 	andeq	r6, r5, r0, lsl #16
    1a88:	50010100 	andpl	r0, r1, r0, lsl #2
              state = CHECK_CH;
    1a8c:	00007d02 	andeq	r7, r0, r2, lsl #26
              fmt++;
    1a90:	00095e03 	andeq	r5, r9, r3, lsl #28
              l_count++;
    1a94:	00029a00 	andeq	r9, r2, r0, lsl #20
            if (printf2_numbers(*fmt, &args, 0)) {
    1a98:	00058900 	andeq	r8, r5, r0, lsl #18
    1a9c:	50010100 	andpl	r0, r1, r0, lsl #2
              fmt++;
    1aa0:	01007d02 	tsteq	r0, r2, lsl #26
              break;
    1aa4:	91035101 	tstls	r3, r1, lsl #2
            return -1;
    1aa8:	01017ef0 	strdeq	r7, [r1, -r0]
}
    1aac:	30080252 	andcc	r0, r8, r2, asr r2
    1ab0:	09660300 	stmdbeq	r6!, {r8, r9}^
            return -1;
    1ab4:	027a0000 	rsbseq	r0, sl, #0
    1ab8:	05a40000 	streq	r0, [r4, #0]!
    1abc:	01010000 	mrseq	r0, (UNDEF: 1)
int r32(int argc, char *argv[]) {
    1ac0:	007d0250 	rsbseq	r0, sp, r0, asr r2
  if (argc < 2) {
    1ac4:	03510101 	cmpeq	r1, #1073741824	@ 0x40000000
  uint32_t addr = atoh(argv[1]);
    1ac8:	007ed091 			@ <UNDEFINED> instruction: 0x007ed091
    1acc:	00097003 	andeq	r7, r9, r3
  printf("0x%x: 0x%x\n", addr, data);
    1ad0:	00025500 	andeq	r5, r2, r0, lsl #10
    1ad4:	0005c600 	andeq	ip, r5, r0, lsl #12
}
    1ad8:	50010100 	andpl	r0, r1, r0, lsl #2
    printf("Usage: %s <address> (in hex)\n", argv[0]);
    1adc:	7ed09103 	atnvcs	f1, f3
    1ae0:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    return -1;
    1ae4:	01012008 	tsteq	r1, r8
    1ae8:	a0910352 	addsge	r0, r1, r2, asr r3
    1aec:	8403007e 	strhi	r0, [r3], #-126	@ 0xffffff82
int w32(int argc, char *argv[]) {
    1af0:	2b000009 	blcs	1b1c <w32+0x2c>
  if (argc < 3) {
    1af4:	e4000003 	str	r0, [r0], #-3
  uint32_t addr = atoh(argv[1]);
    1af8:	01000005 	tsteq	r0, r5
    1afc:	03055001 	movweq	r5, #20481	@ 0x5001
  uint32_t data = atoh(argv[2]);
    1b00:	00002f4c 	andeq	r2, r0, ip, asr #30
    1b04:	03510101 	cmpeq	r1, #1073741824	@ 0x40000000
  return 0;
    1b08:	007ea091 			@ <UNDEFINED> instruction: 0x007ea091
    printf("Usage: %s <address> (in hex) <value> (in hex)\n", argv[0]);
    1b0c:	00098a03 	andeq	r8, r9, r3, lsl #20
    1b10:	00032b00 	andeq	r2, r3, r0, lsl #22
    return -1;
    1b14:	0005fb00 	andeq	pc, r5, r0, lsl #22
    1b18:	50010100 	andpl	r0, r1, r0, lsl #2
    1b1c:	2f640305 	svccs	0x00640305
int read_mem(int argc, char *argv[]) {
    1b20:	1d000000 	stcne	0, cr0, [r0, #-0]
  if (argc < 3) {
    1b24:	00000992 	muleq	r0, r2, r9
  uint32_t addr = atoh(argv[1]);
    1b28:	00000235 	andeq	r0, r0, r5, lsr r2
    1b2c:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
  uint32_t length = atoi(argv[2]);
    1b30:	00000075 	andeq	r0, r0, r5, ror r0
    1b34:	00004207 	andeq	r4, r0, r7, lsl #4
  for (uint32_t i = 0, data = 0; i < length; i++) {
    1b38:	00061c00 	andeq	r1, r6, r0, lsl #24
    printf("Usage: %s <address> (in hex) <num_words> (in decimal)\n", argv[0]);
    1b3c:	00760800 	rsbseq	r0, r6, r0, lsl #16
    1b40:	001f0000 	andseq	r0, pc, r0
    return -1;
    1b44:	00004207 	andeq	r4, r0, r7, lsl #4
    1b48:	00062c00 	andeq	r2, r6, r0, lsl #24
    printf("0x%x: 0x%x\n", addr, data);
    1b4c:	00760800 	rsbseq	r0, r6, r0, lsl #16
    1b50:	00170000 	andseq	r0, r7, r0
    addr += 4;
    1b54:	00004207 	andeq	r4, r0, r7, lsl #4
  for (uint32_t i = 0, data = 0; i < length; i++) {
    1b58:	00063c00 	andeq	r3, r6, r0, lsl #24
  return 0;
    1b5c:	00760800 	rsbseq	r0, r6, r0, lsl #16
}
    1b60:	002f0000 	eoreq	r0, pc, r0
    1b64:	0000421e 	andeq	r4, r0, lr, lsl r2
{
    1b68:	00760800 	rsbseq	r0, r6, r0, lsl #16
  if (argc < 4) {
    1b6c:	002c0000 	eoreq	r0, ip, r0
  uint32_t addr = atoh(argv[1]);
    1b70:	00018b00 	andeq	r8, r1, r0, lsl #22
    1b74:	01000500 	tsteq	r0, r0, lsl #10
  uint32_t bit_loc = atoi(argv[2]);
    1b78:	000a6e04 	andeq	r6, sl, r4, lsl #28
    1b7c:	00460900 	subeq	r0, r6, r0, lsl #18
  uint32_t bit_val = atoi(argv[3]);
    1b80:	fb1d0000 	blx	741b8a <__ROM_SIZE__+0x701b8a>
    1b84:	14000005 	strne	r0, [r0], #-5
  if (bit_loc > 31) {
    1b88:	c4000000 	strgt	r0, [r0], #-0
  if (bit_val != 0 && bit_val != 1) {
    1b8c:	1c000009 	stcne	0, cr0, [r0], {9}
  data = data | (bit_val << bit_loc);
    1b90:	62000000 	andvs	r0, r0, #0
    1b94:	0100000f 	tsteq	r0, pc
  data = data & ~(!bit_val << bit_loc);
    1b98:	012d0601 			@ <UNDEFINED> instruction: 0x012d0601
    1b9c:	02010000 	andeq	r0, r1, #0
    1ba0:	0001e305 	andeq	lr, r1, r5, lsl #6
  return 0;
    1ba4:	05040100 	streq	r0, [r4, #-256]	@ 0xffffff00
    printf("Error: Invalid bit location argument\n");
    1ba8:	000001c7 	andeq	r0, r0, r7, asr #3
    1bac:	c2050801 	andgt	r0, r5, #65536	@ 0x10000
    printf("Error: Invalid bit value argument\n");
    1bb0:	01000001 	tsteq	r0, r1
    1bb4:	012b0801 			@ <UNDEFINED> instruction: 0x012b0801
  printf("Usage: %s <address_in_hex(32-bits)> <bit_location_in_decimal(0 to 31)> <bit_value(0 or 1)>\n", argv[0]);
    1bb8:	02010000 	andeq	r0, r1, #0
    1bbc:	00013907 	andeq	r3, r1, r7, lsl #18
  return -1;
    1bc0:	07040100 	streq	r0, [r4, -r0, lsl #2]
    1bc4:	00000176 	andeq	r0, r0, r6, ror r1
    1bc8:	71070801 	tstvc	r7, r1, lsl #16
    1bcc:	0a000001 	beq	1bd8 <r32_bit+0x8>
{
    1bd0:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
  if (argc < 3) {
    1bd4:	04010074 	streq	r0, [r1], #-116	@ 0xffffff8c
  uint32_t addr = atoh(argv[1]);
    1bd8:	00017b07 	andeq	r7, r1, r7, lsl #22
    1bdc:	04080100 	streq	r0, [r8], #-256	@ 0xffffff00
  uint32_t bit_loc = atoi(argv[2]);
    1be0:	00000225 	andeq	r0, r0, r5, lsr #4
    1be4:	646d630b 	strbtvs	r6, [sp], #-779	@ 0xfffffcf5
  if (bit_loc > 31) {
    1be8:	0f3b0200 	svceq	0x003b0200
  uint32_t data = reg32(addr);
    1bec:	0000007f 	andeq	r0, r0, pc, ror r0
  printf("Bit %u @ 0x%08x: %u\n", bit_loc, addr, bit_val);
    1bf0:	00008402 	andeq	r8, r0, r2, lsl #8
    1bf4:	005e0c00 	subseq	r0, lr, r0, lsl #24
    1bf8:	00980000 	addseq	r0, r8, r0
  return 0;
    1bfc:	5e030000 	cdppl	0, 0, cr0, cr3, cr0, {0}
    printf("Error: Invalid bit location argument\n");
    1c00:	03000000 	movweq	r0, #0
    1c04:	00000098 	muleq	r0, r8, r0
  printf("Usage: %s <address_in_hex(32-bits)> <bit_location_in_decimal(0 to 31)\n", argv[0]);
    1c08:	009d0200 	addseq	r0, sp, r0, lsl #4
    1c0c:	a2020000 	andge	r0, r2, #0
  return -1;
    1c10:	01000000 	mrseq	r0, (UNDEF: 0)
    1c14:	01340801 	teqeq	r4, r1, lsl #16
    1c18:	a20d0000 	andge	r0, sp, #0
    1c1c:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
{
    1c20:	0944020c 	stmdbeq	r4, {r2, r3, r9}^
  for (i = 0; i < Nk; ++i)
    1c24:	000000dc 	ldrdeq	r0, [r0], -ip
    RoundKey[(i * 4) + 0] = Key[(i * 4) + 0];
    1c28:	00025d04 	andeq	r5, r2, r4, lsl #26
    1c2c:	dc0f4500 	cfstr32le	mvfx4, [pc], {-0}
    1c30:	00000000 	andeq	r0, r0, r0
    RoundKey[(i * 4) + 1] = Key[(i * 4) + 1];
    1c34:	00000004 	andeq	r0, r0, r4
    RoundKey[(i * 4) + 2] = Key[(i * 4) + 2];
    1c38:	dc0f4600 	stcle	6, cr4, [pc], {-0}
    1c3c:	04000000 	streq	r0, [r0], #-0
    RoundKey[(i * 4) + 3] = Key[(i * 4) + 3];
    1c40:	0000da04 	andeq	sp, r0, r4, lsl #20
  for (i = 0; i < Nk; ++i)
    1c44:	73074700 	movwvc	r4, #30464	@ 0x7700
    1c48:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
  for (i = Nk; i < Nb * (Nr + 1); ++i)
    1c4c:	00a90200 	adceq	r0, r9, r0, lsl #4
    if (i % Nk == 4)
    1c50:	bc0f0000 	stclt	0, cr0, [pc], {-0}
    j = i * 4; k=(i - Nk) * 4;
    1c54:	02000001 	andeq	r0, r0, #1
    RoundKey[j + 0] = RoundKey[k + 0] ^ tempa[0];
    1c58:	00ae0348 	adceq	r0, lr, r8, asr #6
    1c5c:	ed100000 	ldc	0, cr0, [r0, #-0]
    1c60:	01000005 	tsteq	r0, r5
    1c64:	00e1010c 	rsceq	r0, r1, ip, lsl #2
    RoundKey[j + 1] = RoundKey[k + 1] ^ tempa[1];
    1c68:	03050000 	movweq	r0, #20480	@ 0x5000
    1c6c:	000029c8 	andeq	r2, r0, r8, asr #19
    1c70:	00045805 	andeq	r5, r4, r5, lsl #16
    1c74:	005e2d00 	subseq	r2, lr, r0, lsl #26
    1c78:	01140000 	tsteq	r4, r0
    1c7c:	dc030000 	stcle	0, cr0, [r3], {-0}
    RoundKey[j + 2] = RoundKey[k + 2] ^ tempa[2];
    1c80:	06000000 	streq	r0, [r0], -r0
    1c84:	01dc0500 	bicseq	r0, ip, r0, lsl #10
    1c88:	5e2c0000 	cdppl	0, 2, cr0, cr12, cr0, {0}
    1c8c:	29000000 	stmdbcs	r0, {}	@ <UNPREDICTABLE>
    RoundKey[j + 3] = RoundKey[k + 3] ^ tempa[3];
    1c90:	03000001 	movweq	r0, #1
    1c94:	000000dc 	ldrdeq	r0, [r0], -ip
    1c98:	f1110006 			@ <UNDEFINED> instruction: 0xf1110006
  for (i = Nk; i < Nb * (Nr + 1); ++i)
    1c9c:	01000005 	tsteq	r0, r5
    1ca0:	005e0505 	subseq	r0, lr, r5, lsl #10
      tempa[0]=RoundKey[k + 0];
    1ca4:	09c40000 	stmibeq	r4, {}^	@ <UNPREDICTABLE>
    1ca8:	001c0000 	andseq	r0, ip, r0
      tempa[1]=RoundKey[k + 1];
    1cac:	9c010000 	stcls	0, cr0, [r1], {-0}
    1cb0:	0001ed07 	andeq	lr, r1, r7, lsl #26
    1cb4:	005e1300 	subseq	r1, lr, r0, lsl #6
      tempa[2]=RoundKey[k + 2];
    1cb8:	035e0000 	cmpeq	lr, #0
    1cbc:	035a0000 	cmpeq	sl, #0
      tempa[3]=RoundKey[k + 3];
    1cc0:	5a070000 	bpl	1c1cc8 <__ROM_SIZE__+0x181cc8>
    1cc4:	20000001 	andcs	r0, r0, r1
    if (i % Nk == 0)
    1cc8:	00000098 	muleq	r0, r8, r0
        tempa[0] = tempa[1];
    1ccc:	00000370 	andeq	r0, r0, r0, ror r3
        tempa[1] = tempa[2];
    1cd0:	0000036c 	andeq	r0, r0, ip, ror #6
        tempa[2] = tempa[3];
    1cd4:	0009cc12 	andeq	ip, r9, r2, lsl ip
        tempa[3] = u8tmp;
    1cd8:	00011400 	andeq	r1, r1, r0, lsl #8
        tempa[0] = getSBoxValue(tempa[0]);
    1cdc:	00017a00 	andeq	r7, r1, r0, lsl #20
    1ce0:	50010800 	andpl	r0, r1, r0, lsl #16
        tempa[1] = getSBoxValue(tempa[1]);
    1ce4:	2fe40305 	svccs	0x00e40305
    1ce8:	13000000 	movwne	r0, #0
        tempa[2] = getSBoxValue(tempa[2]);
    1cec:	000009d2 	ldrdeq	r0, [r0], -r2
    1cf0:	000000ff 	strdeq	r0, [r0], -pc	@ <UNPREDICTABLE>
        tempa[3] = getSBoxValue(tempa[3]);
    1cf4:	05500108 	ldrbeq	r0, [r0, #-264]	@ 0xfffffef8
    1cf8:	002ff803 	eoreq	pc, pc, r3, lsl #16
      tempa[0] = tempa[0] ^ Rcon[i/Nk];
    1cfc:	00000000 	andeq	r0, r0, r0
    1d00:	00000406 	andeq	r0, r0, r6, lsl #8
    1d04:	04010005 	streq	r0, [r1], #-5
    1d08:	00000b79 	andeq	r0, r0, r9, ror fp
        tempa[0] = getSBoxValue(tempa[0]);
    1d0c:	00004610 	andeq	r4, r0, r0, lsl r6
    1d10:	06271d00 	strteq	r1, [r7], -r0, lsl #26
    1d14:	00140000 	andseq	r0, r4, r0
        tempa[1] = getSBoxValue(tempa[1]);
    1d18:	09e00000 	stmibeq	r0!, {}^	@ <UNPREDICTABLE>
    1d1c:	00a40000 	adceq	r0, r4, r0
        tempa[2] = getSBoxValue(tempa[2]);
    1d20:	10380000 	eorsne	r0, r8, r0
    1d24:	01030000 	mrseq	r0, (UNDEF: 3)
    1d28:	00012d06 	andeq	r2, r1, r6, lsl #26
        tempa[3] = getSBoxValue(tempa[3]);
    1d2c:	05020300 	streq	r0, [r2, #-768]	@ 0xfffffd00
    1d30:	000001e3 	andeq	r0, r0, r3, ror #3
    1d34:	c7050403 	strgt	r0, [r5, -r3, lsl #8]
}
    1d38:	03000001 	movweq	r0, #1
    1d3c:	01c20508 	biceq	r0, r2, r8, lsl #10
{
    1d40:	88070000 	stmdahi	r7, {}	@ <UNPREDICTABLE>
  for (i = 0; i < 4; ++i)
    1d44:	02000001 	andeq	r0, r0, #1
      (*state)[i][j] ^= RoundKey[(round * Nb * 4) + (i * Nb) + j];
    1d48:	004e182e 	subeq	r1, lr, lr, lsr #16
    1d4c:	01030000 	mrseq	r0, (UNDEF: 3)
    1d50:	00012b08 	andeq	r2, r1, r8, lsl #22
    1d54:	07020300 	streq	r0, [r2, -r0, lsl #6]
    1d58:	00000139 	andeq	r0, r0, r9, lsr r1
    1d5c:	76070403 	strvc	r0, [r7], -r3, lsl #8
    1d60:	03000001 	movweq	r0, #1
    for (j = 0; j < 4; ++j)
    1d64:	01710708 	cmneq	r1, r8, lsl #14
    1d68:	04110000 	ldreq	r0, [r1], #-0
  for (i = 0; i < 4; ++i)
    1d6c:	746e6905 	strbtvc	r6, [lr], #-2309	@ 0xfffff6fb
    1d70:	07040300 	streq	r0, [r4, -r0, lsl #6]
    for (j = 0; j < 4; ++j)
    1d74:	0000017b 	andeq	r0, r0, fp, ror r1
  for (i = 0; i < 4; ++i)
    1d78:	00000d07 	andeq	r0, r0, r7, lsl #26
    1d7c:	17d60300 	ldrbne	r0, [r6, r0, lsl #6]
    for (j = 0; j < 4; ++j)
    1d80:	00000071 	andeq	r0, r0, r1, ror r0
{
    1d84:	25040803 	strcs	r0, [r4, #-2051]	@ 0xfffff7fd
      (*state)[j][i] = getSBoxValue((*state)[j][i]);
    1d88:	07000002 	streq	r0, [r0, -r2]
    1d8c:	000000e2 	andeq	r0, r0, r2, ror #1
    1d90:	4e171304 	cdpmi	3, 1, cr1, cr7, cr4, {0}
    1d94:	0d000000 	stceq	0, cr0, [r0, #-0]
    for (j = 0; j < 4; ++j)
    1d98:	0000008b 	andeq	r0, r0, fp, lsl #1
    1d9c:	0000c907 	andeq	ip, r0, r7, lsl #18
  for (i = 0; i < 4; ++i)
    1da0:	17140400 	ldrne	r0, [r4, -r0, lsl #8]
    1da4:	00000071 	andeq	r0, r0, r1, ror r0
    for (j = 0; j < 4; ++j)
    1da8:	1604700e 	strne	r7, [r4], -lr
}
    1dac:	000000e5 	andeq	r0, r0, r5, ror #1
  for (i = 0; i < 4; ++i)
    1db0:	00079006 	andeq	r9, r7, r6
    1db4:	07170400 	ldreq	r0, [r7, -r0, lsl #8]
    1db8:	000000e5 	andeq	r0, r0, r5, ror #1
  temp           = (*state)[0][1];
    1dbc:	00c10600 	sbceq	r0, r1, r0, lsl #12
  (*state)[0][1] = (*state)[1][1];
    1dc0:	18040000 	stmdane	r4, {}	@ <UNPREDICTABLE>
  (*state)[1][1] = (*state)[2][1];
    1dc4:	00009c07 	andeq	r9, r0, r7, lsl #24
  (*state)[2][1] = (*state)[3][1];
    1dc8:	5f064000 	svcpl	0x00064000
  temp           = (*state)[0][2];
    1dcc:	04000001 	streq	r0, [r0], #-1
  (*state)[0][2] = (*state)[2][2];
    1dd0:	00631519 	rsbeq	r1, r3, r9, lsl r5
  temp           = (*state)[1][2];
    1dd4:	06480000 	strbeq	r0, [r8], -r0
  (*state)[1][2] = (*state)[3][2];
    1dd8:	00000b2e 	andeq	r0, r0, lr, lsr #22
  temp           = (*state)[0][3];
    1ddc:	f5071a04 			@ <UNDEFINED> instruction: 0xf5071a04
  (*state)[0][3] = (*state)[3][3];
    1de0:	50000000 	andpl	r0, r0, r0
  (*state)[3][3] = (*state)[2][3];
    1de4:	008b0a00 	addeq	r0, fp, r0, lsl #20
  (*state)[2][3] = (*state)[1][3];
    1de8:	00f50000 	rscseq	r0, r5, r0
}
    1dec:	71080000 	mrsvc	r0, (UNDEF: 8)
  return ((x<<1) ^ (((x>>7) & 1) * 0x1b));
    1df0:	3f000000 	svccc	0x00000000
    1df4:	009c0a00 	addseq	r0, ip, r0, lsl #20
    1df8:	01050000 	mrseq	r0, (UNDEF: 5)
}
    1dfc:	71080000 	mrsvc	r0, (UNDEF: 8)
{
    1e00:	07000000 	streq	r0, [r0, -r0]
    1e04:	01660700 	cmneq	r6, r0, lsl #14
  for (i = 0; i < 4; ++i)
    1e08:	1b040000 	blne	101e10 <__ROM_SIZE__+0xc1e10>
    t   = (*state)[i][0];
    1e0c:	0000a803 	andeq	sl, r0, r3, lsl #16
    Tmp = (*state)[i][0] ^ (*state)[i][1] ^ (*state)[i][2] ^ (*state)[i][3] ;
    1e10:	6d631200 	sfmvs	f1, 2, [r3, #-0]
    1e14:	3b050064 	blcc	141fac <__ROM_SIZE__+0x101fac>
    1e18:	00011d0f 	andeq	r1, r1, pc, lsl #26
    1e1c:	01220400 			@ <UNDEFINED> instruction: 0x01220400
    1e20:	6a130000 	bvs	4c1e28 <__ROM_SIZE__+0x481e28>
    1e24:	36000000 	strcc	r0, [r0], -r0
    Tm  = (*state)[i][0] ^ (*state)[i][1] ; Tm = xtime(Tm);  (*state)[i][0] ^= Tm ^ Tmp ;
    1e28:	02000001 	andeq	r0, r0, #1
    1e2c:	0000006a 	andeq	r0, r0, sl, rrx
    1e30:	00013602 	andeq	r3, r1, r2, lsl #12
    Tm  = (*state)[i][1] ^ (*state)[i][2] ; Tm = xtime(Tm);  (*state)[i][1] ^= Tm ^ Tmp ;
    1e34:	3b040000 	blcc	101e3c <__ROM_SIZE__+0xc1e3c>
    1e38:	04000001 	streq	r0, [r0], #-1
    1e3c:	00000140 	andeq	r0, r0, r0, asr #2
    1e40:	34080103 	strcc	r0, [r8], #-259	@ 0xfffffefd
    1e44:	0d000001 	stceq	0, cr0, [r0, #-4]
    Tm  = (*state)[i][2] ^ (*state)[i][3] ; Tm = xtime(Tm);  (*state)[i][2] ^= Tm ^ Tmp ;
    1e48:	00000140 	andeq	r0, r0, r0, asr #2
    1e4c:	44050c0e 	strmi	r0, [r5], #-3086	@ 0xfffff3f2
    1e50:	0000017c 	andeq	r0, r0, ip, ror r1
    1e54:	00025d06 	andeq	r5, r2, r6, lsl #26
    Tm  = (*state)[i][3] ^ t ;              Tm = xtime(Tm);  (*state)[i][3] ^= Tm ^ Tmp ;
    1e58:	0f450500 	svceq	0x00450500
    1e5c:	0000017c 	andeq	r0, r0, ip, ror r1
    1e60:	00000600 	andeq	r0, r0, r0, lsl #12
    1e64:	46050000 	strmi	r0, [r5], -r0
    1e68:	00017c0f 	andeq	r7, r1, pc, lsl #24
  for (i = 0; i < 4; ++i)
    1e6c:	da060400 	ble	182e74 <__ROM_SIZE__+0x142e74>
    1e70:	05000000 	streq	r0, [r0, #-0]
}
    1e74:	01110747 	tsteq	r1, r7, asr #14
{
    1e78:	00080000 	andeq	r0, r8, r0
    1e7c:	00014704 	andeq	r4, r1, r4, lsl #14
  for (i = 0; i < 4; ++i)
    1e80:	01bc0700 			@ <UNDEFINED> instruction: 0x01bc0700
    a = (*state)[i][0];
    1e84:	48050000 	stmdami	r5, {}	@ <UNPREDICTABLE>
    b = (*state)[i][1];
    1e88:	00014c03 	andeq	r4, r1, r3, lsl #24
    1e8c:	06721400 	ldrbteq	r1, [r2], -r0, lsl #8
    c = (*state)[i][2];
    1e90:	22010000 	andcs	r0, r1, #0
    d = (*state)[i][3];
    1e94:	00018101 	andeq	r8, r1, r1, lsl #2
    (*state)[i][0] = Multiply(a, 0x0e) ^ Multiply(b, 0x0b) ^ Multiply(c, 0x0d) ^ Multiply(d, 0x09);
    1e98:	d4030500 	strle	r0, [r3], #-1280	@ 0xfffffb00
    1e9c:	0b000029 	bleq	1f48 <InvMixColumns+0xd2>
    1ea0:	00000468 	andeq	r0, r0, r8, ror #8
    1ea4:	710e3d06 	tstvc	lr, r6, lsl #26
    1ea8:	bf000000 	svclt	0x00000000
    1eac:	02000001 	andeq	r0, r0, #1
    1eb0:	000001bf 			@ <UNDEFINED> instruction: 0x000001bf
    1eb4:	00007102 	andeq	r7, r0, r2, lsl #2
    1eb8:	01bf0200 			@ <UNDEFINED> instruction: 0x01bf0200
    1ebc:	04000000 	streq	r0, [r0], #-0
    1ec0:	0000004e 	andeq	r0, r0, lr, asr #32
    1ec4:	0001050c 	andeq	r0, r1, ip, lsl #10
    1ec8:	01d92000 	bicseq	r2, r9, r0
    1ecc:	d9020000 	stmdble	r2, {}	@ <UNPREDICTABLE>
    1ed0:	02000001 	andeq	r0, r0, #1
    1ed4:	000001de 	ldrdeq	r0, [r0], -lr
    1ed8:	01050400 	tsteq	r5, r0, lsl #8
    1edc:	8b040000 	blhi	101ee4 <__ROM_SIZE__+0xc1ee4>
    1ee0:	0c000000 	stceq	0, cr0, [r0], {-0}
    1ee4:	0000014c 	andeq	r0, r0, ip, asr #2
    1ee8:	0001fd1f 	andeq	pc, r1, pc, lsl sp	@ <UNPREDICTABLE>
    1eec:	01d90200 	bicseq	r0, r9, r0, lsl #4
    1ef0:	fd020000 	stc2	0, cr0, [r2, #-0]
    1ef4:	02000001 	andeq	r0, r0, #1
    1ef8:	00000078 	andeq	r0, r0, r8, ror r0
    1efc:	00970400 	addseq	r0, r7, r0, lsl #8
    1f00:	4e0b0000 	cdpmi	0, 0, cr0, cr11, cr0, {0}
    1f04:	07000002 	streq	r0, [r0, -r2]
    1f08:	0078081f 	rsbseq	r0, r8, pc, lsl r8
    1f0c:	02180000 	andseq	r0, r8, #0
    1f10:	7c020000 	stcvc	0, cr0, [r2], {-0}
    1f14:	00000001 	andeq	r0, r0, r1
    1f18:	00011f0c 	andeq	r1, r1, ip, lsl #30
    1f1c:	02281e00 	eoreq	r1, r8, #0, 28
    1f20:	d9020000 	stmdble	r2, {}	@ <UNPREDICTABLE>
    1f24:	00000001 	andeq	r0, r0, r1
    (*state)[i][1] = Multiply(a, 0x09) ^ Multiply(b, 0x0e) ^ Multiply(c, 0x0b) ^ Multiply(d, 0x0d);
    1f28:	0001dc0b 	andeq	sp, r1, fp, lsl #24
    1f2c:	052c0800 	streq	r0, [ip, #-2048]!	@ 0xfffff800
    1f30:	0000006a 	andeq	r0, r0, sl, rrx
    1f34:	0000023f 	andeq	r0, r0, pc, lsr r2
    1f38:	00017c02 	andeq	r7, r1, r2, lsl #24
    1f3c:	16001500 	strne	r1, [r0], -r0, lsl #10
    1f40:	00000676 	andeq	r0, r0, r6, ror r6
    1f44:	6a050401 	bvs	142f50 <__ROM_SIZE__+0x102f50>
    1f48:	e0000000 	and	r0, r0, r0
    1f4c:	a4000009 	strge	r0, [r0], #-9
    1f50:	01000000 	mrseq	r0, (UNDEF: 0)
    1f54:	0003dd9c 	muleq	r3, ip, sp
    1f58:	01ed0f00 	mvneq	r0, r0, lsl #30
    1f5c:	6a150000 	bvs	541f64 <__ROM_SIZE__+0x501f64>
    (*state)[i][2] = Multiply(a, 0x0d) ^ Multiply(b, 0x09) ^ Multiply(c, 0x0e) ^ Multiply(d, 0x0b);
    1f60:	8e000000 	cdphi	0, 0, cr0, cr0, cr0, {0}
    1f64:	8a000003 	bhi	1f78 <InvMixColumns+0x102>
    1f68:	0f000003 	svceq	0x00000003
    1f6c:	0000015a 	andeq	r0, r0, sl, asr r1
    1f70:	00013622 	andeq	r3, r1, r2, lsr #12
    1f74:	0003a100 	andeq	sl, r3, r0, lsl #2
    1f78:	00039d00 	andeq	r9, r3, r0, lsl #26
    1f7c:	01f20900 	mvnseq	r0, r0, lsl #18
    1f80:	10070000 	andne	r0, r7, r0
    1f84:	00000105 	andeq	r0, r0, r5, lsl #2
    1f88:	7f809103 	svcvc	0x00809103
    1f8c:	00066c09 	andeq	r6, r6, r9, lsl #24
    (*state)[i][3] = Multiply(a, 0x0b) ^ Multiply(b, 0x0d) ^ Multiply(c, 0x09) ^ Multiply(d, 0x0e);
    1f90:	dd0a0800 	stcle	8, cr0, [sl, #-0]
    1f94:	03000003 	movweq	r0, #3
    1f98:	097ec491 	ldmdbeq	lr!, {r0, r4, r7, sl, lr, pc}^
    1f9c:	00000666 	andeq	r0, r0, r6, ror #12
    1fa0:	03ed0a09 	mvneq	r0, #36864	@ 0x9000
    1fa4:	91030000 	mrsls	r0, (UNDEF: 3)
    1fa8:	62177ea4 	andsvs	r7, r7, #164, 28	@ 0xa40
    1fac:	01006675 	tsteq	r0, r5, ror r6
    1fb0:	03ed0a0b 	mvneq	r0, #45056	@ 0xb000
    1fb4:	91030000 	mrsls	r0, (UNDEF: 3)
    1fb8:	62097e84 	andvs	r7, r9, #132, 28	@ 0x840
    1fbc:	0d000006 	stceq	0, cr0, [r0, #-24]	@ 0xffffffe8
    1fc0:	0003fd0d 	andeq	pc, r3, sp, lsl #26
  for (i = 0; i < 4; ++i)
    1fc4:	d4910300 	ldrle	r0, [r1], #768	@ 0x300
    1fc8:	065a097d 			@ <UNDEFINED> instruction: 0x065a097d
}
    1fcc:	0d0e0000 	stceq	0, cr0, [lr, #-0]
  for (i = 0; i < 4; ++i)
    1fd0:	000003fd 	strdeq	r0, [r0], -sp
    1fd4:	7da49103 	stfvcd	f1, [r4, #12]!
    for (j = 0; j < 4; ++j)
    1fd8:	6e656c18 	mcrvs	12, 3, r6, cr5, cr8, {0}
{
    1fdc:	090f0100 	stmdbeq	pc, {r8}	@ <UNPREDICTABLE>
      (*state)[j][i] = getSBoxInvert((*state)[j][i]);
    1fe0:	0000006a 	andeq	r0, r0, sl, rrx
    1fe4:	000003b4 			@ <UNDEFINED> instruction: 0x000003b4
    1fe8:	000003b0 			@ <UNDEFINED> instruction: 0x000003b0
    1fec:	0009ea05 	andeq	lr, r9, r5, lsl #20
    1ff0:	00022800 	andeq	r2, r2, r0, lsl #16
    for (j = 0; j < 4; ++j)
    1ff4:	00030300 	andeq	r0, r3, r0, lsl #6
    1ff8:	50010100 	andpl	r0, r1, r0, lsl #2
  for (i = 0; i < 4; ++i)
    1ffc:	30280305 	eorcc	r0, r8, r5, lsl #6
    2000:	05000000 	streq	r0, [r0, #-0]
    for (j = 0; j < 4; ++j)
    2004:	00000a24 	andeq	r0, r0, r4, lsr #20
}
    2008:	00000218 	andeq	r0, r0, r8, lsl r2
  for (i = 0; i < 4; ++i)
    200c:	00000318 	andeq	r0, r0, r8, lsl r3
    2010:	03500101 	cmpeq	r0, #1073741824	@ 0x40000000
    2014:	007f8091 			@ <UNDEFINED> instruction: 0x007f8091
  temp = (*state)[3][1];
    2018:	000a2a05 	andeq	r2, sl, r5, lsl #20
  (*state)[3][1] = (*state)[2][1];
    201c:	00020200 	andeq	r0, r2, r0, lsl #4
  (*state)[2][1] = (*state)[1][1];
    2020:	00032d00 	andeq	r2, r3, r0, lsl #26
  (*state)[1][1] = (*state)[0][1];
    2024:	50010100 	andpl	r0, r1, r0, lsl #2
  temp = (*state)[0][2];
    2028:	7ec49103 	acsvcs	f1, f3
  (*state)[0][2] = (*state)[2][2];
    202c:	0a340500 	beq	d03434 <__ROM_SIZE__+0xcc3434>
  temp = (*state)[1][2];
    2030:	01e30000 	mvneq	r0, r0
  (*state)[1][2] = (*state)[3][2];
    2034:	03490000 	movteq	r0, #36864	@ 0x9000
  temp = (*state)[0][3];
    2038:	01010000 	mrseq	r0, (UNDEF: 1)
  (*state)[0][3] = (*state)[1][3];
    203c:	80910350 	addshi	r0, r1, r0, asr r3
  (*state)[1][3] = (*state)[2][3];
    2040:	5101017f 	tstpl	r1, pc, ror r1
  (*state)[2][3] = (*state)[3][3];
    2044:	7ec49103 	acsvcs	f1, f3
}
    2048:	0a3c0500 	beq	f03450 <__ROM_SIZE__+0xec3450>
{
    204c:	01c40000 	biceq	r0, r4, r0
  AddRoundKey(0, state, RoundKey);
    2050:	03650000 	cmneq	r5, #0
    2054:	01010000 	mrseq	r0, (UNDEF: 1)
    2058:	80910350 	addshi	r0, r1, r0, asr r3
  for (round = 1; ; ++round)
    205c:	5101017f 	tstpl	r1, pc, ror r1
    MixColumns(state);
    2060:	7e849103 	sinvcs	f1, f3
    AddRoundKey(round, state, RoundKey);
    2064:	0a480500 	beq	120346c <__ROM_SIZE__+0x11c346c>
    2068:	019f0000 	orrseq	r0, pc, r0
    206c:	03850000 	orreq	r0, r5, #0
  for (round = 1; ; ++round)
    2070:	01010000 	mrseq	r0, (UNDEF: 1)
    SubBytes(state);
    2074:	70740250 	rsbsvc	r0, r4, r0, asr r2
    ShiftRows(state);
    2078:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    207c:	01012008 	tsteq	r1, r8
    if (round == Nr) {
    2080:	00750252 	rsbseq	r0, r5, r2, asr r2
  AddRoundKey(Nr, state, RoundKey);
    2084:	0a580500 	beq	160348c <__ROM_SIZE__+0x15c348c>
    2088:	019f0000 	orrseq	r0, pc, r0
}
    208c:	03a60000 			@ <UNDEFINED> instruction: 0x03a60000
{
    2090:	01010000 	mrseq	r0, (UNDEF: 1)
  AddRoundKey(Nr, state, RoundKey);
    2094:	84910350 	ldrhi	r0, [r1], #848	@ 0x350
    2098:	5101017e 	tstpl	r1, lr, ror r1
    209c:	01200802 			@ <UNDEFINED> instruction: 0x01200802
  for (round = (Nr - 1); ; --round)
    20a0:	76025201 	strvc	r5, [r2], -r1, lsl #4
    InvMixColumns(state);
    20a4:	62050000 	andvs	r0, r5, #0
  for (round = (Nr - 1); ; --round)
    20a8:	2800000a 	stmdacs	r0, {r1, r3}
    InvShiftRows(state);
    20ac:	c3000002 	movwgt	r0, #2
    20b0:	01000003 	tsteq	r0, r3
    InvSubBytes(state);
    20b4:	03055001 	movweq	r5, #20481	@ 0x5001
    AddRoundKey(round, state, RoundKey);
    20b8:	00003040 	andeq	r3, r0, r0, asr #32
    20bc:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    20c0:	19000076 	stmdbne	r0, {r1, r2, r4, r5, r6}
    if (round == 0) {
    20c4:	00000a6a 	andeq	r0, r0, sl, ror #20
  for (i = 0; i < AES_BLOCKLEN; ++i) // The block in AES is always 128bit no matter the key size
    20c8:	00000228 	andeq	r0, r0, r8, lsr #4
    buf[i] ^= Iv[i];
    20cc:	05500101 	ldrbeq	r0, [r0, #-257]	@ 0xfffffeff
    20d0:	00306003 	eorseq	r6, r0, r3
    20d4:	51010100 	mrspl	r0, (UNDEF: 17)
  for (i = 0; i < AES_BLOCKLEN; ++i) // The block in AES is always 128bit no matter the key size
    20d8:	00007502 	andeq	r7, r0, r2, lsl #10
    20dc:	008b0a00 	addeq	r0, fp, r0, lsl #20
}
    20e0:	03ed0000 	mvneq	r0, #0
  KeyExpansion(ctx->RoundKey, key);
    20e4:	71080000 	mrsvc	r0, (UNDEF: 8)
}
    20e8:	38000000 	stmdacc	r0, {}	@ <UNPREDICTABLE>
{
    20ec:	008b0a00 	addeq	r0, fp, r0, lsl #20
  KeyExpansion(ctx->RoundKey, key);
    20f0:	03fd0000 	mvnseq	r0, #0
  memcpy (ctx->Iv, iv, AES_BLOCKLEN);
    20f4:	71080000 	mrsvc	r0, (UNDEF: 8)
    20f8:	1f000000 	svcne	0x00000000
    20fc:	00421a00 	subeq	r1, r2, r0, lsl #20
}
    2100:	71080000 	mrsvc	r0, (UNDEF: 8)
  memcpy (ctx->Iv, iv, AES_BLOCKLEN);
    2104:	2c000000 	stccs	0, cr0, [r0], {-0}
    2108:	11260000 			@ <UNDEFINED> instruction: 0x11260000
}
    210c:	00050000 	andeq	r0, r5, r0
{
    2110:	0ceb0401 	cfstrdeq	mvd0, [fp], #4
  Cipher((state_t*)buf, ctx->RoundKey);
    2114:	462a0000 	strtmi	r0, [sl], -r0
    2118:	1d000000 	stcne	0, cr0, [r0, #-0]
{
    211c:	000008d3 	ldrdeq	r0, [r0], -r3
  InvCipher((state_t*)buf, ctx->RoundKey);
    2120:	00000014 	andeq	r0, r0, r4, lsl r0
    2124:	00000a84 	andeq	r0, r0, r4, lsl #21
}
    2128:	00000680 	andeq	r0, r0, r0, lsl #13
{
    212c:	0000125a 	andeq	r1, r0, sl, asr r2
    2130:	2d060107 	stfcss	f0, [r6, #-28]	@ 0xffffffe4
  uint8_t *Iv = ctx->Iv;
    2134:	07000001 	streq	r0, [r0, -r1]
    2138:	01e30502 	mvneq	r0, r2, lsl #10
  for (i = 0; i < length; i += AES_BLOCKLEN)
    213c:	04070000 	streq	r0, [r7], #-0
    XorWithIv(buf, Iv);
    2140:	0001c705 	andeq	ip, r1, r5, lsl #14
    Cipher((state_t*)buf, ctx->RoundKey);
    2144:	05080700 	streq	r0, [r8, #-1792]	@ 0xfffff900
    2148:	000001c2 	andeq	r0, r0, r2, asr #3
  for (i = 0; i < length; i += AES_BLOCKLEN)
    214c:	00018816 	andeq	r8, r1, r6, lsl r8
    buf += AES_BLOCKLEN;
    2150:	182e0200 	stmdane	lr!, {r9}
  for (i = 0; i < length; i += AES_BLOCKLEN)
    2154:	00000053 	andeq	r0, r0, r3, asr r0
  memcpy(ctx->Iv, Iv, AES_BLOCKLEN);
    2158:	0000421d 	andeq	r4, r0, sp, lsl r2
    215c:	08010700 	stmdaeq	r1, {r8, r9, sl}
}
    2160:	0000012b 	andeq	r0, r0, fp, lsr #2
{
    2164:	39070207 	stmdbcc	r7, {r0, r1, r2, r9}
    2168:	16000001 	strne	r0, [r0], -r1
    216c:	0000026a 	andeq	r0, r0, sl, ror #4
  for (i = 0; i < length; i += AES_BLOCKLEN)
    2170:	6d193402 	cfldrsvs	mvf3, [r9, #-8]
    memcpy(storeNextIv, buf, AES_BLOCKLEN);
    2174:	07000000 	streq	r0, [r0, -r0]
    2178:	01760704 	cmneq	r6, r4, lsl #14
    InvCipher((state_t*)buf, ctx->RoundKey);
    217c:	08070000 	stmdaeq	r7, {}	@ <UNPREDICTABLE>
    2180:	00017107 	andeq	r7, r1, r7, lsl #2
    XorWithIv(buf, ctx->Iv);
    2184:	05042b00 	streq	r2, [r4, #-2816]	@ 0xfffff500
    2188:	00746e69 	rsbseq	r6, r4, r9, ror #28
    218c:	00007b1e 	andeq	r7, r0, lr, lsl fp
    memcpy(ctx->Iv, storeNextIv, AES_BLOCKLEN);
    2190:	07040700 	streq	r0, [r4, -r0, lsl #14]
    2194:	0000017b 	andeq	r0, r0, fp, ror r1
    2198:	00000d16 	andeq	r0, r0, r6, lsl sp
  for (i = 0; i < length; i += AES_BLOCKLEN)
    219c:	17d60300 	ldrbne	r0, [r6, r0, lsl #6]
    21a0:	00000087 	andeq	r0, r0, r7, lsl #1
}
    21a4:	25040807 	strcs	r0, [r4, #-2055]	@ 0xfffff7f9
{
    21a8:	2c000002 	stccs	0, cr0, [r0], {2}
    21ac:	000001a0 	andeq	r0, r0, r0, lsr #3
    21b0:	2c050100 	stfcss	f0, [r5], {-0}
  for (i = 0, bi = AES_BLOCKLEN; i < length; ++i, ++bi)
    21b4:	0000c908 	andeq	ip, r0, r8, lsl #18
          ctx->Iv[bi] = 0;
    21b8:	0c961700 	ldceq	7, cr1, [r6], {0}
    21bc:	2e050000 	cdpcs	0, 0, cr0, cr5, cr0, {0}
      for (bi = (AES_BLOCKLEN - 1); bi >= 0; --bi)
    21c0:	0000c90b 	andeq	ip, r0, fp, lsl #18
      bi = 0;
    21c4:	492d0000 	pushmi	{}	@ <UNPREDICTABLE>
    buf[i] = (buf[i] ^ buffer[bi]);
    21c8:	30050076 	andcc	r0, r5, r6, ror r0
    21cc:	0000d90b 	andeq	sp, r0, fp, lsl #18
    21d0:	0b00f000 	bleq	3e1d8 <__RAM_SIZE__+0x361d8>
    21d4:	00000042 	andeq	r0, r0, r2, asr #32
    21d8:	000000d9 	ldrdeq	r0, [r0], -r9
  for (i = 0, bi = AES_BLOCKLEN; i < length; ++i, ++bi)
    21dc:	0000870c 	andeq	r8, r0, ip, lsl #14
    21e0:	0b00ef00 	bleq	3dde8 <__RAM_SIZE__+0x35de8>
    if (bi == AES_BLOCKLEN) /* we need to regen xor compliment in buffer */
    21e4:	00000042 	andeq	r0, r0, r2, asr #32
      memcpy(buffer, ctx->Iv, AES_BLOCKLEN);
    21e8:	000000e9 	andeq	r0, r0, r9, ror #1
    21ec:	0000870c 	andeq	r8, r0, ip, lsl #14
    21f0:	09000f00 	stmdbeq	r0, {r8, r9, sl, fp}
      Cipher((state_t*)buffer,ctx->RoundKey);
    21f4:	000004ef 	andeq	r0, r0, pc, ror #9
    21f8:	7b0c2304 	blvc	30ae10 <__ROM_SIZE__+0x2cae10>
      for (bi = (AES_BLOCKLEN - 1); bi >= 0; --bi)
    21fc:	09000000 	stmdbeq	r0, {}	@ <UNPREDICTABLE>
    2200:	00000483 	andeq	r0, r0, r3, lsl #9
        if (ctx->Iv[bi] == 255)
    2204:	7b0c2404 	blvc	30b21c <__ROM_SIZE__+0x2cb21c>
    2208:	2e000000 	cdpcs	0, 0, cr0, cr0, cr0, {0}
        ctx->Iv[bi] += 1;
    220c:	00787463 	rsbseq	r7, r8, r3, ror #8
    2210:	a1172504 	tstge	r7, r4, lsl #10
      bi = 0;
    2214:	0b000000 	bleq	221c <bitvec_get_bit>
}
    2218:	00000042 	andeq	r0, r0, r2, asr #32
  return ((x[idx / 32U] >> (idx & 31U) & 1U));
    221c:	00000118 	andeq	r0, r0, r8, lsl r1
    2220:	9b09002f 	blls	2422e4 <__ROM_SIZE__+0x2022e4>
    2224:	04000007 	streq	r0, [r0], #-7
}
    2228:	010d1026 	tsteq	sp, r6, lsr #32
    222c:	ce090000 	cdpgt	0, 0, cr0, cr9, cr0, {0}
  x[idx / 32U] &= ~(1U << (idx & 31U));
    2230:	04000006 	streq	r0, [r0], #-6
    2234:	010d1027 	tsteq	sp, r7, lsr #32
    2238:	fb090000 	blx	242242 <__ROM_SIZE__+0x202242>
    223c:	04000004 	streq	r0, [r0], #-4
    2240:	010d1028 	tsteq	sp, r8, lsr #32
    2244:	39090000 	stmdbcc	r9, {}	@ <UNPREDICTABLE>
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2248:	04000000 	streq	r0, [r0], #-0
    x[i] = y[i];
    224c:	010d1029 	tsteq	sp, r9, lsr #32
    2250:	16090000 	strne	r0, [r9], -r0
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2254:	04000005 	streq	r0, [r0], #-5
    2258:	010d102a 	tsteq	sp, sl, lsr #32
{
    225c:	d0090000 	andle	r0, r9, r0
    2260:	04000001 	streq	r0, [r0], #-1
  bitvec_copy(tmp, x);
    2264:	010d102c 	tsteq	sp, ip, lsr #32
    2268:	ce090000 	cdpgt	0, 0, cr0, cr9, cr0, {0}
  bitvec_copy(x, y);
    226c:	04000000 	streq	r0, [r0], #-0
    2270:	010d102d 	tsteq	sp, sp, lsr #32
  bitvec_copy(y, tmp);
    2274:	63300000 	teqvs	r0, #0
    2278:	0400646d 	streq	r6, [r0], #-1133	@ 0xfffffb93
}
    227c:	01780f3b 	cmneq	r8, fp, lsr pc
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2280:	7d080000 	stcvc	0, cr0, [r8, #-0]
    2284:	31000001 	tstcc	r0, r1
    if (x[i] != y[i])
    2288:	0000007b 	andeq	r0, r0, fp, ror r0
    228c:	00000191 	muleq	r0, r1, r1
    2290:	00007b03 	andeq	r7, r0, r3, lsl #22
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2294:	01910300 	orrseq	r0, r1, r0, lsl #6
  return 1;
    2298:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
}
    229c:	00000196 	muleq	r0, r6, r1
  for (i = 0; i < BITVEC_NWORDS; ++i)
    22a0:	00019b08 	andeq	r9, r1, r8, lsl #22
    x[i] = 0;
    22a4:	08010700 	stmdaeq	r1, {r8, r9, sl}
  for (i = 0; i < BITVEC_NWORDS; ++i)
    22a8:	00000134 	andeq	r0, r0, r4, lsr r1
    22ac:	00019b1d 	andeq	r9, r1, sp, lsl fp
  uint32_t i = 0;
    22b0:	040c3200 	streq	r3, [ip], #-512	@ 0xfffffe00
  while (i < BITVEC_NWORDS)
    22b4:	01d80944 	bicseq	r0, r8, r4, asr #18
    if (x[i] != 0)
    22b8:	5d170000 	ldcpl	0, cr0, [r7, #-0]
    i += 1;
    22bc:	04000002 	streq	r0, [r0], #-2
}
    22c0:	01d80f45 	bicseq	r0, r8, r5, asr #30
    22c4:	17000000 	strne	r0, [r0, -r0]
    22c8:	00000000 	andeq	r0, r0, r0
  x += BITVEC_NWORDS;
    22cc:	d80f4604 	stmdale	pc, {r2, r9, sl, lr}	@ <UNPREDICTABLE>
          && (*(--x)) == 0)
    22d0:	04000001 	streq	r0, [r0], #-1
    22d4:	0000da17 	andeq	sp, r0, r7, lsl sl
    22d8:	07470400 	strbeq	r0, [r7, -r0, lsl #8]
    i -= 32;
    22dc:	0000016c 	andeq	r0, r0, ip, ror #2
  if (i != 0)
    22e0:	a2080008 	andge	r0, r8, #8
      i -= 1;
    22e4:	16000001 	strne	r0, [r0], -r1
    while (((*x) & u32mask) == 0)
    22e8:	000001bc 			@ <UNDEFINED> instruction: 0x000001bc
}
    22ec:	a7034804 	strge	r4, [r3, -r4, lsl #16]
    uint32_t u32mask = ((uint32_t)1 << 31);
    22f0:	1d000001 	stcne	0, cr0, [r0, #-4]
{
    22f4:	000001dd 	ldrdeq	r0, [r0], -sp
  int nwords = (nbits / 32);
    22f8:	0001dd1e 	andeq	sp, r1, lr, lsl sp
    22fc:	00e91f00 	rsceq	r1, r9, r0, lsl #30
  for (i = 0; i < nwords; ++i)
    2300:	05180000 	ldreq	r0, [r8, #-0]
  int nwords = (nbits / 32);
    2304:	00540305 	subseq	r0, r4, r5, lsl #6
    2308:	f51f2000 			@ <UNDEFINED> instruction: 0xf51f2000
    x[i] = 0;
    230c:	19000000 	stmdbne	r0, {}	@ <UNPREDICTABLE>
  for (i = 0; i < nwords; ++i)
    2310:	50030505 	andpl	r0, r3, r5, lsl #10
    2314:	1f200000 	svcne	0x00200000
  j = 0;
    2318:	00000101 	andeq	r0, r0, r1, lsl #2
    x[i] = y[j];
    231c:	0305101c 	movweq	r1, #20508	@ 0x501c
    2320:	20000194 	mulcs	r0, r4, r1
    i += 1;
    2324:	0000420b 	andeq	r4, r0, fp, lsl #4
    j += 1;
    2328:	00022a00 	andeq	r2, r2, r0, lsl #20
  while (i < BITVEC_NWORDS)
    232c:	00870c00 	addeq	r0, r7, r0, lsl #24
  if (nbits != 0)
    2330:	002b0000 	eoreq	r0, fp, r0
}
    2334:	0001180e 	andeq	r1, r1, lr, lsl #16
      x[i]  = (x[i] << nbits) | (x[i - 1] >> (32 - nbits));
    2338:	021a1d00 	andseq	r1, sl, #0, 26
    233c:	03050000 	movweq	r0, #20480	@ 0x5000
    2340:	20000004 	andcs	r0, r0, r4
    2344:	0000420b 	andeq	r4, r0, fp, lsl #4
    2348:	00024a00 	andeq	r4, r2, r0, lsl #20
    234c:	00870c00 	addeq	r0, r7, r0, lsl #24
    2350:	001f0000 	andseq	r0, pc, r0
    2354:	0001240e 	andeq	r2, r1, lr, lsl #8
    for (i = (BITVEC_NWORDS - 1); i > 0; --i)
    2358:	023a1e00 	eorseq	r1, sl, #0, 28
    x[0] <<= nbits;
    235c:	03050000 	movweq	r0, #20480	@ 0x5000
    2360:	20000174 	andcs	r0, r0, r4, ror r1
    for (i = (BITVEC_NWORDS - 1); i > 0; --i)
    2364:	0001300e 	andeq	r3, r1, lr
  x[0] = 1;
    2368:	023a2000 	eorseq	r2, sl, #0
  for (i = 1; i < BITVEC_NWORDS; ++i)
    236c:	03050000 	movweq	r0, #20480	@ 0x5000
    x[i] = 0;
    2370:	20000030 	andcs	r0, r0, r0, lsr r0
  for (i = 1; i < BITVEC_NWORDS; ++i)
    2374:	0000420b 	andeq	r4, r0, fp, lsl #4
    2378:	00027a00 	andeq	r7, r2, r0, lsl #20
  if (x[0] != 1)
    237c:	00870c00 	addeq	r0, r7, r0, lsl #24
    2380:	00170000 	andseq	r0, r7, r0
  for (i = 1; i < BITVEC_NWORDS; ++i)
    2384:	00013c0e 	andeq	r3, r1, lr, lsl #24
    if (x[i] != 0)
    2388:	026a2100 	rsbeq	r2, sl, #0, 2
  for (i = 1; i < BITVEC_NWORDS; ++i)
    238c:	03050000 	movweq	r0, #20480	@ 0x5000
  return (i == BITVEC_NWORDS);
    2390:	20000314 	andcs	r0, r0, r4, lsl r3
    2394:	0000420b 	andeq	r4, r0, fp, lsl #4
    2398:	00029a00 	andeq	r9, r2, r0, lsl #20
}
    239c:	00870c00 	addeq	r0, r7, r0, lsl #24
  for (i = 0; i < BITVEC_NWORDS; ++i)
    23a0:	002f0000 	eoreq	r0, pc, r0
{
    23a4:	0001480e 	andeq	r4, r1, lr, lsl #16
    z[i] = (x[i] ^ y[i]);
    23a8:	028a2200 	addeq	r2, sl, #0, 4
    23ac:	03050000 	movweq	r0, #20480	@ 0x5000
    23b0:	200002e4 	andcs	r0, r0, r4, ror #5
  for (i = 0; i < BITVEC_NWORDS; ++i)
    23b4:	0001540e 	andeq	r5, r1, lr, lsl #8
    23b8:	028a2300 	addeq	r2, sl, #0, 6
}
    23bc:	03050000 	movweq	r0, #20480	@ 0x5000
  x[0] ^= 1;
    23c0:	200002b4 			@ <UNDEFINED> instruction: 0x200002b4
    23c4:	0001600e 	andeq	r6, r1, lr
}
    23c8:	023a2400 	eorseq	r2, sl, #0, 8
{
    23cc:	03050000 	movweq	r0, #20480	@ 0x5000
    23d0:	20000294 	mulcs	r0, r4, r2
  bitvec_copy(tmp, x);
    23d4:	00007b33 	andeq	r7, r0, r3, lsr fp
    23d8:	06f21200 	ldrbteq	r1, [r2], r0, lsl #4
  if (bitvec_get_bit(y, 0) != 0)
    23dc:	07270000 	streq	r0, [r7, -r0]!
    23e0:	000002e0 	andeq	r0, r0, r0, ror #5
    bitvec_copy(z, x);
    23e4:	01680305 	cmneq	r8, r5, lsl #6
    23e8:	ca082000 	bgt	20a3f0 <__ROM_SIZE__+0x1ca3f0>
{
    23ec:	12000002 	andne	r0, r0, #2
    bitvec_set_zero(z);
    23f0:	00000934 	andeq	r0, r0, r4, lsr r9
    23f4:	02e00728 	rsceq	r0, r0, #40, 14	@ 0xa00000
      gf2field_add(tmp, tmp, polynomial);
    23f8:	03050000 	movweq	r0, #20480	@ 0x5000
    23fc:	2000016c 	andcs	r0, r0, ip, ror #2
    2400:	00030134 	andeq	r0, r3, r4, lsr r1
  for (i = 1; i < CURVE_DEGREE; ++i)
    2404:	019b0300 	orrseq	r0, fp, r0, lsl #6
    2408:	12000000 	andne	r0, r0, #0
    bitvec_lshift(tmp, tmp, 1);
    240c:	00000858 	andeq	r0, r0, r8, asr r8
    2410:	03120829 	tsteq	r2, #2686976	@ 0x290000
    if (bitvec_get_bit(tmp, CURVE_DEGREE))
    2414:	03050000 	movweq	r0, #20480	@ 0x5000
    2418:	20000058 	andcs	r0, r0, r8, asr r0
    241c:	0002f608 	andeq	pc, r2, r8, lsl #12
    if (bitvec_get_bit(y, i))
    2420:	06981200 	ldreq	r1, [r8], r0, lsl #4
    2424:	082a0000 	stmdaeq	sl!, {}	@ <UNPREDICTABLE>
    2428:	00000312 	andeq	r0, r0, r2, lsl r3
      gf2field_add(z, z, tmp);
    242c:	01700305 	cmneq	r0, r5, lsl #6
    2430:	71092000 	mrsvc	r2, (UNDEF: 9)
    2434:	01000007 	tsteq	r0, r7
}
    2438:	006d1a2c 	rsbeq	r1, sp, ip, lsr #20
    243c:	e6090000 	str	r0, [r9], -r0
{
    2440:	01000007 	tsteq	r0, r7
    2444:	006d1a2d 	rsbeq	r1, sp, sp, lsr #20
  bitvec_copy(u, x);
    2448:	e1270000 			@ <UNDEFINED> instruction: 0xe1270000
  bitvec_copy(v, polynomial);
    244c:	2f000002 	svccs	0x00000002
    2450:	0000034a 	andeq	r0, r0, sl, asr #6
  bitvec_set_zero(g);
    2454:	0001e908 	andeq	lr, r1, r8, lsl #18
    2458:	092a2700 	stmdbeq	sl!, {r8, r9, sl, sp}
  gf2field_set_one(z);
    245c:	4a300000 	bmi	c02464 <__ROM_SIZE__+0xbc2464>
  while (!gf2field_is_one(u))
    2460:	13000003 	movwne	r0, #3
    bitvec_lshift(h, v, i);
    2464:	0000088b 	andeq	r0, r0, fp, lsl #17
    2468:	00821531 	addeq	r1, r2, r1, lsr r5
    gf2field_add(u, u, h);
    246c:	03050000 	movweq	r0, #20480	@ 0x5000
    2470:	20000160 	andcs	r0, r0, r0, ror #2
    2474:	0007d313 	andeq	sp, r7, r3, lsl r3
    bitvec_lshift(h, g, i);
    2478:	82153900 	andshi	r3, r5, #0, 18
    247c:	05000000 	streq	r0, [r0, #-0]
    gf2field_add(z, z, h);
    2480:	00005c03 	andeq	r5, r0, r3, lsl #24
    2484:	08b81320 	ldmeq	r8!, {r5, r8, r9, ip}
    2488:	153a0000 	ldrne	r0, [sl, #-0]!
  while (!gf2field_is_one(u))
    248c:	00000082 	andeq	r0, r0, r2, lsl #1
    2490:	01640305 	cmneq	r4, r5, lsl #6
    i = (bitvec_degree(u) - bitvec_degree(v));
    2494:	9b0b2000 	blls	2ca49c <__ROM_SIZE__+0x28a49c>
    2498:	a2000001 	andge	r0, r0, #1
    249c:	0c000003 	stceq	0, cr0, [r0], {3}
    24a0:	00000087 	andeq	r0, r0, r7, lsl #1
    if (i < 0)
    24a4:	00870c01 	addeq	r0, r7, r1, lsl #24
      bitvec_swap(u, v);
    24a8:	007f0000 	rsbseq	r0, pc, r0
    24ac:	00073613 	andeq	r3, r7, r3, lsl r6
      bitvec_swap(g, z);
    24b0:	8c0d3b00 			@ <UNDEFINED> instruction: 0x8c0d3b00
    24b4:	05000003 	streq	r0, [r0, #-3]
      i = -i;
    24b8:	00006003 	andeq	r6, r0, r3
}
    24bc:	09191320 	ldmdbeq	r9, {r5, r8, r9, ip}
    24c0:	163e0000 	ldrtne	r0, [lr], -r0
{
    24c4:	000003cb 	andeq	r0, r0, fp, asr #7
    24c8:	00000305 	andeq	r0, r0, r5, lsl #6
  bitvec_copy(x1, x2);
    24cc:	01072000 	mrseq	r2, (UNDEF: 7)
  bitvec_copy(y1, y2);
    24d0:	00083102 	andeq	r3, r8, r2, lsl #2
    24d4:	03c41e00 	biceq	r1, r4, #0, 28
}
    24d8:	af120000 	svcge	0x00120000
{
    24dc:	a1000006 	tstge	r0, r6
  bitvec_set_zero(x);
    24e0:	0001dd01 	andeq	sp, r1, r1, lsl #26
  bitvec_set_zero(y);
    24e4:	f8030500 			@ <UNDEFINED> instruction: 0xf8030500
}
    24e8:	20000029 	andcs	r0, r0, r9, lsr #32
{
    24ec:	00000815 	andeq	r0, r0, r5, lsl r8
  return (    bitvec_is_zero(x)
    24f0:	01dd01f6 	ldrsheq	r0, [sp, #22]
           && bitvec_is_zero(y));
    24f4:	03050000 	movweq	r0, #20480	@ 0x5000
    24f8:	00002a40 	andeq	r2, r0, r0, asr #20
    24fc:	00071520 	andeq	r1, r7, r0, lsr #10
{
    2500:	dd01f700 	stcle	7, cr15, [r1, #-0]
    2504:	05000001 	streq	r0, [r0, #-1]
  if (bitvec_is_zero(x))
    2508:	0029ec03 	eoreq	lr, r9, r3, lsl #24
    250c:	06de2000 	ldrbeq	r2, [lr], r0
    bitvec_set_zero(y);
    2510:	01f80000 	mvnseq	r0, r0
}
    2514:	000001dd 	ldrdeq	r0, [r0], -sp
    gf2field_inv(l, x);
    2518:	29e00305 	stmibcs	r0!, {r0, r2, r8, r9}^
    251c:	ca140000 	bgt	502524 <__ROM_SIZE__+0x4c2524>
    gf2field_mul(l, l, y);
    2520:	fc000007 	stc2	0, cr0, [r0], {7}
    2524:	01ee3c01 	mvneq	r3, r1, lsl #24
    2528:	03050000 	movweq	r0, #20480	@ 0x5000
    gf2field_add(l, l, x);
    252c:	00002a4c 	andeq	r2, r0, ip, asr #20
    2530:	00076a11 	andeq	r6, r7, r1, lsl sl
    gf2field_mul(y, x, x);
    2534:	07410600 	strbeq	r0, [r1, -r0, lsl #12]
    2538:	00000446 	andeq	r0, r0, r6, asr #8
    253c:	00000446 	andeq	r0, r0, r6, asr #8
    gf2field_mul(x, l, l);
    2540:	00044603 	andeq	r4, r4, r3, lsl #12
    2544:	007b0300 	rsbseq	r0, fp, r0, lsl #6
    gf2field_inc(l);
    2548:	8e030000 	cdphi	0, 0, cr0, cr3, cr0, {0}
    254c:	00000000 	andeq	r0, r0, r0
    gf2field_add(x, x, l);
    2550:	4e110435 	mrcmi	4, 0, r0, cr1, cr5, {1}
    2554:	06000002 	streq	r0, [r0], -r2
    gf2field_mul(l, l, x);
    2558:	008e081f 	addeq	r0, lr, pc, lsl r8
    255c:	045e0000 	ldrbeq	r0, [lr], #-0
    2560:	d8030000 	stmdale	r3, {}	@ <UNPREDICTABLE>
    gf2field_add(y, y, l);
    2564:	00000001 	andeq	r0, r0, r1
    2568:	00070e11 	andeq	r0, r7, r1, lsl lr
}
    256c:	07380600 	ldreq	r0, [r8, -r0, lsl #12]!
{
    2570:	00000446 	andeq	r0, r0, r6, asr #8
    2574:	0000047e 	andeq	r0, r0, lr, ror r4
    2578:	00044603 	andeq	r4, r4, r3, lsl #12
  if (!gf2point_is_zero(x2, y2))
    257c:	047e0300 	ldrbteq	r0, [lr], #-768	@ 0xfffffd00
    2580:	8e030000 	cdphi	0, 0, cr0, cr3, cr0, {0}
    if (gf2point_is_zero(x1, y1))
    2584:	00000000 	andeq	r0, r0, r0
    2588:	00048308 	andeq	r8, r4, r8, lsl #6
    258c:	b5113600 	ldrlt	r3, [r1, #-1536]	@ 0xfffffa00
      if (bitvec_equal(x1, x2))
    2590:	06000001 	streq	r0, [r0], -r1
    2594:	007b0527 	rsbseq	r0, fp, r7, lsr #10
        if (bitvec_equal(y1, y2))
    2598:	049f0000 	ldreq	r0, [pc], #0	@ 25a0 <gf2point_add+0x32>
    259c:	d8030000 	stmdale	r3, {}	@ <UNPREDICTABLE>
    25a0:	03000001 	movweq	r0, #1
          gf2point_double(x1, y1);
    25a4:	000001d8 	ldrdeq	r0, [r0], -r8
    25a8:	01a83700 			@ <UNDEFINED> instruction: 0x01a83700
      gf2point_copy(x1, y1, x2, y2);
    25ac:	34050000 	strcc	r0, [r5], #-0
    25b0:	0004b606 	andeq	fp, r4, r6, lsl #12
    25b4:	04b60300 	ldrteq	r0, [r6], #768	@ 0x300
}
    25b8:	bb030000 	bllt	c25c0 <__ROM_SIZE__+0x825c0>
          gf2point_set_zero(x1, y1);
    25bc:	00000004 	andeq	r0, r0, r4
    25c0:	0000a108 	andeq	sl, r0, r8, lsl #2
    25c4:	004e0800 	subeq	r0, lr, r0, lsl #16
        gf2field_add(a, y1, y2);
    25c8:	e7110000 	ldr	r0, [r1, -r0]
    25cc:	07000000 	streq	r0, [r0, -r0]
        gf2field_add(b, x1, x2);
    25d0:	00870e4a 	addeq	r0, r7, sl, asr #28
    25d4:	04e00000 	strbteq	r0, [r0], #0
    25d8:	e0030000 	and	r0, r3, r0
        gf2field_inv(c, b);
    25dc:	03000004 	movweq	r0, #4
    25e0:	00000087 	andeq	r0, r0, r7, lsl #1
        gf2field_mul(c, c, a);
    25e4:	0004e003 	andeq	lr, r4, r3
    25e8:	53080000 	movwpl	r0, #32768	@ 0x8000
        gf2field_mul(d, c, c);
    25ec:	38000000 	stmdacc	r0, {}	@ <UNPREDICTABLE>
    25f0:	0000040a 	andeq	r0, r0, sl, lsl #8
    25f4:	11069604 	tstne	r6, r4, lsl #12
        gf2field_add(d, d, c);
    25f8:	000001dc 	ldrdeq	r0, [r0], -ip
    25fc:	7b052c08 	blvc	14d624 <__ROM_SIZE__+0x10d624>
        gf2field_add(d, d, b);
    2600:	04000000 	streq	r0, [r0], #-0
    2604:	03000005 	movweq	r0, #5
    2608:	000001d8 	ldrdeq	r0, [r0], -r8
        gf2field_inc(d);
    260c:	8d180039 	ldchi	0, cr0, [r8, #-228]	@ 0xffffff1c
        gf2field_add(x1, x1, d);
    2610:	f0000008 			@ <UNDEFINED> instruction: 0xf0000008
    2614:	00007b01 	andeq	r7, r0, r1, lsl #22
    2618:	000b8400 	andeq	r8, fp, r0, lsl #8
        gf2field_mul(a, x1, c);
    261c:	00001c00 	andeq	r1, r0, r0, lsl #24
    2620:	599c0100 	ldmibpl	ip, {r8}
        gf2field_add(a, a, d);
    2624:	0d000005 	stceq	0, cr0, [r0, #-20]	@ 0xffffffec
    2628:	000001ed 	andeq	r0, r0, sp, ror #3
    262c:	7b1901f0 	blvc	642df4 <__ROM_SIZE__+0x602df4>
        gf2field_add(y1, y1, a);
    2630:	cf000000 	svcgt	0x00000000
    2634:	cb000003 	blgt	2648 <gf2point_mul+0x6>
        bitvec_copy(x1, d);
    2638:	0d000003 	stceq	0, cr0, [r0, #-12]
    263c:	0000015a 	andeq	r0, r0, sl, asr r1
}
    2640:	912601f0 	strdls	r0, [r6, -r0]!	@ <UNPREDICTABLE>
{
    2644:	e5000001 	str	r0, [r0, #-1]
    2648:	e1000003 	tst	r0, r3
  int nbits = bitvec_degree(exp);
    264c:	06000003 	streq	r0, [r0], -r3
    2650:	00000b92 	muleq	r0, r2, fp
  gf2point_set_zero(tmpx, tmpy);
    2654:	000004ed 	andeq	r0, r0, sp, ror #9
    2658:	05500101 	ldrbeq	r0, [r0, #-257]	@ 0xfffffeff
  for (i = (nbits - 1); i >= 0; --i)
    265c:	00310003 	eorseq	r0, r1, r3
    2660:	18000000 	stmdane	r0, {}	@ <UNPREDICTABLE>
    2664:	00000008 	andeq	r0, r0, r8
    gf2point_double(tmpx, tmpy);
    2668:	007b01d6 	ldrsbteq	r0, [fp], #-22	@ 0xffffffea
    266c:	0c0c0000 	stceq	0, cr0, [ip], {-0}
    if (bitvec_get_bit(exp, i))
    2670:	00680000 	rsbeq	r0, r8, r0
    2674:	9c010000 	stcls	0, cr0, [r1], {-0}
    2678:	0000062f 	andeq	r0, r0, pc, lsr #12
      gf2point_add(tmpx, tmpy, x, y);
    267c:	0001ed0d 	andeq	lr, r1, sp, lsl #26
    2680:	0e01d600 	cfmadd32eq	mvax0, mvfx13, mvfx1, mvfx0
    2684:	0000007b 	andeq	r0, r0, fp, ror r0
  gf2point_copy(x, y, tmpx, tmpy);
    2688:	000003fb 	strdeq	r0, [r0], -fp
    268c:	000003f7 	strdeq	r0, [r0], -r7
    2690:	00015a0d 	andeq	r5, r1, sp, lsl #20
}
    2694:	1b01d600 	blne	77e9c <__ROM_SIZE__+0x37e9c>
{
    2698:	00000191 	muleq	r0, r1, r1
    269c:	00000413 	andeq	r0, r0, r3, lsl r4
  if (gf2point_is_zero(x, y))
    26a0:	0000040d 	andeq	r0, r0, sp, lsl #8
    26a4:	d700690f 	strle	r6, [r0, -pc, lsl #18]
}
    26a8:	007b0701 	rsbseq	r0, fp, r1, lsl #14
    gf2field_mul(a, x, x);
    26ac:	04340000 	ldrteq	r0, [r4], #-0
    26b0:	042c0000 	strteq	r0, [ip], #-0
    26b4:	d6190000 	ldrle	r0, [r9], -r0
    gf2field_mul(b, a, x);
    26b8:	d9000006 	stmdble	r0, {r1, r2}
    26bc:	03c40801 	biceq	r0, r4, #65536	@ 0x10000
    gf2field_add(a, a, b);
    26c0:	045b0000 	ldrbeq	r0, [fp], #-0
    26c4:	04530000 	ldrbeq	r0, [r3], #-0
    26c8:	1c020000 	stcne	0, cr0, [r2], {-0}
    gf2field_add(a, a, coeff_b);
    26cc:	8400000c 	strhi	r0, [r0], #-12
    26d0:	d7000004 	strle	r0, [r0, -r4]
    gf2field_mul(b, y, y);
    26d4:	01000005 	tsteq	r0, r5
    26d8:	03055101 	movweq	r5, #20737	@ 0x5101
    26dc:	0000318c 	andeq	r3, r0, ip, lsl #3
    gf2field_add(a, a, b);
    26e0:	0c240200 	sfmeq	f0, 4, [r4], #-0
    26e4:	04ed0000 	strbteq	r0, [sp], #0
    gf2field_mul(b, x, y);
    26e8:	05ee0000 	strbeq	r0, [lr, #0]!
    26ec:	01010000 	mrseq	r0, (UNDEF: 1)
    26f0:	90030550 	andls	r0, r3, r0, asr r5
    return bitvec_equal(a, b);
    26f4:	00000031 	andeq	r0, r0, r1, lsr r0
    26f8:	000c3002 	andeq	r3, ip, r2
    26fc:	0004ed00 	andeq	lr, r4, r0, lsl #26
{
    2700:	00060500 	andeq	r0, r6, r0, lsl #10
    2704:	50010100 	andpl	r0, r1, r0, lsl #2
  gf2point_copy((uint32_t*)public_key, (uint32_t*)(public_key + BITVEC_NBYTES), base_x, base_y);
    2708:	31b40305 			@ <UNDEFINED> instruction: 0x31b40305
    270c:	04000000 	streq	r0, [r0], #-0
    2710:	00000c42 	andeq	r0, r0, r2, asr #24
    2714:	000004ed 	andeq	r0, r0, sp, ror #9
  if (bitvec_degree((uint32_t*)private_key) < (CURVE_DEGREE / 2))
    2718:	000c4c02 	andeq	r4, ip, r2, lsl #24
    271c:	0004ed00 	andeq	lr, r4, r0, lsl #26
    2720:	00062500 	andeq	r2, r6, r0, lsl #10
    int nbits = bitvec_degree(base_order);
    2724:	50010100 	andpl	r0, r1, r0, lsl #2
    for (i = (nbits - 1); i < (BITVEC_NWORDS * 32); ++i)
    2728:	31b00305 	lslscc	r0, r5, #6
      bitvec_clr_bit((uint32_t*)private_key, i);
    272c:	04000000 	streq	r0, [r0], #-0
    2730:	00000c56 	andeq	r0, r0, r6, asr ip
    for (i = (nbits - 1); i < (BITVEC_NWORDS * 32); ++i)
    2734:	000004ed 	andeq	r0, r0, sp, ror #9
    2738:	08791800 	ldmdaeq	r9!, {fp, ip}^
    gf2point_mul((uint32_t*)public_key, (uint32_t*)(public_key + BITVEC_NBYTES), (uint32_t*)private_key);
    273c:	01cd0000 	biceq	r0, sp, r0
    2740:	0000016c 	andeq	r0, r0, ip, ror #2
    return 1;
    2744:	000010d4 	ldrdeq	r1, [r0], -r4
    return 0;
    2748:	00000030 	andeq	r0, r0, r0, lsr r0
    274c:	06899c01 	streq	r9, [r9], r1, lsl #24
    2750:	420d0000 	andmi	r0, sp, #0
{
    2754:	cd000007 	stcgt	0, cr0, [r0, #-28]	@ 0xffffffe4
    2758:	01961d01 	orrseq	r1, r6, r1, lsl #26
  if (    !gf2point_is_zero ((uint32_t*)others_pub, (uint32_t*)(others_pub + BITVEC_NBYTES))
    275c:	04800000 	streq	r0, [r0], #0
    2760:	047a0000 	ldrbteq	r0, [sl], #-0
    2764:	d8210000 	stmdale	r1!, {}	@ <UNPREDICTABLE>
    2768:	24000010 	strcs	r0, [r0], #-16
}
    276c:	0f000000 	svceq	0x00000000
       &&  gf2point_on_curve((uint32_t*)others_pub, (uint32_t*)(others_pub + BITVEC_NBYTES)) )
    2770:	01ce0069 	biceq	r0, lr, r9, rrx
    2774:	00007b0c 	andeq	r7, r0, ip, lsl #22
    2778:	00049d00 	andeq	r9, r4, r0, lsl #26
    for (i = 0; i < (BITVEC_NBYTES * 2); ++i)
    277c:	00049900 	andeq	r9, r4, r0, lsl #18
      output[i] = others_pub[i];
    2780:	10f00600 	rscsne	r0, r0, r0, lsl #12
    2784:	04840000 	streq	r0, [r4], #0
    for (i = 0; i < (BITVEC_NBYTES * 2); ++i)
    2788:	01010000 	mrseq	r0, (UNDEF: 1)
    gf2point_mul((uint32_t*)output,(uint32_t*)(output + BITVEC_NBYTES), (const uint32_t*)private_key);
    278c:	00760250 	rsbseq	r0, r6, r0, asr r2
    2790:	18000000 	stmdane	r0, {}	@ <UNPREDICTABLE>
    2794:	0000075a 	andeq	r0, r0, sl, asr r7
    return 1;
    2798:	007b01be 	ldrhteq	r0, [fp], #-30	@ 0xffffffe2
int atoi(const char* str) {
    279c:	10a80000 	adcne	r0, r8, r0
  int res = 0;
    27a0:	002c0000 	eoreq	r0, ip, r0
    res = res * 10 + str[i] - '0';
    27a4:	9c010000 	stcls	0, cr0, [r1], {-0}
    27a8:	0000070c 	andeq	r0, r0, ip, lsl #14
    27ac:	0007420d 	andeq	r4, r7, sp, lsl #4
  for (int i = 0; str[i] != '\0'; ++i) {
    27b0:	1001be00 	andne	fp, r1, r0, lsl #28
    27b4:	00000196 	muleq	r0, r6, r1
}
    27b8:	000004b3 			@ <UNDEFINED> instruction: 0x000004b3
  for (uint32_t i = 0; str[i] != '\0'; i++) {
    27bc:	000004ad 	andeq	r0, r0, sp, lsr #9
    27c0:	0001ed19 	andeq	lr, r1, r9, lsl sp
    } else if (str[i] >= 'a' && str[i] <= 'f') {
    27c4:	0701bf00 	streq	fp, [r1, -r0, lsl #30]
    27c8:	0000007b 	andeq	r0, r0, fp, ror r0
      value = str[i] - 'a' + 10;
    27cc:	000004d0 	ldrdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
    hex |= value;
    27d0:	000004cc 	andeq	r0, r0, ip, asr #9
  for (uint32_t i = 0; str[i] != '\0'; i++) {
    27d4:	00015a14 	andeq	r5, r1, r4, lsl sl
    27d8:	0901c200 	stmdbeq	r1, {r9, lr, pc}
    if (str[i] >= '0' && str[i] <= '9') {
    27dc:	0000070c 	andeq	r0, r0, ip, lsl #14
    27e0:	7df89103 	ldfvcp	f1, [r8, #12]!
      value = str[i] - '0';
    27e4:	0010b602 	andseq	fp, r0, r2, lsl #12
    } else if (str[i] >= 'A' && str[i] <= 'F') {
    27e8:	000b2a00 	andeq	r2, fp, r0, lsl #20
    27ec:	0006fb00 	andeq	pc, r6, r0, lsl #22
    27f0:	50010100 	andpl	r0, r1, r0, lsl #2
      value = str[i] - 'A' + 10;
    27f4:	01007d02 	tsteq	r0, r2, lsl #26
  selected_mode = mode;
    27f8:	a3035101 	movwge	r5, #12545	@ 0x3101
  if (selected_mode == NONE) {
    27fc:	01015001 	tsteq	r1, r1
  out_buf_rgn.addr = addr;
    2800:	40080252 	andmi	r0, r8, r2, asr r2
  out_buf_rgn.size = size / 2;
    2804:	10cc0600 	sbcne	r0, ip, r0, lsl #12
  out_buf_rgn.curr_index = 0;
    2808:	0a8f0000 	beq	fe3c2810 <_STACK_TOP_+0xde3ba814>
  inp_buf_rgn.addr = addr + size / 2;
    280c:	01010000 	mrseq	r0, (UNDEF: 1)
  inp_buf_rgn.curr_index = 0;
    2810:	007d0251 	rsbseq	r0, sp, r1, asr r2
  if (!(selected_mode & INP)) {
    2814:	960b0000 	strls	r0, [fp], -r0
    out_buf_rgn.size = size;
    2818:	1c000001 	stcne	0, cr0, [r0], {1}
  memset(addr, 0, size);
    281c:	0c000007 	stceq	0, cr0, [r0], {7}
    2820:	00000087 	andeq	r0, r0, r7, lsl #1
  } else if (!(selected_mode & OUT)) {
    2824:	4a3a003f 	bmi	e82928 <__ROM_SIZE__+0xe42928>
    2828:	01000008 	tsteq	r0, r8
    inp_buf_rgn.addr = addr;
    282c:	700601b2 			@ <UNDEFINED> instruction: 0x700601b2
    inp_buf_rgn.size = size;
    2830:	38000010 	stmdacc	r0, {r4}
    2834:	01000000 	mrseq	r0, (UNDEF: 0)
  if (!(selected_mode & INP)) {
    2838:	0007969c 	muleq	r7, ip, r6
    283c:	10760400 	rsbsne	r0, r6, r0, lsl #8
    2840:	07960000 	ldreq	r0, [r6, r0]
  if (inp_buf_rgn.addr[inp_buf_rgn.curr_index] == 0) {
    2844:	7a040000 	bvc	10284c <__ROM_SIZE__+0xc284c>
    2848:	51000010 	tstpl	r0, r0, lsl r0
  int val = inp_buf_rgn.addr[inp_buf_rgn.curr_index];
    284c:	04000008 	streq	r0, [r0], #-8
  inp_buf_rgn.addr[inp_buf_rgn.curr_index] = 0;
    2850:	0000107e 	andeq	r1, r0, lr, ror r0
  inp_buf_rgn.curr_index++;
    2854:	00001093 	muleq	r0, r3, r0
    2858:	00108e02 	andseq	r8, r0, r2, lsl #28
  if (inp_buf_rgn.curr_index == inp_buf_rgn.size) {
    285c:	0004c000 	andeq	ip, r4, r0
}
    2860:	00077100 	andeq	r7, r7, r0, lsl #2
    inp_buf_rgn.curr_index = 0;
    2864:	50010100 	andpl	r0, r1, r0, lsl #2
    return -1;
    2868:	00040305 	andeq	r0, r4, r5, lsl #6
    286c:	01012000 	mrseq	r2, (UNDEF: 1)
    return -1;
    2870:	2c080251 	sfmcs	f0, 4, [r8], {81}	@ 0x51
    2874:	02520101 	subseq	r0, r2, #1073741824	@ 0x40000000
  if (!(selected_mode & OUT) || c == 0) {
    2878:	02000075 	andeq	r0, r0, #117	@ 0x75
    287c:	00001098 	muleq	r0, r8, r0
    2880:	0000049f 	muleq	r0, pc, r4	@ <UNPREDICTABLE>
  out_buf_rgn.addr[out_buf_rgn.curr_index] = (uint8_t) c;
    2884:	0000078c 	andeq	r0, r0, ip, lsl #15
    2888:	03500101 	cmpeq	r0, #1073741824	@ 0x40000000
  out_buf_rgn.curr_index++;
    288c:	0102bc74 	tsteq	r2, r4, ror ip
  if (out_buf_rgn.curr_index == out_buf_rgn.size) {
    2890:	75025101 	strvc	r5, [r2, #-257]	@ 0xfffffeff
    2894:	9c040000 	stcls	0, cr0, [r4], {-0}
    out_buf_rgn.curr_index = 0;
    2898:	95000010 	strls	r0, [r0, #-16]
    289c:	00000008 	andeq	r0, r0, r8
    28a0:	0007003b 	andeq	r0, r7, fp, lsr r0
size_t strlen(const char *str) {
    28a4:	01840100 	orreq	r0, r4, r0, lsl #2
  while (str[len]) {
    28a8:	000a842c 	andeq	r8, sl, ip, lsr #8
    28ac:	00006c00 	andeq	r6, r0, r0, lsl #24
    28b0:	fa9c0100 	blx	fe702cb8 <_STACK_TOP_+0xde6facbc>
  while (*str1 && (*str1 == *str2)) {
    28b4:	15000007 	strne	r0, [r0, #-7]
    str2++;
    28b8:	00000943 	andeq	r0, r0, r3, asr #18
  while (*str1 && (*str1 == *str2)) {
    28bc:	00019b0f 	andeq	r9, r1, pc, lsl #22
    28c0:	078f1500 	streq	r1, [pc, r0, lsl #10]
  return *str1 - *str2;
    28c4:	9b170000 	blls	5c28cc <__ROM_SIZE__+0x5828cc>
}
    28c8:	15000001 	strne	r0, [r0, #-1]
    *(str1++) = *(str2++);
    28cc:	000006a8 	andeq	r0, r0, r8, lsr #13
    28d0:	00019b1e 	andeq	r9, r1, lr, lsl fp
  while (*str2) {
    28d4:	094a1500 	stmdbeq	sl, {r8, sl, ip}^
  *str1 = '\0';
    28d8:	9b260000 	blls	9828e0 <__ROM_SIZE__+0x9428e0>
}
    28dc:	15000001 	strne	r0, [r0, #-1]
  for (i = 0; i < size; i++) {
    28e0:	00000764 	andeq	r0, r0, r4, ror #14
    dest_char[i] = src_char[i];
    28e4:	00019b2c 	andeq	r9, r1, ip, lsr #22
    28e8:	72732800 	rsbsvc	r2, r3, #0, 16
  for (i = 0; i < size; i++) {
    28ec:	96090063 	strls	r0, [r9], -r3, rrx
}
    28f0:	02000001 	andeq	r0, r0, #1
  for (i = 0; i < size; i++) {
    28f4:	64287491 	strtvs	r7, [r8], #-1169	@ 0xfffffb6f
    dest_char[i] = val;
    28f8:	19007473 	stmdbne	r0, {r0, r1, r4, r5, r6, sl, ip, sp, lr}
  for (i = 0; i < size; i++) {
    28fc:	00000196 	muleq	r0, r6, r1
}
    2900:	00709102 	rsbseq	r9, r0, r2, lsl #2
    2904:	0008193c 	andeq	r1, r8, ip, lsr r9
    2908:	017d0100 	cmneq	sp, r0, lsl #2
    290c:	00007b0c 	andeq	r7, r0, ip, lsl #22
    2910:	000ba000 	andeq	sl, fp, r0
    2914:	00001000 	andeq	r1, r0, r0
    2918:	519c0100 	orrspl	r0, ip, r0, lsl #2
    291c:	0d000008 	stceq	0, cr0, [r0, #-32]	@ 0xffffffe0
    2920:	000001ed 	andeq	r0, r0, sp, ror #3
    2924:	7b1b017d 	blvc	6c2f20 <__ROM_SIZE__+0x682f20>
    2928:	e3000000 	movw	r0, #0
    292c:	df000004 	svcle	0x00000004
    2930:	0d000004 	stceq	0, cr0, [r0, #-16]
    2934:	0000015a 	andeq	r0, r0, sl, asr r1
    2938:	9128017d 			@ <UNDEFINED> instruction: 0x9128017d
    293c:	f9000001 			@ <UNDEFINED> instruction: 0xf9000001
    2940:	f5000004 			@ <UNDEFINED> instruction: 0xf5000004
    2944:	06000004 	streq	r0, [r0], -r4
    2948:	00000ba8 	andeq	r0, r0, r8, lsr #23
    294c:	000004ed 	andeq	r0, r0, sp, ror #9
    2950:	05500101 	ldrbeq	r0, [r0, #-257]	@ 0xfffffeff
    2954:	00310403 	eorseq	r0, r1, r3, lsl #8
    2958:	3d000000 	stccc	0, cr0, [r0, #-0]
    295c:	000008a9 	andeq	r0, r0, r9, lsr #17
    2960:	0d017701 	stceq	7, cr7, [r1, #-4]
    2964:	00000b1e 	andeq	r0, r0, lr, lsl fp
    2968:	00000026 	andeq	r0, r0, r6, lsr #32
    296c:	08959c01 	ldmeq	r5, {r0, sl, fp, ip, pc}
    2970:	20210000 	eorcs	r0, r1, r0
    2974:	1e00000b 	cdpne	0, 0, cr0, cr0, cr11, {0}
    2978:	0f000000 	svceq	0x00000000
    297c:	01780069 	cmneq	r8, r9, rrx
    2980:	00007b0c 	andeq	r7, r0, ip, lsl #22
    2984:	00050f00 	andeq	r0, r5, r0, lsl #30
    2988:	00050b00 	andeq	r0, r5, r0, lsl #22
    298c:	0b2c2200 	bleq	b0b194 <__ROM_SIZE__+0xacb194>
    2990:	01010000 	mrseq	r0, (UNDEF: 1)
    2994:	01300150 	teqeq	r0, r0, asr r1
    2998:	30015101 	andcc	r5, r1, r1, lsl #2
    299c:	3e000000 	cdpcc	0, 0, cr0, cr0, cr0, {0}
    29a0:	00000795 	muleq	r0, r5, r7
    29a4:	0d010401 	cfstrseq	mvf0, [r1, #-4]
    29a8:	00000ef8 	strdeq	r0, [r0], -r8
    29ac:	00000178 	andeq	r0, r0, r8, ror r1
    29b0:	0a7f9c01 	beq	1fe99bc <__ROM_SIZE__+0x1fa99bc>
    29b4:	730f0000 	movwvc	r0, #61440	@ 0xf000
    29b8:	07010500 	streq	r0, [r1, -r0, lsl #10]
    29bc:	0000007b 	andeq	r0, r0, fp, ror r0
    29c0:	00000525 	andeq	r0, r0, r5, lsr #10
    29c4:	0000051f 	andeq	r0, r0, pc, lsl r5
    29c8:	0001ed19 	andeq	lr, r1, r9, lsl sp
    29cc:	0a010500 	beq	43dd4 <__ROM_SIZE__+0x3dd4>
    29d0:	0000007b 	andeq	r0, r0, fp, ror r0
    29d4:	0000053f 	andeq	r0, r0, pc, lsr r5
    29d8:	0000053b 	andeq	r0, r0, fp, lsr r5
    29dc:	0008a314 	andeq	sl, r8, r4, lsl r3
    29e0:	07010600 	streq	r0, [r1, -r0, lsl #12]
    29e4:	0000007b 	andeq	r0, r0, fp, ror r0
    29e8:	196c9102 	stmdbne	ip!, {r1, r8, ip, pc}^
    29ec:	00000800 	andeq	r0, r0, r0, lsl #16
    29f0:	7b070107 	blvc	1c2e14 <__ROM_SIZE__+0x182e14>
    29f4:	5e000000 	cdppl	0, 0, cr0, cr0, cr0, {0}
    29f8:	4e000005 	cdpmi	0, 0, cr0, cr0, cr5, {0}
    29fc:	0f000005 	svceq	0x00000005
    2a00:	01080063 	tsteq	r8, r3, rrx
    2a04:	00019b08 	andeq	r9, r1, r8, lsl #22
    2a08:	00059f00 	andeq	r9, r5, r0, lsl #30
    2a0c:	00059900 	andeq	r9, r5, r0, lsl #18
    2a10:	07851400 	streq	r1, [r5, r0, lsl #8]
    2a14:	010a0000 	mrseq	r0, (UNDEF: 10)
    2a18:	000a7f08 	andeq	r7, sl, r8, lsl #30
    2a1c:	ec910300 	ldc	3, cr0, [r1], {0}
    2a20:	015a147e 	cmpeq	sl, lr, ror r4
    2a24:	010b0000 	mrseq	r0, (UNDEF: 11)
    2a28:	00070c09 	andeq	r0, r7, r9, lsl #24
    2a2c:	ec910300 	ldc	3, cr0, [r1], {0}
    2a30:	0f00237c 	svceq	0x0000237c
    2a34:	00140000 	andseq	r0, r4, r0
    2a38:	09470000 	stmdbeq	r7, {}^	@ <UNPREDICTABLE>
    2a3c:	690f0000 	stmdbvs	pc, {}	@ <UNPREDICTABLE>
    2a40:	0c010d00 	stceq	13, cr0, [r1], {-0}
    2a44:	0000007b 	andeq	r0, r0, fp, ror r0
    2a48:	000005b9 			@ <UNDEFINED> instruction: 0x000005b9
    2a4c:	000005b5 			@ <UNDEFINED> instruction: 0x000005b5
    2a50:	0f142300 	svceq	0x00142300
    2a54:	00120000 	andseq	r0, r2, r0
    2a58:	09670000 	stmdbeq	r7!, {}^	@ <UNPREDICTABLE>
    2a5c:	690f0000 	stmdbvs	pc, {}	@ <UNPREDICTABLE>
    2a60:	0c010f00 	stceq	15, cr0, [r1], {-0}
    2a64:	0000007b 	andeq	r0, r0, fp, ror r0
    2a68:	000005cb 	andeq	r0, r0, fp, asr #11
    2a6c:	000005c9 	andeq	r0, r0, r9, asr #11
    2a70:	0f2a0400 	svceq	0x002a0400
    2a74:	10710000 	rsbsne	r0, r1, r0
    2a78:	30020000 	andcc	r0, r2, r0
    2a7c:	ed00000f 	stc	0, cr0, [r0, #-60]	@ 0xffffffc4
    2a80:	87000004 	strhi	r0, [r0, -r4]
    2a84:	01000009 	tsteq	r0, r9
    2a88:	03055001 	movweq	r5, #20481	@ 0x5001
    2a8c:	000031c4 	andeq	r3, r0, r4, asr #3
    2a90:	0f4a0400 	svceq	0x004a0400
    2a94:	10830000 	addne	r0, r3, r0
    2a98:	621a0000 	andsvs	r0, sl, #0
    2a9c:	9f00000f 	svcls	0x0000000f
    2aa0:	01000009 	tsteq	r0, r9
    2aa4:	3a015001 	bcc	56ab0 <__ROM_SIZE__+0x16ab0>
    2aa8:	0f680200 	svceq	0x00680200
    2aac:	0dfe0000 	ldcleq	0, cr0, [lr]
    2ab0:	09b40000 	ldmibeq	r4!, {}	@ <UNPREDICTABLE>
    2ab4:	01010000 	mrseq	r0, (UNDEF: 1)
    2ab8:	ec910350 	ldc	3, cr0, [r1], {80}	@ 0x50
    2abc:	7202007e 	andvc	r0, r2, #126	@ 0x7e
    2ac0:	2a00000f 	bcs	2b04 <cmd_end_+0xb8>
    2ac4:	d600000b 	strle	r0, [r0], -fp
    2ac8:	01000009 	tsteq	r0, r9
    2acc:	91035001 	tstls	r3, r1
    2ad0:	01017cec 	smlatteq	r1, ip, ip, r7
    2ad4:	ec910351 	ldc	3, cr0, [r1], {81}	@ 0x51
    2ad8:	5201017e 	andpl	r0, r1, #-2147483617	@ 0x8000001f
    2adc:	00400802 	subeq	r0, r0, r2, lsl #16
    2ae0:	000f9a04 	andeq	r9, pc, r4, lsl #20
    2ae4:	00101c00 	andseq	r1, r0, r0, lsl #24
    2ae8:	0fa81a00 	svceq	0x00a81a00
    2aec:	09ef0000 	stmibeq	pc!, {}^	@ <UNPREDICTABLE>
    2af0:	01010000 	mrseq	r0, (UNDEF: 1)
    2af4:	00740250 	rsbseq	r0, r4, r0, asr r2
    2af8:	0fac0400 	svceq	0x00ac0400
    2afc:	105b0000 	subsne	r0, fp, r0
    2b00:	06040000 	streq	r0, [r4], -r0
    2b04:	1c000010 	stcne	0, cr0, [r0], {16}
    2b08:	04000010 	streq	r0, [r0], #-16
    2b0c:	0000100a 	andeq	r1, r0, sl
    2b10:	0000101c 	andeq	r1, r0, ip, lsl r0
    2b14:	00102e04 	andseq	r2, r0, r4, lsl #28
    2b18:	000feb00 	andeq	lr, pc, r0, lsl #22
    2b1c:	103a0200 	eorsne	r0, sl, r0, lsl #4
    2b20:	0e6c0000 	cdpeq	0, 6, cr0, cr12, cr0, {0}
    2b24:	0a2e0000 	beq	b82b2c <__ROM_SIZE__+0xb42b2c>
    2b28:	01010000 	mrseq	r0, (UNDEF: 1)
    2b2c:	ec910350 	ldc	3, cr0, [r1], {80}	@ 0x50
    2b30:	5101017e 	tstpl	r1, lr, ror r1
    2b34:	006c9102 	rsbeq	r9, ip, r2, lsl #2
    2b38:	00104404 	andseq	r4, r0, r4, lsl #8
    2b3c:	000feb00 	andeq	lr, pc, r0, lsl #22
    2b40:	104e0200 	subne	r0, lr, r0, lsl #4
    2b44:	0f200000 	svceq	0x00200000
    2b48:	0a520000 	beq	1482b50 <__ROM_SIZE__+0x1442b50>
    2b4c:	01010000 	mrseq	r0, (UNDEF: 1)
    2b50:	ec910350 	ldc	3, cr0, [r1], {80}	@ 0x50
    2b54:	5101017e 	tstpl	r1, lr, ror r1
    2b58:	006c9102 	rsbeq	r9, ip, r2, lsl #2
    2b5c:	00105802 	andseq	r5, r0, r2, lsl #16
    2b60:	000bc500 	andeq	ip, fp, r0, lsl #10
    2b64:	000a6d00 	andeq	r6, sl, r0, lsl #26
    2b68:	50010100 	andpl	r0, r1, r0, lsl #2
    2b6c:	7eec9103 	urdvce	f1, f3
    2b70:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    2b74:	06006c91 			@ <UNDEFINED> instruction: 0x06006c91
    2b78:	00001060 	andeq	r1, r0, r0, rrx
    2b7c:	00000a8f 	andeq	r0, r0, pc, lsl #21
    2b80:	03510101 	cmpeq	r1, #1073741824	@ 0x40000000
    2b84:	007cec91 			@ <UNDEFINED> instruction: 0x007cec91
    2b88:	019b0b00 	orrseq	r0, fp, r0, lsl #22
    2b8c:	0a8f0000 	beq	fe3c2b94 <_STACK_TOP_+0xde3bab98>
    2b90:	870c0000 	strhi	r0, [ip, -r0]
    2b94:	7f000000 	svcvc	0x00000000
    2b98:	09031000 	stmdbeq	r3, {ip}
    2b9c:	b0f20000 	rscslt	r0, r2, r0
    2ba0:	5c00000b 	stcpl	0, cr0, [r0], {11}
    2ba4:	01000000 	mrseq	r0, (UNDEF: 0)
    2ba8:	000b2a9c 	muleq	fp, ip, sl
    2bac:	01ed0500 	mvneq	r0, r0, lsl #10
    2bb0:	19f20000 	ldmibne	r2!, {}^	@ <UNPREDICTABLE>
    2bb4:	0000007b 	andeq	r0, r0, fp, ror r0
    2bb8:	000005d9 	ldrdeq	r0, [r0], -r9
    2bbc:	000005d3 	ldrdeq	r0, [r0], -r3
    2bc0:	00015a05 	andeq	r5, r1, r5, lsl #20
    2bc4:	9126f200 	msrls	LR_usr, r0
    2bc8:	f8000001 			@ <UNDEFINED> instruction: 0xf8000001
    2bcc:	f2000005 	vhadd.s8	d0, d0, d5
    2bd0:	0a000005 	beq	2bec <cmd_end_+0x1a0>
    2bd4:	000007be 			@ <UNDEFINED> instruction: 0x000007be
    2bd8:	007b07f3 	ldrshteq	r0, [fp], #-115	@ 0xffffff8d
    2bdc:	06170000 	ldreq	r0, [r7], -r0
    2be0:	06110000 	ldreq	r0, [r1], -r0
    2be4:	b8230000 	stmdalt	r3!, {}	@ <UNPREDICTABLE>
    2be8:	2e00000b 	cdpcs	0, 0, cr0, cr0, cr11, {0}
    2bec:	16000000 	strne	r0, [r0], -r0
    2bf0:	1b00000b 	blne	2c24 <cmd_end_+0x1d8>
    2bf4:	0cf50069 	ldcleq	0, cr0, [r5], #420	@ 0x1a4
    2bf8:	0000007b 	andeq	r0, r0, fp, ror r0
    2bfc:	00000634 	andeq	r0, r0, r4, lsr r6
    2c00:	00000630 	andeq	r0, r0, r0, lsr r6
    2c04:	000bd004 	andeq	sp, fp, r4
    2c08:	00048400 	andeq	r8, r4, r0, lsl #8
    2c0c:	0be02200 	bleq	ff80b414 <_STACK_TOP_+0xdf803418>
    2c10:	01010000 	mrseq	r0, (UNDEF: 1)
    2c14:	00780250 	rsbseq	r0, r8, r0, asr r2
    2c18:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    2c1c:	00000076 	andeq	r0, r0, r6, ror r0
    2c20:	000bf006 	andeq	pc, fp, r6
    2c24:	0004ed00 	andeq	lr, r4, r0, lsl #26
    2c28:	50010100 	andpl	r0, r1, r0, lsl #2
    2c2c:	31500305 	cmpcc	r0, r5, lsl #6
    2c30:	00000000 	andeq	r0, r0, r0
    2c34:	00068224 	andeq	r8, r6, r4, lsr #4
    2c38:	007bda00 	rsbseq	sp, fp, r0, lsl #20
    2c3c:	0cbc0000 	ldceq	0, cr0, [ip]
    2c40:	00520000 	subseq	r0, r2, r0
    2c44:	9c010000 	stcls	0, cr0, [r1], {-0}
    2c48:	00000bc5 	andeq	r0, r0, r5, asr #23
    2c4c:	00015a05 	andeq	r5, r1, r5, lsl #20
    2c50:	911eda00 	tstls	lr, r0, lsl #20
    2c54:	48000001 	stmdami	r0, {r0}
    2c58:	44000006 	strmi	r0, [r0], #-6
    2c5c:	05000006 	streq	r0, [r0, #-6]
    2c60:	00000785 	andeq	r0, r0, r5, lsl #15
    2c64:	01962ada 			@ <UNDEFINED> instruction: 0x01962ada
    2c68:	065b0000 	ldrbeq	r0, [fp], -r0
    2c6c:	06570000 	ldrbeq	r0, [r7], -r0
    2c70:	0b050000 	bleq	142c78 <__ROM_SIZE__+0x102c78>
    2c74:	da000009 	ble	2ca0 <cmd_end_+0x254>
    2c78:	00007b39 	andeq	r7, r0, r9, lsr fp
    2c7c:	00066e00 	andeq	r6, r6, r0, lsl #28
    2c80:	00066a00 	andeq	r6, r6, r0, lsl #20
    2c84:	01ed0a00 	mvneq	r0, r0, lsl #20
    2c88:	07db0000 	ldrbeq	r0, [fp, r0]
    2c8c:	0000007b 	andeq	r0, r0, fp, ror r0
    2c90:	00000688 	andeq	r0, r0, r8, lsl #13
    2c94:	00000680 	andeq	r0, r0, r0, lsl #13
    2c98:	736f701b 	cmnvc	pc, #27
    2c9c:	7b07dc00 	blvc	1f9ca4 <__ROM_SIZE__+0x1b9ca4>
    2ca0:	ac000000 	stcge	0, cr0, [r0], {-0}
    2ca4:	a8000006 	stmdage	r0, {r1, r2}
    2ca8:	0a000006 	beq	2cc8 <cmd_end_+0x27c>
    2cac:	00000a02 	andeq	r0, r0, r2, lsl #20
    2cb0:	007b07dd 	ldrsbteq	r0, [fp], #-125	@ 0xffffff83
    2cb4:	06c00000 	strbeq	r0, [r0], r0
    2cb8:	06bc0000 	ldrteq	r0, [ip], r0
    2cbc:	c8060000 	stmdagt	r6, {}	@ <UNPREDICTABLE>
    2cc0:	4800000c 	stmdami	r0, {r2, r3}
    2cc4:	01000004 	tsteq	r0, r4
    2cc8:	74025001 	strvc	r5, [r2], #-1
    2ccc:	10000000 	andne	r0, r0, r0
    2cd0:	0000071e 	andeq	r0, r0, lr, lsl r7
    2cd4:	000e52b5 			@ <UNDEFINED> instruction: 0x000e52b5
    2cd8:	0000a200 	andeq	sl, r0, r0, lsl #4
    2cdc:	da9c0100 	ble	fe7030e4 <_STACK_TOP_+0xde6fb0e8>
    2ce0:	0500000c 	streq	r0, [r0, #-12]
    2ce4:	0000080c 	andeq	r0, r0, ip, lsl #16
    2ce8:	01961eb5 			@ <UNDEFINED> instruction: 0x01961eb5
    2cec:	06d50000 	ldrbeq	r0, [r5], r0
    2cf0:	06cf0000 	strbeq	r0, [pc], r0
    2cf4:	8d050000 	stchi	0, cr0, [r5, #-0]
    2cf8:	b5000006 	strlt	r0, [r0, #-6]
    2cfc:	000cda2d 	andeq	sp, ip, sp, lsr #20
    2d00:	0006f100 	andeq	pc, r6, r0, lsl #2
    2d04:	0006eb00 	andeq	lr, r6, r0, lsl #22
    2d08:	00691b00 	rsbeq	r1, r9, r0, lsl #22
    2d0c:	007b07ba 	ldrhteq	r0, [fp], #-122	@ 0xffffff86
    2d10:	070b0000 	streq	r0, [fp, -r0]
    2d14:	07070000 	streq	r0, [r7, -r0]
    2d18:	9d0a0000 	stcls	0, cr0, [sl, #-0]
    2d1c:	bb000008 	bllt	2d44 <cmd_end_+0x2f8>
    2d20:	00007b07 	andeq	r7, r0, r7, lsl #22
    2d24:	00071e00 	andeq	r1, r7, r0, lsl #28
    2d28:	00071a00 	andeq	r1, r7, r0, lsl #20
    2d2c:	08370a00 	ldmdaeq	r7!, {r9, fp}
    2d30:	07bc0000 	ldreq	r0, [ip, r0]!
    2d34:	0000007b 	andeq	r0, r0, fp, ror r0
    2d38:	00000735 	andeq	r0, r0, r5, lsr r7
    2d3c:	0000072d 	andeq	r0, r0, sp, lsr #14
    2d40:	000e8202 	andeq	r8, lr, r2, lsl #4
    2d44:	000cdf00 	andeq	sp, ip, r0, lsl #30
    2d48:	000c4a00 	andeq	r4, ip, r0, lsl #20
    2d4c:	50010100 	andpl	r0, r1, r0, lsl #2
    2d50:	00007802 	andeq	r7, r0, r2, lsl #16
    2d54:	000e9402 	andeq	r9, lr, r2, lsl #8
    2d58:	0004ed00 	andeq	lr, r4, r0, lsl #26
    2d5c:	000c6100 	andeq	r6, ip, r0, lsl #2
    2d60:	50010100 	andpl	r0, r1, r0, lsl #2
    2d64:	31c00305 	biccc	r0, r0, r5, lsl #6
    2d68:	02000000 	andeq	r0, r0, #0
    2d6c:	00000eb8 			@ <UNDEFINED> instruction: 0x00000eb8
    2d70:	0000045e 	andeq	r0, r0, lr, asr r4
    2d74:	00000c7b 	andeq	r0, r0, fp, ror ip
    2d78:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    2d7c:	01010078 	tsteq	r1, r8, ror r0
    2d80:	80080252 	andhi	r0, r8, r2, asr r2
    2d84:	0ebe0200 	cdpeq	2, 11, cr0, cr14, cr0, {0}
    2d88:	04480000 	strbeq	r0, [r8], #-0
    2d8c:	0c8f0000 	stceq	0, cr0, [pc], {0}
    2d90:	01010000 	mrseq	r0, (UNDEF: 1)
    2d94:	00780250 	rsbseq	r0, r8, r0, asr r2
    2d98:	0ecc0200 	cdpeq	2, 12, cr0, cr12, cr0, {0}
    2d9c:	04ed0000 	strbteq	r0, [sp], #0
    2da0:	0ca40000 	stceq	0, cr0, [r4]
    2da4:	01010000 	mrseq	r0, (UNDEF: 1)
    2da8:	b8740350 	ldmdalt	r4!, {r4, r6, r8, r9}^
    2dac:	d0040001 	andle	r0, r4, r1
    2db0:	7100000e 	tstvc	r0, lr
    2db4:	02000010 	andeq	r0, r0, #16
    2db8:	00000ed8 	ldrdeq	r0, [r0], -r8
    2dbc:	000004ed 	andeq	r0, r0, sp, ror #9
    2dc0:	00000cc2 	andeq	r0, r0, r2, asr #25
    2dc4:	03500101 	cmpeq	r0, #1073741824	@ 0x40000000
    2dc8:	0001c874 	andeq	ip, r1, r4, ror r8
    2dcc:	000ee206 	andeq	lr, lr, r6, lsl #4
    2dd0:	0004ed00 	andeq	lr, r4, r0, lsl #26
    2dd4:	50010100 	andpl	r0, r1, r0, lsl #2
    2dd8:	01c07403 	biceq	r7, r0, r3, lsl #8
    2ddc:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    2de0:	00000078 	andeq	r0, r0, r8, ror r0
    2de4:	00007b08 	andeq	r7, r0, r8, lsl #22
    2de8:	08242400 	stmdaeq	r4!, {sl, sp}
    2dec:	7ba80000 	blvc	fea02df4 <_STACK_TOP_+0xde9fadf8>
    2df0:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
    2df4:	3c00000d 	stccc	0, cr0, [r0], {13}
    2df8:	01000000 	mrseq	r0, (UNDEF: 0)
    2dfc:	000d599c 	muleq	sp, ip, r9
    2e00:	75732500 	ldrbvc	r2, [r3, #-1280]!	@ 0xfffffb00
    2e04:	961f0062 	ldrls	r0, [pc], -r2, rrx
    2e08:	5a000001 	bpl	2e14 <cmd_end_+0x3c8>
    2e0c:	52000007 	andpl	r0, r0, #7
    2e10:	25000007 	strcs	r0, [r0, #-7]
    2e14:	006e656c 	rsbeq	r6, lr, ip, ror #10
    2e18:	00007b28 	andeq	r7, r0, r8, lsr #22
    2e1c:	00078000 	andeq	r8, r7, r0
    2e20:	00077a00 	andeq	r7, r7, r0, lsl #20
    2e24:	74732500 	ldrbtvc	r2, [r3], #-1280	@ 0xfffffb00
    2e28:	d8390072 	ldmdale	r9!, {r1, r4, r5, r6}
    2e2c:	9c000001 	stcls	0, cr0, [r0], {1}
    2e30:	96000007 	strls	r0, [r0], -r7
    2e34:	3f000007 	svccc	0x00000007
    2e38:	0000000c 	andeq	r0, r0, ip
    2e3c:	00000d48 	andeq	r0, r0, r8, asr #26
    2e40:	ad00691b 	vstrge.16	s12, [r0, #-54]	@ 0xffffffca	@ <UNPREDICTABLE>
    2e44:	00007b0c 	andeq	r7, r0, ip, lsl #22
    2e48:	0007b600 	andeq	fp, r7, r0, lsl #12
    2e4c:	0007b200 	andeq	fp, r7, r0, lsl #4
    2e50:	24060000 	strcs	r0, [r6], #-0
    2e54:	4800000d 	stmdami	r0, {r0, r2, r3}
    2e58:	01000004 	tsteq	r0, r4
    2e5c:	74025001 	strvc	r5, [r2], #-1
    2e60:	24000000 	strcs	r0, [r0], #-0
    2e64:	000006b3 			@ <UNDEFINED> instruction: 0x000006b3
    2e68:	00007b94 	muleq	r0, r4, fp
    2e6c:	000b4400 	andeq	r4, fp, r0, lsl #8
    2e70:	00004000 	andeq	r4, r0, r0
    2e74:	fe9c0100 	cdp2	1, 9, cr0, cr12, cr0, {0}
    2e78:	0500000d 	streq	r0, [r0, #-13]
    2e7c:	000001ed 	andeq	r0, r0, sp, ror #3
    2e80:	007b1d94 			@ <UNDEFINED> instruction: 0x007b1d94
    2e84:	07c90000 	strbeq	r0, [r9, r0]
    2e88:	07c50000 	strbeq	r0, [r5, r0]
    2e8c:	5a050000 	bpl	142e94 <__ROM_SIZE__+0x102e94>
    2e90:	94000001 	strls	r0, [r0], #-1
    2e94:	0001912a 	andeq	r9, r1, sl, lsr #2
    2e98:	0007df00 	andeq	sp, r7, r0, lsl #30
    2e9c:	0007db00 	andeq	sp, r7, r0, lsl #22
    2ea0:	08c90a00 	stmiaeq	r9, {r9, fp}^
    2ea4:	0c950000 	ldceq	0, cr0, [r5], {0}
    2ea8:	00000061 	andeq	r0, r0, r1, rrx
    2eac:	000007f3 	strdeq	r0, [r0], -r3
    2eb0:	000007f1 	strdeq	r0, [r0], -r1
    2eb4:	0009200a 	andeq	r2, r9, sl
    2eb8:	610c9600 	tstvs	ip, r0, lsl #12
    2ebc:	01000000 	mrseq	r0, (UNDEF: 0)
    2ec0:	fb000008 	blx	2eea <cmd_end_+0x49e>
    2ec4:	21000007 	tstcs	r0, r7
    2ec8:	00000b5e 	andeq	r0, r0, lr, asr fp
    2ecc:	00000016 	andeq	r0, r0, r6, lsl r0
    2ed0:	0008cd0a 	andeq	ip, r8, sl, lsl #26
    2ed4:	61119a00 	tstvs	r1, r0, lsl #20
    2ed8:	1b000000 	blne	2ee0 <cmd_end_+0x494>
    2edc:	19000008 	stmdbne	r0, {r3}
    2ee0:	06000008 	streq	r0, [r0], -r8
    2ee4:	00000b6e 	andeq	r0, r0, lr, ror #22
    2ee8:	000004ed 	andeq	r0, r0, sp, ror #9
    2eec:	05500101 	ldrbeq	r0, [r0, #-257]	@ 0xfffffeff
    2ef0:	0030fc03 	eorseq	pc, r0, r3, lsl #24
    2ef4:	51010100 	mrspl	r0, (UNDEF: 17)
    2ef8:	3100740c 	tstcc	r0, ip, lsl #8
    2efc:	0324371a 			@ <UNDEFINED> instruction: 0x0324371a
    2f00:	20000060 	andcs	r0, r0, r0, rrx
    2f04:	00000022 	andeq	r0, r0, r2, lsr #32
    2f08:	0007a710 	andeq	sl, r7, r0, lsl r7
    2f0c:	0c748800 	ldcleq	8, cr8, [r4], #-0
    2f10:	00480000 	subeq	r0, r8, r0
    2f14:	9c010000 	stcls	0, cr0, [r1], {-0}
    2f18:	00000e6c 	andeq	r0, r0, ip, ror #28
    2f1c:	00074205 	andeq	r4, r7, r5, lsl #4
    2f20:	d8308800 	ldmdale	r0!, {fp, pc}
    2f24:	29000001 	stmdbcs	r0, {r0}
    2f28:	23000008 	movwcs	r0, #8
    2f2c:	0a000008 	beq	2f54 <cmd_end_+0x508>
    2f30:	000008cd 	andeq	r0, r0, sp, asr #17
    2f34:	007b078e 	rsbseq	r0, fp, lr, lsl #15
    2f38:	08410000 	stmdaeq	r1, {}^	@ <UNPREDICTABLE>
    2f3c:	083f0000 	ldmdaeq	pc!, {}	@ <UNPREDICTABLE>
    2f40:	80020000 	andhi	r0, r2, r0
    2f44:	8400000c 	strhi	r0, [r0], #-12
    2f48:	55000004 	strpl	r0, [r0, #-4]
    2f4c:	0100000e 	tsteq	r0, lr
    2f50:	75025001 	strvc	r5, [r2, #-1]
    2f54:	51010100 	mrspl	r0, (UNDEF: 17)
    2f58:	31b80305 			@ <UNDEFINED> instruction: 0x31b80305
    2f5c:	06000000 	streq	r0, [r0], -r0
    2f60:	00000ca2 	andeq	r0, r0, r2, lsr #25
    2f64:	0000045e 	andeq	r0, r0, lr, asr r4
    2f68:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    2f6c:	01010075 	tsteq	r1, r5, ror r0
    2f70:	80080252 	andhi	r0, r8, r2, asr r2
    2f74:	67100000 	ldrvs	r0, [r0, -r0]
    2f78:	7b000008 	blvc	2fa0 <cmd_end_+0x554>
    2f7c:	00000dbc 			@ <UNDEFINED> instruction: 0x00000dbc
    2f80:	00000060 	andeq	r0, r0, r0, rrx
    2f84:	0f209c01 	svceq	0x00209c01
    2f88:	0c050000 	stceq	0, cr0, [r5], {-0}
    2f8c:	7b000008 	blvc	2fb4 <cmd_end_+0x568>
    2f90:	00019625 	andeq	r9, r1, r5, lsr #12
    2f94:	00084f00 	andeq	r4, r8, r0, lsl #30
    2f98:	00084900 	andeq	r4, r8, r0, lsl #18
    2f9c:	068d0500 	streq	r0, [sp], r0, lsl #10
    2fa0:	347b0000 	ldrbtcc	r0, [fp], #-0
    2fa4:	00000cda 	ldrdeq	r0, [r0], -sl
    2fa8:	0000086e 	andeq	r0, r0, lr, ror #16
    2fac:	00000868 	andeq	r0, r0, r8, ror #16
    2fb0:	0008cd0a 	andeq	ip, r8, sl, lsl #26
    2fb4:	7b078100 	blvc	1e33bc <__ROM_SIZE__+0x1a33bc>
    2fb8:	89000000 	stmdbhi	r0, {}	@ <UNPREDICTABLE>
    2fbc:	87000008 	strhi	r0, [r0, -r8]
    2fc0:	02000008 	andeq	r0, r0, #8
    2fc4:	00000dca 	andeq	r0, r0, sl, asr #27
    2fc8:	00000426 	andeq	r0, r0, r6, lsr #8
    2fcc:	00000ed8 	ldrdeq	r0, [r0], -r8
    2fd0:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    2fd4:	01010074 	tsteq	r1, r4, ror r0
    2fd8:	01300151 	teqeq	r0, r1, asr r1
    2fdc:	08025201 	stmdaeq	r2, {r0, r9, ip, lr}
    2fe0:	02020080 	andeq	r0, r2, #128	@ 0x80
    2fe4:	5e00000e 	cdppl	0, 0, cr0, cr0, cr14, {0}
    2fe8:	f2000004 	vhadd.s8	d0, d0, d4
    2fec:	0100000e 	tsteq	r0, lr
    2ff0:	74025001 	strvc	r5, [r2], #-1
    2ff4:	52010100 	andpl	r0, r1, #0, 2
    2ff8:	00800802 	addeq	r0, r0, r2, lsl #16
    2ffc:	000e0802 	andeq	r0, lr, r2, lsl #16
    3000:	00044800 	andeq	r4, r4, r0, lsl #16
    3004:	000f0600 	andeq	r0, pc, r0, lsl #12
    3008:	50010100 	andpl	r0, r1, r0, lsl #2
    300c:	00007402 	andeq	r7, r0, r2, lsl #8
    3010:	000e1206 	andeq	r1, lr, r6, lsl #4
    3014:	0004ed00 	andeq	lr, r4, r0, lsl #26
    3018:	50010100 	andpl	r0, r1, r0, lsl #2
    301c:	31bc0305 			@ <UNDEFINED> instruction: 0x31bc0305
    3020:	01010000 	mrseq	r0, (UNDEF: 1)
    3024:	00740251 	rsbseq	r0, r4, r1, asr r2
    3028:	4a100000 	bmi	403030 <__ROM_SIZE__+0x3c3030>
    302c:	6a000007 	bvs	3050 <cmd_end_+0x604>
    3030:	00000d4a 	andeq	r0, r0, sl, asr #26
    3034:	00000072 	andeq	r0, r0, r2, ror r0
    3038:	0feb9c01 	svceq	0x00eb9c01
    303c:	0c050000 	stceq	0, cr0, [r5], {-0}
    3040:	6a000008 	bvs	3068 <cmd_end_+0x61c>
    3044:	00019623 	andeq	r9, r1, r3, lsr #12
    3048:	00089900 	andeq	r9, r8, r0, lsl #18
    304c:	00089100 	andeq	r9, r8, r0, lsl #2
    3050:	068d0500 	streq	r0, [sp], r0, lsl #10
    3054:	326a0000 	rsbcc	r0, sl, #0
    3058:	00000cda 	ldrdeq	r0, [r0], -sl
    305c:	000008be 			@ <UNDEFINED> instruction: 0x000008be
    3060:	000008b6 			@ <UNDEFINED> instruction: 0x000008b6
    3064:	0008cd0a 	andeq	ip, r8, sl, lsl #26
    3068:	7b077400 	blvc	1e0070 <__ROM_SIZE__+0x1a0070>
    306c:	e0000000 	and	r0, r0, r0
    3070:	de000008 	cdple	0, 0, cr0, cr0, cr8, {0}
    3074:	02000008 	andeq	r0, r0, #8
    3078:	00000d6e 	andeq	r0, r0, lr, ror #26
    307c:	000004ed 	andeq	r0, r0, sp, ror #9
    3080:	00000f8a 	andeq	r0, r0, sl, lsl #31
    3084:	05500101 	ldrbeq	r0, [r0, #-257]	@ 0xfffffeff
    3088:	0031bc03 	eorseq	fp, r1, r3, lsl #24
    308c:	51010100 	mrspl	r0, (UNDEF: 17)
    3090:	00007402 	andeq	r7, r0, r2, lsl #8
    3094:	000d7802 	andeq	r7, sp, r2, lsl #16
    3098:	00042600 	andeq	r2, r4, r0, lsl #12
    309c:	000fa300 	andeq	sl, pc, r0, lsl #6
    30a0:	51010100 	mrspl	r0, (UNDEF: 17)
    30a4:	01013001 	tsteq	r1, r1
    30a8:	80080252 	andhi	r0, r8, r2, asr r2
    30ac:	0da00200 	sfmeq	f0, 4, [r0]
    30b0:	045e0000 	ldrbeq	r0, [lr], #-0
    30b4:	0fbd0000 	svceq	0x00bd0000
    30b8:	01010000 	mrseq	r0, (UNDEF: 1)
    30bc:	00740250 	rsbseq	r0, r4, r0, asr r2
    30c0:	02520101 	subseq	r0, r2, #1073741824	@ 0x40000000
    30c4:	02008008 	andeq	r8, r0, #8
    30c8:	00000da6 	andeq	r0, r0, r6, lsr #27
    30cc:	00000448 	andeq	r0, r0, r8, asr #8
    30d0:	00000fd1 	ldrdeq	r0, [r0], -r1
    30d4:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    30d8:	06000074 			@ <UNDEFINED> instruction: 0x06000074
    30dc:	00000db0 			@ <UNDEFINED> instruction: 0x00000db0
    30e0:	000004ed 	andeq	r0, r0, sp, ror #9
    30e4:	05500101 	ldrbeq	r0, [r0, #-257]	@ 0xfffffeff
    30e8:	0031bc03 	eorseq	fp, r1, r3, lsl #24
    30ec:	51010100 	mrspl	r0, (UNDEF: 17)
    30f0:	00007402 	andeq	r7, r0, r2, lsl #8
    30f4:	07291000 	streq	r1, [r9, -r0]!
    30f8:	0c5d0000 	mraeq	r0, sp, acc0
    30fc:	1200000b 	andne	r0, r0, #11
    3100:	01000000 	mrseq	r0, (UNDEF: 0)
    3104:	00101c9c 	mulseq	r0, ip, ip
    3108:	068d0500 	streq	r0, [sp], r0, lsl #10
    310c:	1e5d0000 	cdpne	0, 5, cr0, cr13, cr0, {0}
    3110:	0000007b 	andeq	r0, r0, fp, ror r0
    3114:	000008ec 	andeq	r0, r0, ip, ror #17
    3118:	000008e8 	andeq	r0, r0, r8, ror #17
    311c:	000b1604 	andeq	r1, fp, r4, lsl #12
    3120:	00101c00 	andseq	r1, r0, r0, lsl #24
    3124:	51100000 	tstpl	r0, r0
    3128:	57000008 	strpl	r0, [r0, -r8]
    312c:	00000af0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
    3130:	0000001c 	andeq	r0, r0, ip, lsl r0
    3134:	105b9c01 	subsne	r9, fp, r1, lsl #24
    3138:	fa1a0000 	blx	683140 <__ROM_SIZE__+0x643140>
    313c:	3f00000a 	svccc	0x0000000a
    3140:	01000010 	tsteq	r0, r0, lsl r0
    3144:	38015001 	stmdacc	r1, {r0, ip, lr}
    3148:	0b001a00 	bleq	9950 <__RAM_SIZE__+0x1950>
    314c:	104f0000 	subne	r0, pc, r0
    3150:	01010000 	mrseq	r0, (UNDEF: 1)
    3154:	20080250 	andcs	r0, r8, r0, asr r2
    3158:	0b062200 	bleq	18b960 <__ROM_SIZE__+0x14b960>
    315c:	01010000 	mrseq	r0, (UNDEF: 1)
    3160:	00380150 	eorseq	r0, r8, r0, asr r1
    3164:	06c04000 	strbeq	r4, [r0], r0
    3168:	55010000 	strpl	r0, [r1, #-0]
    316c:	00007b1b 	andeq	r7, r0, fp, lsl fp
    3170:	000ef400 	andeq	pc, lr, r0, lsl #8
    3174:	00000400 	andeq	r0, r0, r0, lsl #8
    3178:	419c0100 	orrsmi	r0, ip, r0, lsl #2
    317c:	00000842 	andeq	r0, r0, r2, asr #16
    3180:	501c4f01 	andspl	r4, ip, r1, lsl #30
    3184:	0200000e 	andeq	r0, r0, #14
    3188:	01000000 	mrseq	r0, (UNDEF: 0)
    318c:	07fb299c 			@ <UNDEFINED> instruction: 0x07fb299c
    3190:	4e4a0000 	cdpmi	0, 4, cr0, cr10, cr0, {0}
    3194:	0200000e 	andeq	r0, r0, #14
    3198:	01000000 	mrseq	r0, (UNDEF: 0)
    319c:	0708299c 			@ <UNDEFINED> instruction: 0x0708299c
    31a0:	4c460000 	marmi	acc0, r0, r6
    31a4:	0200000e 	andeq	r0, r0, #14
    31a8:	01000000 	mrseq	r0, (UNDEF: 0)
    31ac:	03b3269c 			@ <UNDEFINED> instruction: 0x03b3269c
    31b0:	40440000 	submi	r0, r4, r0
    31b4:	0c00000e 	stceq	0, cr0, [r0], {14}
    31b8:	01000000 	mrseq	r0, (UNDEF: 0)
    31bc:	0010c59c 	mulseq	r0, ip, r5
    31c0:	075f1c00 	ldrbeq	r1, [pc, -r0, lsl #24]
    31c4:	1d440000 	stclne	0, cr0, [r4, #-0]
    31c8:	00000312 	andeq	r0, r0, r2, lsl r3
    31cc:	26005001 	strcs	r5, [r0], -r1
    31d0:	000003a4 	andeq	r0, r0, r4, lsr #7
    31d4:	000e3443 	andeq	r3, lr, r3, asr #8
    31d8:	00000c00 	andeq	r0, r0, r0, lsl #24
    31dc:	e79c0100 	ldr	r0, [ip, r0, lsl #2]
    31e0:	1c000010 	stcne	0, cr0, [r0], {16}
    31e4:	0000075f 	andeq	r0, r0, pc, asr r7
    31e8:	03121c43 	tsteq	r2, #17152	@ 0x4300
    31ec:	50010000 	andpl	r0, r1, r0
    31f0:	03952600 	orrseq	r2, r5, #0, 12
    31f4:	28410000 	stmdacs	r1, {}^	@ <UNPREDICTABLE>
    31f8:	0c00000e 	stceq	0, cr0, [r0], {14}
    31fc:	01000000 	mrseq	r0, (UNDEF: 0)
    3200:	0011099c 	mulseq	r1, ip, r9
    3204:	075f1c00 	ldrbeq	r1, [pc, -r0, lsl #24]
    3208:	1b410000 	blne	1043210 <__ROM_SIZE__+0x1003210>
    320c:	000002e0 	andeq	r0, r0, r0, ror #5
    3210:	42005001 	andmi	r5, r0, #1
    3214:	000003c3 	andeq	r0, r0, r3, asr #7
    3218:	1c064001 	stcne	0, cr4, [r6], {1}
    321c:	0c00000e 	stceq	0, cr0, [r0], {14}
    3220:	01000000 	mrseq	r0, (UNDEF: 0)
    3224:	075f1c9c 			@ <UNDEFINED> instruction: 0x075f1c9c
    3228:	1a400000 	bne	1003230 <__ROM_SIZE__+0xfc3230>
    322c:	000002e0 	andeq	r0, r0, r0, ror #5
    3230:	00005001 	andeq	r5, r0, r1
    3234:	00000305 	andeq	r0, r0, r5, lsl #6
    3238:	04010005 	streq	r0, [r1], #-5
    323c:	0000113c 	andeq	r1, r0, ip, lsr r1
    3240:	0000460b 	andeq	r4, r0, fp, lsl #12
    3244:	097e1d00 	ldmdbeq	lr!, {r8, sl, fp, ip}^
    3248:	00140000 	andseq	r0, r4, r0
    324c:	11040000 	mrsne	r0, (UNDEF: 4)
    3250:	025c0000 	subseq	r0, ip, #0
    3254:	1c430000 	marne	acc0, r0, r3
    3258:	e7030000 	str	r0, [r3, -r0]
    325c:	5e000000 	cdppl	0, 0, cr0, cr0, cr0, {0}
    3260:	0001310e 	andeq	r3, r1, lr, lsl #2
    3264:	0012a400 	andseq	sl, r2, r0, lsl #8
    3268:	0000bc00 	andeq	fp, r0, r0, lsl #24
    326c:	319c0100 	orrscc	r0, ip, r0, lsl #2
    3270:	02000001 	andeq	r0, r0, #1
    3274:	000009e8 	andeq	r0, r0, r8, ror #19
    3278:	01382a5e 	teqeq	r8, lr, asr sl
    327c:	090b0000 	stmdbeq	fp, {}	@ <UNPREDICTABLE>
    3280:	09070000 	stmdbeq	r7, {}	@ <UNPREDICTABLE>
    3284:	71020000 	mrsvc	r0, (UNDEF: 2)
    3288:	5e000009 	cdppl	0, 0, cr0, cr0, cr9, {0}
    328c:	00013140 	andeq	r3, r1, r0, asr #2
    3290:	00091e00 	andeq	r1, r9, r0, lsl #28
    3294:	00091a00 	andeq	r1, r9, r0, lsl #20
    3298:	09590200 	ldmdbeq	r9, {r9}^
    329c:	5c5e0000 	mrapl	r0, lr, acc0
    32a0:	00000138 	andeq	r0, r0, r8, lsr r1
    32a4:	00000934 	andeq	r0, r0, r4, lsr r9
    32a8:	00000930 	andeq	r0, r0, r0, lsr r9
    32ac:	0009c904 	andeq	ip, r9, r4, lsl #18
    32b0:	31105f00 	tstcc	r0, r0, lsl #30
    32b4:	47000001 	strmi	r0, [r0, -r1]
    32b8:	43000009 	movwmi	r0, #9
    32bc:	06000009 	streq	r0, [r0], -r9
    32c0:	000012b2 			@ <UNDEFINED> instruction: 0x000012b2
    32c4:	00000048 	andeq	r0, r0, r8, asr #32
    32c8:	000000df 	ldrdeq	r0, [r0], -pc	@ <UNPREDICTABLE>
    32cc:	62006907 	andvs	r6, r0, #114688	@ 0x1c000
    32d0:	00000131 	andeq	r0, r0, r1, lsr r1
    32d4:	0000095a 	andeq	r0, r0, sl, asr r9
    32d8:	00000956 	andeq	r0, r0, r6, asr r9
    32dc:	0012bc01 	andseq	fp, r2, r1, lsl #24
    32e0:	0002b700 	andeq	fp, r2, r0, lsl #14
    32e4:	12c40100 	sbcne	r0, r4, #0, 2
    32e8:	02b70000 	adcseq	r0, r7, #0
    32ec:	d0010000 	andle	r0, r1, r0
    32f0:	b7000012 	smladlt	r0, r2, r0, r0
    32f4:	01000002 	tsteq	r0, r2
    32f8:	000012d8 	ldrdeq	r1, [r0], -r8
    32fc:	000002b7 			@ <UNDEFINED> instruction: 0x000002b7
    3300:	0012e401 	andseq	lr, r2, r1, lsl #8
    3304:	0002b700 	andeq	fp, r2, r0, lsl #14
    3308:	12ec0100 	rscne	r0, ip, #0, 2
    330c:	02b70000 	adcseq	r0, r7, #0
    3310:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
    3314:	000012b0 			@ <UNDEFINED> instruction: 0x000012b0
    3318:	0000022e 	andeq	r0, r0, lr, lsr #4
    331c:	000000fa 	strdeq	r0, [r0], -sl
    3320:	02500105 	subseq	r0, r0, #1073741825	@ 0x40000001
    3324:	01050074 	tsteq	r5, r4, ror r0
    3328:	01a30351 			@ <UNDEFINED> instruction: 0x01a30351
    332c:	20010051 	andcs	r0, r1, r1, asr r0
    3330:	b7000013 	smladlt	r0, r3, r0, r0
    3334:	01000002 	tsteq	r0, r2
    3338:	00001328 	andeq	r1, r0, r8, lsr #6
    333c:	000002b7 			@ <UNDEFINED> instruction: 0x000002b7
    3340:	00133601 	andseq	r3, r3, r1, lsl #12
    3344:	0002b700 	andeq	fp, r2, r0, lsl #14
    3348:	133e0100 	teqne	lr, #0, 2
    334c:	02b70000 	adcseq	r0, r7, #0
    3350:	4a010000 	bmi	43358 <__ROM_SIZE__+0x3358>
    3354:	b7000013 	smladlt	r0, r3, r0, r0
    3358:	01000002 	tsteq	r0, r2
    335c:	00001352 	andeq	r1, r0, r2, asr r3
    3360:	000002b7 			@ <UNDEFINED> instruction: 0x000002b7
    3364:	07040900 	streq	r0, [r4, -r0, lsl #18]
    3368:	0000017b 	andeq	r0, r0, fp, ror r1
    336c:	013e040c 	teqeq	lr, ip, lsl #8
    3370:	01090000 	mrseq	r0, (UNDEF: 9)
    3374:	00012b08 	andeq	r2, r1, r8, lsl #22
    3378:	04680300 	strbteq	r0, [r8], #-768	@ 0xfffffd00
    337c:	0e380000 	cdpeq	0, 3, cr0, cr8, cr0, {0}
    3380:	00000131 	andeq	r0, r0, r1, lsr r1
    3384:	000011bc 			@ <UNDEFINED> instruction: 0x000011bc
    3388:	000000e8 	andeq	r0, r0, r8, ror #1
    338c:	022e9c01 	eoreq	r9, lr, #256	@ 0x100
    3390:	e8020000 	stmda	r2, {}	@ <UNPREDICTABLE>
    3394:	38000009 	stmdacc	r0, {r0, r3}
    3398:	0001382a 	andeq	r3, r1, sl, lsr #16
    339c:	00096e00 	andeq	r6, r9, r0, lsl #28
    33a0:	00096a00 	andeq	r6, r9, r0, lsl #20
    33a4:	09710200 	ldmdbeq	r1!, {r9}^
    33a8:	40380000 	eorsmi	r0, r8, r0
    33ac:	00000131 	andeq	r0, r0, r1, lsr r1
    33b0:	00000981 	andeq	r0, r0, r1, lsl #19
    33b4:	0000097d 	andeq	r0, r0, sp, ror r9
    33b8:	00095902 	andeq	r5, r9, r2, lsl #18
    33bc:	385c3800 	ldmdacc	ip, {fp, ip, sp}^
    33c0:	94000001 	strls	r0, [r0], #-1
    33c4:	90000009 	andls	r0, r0, r9
    33c8:	04000009 	streq	r0, [r0], #-9
    33cc:	0000094f 	andeq	r0, r0, pc, asr #18
    33d0:	01311039 	teqeq	r1, r9, lsr r0
    33d4:	09a50000 	stmibeq	r5!, {}	@ <UNPREDICTABLE>
    33d8:	09a30000 	stmibeq	r3!, {}	@ <UNPREDICTABLE>
    33dc:	ce060000 	cdpgt	0, 0, cr0, cr6, cr0, {0}
    33e0:	4c000011 	stcmi	0, cr0, [r0], {17}
    33e4:	ec000000 	stc	0, cr0, [r0], {-0}
    33e8:	07000001 	streq	r0, [r0, -r1]
    33ec:	313c0069 	teqcc	ip, r9, rrx
    33f0:	b1000001 	tstlt	r0, r1
    33f4:	ad000009 	stcge	0, cr0, [r0, #-36]	@ 0xffffffdc
    33f8:	01000009 	tsteq	r0, r9
    33fc:	000011da 	ldrdeq	r1, [r0], -sl
    3400:	000002e1 	andeq	r0, r0, r1, ror #5
    3404:	0011ee01 	andseq	lr, r1, r1, lsl #28
    3408:	0002e100 	andeq	lr, r2, r0, lsl #2
    340c:	12020100 	andne	r0, r2, #0, 2
    3410:	02e10000 	rsceq	r0, r1, #0
    3414:	0e010000 	cdpeq	0, 0, cr0, cr1, cr0, {0}
    3418:	e1000012 	tst	r0, r2, lsl r0
    341c:	00000002 	andeq	r0, r0, r2
    3420:	00123c08 	andseq	r3, r2, r8, lsl #24
    3424:	00028a00 	andeq	r8, r2, r0, lsl #20
    3428:	00020000 	andeq	r0, r2, r0
    342c:	50010500 	andpl	r0, r1, r0, lsl #10
    3430:	00007802 	andeq	r7, r0, r2, lsl #16
    3434:	00124c01 	andseq	r4, r2, r1, lsl #24
    3438:	0002e100 	andeq	lr, r2, r0, lsl #2
    343c:	125a0100 	subsne	r0, sl, #0, 2
    3440:	02e10000 	rsceq	r0, r1, #0
    3444:	70010000 	andvc	r0, r1, r0
    3448:	e1000012 	tst	r0, r2, lsl r0
    344c:	01000002 	tsteq	r0, r2
    3450:	00001284 	andeq	r1, r0, r4, lsl #5
    3454:	000002e1 	andeq	r0, r0, r1, ror #5
    3458:	00129201 	andseq	r9, r2, r1, lsl #4
    345c:	0002e100 	andeq	lr, r2, r0, lsl #2
    3460:	f4030000 	vst4.8	{d0-d3}, [r3], r0
    3464:	2d000009 	stccs	0, cr0, [r0, #-36]	@ 0xffffffdc
    3468:	0001310e 	andeq	r3, r1, lr, lsl #2
    346c:	00118800 	andseq	r8, r1, r0, lsl #16
    3470:	00003400 	andeq	r3, r0, r0, lsl #8
    3474:	8a9c0100 	bhi	fe70387c <_STACK_TOP_+0xde6fb880>
    3478:	02000002 	andeq	r0, r0, #2
    347c:	000009e8 	andeq	r0, r0, r8, ror #19
    3480:	0138312d 	teqeq	r8, sp, lsr #2
    3484:	09c50000 	stmibeq	r5, {}^	@ <UNPREDICTABLE>
    3488:	09c10000 	stmibeq	r1, {}^	@ <UNPREDICTABLE>
    348c:	71020000 	mrsvc	r0, (UNDEF: 2)
    3490:	2d000009 	stccs	0, cr0, [r0, #-36]	@ 0xffffffdc
    3494:	00013147 	andeq	r3, r1, r7, asr #2
    3498:	0009da00 	andeq	sp, r9, r0, lsl #20
    349c:	0009d400 	andeq	sp, r9, r0, lsl #8
    34a0:	09ee0400 	stmibeq	lr!, {sl}^
    34a4:	122e0000 	eorne	r0, lr, #0
    34a8:	00000138 	andeq	r0, r0, r8, lsr r1
    34ac:	000009f4 	strdeq	r0, [r0], -r4
    34b0:	000009f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
    34b4:	00119a01 	andseq	r9, r1, r1, lsl #20
    34b8:	0002b700 	andeq	fp, r2, r0, lsl #14
    34bc:	b4030000 	strlt	r0, [r3], #-0
    34c0:	29000009 	stmdbcs	r0, {r0, r3}
    34c4:	0001310e 	andeq	r3, r1, lr, lsl #2
    34c8:	00117400 	andseq	r7, r1, r0, lsl #8
    34cc:	00001400 	andeq	r1, r0, r0, lsl #8
    34d0:	b79c0100 	ldrlt	r0, [ip, r0, lsl #2]
    34d4:	02000002 	andeq	r0, r0, #2
    34d8:	00000971 	andeq	r0, r0, r1, ror r9
    34dc:	01313029 	teqeq	r1, r9, lsr #32
    34e0:	0a090000 	beq	2434e8 <__ROM_SIZE__+0x2034e8>
    34e4:	0a030000 	beq	c34ec <__ROM_SIZE__+0x834ec>
    34e8:	03000000 	movweq	r0, #0
    34ec:	00000960 	andeq	r0, r0, r0, ror #18
    34f0:	013e0f16 	teqeq	lr, r6, lsl pc
    34f4:	11360000 	teqne	r6, r0
    34f8:	003e0000 	eorseq	r0, lr, r0
    34fc:	9c010000 	stcls	0, cr0, [r1], {-0}
    3500:	000002e1 	andeq	r0, r0, r1, ror #5
    3504:	1600630a 	strne	r6, [r0], -sl, lsl #6
    3508:	0000013e 	andeq	r0, r0, lr, lsr r1
    350c:	00000a23 	andeq	r0, r0, r3, lsr #20
    3510:	00000a1f 	andeq	r0, r0, pc, lsl sl
    3514:	09d70d00 	ldmibeq	r7, {r8, sl, fp}^
    3518:	03010000 	movweq	r0, #4096	@ 0x1000
    351c:	00013e0f 	andeq	r3, r1, pc, lsl #28
    3520:	00110400 	andseq	r0, r1, r0, lsl #8
    3524:	00003200 	andeq	r3, r0, r0, lsl #4
    3528:	0a9c0100 	beq	fe703930 <_STACK_TOP_+0xde6fb934>
    352c:	3e030076 	mcrcc	0, 0, r0, cr3, cr6, {3}
    3530:	49000001 	stmdbmi	r0, {r0}
    3534:	3100000a 	tstcc	r0, sl
    3538:	0000000a 	andeq	r0, r0, sl
    353c:	0003b500 	andeq	fp, r3, r0, lsl #10
    3540:	01000500 	tsteq	r0, r0, lsl #10
    3544:	00121b04 	andseq	r1, r2, r4, lsl #22
    3548:	00461100 	subeq	r1, r6, r0, lsl #2
    354c:	091d0000 	ldmdbeq	sp, {}	@ <UNPREDICTABLE>
    3550:	1400000a 	strne	r0, [r0], #-10
    3554:	60000000 	andvs	r0, r0, r0
    3558:	ee000013 	mcr	0, 0, r0, cr0, cr3, {0}
    355c:	ad000002 	stcge	0, cr0, [r0, #-8]
    3560:	04000020 	streq	r0, [r0], #-32	@ 0xffffffe0
    3564:	0000000d 	andeq	r0, r0, sp
    3568:	3217d602 	andscc	sp, r7, #2097152	@ 0x200000
    356c:	02000000 	andeq	r0, r0, #0
    3570:	017b0704 	cmneq	fp, r4, lsl #14
    3574:	04120000 	ldreq	r0, [r2], #-0
    3578:	746e6905 	strbtvc	r6, [lr], #-2309	@ 0xfffff6fb
    357c:	05080200 	streq	r0, [r8, #-512]	@ 0xfffffe00
    3580:	000001c2 	andeq	r0, r0, r2, asr #3
    3584:	25040802 	strcs	r0, [r4, #-2050]	@ 0xfffff7fe
    3588:	02000002 	andeq	r0, r0, #2
    358c:	012d0601 			@ <UNDEFINED> instruction: 0x012d0601
    3590:	01020000 	mrseq	r0, (UNDEF: 2)
    3594:	00012b08 	andeq	r2, r1, r8, lsl #22
    3598:	05020200 	streq	r0, [r2, #-512]	@ 0xfffffe00
    359c:	000001e3 	andeq	r0, r0, r3, ror #3
    35a0:	39070202 	stmdbcc	r7, {r1, r9}
    35a4:	02000001 	andeq	r0, r0, #1
    35a8:	01c70504 	biceq	r0, r7, r4, lsl #10
    35ac:	04020000 	streq	r0, [r2], #-0
    35b0:	00017607 	andeq	r7, r1, r7, lsl #12
    35b4:	07080200 	streq	r0, [r8, -r0, lsl #4]
    35b8:	00000171 	andeq	r0, r0, r1, ror r1
    35bc:	01020413 	tsteq	r2, r3, lsl r4
    35c0:	00013408 	andeq	r3, r1, r8, lsl #8
    35c4:	00e20400 	rsceq	r0, r2, r0, lsl #8
    35c8:	13030000 	movwne	r0, #12288	@ 0x3000
    35cc:	00005517 	andeq	r5, r0, r7, lsl r5
    35d0:	00880900 	addeq	r0, r8, r0, lsl #18
    35d4:	c9040000 	stmdbgt	r4, {}	@ <UNPREDICTABLE>
    35d8:	03000000 	movweq	r0, #0
    35dc:	00321714 	eorseq	r1, r2, r4, lsl r7
    35e0:	99090000 	stmdbls	r9, {}	@ <UNPREDICTABLE>
    35e4:	14000000 	strne	r0, [r0], #-0
    35e8:	09160370 	ldmdbeq	r6, {r4, r5, r6, r8, r9}
    35ec:	000000e4 	andeq	r0, r0, r4, ror #1
    35f0:	00079005 	andeq	r9, r7, r5
    35f4:	e4071700 	str	r1, [r7], #-1792	@ 0xfffff900
    35f8:	00000000 	andeq	r0, r0, r0
    35fc:	0000c105 	andeq	ip, r0, r5, lsl #2
    3600:	99071800 	stmdbls	r7, {fp, ip}
    3604:	40000000 	andmi	r0, r0, r0
    3608:	00015f05 	andeq	r5, r1, r5, lsl #30
    360c:	78151900 	ldmdavc	r5, {r8, fp, ip}
    3610:	48000000 	stmdami	r0, {}	@ <UNPREDICTABLE>
    3614:	000b2e05 	andeq	r2, fp, r5, lsl #28
    3618:	f4071a00 	vst1.8	{d1-d2}, [r7], r0
    361c:	50000000 	andpl	r0, r0, r0
    3620:	00880a00 	addeq	r0, r8, r0, lsl #20
    3624:	00f40000 	rscseq	r0, r4, r0
    3628:	32060000 	andcc	r0, r6, #0
    362c:	3f000000 	svccc	0x00000000
    3630:	00990a00 	addseq	r0, r9, r0, lsl #20
    3634:	01040000 	mrseq	r0, (UNDEF: 4)
    3638:	32060000 	andcc	r0, r6, #0
    363c:	07000000 	streq	r0, [r0, -r0]
    3640:	01660400 	cmneq	r6, r0, lsl #8
    3644:	1b030000 	blne	c364c <__ROM_SIZE__+0x8364c>
    3648:	0000aa03 	andeq	sl, r0, r3, lsl #20
    364c:	00a50a00 	adceq	r0, r5, r0, lsl #20
    3650:	01200000 			@ <UNDEFINED> instruction: 0x01200000
    3654:	32060000 	andcc	r0, r6, #0
    3658:	3f000000 	svccc	0x00000000
    365c:	01100900 	tsteq	r0, r0, lsl #18
    3660:	6b0e0000 	blvs	383668 <__ROM_SIZE__+0x343668>
    3664:	20132000 	andscs	r2, r3, r0
    3668:	05000001 	streq	r0, [r0, #-1]
    366c:	00326c03 	eorseq	r6, r2, r3, lsl #24
    3670:	076a1500 	strbeq	r1, [sl, -r0, lsl #10]!
    3674:	41040000 	mrsmi	r0, (UNDEF: 4)
    3678:	00007f07 	andeq	r7, r0, r7, lsl #30
    367c:	00015400 	andeq	r5, r1, r0, lsl #8
    3680:	007f0b00 	rsbseq	r0, pc, r0, lsl #22
    3684:	390b0000 	stmdbcc	fp, {}	@ <UNPREDICTABLE>
    3688:	0b000000 	bleq	3690 <sbox+0x7c>
    368c:	00000026 	andeq	r0, r0, r6, lsr #32
    3690:	01050700 	tsteq	r5, r0, lsl #14
    3694:	68720000 	ldmdavs	r2!, {}^	@ <UNPREDICTABLE>
    3698:	e6000015 			@ <UNDEFINED> instruction: 0xe6000015
    369c:	01000000 	mrseq	r0, (UNDEF: 0)
    36a0:	0001ef9c 	muleq	r1, ip, pc	@ <UNPREDICTABLE>
    36a4:	74630800 	strbtvc	r0, [r3], #-2048	@ 0xfffff800
    36a8:	1f720078 	svcne	0x00720078
    36ac:	000001ef 	andeq	r0, r0, pc, ror #3
    36b0:	00000aac 	andeq	r0, r0, ip, lsr #21
    36b4:	00000aa4 	andeq	r0, r0, r4, lsr #21
    36b8:	000a3f0c 	andeq	r3, sl, ip, lsl #30
    36bc:	f4297200 	vld1.8	{d7-d10}, [r9], r0
    36c0:	d1000001 	tstle	r0, r1
    36c4:	c900000a 	stmdbgt	r0, {r1, r3}
    36c8:	0100000a 	tsteq	r0, sl
    36cc:	07740069 	ldrbeq	r0, [r4, -r9, rrx]!
    36d0:	00000099 	muleq	r0, r9, r0
    36d4:	00000b02 	andeq	r0, r0, r2, lsl #22
    36d8:	00000aee 	andeq	r0, r0, lr, ror #21
    36dc:	0015cc0f 	andseq	ip, r5, pc, lsl #24
    36e0:	00029600 	andeq	r9, r2, r0, lsl #12
    36e4:	0001b900 	andeq	fp, r1, r0, lsl #18
    36e8:	50010300 	andpl	r0, r1, r0, lsl #6
    36ec:	03007402 	movweq	r7, #1026	@ 0x402
    36f0:	74025101 	strvc	r5, [r2], #-257	@ 0xfffffeff
    36f4:	ea0f0000 	b	3c36fc <__ROM_SIZE__+0x3836fc>
    36f8:	96000015 			@ <UNDEFINED> instruction: 0x96000015
    36fc:	d3000002 	movwle	r0, #2
    3700:	03000001 	movweq	r0, #1
    3704:	74025001 	strvc	r5, [r2], #-1
    3708:	51010300 	mrspl	r0, SP_irq
    370c:	00007402 	andeq	r7, r0, r2, lsl #8
    3710:	0015f410 	andseq	pc, r5, r0, lsl r4	@ <UNPREDICTABLE>
    3714:	00013400 	andeq	r3, r1, r0, lsl #8
    3718:	50010300 	andpl	r0, r1, r0, lsl #6
    371c:	03007402 	movweq	r7, #1026	@ 0x402
    3720:	30015101 	andcc	r5, r1, r1, lsl #2
    3724:	02520103 	subseq	r0, r2, #-1073741824	@ 0xc0000000
    3728:	00003808 	andeq	r3, r0, r8, lsl #16
    372c:	0001040d 	andeq	r0, r1, sp, lsl #8
    3730:	00880d00 	addeq	r0, r8, r0, lsl #26
    3734:	4c070000 	stcmi	0, cr0, [r7], {-0}
    3738:	63000001 	movwvs	r0, #1
    373c:	00001528 	andeq	r1, r0, r8, lsr #10
    3740:	00000040 	andeq	r0, r0, r0, asr #32
    3744:	026e9c01 	rsbeq	r9, lr, #256	@ 0x100
    3748:	63080000 	movwvs	r0, #32768	@ 0x8000
    374c:	63007874 	movwvs	r7, #2164	@ 0x874
    3750:	0001ef20 	andeq	lr, r1, r0, lsr #30
    3754:	000b5200 	andeq	r5, fp, r0, lsl #4
    3758:	000b4e00 	andeq	r4, fp, r0, lsl #28
    375c:	07900c00 	ldreq	r0, [r0, r0, lsl #24]
    3760:	30630000 	rsbcc	r0, r3, r0
    3764:	0000026e 	andeq	r0, r0, lr, ror #4
    3768:	00000b65 	andeq	r0, r0, r5, ror #22
    376c:	00000b61 	andeq	r0, r0, r1, ror #22
    3770:	6e656c08 	cdpvs	12, 6, cr6, cr5, cr8, {0}
    3774:	263f6300 	ldrtcs	r6, [pc], -r0, lsl #6
    3778:	78000000 	stmdavc	r0, {}	@ <UNPREDICTABLE>
    377c:	7400000b 	strvc	r0, [r0], #-11
    3780:	0100000b 	tsteq	r0, fp
    3784:	07650069 	strbeq	r0, [r5, -r9, rrx]!
    3788:	00000099 	muleq	r0, r9, r0
    378c:	00000b8b 	andeq	r0, r0, fp, lsl #23
    3790:	00000b87 	andeq	r0, r0, r7, lsl #23
    3794:	00155010 	andseq	r5, r5, r0, lsl r0
    3798:	00029600 	andeq	r9, r2, r0, lsl #12
    379c:	50010300 	andpl	r0, r1, r0, lsl #6
    37a0:	03007402 	movweq	r7, #1026	@ 0x402
    37a4:	74025101 	strvc	r5, [r2], #-257	@ 0xfffffeff
    37a8:	0d000000 	stceq	0, cr0, [r0, #-0]
    37ac:	00000094 	muleq	r0, r4, r0
    37b0:	00011f07 	andeq	r1, r1, r7, lsl #30
    37b4:	14d45500 	ldrbne	r5, [r4], #1280	@ 0x500
    37b8:	00540000 	subseq	r0, r4, r0
    37bc:	9c010000 	stcls	0, cr0, [r1], {-0}
    37c0:	00000296 	muleq	r0, r6, r2
    37c4:	78746316 	ldmdavc	r4!, {r1, r2, r4, r8, r9, sp, lr}^
    37c8:	1e550100 	rdfnes	f0, f5, f0
    37cc:	000001ef 	andeq	r0, r0, pc, ror #3
    37d0:	07005001 	streq	r5, [r0, -r1]
    37d4:	00000a44 	andeq	r0, r0, r4, asr #20
    37d8:	0013602c 	andseq	r6, r3, ip, lsr #32
    37dc:	00017400 	andeq	r7, r1, r0, lsl #8
    37e0:	ac9c0100 	ldfges	f0, [ip], {0}
    37e4:	08000003 	stmdaeq	r0, {r0, r1}
    37e8:	00787463 	rsbseq	r7, r8, r3, ror #8
    37ec:	01ef232c 	mvneq	r2, ip, lsr #6
    37f0:	0ba10000 	bleq	fe8437f8 <_STACK_TOP_+0xde83b7fc>
    37f4:	0b9b0000 	bleq	fe6c37fc <_STACK_TOP_+0xde6bb800>
    37f8:	900c0000 	andls	r0, ip, r0
    37fc:	2c000007 	stccs	0, cr0, [r0], {7}
    3800:	00026e33 	andeq	r6, r2, r3, lsr lr
    3804:	000bbb00 	andeq	fp, fp, r0, lsl #22
    3808:	000bb700 	andeq	fp, fp, r0, lsl #14
    380c:	00610100 	rsbeq	r0, r1, r0, lsl #2
    3810:	0099072e 	addseq	r0, r9, lr, lsr #14
    3814:	0bd20000 	bleq	ff48381c <_STACK_TOP_+0xdf47b820>
    3818:	0bca0000 	bleq	ff283820 <_STACK_TOP_+0xdf27b824>
    381c:	62010000 	andvs	r0, r1, #0
    3820:	990a2e00 	stmdbls	sl, {r9, sl, fp, sp}
    3824:	fc000000 	stc2	0, cr0, [r0], {-0}
    3828:	f400000b 	vst4.8	{d0-d3}, [r0], fp
    382c:	0100000b 	tsteq	r0, fp
    3830:	0d2e0063 	stceq	0, cr0, [lr, #-396]!	@ 0xfffffe74
    3834:	00000099 	muleq	r0, r9, r0
    3838:	00000c21 	andeq	r0, r0, r1, lsr #24
    383c:	00000c19 	andeq	r0, r0, r9, lsl ip
    3840:	2e006401 	cdpcs	4, 0, cr6, cr0, cr1, {0}
    3844:	00009910 	andeq	r9, r0, r0, lsl r9
    3848:	000c4600 	andeq	r4, ip, r0, lsl #12
    384c:	000c3e00 	andeq	r3, ip, r0, lsl #28
    3850:	00650100 	rsbeq	r0, r5, r0, lsl #2
    3854:	0099132e 	addseq	r1, r9, lr, lsr #6
    3858:	0c690000 	stcleq	0, cr0, [r9], #-0
    385c:	0c630000 	stcleq	0, cr0, [r3], #-0
    3860:	66010000 	strvs	r0, [r1], -r0
    3864:	99162e00 	ldmdbls	r6, {r9, sl, fp, sp}
    3868:	8a000000 	bhi	3870 <base_x+0x8>
    386c:	8400000c 	strhi	r0, [r0], #-12
    3870:	0100000c 	tsteq	r0, ip
    3874:	192e0067 	stmdbne	lr!, {r0, r1, r2, r5, r6}
    3878:	00000099 	muleq	r0, r9, r0
    387c:	00000ca6 	andeq	r0, r0, r6, lsr #25
    3880:	00000ca0 	andeq	r0, r0, r0, lsr #25
    3884:	2e006801 	cdpcs	8, 0, cr6, cr0, cr1, {0}
    3888:	0000991c 	andeq	r9, r0, ip, lsl r9
    388c:	000cc400 	andeq	ip, ip, r0, lsl #8
    3890:	000cbc00 	andeq	fp, ip, r0, lsl #24
    3894:	00690100 	rsbeq	r0, r9, r0, lsl #2
    3898:	00991f2e 	addseq	r1, r9, lr, lsr #30
    389c:	0ce90000 	stcleq	0, cr0, [r9]
    38a0:	0ce10000 	stcleq	0, cr0, [r1]
    38a4:	6a010000 	bvs	438ac <__ROM_SIZE__+0x38ac>
    38a8:	99222e00 	stmdbls	r2!, {r9, sl, fp, sp}
    38ac:	09000000 	stmdbeq	r0, {}	@ <UNPREDICTABLE>
    38b0:	0500000d 	streq	r0, [r0, #-13]
    38b4:	0100000d 	tsteq	r0, sp
    38b8:	2e003174 	mcrcs	1, 0, r3, cr0, cr4, {3}
    38bc:	00009925 	andeq	r9, r0, r5, lsr #18
    38c0:	000d1700 	andeq	r1, sp, r0, lsl #14
    38c4:	000d1500 	andeq	r1, sp, r0, lsl #10
    38c8:	32740100 	rsbscc	r0, r4, #0, 2
    38cc:	99292e00 	stmdbls	r9!, {r9, sl, fp, sp}
    38d0:	21000000 	mrscs	r0, (UNDEF: 0)
    38d4:	1f00000d 	svcne	0x0000000d
    38d8:	0e00000d 	cdpeq	0, 0, cr0, cr0, cr13, {0}
    38dc:	2d2e006d 	stccs	0, cr0, [lr, #-436]!	@ 0xfffffe4c
    38e0:	000003ac 	andeq	r0, r0, ip, lsr #7
    38e4:	7dd89103 	ldfvcp	f1, [r8, #12]
    38e8:	00991700 	addseq	r1, r9, r0, lsl #14
    38ec:	32060000 	andcc	r0, r6, #0
    38f0:	3f000000 	svccc	0x00000000
    38f4:	032b0000 			@ <UNDEFINED> instruction: 0x032b0000
    38f8:	00050000 	andeq	r0, r5, r0
    38fc:	13600401 	cmnne	r0, #16777216	@ 0x1000000
    3900:	46100000 	ldrmi	r0, [r0], -r0
    3904:	1d000000 	stcne	0, cr0, [r0, #-0]
    3908:	00000aa2 	andeq	r0, r0, r2, lsr #21
    390c:	00000014 	andeq	r0, r0, r4, lsl r0
    3910:	00001650 	andeq	r1, r0, r0, asr r6
    3914:	00000238 	andeq	r0, r0, r8, lsr r2
    3918:	000026ad 	andeq	r2, r0, sp, lsr #13
    391c:	000aef04 	andeq	lr, sl, r4, lsl #30
    3920:	1b280200 	blne	a04128 <__ROM_SIZE__+0x9c4128>
    3924:	00000032 	andeq	r0, r0, r2, lsr r0
    3928:	000a9811 	andeq	r9, sl, r1, lsl r8
    392c:	00030400 	andeq	r0, r3, r0, lsl #8
    3930:	00000049 	andeq	r0, r0, r9, asr #32
    3934:	000b2112 	andeq	r2, fp, r2, lsl r1
    3938:	00004900 	andeq	r4, r0, r0, lsl #18
    393c:	13000000 	movwne	r0, #0
    3940:	0a9a0404 	beq	fe684958 <_STACK_TOP_+0xde67c95c>
    3944:	63020000 	movwvs	r0, #8192	@ 0x2000
    3948:	00002618 	andeq	r2, r0, r8, lsl r6
    394c:	05041400 	streq	r1, [r4, #-1024]	@ 0xfffffc00
    3950:	00746e69 	rsbseq	r6, r4, r9, ror #28
    3954:	00006915 	andeq	r6, r0, r5, lsl r9
    3958:	00691600 	rsbeq	r1, r9, r0, lsl #12
    395c:	03000000 	movweq	r0, #0
    3960:	01340801 	teqeq	r4, r1, lsl #16
    3964:	69170000 	ldmdbvs	r7, {}	@ <UNPREDICTABLE>
    3968:	18000000 	stmdane	r0, {}	@ <UNPREDICTABLE>
    396c:	00000858 	andeq	r0, r0, r8, asr r8
    3970:	810f1801 	tsthi	pc, r1, lsl #16
    3974:	05000000 	streq	r0, [r0, #-0]
    3978:	0000005e 	andeq	r0, r0, lr, asr r0
    397c:	a1010719 	tstge	r1, r9, lsl r7
    3980:	01000000 	mrseq	r0, (UNDEF: 0)
    3984:	00a10e23 	adceq	r0, r1, r3, lsr #28
    3988:	130a0000 	movwne	r0, #40960	@ 0xa000
    398c:	0000000b 	andeq	r0, r0, fp
    3990:	000a710a 	andeq	r7, sl, sl, lsl #2
    3994:	03000100 	movweq	r0, #256	@ 0x100
    3998:	012b0801 			@ <UNDEFINED> instruction: 0x012b0801
    399c:	d8040000 	stmdale	r4, {}	@ <UNPREDICTABLE>
    39a0:	0100000a 	tsteq	r0, sl
    39a4:	00860326 	addeq	r0, r6, r6, lsr #6
    39a8:	690b0000 	stmdbvs	fp, {}	@ <UNPREDICTABLE>
    39ac:	c4000000 	strgt	r0, [r0], #-0
    39b0:	0c000000 	stceq	0, cr0, [r0], {-0}
    39b4:	000000c4 	andeq	r0, r0, r4, asr #1
    39b8:	0403000f 	streq	r0, [r3], #-15
    39bc:	00017b07 	andeq	r7, r1, r7, lsl #22
    39c0:	0a7f0d00 	beq	1fc6dc8 <__ROM_SIZE__+0x1f86dc8>
    39c4:	0d280000 	stceq	0, cr0, [r8, #-0]
    39c8:	000000b4 	strheq	r0, [r0], -r4
    39cc:	337c0305 	cmncc	ip, #335544320	@ 0x14000000
    39d0:	dc1a0000 	ldcle	0, cr0, [sl], {-0}
    39d4:	01000001 	tsteq	r0, r1
    39d8:	005705a9 	subseq	r0, r7, r9, lsr #11
    39dc:	17ac0000 	strne	r0, [ip, r0]!
    39e0:	00dc0000 	sbcseq	r0, ip, r0
    39e4:	9c010000 	stcls	0, cr0, [r1], {-0}
    39e8:	00000179 	andeq	r0, r0, r9, ror r1
    39ec:	746d6606 	strbtvc	r6, [sp], #-1542	@ 0xfffff9fa
    39f0:	7918a900 	ldmdbvc	r8, {r8, fp, sp, pc}
    39f4:	45000001 	strmi	r0, [r0, #-1]
    39f8:	3500000d 	strcc	r0, [r0, #-13]
    39fc:	1b00000d 	blne	3a38 <base_order+0x1b8>
    3a00:	000b2e02 	andeq	r2, fp, r2, lsl #28
    3a04:	a810aa00 	ldmdage	r0, {r9, fp, sp, pc}
    3a08:	9b000000 	blls	3a10 <base_order+0x190>
    3a0c:	7f00000d 	svcvc	0x0000000d
    3a10:	0d00000d 	stceq	0, cr0, [r0, #-52]	@ 0xffffffcc
    3a14:	00000b1c 	andeq	r0, r0, ip, lsl fp
    3a18:	004b0bab 	subeq	r0, fp, fp, lsr #23
    3a1c:	91020000 	mrsls	r0, (UNDEF: 2)
    3a20:	004e075c 	subeq	r0, lr, ip, asr r7
    3a24:	01590000 	cmpeq	r9, r0
    3a28:	90020000 	andls	r0, r2, r0
    3a2c:	d400000a 	strle	r0, [r0], #-10
    3a30:	00005711 	andeq	r5, r0, r1, lsl r7
    3a34:	000e0d00 	andeq	r0, lr, r0, lsl #26
    3a38:	000e0500 	andeq	r0, lr, r0, lsl #10
    3a3c:	18500800 	ldmdane	r0, {fp}^
    3a40:	017e0000 	cmneq	lr, r0
    3a44:	01010000 	mrseq	r0, (UNDEF: 1)
    3a48:	bc910351 	ldclt	3, cr0, [r1], {81}	@ 0x51
    3a4c:	1c00007f 	stcne	0, cr0, [r0], {127}	@ 0x7f
    3a50:	00001824 	andeq	r1, r0, r4, lsr #16
    3a54:	00000308 	andeq	r0, r0, r8, lsl #6
    3a58:	00186608 	andseq	r6, r8, r8, lsl #12
    3a5c:	00017e00 	andeq	r7, r1, r0, lsl #28
    3a60:	51010100 	mrspl	r0, (UNDEF: 17)
    3a64:	7fbc9103 	svcvc	0x00bc9103
    3a68:	01520101 	cmpeq	r2, r1, lsl #2
    3a6c:	05000030 	streq	r0, [r0, #-48]	@ 0xffffffd0
    3a70:	00000070 	andeq	r0, r0, r0, ror r0
    3a74:	000b041d 	andeq	r0, fp, sp, lsl r4
    3a78:	0d320100 	ldfeqs	f0, [r2, #-0]
    3a7c:	000002ec 	andeq	r0, r0, ip, ror #5
    3a80:	0000166c 	andeq	r1, r0, ip, ror #12
    3a84:	00000140 	andeq	r0, r0, r0, asr #2
    3a88:	02ec9c01 	rsceq	r9, ip, #256	@ 0x100
    3a8c:	66060000 	strvs	r0, [r6], -r0
    3a90:	3200746d 	andcc	r7, r0, #1828716544	@ 0x6d000000
    3a94:	00007027 	andeq	r7, r0, r7, lsr #32
    3a98:	000e4900 	andeq	r4, lr, r0, lsl #18
    3a9c:	000e2d00 	andeq	r2, lr, r0, lsl #26
    3aa0:	0b1c0e00 	bleq	7072a8 <__ROM_SIZE__+0x6c72a8>
    3aa4:	f3350000 	vhadd.u<illegal width 64>	d0, d5, d0
    3aa8:	cc000002 	stcgt	0, cr0, [r0], {2}
    3aac:	b600000e 	strlt	r0, [r0], -lr
    3ab0:	0e00000e 	cdpeq	0, 0, cr0, cr0, cr14, {0}
    3ab4:	00000a90 	muleq	r0, r0, sl
    3ab8:	0000573f 	andeq	r5, r0, pc, lsr r7
    3abc:	000f3800 	andeq	r3, pc, r0, lsl #16
    3ac0:	000f1e00 	andeq	r1, pc, r0, lsl #28
    3ac4:	756e1e00 	strbvc	r1, [lr, #-3584]!	@ 0xfffff200
    3ac8:	3301006d 	movwcc	r0, #4205	@ 0x106d
    3acc:	0002f808 	andeq	pc, r2, r8, lsl #16
    3ad0:	64910200 	ldrvs	r0, [r1], #512	@ 0x200
    3ad4:	000a8802 	andeq	r8, sl, r2, lsl #16
    3ad8:	57073400 	strpl	r3, [r7, -r0, lsl #8]
    3adc:	a3000000 	movwge	r0, #0
    3ae0:	9100000f 	tstls	r0, pc
    3ae4:	0700000f 	streq	r0, [r0, -pc]
    3ae8:	00000044 	andeq	r0, r0, r4, asr #32
    3aec:	00000231 	andeq	r0, r0, r1, lsr r2
    3af0:	000afe02 	andeq	pc, sl, r2, lsl #28
    3af4:	570b4100 	strpl	r4, [fp, -r0, lsl #2]
    3af8:	f0000000 			@ <UNDEFINED> instruction: 0xf0000000
    3afc:	e600000f 	str	r0, [r0], -pc
    3b00:	0f00000f 	svceq	0x0000000f
    3b04:	000016fa 	strdeq	r1, [r0], -sl
    3b08:	0000021d 	andeq	r0, r0, sp, lsl r2
    3b0c:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    3b10:	09002d08 	stmdbeq	r0, {r3, r8, sl, fp, sp}
    3b14:	00001712 	andeq	r1, r0, r2, lsl r7
    3b18:	09500101 	ldmdbeq	r0, {r0, r8}^
    3b1c:	00740091 			@ <UNDEFINED> instruction: 0x00740091
    3b20:	941c4c22 	ldrls	r4, [ip], #-3106	@ 0xfffff3de
    3b24:	07000001 	streq	r0, [r0, -r1]
    3b28:	00000023 	andeq	r0, r0, r3, lsr #32
    3b2c:	000002d8 	ldrdeq	r0, [r0], -r8
    3b30:	000afe02 	andeq	pc, sl, r2, lsl #28
    3b34:	c4147100 	ldrgt	r7, [r4], #-256	@ 0xffffff00
    3b38:	1d000000 	stcne	0, cr0, [r0, #-0]
    3b3c:	13000010 	movwne	r0, #16
    3b40:	1f000010 	svcne	0x00000010
    3b44:	00001762 	andeq	r1, r0, r2, ror #14
    3b48:	00000028 	andeq	r0, r0, r8, lsr #32
    3b4c:	000002b4 			@ <UNDEFINED> instruction: 0x000002b4
    3b50:	000ae502 	andeq	lr, sl, r2, lsl #10
    3b54:	570f9300 	strpl	r9, [pc, -r0, lsl #6]
    3b58:	45000000 	strmi	r0, [r0, #-0]
    3b5c:	41000010 	tstmi	r0, r0, lsl r0
    3b60:	02000010 	andeq	r0, r0, #16
    3b64:	00000a5c 	andeq	r0, r0, ip, asr sl
    3b68:	02ec1094 	rsceq	r1, ip, #148	@ 0x94
    3b6c:	105c0000 	subsne	r0, ip, r0
    3b70:	10540000 	subsne	r0, r4, r0
    3b74:	39200000 	stmdbcc	r0!, {}	@ <UNPREDICTABLE>
    3b78:	21000000 	mrscs	r0, (UNDEF: 0)
    3b7c:	006c6176 	rsbeq	r6, ip, r6, ror r1
    3b80:	57119701 	ldrpl	r9, [r1, -r1, lsl #14]
    3b84:	82000000 	andhi	r0, r0, #0
    3b88:	7a000010 	bvc	3bd0 <base_order+0x350>
    3b8c:	09000010 	stmdbeq	r0, {r4}
    3b90:	0000176c 	andeq	r1, r0, ip, ror #14
    3b94:	0f500101 	svceq	0x00500101
    3b98:	00740075 	rsbseq	r0, r4, r5, ror r0
    3b9c:	031a3f25 	tsteq	sl, #37, 30	@ 0x94
    3ba0:	0000337c 	andeq	r3, r0, ip, ror r3
    3ba4:	00019422 	andeq	r9, r1, r2, lsr #8
    3ba8:	9e0f0000 	cdpls	0, 0, cr0, cr15, cr0, {0}
    3bac:	c4000016 	strgt	r0, [r0], #-22	@ 0xffffffea
    3bb0:	01000002 	tsteq	r0, r2
    3bb4:	08025001 	stmdaeq	r2, {r0, ip, lr}
    3bb8:	5c090030 	stcpl	0, cr0, [r9], {48}	@ 0x30
    3bbc:	01000017 	tsteq	r0, r7, lsl r0
    3bc0:	91095001 	tstls	r9, r1
    3bc4:	22007400 	andcs	r7, r0, #0, 8
    3bc8:	01941c4c 	orrseq	r1, r4, ip, asr #24
    3bcc:	ac080000 	stcge	0, cr0, [r8], {-0}
    3bd0:	08000016 	stmdaeq	r0, {r1, r2, r4}
    3bd4:	01000003 	tsteq	r0, r3
    3bd8:	03055001 	movweq	r5, #20481	@ 0x5001
    3bdc:	0000336c 	andeq	r3, r0, ip, ror #6
    3be0:	01030000 	mrseq	r0, (UNDEF: 3)
    3be4:	00083102 	andeq	r3, r8, r2, lsl #2
    3be8:	004b0500 	subeq	r0, fp, r0, lsl #10
    3bec:	690b0000 	stmdbvs	fp, {}	@ <UNPREDICTABLE>
    3bf0:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
    3bf4:	0c000003 	stceq	0, cr0, [r0], {3}
    3bf8:	000000c4 	andeq	r0, r0, r4, asr #1
    3bfc:	55220009 	strpl	r0, [r2, #-9]!
    3c00:	0100000a 	tsteq	r0, sl
    3c04:	16500d2b 	ldrbne	r0, [r0], -fp, lsr #26
    3c08:	001c0000 	andseq	r0, ip, r0
    3c0c:	9c010000 	stcls	0, cr0, [r1], {-0}
    3c10:	72747306 	rsbsvc	r7, r4, #402653184	@ 0x18000000
    3c14:	79202b00 	stmdbvc	r0!, {r8, r9, fp, sp}
    3c18:	ae000001 	cdpge	0, 0, cr0, cr0, cr1, {0}
    3c1c:	aa000010 	bge	3c64 <base_order+0x3e4>
    3c20:	00000010 	andeq	r0, r0, r0, lsl r0
    3c24:	00032b00 	andeq	r2, r3, r0, lsl #22
    3c28:	01000500 	tsteq	r0, r0, lsl #10
    3c2c:	00152f04 	andseq	r2, r5, r4, lsl #30
    3c30:	00461000 	subeq	r1, r6, r0
    3c34:	3c1d0000 	ldccc	0, cr0, [sp], {-0}
    3c38:	1400000b 	strne	r0, [r0], #-11
    3c3c:	88000000 	stmdahi	r0, {}	@ <UNPREDICTABLE>
    3c40:	38000018 	stmdacc	r0, {r3, r4}
    3c44:	54000002 	strpl	r0, [r0], #-2
    3c48:	0400002a 	streq	r0, [r0], #-42	@ 0xffffffd6
    3c4c:	00000aef 	andeq	r0, r0, pc, ror #21
    3c50:	321b2802 	andscc	r2, fp, #131072	@ 0x20000
    3c54:	11000000 	mrsne	r0, (UNDEF: 0)
    3c58:	00000a98 	muleq	r0, r8, sl
    3c5c:	49000304 	stmdbmi	r0, {r2, r8, r9}
    3c60:	12000000 	andne	r0, r0, #0
    3c64:	00000b21 	andeq	r0, r0, r1, lsr #22
    3c68:	00000049 	andeq	r0, r0, r9, asr #32
    3c6c:	04130000 	ldreq	r0, [r3], #-0
    3c70:	000a9a04 	andeq	r9, sl, r4, lsl #20
    3c74:	18630200 	stmdane	r3!, {r9}^
    3c78:	00000026 	andeq	r0, r0, r6, lsr #32
    3c7c:	69050414 	stmdbvs	r5, {r2, r4, sl}
    3c80:	1500746e 	strne	r7, [r0, #-1134]	@ 0xfffffb92
    3c84:	00000069 	andeq	r0, r0, r9, rrx
    3c88:	00006916 	andeq	r6, r0, r6, lsl r9
    3c8c:	01030000 	mrseq	r0, (UNDEF: 3)
    3c90:	00013408 	andeq	r3, r1, r8, lsl #8
    3c94:	00691700 	rsbeq	r1, r9, r0, lsl #14
    3c98:	98180000 	ldmdals	r8, {}	@ <UNPREDICTABLE>
    3c9c:	01000006 	tsteq	r0, r6
    3ca0:	00810f17 	addeq	r0, r1, r7, lsl pc
    3ca4:	5e050000 	cdppl	0, 0, cr0, cr5, cr0, {0}
    3ca8:	19000000 	stmdbne	r0, {}	@ <UNPREDICTABLE>
    3cac:	00a10107 	adceq	r0, r1, r7, lsl #2
    3cb0:	21010000 	mrscs	r0, (UNDEF: 1)
    3cb4:	0000a10e 	andeq	sl, r0, lr, lsl #2
    3cb8:	0b130a00 	bleq	4c64c0 <__ROM_SIZE__+0x4864c0>
    3cbc:	0a000000 	beq	3cc4 <base_order+0x444>
    3cc0:	00000a71 	andeq	r0, r0, r1, ror sl
    3cc4:	01030001 	tsteq	r3, r1
    3cc8:	00012b08 	andeq	r2, r1, r8, lsl #22
    3ccc:	0b260400 	bleq	984cd4 <__ROM_SIZE__+0x944cd4>
    3cd0:	24010000 	strcs	r0, [r1], #-0
    3cd4:	00008603 	andeq	r8, r0, r3, lsl #12
    3cd8:	00690b00 	rsbeq	r0, r9, r0, lsl #22
    3cdc:	00c40000 	sbceq	r0, r4, r0
    3ce0:	c40c0000 	strgt	r0, [ip], #-0
    3ce4:	0f000000 	svceq	0x00000000
    3ce8:	07040300 	streq	r0, [r4, -r0, lsl #6]
    3cec:	0000017b 	andeq	r0, r0, fp, ror r1
    3cf0:	000b830d 	andeq	r8, fp, sp, lsl #6
    3cf4:	b40d2600 	strlt	r2, [sp], #-1536	@ 0xfffffa00
    3cf8:	05000000 	streq	r0, [r0, #-0]
    3cfc:	00339c03 	eorseq	r9, r3, r3, lsl #24
    3d00:	04581a00 	ldrbeq	r1, [r8], #-2560	@ 0xfffff600
    3d04:	a7010000 	strge	r0, [r1, -r0]
    3d08:	00005705 	andeq	r5, r0, r5, lsl #14
    3d0c:	0019e400 	andseq	lr, r9, r0, lsl #8
    3d10:	0000dc00 	andeq	sp, r0, r0, lsl #24
    3d14:	799c0100 	ldmibvc	ip, {r8}
    3d18:	06000001 	streq	r0, [r0], -r1
    3d1c:	00746d66 	rsbseq	r6, r4, r6, ror #26
    3d20:	017919a7 	cmneq	r9, r7, lsr #19
    3d24:	10d50000 	sbcsne	r0, r5, r0
    3d28:	10c50000 	sbcne	r0, r5, r0
    3d2c:	021b0000 	andseq	r0, fp, #0
    3d30:	00000b2e 	andeq	r0, r0, lr, lsr #22
    3d34:	00a811a8 	adceq	r1, r8, r8, lsr #3
    3d38:	112b0000 			@ <UNDEFINED> instruction: 0x112b0000
    3d3c:	110f0000 	mrsne	r0, CPSR
    3d40:	1c0d0000 	stcne	0, cr0, [sp], {-0}
    3d44:	a900000b 	stmdbge	r0, {r0, r1, r3}
    3d48:	00004b0b 	andeq	r4, r0, fp, lsl #22
    3d4c:	5c910200 	lfmpl	f0, 4, [r1], {0}
    3d50:	00009007 	andeq	r9, r0, r7
    3d54:	00015900 	andeq	r5, r1, r0, lsl #18
    3d58:	0a900200 	beq	fe404560 <_STACK_TOP_+0xde3fc564>
    3d5c:	11d20000 	bicsne	r0, r2, r0
    3d60:	00000057 	andeq	r0, r0, r7, asr r0
    3d64:	0000119d 	muleq	r0, sp, r1
    3d68:	00001195 	muleq	r0, r5, r1
    3d6c:	001a8808 	andseq	r8, sl, r8, lsl #16
    3d70:	00017e00 	andeq	r7, r1, r0, lsl #28
    3d74:	51010100 	mrspl	r0, (UNDEF: 17)
    3d78:	7fbc9103 	svcvc	0x00bc9103
    3d7c:	5c1c0000 	ldcpl	0, cr0, [ip], {-0}
    3d80:	0800001a 	stmdaeq	r0, {r1, r3, r4}
    3d84:	08000003 	stmdaeq	r0, {r0, r1}
    3d88:	00001a9e 	muleq	r0, lr, sl
    3d8c:	0000017e 	andeq	r0, r0, lr, ror r1
    3d90:	03510101 	cmpeq	r1, #1073741824	@ 0x40000000
    3d94:	017fbc91 			@ <UNDEFINED> instruction: 0x017fbc91
    3d98:	30015201 	andcc	r5, r1, r1, lsl #4
    3d9c:	70050000 	andvc	r0, r5, r0
    3da0:	1d000000 	stcne	0, cr0, [r0, #-0]
    3da4:	00000b73 	andeq	r0, r0, r3, ror fp
    3da8:	ec0d3001 	stc	0, cr3, [sp], {1}
    3dac:	a4000002 	strge	r0, [r0], #-2
    3db0:	40000018 	andmi	r0, r0, r8, lsl r0
    3db4:	01000001 	tsteq	r0, r1
    3db8:	0002ec9c 	muleq	r2, ip, ip
    3dbc:	6d660600 	stclvs	6, cr0, [r6, #-0]
    3dc0:	28300074 	ldmdacs	r0!, {r2, r4, r5, r6}
    3dc4:	00000070 	andeq	r0, r0, r0, ror r0
    3dc8:	000011d9 	ldrdeq	r1, [r0], -r9
    3dcc:	000011bd 			@ <UNDEFINED> instruction: 0x000011bd
    3dd0:	000b1c0e 	andeq	r1, fp, lr, lsl #24
    3dd4:	02f33600 	rscseq	r3, r3, #0, 12
    3dd8:	125c0000 	subsne	r0, ip, #0
    3ddc:	12460000 	subne	r0, r6, #0
    3de0:	900e0000 	andls	r0, lr, r0
    3de4:	4000000a 	andmi	r0, r0, sl
    3de8:	00000057 	andeq	r0, r0, r7, asr r0
    3dec:	000012c8 	andeq	r1, r0, r8, asr #5
    3df0:	000012ae 	andeq	r1, r0, lr, lsr #5
    3df4:	6d756e1e 	ldclvs	14, cr6, [r5, #-120]!	@ 0xffffff88
    3df8:	08310100 	ldmdaeq	r1!, {r8}
    3dfc:	000002f8 	strdeq	r0, [r0], -r8
    3e00:	02649102 	rsbeq	r9, r4, #-2147483648	@ 0x80000000
    3e04:	00000a88 	andeq	r0, r0, r8, lsl #21
    3e08:	00570732 	subseq	r0, r7, r2, lsr r7
    3e0c:	13330000 	teqne	r3, #0
    3e10:	13210000 			@ <UNDEFINED> instruction: 0x13210000
    3e14:	86070000 	strhi	r0, [r7], -r0
    3e18:	31000000 	mrscc	r0, (UNDEF: 0)
    3e1c:	02000002 	andeq	r0, r0, #2
    3e20:	00000afe 	strdeq	r0, [r0], -lr
    3e24:	00570b3f 	subseq	r0, r7, pc, lsr fp
    3e28:	13800000 	orrne	r0, r0, #0
    3e2c:	13760000 	cmnne	r6, #0
    3e30:	320f0000 	andcc	r0, pc, #0
    3e34:	1d000019 	stcne	0, cr0, [r0, #-100]	@ 0xffffff9c
    3e38:	01000002 	tsteq	r0, r2
    3e3c:	08025001 	stmdaeq	r2, {r0, ip, lr}
    3e40:	4a09002d 	bmi	243efc <__ROM_SIZE__+0x203efc>
    3e44:	01000019 	tsteq	r0, r9, lsl r0
    3e48:	91095001 	tstls	r9, r1
    3e4c:	22007400 	andcs	r7, r0, #0, 8
    3e50:	01941c4c 	orrseq	r1, r4, ip, asr #24
    3e54:	65070000 	strvs	r0, [r7, #-0]
    3e58:	d8000000 	stmdale	r0, {}	@ <UNPREDICTABLE>
    3e5c:	02000002 	andeq	r0, r0, #2
    3e60:	00000afe 	strdeq	r0, [r0], -lr
    3e64:	00c4146f 	sbceq	r1, r4, pc, ror #8
    3e68:	13ad0000 			@ <UNDEFINED> instruction: 0x13ad0000
    3e6c:	13a30000 			@ <UNDEFINED> instruction: 0x13a30000
    3e70:	9a1f0000 	bls	7c3e78 <__ROM_SIZE__+0x783e78>
    3e74:	28000019 	stmdacs	r0, {r0, r3, r4}
    3e78:	b4000000 	strlt	r0, [r0], #-0
    3e7c:	02000002 	andeq	r0, r0, #2
    3e80:	00000ae5 	andeq	r0, r0, r5, ror #21
    3e84:	00570f91 			@ <UNDEFINED> instruction: 0x00570f91
    3e88:	13d50000 	bicsne	r0, r5, #0
    3e8c:	13d10000 	bicsne	r0, r1, #0
    3e90:	5c020000 	stcpl	0, cr0, [r2], {-0}
    3e94:	9200000a 	andls	r0, r0, #10
    3e98:	0002ec10 	andeq	lr, r2, r0, lsl ip
    3e9c:	0013ec00 	andseq	lr, r3, r0, lsl #24
    3ea0:	0013e400 	andseq	lr, r3, r0, lsl #8
    3ea4:	007b2000 	rsbseq	r2, fp, r0
    3ea8:	76210000 	strtvc	r0, [r1], -r0
    3eac:	01006c61 	tsteq	r0, r1, ror #24
    3eb0:	00571195 			@ <UNDEFINED> instruction: 0x00571195
    3eb4:	14120000 	ldrne	r0, [r2], #-0
    3eb8:	140a0000 	strne	r0, [sl], #-0
    3ebc:	a4090000 	strge	r0, [r9], #-0
    3ec0:	01000019 	tsteq	r0, r9, lsl r0
    3ec4:	750f5001 	strvc	r5, [pc, #-1]	@ 3ecb <base_order+0x64b>
    3ec8:	25007400 	strcs	r7, [r0, #-1024]	@ 0xfffffc00
    3ecc:	9c031a3f 			@ <UNDEFINED> instruction: 0x9c031a3f
    3ed0:	22000033 	andcs	r0, r0, #51	@ 0x33
    3ed4:	00000194 	muleq	r0, r4, r1
    3ed8:	18d60f00 	ldmne	r6, {r8, r9, sl, fp}^
    3edc:	02c40000 	sbceq	r0, r4, #0
    3ee0:	01010000 	mrseq	r0, (UNDEF: 1)
    3ee4:	30080250 	andcc	r0, r8, r0, asr r2
    3ee8:	19940900 	ldmibne	r4, {r8, fp}
    3eec:	01010000 	mrseq	r0, (UNDEF: 1)
    3ef0:	00910950 	addseq	r0, r1, r0, asr r9
    3ef4:	4c220074 	stcmi	0, cr0, [r2], #-464	@ 0xfffffe30
    3ef8:	0001941c 	andeq	r9, r1, ip, lsl r4
    3efc:	18e40800 	stmiane	r4!, {fp}^
    3f00:	03080000 	movweq	r0, #32768	@ 0x8000
    3f04:	01010000 	mrseq	r0, (UNDEF: 1)
    3f08:	8c030550 	cfstr32hi	mvfx0, [r3], {80}	@ 0x50
    3f0c:	00000033 	andeq	r0, r0, r3, lsr r0
    3f10:	02010300 	andeq	r0, r1, #0, 6
    3f14:	00000831 	andeq	r0, r0, r1, lsr r8
    3f18:	00004b05 	andeq	r4, r0, r5, lsl #22
    3f1c:	00690b00 	rsbeq	r0, r9, r0, lsl #22
    3f20:	03080000 	movweq	r0, #32768	@ 0x8000
    3f24:	c40c0000 	strgt	r0, [ip], #-0
    3f28:	09000000 	stmdbeq	r0, {}	@ <UNPREDICTABLE>
    3f2c:	0b342200 	bleq	d0c734 <__ROM_SIZE__+0xccc734>
    3f30:	29010000 	stmdbcs	r1, {}	@ <UNPREDICTABLE>
    3f34:	0018880d 	andseq	r8, r8, sp, lsl #16
    3f38:	00001c00 	andeq	r1, r0, r0, lsl #24
    3f3c:	069c0100 	ldreq	r0, [ip], r0, lsl #2
    3f40:	00727473 	rsbseq	r7, r2, r3, ror r4
    3f44:	01792129 	cmneq	r9, r9, lsr #2
    3f48:	143e0000 	ldrtne	r0, [lr], #-0
    3f4c:	143a0000 	ldrtne	r0, [sl], #-0
    3f50:	00000000 	andeq	r0, r0, r0
    3f54:	00000568 	andeq	r0, r0, r8, ror #10
    3f58:	04010005 	streq	r0, [r1], #-5
    3f5c:	000016fe 	strdeq	r1, [r0], -lr
    3f60:	00004610 	andeq	r4, r0, r0, lsl r6
    3f64:	0bbd1d00 	bleq	fef4b36c <_STACK_TOP_+0xdef43370>
    3f68:	00140000 	andseq	r0, r4, r0
    3f6c:	1ac00000 	bne	ff003f74 <_STACK_TOP_+0xdeffbf78>
    3f70:	01600000 	cmneq	r0, r0
    3f74:	2dfc0000 	ldclcs	0, cr0, [ip]
    3f78:	01030000 	mrseq	r0, (UNDEF: 3)
    3f7c:	00012d06 	andeq	r2, r1, r6, lsl #26
    3f80:	05020300 	streq	r0, [r2, #-768]	@ 0xfffffd00
    3f84:	000001e3 	andeq	r0, r0, r3, ror #3
    3f88:	c7050403 	strgt	r0, [r5, -r3, lsl #8]
    3f8c:	03000001 	movweq	r0, #1
    3f90:	01c20508 	biceq	r0, r2, r8, lsl #10
    3f94:	01030000 	mrseq	r0, (UNDEF: 3)
    3f98:	00012b08 	andeq	r2, r1, r8, lsl #22
    3f9c:	07020300 	streq	r0, [r2, -r0, lsl #6]
    3fa0:	00000139 	andeq	r0, r0, r9, lsr r1
    3fa4:	00026a0b 	andeq	r6, r2, fp, lsl #20
    3fa8:	19340200 	ldmdbne	r4!, {r9}
    3fac:	0000005c 	andeq	r0, r0, ip, asr r0
    3fb0:	76070403 	strvc	r0, [r7], -r3, lsl #8
    3fb4:	03000001 	movweq	r0, #1
    3fb8:	01710708 	cmneq	r1, r8, lsl #14
    3fbc:	04110000 	ldreq	r0, [r1], #-0
    3fc0:	746e6905 	strbtvc	r6, [lr], #-2309	@ 0xfffff6fb
    3fc4:	07040300 	streq	r0, [r4, -r0, lsl #6]
    3fc8:	0000017b 	andeq	r0, r0, fp, ror r1
    3fcc:	000b9f0b 	andeq	r9, fp, fp, lsl #30
    3fd0:	1a560200 	bne	15847d8 <__ROM_SIZE__+0x15447d8>
    3fd4:	00000071 	andeq	r0, r0, r1, ror r0
    3fd8:	25040803 	strcs	r0, [r4, #-2051]	@ 0xfffff7fd
    3fdc:	12000002 	andne	r0, r0, #2
    3fe0:	00646d63 	rsbeq	r6, r4, r3, ror #26
    3fe4:	970f3b03 	strls	r3, [pc, -r3, lsl #22]
    3fe8:	0a000000 	beq	3ff0 <base_order+0x770>
    3fec:	0000009c 	muleq	r0, ip, r0
    3ff0:	00006a13 	andeq	r6, r0, r3, lsl sl
    3ff4:	0000b000 	andeq	fp, r0, r0
    3ff8:	006a0700 	rsbeq	r0, sl, r0, lsl #14
    3ffc:	b0070000 	andlt	r0, r7, r0
    4000:	00000000 	andeq	r0, r0, r0
    4004:	0000b50a 	andeq	fp, r0, sl, lsl #10
    4008:	00ba0a00 	adcseq	r0, sl, r0, lsl #20
    400c:	01030000 	mrseq	r0, (UNDEF: 3)
    4010:	00013408 	andeq	r3, r1, r8, lsl #8
    4014:	00ba1400 	adcseq	r1, sl, r0, lsl #8
    4018:	0c150000 	ldceq	0, cr0, [r5], {-0}
    401c:	f4094403 	vst3.8	{d4-d6}, [r9], r3
    4020:	0c000000 	stceq	0, cr0, [r0], {-0}
    4024:	0000025d 	andeq	r0, r0, sp, asr r2
    4028:	00f40f45 	rscseq	r0, r4, r5, asr #30
    402c:	0c000000 	stceq	0, cr0, [r0], {-0}
    4030:	00000000 	andeq	r0, r0, r0
    4034:	00f40f46 	rscseq	r0, r4, r6, asr #30
    4038:	0c040000 	stceq	0, cr0, [r4], {-0}
    403c:	000000da 	ldrdeq	r0, [r0], -sl
    4040:	008b0747 	addeq	r0, fp, r7, asr #14
    4044:	00080000 	andeq	r0, r8, r0
    4048:	0000c10a 	andeq	ip, r0, sl, lsl #2
    404c:	01bc0b00 			@ <UNDEFINED> instruction: 0x01bc0b00
    4050:	48030000 	stmdami	r3, {}	@ <UNPREDICTABLE>
    4054:	0000c603 	andeq	ip, r0, r3, lsl #12
    4058:	0b8d0800 	bleq	fe346060 <_STACK_TOP_+0xde33e064>
    405c:	f97f0000 			@ <UNDEFINED> instruction: 0xf97f0000
    4060:	05000000 	streq	r0, [r0, #-0]
    4064:	002a3403 	eoreq	r3, sl, r3, lsl #8
    4068:	0bb10800 	bleq	fec46070 <_STACK_TOP_+0xdec3e074>
    406c:	f9800000 			@ <UNDEFINED> instruction: 0xf9800000
    4070:	05000000 	streq	r0, [r0, #-0]
    4074:	002a2803 	eoreq	r2, sl, r3, lsl #16
    4078:	0bf10800 	bleq	ffc46080 <_STACK_TOP_+0xdfc3e084>
    407c:	f9830000 			@ <UNDEFINED> instruction: 0xf9830000
    4080:	05000000 	streq	r0, [r0, #-0]
    4084:	002a1c03 	eoreq	r1, sl, r3, lsl #24
    4088:	0c180800 	ldceq	8, cr0, [r8], {-0}
    408c:	f9840000 			@ <UNDEFINED> instruction: 0xf9840000
    4090:	05000000 	streq	r0, [r0, #-0]
    4094:	002a1003 	eoreq	r1, sl, r3
    4098:	0c030800 	stceq	8, cr0, [r3], {-0}
    409c:	f9850000 			@ <UNDEFINED> instruction: 0xf9850000
    40a0:	05000000 	streq	r0, [r0, #-0]
    40a4:	002a0403 	eoreq	r0, sl, r3, lsl #8
    40a8:	0bf90d00 	bleq	ffe474b0 <_STACK_TOP_+0xdfe3f4b4>
    40ac:	1f040000 	svcne	0x00040000
    40b0:	00006a05 	andeq	r6, r0, r5, lsl #20
    40b4:	00016b00 	andeq	r6, r1, r0, lsl #22
    40b8:	00f40700 	rscseq	r0, r4, r0, lsl #14
    40bc:	0d000000 	stceq	0, cr0, [r0, #-0]
    40c0:	00000bfe 	strdeq	r0, [r0], -lr
    40c4:	500a2604 	andpl	r2, sl, r4, lsl #12
    40c8:	81000000 	mrshi	r0, (UNDEF: 0)
    40cc:	07000001 	streq	r0, [r0, -r1]
    40d0:	000000f4 	strdeq	r0, [r0], -r4
    40d4:	01dc0d00 	bicseq	r0, ip, r0, lsl #26
    40d8:	2c050000 	stccs	0, cr0, [r5], {-0}
    40dc:	00006a05 	andeq	r6, r0, r5, lsl #20
    40e0:	00019800 	andeq	r9, r1, r0, lsl #16
    40e4:	00f40700 	rscseq	r0, r4, r0, lsl #14
    40e8:	00160000 	andseq	r0, r6, r0
    40ec:	000bb50e 	andeq	fp, fp, lr, lsl #10
    40f0:	006a6700 	rsbeq	r6, sl, r0, lsl #14
    40f4:	1bd00000 	blne	ff4040fc <_STACK_TOP_+0xdf3fc100>
    40f8:	00500000 	subseq	r0, r0, r0
    40fc:	9c010000 	stcls	0, cr0, [r1], {-0}
    4100:	00000286 	andeq	r0, r0, r6, lsl #5
    4104:	0001ed04 	andeq	lr, r1, r4, lsl #26
    4108:	6a116700 	bvs	45dd10 <__ROM_SIZE__+0x41dd10>
    410c:	59000000 	stmdbpl	r0, {}	@ <UNPREDICTABLE>
    4110:	55000014 	strpl	r0, [r0, #-20]	@ 0xffffffec
    4114:	04000014 	streq	r0, [r0], #-20	@ 0xffffffec
    4118:	0000015a 	andeq	r0, r0, sl, asr r1
    411c:	00b01d67 	adcseq	r1, r0, r7, ror #26
    4120:	146f0000 	strbtne	r0, [pc], #-0	@ 4128 <base_order+0x8a8>
    4124:	146b0000 	strbtne	r0, [fp], #-0
    4128:	990f0000 	stmdbls	pc, {}	@ <UNPREDICTABLE>
    412c:	7a00000b 	bvc	4160 <base_order+0x8e0>
    4130:	00001c06 	andeq	r1, r0, r6, lsl #24
    4134:	00088601 	andeq	r8, r8, r1, lsl #12
    4138:	500c6d00 	andpl	r6, ip, r0, lsl #26
    413c:	84000000 	strhi	r0, [r0], #-0
    4140:	7e000014 	mcrvc	0, 0, r0, cr0, cr4, {0}
    4144:	01000014 	tsteq	r0, r4, lsl r0
    4148:	00000ba9 	andeq	r0, r0, r9, lsr #23
    414c:	00500c6e 	subseq	r0, r0, lr, ror #24
    4150:	14a20000 	strtne	r0, [r2], #0
    4154:	149a0000 	ldrne	r0, [sl], #0
    4158:	90010000 	andls	r0, r1, r0
    415c:	75000007 	strvc	r0, [r0, #-7]
    4160:	0000500c 	andeq	r5, r0, ip
    4164:	0014c100 	andseq	ip, r4, r0, lsl #2
    4168:	0014bf00 	andseq	fp, r4, r0, lsl #30
    416c:	0c100100 	ldfeqs	f0, [r0], {-0}
    4170:	0c760000 	ldcleq	0, cr0, [r6], #-0
    4174:	00000050 	andeq	r0, r0, r0, asr r0
    4178:	000014cd 	andeq	r1, r0, sp, asr #9
    417c:	000014c9 	andeq	r1, r0, r9, asr #9
    4180:	001bde05 	andseq	sp, fp, r5, lsl #28
    4184:	00016b00 	andeq	r6, r1, r0, lsl #22
    4188:	1be60500 	blne	ff985590 <_STACK_TOP_+0xdf97d594>
    418c:	01550000 	cmpeq	r5, r0
    4190:	fc090000 	stc2	0, cr0, [r9], {-0}
    4194:	8100001b 	tsthi	r0, fp, lsl r0
    4198:	5b000001 	blpl	41a4 <base_order+0x924>
    419c:	02000002 	andeq	r0, r0, #2
    41a0:	03055001 	movweq	r5, #20481	@ 0x5001
    41a4:	000034e8 	andeq	r3, r0, r8, ror #9
    41a8:	02520102 	subseq	r0, r2, #-2147483648	@ 0x80000000
    41ac:	09000075 	stmdbeq	r0, {r0, r2, r4, r5, r6}
    41b0:	00001c06 	andeq	r1, r0, r6, lsl #24
    41b4:	00000181 	andeq	r0, r0, r1, lsl #3
    41b8:	00000272 	andeq	r0, r0, r2, ror r2
    41bc:	05500102 	ldrbeq	r0, [r0, #-258]	@ 0xfffffefe
    41c0:	00344003 	eorseq	r4, r4, r3
    41c4:	0e060000 	cdpeq	0, 0, cr0, cr6, cr0, {0}
    41c8:	8100001c 	tsthi	r0, ip, lsl r0
    41cc:	02000001 	andeq	r0, r0, #1
    41d0:	03055001 	movweq	r5, #20481	@ 0x5001
    41d4:	00003500 	andeq	r3, r0, r0, lsl #10
    41d8:	910e0000 	mrsls	r0, (UNDEF: 14)
    41dc:	4800000b 	stmdami	r0, {r0, r1, r3}
    41e0:	0000006a 	andeq	r0, r0, sl, rrx
    41e4:	00001b68 	andeq	r1, r0, r8, ror #22
    41e8:	00000068 	andeq	r0, r0, r8, rrx
    41ec:	03779c01 	cmneq	r7, #256	@ 0x100
    41f0:	ed040000 	stc	0, cr0, [r4, #-0]
    41f4:	48000001 	stmdami	r0, {r0}
    41f8:	00006a11 	andeq	r6, r0, r1, lsl sl
    41fc:	0014e400 	andseq	lr, r4, r0, lsl #8
    4200:	0014e000 	andseq	lr, r4, r0
    4204:	015a0400 	cmpeq	sl, r0, lsl #8
    4208:	1d480000 	stclne	0, cr0, [r8, #-0]
    420c:	000000b0 	strheq	r0, [r0], -r0	@ <UNPREDICTABLE>
    4210:	000014fa 	strdeq	r1, [r0], -sl
    4214:	000014f6 	strdeq	r1, [r0], -r6
    4218:	000b990f 	andeq	r9, fp, pc, lsl #18
    421c:	1bb66200 	blne	fed9ca24 <_STACK_TOP_+0xded94a28>
    4220:	86010000 	strhi	r0, [r1], -r0
    4224:	4e000008 	cdpmi	0, 0, cr0, cr0, cr8, {0}
    4228:	0000500c 	andeq	r5, r0, ip
    422c:	00150f00 	andseq	r0, r5, r0, lsl #30
    4230:	00150900 	andseq	r0, r5, r0, lsl #18
    4234:	0ba90100 	bleq	fea4463c <_STACK_TOP_+0xdea3c640>
    4238:	0c4f0000 	mareq	acc0, r0, pc
    423c:	00000050 	andeq	r0, r0, r0, asr r0
    4240:	0000152b 	andeq	r1, r0, fp, lsr #10
    4244:	00001525 	andeq	r1, r0, r5, lsr #10
    4248:	000c1001 	andeq	r1, ip, r1
    424c:	500c5000 	andpl	r5, ip, r0
    4250:	47000000 	strmi	r0, [r0, -r0]
    4254:	41000015 	tstmi	r0, r5, lsl r0
    4258:	01000015 	tsteq	r0, r5, lsl r0
    425c:	00000790 	muleq	r0, r0, r7
    4260:	00500c5c 	subseq	r0, r0, ip, asr ip
    4264:	15610000 	strbne	r0, [r1, #-0]!
    4268:	155d0000 	ldrbne	r0, [sp, #-0]
    426c:	76050000 	strvc	r0, [r5], -r0
    4270:	6b00001b 	blvs	42e4 <base_order+0xa64>
    4274:	05000001 	streq	r0, [r0, #-1]
    4278:	00001b7e 	andeq	r1, r0, lr, ror fp
    427c:	00000155 	andeq	r0, r0, r5, asr r1
    4280:	001b8605 	andseq	r8, fp, r5, lsl #12
    4284:	00015500 	andeq	r5, r1, r0, lsl #10
    4288:	1bae0900 	blne	feb86690 <_STACK_TOP_+0xdeb7e694>
    428c:	01810000 	orreq	r0, r1, r0
    4290:	034c0000 	movteq	r0, #49152	@ 0xc000
    4294:	01020000 	mrseq	r0, (UNDEF: 2)
    4298:	40030550 	andmi	r0, r3, r0, asr r5
    429c:	00000034 	andeq	r0, r0, r4, lsr r0
    42a0:	001bb609 	andseq	fp, fp, r9, lsl #12
    42a4:	00018100 	andeq	r8, r1, r0, lsl #2
    42a8:	00036300 	andeq	r6, r3, r0, lsl #6
    42ac:	50010200 	andpl	r0, r1, r0, lsl #4
    42b0:	34680305 	strbtcc	r0, [r8], #-773	@ 0xfffffcfb
    42b4:	06000000 	streq	r0, [r0], -r0
    42b8:	00001bbe 			@ <UNDEFINED> instruction: 0x00001bbe
    42bc:	00000181 	andeq	r0, r0, r1, lsl #3
    42c0:	05500102 	ldrbeq	r0, [r0, #-258]	@ 0xfffffefe
    42c4:	00348c03 	eorseq	r8, r4, r3, lsl #24
    42c8:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
    42cc:	00000c07 	andeq	r0, r0, r7, lsl #24
    42d0:	00006a34 	andeq	r6, r0, r4, lsr sl
    42d4:	001b2000 	andseq	r2, fp, r0
    42d8:	00004800 	andeq	r4, r0, r0, lsl #16
    42dc:	499c0100 	ldmibmi	ip, {r8}
    42e0:	04000004 	streq	r0, [r0], #-4
    42e4:	000001ed 	andeq	r0, r0, sp, ror #3
    42e8:	006a1234 	rsbeq	r1, sl, r4, lsr r2
    42ec:	15780000 	ldrbne	r0, [r8, #-0]!
    42f0:	15700000 	ldrbne	r0, [r0, #-0]!
    42f4:	5a040000 	bpl	1042fc <__ROM_SIZE__+0xc42fc>
    42f8:	34000001 	strcc	r0, [r0], #-1
    42fc:	0000b01e 	andeq	fp, r0, lr, lsl r0
    4300:	0015a200 	andseq	sl, r5, r0, lsl #4
    4304:	00159600 	andseq	r9, r5, r0, lsl #12
    4308:	08860100 	stmeq	r6, {r8}
    430c:	0c3a0000 	ldceq	0, cr0, [sl], #-0
    4310:	00000050 	andeq	r0, r0, r0, asr r0
    4314:	000015d0 	ldrdeq	r1, [r0], -r0
    4318:	000015ca 	andeq	r1, r0, sl, asr #11
    431c:	000a0201 	andeq	r0, sl, r1, lsl #4
    4320:	500c3b00 	andpl	r3, ip, r0, lsl #22
    4324:	e6000000 	str	r0, [r0], -r0
    4328:	e2000015 	and	r0, r0, #21
    432c:	17000015 	smladne	r0, r5, r0, r0
    4330:	000000a7 	andeq	r0, r0, r7, lsr #1
    4334:	00000423 	andeq	r0, r0, r3, lsr #8
    4338:	01006918 	tsteq	r0, r8, lsl r9
    433c:	0050113d 	subseq	r1, r0, sp, lsr r1
    4340:	15f70000 	ldrbne	r0, [r7, #0]!
    4344:	15f30000 	ldrbne	r0, [r3, #0]!
    4348:	90010000 	andls	r0, r1, r0
    434c:	3d000007 	stccc	0, cr0, [r0, #-28]	@ 0xffffffe4
    4350:	00005018 	andeq	r5, r0, r8, lsl r0
    4354:	00160900 	andseq	r0, r6, r0, lsl #18
    4358:	00160500 	andseq	r0, r6, r0, lsl #10
    435c:	1b540600 	blne	1505b64 <__ROM_SIZE__+0x14c5b64>
    4360:	01810000 	orreq	r0, r1, r0
    4364:	01020000 	mrseq	r0, (UNDEF: 2)
    4368:	cc030550 	cfstr32gt	mvfx0, [r3], {80}	@ 0x50
    436c:	02000033 	andeq	r0, r0, #51	@ 0x33
    4370:	74025101 	strvc	r5, [r2], #-257	@ 0xfffffeff
    4374:	05000000 	streq	r0, [r0, #-0]
    4378:	00001b2e 	andeq	r1, r0, lr, lsr #22
    437c:	0000016b 	andeq	r0, r0, fp, ror #2
    4380:	001b3605 	andseq	r3, fp, r5, lsl #12
    4384:	00015500 	andeq	r5, r1, r0, lsl #10
    4388:	1b440600 	blne	1105b90 <__ROM_SIZE__+0x10c5b90>
    438c:	01810000 	orreq	r0, r1, r0
    4390:	01020000 	mrseq	r0, (UNDEF: 2)
    4394:	08030550 	stmdaeq	r3, {r4, r6, r8, sl}
    4398:	00000034 	andeq	r0, r0, r4, lsr r0
    439c:	33771900 	cmncc	r7, #0, 18
    43a0:	28010032 	stmdacs	r1, {r1, r4, r5}
    43a4:	00006a05 	andeq	r6, r0, r5, lsl #20
    43a8:	001af000 	andseq	pc, sl, r0
    43ac:	00003000 	andeq	r3, r0, r0
    43b0:	d59c0100 	ldrle	r0, [ip, #256]	@ 0x100
    43b4:	04000004 	streq	r0, [r0], #-4
    43b8:	000001ed 	andeq	r0, r0, sp, ror #3
    43bc:	006a0d28 	rsbeq	r0, sl, r8, lsr #26
    43c0:	161f0000 	ldrne	r0, [pc], -r0
    43c4:	16170000 	ldrne	r0, [r7], -r0
    43c8:	5a040000 	bpl	1043d0 <__ROM_SIZE__+0xc43d0>
    43cc:	28000001 	stmdacs	r0, {r0}
    43d0:	0000b019 	andeq	fp, r0, r9, lsl r0
    43d4:	00164200 	andseq	r4, r6, r0, lsl #4
    43d8:	00163a00 	andseq	r3, r6, r0, lsl #20
    43dc:	08860100 	stmeq	r6, {r8}
    43e0:	0c2d0000 	stceq	0, cr0, [sp], #-0
    43e4:	00000050 	andeq	r0, r0, r0, asr r0
    43e8:	0000165b 	andeq	r1, r0, fp, asr r6
    43ec:	00001657 	andeq	r1, r0, r7, asr r6
    43f0:	00079001 	andeq	r9, r7, r1
    43f4:	500c2e00 	andpl	r2, ip, r0, lsl #28
    43f8:	68000000 	stmdavs	r0, {}	@ <UNPREDICTABLE>
    43fc:	66000016 			@ <UNDEFINED> instruction: 0x66000016
    4400:	05000016 	streq	r0, [r0, #-22]	@ 0xffffffea
    4404:	00001afe 	strdeq	r1, [r0], -lr
    4408:	0000016b 	andeq	r0, r0, fp, ror #2
    440c:	001b0605 	andseq	r0, fp, r5, lsl #12
    4410:	00016b00 	andeq	r6, r1, r0, lsl #22
    4414:	1b140600 	blne	505c1c <__ROM_SIZE__+0x4c5c1c>
    4418:	01810000 	orreq	r0, r1, r0
    441c:	01020000 	mrseq	r0, (UNDEF: 2)
    4420:	d8030550 	stmdale	r3, {r4, r6, r8, sl}
    4424:	00000033 	andeq	r0, r0, r3, lsr r0
    4428:	33721a00 	cmncc	r2, #0, 20
    442c:	19010032 	stmdbne	r1, {r1, r4, r5}
    4430:	00006a05 	andeq	r6, r0, r5, lsl #20
    4434:	001ac000 	andseq	ip, sl, r0
    4438:	00003000 	andeq	r3, r0, r0
    443c:	049c0100 	ldreq	r0, [ip], #256	@ 0x100
    4440:	000001ed 	andeq	r0, r0, sp, ror #3
    4444:	006a0d19 	rsbeq	r0, sl, r9, lsl sp
    4448:	16760000 	ldrbtne	r0, [r6], -r0
    444c:	166e0000 	strbtne	r0, [lr], -r0
    4450:	5a040000 	bpl	104458 <__ROM_SIZE__+0xc4458>
    4454:	19000001 	stmdbne	r0, {r0}
    4458:	0000b019 	andeq	fp, r0, r9, lsl r0
    445c:	00169900 	andseq	r9, r6, r0, lsl #18
    4460:	00169100 	andseq	r9, r6, r0, lsl #2
    4464:	08860100 	stmeq	r6, {r8}
    4468:	0c1f0000 	ldceq	0, cr0, [pc], {-0}
    446c:	00000050 	andeq	r0, r0, r0, asr r0
    4470:	000016b8 			@ <UNDEFINED> instruction: 0x000016b8
    4474:	000016b4 			@ <UNDEFINED> instruction: 0x000016b4
    4478:	00079001 	andeq	r9, r7, r1
    447c:	500c2000 	andpl	r2, ip, r0
    4480:	c5000000 	strgt	r0, [r0, #-0]
    4484:	c3000016 	movwgt	r0, #22
    4488:	05000016 	streq	r0, [r0, #-22]	@ 0xffffffea
    448c:	00001acc 	andeq	r1, r0, ip, asr #21
    4490:	0000016b 	andeq	r0, r0, fp, ror #2
    4494:	001ad609 	andseq	sp, sl, r9, lsl #12
    4498:	00018100 	andeq	r8, r1, r0, lsl #2
    449c:	00055700 	andeq	r5, r5, r0, lsl #14
    44a0:	50010200 	andpl	r0, r1, r0, lsl #4
    44a4:	33cc0305 	biccc	r0, ip, #335544320	@ 0x14000000
    44a8:	06000000 	streq	r0, [r0], -r0
    44ac:	00001ae2 	andeq	r1, r0, r2, ror #21
    44b0:	00000181 	andeq	r0, r0, r1, lsl #3
    44b4:	05500102 	ldrbeq	r0, [r0, #-258]	@ 0xfffffefe
    44b8:	0033ac03 	eorseq	sl, r3, r3, lsl #24
    44bc:	00000000 	andeq	r0, r0, r0
    44c0:	00000c30 	andeq	r0, r0, r0, lsr ip
    44c4:	04010005 	streq	r0, [r1], #-5
    44c8:	00001890 	muleq	r0, r0, r8
    44cc:	0000461a 	andeq	r4, r0, sl, lsl r6
    44d0:	0cad1d00 	stceq	13, cr1, [sp]
    44d4:	00140000 	andseq	r0, r4, r0
    44d8:	1c200000 	stcne	0, cr0, [r0], #-0
    44dc:	05fc0000 	ldrbeq	r0, [ip, #0]!
    44e0:	312f0000 			@ <UNDEFINED> instruction: 0x312f0000
    44e4:	041b0000 	ldreq	r0, [fp], #-0
    44e8:	746e6905 	strbtvc	r6, [lr], #-2309	@ 0xfffff6fb
    44ec:	000d1300 	andeq	r1, sp, r0, lsl #6
    44f0:	d6020000 	strle	r0, [r2], -r0
    44f4:	00003917 	andeq	r3, r0, r7, lsl r9
    44f8:	07040600 	streq	r0, [r4, -r0, lsl #12]
    44fc:	0000017b 	andeq	r0, r0, fp, ror r1
    4500:	c2050806 	andgt	r0, r5, #393216	@ 0x60000
    4504:	06000001 	streq	r0, [r0], -r1
    4508:	02250408 	eoreq	r0, r5, #8, 8	@ 0x8000000
    450c:	01060000 	mrseq	r0, (UNDEF: 6)
    4510:	00012d06 	andeq	r2, r1, r6, lsl #26
    4514:	05020600 	streq	r0, [r2, #-1536]	@ 0xfffffa00
    4518:	000001e3 	andeq	r0, r0, r3, ror #3
    451c:	c7050406 	strgt	r0, [r5, -r6, lsl #8]
    4520:	13000001 	movwne	r0, #1
    4524:	00000188 	andeq	r0, r0, r8, lsl #3
    4528:	74182e03 	ldrvc	r2, [r8], #-3587	@ 0xfffff1fd
    452c:	10000000 	andne	r0, r0, r0
    4530:	00000063 	andeq	r0, r0, r3, rrx
    4534:	2b080106 	blcs	204954 <__ROM_SIZE__+0x1c4954>
    4538:	06000001 	streq	r0, [r0], -r1
    453c:	01390702 	teqeq	r9, r2, lsl #14
    4540:	04060000 	streq	r0, [r6], #-0
    4544:	00017607 	andeq	r7, r1, r7, lsl #12
    4548:	07080600 	streq	r0, [r8, -r0, lsl #12]
    454c:	00000171 	andeq	r0, r0, r1, ror r1
    4550:	0001a01c 	andeq	sl, r1, ip, lsl r0
    4554:	04010000 	streq	r0, [r1], #-0
    4558:	00b8082c 	adcseq	r0, r8, ip, lsr #16
    455c:	961d0000 	ldrls	r0, [sp], -r0
    4560:	0400000c 	streq	r0, [r0], #-12
    4564:	00bd0b2e 	adcseq	r0, sp, lr, lsr #22
    4568:	1e000000 	cdpne	0, 0, cr0, cr0, cr0, {0}
    456c:	04007649 	streq	r7, [r0], #-1609	@ 0xfffff9b7
    4570:	00cd0b30 	sbceq	r0, sp, r0, lsr fp
    4574:	00f00000 	rscseq	r0, r0, r0
    4578:	00009010 	andeq	r9, r0, r0, lsl r0
    457c:	00630d00 	rsbeq	r0, r3, r0, lsl #26
    4580:	00cd0000 	sbceq	r0, sp, r0
    4584:	390a0000 	stmdbcc	sl, {}	@ <UNPREDICTABLE>
    4588:	ef000000 	svc	0x00000000
    458c:	00630d00 	rsbeq	r0, r3, r0, lsl #26
    4590:	00dd0000 	sbcseq	r0, sp, r0
    4594:	390a0000 	stmdbcc	sl, {}	@ <UNPREDICTABLE>
    4598:	0f000000 	svceq	0x00000000
    459c:	0c741300 	ldcleq	3, cr1, [r4], #-0
    45a0:	48010000 	stmdami	r1, {}	@ <UNPREDICTABLE>
    45a4:	0000e911 	andeq	lr, r0, r1, lsl r9
    45a8:	00630d00 	rsbeq	r0, r3, r0, lsl #26
    45ac:	00ff0000 	rscseq	r0, pc, r0
    45b0:	390a0000 	stmdbcc	sl, {}	@ <UNPREDICTABLE>
    45b4:	03000000 	movweq	r0, #0
    45b8:	0000390a 	andeq	r3, r0, sl, lsl #18
    45bc:	0d000300 	stceq	3, cr0, [r0, #-0]
    45c0:	0000006f 	andeq	r0, r0, pc, rrx
    45c4:	0000010f 	andeq	r0, r0, pc, lsl #2
    45c8:	0000390a 	andeq	r3, r0, sl, lsl #18
    45cc:	1000ff00 	andne	pc, r0, r0, lsl #30
    45d0:	000000ff 	strdeq	r0, [r0], -pc	@ <UNPREDICTABLE>
    45d4:	000c4811 	andeq	r4, ip, r1, lsl r8
    45d8:	0f164f00 	svceq	0x00164f00
    45dc:	05000001 	streq	r0, [r0, #-1]
    45e0:	00361403 	eorseq	r1, r6, r3, lsl #8
    45e4:	0c471100 	stfeqe	f1, [r7], {-0}
    45e8:	16630000 	strbtne	r0, [r3], -r0
    45ec:	0000010f 	andeq	r0, r0, pc, lsl #2
    45f0:	37200305 	strcc	r0, [r0, -r5, lsl #6]!
    45f4:	6f0d0000 	svcvs	0x000d0000
    45f8:	46000000 	strmi	r0, [r0], -r0
    45fc:	0a000001 	beq	4608 <base_order+0xd88>
    4600:	00000039 	andeq	r0, r0, r9, lsr r0
    4604:	3610000a 	ldrcc	r0, [r0], -sl
    4608:	11000001 	tstne	r0, r1
    460c:	00000cfe 	strdeq	r0, [r0], -lr
    4610:	01461678 	hvceq	24936	@ 0x6168
    4614:	03050000 	movweq	r0, #20480	@ 0x5000
    4618:	00003714 	andeq	r3, r0, r4, lsl r7
    461c:	00070e1f 	andeq	r0, r7, pc, lsl lr
    4620:	07380500 	ldreq	r0, [r8, -r0, lsl #10]!
    4624:	0000017c 	andeq	r0, r0, ip, ror r1
    4628:	0000017c 	andeq	r0, r0, ip, ror r1
    462c:	00017c14 	andeq	r7, r1, r4, lsl ip
    4630:	017e1400 	cmneq	lr, r0, lsl #8
    4634:	2d140000 	ldccs	0, cr0, [r4, #-0]
    4638:	00000000 	andeq	r0, r0, r0
    463c:	830c0420 	movwhi	r0, #50208	@ 0xc420
    4640:	21000001 	tstcs	r0, r1
    4644:	000ce20e 	andeq	lr, ip, lr, lsl #4
    4648:	a8021a00 	stmdage	r2, {r9, fp, ip}
    464c:	74000021 	strvc	r0, [r0], #-33	@ 0xffffffdf
    4650:	01000000 	mrseq	r0, (UNDEF: 0)
    4654:	00023f9c 	muleq	r2, ip, pc	@ <UNPREDICTABLE>
    4658:	74630500 	strbtvc	r0, [r3], #-1280	@ 0xfffffb00
    465c:	021a0078 	andseq	r0, sl, #120	@ 0x78
    4660:	00023f2c 	andeq	r3, r2, ip, lsr #30
    4664:	0016db00 	andseq	sp, r6, r0, lsl #22
    4668:	0016d700 	andseq	sp, r6, r0, lsl #14
    466c:	75620500 	strbvc	r0, [r2, #-1280]!	@ 0xfffffb00
    4670:	021a0066 	andseq	r0, sl, #102	@ 0x66
    4674:	0002443a 	andeq	r4, r2, sl, lsr r4
    4678:	0016ee00 	andseq	lr, r6, r0, lsl #28
    467c:	0016ea00 	andseq	lr, r6, r0, lsl #20
    4680:	0a020700 	beq	86288 <__ROM_SIZE__+0x46288>
    4684:	021a0000 	andseq	r0, sl, #0
    4688:	00002d46 	andeq	r2, r0, r6, asr #26
    468c:	00170100 	andseq	r0, r7, r0, lsl #2
    4690:	0016fd00 	andseq	pc, r6, r0, lsl #26
    4694:	0c8c1800 	stceq	8, cr1, [ip], {0}
    4698:	021c0000 	andseq	r0, ip, #0
    469c:	000000cd 	andeq	r0, r0, sp, asr #1
    46a0:	03589102 	cmpeq	r8, #-2147483648	@ 0x80000000
    46a4:	021e0069 	andseq	r0, lr, #105	@ 0x69
    46a8:	00002d0a 	andeq	r2, r0, sl, lsl #26
    46ac:	00171400 	andseq	r1, r7, r0, lsl #8
    46b0:	00171000 	andseq	r1, r7, r0
    46b4:	69620300 	stmdbvs	r2!, {r8, r9}^
    46b8:	07021f00 	streq	r1, [r2, -r0, lsl #30]
    46bc:	00000026 	andeq	r0, r0, r6, lsr #32
    46c0:	0000172e 	andeq	r1, r0, lr, lsr #14
    46c4:	00001724 	andeq	r1, r0, r4, lsr #14
    46c8:	0021f402 	eoreq	pc, r1, r2, lsl #8
    46cc:	00015c00 	andeq	r5, r1, r0, lsl #24
    46d0:	00022800 	andeq	r2, r2, r0, lsl #16
    46d4:	50010100 	andpl	r0, r1, r0, lsl #2
    46d8:	01007d02 	tsteq	r0, r2, lsl #26
    46dc:	77035101 	strvc	r5, [r3, -r1, lsl #2]
    46e0:	010101f0 	strdeq	r0, [r1, -r0]
    46e4:	00400152 	subeq	r0, r0, r2, asr r1
    46e8:	0021fc04 	eoreq	pc, r1, r4, lsl #24
    46ec:	0005a500 	andeq	sl, r5, r0, lsl #10
    46f0:	50010100 	andpl	r0, r1, r0, lsl #2
    46f4:	01007d02 	tsteq	r0, r2, lsl #26
    46f8:	77025101 	strvc	r5, [r2, -r1, lsl #2]
    46fc:	0c000000 	stceq	0, cr0, [r0], {-0}
    4700:	00000090 	muleq	r0, r0, r0
    4704:	0000630c 	andeq	r6, r0, ip, lsl #6
    4708:	0c7c0e00 	ldcleq	14, cr0, [ip], #-0
    470c:	02040000 	andeq	r0, r4, #0
    4710:	00002162 	andeq	r2, r0, r2, ror #2
    4714:	00000046 	andeq	r0, r0, r6, asr #32
    4718:	03299c01 			@ <UNDEFINED> instruction: 0x03299c01
    471c:	63050000 	movwvs	r0, #20480	@ 0x5000
    4720:	04007874 	streq	r7, [r0], #-2164	@ 0xfffff78c
    4724:	023f2d02 	eorseq	r2, pc, #2, 26	@ 0x80
    4728:	17580000 	ldrbne	r0, [r8, -r0]
    472c:	17540000 	ldrbne	r0, [r4, -r0]
    4730:	62050000 	andvs	r0, r5, #0
    4734:	04006675 	streq	r6, [r0], #-1653	@ 0xfffff98b
    4738:	02443b02 	subeq	r3, r4, #2048	@ 0x800
    473c:	176b0000 	strbne	r0, [fp, -r0]!
    4740:	17670000 	strbne	r0, [r7, -r0]!
    4744:	02070000 	andeq	r0, r7, #0
    4748:	0400000a 	streq	r0, [r0], #-10
    474c:	002d4702 	eoreq	r4, sp, r2, lsl #14
    4750:	177e0000 	ldrbne	r0, [lr, -r0]!
    4754:	177a0000 	ldrbne	r0, [sl, -r0]!
    4758:	69030000 	stmdbvs	r3, {}	@ <UNPREDICTABLE>
    475c:	0a020600 	beq	85f64 <__ROM_SIZE__+0x45f64>
    4760:	0000002d 	andeq	r0, r0, sp, lsr #32
    4764:	00001791 	muleq	r0, r1, r7
    4768:	0000178d 	andeq	r1, r0, sp, lsl #15
    476c:	000c3b18 	andeq	r3, ip, r8, lsl fp
    4770:	cd020700 	stcgt	7, cr0, [r2, #-0]
    4774:	02000000 	andeq	r0, r0, #0
    4778:	7c025891 	stcvc	8, cr5, [r2], {145}	@ 0x91
    477c:	5c000021 	stcpl	0, cr0, [r0], {33}	@ 0x21
    4780:	d9000001 	stmdble	r0, {r0}
    4784:	01000002 	tsteq	r0, r2
    4788:	7d025001 	stcvc	0, cr5, [r2, #-4]
    478c:	51010100 	mrspl	r0, (UNDEF: 17)
    4790:	01007402 	tsteq	r0, r2, lsl #8
    4794:	40015201 	andmi	r5, r1, r1, lsl #4
    4798:	21840200 	orrcs	r0, r4, r0, lsl #4
    479c:	04d80000 	ldrbeq	r0, [r8], #0
    47a0:	02f30000 	rscseq	r0, r3, #0
    47a4:	01010000 	mrseq	r0, (UNDEF: 1)
    47a8:	00740250 	rsbseq	r0, r4, r0, asr r2
    47ac:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    47b0:	02000077 	andeq	r0, r0, #119	@ 0x77
    47b4:	00002190 	muleq	r0, r0, r1
    47b8:	000003e3 	andeq	r0, r0, r3, ror #7
    47bc:	0000030d 	andeq	r0, r0, sp, lsl #6
    47c0:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    47c4:	01010074 	tsteq	r1, r4, ror r0
    47c8:	00760251 	rsbseq	r0, r6, r1, asr r2
    47cc:	219a0400 	orrscs	r0, sl, r0, lsl #8
    47d0:	015c0000 	cmpeq	ip, r0
    47d4:	01010000 	mrseq	r0, (UNDEF: 1)
    47d8:	00760250 	rsbseq	r0, r6, r0, asr r2
    47dc:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    47e0:	0101007d 	tsteq	r1, sp, ror r0
    47e4:	00400152 	subeq	r0, r0, r2, asr r1
    47e8:	0c4d0e00 	mcrreq	14, 0, r0, sp, cr0
    47ec:	01f50000 	mvnseq	r0, r0
    47f0:	0000212a 	andeq	r2, r0, sl, lsr #2
    47f4:	00000038 	andeq	r0, r0, r8, lsr r0
    47f8:	03e39c01 	mvneq	r9, #256	@ 0x100
    47fc:	63050000 	movwvs	r0, #20480	@ 0x5000
    4800:	f5007874 			@ <UNDEFINED> instruction: 0xf5007874
    4804:	023f2d01 	eorseq	r2, pc, #1, 26	@ 0x40
    4808:	17a50000 	strne	r0, [r5, r0]!
    480c:	17a10000 	strne	r0, [r1, r0]!
    4810:	62050000 	andvs	r0, r5, #0
    4814:	f5006675 			@ <UNDEFINED> instruction: 0xf5006675
    4818:	02443b01 	subeq	r3, r4, #1024	@ 0x400
    481c:	17bc0000 	ldrne	r0, [ip, r0]!
    4820:	17b40000 	ldrne	r0, [r4, r0]!
    4824:	02070000 	andeq	r0, r7, #0
    4828:	f500000a 			@ <UNDEFINED> instruction: 0xf500000a
    482c:	002d4701 	eoreq	r4, sp, r1, lsl #14
    4830:	17df0000 	ldrbne	r0, [pc, r0]
    4834:	17db0000 	ldrbne	r0, [fp, r0]
    4838:	69030000 	stmdbvs	r3, {}	@ <UNPREDICTABLE>
    483c:	0a01f700 	beq	82444 <__ROM_SIZE__+0x42444>
    4840:	0000002d 	andeq	r0, r0, sp, lsr #32
    4844:	000017f2 	strdeq	r1, [r0], -r2
    4848:	000017ee 	andeq	r1, r0, lr, ror #15
    484c:	00764903 	rsbseq	r4, r6, r3, lsl #18
    4850:	440c01f8 	strmi	r0, [ip], #-504	@ 0xfffffe08
    4854:	0a000002 	beq	4864 <base_order+0xfe4>
    4858:	02000018 	andeq	r0, r0, #24
    485c:	02000018 	andeq	r0, r0, #24
    4860:	00002144 	andeq	r2, r0, r4, asr #2
    4864:	000003e3 	andeq	r0, r0, r3, ror #7
    4868:	000003b3 			@ <UNDEFINED> instruction: 0x000003b3
    486c:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    4870:	02000074 	andeq	r0, r0, #116	@ 0x74
    4874:	0000214c 	andeq	r2, r0, ip, asr #2
    4878:	000005a5 	andeq	r0, r0, r5, lsr #11
    487c:	000003cd 	andeq	r0, r0, sp, asr #7
    4880:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    4884:	01010074 	tsteq	r1, r4, ror r0
    4888:	00760251 	rsbseq	r0, r6, r1, asr r2
    488c:	215e0400 	cmpcs	lr, r0, lsl #8
    4890:	015c0000 	cmpeq	ip, r0
    4894:	01010000 	mrseq	r0, (UNDEF: 1)
    4898:	00780250 	rsbseq	r0, r8, r0, asr r2
    489c:	01520101 	cmpeq	r2, r1, lsl #2
    48a0:	08000040 	stmdaeq	r0, {r6}
    48a4:	00000d3e 	andeq	r0, r0, lr, lsr sp
    48a8:	20c801ec 	sbccs	r0, r8, ip, ror #3
    48ac:	001a0000 	andseq	r0, sl, r0
    48b0:	9c010000 	stcls	0, cr0, [r1], {-0}
    48b4:	00000422 	andeq	r0, r0, r2, lsr #8
    48b8:	66756219 			@ <UNDEFINED> instruction: 0x66756219
    48bc:	02442000 	subeq	r2, r4, #0
    48c0:	50010000 	andpl	r0, r1, r0
    48c4:	00764919 	rsbseq	r4, r6, r9, lsl r9
    48c8:	00042234 	andeq	r2, r4, r4, lsr r2
    48cc:	03510100 	cmpeq	r1, #0, 2
    48d0:	01ee0069 	mvneq	r0, r9, rrx
    48d4:	0000630b 	andeq	r6, r0, fp, lsl #6
    48d8:	00182d00 	andseq	r2, r8, r0, lsl #26
    48dc:	00182700 	andseq	r2, r8, r0, lsl #14
    48e0:	6f0c0000 	svcvs	0x000c0000
    48e4:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
    48e8:	000000f5 	strdeq	r0, [r0], -r5
    48ec:	211c01dc 			@ <UNDEFINED> instruction: 0x211c01dc
    48f0:	000e0000 	andeq	r0, lr, r0
    48f4:	9c010000 	stcls	0, cr0, [r1], {-0}
    48f8:	0000047d 	andeq	r0, r0, sp, ror r4
    48fc:	78746305 	ldmdavc	r4!, {r0, r2, r8, r9, sp, lr}^
    4900:	2c01dc00 	stccs	12, cr13, [r1], {-0}
    4904:	0000047d 	andeq	r0, r0, sp, ror r4
    4908:	0000184a 	andeq	r1, r0, sl, asr #16
    490c:	00001844 	andeq	r1, r0, r4, asr #16
    4910:	66756205 	ldrbtvs	r6, [r5], -r5, lsl #4
    4914:	3a01dc00 	bcc	7b91c <__ROM_SIZE__+0x3b91c>
    4918:	00000244 	andeq	r0, r0, r4, asr #4
    491c:	00001869 	andeq	r1, r0, r9, ror #16
    4920:	00001863 	andeq	r1, r0, r3, ror #16
    4924:	00212804 	eoreq	r2, r1, r4, lsl #16
    4928:	0004d800 	andeq	sp, r4, r0, lsl #16
    492c:	50010100 	andpl	r0, r1, r0, lsl #2
    4930:	5101a303 	tstpl	r1, r3, lsl #6
    4934:	03510101 	cmpeq	r1, #1073741824	@ 0x40000000
    4938:	005001a3 	subseq	r0, r0, r3, lsr #3
    493c:	00b80c00 	adcseq	r0, r8, r0, lsl #24
    4940:	180e0000 	stmdane	lr, {}	@ <UNPREDICTABLE>
    4944:	d6000004 	strle	r0, [r0], -r4
    4948:	00210e01 	eoreq	r0, r1, r1, lsl #28
    494c:	00000e00 	andeq	r0, r0, r0, lsl #28
    4950:	d89c0100 	ldmle	ip, {r8}
    4954:	05000004 	streq	r0, [r0, #-4]
    4958:	00787463 	rsbseq	r7, r8, r3, ror #8
    495c:	7d2c01d6 	stfvcs	f0, [ip, #-856]!	@ 0xfffffca8
    4960:	88000004 	stmdahi	r0, {r2}
    4964:	82000018 	andhi	r0, r0, #24
    4968:	05000018 	streq	r0, [r0, #-24]	@ 0xffffffe8
    496c:	00667562 	rsbeq	r7, r6, r2, ror #10
    4970:	443a01d6 	ldrtmi	r0, [sl], #-470	@ 0xfffffe2a
    4974:	a7000002 	strge	r0, [r0, -r2]
    4978:	a1000018 	tstge	r0, r8, lsl r0
    497c:	04000018 	streq	r0, [r0], #-24	@ 0xffffffe8
    4980:	0000211a 	andeq	r2, r0, sl, lsl r1
    4984:	000005a5 	andeq	r0, r0, r5, lsr #11
    4988:	03500101 	cmpeq	r0, #1073741824	@ 0x40000000
    498c:	015101a3 	cmpeq	r1, r3, lsr #3
    4990:	a3035101 	movwge	r5, #12545	@ 0x3101
    4994:	00005001 	andeq	r5, r0, r1
    4998:	000c6408 	andeq	r6, ip, r8, lsl #8
    499c:	8e01b700 	cdphi	7, 0, cr11, cr1, cr0, {0}
    49a0:	3a000020 	bcc	4a28 <base_order+0x11a8>
    49a4:	01000000 	mrseq	r0, (UNDEF: 0)
    49a8:	0005a09c 	muleq	r5, ip, r0
    49ac:	0b2e0700 	bleq	b865b4 <__ROM_SIZE__+0xb465b4>
    49b0:	01b70000 			@ <UNDEFINED> instruction: 0x01b70000
    49b4:	0005a020 	andeq	sl, r5, r0, lsr #32
    49b8:	0018c600 	andseq	ip, r8, r0, lsl #12
    49bc:	0018c000 	andseq	ip, r8, r0
    49c0:	0c960700 	ldceq	7, cr0, [r6], {0}
    49c4:	01b70000 			@ <UNDEFINED> instruction: 0x01b70000
    49c8:	00042236 	andeq	r2, r4, r6, lsr r2
    49cc:	0018e200 	andseq	lr, r8, r0, lsl #4
    49d0:	0018dc00 	andseq	sp, r8, r0, lsl #24
    49d4:	0cf81200 	lfmeq	f1, 2, [r8]
    49d8:	01b90000 			@ <UNDEFINED> instruction: 0x01b90000
    49dc:	00000063 	andeq	r0, r0, r3, rrx
    49e0:	00001900 	andeq	r1, r0, r0, lsl #18
    49e4:	000018f8 	strdeq	r1, [r0], -r8
    49e8:	00209e02 	eoreq	r9, r0, r2, lsl #28
    49ec:	000a0400 	andeq	r0, sl, r0, lsl #8
    49f0:	00054700 	andeq	r4, r5, r0, lsl #14
    49f4:	50010100 	andpl	r0, r1, r0, lsl #2
    49f8:	01013e01 	tsteq	r1, r1, lsl #28
    49fc:	00750251 	rsbseq	r0, r5, r1, asr r2
    4a00:	02520101 	subseq	r0, r2, #1073741824	@ 0x40000000
    4a04:	02000076 	andeq	r0, r0, #118	@ 0x76
    4a08:	000020a8 	andeq	r2, r0, r8, lsr #1
    4a0c:	0000070b 	andeq	r0, r0, fp, lsl #14
    4a10:	0000055b 	andeq	r0, r0, fp, asr r5
    4a14:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    4a18:	02000075 	andeq	r0, r0, #117	@ 0x75
    4a1c:	000020b2 	strheq	r2, [r0], -r2	@ <UNPREDICTABLE>
    4a20:	0000068c 	andeq	r0, r0, ip, lsl #13
    4a24:	0000056f 	andeq	r0, r0, pc, ror #10
    4a28:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    4a2c:	02000075 	andeq	r0, r0, #117	@ 0x75
    4a30:	000020b8 	strheq	r2, [r0], -r8
    4a34:	000006c3 	andeq	r0, r0, r3, asr #13
    4a38:	00000583 	andeq	r0, r0, r3, lsl #11
    4a3c:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    4a40:	04000075 	streq	r0, [r0], #-117	@ 0xffffff8b
    4a44:	000020c2 	andeq	r2, r0, r2, asr #1
    4a48:	00000a04 	andeq	r0, r0, r4, lsl #20
    4a4c:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    4a50:	01010074 	tsteq	r1, r4, ror r0
    4a54:	00750251 	rsbseq	r0, r5, r1, asr r2
    4a58:	02520101 	subseq	r0, r2, #1073741824	@ 0x40000000
    4a5c:	00000076 	andeq	r0, r0, r6, ror r0
    4a60:	0000dd0c 	andeq	sp, r0, ip, lsl #26
    4a64:	0c670800 	stcleq	8, cr0, [r7], #-0
    4a68:	019d0000 	orrseq	r0, sp, r0
    4a6c:	0000204a 	andeq	r2, r0, sl, asr #32
    4a70:	00000044 	andeq	r0, r0, r4, asr #32
    4a74:	068c9c01 	streq	r9, [ip], r1, lsl #24
    4a78:	2e070000 	cdpcs	0, 0, cr0, cr7, cr0, {0}
    4a7c:	9d00000b 	stcls	0, cr0, [r0, #-44]	@ 0xffffffd4
    4a80:	05a01d01 	streq	r1, [r0, #3329]!	@ 0xd01
    4a84:	19250000 	stmdbne	r5!, {}	@ <UNPREDICTABLE>
    4a88:	191f0000 	ldmdbne	pc, {}	@ <UNPREDICTABLE>
    4a8c:	96070000 	strls	r0, [r7], -r0
    4a90:	9d00000c 	stcls	0, cr0, [r0, #-48]	@ 0xffffffd0
    4a94:	04223301 	strteq	r3, [r2], #-769	@ 0xfffffcff
    4a98:	19410000 	stmdbne	r1, {}^	@ <UNPREDICTABLE>
    4a9c:	193b0000 	ldmdbne	fp!, {}	@ <UNPREDICTABLE>
    4aa0:	f8120000 			@ <UNDEFINED> instruction: 0xf8120000
    4aa4:	9f00000c 	svcls	0x0000000c
    4aa8:	00006301 	andeq	r6, r0, r1, lsl #6
    4aac:	00195f00 	andseq	r5, r9, r0, lsl #30
    4ab0:	00195700 	andseq	r5, r9, r0, lsl #14
    4ab4:	205a0200 	subscs	r0, sl, r0, lsl #4
    4ab8:	0a040000 	beq	104ac0 <__ROM_SIZE__+0xc4ac0>
    4abc:	06140000 	ldreq	r0, [r4], -r0
    4ac0:	01010000 	mrseq	r0, (UNDEF: 1)
    4ac4:	01300150 	teqeq	r0, r0, asr r1
    4ac8:	75025101 	strvc	r5, [r2, #-257]	@ 0xfffffeff
    4acc:	52010100 	andpl	r0, r1, #0, 2
    4ad0:	00007602 	andeq	r7, r0, r2, lsl #12
    4ad4:	00206402 	eoreq	r6, r0, r2, lsl #8
    4ad8:	00088e00 	andeq	r8, r8, r0, lsl #28
    4adc:	00062800 	andeq	r2, r6, r0, lsl #16
    4ae0:	50010100 	andpl	r0, r1, r0, lsl #2
    4ae4:	00007502 	andeq	r7, r0, r2, lsl #10
    4ae8:	00206e02 	eoreq	r6, r0, r2, lsl #28
    4aec:	000a0400 	andeq	r0, sl, r0, lsl #8
    4af0:	00064800 	andeq	r4, r6, r0, lsl #16
    4af4:	50010100 	andpl	r0, r1, r0, lsl #2
    4af8:	01007402 	tsteq	r0, r2, lsl #8
    4afc:	75025101 	strvc	r5, [r2, #-257]	@ 0xfffffeff
    4b00:	52010100 	andpl	r0, r1, #0, 2
    4b04:	00007602 	andeq	r7, r0, r2, lsl #12
    4b08:	00207802 	eoreq	r7, r0, r2, lsl #16
    4b0c:	0009c000 	andeq	ip, r9, r0
    4b10:	00065c00 	andeq	r5, r6, r0, lsl #24
    4b14:	50010100 	andpl	r0, r1, r0, lsl #2
    4b18:	00007502 	andeq	r7, r0, r2, lsl #10
    4b1c:	00207e02 	eoreq	r7, r0, r2, lsl #28
    4b20:	00098900 	andeq	r8, r9, r0, lsl #18
    4b24:	00067000 	andeq	r7, r6, r0
    4b28:	50010100 	andpl	r0, r1, r0, lsl #2
    4b2c:	00007502 	andeq	r7, r0, r2, lsl #10
    4b30:	00208c04 	eoreq	r8, r0, r4, lsl #24
    4b34:	000a0400 	andeq	r0, sl, r0, lsl #8
    4b38:	50010100 	andpl	r0, r1, r0, lsl #2
    4b3c:	01013e01 	tsteq	r1, r1, lsl #28
    4b40:	00750251 	rsbseq	r0, r5, r1, asr r2
    4b44:	02520101 	subseq	r0, r2, #1073741824	@ 0x40000000
    4b48:	00000076 	andeq	r0, r0, r6, ror r0
    4b4c:	000d1208 	andeq	r1, sp, r8, lsl #4
    4b50:	18017f00 	stmdane	r1, {r8, r9, sl, fp, ip, sp, lr}
    4b54:	32000020 	andcc	r0, r0, #32
    4b58:	01000000 	mrseq	r0, (UNDEF: 0)
    4b5c:	0006c39c 	muleq	r6, ip, r3
    4b60:	0b2e1500 	bleq	b89f68 <__ROM_SIZE__+0xb49f68>
    4b64:	017f0000 	cmneq	pc, r0
    4b68:	0005a023 	andeq	sl, r5, r3, lsr #32
    4b6c:	12500100 	subsne	r0, r0, #0, 2
    4b70:	00000c36 	andeq	r0, r0, r6, lsr ip
    4b74:	00630181 	rsbeq	r0, r3, r1, lsl #3
    4b78:	19800000 	stmibne	r0, {}	@ <UNPREDICTABLE>
    4b7c:	197e0000 	ldmdbne	lr!, {}^	@ <UNPREDICTABLE>
    4b80:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
    4b84:	00000d32 	andeq	r0, r0, r2, lsr sp
    4b88:	1fd00173 	svcne	0x00d00173
    4b8c:	00480000 	subeq	r0, r8, r0
    4b90:	9c010000 	stcls	0, cr0, [r1], {-0}
    4b94:	0000070b 	andeq	r0, r0, fp, lsl #14
    4b98:	000b2e15 	andeq	r2, fp, r5, lsl lr
    4b9c:	22017300 	andcs	r7, r1, #0, 6
    4ba0:	000005a0 	andeq	r0, r0, r0, lsr #11
    4ba4:	69035001 	stmdbvs	r3, {r0, ip, lr}
    4ba8:	0b017500 	bleq	61fb0 <__ROM_SIZE__+0x21fb0>
    4bac:	00000063 	andeq	r0, r0, r3, rrx
    4bb0:	00001990 	muleq	r0, r0, r9
    4bb4:	00001988 	andeq	r1, r0, r8, lsl #19
    4bb8:	75006a03 	strvc	r6, [r0, #-2563]	@ 0xfffff5fd
    4bbc:	00630e01 	rsbeq	r0, r3, r1, lsl #28
    4bc0:	19b40000 	ldmibne	r4!, {}	@ <UNPREDICTABLE>
    4bc4:	19ae0000 	stmibne	lr!, {}	@ <UNPREDICTABLE>
    4bc8:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
    4bcc:	00000c9f 	muleq	r0, pc, ip	@ <UNPREDICTABLE>
    4bd0:	1e76015e 	mrcne	1, 3, r0, cr6, cr14, {2}
    4bd4:	015a0000 	cmpeq	sl, r0
    4bd8:	9c010000 	stcls	0, cr0, [r1], {-0}
    4bdc:	0000088e 	andeq	r0, r0, lr, lsl #17
    4be0:	000b2e07 	andeq	r2, fp, r7, lsl #28
    4be4:	24015e00 	strcs	r5, [r1], #-3584	@ 0xfffff200
    4be8:	000005a0 	andeq	r0, r0, r0, lsr #11
    4bec:	000019d0 	ldrdeq	r1, [r0], -r0
    4bf0:	000019ca 	andeq	r1, r0, sl, asr #19
    4bf4:	60006903 	andvs	r6, r0, r3, lsl #18
    4bf8:	00260701 	eoreq	r0, r6, r1, lsl #14
    4bfc:	19ed0000 	stmibne	sp!, {}^	@ <UNPREDICTABLE>
    4c00:	19e90000 	stmibne	r9!, {}^	@ <UNPREDICTABLE>
    4c04:	61030000 	mrsvs	r0, (UNDEF: 3)
    4c08:	0b016100 	bleq	5d010 <__ROM_SIZE__+0x1d010>
    4c0c:	00000063 	andeq	r0, r0, r3, rrx
    4c10:	000019ff 	strdeq	r1, [r0], -pc	@ <UNPREDICTABLE>
    4c14:	000019fd 	strdeq	r1, [r0], -sp
    4c18:	61006203 	tstvs	r0, r3, lsl #4
    4c1c:	00630e01 	rsbeq	r0, r3, r1, lsl #28
    4c20:	1a090000 	bne	244c28 <__ROM_SIZE__+0x204c28>
    4c24:	1a070000 	bne	1c4c2c <__ROM_SIZE__+0x184c2c>
    4c28:	63030000 	movwvs	r0, #12288	@ 0x3000
    4c2c:	11016100 	mrsne	r6, (UNDEF: 17)
    4c30:	00000063 	andeq	r0, r0, r3, rrx
    4c34:	00001a13 	andeq	r1, r0, r3, lsl sl
    4c38:	00001a11 	andeq	r1, r0, r1, lsl sl
    4c3c:	61006403 	tstvs	r0, r3, lsl #8
    4c40:	00631401 	rsbeq	r1, r3, r1, lsl #8
    4c44:	1a1d0000 	bne	744c4c <__ROM_SIZE__+0x704c4c>
    4c48:	1a1b0000 	bne	6c4c50 <__ROM_SIZE__+0x684c50>
    4c4c:	9e020000 	cdpls	0, 0, cr0, cr2, cr0, {0}
    4c50:	5b00001e 	blpl	4cd0 <base_order+0x1450>
    4c54:	a2000009 	andge	r0, r0, #9
    4c58:	01000007 	tsteq	r0, r7
    4c5c:	7b025001 	blvc	98c68 <__ROM_SIZE__+0x58c68>
    4c60:	a4020000 	strge	r0, [r2], #-0
    4c64:	5b00001e 	blpl	4ce4 <base_order+0x1464>
    4c68:	b8000009 	stmdalt	r0, {r0, r3}
    4c6c:	01000007 	tsteq	r0, r7
    4c70:	91045001 	tstls	r4, r1
    4c74:	0001944c 	andeq	r9, r1, ip, asr #8
    4c78:	001eaa02 	andseq	sl, lr, r2, lsl #20
    4c7c:	00095b00 	andeq	r5, r9, r0, lsl #22
    4c80:	0007cf00 	andeq	ip, r7, r0, lsl #30
    4c84:	50010100 	andpl	r0, r1, r0, lsl #2
    4c88:	7fb49105 	svcvc	0x00b49105
    4c8c:	02000194 	andeq	r0, r0, #148, 2	@ 0x25
    4c90:	00001eb2 			@ <UNDEFINED> instruction: 0x00001eb2
    4c94:	0000095b 	andeq	r0, r0, fp, asr r9
    4c98:	000007e3 	andeq	r0, r0, r3, ror #15
    4c9c:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    4ca0:	0200007a 	andeq	r0, r0, #122	@ 0x7a
    4ca4:	00001eb8 			@ <UNDEFINED> instruction: 0x00001eb8
    4ca8:	0000095b 	andeq	r0, r0, fp, asr r9
    4cac:	000007fa 	strdeq	r0, [r0], -sl
    4cb0:	05500101 	ldrbeq	r0, [r0, #-257]	@ 0xfffffeff
    4cb4:	947fb891 	ldrbtls	fp, [pc], #-2193	@ 4cbc <base_order+0x143c>
    4cb8:	be020001 	cdplt	0, 0, cr0, cr2, cr1, {0}
    4cbc:	5b00001e 	blpl	4d3c <base_order+0x14bc>
    4cc0:	11000009 	tstne	r0, r9
    4cc4:	01000008 	tsteq	r0, r8
    4cc8:	91055001 	tstls	r5, r1
    4ccc:	01947fbc 			@ <UNDEFINED> instruction: 0x01947fbc
    4cd0:	1ec60200 	cdpne	2, 12, cr0, cr6, cr0, {0}
    4cd4:	095b0000 	ldmdbeq	fp, {}^	@ <UNPREDICTABLE>
    4cd8:	08250000 	stmdaeq	r5!, {}	@ <UNPREDICTABLE>
    4cdc:	01010000 	mrseq	r0, (UNDEF: 1)
    4ce0:	00790250 	rsbseq	r0, r9, r0, asr r2
    4ce4:	1ecc0200 	cdpne	2, 12, cr0, cr12, cr0, {0}
    4ce8:	095b0000 	ldmdbeq	fp, {}^	@ <UNPREDICTABLE>
    4cec:	083b0000 	ldmdaeq	fp!, {}	@ <UNPREDICTABLE>
    4cf0:	01010000 	mrseq	r0, (UNDEF: 1)
    4cf4:	54910450 	ldrpl	r0, [r1], #1104	@ 0x450
    4cf8:	02000194 	andeq	r0, r0, #148, 2	@ 0x25
    4cfc:	00001ed2 	ldrdeq	r1, [r0], -r2
    4d00:	0000095b 	andeq	r0, r0, fp, asr r9
    4d04:	00000851 	andeq	r0, r0, r1, asr r8
    4d08:	04500101 	ldrbeq	r0, [r0], #-257	@ 0xfffffeff
    4d0c:	01944091 			@ <UNDEFINED> instruction: 0x01944091
    4d10:	1eda0200 	cdpne	2, 13, cr0, cr10, cr0, {0}
    4d14:	095b0000 	ldmdbeq	fp, {}^	@ <UNPREDICTABLE>
    4d18:	08650000 	stmdaeq	r5!, {}^	@ <UNPREDICTABLE>
    4d1c:	01010000 	mrseq	r0, (UNDEF: 1)
    4d20:	00750250 	rsbseq	r0, r5, r0, asr r2
    4d24:	1ee00200 	cdpne	2, 14, cr0, cr0, cr0, {0}
    4d28:	095b0000 	ldmdbeq	fp, {}^	@ <UNPREDICTABLE>
    4d2c:	087b0000 	ldmdaeq	fp!, {}^	@ <UNPREDICTABLE>
    4d30:	01010000 	mrseq	r0, (UNDEF: 1)
    4d34:	44910450 	ldrmi	r0, [r1], #1104	@ 0x450
    4d38:	04000194 	streq	r0, [r0], #-404	@ 0xfffffe6c
    4d3c:	00001ee6 	andeq	r1, r0, r6, ror #29
    4d40:	0000095b 	andeq	r0, r0, fp, asr r9
    4d44:	04500101 	ldrbeq	r0, [r0], #-257	@ 0xfffffeff
    4d48:	01944891 			@ <UNDEFINED> instruction: 0x01944891
    4d4c:	a2080000 	andge	r0, r8, #0
    4d50:	2c00000c 	stccs	0, cr0, [r0], {12}
    4d54:	001e0001 	andseq	r0, lr, r1
    4d58:	00007600 	andeq	r7, r0, r0, lsl #12
    4d5c:	5b9c0100 	blpl	fe705164 <_STACK_TOP_+0xde6fd168>
    4d60:	07000009 	streq	r0, [r0, -r9]
    4d64:	00000b2e 	andeq	r0, r0, lr, lsr #22
    4d68:	a021012c 	eorge	r0, r1, ip, lsr #2
    4d6c:	29000005 	stmdbcs	r0, {r0, r2}
    4d70:	2500001a 	strcs	r0, [r0, #-26]	@ 0xffffffe6
    4d74:	0300001a 	movweq	r0, #26
    4d78:	012e0069 			@ <UNDEFINED> instruction: 0x012e0069
    4d7c:	0000630b 	andeq	r6, r0, fp, lsl #6
    4d80:	001a3e00 	andseq	r3, sl, r0, lsl #28
    4d84:	001a3800 	andseq	r3, sl, r0, lsl #16
    4d88:	6d540300 	ldclvs	3, cr0, [r4, #-0]
    4d8c:	012f0070 			@ <UNDEFINED> instruction: 0x012f0070
    4d90:	0000630b 	andeq	r6, r0, fp, lsl #6
    4d94:	001a5700 	andseq	r5, sl, r0, lsl #14
    4d98:	001a5500 	andseq	r5, sl, r0, lsl #10
    4d9c:	6d540300 	ldclvs	3, cr0, [r4, #-0]
    4da0:	10012f00 	andne	r2, r1, r0, lsl #30
    4da4:	00000063 	andeq	r0, r0, r3, rrx
    4da8:	00001a7d 	andeq	r1, r0, sp, ror sl
    4dac:	00001a5f 	andeq	r1, r0, pc, asr sl
    4db0:	2f007403 	svccs	0x00007403
    4db4:	00631401 	rsbeq	r1, r3, r1, lsl #8
    4db8:	1b0c0000 	blne	304dc0 <__ROM_SIZE__+0x2c4dc0>
    4dbc:	1b0a0000 	blne	284dc4 <__ROM_SIZE__+0x244dc4>
    4dc0:	2a020000 	bcs	84dc8 <__ROM_SIZE__+0x44dc8>
    4dc4:	5b00001e 	blpl	4e44 <base_order+0x15c4>
    4dc8:	19000009 	stmdbne	r0, {r0, r3}
    4dcc:	01000009 	tsteq	r0, r9
    4dd0:	7b055001 	blvc	158ddc <__ROM_SIZE__+0x118ddc>
    4dd4:	27007a00 	strcs	r7, [r0, -r0, lsl #20]
    4dd8:	1e3c0200 	cdpne	2, 3, cr0, cr12, cr0, {0}
    4ddc:	095b0000 	ldmdbeq	fp, {}^	@ <UNPREDICTABLE>
    4de0:	09300000 	ldmdbeq	r0!, {}	@ <UNPREDICTABLE>
    4de4:	01010000 	mrseq	r0, (UNDEF: 1)
    4de8:	007b0550 	rsbseq	r0, fp, r0, asr r5
    4dec:	00270078 	eoreq	r0, r7, r8, ror r0
    4df0:	001e4e02 	andseq	r4, lr, r2, lsl #28
    4df4:	00095b00 	andeq	r5, r9, r0, lsl #22
    4df8:	00094700 	andeq	r4, r9, r0, lsl #14
    4dfc:	50010100 	andpl	r0, r1, r0, lsl #2
    4e00:	77007805 	strvc	r7, [r0, -r5, lsl #16]
    4e04:	04002700 	streq	r2, [r0], #-1792	@ 0xfffff900
    4e08:	00001e60 	andeq	r1, r0, r0, ror #28
    4e0c:	0000095b 	andeq	r0, r0, fp, asr r9
    4e10:	05500101 	ldrbeq	r0, [r0, #-257]	@ 0xfffffeff
    4e14:	007a0077 	rsbseq	r0, sl, r7, ror r0
    4e18:	22000027 	andcs	r0, r0, #39	@ 0x27
    4e1c:	00000d1f 	andeq	r0, r0, pc, lsl sp
    4e20:	10012601 	andne	r2, r1, r1, lsl #12
    4e24:	00000063 	andeq	r0, r0, r3, rrx
    4e28:	00001dee 	andeq	r1, r0, lr, ror #27
    4e2c:	00000012 	andeq	r0, r0, r2, lsl r0
    4e30:	09899c01 	stmibeq	r9, {r0, sl, fp, ip, pc}
    4e34:	78050000 	stmdavc	r5, {}	@ <UNPREDICTABLE>
    4e38:	1e012600 	cfmadd32ne	mvax0, mvfx2, mvfx1, mvfx0
    4e3c:	00000063 	andeq	r0, r0, r3, rrx
    4e40:	00001b18 	andeq	r1, r0, r8, lsl fp
    4e44:	00001b14 	andeq	r1, r0, r4, lsl fp
    4e48:	0d150800 	ldceq	8, cr0, [r5, #-0]
    4e4c:	010a0000 	mrseq	r0, (UNDEF: 10)
    4e50:	00001dbc 			@ <UNDEFINED> instruction: 0x00001dbc
    4e54:	00000032 	andeq	r0, r0, r2, lsr r0
    4e58:	09c09c01 	stmibeq	r0, {r0, sl, fp, ip, pc}^
    4e5c:	2e150000 	cdpcs	0, 1, cr0, cr5, cr0, {0}
    4e60:	0a00000b 	beq	4e94 <base_order+0x1614>
    4e64:	05a02001 	streq	r2, [r0, #1]!
    4e68:	50010000 	andpl	r0, r1, r0
    4e6c:	000c3612 	andeq	r3, ip, r2, lsl r6
    4e70:	63010c00 	movwvs	r0, #7168	@ 0x1c00
    4e74:	2c000000 	stccs	0, cr0, [r0], {-0}
    4e78:	2a00001b 	bcs	4eec <base_order+0x166c>
    4e7c:	0000001b 	andeq	r0, r0, fp, lsl r0
    4e80:	000d3516 	andeq	r3, sp, r6, lsl r5
    4e84:	1d78fb00 	vldmdbne	r8!, {d31-d30}
    4e88:	00440000 	subeq	r0, r4, r0
    4e8c:	9c010000 	stcls	0, cr0, [r1], {-0}
    4e90:	00000a04 	andeq	r0, r0, r4, lsl #20
    4e94:	000b2e0f 	andeq	r2, fp, pc, lsl #28
    4e98:	a01ffb00 	andsge	pc, pc, r0, lsl #22
    4e9c:	01000005 	tsteq	r0, r5
    4ea0:	00690b50 	rsbeq	r0, r9, r0, asr fp
    4ea4:	00630bfd 	strdeq	r0, [r3], #-189	@ 0xffffff43	@ <UNPREDICTABLE>
    4ea8:	1b3c0000 	blne	f04eb0 <__ROM_SIZE__+0xec4eb0>
    4eac:	1b340000 	blne	d04eb4 <__ROM_SIZE__+0xcc4eb4>
    4eb0:	6a0b0000 	bvs	2c4eb8 <__ROM_SIZE__+0x284eb8>
    4eb4:	630efd00 	movwvs	pc, #60672	@ 0xed00	@ <UNPREDICTABLE>
    4eb8:	60000000 	andvs	r0, r0, r0
    4ebc:	5a00001b 	bpl	4f30 <base_order+0x16b0>
    4ec0:	0000001b 	andeq	r0, r0, fp, lsl r0
    4ec4:	000c9316 	andeq	r9, ip, r6, lsl r3
    4ec8:	1d40ed00 	stclne	13, cr14, [r0, #-0]
    4ecc:	00380000 	eorseq	r0, r8, r0
    4ed0:	9c010000 	stcls	0, cr0, [r1], {-0}
    4ed4:	00000a62 	andeq	r0, r0, r2, ror #20
    4ed8:	000cf80f 	andeq	pc, ip, pc, lsl #16
    4edc:	6321ed00 			@ <UNDEFINED> instruction: 0x6321ed00
    4ee0:	01000000 	mrseq	r0, (UNDEF: 0)
    4ee4:	0b2e0f50 	bleq	b88c2c <__ROM_SIZE__+0xb48c2c>
    4ee8:	31ed0000 	mvncc	r0, r0
    4eec:	000005a0 	andeq	r0, r0, r0, lsr #11
    4ef0:	960f5101 	strls	r5, [pc], -r1, lsl #2
    4ef4:	ed00000c 	stc	0, cr0, [r0, #-48]	@ 0xffffffd0
    4ef8:	00042247 	andeq	r2, r4, r7, asr #4
    4efc:	0b520100 	bleq	1485304 <__ROM_SIZE__+0x1445304>
    4f00:	0bef0069 	bleq	ffbc50ac <_STACK_TOP_+0xdfbbd0b0>
    4f04:	00000063 	andeq	r0, r0, r3, rrx
    4f08:	00001b7c 	andeq	r1, r0, ip, ror fp
    4f0c:	00001b76 	andeq	r1, r0, r6, ror fp
    4f10:	ef006a0b 	svc	0x00006a0b
    4f14:	0000630d 	andeq	r6, r0, sp, lsl #6
    4f18:	001b9700 	andseq	r9, fp, r0, lsl #14
    4f1c:	001b9300 	andseq	r9, fp, r0, lsl #6
    4f20:	03170000 	tsteq	r7, #0
    4f24:	e500000d 	str	r0, [r0, #-13]
    4f28:	00002102 	andeq	r2, r0, r2, lsl #2
    4f2c:	0000000c 	andeq	r0, r0, ip
    4f30:	0abc9c01 	beq	fef2bf3c <_STACK_TOP_+0xdef23f40>
    4f34:	63090000 	movwvs	r0, #36864	@ 0x9000
    4f38:	e5007874 	str	r7, [r0, #-2164]	@ 0xfffff78c
    4f3c:	00023f25 	andeq	r3, r2, r5, lsr #30
    4f40:	001bac00 	andseq	sl, fp, r0, lsl #24
    4f44:	001ba600 	andseq	sl, fp, r0, lsl #12
    4f48:	76690900 	strbtvc	r0, [r9], -r0, lsl #18
    4f4c:	2239e500 	eorscs	lr, r9, #0, 10
    4f50:	cc000004 	stcgt	0, cr0, [r0], {4}
    4f54:	c800001b 	stmdagt	r0, {r0, r1, r3, r4}
    4f58:	0400001b 	streq	r0, [r0], #-27	@ 0xffffffe5
    4f5c:	0000210c 	andeq	r2, r0, ip, lsl #2
    4f60:	0000015c 	andeq	r0, r0, ip, asr r1
    4f64:	06500101 	ldrbeq	r0, [r0], -r1, lsl #2
    4f68:	235001a3 	cmpcs	r0, #-1073741784	@ 0xc0000028
    4f6c:	010101f0 	strdeq	r0, [r1, -r0]
    4f70:	01a30351 			@ <UNDEFINED> instruction: 0x01a30351
    4f74:	52010151 	andpl	r0, r1, #1073741844	@ 0x40000014
    4f78:	00004001 	andeq	r4, r0, r1
    4f7c:	000c2017 	andeq	r2, ip, r7, lsl r0
    4f80:	20eae000 	rsccs	lr, sl, r0
    4f84:	00180000 	andseq	r0, r8, r0
    4f88:	9c010000 	stcls	0, cr0, [r1], {-0}
    4f8c:	00000b40 	andeq	r0, r0, r0, asr #22
    4f90:	78746309 	ldmdavc	r4!, {r0, r3, r8, r9, sp, lr}^
    4f94:	3f26e000 	svccc	0x0026e000
    4f98:	e2000002 	and	r0, r0, #2
    4f9c:	de00001b 	mcrle	0, 0, r0, cr0, cr11, {0}
    4fa0:	0900001b 	stmdbeq	r0, {r0, r1, r3, r4}
    4fa4:	0079656b 	rsbseq	r6, r9, fp, ror #10
    4fa8:	04223ae0 	strteq	r3, [r2], #-2784	@ 0xfffff520
    4fac:	1bf50000 	blne	ffd44fb4 <_STACK_TOP_+0xdfd3cfb8>
    4fb0:	1bf10000 	blne	ffc44fb8 <_STACK_TOP_+0xdfc3cfbc>
    4fb4:	69090000 	stmdbvs	r9, {}	@ <UNPREDICTABLE>
    4fb8:	4ee00076 	mcrmi	0, 7, r0, cr0, cr6, {3}
    4fbc:	00000422 	andeq	r0, r0, r2, lsr #8
    4fc0:	00001c0b 	andeq	r1, r0, fp, lsl #24
    4fc4:	00001c07 	andeq	r1, r0, r7, lsl #24
    4fc8:	0020f402 	eoreq	pc, r0, r2, lsl #8
    4fcc:	000b9300 	andeq	r9, fp, r0, lsl #6
    4fd0:	000b2300 	andeq	r2, fp, r0, lsl #6
    4fd4:	50010100 	andpl	r0, r1, r0, lsl #2
    4fd8:	01007402 	tsteq	r0, r2, lsl #8
    4fdc:	a3035101 	movwge	r5, #12545	@ 0x3101
    4fe0:	04005101 	streq	r5, [r0], #-257	@ 0xfffffeff
    4fe4:	00002100 	andeq	r2, r0, r0, lsl #2
    4fe8:	0000015c 	andeq	r0, r0, ip, asr r1
    4fec:	03500101 	cmpeq	r0, #1073741824	@ 0x40000000
    4ff0:	0101f074 	tsteq	r1, r4, ror r0	@ <UNPREDICTABLE>
    4ff4:	75025101 	strvc	r5, [r2, #-257]	@ 0xfffffeff
    4ff8:	52010100 	andpl	r0, r1, #0, 2
    4ffc:	00004001 	andeq	r4, r0, r1
    5000:	0001a817 	andeq	sl, r1, r7, lsl r8
    5004:	20e2db00 	rsccs	sp, r2, r0, lsl #22
    5008:	00080000 	andeq	r0, r8, r0
    500c:	9c010000 	stcls	0, cr0, [r1], {-0}
    5010:	00000b93 	muleq	r0, r3, fp
    5014:	78746309 	ldmdavc	r4!, {r0, r3, r8, r9, sp, lr}^
    5018:	3f23db00 	svccc	0x0023db00
    501c:	1e000002 	cdpne	0, 0, cr0, cr0, cr2, {0}
    5020:	1a00001c 	bne	5098 <base_order+0x1818>
    5024:	0900001c 	stmdbeq	r0, {r2, r3, r4}
    5028:	0079656b 	rsbseq	r6, r9, fp, ror #10
    502c:	042237db 	strteq	r3, [r2], #-2011	@ 0xfffff825
    5030:	1c340000 	ldcne	0, cr0, [r4], #-0
    5034:	1c300000 	ldcne	0, cr0, [r0], #-0
    5038:	e8040000 	stmda	r4, {}	@ <UNPREDICTABLE>
    503c:	93000020 	movwls	r0, #32
    5040:	0100000b 	tsteq	r0, fp
    5044:	a3035001 	movwge	r5, #12289	@ 0x3001
    5048:	01015001 	tsteq	r1, r1
    504c:	01a30351 			@ <UNDEFINED> instruction: 0x01a30351
    5050:	16000051 			@ <UNDEFINED> instruction: 0x16000051
    5054:	00000d25 	andeq	r0, r0, r5, lsr #26
    5058:	001c2092 	mulseq	ip, r2, r0
    505c:	00012000 	andeq	r2, r1, r0
    5060:	279c0100 	ldrcs	r0, [ip, r0, lsl #2]
    5064:	0f00000c 	svceq	0x0000000c
    5068:	00000c96 	muleq	r0, r6, ip
    506c:	02442392 	subeq	r2, r4, #1207959554	@ 0x48000002
    5070:	50010000 	andpl	r0, r1, r0
    5074:	79654b09 	stmdbvc	r5!, {r0, r3, r8, r9, fp, lr}^
    5078:	223c9200 	eorscs	r9, ip, #0, 4
    507c:	4a000004 	bmi	5094 <base_order+0x1814>
    5080:	4600001c 			@ <UNDEFINED> instruction: 0x4600001c
    5084:	0b00001c 	bleq	50fc <base_order+0x187c>
    5088:	0c940069 	ldceq	0, cr0, [r4], {105}	@ 0x69
    508c:	00000039 	andeq	r0, r0, r9, lsr r0
    5090:	00001c5f 	andeq	r1, r0, pc, asr ip
    5094:	00001c59 	andeq	r1, r0, r9, asr ip
    5098:	94006a0b 	strls	r6, [r0], #-2571	@ 0xfffff5f5
    509c:	0000390f 	andeq	r3, r0, pc, lsl #18
    50a0:	001c7500 	andseq	r7, ip, r0, lsl #10
    50a4:	001c7100 	andseq	r7, ip, r0, lsl #2
    50a8:	006b0b00 	rsbeq	r0, fp, r0, lsl #22
    50ac:	00391294 	mlaseq	r9, r4, r2, r1
    50b0:	1c8c0000 	stcne	0, cr0, [ip], {0}
    50b4:	1c820000 	stcne	0, cr0, [r2], {0}
    50b8:	30110000 	andscc	r0, r1, r0
    50bc:	9500000c 	strls	r0, [r0, #-12]
    50c0:	000c270b 	andeq	r2, ip, fp, lsl #14
    50c4:	6c910200 	lfmvs	f0, 4, [r1], {0}
    50c8:	001ccc23 	andseq	ip, ip, r3, lsr #24
    50cc:	00001000 	andeq	r1, r0, r0
    50d0:	0c6e2400 	cfstrdeq	mvd2, [lr], #-0
    50d4:	b3010000 	movwlt	r0, #4096	@ 0x1000
    50d8:	00006f17 	andeq	r6, r0, r7, lsl pc
    50dc:	001cc400 	andseq	ip, ip, r0, lsl #8
    50e0:	001cbe00 	andseq	fp, ip, r0, lsl #28
    50e4:	25000000 	strcs	r0, [r0, #-0]
    50e8:	00000063 	andeq	r0, r0, r3, rrx
    50ec:	0000390a 	andeq	r3, r0, sl, lsl #18
    50f0:	00000300 	andeq	r0, r0, r0, lsl #6
    50f4:	00001241 	andeq	r1, r0, r1, asr #4
    50f8:	04010005 	streq	r0, [r1], #-5
    50fc:	00001af1 	strdeq	r1, [r0], -r1	@ <UNPREDICTABLE>
    5100:	00004619 	andeq	r4, r0, r9, lsl r6
    5104:	0e361d00 	cdpeq	13, 3, cr1, cr6, cr0, {0}
    5108:	00140000 	andseq	r0, r4, r0
    510c:	221c0000 	andscs	r0, ip, #0
    5110:	05800000 	streq	r0, [r0]
    5114:	3c480000 	marcc	acc0, r0, r8
    5118:	01080000 	mrseq	r0, (UNDEF: 8)
    511c:	00012d06 	andeq	r2, r1, r6, lsl #26
    5120:	05020800 	streq	r0, [r2, #-2048]	@ 0xfffff800
    5124:	000001e3 	andeq	r0, r0, r3, ror #3
    5128:	c7050408 	strgt	r0, [r5, -r8, lsl #8]
    512c:	08000001 	stmdaeq	r0, {r0}
    5130:	01c20508 	biceq	r0, r2, r8, lsl #10
    5134:	880f0000 	stmdahi	pc, {}	@ <UNPREDICTABLE>
    5138:	02000001 	andeq	r0, r0, #1
    513c:	0053182e 	subseq	r1, r3, lr, lsr #16
    5140:	42140000 	andsmi	r0, r4, #0
    5144:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
    5148:	012b0801 			@ <UNDEFINED> instruction: 0x012b0801
    514c:	02080000 	andeq	r0, r8, #0
    5150:	00013907 	andeq	r3, r1, r7, lsl #18
    5154:	026a0f00 	rsbeq	r0, sl, #0, 30
    5158:	34020000 	strcc	r0, [r2], #-0
    515c:	00007219 	andeq	r7, r0, r9, lsl r2
    5160:	00611400 	rsbeq	r1, r1, r0, lsl #8
    5164:	04080000 	streq	r0, [r8], #-0
    5168:	00017607 	andeq	r7, r1, r7, lsl #12
    516c:	07080800 	streq	r0, [r8, -r0, lsl #16]
    5170:	00000171 	andeq	r0, r0, r1, ror r1
    5174:	6905041a 	stmdbvs	r5, {r1, r3, r4, sl}
    5178:	0800746e 	stmdaeq	r0, {r1, r2, r3, r5, r6, sl, ip, sp, lr}
    517c:	017b0704 	cmneq	fp, r4, lsl #14
    5180:	b30f0000 	movwlt	r0, #61440	@ 0xf000
    5184:	0100000e 	tsteq	r0, lr
    5188:	009f1245 	addseq	r1, pc, r5, asr #4
    518c:	8e140000 	cdphi	0, 1, cr0, cr4, cr0, {0}
    5190:	1b000000 	blne	5198 <base_order+0x1918>
    5194:	00000061 	andeq	r0, r0, r1, rrx
    5198:	000000af 	andeq	r0, r0, pc, lsr #1
    519c:	0000871c 	andeq	r8, r0, ip, lsl r7
    51a0:	0f000500 	svceq	0x00000500
    51a4:	00000d76 	andeq	r0, r0, r6, ror sp
    51a8:	8e124601 	cfmsub32hi	mvax0, mvfx4, mvfx2, mvfx1
    51ac:	0c000000 	stceq	0, cr0, [r0], {-0}
    51b0:	00000d64 	andeq	r0, r0, r4, ror #26
    51b4:	00009a5e 	andeq	r9, r0, lr, asr sl
    51b8:	20030500 	andcs	r0, r3, r0, lsl #10
    51bc:	0c000038 	stceq	0, cr0, [r0], {56}	@ 0x38
    51c0:	00000f13 	andeq	r0, r0, r3, lsl pc
    51c4:	00009a5f 	andeq	r9, r0, pc, asr sl
    51c8:	38030500 	stmdacc	r3, {r8, sl}
    51cc:	0c000038 	stceq	0, cr0, [r0], {56}	@ 0x38
    51d0:	00000ee6 	andeq	r0, r0, r6, ror #29
    51d4:	00009a60 	andeq	r9, r0, r0, ror #20
    51d8:	68030500 	stmdavs	r3, {r8, sl}
    51dc:	0c000038 	stceq	0, cr0, [r0], {56}	@ 0x38
    51e0:	00000eed 	andeq	r0, r0, sp, ror #29
    51e4:	00009a61 	andeq	r9, r0, r1, ror #20
    51e8:	50030500 	andpl	r0, r3, r0, lsl #10
    51ec:	0c000038 	stceq	0, cr0, [r0], {56}	@ 0x38
    51f0:	00000daa 	andeq	r0, r0, sl, lsr #27
    51f4:	00009a62 	andeq	r9, r0, r2, ror #20
    51f8:	80030500 	andhi	r0, r3, r0, lsl #10
    51fc:	16000038 			@ <UNDEFINED> instruction: 0x16000038
    5200:	00000231 	andeq	r0, r0, r1, lsr r2
    5204:	008002ea 	addeq	r0, r0, sl, ror #5
    5208:	27540000 	ldrbcs	r0, [r4, -r0]
    520c:	00480000 	subeq	r0, r8, r0
    5210:	9c010000 	stcls	0, cr0, [r1], {-0}
    5214:	000001cd 	andeq	r0, r0, sp, asr #3
    5218:	000e6d09 	andeq	r6, lr, r9, lsl #26
    521c:	2702ea00 	strcs	lr, [r2, -r0, lsl #20]
    5220:	000001cd 	andeq	r0, r0, sp, asr #3
    5224:	00001cf1 	strdeq	r1, [r0], -r1	@ <UNPREDICTABLE>
    5228:	00001ced 	andeq	r1, r0, sp, ror #25
    522c:	000e1209 	andeq	r1, lr, r9, lsl #4
    5230:	4302ea00 	movwmi	lr, #10752	@ 0x2a00
    5234:	000001cd 	andeq	r0, r0, sp, asr #3
    5238:	00001d04 	andeq	r1, r0, r4, lsl #26
    523c:	00001d00 	andeq	r1, r0, r0, lsl #26
    5240:	00095909 	andeq	r5, r9, r9, lsl #18
    5244:	5802ea00 	stmdapl	r2, {r9, fp, sp, lr, pc}
    5248:	000001d2 	ldrdeq	r0, [r0], -r2
    524c:	00001d17 	andeq	r1, r0, r7, lsl sp
    5250:	00001d13 	andeq	r1, r0, r3, lsl sp
    5254:	00277a10 	eoreq	r7, r7, r0, lsl sl
    5258:	00002200 	andeq	r2, r0, r0, lsl #4
    525c:	00019c00 	andeq	r9, r1, r0, lsl #24
    5260:	00690500 	rsbeq	r0, r9, r0, lsl #10
    5264:	871202f1 			@ <UNDEFINED> instruction: 0x871202f1
    5268:	28000000 	stmdacs	r0, {}	@ <UNPREDICTABLE>
    526c:	2600001d 			@ <UNDEFINED> instruction: 0x2600001d
    5270:	0400001d 	streq	r0, [r0], #-29	@ 0xffffffe3
    5274:	00002798 	muleq	r0, r8, r7
    5278:	00000446 	andeq	r0, r0, r6, asr #8
    527c:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    5280:	01010075 	tsteq	r1, r5, ror r0
    5284:	18750251 	ldmdane	r5!, {r0, r4, r6, r9}^
    5288:	02520101 	subseq	r0, r2, #1073741824	@ 0x40000000
    528c:	00000076 	andeq	r0, r0, r6, ror r0
    5290:	00276802 	eoreq	r6, r7, r2, lsl #16
    5294:	0009fa00 	andeq	pc, r9, r0, lsl #20
    5298:	0001b600 	andeq	fp, r1, r0, lsl #12
    529c:	50010100 	andpl	r0, r1, r0, lsl #2
    52a0:	01007402 	tsteq	r0, r2, lsl #8
    52a4:	77025101 	strvc	r5, [r2, -r1, lsl #2]
    52a8:	76040000 	strvc	r0, [r4], -r0
    52ac:	d6000027 	strle	r0, [r0], -r7, lsr #32
    52b0:	01000002 	tsteq	r0, r2
    52b4:	74025001 	strvc	r5, [r2], #-1
    52b8:	51010100 	mrspl	r0, (UNDEF: 17)
    52bc:	00007702 	andeq	r7, r0, r2, lsl #14
    52c0:	004e1100 	subeq	r1, lr, r0, lsl #2
    52c4:	42110000 	andsmi	r0, r1, #0
    52c8:	16000000 	strne	r0, [r0], -r0
    52cc:	0000048a 	andeq	r0, r0, sl, lsl #9
    52d0:	008002cc 	addeq	r0, r0, ip, asr #5
    52d4:	27000000 	strcs	r0, [r0, -r0]
    52d8:	00540000 	subseq	r0, r4, r0
    52dc:	9c010000 	stcls	0, cr0, [r1], {-0}
    52e0:	000002d6 	ldrdeq	r0, [r0], -r6
    52e4:	000e2b09 	andeq	r2, lr, r9, lsl #22
    52e8:	2102cc00 	tstcs	r2, r0, lsl #24
    52ec:	000001d2 	ldrdeq	r0, [r0], -r2
    52f0:	00001d34 	andeq	r1, r0, r4, lsr sp
    52f4:	00001d30 	andeq	r1, r0, r0, lsr sp
    52f8:	000e6d09 	andeq	r6, lr, r9, lsl #26
    52fc:	3602cc00 	strcc	ip, [r2], -r0, lsl #24
    5300:	000001d2 	ldrdeq	r0, [r0], -r2
    5304:	00001d47 	andeq	r1, r0, r7, asr #26
    5308:	00001d43 	andeq	r1, r0, r3, asr #26
    530c:	00272210 	eoreq	r2, r7, r0, lsl r2
    5310:	00002400 	andeq	r2, r0, r0, lsl #8
    5314:	00029900 	andeq	r9, r2, r0, lsl #18
    5318:	0def1200 	sfmeq	f1, 2, [pc]	@ 5320 <base_order+0x1aa0>
    531c:	02d90000 	sbcseq	r0, r9, #0
    5320:	00008009 	andeq	r8, r0, r9
    5324:	001d5800 	andseq	r5, sp, r0, lsl #16
    5328:	001d5600 	andseq	r5, sp, r0, lsl #12
    532c:	00690500 	rsbeq	r0, r9, r0, lsl #10
    5330:	800902da 	ldrdhi	r0, [r9], -sl
    5334:	62000000 	andvs	r0, r0, #0
    5338:	6000001d 	andvs	r0, r0, sp, lsl r0
    533c:	0200001d 	andeq	r0, r0, #29
    5340:	00002728 	andeq	r2, r0, r8, lsr #14
    5344:	00000ffe 	strdeq	r0, [r0], -lr
    5348:	00000262 	andeq	r0, r0, r2, ror #4
    534c:	05500101 	ldrbeq	r0, [r0, #-257]	@ 0xfffffeff
    5350:	00388003 	eorseq	r8, r8, r3
    5354:	34020000 	strcc	r0, [r2], #-0
    5358:	d6000027 	strle	r0, [r0], -r7, lsr #32
    535c:	7c000011 	stcvc	0, cr0, [r0], {17}
    5360:	01000002 	tsteq	r0, r2
    5364:	75025001 	strvc	r5, [r2, #-1]
    5368:	51010100 	mrspl	r0, (UNDEF: 17)
    536c:	00007402 	andeq	r7, r0, r2, lsl #8
    5370:	00274404 	eoreq	r4, r7, r4, lsl #8
    5374:	00044600 	andeq	r4, r4, r0, lsl #12
    5378:	50010100 	andpl	r0, r1, r0, lsl #2
    537c:	01007602 	tsteq	r0, r2, lsl #12
    5380:	77025101 	strvc	r5, [r2, -r1, lsl #2]
    5384:	52010100 	andpl	r0, r1, #0, 2
    5388:	00007502 	andeq	r7, r0, r2, lsl #10
    538c:	27180200 	ldrcs	r0, [r8, -r0, lsl #4]
    5390:	0abc0000 	beq	fef05398 <_STACK_TOP_+0xdeefd39c>
    5394:	02c50000 	sbceq	r0, r5, #0
    5398:	01010000 	mrseq	r0, (UNDEF: 1)
    539c:	00760250 	rsbseq	r0, r6, r0, asr r2
    53a0:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    53a4:	01010077 	tsteq	r1, r7, ror r0
    53a8:	68030552 	stmdavs	r3, {r1, r4, r6, r8, sl}
    53ac:	01000038 	tsteq	r0, r8, lsr r0
    53b0:	03055301 	movweq	r5, #21249	@ 0x5301
    53b4:	00003850 	andeq	r3, r0, r0, asr r8
    53b8:	271e0400 	ldrcs	r0, [lr, -r0, lsl #8]
    53bc:	0ffe0000 	svceq	0x00fe0000
    53c0:	01010000 	mrseq	r0, (UNDEF: 1)
    53c4:	00750250 	rsbseq	r0, r5, r0, asr r2
    53c8:	dd0d0000 	stcle	0, cr0, [sp, #-0]
    53cc:	a800000d 	stmdage	r0, {r0, r2, r3}
    53d0:	00008002 	andeq	r8, r0, r2
    53d4:	00269800 	eoreq	r9, r6, r0, lsl #16
    53d8:	00006800 	andeq	r6, r0, r0, lsl #16
    53dc:	419c0100 	orrsmi	r0, ip, r0, lsl #2
    53e0:	03000004 	movweq	r0, #4
    53e4:	02a80078 	adceq	r0, r8, #120	@ 0x78
    53e8:	0004412e 	andeq	r4, r4, lr, lsr #2
    53ec:	001d6e00 	andseq	r6, sp, r0, lsl #28
    53f0:	001d6a00 	andseq	r6, sp, r0, lsl #20
    53f4:	00790300 	rsbseq	r0, r9, r0, lsl #6
    53f8:	414102a8 	smlaltbmi	r0, r1, r8, r2
    53fc:	81000004 	tsthi	r0, r4
    5400:	7d00001d 	stcvc	0, cr0, [r0, #-116]	@ 0xffffff8c
    5404:	0600001d 			@ <UNDEFINED> instruction: 0x0600001d
    5408:	02aa0061 	adceq	r0, sl, #97	@ 0x61
    540c:	0000af0d 	andeq	sl, r0, sp, lsl #30
    5410:	58910200 	ldmpl	r1, {r9}
    5414:	aa006206 	bge	1dc34 <__RAM_SIZE__+0x15c34>
    5418:	00af1002 	adceq	r1, pc, r2
    541c:	91020000 	mrsls	r0, (UNDEF: 2)
    5420:	26a40240 	strtcs	r0, [r4], r0, asr #4
    5424:	09fa0000 	ldmibeq	sl!, {}^	@ <UNPREDICTABLE>
    5428:	03470000 	movteq	r0, #28672	@ 0x7000
    542c:	01010000 	mrseq	r0, (UNDEF: 1)
    5430:	00740250 	rsbseq	r0, r4, r0, asr r2
    5434:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    5438:	02000075 	andeq	r0, r0, #117	@ 0x75
    543c:	000026b6 			@ <UNDEFINED> instruction: 0x000026b6
    5440:	00000d26 	andeq	r0, r0, r6, lsr #26
    5444:	00000367 	andeq	r0, r0, r7, ror #6
    5448:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    544c:	01015891 			@ <UNDEFINED> instruction: 0x01015891
    5450:	00740251 	rsbseq	r0, r4, r1, asr r2
    5454:	02520101 	subseq	r0, r2, #1073741824	@ 0x40000000
    5458:	02000074 	andeq	r0, r0, #116	@ 0x74
    545c:	000026c0 	andeq	r2, r0, r0, asr #13
    5460:	00000d26 	andeq	r0, r0, r6, lsr #26
    5464:	00000387 	andeq	r0, r0, r7, lsl #7
    5468:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    546c:	0101007d 	tsteq	r1, sp, ror r0
    5470:	58910251 	ldmpl	r1, {r0, r4, r6, r9}
    5474:	02520101 	subseq	r0, r2, #1073741824	@ 0x40000000
    5478:	02000074 	andeq	r0, r0, #116	@ 0x74
    547c:	000026ca 	andeq	r2, r0, sl, asr #13
    5480:	00000ea8 	andeq	r0, r0, r8, lsr #29
    5484:	000003a7 	andeq	r0, r0, r7, lsr #7
    5488:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    548c:	01015891 			@ <UNDEFINED> instruction: 0x01015891
    5490:	58910251 	ldmpl	r1, {r0, r4, r6, r9}
    5494:	02520101 	subseq	r0, r2, #1073741824	@ 0x40000000
    5498:	0200007d 	andeq	r0, r0, #125	@ 0x7d
    549c:	000026d4 	ldrdeq	r2, [r0], -r4
    54a0:	00000ea8 	andeq	r0, r0, r8, lsr #29
    54a4:	000003ca 	andeq	r0, r0, sl, asr #7
    54a8:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    54ac:	01015891 			@ <UNDEFINED> instruction: 0x01015891
    54b0:	58910251 	ldmpl	r1, {r0, r4, r6, r9}
    54b4:	05520101 	ldrbeq	r0, [r2, #-257]	@ 0xfffffeff
    54b8:	00383803 	eorseq	r3, r8, r3, lsl #16
    54bc:	de020000 	cdple	0, 0, cr0, cr2, cr0, {0}
    54c0:	26000026 	strcs	r0, [r0], -r6, lsr #32
    54c4:	ea00000d 	b	5500 <base_order+0x1c80>
    54c8:	01000003 	tsteq	r0, r3
    54cc:	7d025001 	stcvc	0, cr5, [r2, #-4]
    54d0:	51010100 	mrspl	r0, (UNDEF: 17)
    54d4:	01007502 	tsteq	r0, r2, lsl #10
    54d8:	75025201 	strvc	r5, [r2, #-513]	@ 0xfffffdff
    54dc:	e8020000 	stmda	r2, {}	@ <UNPREDICTABLE>
    54e0:	a8000026 	stmdage	r0, {r1, r2, r5}
    54e4:	0a00000e 	beq	5524 <base_order+0x1ca4>
    54e8:	01000004 	tsteq	r0, r4
    54ec:	91025001 	tstls	r2, r1
    54f0:	51010158 	tstpl	r1, r8, asr r1
    54f4:	01589102 	cmpeq	r8, r2, lsl #2
    54f8:	7d025201 	sfmvc	f5, 4, [r2, #-4]
    54fc:	f2020000 	vhadd.s8	d0, d2, d0
    5500:	26000026 	strcs	r0, [r0], -r6, lsr #32
    5504:	2a00000d 	bcs	5540 <base_order+0x1cc0>
    5508:	01000004 	tsteq	r0, r4
    550c:	7d025001 	stcvc	0, cr5, [r2, #-4]
    5510:	51010100 	mrspl	r0, (UNDEF: 17)
    5514:	01007402 	tsteq	r0, r2, lsl #8
    5518:	75025201 	strvc	r5, [r2, #-513]	@ 0xfffffdff
    551c:	fa040000 	blx	105524 <__ROM_SIZE__+0xc5524>
    5520:	c4000026 	strgt	r0, [r0], #-38	@ 0xffffffda
    5524:	01000010 	tsteq	r0, r0, lsl r0
    5528:	91025001 	tstls	r2, r1
    552c:	51010158 	tstpl	r1, r8, asr r1
    5530:	00007d02 	andeq	r7, r0, r2, lsl #26
    5534:	006d1100 	rsbeq	r1, sp, r0, lsl #2
    5538:	1b070000 	blne	1c5540 <__ROM_SIZE__+0x185540>
    553c:	7400000f 	strvc	r0, [r0], #-15
    5540:	00264202 	eoreq	r4, r6, r2, lsl #4
    5544:	00005600 	andeq	r5, r0, r0, lsl #12
    5548:	7f9c0100 	svcvc	0x009c0100
    554c:	03000005 	movweq	r0, #5
    5550:	02740078 	rsbseq	r0, r4, #120	@ 0x78
    5554:	00057f24 	andeq	r7, r5, r4, lsr #30
    5558:	001d9400 	andseq	r9, sp, r0, lsl #8
    555c:	001d9000 	andseq	r9, sp, r0
    5560:	00790300 	rsbseq	r0, r9, r0, lsl #6
    5564:	7f310274 	svcvc	0x00310274
    5568:	a7000005 	strge	r0, [r0, -r5]
    556c:	a300001d 	movwge	r0, #29
    5570:	0300001d 	movweq	r0, #29
    5574:	00707865 	rsbseq	r7, r0, r5, ror #16
    5578:	41430274 	hvcmi	12324	@ 0x3024
    557c:	ba000004 	blt	5594 <base_order+0x1d14>
    5580:	b600001d 			@ <UNDEFINED> instruction: 0xb600001d
    5584:	1700001d 	smladne	r0, sp, r0, r0
    5588:	00000d48 	andeq	r0, r0, r8, asr #26
    558c:	0000af0d 	andeq	sl, r0, sp, lsl #30
    5590:	50910200 	addspl	r0, r1, r0, lsl #4
    5594:	000d4d17 	andeq	r4, sp, r7, lsl sp
    5598:	00af1300 	adceq	r1, pc, r0, lsl #6
    559c:	91030000 	mrsls	r0, (UNDEF: 3)
    55a0:	69057fb8 	stmdbvs	r5, {r3, r4, r5, r7, r8, r9, sl, fp, ip, sp, lr}
    55a4:	07027700 	streq	r7, [r2, -r0, lsl #14]
    55a8:	00000080 	andeq	r0, r0, r0, lsl #1
    55ac:	00001dcb 	andeq	r1, r0, fp, asr #27
    55b0:	00001dc9 	andeq	r1, r0, r9, asr #27
    55b4:	000def12 	andeq	lr, sp, r2, lsl pc
    55b8:	07027800 	streq	r7, [r2, -r0, lsl #16]
    55bc:	00000080 	andeq	r0, r0, r0, lsl #1
    55c0:	00001dd9 	ldrdeq	r1, [r0], -r9
    55c4:	00001dd3 	ldrdeq	r1, [r0], -r3
    55c8:	00265202 	eoreq	r5, r6, r2, lsl #4
    55cc:	000ffe00 	andeq	pc, pc, r0, lsl #28
    55d0:	0004e800 	andeq	lr, r4, r0, lsl #16
    55d4:	50010100 	andpl	r0, r1, r0, lsl #2
    55d8:	00007502 	andeq	r7, r0, r2, lsl #10
    55dc:	00265c02 	eoreq	r5, r6, r2, lsl #24
    55e0:	000a5d00 	andeq	r5, sl, r0, lsl #26
    55e4:	00050200 	andeq	r0, r5, r0, lsl #4
    55e8:	50010100 	andpl	r0, r1, r0, lsl #2
    55ec:	01509102 	cmpeq	r0, r2, lsl #2
    55f0:	7d025101 	stfvcs	f5, [r2, #-4]
    55f4:	6e020000 	cdpvs	0, 0, cr0, cr2, cr0, {0}
    55f8:	77000026 	strvc	r0, [r0, -r6, lsr #32]
    55fc:	1c000008 	stcne	0, cr0, [r0], {8}
    5600:	01000005 	tsteq	r0, r5
    5604:	91025001 	tstls	r2, r1
    5608:	51010150 	tstpl	r1, r0, asr r1
    560c:	00007d02 	andeq	r7, r0, r2, lsl #26
    5610:	00267602 	eoreq	r7, r6, r2, lsl #12
    5614:	00120900 	andseq	r0, r2, r0, lsl #18
    5618:	00053600 	andeq	r3, r5, r0, lsl #12
    561c:	50010100 	andpl	r0, r1, r0, lsl #2
    5620:	01007502 	tsteq	r0, r2, lsl #10
    5624:	74025101 	strvc	r5, [r2], #-257	@ 0xfffffeff
    5628:	86020000 	strhi	r0, [r2], -r0
    562c:	84000026 	strhi	r0, [r0], #-38	@ 0xffffffda
    5630:	5c000005 	stcpl	0, cr0, [r0], {5}
    5634:	01000005 	tsteq	r0, r5
    5638:	91025001 	tstls	r2, r1
    563c:	51010150 	tstpl	r1, r0, asr r1
    5640:	01007d02 	tsteq	r0, r2, lsl #26
    5644:	76025201 	strvc	r5, [r2], -r1, lsl #4
    5648:	53010100 	movwpl	r0, #4352	@ 0x1100
    564c:	00007702 	andeq	r7, r0, r2, lsl #14
    5650:	00269404 	eoreq	r9, r6, r4, lsl #8
    5654:	000abc00 	andeq	fp, sl, r0, lsl #24
    5658:	50010100 	andpl	r0, r1, r0, lsl #2
    565c:	01007602 	tsteq	r0, r2, lsl #12
    5660:	77025101 	strvc	r5, [r2, -r1, lsl #2]
    5664:	52010100 	andpl	r0, r1, #0, 2
    5668:	01509102 	cmpeq	r0, r2, lsl #2
    566c:	7d025301 	stcvc	3, cr5, [r2, #-4]
    5670:	11000000 	mrsne	r0, (UNDEF: 0)
    5674:	00000061 	andeq	r0, r0, r1, rrx
    5678:	000ed907 	andeq	sp, lr, r7, lsl #18
    567c:	6e024200 	cdpvs	2, 0, cr4, cr2, cr0, {0}
    5680:	d4000025 	strle	r0, [r0], #-37	@ 0xffffffdb
    5684:	01000000 	mrseq	r0, (UNDEF: 0)
    5688:	0008779c 	muleq	r8, ip, r7
    568c:	31780300 	cmncc	r8, r0, lsl #6
    5690:	24024200 	strcs	r4, [r2], #-512	@ 0xfffffe00
    5694:	0000057f 	andeq	r0, r0, pc, ror r5
    5698:	00001df5 	strdeq	r1, [r0], -r5
    569c:	00001df1 	strdeq	r1, [r0], -r1	@ <UNPREDICTABLE>
    56a0:	00317903 	eorseq	r7, r1, r3, lsl #18
    56a4:	7f320242 	svcvc	0x00320242
    56a8:	08000005 	stmdaeq	r0, {r0, r2}
    56ac:	0400001e 	streq	r0, [r0], #-30	@ 0xffffffe2
    56b0:	0300001e 	movweq	r0, #30
    56b4:	42003278 	andmi	r3, r0, #120, 4	@ 0x80000007
    56b8:	04414602 	strbeq	r4, [r1], #-1538	@ 0xfffff9fe
    56bc:	1e1b0000 	cdpne	0, 1, cr0, cr11, cr0, {0}
    56c0:	1e170000 	cdpne	0, 1, cr0, cr7, cr0, {0}
    56c4:	79030000 	stmdbvc	r3, {}	@ <UNPREDICTABLE>
    56c8:	02420032 	subeq	r0, r2, #50	@ 0x32
    56cc:	0004415a 	andeq	r4, r4, sl, asr r1
    56d0:	001e2e00 	andseq	r2, lr, r0, lsl #28
    56d4:	001e2a00 	andseq	r2, lr, r0, lsl #20
    56d8:	25c61000 	strbcs	r1, [r6]
    56dc:	007a0000 	rsbseq	r0, sl, r0
    56e0:	07b80000 	ldreq	r0, [r8, r0]!
    56e4:	61060000 	mrsvs	r0, (UNDEF: 6)
    56e8:	13025a00 	movwne	r5, #10752	@ 0x2a00
    56ec:	000000af 	andeq	r0, r0, pc, lsr #1
    56f0:	7f889103 	svcvc	0x00889103
    56f4:	5a006206 	bpl	1df14 <__RAM_SIZE__+0x15f14>
    56f8:	00af1602 	adceq	r1, pc, r2, lsl #12
    56fc:	91030000 	mrsls	r0, (UNDEF: 3)
    5700:	63067fa0 	movwvs	r7, #28576	@ 0x6fa0
    5704:	19025a00 	stmdbne	r2, {r9, fp, ip, lr}
    5708:	000000af 	andeq	r0, r0, pc, lsr #1
    570c:	7fb89103 	svcvc	0x00b89103
    5710:	5a006406 	bpl	1e730 <__RAM_SIZE__+0x16730>
    5714:	00af1c02 	adceq	r1, pc, r2, lsl #24
    5718:	91020000 	mrsls	r0, (UNDEF: 2)
    571c:	25d00250 	ldrbcs	r0, [r0, #592]	@ 0x250
    5720:	0ea80000 	cdpeq	0, 10, cr0, cr8, cr0, {0}
    5724:	06490000 	strbeq	r0, [r9], -r0
    5728:	01010000 	mrseq	r0, (UNDEF: 1)
    572c:	007d0250 	rsbseq	r0, sp, r0, asr r2
    5730:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    5734:	01010077 	tsteq	r1, r7, ror r0
    5738:	00760252 	rsbseq	r0, r6, r2, asr r2
    573c:	25da0200 	ldrbcs	r0, [sl, #512]	@ 0x200
    5740:	0ea80000 	cdpeq	0, 10, cr0, cr8, cr0, {0}
    5744:	066a0000 	strbteq	r0, [sl], -r0
    5748:	01010000 	mrseq	r0, (UNDEF: 1)
    574c:	a0910350 	addsge	r0, r1, r0, asr r3
    5750:	5101017f 	tstpl	r1, pc, ror r1
    5754:	01007402 	tsteq	r0, r2, lsl #8
    5758:	75025201 	strvc	r5, [r2, #-513]	@ 0xfffffdff
    575c:	e2020000 	and	r0, r2, #0
    5760:	50000025 	andpl	r0, r0, r5, lsr #32
    5764:	8600000b 	strhi	r0, [r0], -fp
    5768:	01000006 	tsteq	r0, r6
    576c:	91035001 	tstls	r3, r1
    5770:	01017fb8 			@ <UNDEFINED> instruction: 0x01017fb8
    5774:	a0910351 	addsge	r0, r1, r1, asr r3
    5778:	ec02007f 	stc	0, cr0, [r2], {127}	@ 0x7f
    577c:	26000025 	strcs	r0, [r0], -r5, lsr #32
    5780:	a800000d 	stmdage	r0, {r0, r2, r3}
    5784:	01000006 	tsteq	r0, r6
    5788:	91035001 	tstls	r3, r1
    578c:	01017fb8 			@ <UNDEFINED> instruction: 0x01017fb8
    5790:	b8910351 	ldmlt	r1, {r0, r4, r6, r8, r9}
    5794:	5201017f 	andpl	r0, r1, #-1073741793	@ 0xc000001f
    5798:	00007d02 	andeq	r7, r0, r2, lsl #26
    579c:	0025f602 	eoreq	pc, r5, r2, lsl #12
    57a0:	000d2600 	andeq	r2, sp, r0, lsl #12
    57a4:	0006ca00 	andeq	ip, r6, r0, lsl #20
    57a8:	50010100 	andpl	r0, r1, r0, lsl #2
    57ac:	01509102 	cmpeq	r0, r2, lsl #2
    57b0:	91035101 	tstls	r3, r1, lsl #2
    57b4:	01017fb8 			@ <UNDEFINED> instruction: 0x01017fb8
    57b8:	b8910352 	ldmlt	r1, {r1, r4, r6, r8, r9}
    57bc:	0002007f 	andeq	r0, r2, pc, ror r0
    57c0:	a8000026 	stmdage	r0, {r1, r2, r5}
    57c4:	eb00000e 	bl	5804 <base_order+0x1f84>
    57c8:	01000006 	tsteq	r0, r6
    57cc:	91025001 	tstls	r2, r1
    57d0:	51010150 	tstpl	r1, r0, asr r1
    57d4:	01509102 	cmpeq	r0, r2, lsl #2
    57d8:	91035201 	tstls	r3, r1, lsl #4
    57dc:	02007fb8 	andeq	r7, r0, #184, 30	@ 0x2e0
    57e0:	0000260a 	andeq	r2, r0, sl, lsl #12
    57e4:	00000ea8 	andeq	r0, r0, r8, lsr #29
    57e8:	0000070c 	andeq	r0, r0, ip, lsl #14
    57ec:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    57f0:	01015091 	swpeq	r5, r1, [r1]	@ <UNPREDICTABLE>
    57f4:	50910251 	addspl	r0, r1, r1, asr r2
    57f8:	03520101 	cmpeq	r2, #1073741824	@ 0x40000000
    57fc:	007fa091 			@ <UNDEFINED> instruction: 0x007fa091
    5800:	00261002 	eoreq	r1, r6, r2
    5804:	000e8600 	andeq	r8, lr, r0, lsl #12
    5808:	00072000 	andeq	r2, r7, r0
    580c:	50010100 	andpl	r0, r1, r0, lsl #2
    5810:	00509102 	subseq	r9, r0, r2, lsl #2
    5814:	00261a02 	eoreq	r1, r6, r2, lsl #20
    5818:	000ea800 	andeq	sl, lr, r0, lsl #16
    581c:	00074000 	andeq	r4, r7, r0
    5820:	50010100 	andpl	r0, r1, r0, lsl #2
    5824:	01007402 	tsteq	r0, r2, lsl #8
    5828:	74025101 	strvc	r5, [r2], #-257	@ 0xfffffeff
    582c:	52010100 	andpl	r0, r1, #0, 2
    5830:	00509102 	subseq	r9, r0, r2, lsl #2
    5834:	00262402 	eoreq	r2, r6, r2, lsl #8
    5838:	000d2600 	andeq	r2, sp, r0, lsl #12
    583c:	00076100 	andeq	r6, r7, r0, lsl #2
    5840:	50010100 	andpl	r0, r1, r0, lsl #2
    5844:	01007d02 	tsteq	r0, r2, lsl #26
    5848:	74025101 	strvc	r5, [r2], #-257	@ 0xfffffeff
    584c:	52010100 	andpl	r0, r1, #0, 2
    5850:	7fb89103 	svcvc	0x00b89103
    5854:	262e0200 	strtcs	r0, [lr], -r0, lsl #4
    5858:	0ea80000 	cdpeq	0, 10, cr0, cr8, cr0, {0}
    585c:	07810000 	streq	r0, [r1, r0]
    5860:	01010000 	mrseq	r0, (UNDEF: 1)
    5864:	007d0250 	rsbseq	r0, sp, r0, asr r2
    5868:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    586c:	0101007d 	tsteq	r1, sp, ror r0
    5870:	50910252 	addspl	r0, r1, r2, asr r2
    5874:	26380200 	ldrtcs	r0, [r8], -r0, lsl #4
    5878:	0ea80000 	cdpeq	0, 10, cr0, cr8, cr0, {0}
    587c:	07a10000 	streq	r0, [r1, r0]!
    5880:	01010000 	mrseq	r0, (UNDEF: 1)
    5884:	00770250 	rsbseq	r0, r7, r0, asr r2
    5888:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    588c:	01010077 	tsteq	r1, r7, ror r0
    5890:	007d0252 	rsbseq	r0, sp, r2, asr r2
    5894:	26400400 	strbcs	r0, [r0], -r0, lsl #8
    5898:	119b0000 	orrsne	r0, fp, r0
    589c:	01010000 	mrseq	r0, (UNDEF: 1)
    58a0:	00740250 	rsbseq	r0, r4, r0, asr r2
    58a4:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    58a8:	00005091 	muleq	r0, r1, r0
    58ac:	00258202 	eoreq	r8, r5, r2, lsl #4
    58b0:	0009fa00 	andeq	pc, r9, r0, lsl #20
    58b4:	0007d200 	andeq	sp, r7, r0, lsl #4
    58b8:	50010100 	andpl	r0, r1, r0, lsl #2
    58bc:	01007502 	tsteq	r0, r2, lsl #10
    58c0:	76025101 	strvc	r5, [r2], -r1, lsl #2
    58c4:	8c020000 	stchi	0, cr0, [r2], {-0}
    58c8:	fa000025 	blx	5964 <base_order+0x20e4>
    58cc:	ec000009 	stc	0, cr0, [r0], {9}
    58d0:	01000007 	tsteq	r0, r7
    58d4:	74025001 	strvc	r5, [r2], #-1
    58d8:	51010100 	mrspl	r0, (UNDEF: 17)
    58dc:	00007702 	andeq	r7, r0, r2, lsl #14
    58e0:	00259602 	eoreq	r9, r5, r2, lsl #12
    58e4:	0010c400 	andseq	ip, r0, r0, lsl #8
    58e8:	00080600 	andeq	r0, r8, r0, lsl #12
    58ec:	50010100 	andpl	r0, r1, r0, lsl #2
    58f0:	01007402 	tsteq	r0, r2, lsl #8
    58f4:	75025101 	strvc	r5, [r2, #-257]	@ 0xfffffeff
    58f8:	a0020000 	andge	r0, r2, r0
    58fc:	c4000025 	strgt	r0, [r0], #-37	@ 0xffffffdb
    5900:	20000010 	andcs	r0, r0, r0, lsl r0
    5904:	01000008 	tsteq	r0, r8
    5908:	77025001 	strvc	r5, [r2, -r1]
    590c:	51010100 	mrspl	r0, (UNDEF: 17)
    5910:	00007602 	andeq	r7, r0, r2, lsl #12
    5914:	0025aa02 	eoreq	sl, r5, r2, lsl #20
    5918:	00087700 	andeq	r7, r8, r0, lsl #14
    591c:	00083a00 	andeq	r3, r8, r0, lsl #20
    5920:	50010100 	andpl	r0, r1, r0, lsl #2
    5924:	01007402 	tsteq	r0, r2, lsl #8
    5928:	77025101 	strvc	r5, [r2, -r1, lsl #2]
    592c:	b8020000 	stmdalt	r2, {}	@ <UNPREDICTABLE>
    5930:	bc000025 	stclt	0, cr0, [r0], {37}	@ 0x25
    5934:	6000000a 	andvs	r0, r0, sl
    5938:	01000008 	tsteq	r0, r8
    593c:	74025001 	strvc	r5, [r2], #-1
    5940:	51010100 	mrspl	r0, (UNDEF: 17)
    5944:	01007702 	tsteq	r0, r2, lsl #14
    5948:	75025201 	strvc	r5, [r2, #-513]	@ 0xfffffdff
    594c:	53010100 	movwpl	r0, #4352	@ 0x1100
    5950:	00007602 	andeq	r7, r0, r2, lsl #12
    5954:	0025c404 	eoreq	ip, r5, r4, lsl #8
    5958:	000a5d00 	andeq	r5, sl, r0, lsl #26
    595c:	50010100 	andpl	r0, r1, r0, lsl #2
    5960:	01007402 	tsteq	r0, r2, lsl #8
    5964:	77025101 	strvc	r5, [r2, -r1, lsl #2]
    5968:	07000000 	streq	r0, [r0, -r0]
    596c:	00000d8d 	andeq	r0, r0, sp, lsl #27
    5970:	25000227 	strcs	r0, [r0, #-551]	@ 0xfffffdd9
    5974:	006e0000 	rsbeq	r0, lr, r0
    5978:	9c010000 	stcls	0, cr0, [r1], {-0}
    597c:	000009fa 	strdeq	r0, [r0], -sl
    5980:	27007803 	strcs	r7, [r0, -r3, lsl #16]
    5984:	057f2702 	ldrbeq	r2, [pc, #-1794]!	@ 528a <base_order+0x1a0a>
    5988:	1e410000 	cdpne	0, 4, cr0, cr1, cr0, {0}
    598c:	1e3d0000 	cdpne	0, 3, cr0, cr13, cr0, {0}
    5990:	79030000 	stmdbvc	r3, {}	@ <UNPREDICTABLE>
    5994:	34022700 	strcc	r2, [r2], #-1792	@ 0xfffff900
    5998:	0000057f 	andeq	r0, r0, pc, ror r5
    599c:	00001e54 	andeq	r1, r0, r4, asr lr
    59a0:	00001e50 	andeq	r1, r0, r0, asr lr
    59a4:	00251810 	eoreq	r1, r5, r0, lsl r8
    59a8:	00005400 	andeq	r5, r0, r0, lsl #8
    59ac:	0009d500 	andeq	sp, r9, r0, lsl #10
    59b0:	006c0600 	rsbeq	r0, ip, r0, lsl #12
    59b4:	af0f0230 	svcge	0x000f0230
    59b8:	02000000 	andeq	r0, r0, #0
    59bc:	20025891 	mulcs	r2, r1, r8
    59c0:	50000025 	andpl	r0, r0, r5, lsr #32
    59c4:	e400000b 	str	r0, [r0], #-11
    59c8:	01000008 	tsteq	r0, r8
    59cc:	7d025001 	stcvc	0, cr5, [r2, #-4]
    59d0:	51010100 	mrspl	r0, (UNDEF: 17)
    59d4:	00007402 	andeq	r7, r0, r2, lsl #8
    59d8:	00252a02 	eoreq	r2, r5, r2, lsl #20
    59dc:	000d2600 	andeq	r2, sp, r0, lsl #12
    59e0:	00090400 	andeq	r0, r9, r0, lsl #8
    59e4:	50010100 	andpl	r0, r1, r0, lsl #2
    59e8:	01007d02 	tsteq	r0, r2, lsl #26
    59ec:	7d025101 	stfvcs	f5, [r2, #-4]
    59f0:	52010100 	andpl	r0, r1, #0, 2
    59f4:	00007502 	andeq	r7, r0, r2, lsl #10
    59f8:	00253402 	eoreq	r3, r5, r2, lsl #8
    59fc:	000ea800 	andeq	sl, lr, r0, lsl #16
    5a00:	00092400 	andeq	r2, r9, r0, lsl #8
    5a04:	50010100 	andpl	r0, r1, r0, lsl #2
    5a08:	01007d02 	tsteq	r0, r2, lsl #26
    5a0c:	7d025101 	stfvcs	f5, [r2, #-4]
    5a10:	52010100 	andpl	r0, r1, #0, 2
    5a14:	00007402 	andeq	r7, r0, r2, lsl #8
    5a18:	00253e02 	eoreq	r3, r5, r2, lsl #28
    5a1c:	000d2600 	andeq	r2, sp, r0, lsl #12
    5a20:	00094400 	andeq	r4, r9, r0, lsl #8
    5a24:	50010100 	andpl	r0, r1, r0, lsl #2
    5a28:	01007502 	tsteq	r0, r2, lsl #10
    5a2c:	74025101 	strvc	r5, [r2], #-257	@ 0xfffffeff
    5a30:	52010100 	andpl	r0, r1, #0, 2
    5a34:	00007402 	andeq	r7, r0, r2, lsl #8
    5a38:	00254802 	eoreq	r4, r5, r2, lsl #16
    5a3c:	000d2600 	andeq	r2, sp, r0, lsl #12
    5a40:	00096400 	andeq	r6, r9, r0, lsl #8
    5a44:	50010100 	andpl	r0, r1, r0, lsl #2
    5a48:	01007402 	tsteq	r0, r2, lsl #8
    5a4c:	7d025101 	stfvcs	f5, [r2, #-4]
    5a50:	52010100 	andpl	r0, r1, #0, 2
    5a54:	00007d02 	andeq	r7, r0, r2, lsl #26
    5a58:	00254e02 	eoreq	r4, r5, r2, lsl #28
    5a5c:	000e8600 	andeq	r8, lr, r0, lsl #12
    5a60:	00097800 	andeq	r7, r9, r0, lsl #16
    5a64:	50010100 	andpl	r0, r1, r0, lsl #2
    5a68:	00007d02 	andeq	r7, r0, r2, lsl #26
    5a6c:	00255802 	eoreq	r5, r5, r2, lsl #16
    5a70:	000ea800 	andeq	sl, lr, r0, lsl #16
    5a74:	00099800 	andeq	r9, r9, r0, lsl #16
    5a78:	50010100 	andpl	r0, r1, r0, lsl #2
    5a7c:	01007402 	tsteq	r0, r2, lsl #8
    5a80:	74025101 	strvc	r5, [r2], #-257	@ 0xfffffeff
    5a84:	52010100 	andpl	r0, r1, #0, 2
    5a88:	00007d02 	andeq	r7, r0, r2, lsl #26
    5a8c:	00256202 	eoreq	r6, r5, r2, lsl #4
    5a90:	000d2600 	andeq	r2, sp, r0, lsl #12
    5a94:	0009b800 	andeq	fp, r9, r0, lsl #16
    5a98:	50010100 	andpl	r0, r1, r0, lsl #2
    5a9c:	01007d02 	tsteq	r0, r2, lsl #26
    5aa0:	7d025101 	stfvcs	f5, [r2, #-4]
    5aa4:	52010100 	andpl	r0, r1, #0, 2
    5aa8:	00007402 	andeq	r7, r0, r2, lsl #8
    5aac:	00256c04 	eoreq	r6, r5, r4, lsl #24
    5ab0:	000ea800 	andeq	sl, lr, r0, lsl #16
    5ab4:	50010100 	andpl	r0, r1, r0, lsl #2
    5ab8:	01007502 	tsteq	r0, r2, lsl #10
    5abc:	75025101 	strvc	r5, [r2, #-257]	@ 0xfffffeff
    5ac0:	52010100 	andpl	r0, r1, #0, 2
    5ac4:	00007d02 	andeq	r7, r0, r2, lsl #26
    5ac8:	250c0200 	strcs	r0, [ip, #-512]	@ 0xfffffe00
    5acc:	10560000 	subsne	r0, r6, r0
    5ad0:	09e90000 	stmibeq	r9!, {}^	@ <UNPREDICTABLE>
    5ad4:	01010000 	mrseq	r0, (UNDEF: 1)
    5ad8:	00740250 	rsbseq	r0, r4, r0, asr r2
    5adc:	25140400 	ldrcs	r0, [r4, #-1024]	@ 0xfffffc00
    5ae0:	10940000 	addsne	r0, r4, r0
    5ae4:	01010000 	mrseq	r0, (UNDEF: 1)
    5ae8:	00750250 	rsbseq	r0, r5, r0, asr r2
    5aec:	960d0000 	strls	r0, [sp], -r0
    5af0:	2000000e 	andcs	r0, r0, lr
    5af4:	00008002 	andeq	r8, r0, r2
    5af8:	0024ea00 	eoreq	lr, r4, r0, lsl #20
    5afc:	00001600 	andeq	r1, r0, r0, lsl #12
    5b00:	5d9c0100 	ldfpls	f0, [ip]
    5b04:	0300000a 	movweq	r0, #10
    5b08:	02200078 	eoreq	r0, r0, #120	@ 0x78
    5b0c:	0004412d 	andeq	r4, r4, sp, lsr #2
    5b10:	001e6700 	andseq	r6, lr, r0, lsl #14
    5b14:	001e6300 	andseq	r6, lr, r0, lsl #6
    5b18:	00790300 	rsbseq	r0, r9, r0, lsl #6
    5b1c:	41400220 	cmpmi	r0, r0, lsr #4
    5b20:	7d000004 	stcvc	0, cr0, [r0, #-16]
    5b24:	7900001e 	stmdbvc	r0, {r1, r2, r3, r4}
    5b28:	0200001e 	andeq	r0, r0, #30
    5b2c:	000024f2 	strdeq	r2, [r0], -r2	@ <UNPREDICTABLE>
    5b30:	00001056 	andeq	r1, r0, r6, asr r0
    5b34:	00000a4c 	andeq	r0, r0, ip, asr #20
    5b38:	03500101 	cmpeq	r0, #1073741824	@ 0x40000000
    5b3c:	005001a3 	subseq	r0, r0, r3, lsr #3
    5b40:	0024fa04 	eoreq	pc, r4, r4, lsl #20
    5b44:	00105600 	andseq	r5, r0, r0, lsl #12
    5b48:	50010100 	andpl	r0, r1, r0, lsl #2
    5b4c:	00007402 	andeq	r7, r0, r2, lsl #8
    5b50:	0d520700 	ldcleq	7, cr0, [r2, #-0]
    5b54:	021a0000 	andseq	r0, sl, #0
    5b58:	000024da 	ldrdeq	r2, [r0], -sl
    5b5c:	00000010 	andeq	r0, r0, r0, lsl r0
    5b60:	0abc9c01 	beq	fef2cb6c <_STACK_TOP_+0xdef24b70>
    5b64:	78030000 	stmdavc	r3, {}	@ <UNPREDICTABLE>
    5b68:	29021a00 	stmdbcs	r2, {r9, fp, ip}
    5b6c:	0000057f 	andeq	r0, r0, pc, ror r5
    5b70:	00001e90 	muleq	r0, r0, lr
    5b74:	00001e8c 	andeq	r1, r0, ip, lsl #29
    5b78:	1a007903 	bne	23f8c <__RAM_SIZE__+0x1bf8c>
    5b7c:	057f3602 	ldrbeq	r3, [pc, #-1538]!	@ 5582 <base_order+0x1d02>
    5b80:	1ea60000 	cdpne	0, 10, cr0, cr6, cr0, {0}
    5b84:	1ea20000 	cdpne	0, 10, cr0, cr2, cr0, {0}
    5b88:	e2020000 	and	r0, r2, #0
    5b8c:	94000024 	strls	r0, [r0], #-36	@ 0xffffffdc
    5b90:	ab000010 	blge	5bd8 <base_order+0x2358>
    5b94:	0100000a 	tsteq	r0, sl
    5b98:	a3035001 	movwge	r5, #12289	@ 0x3001
    5b9c:	04005001 	streq	r5, [r0], #-1
    5ba0:	000024e8 	andeq	r2, r0, r8, ror #9
    5ba4:	00001094 	muleq	r0, r4, r0
    5ba8:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    5bac:	00000074 	andeq	r0, r0, r4, ror r0
    5bb0:	000f0507 	andeq	r0, pc, r7, lsl #10
    5bb4:	c4021400 	strgt	r1, [r2], #-1024	@ 0xfffffc00
    5bb8:	16000024 	strne	r0, [r0], -r4, lsr #32
    5bbc:	01000000 	mrseq	r0, (UNDEF: 0)
    5bc0:	000b509c 	muleq	fp, ip, r0
    5bc4:	31780300 	cmncc	r8, r0, lsl #6
    5bc8:	25021400 	strcs	r1, [r2, #-1024]	@ 0xfffffc00
    5bcc:	0000057f 	andeq	r0, r0, pc, ror r5
    5bd0:	00001eb9 			@ <UNDEFINED> instruction: 0x00001eb9
    5bd4:	00001eb5 			@ <UNDEFINED> instruction: 0x00001eb5
    5bd8:	00317903 	eorseq	r7, r1, r3, lsl #18
    5bdc:	7f330214 	svcvc	0x00330214
    5be0:	cf000005 	svcgt	0x00000005
    5be4:	cb00001e 	blgt	5c64 <base_order+0x23e4>
    5be8:	0300001e 	movweq	r0, #30
    5bec:	14003278 	strne	r3, [r0], #-632	@ 0xfffffd88
    5bf0:	04414702 	strbeq	r4, [r1], #-1794	@ 0xfffff8fe
    5bf4:	1ee20000 	cdpne	0, 14, cr0, cr2, cr0, {0}
    5bf8:	1ede0000 	cdpne	0, 13, cr0, cr14, cr0, {0}
    5bfc:	79030000 	stmdbvc	r3, {}	@ <UNPREDICTABLE>
    5c00:	02140032 	andseq	r0, r4, #50	@ 0x32
    5c04:	0004415b 	andeq	r4, r4, fp, asr r1
    5c08:	001ef800 	andseq	pc, lr, r0, lsl #16
    5c0c:	001ef400 	andseq	pc, lr, r0, lsl #8
    5c10:	24d00200 	ldrbcs	r0, [r0], #512	@ 0x200
    5c14:	119b0000 	orrsne	r0, fp, r0
    5c18:	0b390000 	bleq	e45c20 <__ROM_SIZE__+0xe05c20>
    5c1c:	01010000 	mrseq	r0, (UNDEF: 1)
    5c20:	01a30350 			@ <UNDEFINED> instruction: 0x01a30350
    5c24:	51010150 	tstpl	r1, r0, asr r1
    5c28:	5201a303 	andpl	sl, r1, #201326592	@ 0xc000000
    5c2c:	24d80400 	ldrbcs	r0, [r8], #1024	@ 0x400
    5c30:	119b0000 	orrsne	r0, fp, r0
    5c34:	01010000 	mrseq	r0, (UNDEF: 1)
    5c38:	00740250 	rsbseq	r0, r4, r0, asr r2
    5c3c:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    5c40:	00000075 	andeq	r0, r0, r5, ror r0
    5c44:	000dd007 	andeq	sp, sp, r7
    5c48:	4001e600 	andmi	lr, r1, r0, lsl #12
    5c4c:	84000024 	strhi	r0, [r0], #-36	@ 0xffffffdc
    5c50:	01000000 	mrseq	r0, (UNDEF: 0)
    5c54:	000d269c 	muleq	sp, ip, r6
    5c58:	007a0300 	rsbseq	r0, sl, r0, lsl #6
    5c5c:	7f2401e6 	svcvc	0x002401e6
    5c60:	0d000005 	stceq	0, cr0, [r0, #-20]	@ 0xffffffec
    5c64:	0700001f 	smladeq	r0, pc, r0, r0	@ <UNPREDICTABLE>
    5c68:	0300001f 	movweq	r0, #31
    5c6c:	01e60078 	mvneq	r0, r8, ror r0
    5c70:	00044137 	andeq	r4, r4, r7, lsr r1
    5c74:	001f2a00 	andseq	r2, pc, r0, lsl #20
    5c78:	001f2600 	andseq	r2, pc, r0, lsl #12
    5c7c:	00750600 	rsbseq	r0, r5, r0, lsl #12
    5c80:	af0d01e8 	svcge	0x000d01e8
    5c84:	02000000 	andeq	r0, r0, #0
    5c88:	76065091 			@ <UNDEFINED> instruction: 0x76065091
    5c8c:	1001e800 	andne	lr, r1, r0, lsl #16
    5c90:	000000af 	andeq	r0, r0, pc, lsr #1
    5c94:	7fb89103 	svcvc	0x00b89103
    5c98:	e8006706 	stmda	r0, {r1, r2, r8, r9, sl, sp, lr}
    5c9c:	00af1301 	adceq	r1, pc, r1, lsl #6
    5ca0:	91030000 	mrsls	r0, (UNDEF: 3)
    5ca4:	68067fa0 	stmdavs	r6, {r5, r7, r8, r9, sl, fp, ip, sp, lr}
    5ca8:	1601e800 	strne	lr, [r1], -r0, lsl #16
    5cac:	000000af 	andeq	r0, r0, pc, lsr #1
    5cb0:	7f889103 	svcvc	0x00889103
    5cb4:	e9006905 	stmdb	r0, {r0, r2, r8, fp, sp, lr}
    5cb8:	00800701 	addeq	r0, r0, r1, lsl #14
    5cbc:	1f420000 	svcne	0x00420000
    5cc0:	1f3c0000 	svcne	0x003c0000
    5cc4:	4c020000 	stcmi	0, cr0, [r2], {-0}
    5cc8:	9b000024 	blls	5d60 <base_order+0x24e0>
    5ccc:	ed000011 	stc	0, cr0, [r0, #-68]	@ 0xffffffbc
    5cd0:	0100000b 	tsteq	r0, fp
    5cd4:	91025001 	tstls	r2, r1
    5cd8:	51010150 	tstpl	r1, r0, asr r1
    5cdc:	5101a303 	tstpl	r1, r3, lsl #6
    5ce0:	24540200 	ldrbcs	r0, [r4], #-512	@ 0xfffffe00
    5ce4:	119b0000 	orrsne	r0, fp, r0
    5ce8:	0c0b0000 	stceq	0, cr0, [fp], {-0}
    5cec:	01010000 	mrseq	r0, (UNDEF: 1)
    5cf0:	b8910350 	ldmlt	r1, {r4, r6, r8, r9}
    5cf4:	5101017f 	tstpl	r1, pc, ror r1
    5cf8:	38200305 	stmdacc	r0!, {r0, r2, r8, r9}
    5cfc:	02000000 	andeq	r0, r0, #0
    5d00:	0000245a 	andeq	r2, r0, sl, asr r4
    5d04:	00001094 	muleq	r0, r4, r0
    5d08:	00000c20 	andeq	r0, r0, r0, lsr #24
    5d0c:	03500101 	cmpeq	r0, #1073741824	@ 0x40000000
    5d10:	007fa091 			@ <UNDEFINED> instruction: 0x007fa091
    5d14:	00246002 	eoreq	r6, r4, r2
    5d18:	000f3200 	andeq	r3, pc, r0, lsl #4
    5d1c:	000c3400 	andeq	r3, ip, r0, lsl #8
    5d20:	50010100 	andpl	r0, r1, r0, lsl #2
    5d24:	00007702 	andeq	r7, r0, r2, lsl #14
    5d28:	00246c02 	eoreq	r6, r4, r2, lsl #24
    5d2c:	000f6600 	andeq	r6, pc, r0, lsl #12
    5d30:	000c5500 	andeq	r5, ip, r0, lsl #10
    5d34:	50010100 	andpl	r0, r1, r0, lsl #2
    5d38:	01007d02 	tsteq	r0, r2, lsl #26
    5d3c:	91035101 	tstls	r3, r1, lsl #2
    5d40:	01017fb8 			@ <UNDEFINED> instruction: 0x01017fb8
    5d44:	00760252 	rsbseq	r0, r6, r2, asr r2
    5d48:	24760200 	ldrbtcs	r0, [r6], #-512	@ 0xfffffe00
    5d4c:	0ea80000 	cdpeq	0, 10, cr0, cr8, cr0, {0}
    5d50:	0c750000 	ldcleq	0, cr0, [r5], #-0
    5d54:	01010000 	mrseq	r0, (UNDEF: 1)
    5d58:	50910250 	addspl	r0, r1, r0, asr r2
    5d5c:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    5d60:	01015091 	swpeq	r5, r1, [r1]	@ <UNPREDICTABLE>
    5d64:	007d0252 	rsbseq	r0, sp, r2, asr r2
    5d68:	24800200 	strcs	r0, [r0], #512	@ 0x200
    5d6c:	0f660000 	svceq	0x00660000
    5d70:	0c960000 	ldceq	0, cr0, [r6], {0}
    5d74:	01010000 	mrseq	r0, (UNDEF: 1)
    5d78:	007d0250 	rsbseq	r0, sp, r0, asr r2
    5d7c:	03510101 	cmpeq	r1, #1073741824	@ 0x40000000
    5d80:	017fa091 			@ <UNDEFINED> instruction: 0x017fa091
    5d84:	76025201 	strvc	r5, [r2], -r1, lsl #4
    5d88:	8a020000 	bhi	85d90 <__ROM_SIZE__+0x45d90>
    5d8c:	a8000024 	stmdage	r0, {r2, r5}
    5d90:	b600000e 	strlt	r0, [r0], -lr
    5d94:	0100000c 	tsteq	r0, ip
    5d98:	77025001 	strvc	r5, [r2, -r1]
    5d9c:	51010100 	mrspl	r0, (UNDEF: 17)
    5da0:	01007702 	tsteq	r0, r2, lsl #14
    5da4:	7d025201 	sfmvc	f5, 4, [r2, #-4]
    5da8:	90020000 	andls	r0, r2, r0
    5dac:	f4000024 	vst4.8	{d0-d3}, [r0 :128], r4
    5db0:	ca00000e 	bgt	5df0 <base_order+0x2570>
    5db4:	0100000c 	tsteq	r0, ip
    5db8:	91025001 	tstls	r2, r1
    5dbc:	98020050 	stmdals	r2, {r4, r6}
    5dc0:	fe000024 	cdp2	0, 0, cr0, cr0, cr4, {1}
    5dc4:	de00000f 	cdple	0, 0, cr0, cr0, cr15, {0}
    5dc8:	0100000c 	tsteq	r0, ip
    5dcc:	91025001 	tstls	r2, r1
    5dd0:	a0020050 	andge	r0, r2, r0, asr r0
    5dd4:	fe000024 	cdp2	0, 0, cr0, cr0, cr4, {1}
    5dd8:	f300000f 	vhadd.u8	d0, d0, d15
    5ddc:	0100000c 	tsteq	r0, ip
    5de0:	91035001 	tstls	r3, r1
    5de4:	02007fb8 	andeq	r7, r0, #184, 30	@ 0x2e0
    5de8:	000024ae 	andeq	r2, r0, lr, lsr #9
    5dec:	0000110b 	andeq	r1, r0, fp, lsl #2
    5df0:	00000d0e 	andeq	r0, r0, lr, lsl #26
    5df4:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    5df8:	01015091 	swpeq	r5, r1, [r1]	@ <UNPREDICTABLE>
    5dfc:	b8910351 	ldmlt	r1, {r0, r4, r6, r8, r9}
    5e00:	b604007f 			@ <UNDEFINED> instruction: 0xb604007f
    5e04:	0b000024 	bleq	5e9c <base_order+0x261c>
    5e08:	01000011 	tsteq	r0, r1, lsl r0
    5e0c:	91035001 	tstls	r3, r1
    5e10:	01017fa0 	smlatbeq	r1, r0, pc, r7	@ <UNPREDICTABLE>
    5e14:	00770251 	rsbseq	r0, r7, r1, asr r2
    5e18:	cc070000 	stcgt	0, cr0, [r7], {-0}
    5e1c:	b000000e 	andlt	r0, r0, lr
    5e20:	0023ca01 	eoreq	ip, r3, r1, lsl #20
    5e24:	00007600 	andeq	r7, r0, r0, lsl #12
    5e28:	869c0100 	ldrhi	r0, [ip], r0, lsl #2
    5e2c:	0300000e 	movweq	r0, #14
    5e30:	01b0007a 	rorseq	r0, sl, r0
    5e34:	00057f24 	andeq	r7, r5, r4, lsr #30
    5e38:	001f6300 	andseq	r6, pc, r0, lsl #6
    5e3c:	001f5d00 	andseq	r5, pc, r0, lsl #26
    5e40:	00780300 	rsbseq	r0, r8, r0, lsl #6
    5e44:	413701b0 	teqmi	r7, r0	@ <illegal shifter operand>
    5e48:	86000004 	strhi	r0, [r0], -r4
    5e4c:	7c00001f 	stcvc	0, cr0, [r0], {31}
    5e50:	0300001f 	movweq	r0, #31
    5e54:	01b00079 	rorseq	r0, r9, r0
    5e58:	0004414a 	andeq	r4, r4, sl, asr #2
    5e5c:	001fb600 	andseq	fp, pc, r0, lsl #12
    5e60:	001fb000 	andseq	fp, pc, r0
    5e64:	00690500 	rsbeq	r0, r9, r0, lsl #10
    5e68:	800701b2 			@ <UNDEFINED> instruction: 0x800701b2
    5e6c:	d1000000 	mrsle	r0, (UNDEF: 0)
    5e70:	cf00001f 	svcgt	0x0000001f
    5e74:	0600001f 			@ <UNDEFINED> instruction: 0x0600001f
    5e78:	00706d74 	rsbseq	r6, r0, r4, ror sp
    5e7c:	af0d01b3 	svcge	0x000d01b3
    5e80:	02000000 	andeq	r0, r0, #0
    5e84:	da025891 	ble	9c0d0 <__ROM_SIZE__+0x5c0d0>
    5e88:	9b000023 	blls	5f1c <base_order+0x269c>
    5e8c:	ac000011 	stcge	0, cr0, [r0], {17}
    5e90:	0100000d 	tsteq	r0, sp
    5e94:	7d025001 	stcvc	0, cr5, [r2, #-4]
    5e98:	51010100 	mrspl	r0, (UNDEF: 17)
    5e9c:	00007402 	andeq	r7, r0, r2, lsl #8
    5ea0:	0023e202 	eoreq	lr, r3, r2, lsl #4
    5ea4:	00120900 	andseq	r0, r2, r0, lsl #18
    5ea8:	000dc500 	andeq	ip, sp, r0, lsl #10
    5eac:	50010100 	andpl	r0, r1, r0, lsl #2
    5eb0:	01007502 	tsteq	r0, r2, lsl #10
    5eb4:	30015101 	andcc	r5, r1, r1, lsl #2
    5eb8:	23ec0200 	mvncs	r0, #0, 4
    5ebc:	119b0000 	orrsne	r0, fp, r0
    5ec0:	0ddf0000 	ldcleq	0, cr0, [pc]	@ 5ec8 <base_order+0x2648>
    5ec4:	01010000 	mrseq	r0, (UNDEF: 1)
    5ec8:	00760250 	rsbseq	r0, r6, r0, asr r2
    5ecc:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    5ed0:	02000074 	andeq	r0, r0, #116	@ 0x74
    5ed4:	000023f6 	strdeq	r2, [r0], -r6
    5ed8:	00001094 	muleq	r0, r4, r0
    5edc:	00000df3 	strdeq	r0, [r0], -r3
    5ee0:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    5ee4:	02000076 	andeq	r0, r0, #118	@ 0x76
    5ee8:	00002402 	andeq	r2, r0, r2, lsl #8
    5eec:	00000ea8 	andeq	r0, r0, r8, lsr #29
    5ef0:	00000e16 	andeq	r0, r0, r6, lsl lr
    5ef4:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    5ef8:	0101007d 	tsteq	r1, sp, ror r0
    5efc:	007d0251 	rsbseq	r0, sp, r1, asr r2
    5f00:	05520101 	ldrbeq	r0, [r2, #-257]	@ 0xfffffeff
    5f04:	00382003 	eorseq	r2, r8, r3
    5f08:	14020000 	strne	r0, [r2], #-0
    5f0c:	66000024 	strvs	r0, [r0], -r4, lsr #32
    5f10:	3500000f 	strcc	r0, [r0, #-15]
    5f14:	0100000e 	tsteq	r0, lr
    5f18:	7d025001 	stcvc	0, cr5, [r2, #-4]
    5f1c:	51010100 	mrspl	r0, (UNDEF: 17)
    5f20:	01007d02 	tsteq	r0, r2, lsl #26
    5f24:	31015201 	tstcc	r1, r1, lsl #4
    5f28:	241c0200 	ldrcs	r0, [ip], #-512	@ 0xfffffe00
    5f2c:	12090000 	andne	r0, r9, #0
    5f30:	0e4f0000 	cdpeq	0, 4, cr0, cr15, cr0, {0}
    5f34:	01010000 	mrseq	r0, (UNDEF: 1)
    5f38:	007d0250 	rsbseq	r0, sp, r0, asr r2
    5f3c:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    5f40:	0200a308 	andeq	sl, r0, #8, 6	@ 0x20000000
    5f44:	00002428 	andeq	r2, r0, r8, lsr #8
    5f48:	00001209 	andeq	r1, r0, r9, lsl #4
    5f4c:	00000e69 	andeq	r0, r0, r9, ror #28
    5f50:	02500101 	subseq	r0, r0, #1073741824	@ 0x40000000
    5f54:	01010075 	tsteq	r1, r5, ror r0
    5f58:	00740251 	rsbseq	r0, r4, r1, asr r2
    5f5c:	24360400 	ldrtcs	r0, [r6], #-1024	@ 0xfffffc00
    5f60:	0ea80000 	cdpeq	0, 10, cr0, cr8, cr0, {0}
    5f64:	01010000 	mrseq	r0, (UNDEF: 1)
    5f68:	00760250 	rsbseq	r0, r6, r0, asr r2
    5f6c:	02510101 	subseq	r0, r1, #1073741824	@ 0x40000000
    5f70:	01010076 	tsteq	r1, r6, ror r0
    5f74:	007d0252 	rsbseq	r0, sp, r2, asr r2
    5f78:	9d070000 	stcls	0, cr0, [r7, #-0]
    5f7c:	a900000d 	stmdbge	r0, {r0, r2, r3}
    5f80:	0023c001 	eoreq	ip, r3, r1
    5f84:	00000a00 	andeq	r0, r0, r0, lsl #20
    5f88:	a89c0100 	ldmge	ip, {r8}
    5f8c:	0a00000e 	beq	5fcc <base_order+0x274c>
    5f90:	01a90078 			@ <UNDEFINED> instruction: 0x01a90078
    5f94:	00057f24 	andeq	r7, r5, r4, lsr #30
    5f98:	00500100 	subseq	r0, r0, r0, lsl #2
    5f9c:	000e8907 	andeq	r8, lr, r7, lsl #18
    5fa0:	9e019f00 	cdpls	15, 0, cr9, cr1, cr0, {0}
    5fa4:	22000023 	andcs	r0, r0, #35	@ 0x23
    5fa8:	01000000 	mrseq	r0, (UNDEF: 0)
    5fac:	000ef49c 	muleq	lr, ip, r4
    5fb0:	007a0a00 	rsbseq	r0, sl, r0, lsl #20
    5fb4:	7f24019f 	svcvc	0x0024019f
    5fb8:	01000005 	tsteq	r0, r5
    5fbc:	00780a50 	rsbseq	r0, r8, r0, asr sl
    5fc0:	4137019f 	teqmi	r7, pc	@ <illegal shifter operand>
    5fc4:	01000004 	tsteq	r0, r4
    5fc8:	00790a51 	rsbseq	r0, r9, r1, asr sl
    5fcc:	414a019f 			@ <UNDEFINED> instruction: 0x414a019f
    5fd0:	01000004 	tsteq	r0, r4
    5fd4:	00690552 	rsbeq	r0, r9, r2, asr r5
    5fd8:	800701a1 	andhi	r0, r7, r1, lsr #3
    5fdc:	dd000000 	stcle	0, cr0, [r0, #-0]
    5fe0:	d900001f 	stmdble	r0, {r0, r1, r2, r3, r4}
    5fe4:	0000001f 	andeq	r0, r0, pc, lsl r0
    5fe8:	000e790d 	andeq	r7, lr, sp, lsl #18
    5fec:	80017700 	andhi	r7, r1, r0, lsl #14
    5ff0:	7c000000 	stcvc	0, cr0, [r0], {-0}
    5ff4:	22000023 	andcs	r0, r0, #35	@ 0x23
    5ff8:	01000000 	mrseq	r0, (UNDEF: 0)
    5ffc:	000f329c 	muleq	pc, ip, r2	@ <UNPREDICTABLE>
    6000:	00780300 	rsbseq	r0, r8, r0, lsl #6
    6004:	412c0177 			@ <UNDEFINED> instruction: 0x412c0177
    6008:	f5000004 			@ <UNDEFINED> instruction: 0xf5000004
    600c:	ed00001f 	stc	0, cr0, [r0, #-124]	@ 0xffffff84
    6010:	0500001f 	streq	r0, [r0, #-31]	@ 0xffffffe1
    6014:	017f0069 	cmneq	pc, r9, rrx
    6018:	00008007 	andeq	r8, r0, r7
    601c:	00201a00 	eoreq	r1, r0, r0, lsl #20
    6020:	00201800 	eoreq	r1, r0, r0, lsl #16
    6024:	f4070000 	vst4.8	{d0-d3}, [r7], r0
    6028:	6900000e 	stmdbvs	r0, {r1, r2, r3}
    602c:	00236801 	eoreq	r6, r3, r1, lsl #16
    6030:	00001400 	andeq	r1, r0, r0, lsl #8
    6034:	669c0100 	ldrvs	r0, [ip], r0, lsl #2
    6038:	0a00000f 	beq	607c <base_order+0x27fc>
    603c:	01690078 	smceq	36872	@ 0x9008
    6040:	00057f28 	andeq	r7, r5, r8, lsr #30
    6044:	05500100 	ldrbeq	r0, [r0, #-256]	@ 0xffffff00
    6048:	016e0069 	cmneq	lr, r9, rrx
    604c:	00008007 	andeq	r8, r0, r7
    6050:	00202600 	eoreq	r2, r0, r0, lsl #12
    6054:	00202200 	eoreq	r2, r0, r0, lsl #4
    6058:	04070000 	streq	r0, [r7], #-0
    605c:	3f00000e 	svccc	0x0000000e
    6060:	0022f401 	eoreq	pc, r2, r1, lsl #8
    6064:	00007400 	andeq	r7, r0, r0, lsl #8
    6068:	fe9c0100 	cdp2	1, 9, cr0, cr12, cr0, {0}
    606c:	0a00000f 	beq	60b0 <base_order+0x2830>
    6070:	013f0078 	teqeq	pc, r8, ror r0	@ <UNPREDICTABLE>
    6074:	00057f24 	andeq	r7, r5, r4, lsr #30
    6078:	03500100 	cmpeq	r0, #0, 2
    607c:	013f0079 	teqeq	pc, r9, ror r0	@ <UNPREDICTABLE>
    6080:	00044136 	andeq	r4, r4, r6, lsr r1
    6084:	00203c00 	eoreq	r3, r0, r0, lsl #24
    6088:	00203600 	eoreq	r3, r0, r0, lsl #12
    608c:	0def0900 			@ <UNDEFINED> instruction: 0x0def0900
    6090:	013f0000 	teqeq	pc, r0
    6094:	0000803d 	andeq	r8, r0, sp, lsr r0
    6098:	00205b00 	eoreq	r5, r0, r0, lsl #22
    609c:	00205500 	eoreq	r5, r0, r0, lsl #10
    60a0:	0d6f1200 	sfmeq	f1, 2, [pc, #-0]	@ 60a8 <base_order+0x2828>
    60a4:	01410000 	mrseq	r0, (UNDEF: 65)
    60a8:	00008007 	andeq	r8, r0, r7
    60ac:	00207900 	eoreq	r7, r0, r0, lsl #18
    60b0:	00207500 	eoreq	r7, r0, r0, lsl #10
    60b4:	00690500 	rsbeq	r0, r9, r0, lsl #10
    60b8:	80070144 	andhi	r0, r7, r4, asr #2
    60bc:	8e000000 	cdphi	0, 0, cr0, cr0, cr0, {0}
    60c0:	88000020 	stmdahi	r0, {r5}
    60c4:	05000020 	streq	r0, [r0, #-32]	@ 0xffffffe0
    60c8:	0144006a 	cmpeq	r4, sl, rrx
    60cc:	00008009 	andeq	r8, r0, r9
    60d0:	0020a900 	eoreq	sl, r0, r0, lsl #18
    60d4:	0020a500 	eoreq	sl, r0, r0, lsl #10
    60d8:	00c71800 	sbceq	r1, r7, r0, lsl #16
    60dc:	69050000 	stmdbvs	r5, {}	@ <UNPREDICTABLE>
    60e0:	09015800 	stmdbeq	r1, {fp, ip, lr}
    60e4:	00000080 	andeq	r0, r0, r0, lsl #1
    60e8:	000020ba 	strheq	r2, [r0], -sl
    60ec:	000020b8 	strheq	r2, [r0], -r8
    60f0:	1d0d0000 	stcne	0, cr0, [sp, #-0]
    60f4:	2400000e 	strcs	r0, [r0], #-14
    60f8:	00008001 	andeq	r8, r0, r1
    60fc:	0022ca00 	eoreq	ip, r2, r0, lsl #20
    6100:	00002a00 	andeq	r2, r0, r0, lsl #20
    6104:	569c0100 	ldrpl	r0, [ip], r0, lsl #2
    6108:	03000010 	movweq	r0, #16
    610c:	01240078 			@ <UNDEFINED> instruction: 0x01240078
    6110:	00044129 	andeq	r4, r4, r9, lsr #2
    6114:	0020ca00 	eoreq	ip, r0, r0, lsl #20
    6118:	0020c200 	eoreq	ip, r0, r0, lsl #4
    611c:	00690500 	rsbeq	r0, r9, r0, lsl #10
    6120:	80070126 	andhi	r0, r7, r6, lsr #2
    6124:	ed000000 	stc	0, cr0, [r0, #-0]
    6128:	e9000020 	stmdb	r0, {r5}
    612c:	18000020 	stmdane	r0, {r5}
    6130:	000000bc 	strheq	r0, [r0], -ip
    6134:	000f2812 	andeq	r2, pc, r2, lsl r8	@ <UNPREDICTABLE>
    6138:	0e013400 	cfcpyseq	mvf3, mvf1
    613c:	00000061 	andeq	r0, r0, r1, rrx
    6140:	00002100 	andeq	r2, r0, r0, lsl #2
    6144:	000020fe 	strdeq	r2, [r0], -lr
    6148:	c10d0000 	mrsgt	r0, (UNDEF: 13)
    614c:	0800000d 	stmdaeq	r0, {r0, r2, r3}
    6150:	00008001 	andeq	r8, r0, r1
    6154:	0022b000 	eoreq	fp, r2, r0
    6158:	00001a00 	andeq	r1, r0, r0, lsl #20
    615c:	949c0100 	ldrls	r0, [ip], #256	@ 0x100
    6160:	03000010 	movweq	r0, #16
    6164:	01080078 	tsteq	r8, r8, ror r0
    6168:	0004412a 	andeq	r4, r4, sl, lsr #2
    616c:	00210c00 	eoreq	r0, r1, r0, lsl #24
    6170:	00210800 	eoreq	r0, r1, r0, lsl #16
    6174:	00690500 	rsbeq	r0, r9, r0, lsl #10
    6178:	610c010a 	tstvs	ip, sl, lsl #2
    617c:	22000000 	andcs	r0, r0, #0
    6180:	1e000021 	cdpne	0, 0, cr0, cr0, cr1, {1}
    6184:	00000021 	andeq	r0, r0, r1, lsr #32
    6188:	000ebc13 	andeq	fp, lr, r3, lsl ip
    618c:	229efd00 	addscs	pc, lr, #0, 26
    6190:	00120000 	andseq	r0, r2, r0
    6194:	9c010000 	stcls	0, cr0, [r1], {-0}
    6198:	000010c4 	andeq	r1, r0, r4, asr #1
    619c:	fd00780e 	stc2	8, cr7, [r0, #-56]	@ 0xffffffc8
    61a0:	00057f26 	andeq	r7, r5, r6, lsr #30
    61a4:	15500100 	ldrbne	r0, [r0, #-256]	@ 0xffffff00
    61a8:	80ff0069 	rscshi	r0, pc, r9, rrx
    61ac:	36000000 	strcc	r0, [r0], -r0
    61b0:	32000021 	andcc	r0, r0, #33	@ 0x21
    61b4:	00000021 	andeq	r0, r0, r1, lsr #32
    61b8:	000d801d 	andeq	r8, sp, sp, lsl r0
    61bc:	0ce30100 	stfeqe	f0, [r3]
    61c0:	00000080 	andeq	r0, r0, r0, lsl #1
    61c4:	00002280 	andeq	r2, r0, r0, lsl #5
    61c8:	0000001e 	andeq	r0, r0, lr, lsl r0
    61cc:	110b9c01 	tstne	fp, r1, lsl #24
    61d0:	780b0000 	stmdavc	fp, {}	@ <UNPREDICTABLE>
    61d4:	4128e300 			@ <UNDEFINED> instruction: 0x4128e300
    61d8:	4e000004 	cdpmi	0, 0, cr0, cr0, cr4, {0}
    61dc:	46000021 	strmi	r0, [r0], -r1, lsr #32
    61e0:	0e000021 	cdpeq	0, 0, cr0, cr0, cr1, {1}
    61e4:	3ae30079 	bcc	ff8c63d0 <_STACK_TOP_+0xdf8be3d4>
    61e8:	00000441 	andeq	r0, r0, r1, asr #8
    61ec:	69155101 	ldmdbvs	r5, {r0, r8, ip, lr}
    61f0:	0080e500 	addeq	lr, r0, r0, lsl #10
    61f4:	21700000 	cmncs	r0, r0
    61f8:	216c0000 	cmncs	ip, r0
    61fc:	13000000 	movwne	r0, #0
    6200:	00000ea7 	andeq	r0, r0, r7, lsr #29
    6204:	00225cd9 	ldrdeq	r5, [r2], -r9	@ <UNPREDICTABLE>
    6208:	00002400 	andeq	r2, r0, r0, lsl #8
    620c:	9b9c0100 	blls	fe706614 <_STACK_TOP_+0xde6fe618>
    6210:	0b000011 	bleq	625c <base_order+0x29dc>
    6214:	22d90078 	sbcscs	r0, r9, #120	@ 0x78
    6218:	0000057f 	andeq	r0, r0, pc, ror r5
    621c:	00002183 	andeq	r2, r0, r3, lsl #3
    6220:	0000217d 	andeq	r2, r0, sp, ror r1
    6224:	d900790b 	stmdble	r0, {r0, r1, r3, r8, fp, ip, sp, lr}
    6228:	00057f2e 	andeq	r7, r5, lr, lsr #30
    622c:	00219700 	eoreq	r9, r1, r0, lsl #14
    6230:	00219300 	eoreq	r9, r1, r0, lsl #6
    6234:	6d741e00 	ldclvs	14, cr1, [r4, #-0]
    6238:	db010070 	blle	46400 <__ROM_SIZE__+0x6400>
    623c:	00008e0c 	andeq	r8, r0, ip, lsl #28
    6240:	58910200 	ldmpl	r1, {r9}
    6244:	00226c02 	eoreq	r6, r2, r2, lsl #24
    6248:	00119b00 	andseq	r9, r1, r0, lsl #22
    624c:	00116a00 	andseq	r6, r1, r0, lsl #20
    6250:	50010100 	andpl	r0, r1, r0, lsl #2
    6254:	01007d02 	tsteq	r0, r2, lsl #26
    6258:	75025101 	strvc	r5, [r2, #-257]	@ 0xfffffeff
    625c:	74020000 	strvc	r0, [r2], #-0
    6260:	9b000022 	blls	62f0 <base_order+0x2a70>
    6264:	84000011 	strhi	r0, [r0], #-17	@ 0xffffffef
    6268:	01000011 	tsteq	r0, r1, lsl r0
    626c:	75025001 	strvc	r5, [r2, #-1]
    6270:	51010100 	mrspl	r0, (UNDEF: 17)
    6274:	00007402 	andeq	r7, r0, r2, lsl #8
    6278:	00227c04 	eoreq	r7, r2, r4, lsl #24
    627c:	00119b00 	andseq	r9, r1, r0, lsl #22
    6280:	50010100 	andpl	r0, r1, r0, lsl #2
    6284:	01007402 	tsteq	r0, r2, lsl #8
    6288:	7d025101 	stfvcs	f5, [r2, #-4]
    628c:	13000000 	movwne	r0, #0
    6290:	00000db5 			@ <UNDEFINED> instruction: 0x00000db5
    6294:	002248d0 	ldrdeq	r4, [r2], -r0	@ <UNPREDICTABLE>
    6298:	00001400 	andeq	r1, r0, r0, lsl #8
    629c:	d69c0100 	ldrle	r0, [ip], r0, lsl #2
    62a0:	0e000011 	mcreq	0, 0, r0, cr0, cr1, {0}
    62a4:	22d00078 	sbcscs	r0, r0, #120	@ 0x78
    62a8:	0000057f 	andeq	r0, r0, pc, ror r5
    62ac:	790e5001 	stmdbvc	lr, {r0, ip, lr}
    62b0:	4134d000 	teqmi	r4, r0
    62b4:	01000004 	tsteq	r0, r4
    62b8:	00691551 	rsbeq	r1, r9, r1, asr r5
    62bc:	000080d2 	ldrdeq	r8, [r0], -r2
    62c0:	0021a600 	eoreq	sl, r1, r0, lsl #12
    62c4:	0021a200 	eoreq	sl, r1, r0, lsl #4
    62c8:	30130000 	andscc	r0, r3, r0
    62cc:	cb00000f 	blgt	6310 <base_order+0x2a90>
    62d0:	0000222e 	andeq	r2, r0, lr, lsr #4
    62d4:	0000001a 	andeq	r0, r0, sl, lsl r0
    62d8:	12099c01 	andne	r9, r9, #256	@ 0x100
    62dc:	780e0000 	stmdavc	lr, {}	@ <UNPREDICTABLE>
    62e0:	7f25cb00 	svcvc	0x0025cb00
    62e4:	01000005 	tsteq	r0, r5
    62e8:	64690b50 	strbtvs	r0, [r9], #-2896	@ 0xfffff4b0
    62ec:	37cb0078 			@ <UNDEFINED> instruction: 0x37cb0078
    62f0:	0000006d 	andeq	r0, r0, sp, rrx
    62f4:	000021b6 			@ <UNDEFINED> instruction: 0x000021b6
    62f8:	000021b2 			@ <UNDEFINED> instruction: 0x000021b2
    62fc:	0df51f00 	ldcleq	15, cr1, [r5]
    6300:	c6010000 	strgt	r0, [r1], -r0
    6304:	0000800c 	andeq	r8, r0, ip
    6308:	00221c00 	eoreq	r1, r2, r0, lsl #24
    630c:	00001200 	andeq	r1, r0, r0, lsl #4
    6310:	0b9c0100 	bleq	fe706718 <_STACK_TOP_+0xde6fe71c>
    6314:	2ac60078 	bcs	ff1864fc <_STACK_TOP_+0xdf17e500>
    6318:	00000441 	andeq	r0, r0, r1, asr #8
    631c:	000021c8 	andeq	r2, r0, r8, asr #3
    6320:	000021c4 	andeq	r2, r0, r4, asr #3
    6324:	7864690b 	stmdavc	r4!, {r0, r1, r3, r8, fp, sp, lr}^
    6328:	6d3cc600 	ldcvs	6, cr12, [ip, #-0]
    632c:	da000000 	ble	6334 <base_order+0x2ab4>
    6330:	d6000021 	strle	r0, [r0], -r1, lsr #32
    6334:	00000021 	andeq	r0, r0, r1, lsr #32
    6338:	00014700 	andeq	r4, r1, r0, lsl #14
    633c:	01000500 	tsteq	r0, r0, lsl #10
    6340:	001d1104 	andseq	r1, sp, r4, lsl #2
    6344:	00460500 	subeq	r0, r6, r0, lsl #10
    6348:	3f1d0000 	svccc	0x001d0000
    634c:	1400000f 	strne	r0, [r0], #-15
    6350:	9c000000 	stcls	0, cr0, [r0], {-0}
    6354:	5c000027 	stcpl	0, cr0, [r0], {39}	@ 0x27
    6358:	ee000000 	cdp	0, 0, cr0, cr0, cr0, {0}
    635c:	01000042 	tsteq	r0, r2, asr #32
    6360:	012d0601 			@ <UNDEFINED> instruction: 0x012d0601
    6364:	02010000 	andeq	r0, r1, #0
    6368:	0001e305 	andeq	lr, r1, r5, lsl #6
    636c:	05040100 	streq	r0, [r4, #-256]	@ 0xffffff00
    6370:	000001c7 	andeq	r0, r0, r7, asr #3
    6374:	c2050801 	andgt	r0, r5, #65536	@ 0x10000
    6378:	01000001 	tsteq	r0, r1
    637c:	012b0801 			@ <UNDEFINED> instruction: 0x012b0801
    6380:	02010000 	andeq	r0, r1, #0
    6384:	00013907 	andeq	r3, r1, r7, lsl #18
    6388:	026a0600 	rsbeq	r0, sl, #0, 12
    638c:	34020000 	strcc	r0, [r2], #-0
    6390:	00005c19 	andeq	r5, r0, r9, lsl ip
    6394:	07040100 	streq	r0, [r4, -r0, lsl #2]
    6398:	00000176 	andeq	r0, r0, r6, ror r1
    639c:	71070801 	tstvc	r7, r1, lsl #16
    63a0:	07000001 	streq	r0, [r0, -r1]
    63a4:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
    63a8:	04010074 	streq	r0, [r1], #-116	@ 0xffffff8c
    63ac:	00017b07 	andeq	r7, r1, r7, lsl #22
    63b0:	0bfe0800 	bleq	fff883b8 <_STACK_TOP_+0xdff803bc>
    63b4:	1b010000 	blne	463bc <__ROM_SIZE__+0x63bc>
    63b8:	0000500a 	andeq	r5, r0, sl
    63bc:	0027ba00 	eoreq	fp, r7, r0, lsl #20
    63c0:	00003e00 	andeq	r3, r0, r0, lsl #28
    63c4:	e49c0100 	ldr	r0, [ip], #256	@ 0x100
    63c8:	03000000 	movweq	r0, #0
    63cc:	00727473 	rsbseq	r7, r2, r3, ror r4
    63d0:	00e41b1b 	rsceq	r1, r4, fp, lsl fp
    63d4:	21f80000 	mvnscs	r0, r0
    63d8:	21f40000 	mvnscs	r0, r0
    63dc:	68020000 	stmdavs	r2, {}	@ <UNPREDICTABLE>
    63e0:	1c007865 	stcne	8, cr7, [r0], {101}	@ 0x65
    63e4:	0000500c 	andeq	r5, r0, ip
    63e8:	00220b00 	eoreq	r0, r2, r0, lsl #22
    63ec:	00220300 	eoreq	r0, r2, r0, lsl #6
    63f0:	0afe0900 	beq	fff887f8 <_STACK_TOP_+0xdff807fc>
    63f4:	1d010000 	stcne	0, cr0, [r1, #-0]
    63f8:	0000500c 	andeq	r5, r0, ip
    63fc:	00222d00 	eoreq	r2, r2, r0, lsl #26
    6400:	00222500 	eoreq	r2, r2, r0, lsl #10
    6404:	00e50400 	rsceq	r0, r5, r0, lsl #8
    6408:	69020000 	stmdbvs	r2, {}	@ <UNPREDICTABLE>
    640c:	50111f00 	andspl	r1, r1, r0, lsl #30
    6410:	47000000 	strmi	r0, [r0, -r0]
    6414:	43000022 	movwmi	r0, #34	@ 0x22
    6418:	00000022 	andeq	r0, r0, r2, lsr #32
    641c:	f1040a00 			@ <UNDEFINED> instruction: 0xf1040a00
    6420:	01000000 	mrseq	r0, (UNDEF: 0)
    6424:	01340801 	teqeq	r4, r1, lsl #16
    6428:	ea0b0000 	b	2c6430 <__ROM_SIZE__+0x286430>
    642c:	0c000000 	stceq	0, cr0, [r0], {-0}
    6430:	00000bf9 	strdeq	r0, [r0], -r9
    6434:	6a051301 	bvs	14b040 <__ROM_SIZE__+0x10b040>
    6438:	9c000000 	stcls	0, cr0, [r0], {-0}
    643c:	1e000027 	cdpne	0, 0, cr0, cr0, cr7, {1}
    6440:	01000000 	mrseq	r0, (UNDEF: 0)
    6444:	7473039c 	ldrbtvc	r0, [r3], #-924	@ 0xfffffc64
    6448:	16130072 			@ <UNDEFINED> instruction: 0x16130072
    644c:	000000e4 	andeq	r0, r0, r4, ror #1
    6450:	00002257 	andeq	r2, r0, r7, asr r2
    6454:	00002253 	andeq	r2, r0, r3, asr r2
    6458:	73657202 	cmnvc	r5, #536870912	@ 0x20000000
    645c:	6a071400 	bvs	1cb464 <__ROM_SIZE__+0x18b464>
    6460:	68000000 	stmdavs	r0, {}	@ <UNPREDICTABLE>
    6464:	62000022 	andvs	r0, r0, #34	@ 0x22
    6468:	04000022 	streq	r0, [r0], #-34	@ 0xffffffde
    646c:	000000de 	ldrdeq	r0, [r0], -lr
    6470:	15006902 	strne	r6, [r0, #-2306]	@ 0xfffff6fe
    6474:	00006a0c 	andeq	r6, r0, ip, lsl #20
    6478:	00227d00 	eoreq	r7, r2, r0, lsl #26
    647c:	00227900 	eoreq	r7, r2, r0, lsl #18
    6480:	00000000 	andeq	r0, r0, r0
    6484:	00000226 	andeq	r0, r0, r6, lsr #4
    6488:	04010005 	streq	r0, [r1], #-5
    648c:	00001dd7 	ldrdeq	r1, [r0], -r7
    6490:	0000460c 	andeq	r4, r0, ip, lsl #12
    6494:	0f8f1d00 	svceq	0x008f1d00
    6498:	00140000 	andseq	r0, r4, r0
    649c:	27f80000 	ldrbcs	r0, [r8, r0]!
    64a0:	00ac0000 	adceq	r0, ip, r0
    64a4:	447b0000 	ldrbtmi	r0, [fp], #-0
    64a8:	01010000 	mrseq	r0, (UNDEF: 1)
    64ac:	00012d06 	andeq	r2, r1, r6, lsl #26
    64b0:	05020100 	streq	r0, [r2, #-256]	@ 0xffffff00
    64b4:	000001e3 	andeq	r0, r0, r3, ror #3
    64b8:	c7050401 	strgt	r0, [r5, -r1, lsl #8]
    64bc:	01000001 	tsteq	r0, r1
    64c0:	01c20508 	biceq	r0, r2, r8, lsl #10
    64c4:	88020000 	stmdahi	r2, {}	@ <UNPREDICTABLE>
    64c8:	02000001 	andeq	r0, r0, #1
    64cc:	0053182e 	subseq	r1, r3, lr, lsr #16
    64d0:	420d0000 	andmi	r0, sp, #0
    64d4:	01000000 	mrseq	r0, (UNDEF: 0)
    64d8:	012b0801 			@ <UNDEFINED> instruction: 0x012b0801
    64dc:	02010000 	andeq	r0, r1, #0
    64e0:	00013907 	andeq	r3, r1, r7, lsl #18
    64e4:	026a0200 	rsbeq	r0, sl, #0, 4
    64e8:	34020000 	strcc	r0, [r2], #-0
    64ec:	00006d19 	andeq	r6, r0, r9, lsl sp
    64f0:	07040100 	streq	r0, [r4, -r0, lsl #2]
    64f4:	00000176 	andeq	r0, r0, r6, ror r1
    64f8:	71070801 	tstvc	r7, r1, lsl #16
    64fc:	0e000001 	cdpeq	0, 0, cr0, cr0, cr1, {0}
    6500:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
    6504:	04010074 	streq	r0, [r1], #-116	@ 0xffffff8c
    6508:	00017b07 	andeq	r7, r1, r7, lsl #22
    650c:	0fce0f00 	svceq	0x00ce0f00
    6510:	01070000 	mrseq	r0, (UNDEF: 7)
    6514:	00000053 	andeq	r0, r0, r3, asr r0
    6518:	b40e1603 	strlt	r1, [lr], #-1539	@ 0xfffff9fd
    651c:	07000000 	streq	r0, [r0, -r0]
    6520:	00000ff6 	strdeq	r0, [r0], -r6
    6524:	4e490800 	cdpmi	8, 4, cr0, cr9, cr0, {0}
    6528:	08010050 	stmdaeq	r1, {r4, r6}
    652c:	0054554f 	subseq	r5, r4, pc, asr #10
    6530:	10130702 	andsne	r0, r3, r2, lsl #14
    6534:	00030000 	andeq	r0, r3, r0
    6538:	00101b02 	andseq	r1, r0, r2, lsl #22
    653c:	031b0300 	tsteq	fp, #0, 6
    6540:	00000089 	andeq	r0, r0, r9, lsl #1
    6544:	000f7a10 	andeq	r7, pc, r0, lsl sl	@ <UNPREDICTABLE>
    6548:	1d030c00 	stcne	12, cr0, [r3, #-0]
    654c:	0000f210 	andeq	pc, r0, r0, lsl r2	@ <UNPREDICTABLE>
    6550:	08860300 	stmeq	r6, {r8, r9}
    6554:	151e0000 	ldrne	r0, [lr, #-0]
    6558:	000000f2 	strdeq	r0, [r0], -r2
    655c:	09140300 	ldmdbeq	r4, {r8, r9}
    6560:	0c1f0000 	ldceq	0, cr0, [pc], {-0}
    6564:	00000061 	andeq	r0, r0, r1, rrx
    6568:	0fdf0304 	svceq	0x00df0304
    656c:	07210000 	streq	r0, [r1, -r0]!
    6570:	0000007b 	andeq	r0, r0, fp, ror r0
    6574:	4e090008 	cdpmi	0, 0, cr0, cr9, cr8, {0}
    6578:	02000000 	andeq	r0, r0, #0
    657c:	00000f6f 	andeq	r0, r0, pc, ror #30
    6580:	c0032203 	andgt	r2, r3, r3, lsl #4
    6584:	02000000 	andeq	r0, r0, #0
    6588:	0000000d 	andeq	r0, r0, sp
    658c:	8217d604 	andshi	sp, r7, #4, 12	@ 0x400000
    6590:	01000000 	mrseq	r0, (UNDEF: 0)
    6594:	02250408 	eoreq	r0, r5, #8, 8	@ 0x8000000
    6598:	ea040000 	b	1065a0 <__ROM_SIZE__+0xc65a0>
    659c:	1400000f 	strne	r0, [r0], #-15
    65a0:	0000f713 	andeq	pc, r0, r3, lsl r7	@ <UNPREDICTABLE>
    65a4:	3c030500 	cfstr32cc	mvfx0, [r3], {-0}
    65a8:	04200003 	strteq	r0, [r0], #-3
    65ac:	00000f83 	andeq	r0, r0, r3, lsl #31
    65b0:	00f72014 	rscseq	r2, r7, r4, lsl r0
    65b4:	03050000 	movweq	r0, #20480	@ 0x5000
    65b8:	20000330 	andcs	r0, r0, r0, lsr r3
    65bc:	000fc504 	andeq	ip, pc, r4, lsl #10
    65c0:	b40f1500 	strlt	r1, [pc], #-1280	@ 65c8 <base_order+0x2d48>
    65c4:	05000000 	streq	r0, [r0, #-0]
    65c8:	00032c03 	andeq	r2, r3, r3, lsl #24
    65cc:	076a1120 	strbeq	r1, [sl, -r0, lsr #2]!
    65d0:	41050000 	mrsmi	r0, (UNDEF: 5)
    65d4:	00016907 	andeq	r6, r1, r7, lsl #18
    65d8:	00016900 	andeq	r6, r1, r0, lsl #18
    65dc:	01690500 	cmneq	r9, r0, lsl #10
    65e0:	7b050000 	blvc	1465e8 <__ROM_SIZE__+0x1065e8>
    65e4:	05000000 	streq	r0, [r0, #-0]
    65e8:	00000103 	andeq	r0, r0, r3, lsl #2
    65ec:	0a041200 	beq	10adf4 <__ROM_SIZE__+0xcadf4>
    65f0:	00000fd3 	ldrdeq	r0, [r0], -r3
    65f4:	00287848 	eoreq	r7, r8, r8, asr #16
    65f8:	00002c00 	andeq	r2, r0, r0, lsl #24
    65fc:	8c9c0100 	ldfhis	f0, [ip], {0}
    6600:	13000001 	movwne	r0, #1
    6604:	48010063 	stmdami	r1, {r0, r1, r5, r6}
    6608:	00018c17 	andeq	r8, r1, r7, lsl ip
    660c:	00500100 	subseq	r0, r0, r0, lsl #2
    6610:	34080101 	strcc	r0, [r8], #-257	@ 0xfffffeff
    6614:	14000001 	strne	r0, [r0], #-1
    6618:	00001007 	andeq	r1, r0, r7
    661c:	7b053401 	blvc	153628 <__ROM_SIZE__+0x113628>
    6620:	38000000 	stmdacc	r0, {}	@ <UNPREDICTABLE>
    6624:	40000028 	andmi	r0, r0, r8, lsr #32
    6628:	01000000 	mrseq	r0, (UNDEF: 0)
    662c:	0001c29c 	muleq	r1, ip, r2
    6630:	61761500 	cmnvs	r6, r0, lsl #10
    6634:	3d01006c 	stccc	0, cr0, [r1, #-432]	@ 0xfffffe50
    6638:	00007b07 	andeq	r7, r0, r7, lsl #22
    663c:	00229900 	eoreq	r9, r2, r0, lsl #18
    6640:	00229500 	eoreq	r9, r2, r0, lsl #10
    6644:	fb0a0000 	blx	28664e <__ROM_SIZE__+0x24664e>
    6648:	1700000f 	strne	r0, [r0, -pc]
    664c:	000027f8 	strdeq	r2, [r0], -r8
    6650:	00000040 	andeq	r0, r0, r0, asr #32
    6654:	02249c01 	eoreq	r9, r4, #256	@ 0x100
    6658:	86060000 	strhi	r0, [r6], -r0
    665c:	1b000008 	blne	6684 <base_order+0x2e04>
    6660:	00000224 	andeq	r0, r0, r4, lsr #4
    6664:	000022aa 	andeq	r2, r0, sl, lsr #5
    6668:	000022a4 	andeq	r2, r0, r4, lsr #5
    666c:	00091406 	andeq	r1, r9, r6, lsl #8
    6670:	00612a00 	rsbeq	r2, r1, r0, lsl #20
    6674:	22c50000 	sbccs	r0, r5, #0
    6678:	22bd0000 	adcscs	r0, sp, #0
    667c:	ce060000 	cdpgt	0, 0, cr0, cr6, cr0, {0}
    6680:	3700000f 	strcc	r0, [r0, -pc]
    6684:	000000b4 	strheq	r0, [r0], -r4
    6688:	000022e5 	andeq	r2, r0, r5, ror #5
    668c:	000022dd 	ldrdeq	r2, [r0], -sp
    6690:	00282216 	eoreq	r2, r8, r6, lsl r2
    6694:	00014900 	andeq	r4, r1, r0, lsl #18
    6698:	51010b00 	tstpl	r1, r0, lsl #22
    669c:	0b007502 	bleq	23aac <__RAM_SIZE__+0x1baac>
    66a0:	a3035201 	movwge	r5, #12801	@ 0x3201
    66a4:	00005101 	andeq	r5, r0, r1, lsl #2
    66a8:	00004209 	andeq	r4, r0, r9, lsl #4
    66ac:	020a0000 	andeq	r0, sl, #0
    66b0:	00050000 	andeq	r0, r5, r0
    66b4:	1f290401 	svcne	0x00290401
    66b8:	46090000 	strmi	r0, [r9], -r0
    66bc:	1d000000 	stcne	0, cr0, [r0, #-0]
    66c0:	00001033 	andeq	r1, r0, r3, lsr r0
    66c4:	00000014 	andeq	r0, r0, r4, lsl r0
    66c8:	000028a4 	andeq	r2, r0, r4, lsr #17
    66cc:	00000060 	andeq	r0, r0, r0, rrx
    66d0:	00004692 	muleq	r0, r2, r6
    66d4:	6905040a 	stmdbvs	r5, {r1, r3, sl}
    66d8:	0b00746e 	bleq	23898 <__RAM_SIZE__+0x1b898>
    66dc:	0000000d 	andeq	r0, r0, sp
    66e0:	3917d602 	ldmdbcc	r7, {r1, r9, sl, ip, lr, pc}
    66e4:	02000000 	andeq	r0, r0, #0
    66e8:	017b0704 	cmneq	fp, r4, lsl #14
    66ec:	08020000 	stmdaeq	r2, {}	@ <UNPREDICTABLE>
    66f0:	0001c205 	andeq	ip, r1, r5, lsl #4
    66f4:	04080200 	streq	r0, [r8], #-512	@ 0xfffffe00
    66f8:	00000225 	andeq	r0, r0, r5, lsr #4
    66fc:	00076a03 	andeq	r6, r7, r3, lsl #20
    6700:	b7073500 	strlt	r3, [r7, -r0, lsl #10]
    6704:	f4000000 	vst4.8	{d0-d3}, [r0], r0
    6708:	10000028 	andne	r0, r0, r8, lsr #32
    670c:	01000000 	mrseq	r0, (UNDEF: 0)
    6710:	0000b79c 	muleq	r0, ip, r7
    6714:	10220100 	eorne	r0, r2, r0, lsl #2
    6718:	14350000 	ldrtne	r0, [r5], #-0
    671c:	000000b7 	strheq	r0, [r0], -r7
    6720:	00002311 	andeq	r2, r0, r1, lsl r3
    6724:	0000230d 	andeq	r2, r0, sp, lsl #6
    6728:	6c617607 	stclvs	6, cr7, [r1], #-28	@ 0xffffffe4
    672c:	261e3500 	ldrcs	r3, [lr], -r0, lsl #10
    6730:	01000000 	mrseq	r0, (UNDEF: 0)
    6734:	09140851 	ldmdbeq	r4, {r0, r4, r6, fp}
    6738:	2a350000 	bcs	d46740 <__ROM_SIZE__+0xd06740>
    673c:	0000002d 	andeq	r0, r0, sp, lsr #32
    6740:	69045201 	stmdbvs	r4, {r0, r9, ip, lr}
    6744:	002d3600 	eoreq	r3, sp, r0, lsl #12
    6748:	23230000 			@ <UNDEFINED> instruction: 0x23230000
    674c:	231f0000 	tstcs	pc, #0
    6750:	69050000 	stmdbvs	r5, {}	@ <UNPREDICTABLE>
    6754:	37000010 	smladcc	r0, r0, r0, r0
    6758:	000000b9 	strheq	r0, [r0], -r9
    675c:	00002333 	andeq	r2, r0, r3, lsr r3
    6760:	0000232f 	andeq	r2, r0, pc, lsr #6
    6764:	06040c00 	streq	r0, [r4], -r0, lsl #24
    6768:	000000be 	strheq	r0, [r0], -lr
    676c:	34080102 	strcc	r0, [r8], #-258	@ 0xfffffefe
    6770:	0d000001 	stceq	0, cr0, [r0, #-4]
    6774:	000000be 	strheq	r0, [r0], -lr
    6778:	00070e03 	andeq	r0, r7, r3, lsl #28
    677c:	b7072b00 	strlt	r2, [r7, -r0, lsl #22]
    6780:	de000000 	cdple	0, 0, cr0, cr0, cr0, {0}
    6784:	16000028 	strne	r0, [r0], -r8, lsr #32
    6788:	01000000 	mrseq	r0, (UNDEF: 0)
    678c:	0001459c 	muleq	r1, ip, r5
    6790:	10220100 	eorne	r0, r2, r0, lsl #2
    6794:	142b0000 	strtne	r0, [fp], #-0
    6798:	000000b7 	strheq	r0, [r0], -r7
    679c:	00002345 	andeq	r2, r0, r5, asr #6
    67a0:	00002341 	andeq	r2, r0, r1, asr #6
    67a4:	63727307 	cmnvs	r2, #469762048	@ 0x1c000000
    67a8:	45262b00 	strmi	r2, [r6, #-2816]!	@ 0xfffff500
    67ac:	01000001 	tsteq	r0, r1
    67b0:	09140851 	ldmdbeq	r4, {r0, r4, r6, fp}
    67b4:	322b0000 	eorcc	r0, fp, #0
    67b8:	0000002d 	andeq	r0, r0, sp, lsr #32
    67bc:	69045201 	stmdbvs	r4, {r0, r9, ip, lr}
    67c0:	002d2c00 	eoreq	r2, sp, r0, lsl #24
    67c4:	23570000 	cmpcs	r7, #0
    67c8:	23530000 	cmpcs	r3, #0
    67cc:	73050000 	movwvc	r0, #20480	@ 0x5000
    67d0:	2d000010 	stccs	0, cr0, [r0, #-64]	@ 0xffffffc0
    67d4:	000000b9 	strheq	r0, [r0], -r9
    67d8:	00002365 	andeq	r2, r0, r5, ror #6
    67dc:	00002363 	andeq	r2, r0, r3, ror #6
    67e0:	00106905 	andseq	r6, r0, r5, lsl #18
    67e4:	00b92e00 	adcseq	r2, r9, r0, lsl #28
    67e8:	236f0000 	cmncs	pc, #0
    67ec:	236b0000 	cmncs	fp, #0
    67f0:	06000000 	streq	r0, [r0], -r0
    67f4:	0000014a 	andeq	r0, r0, sl, asr #2
    67f8:	1027030e 	eorne	r0, r7, lr, lsl #6
    67fc:	07230000 	streq	r0, [r3, -r0]!
    6800:	000000b9 	strheq	r0, [r0], -r9
    6804:	000028ca 	andeq	r2, r0, sl, asr #17
    6808:	00000014 	andeq	r0, r0, r4, lsl r0
    680c:	018b9c01 	orreq	r9, fp, r1, lsl #24
    6810:	2e010000 	cdpcs	0, 0, cr0, cr1, cr0, {0}
    6814:	23000010 	movwcs	r0, #16
    6818:	0000b914 	andeq	fp, r0, r4, lsl r9
    681c:	00238300 	eoreq	r8, r3, r0, lsl #6
    6820:	00237d00 	eoreq	r7, r3, r0, lsl #26
    6824:	0b370100 	bleq	dc6c2c <__ROM_SIZE__+0xd86c2c>
    6828:	26230000 	strtcs	r0, [r3], -r0
    682c:	0000018b 	andeq	r0, r0, fp, lsl #3
    6830:	00002399 	muleq	r0, r9, r3
    6834:	00002395 	muleq	r0, r5, r3
    6838:	00c50600 	sbceq	r0, r5, r0, lsl #12
    683c:	b5030000 	strlt	r0, [r3, #-0]
    6840:	1b000001 	blne	684c <base_order+0x2fcc>
    6844:	00002605 	andeq	r2, r0, r5, lsl #12
    6848:	0028b400 	eoreq	fp, r8, r0, lsl #8
    684c:	00001600 	andeq	r1, r0, r0, lsl #12
    6850:	d09c0100 	addsle	r0, ip, r0, lsl #2
    6854:	01000001 	tsteq	r0, r1
    6858:	0000102e 	andeq	r1, r0, lr, lsr #32
    685c:	018b181b 	orreq	r1, fp, fp, lsl r8
    6860:	23a80000 			@ <UNDEFINED> instruction: 0x23a80000
    6864:	23a40000 			@ <UNDEFINED> instruction: 0x23a40000
    6868:	37010000 	strcc	r0, [r1, -r0]
    686c:	1b00000b 	blne	68a0 <base_order+0x3020>
    6870:	00018b2a 	andeq	r8, r1, sl, lsr #22
    6874:	0023b700 	eoreq	fp, r3, r0, lsl #14
    6878:	0023b300 	eoreq	fp, r3, r0, lsl #6
    687c:	4e0f0000 	cdpmi	0, 0, cr0, cr15, cr0, {0}
    6880:	01000002 	tsteq	r0, r2
    6884:	002d0813 	eoreq	r0, sp, r3, lsl r8
    6888:	28a40000 	stmiacs	r4!, {}	@ <UNPREDICTABLE>
    688c:	00100000 	andseq	r0, r0, r0
    6890:	9c010000 	stcls	0, cr0, [r1], {-0}
    6894:	72747310 	rsbsvc	r7, r4, #16, 6	@ 0x40000000
    6898:	1b130100 	blne	4c6ca0 <__ROM_SIZE__+0x486ca0>
    689c:	0000018b 	andeq	r0, r0, fp, lsl #3
    68a0:	000023c6 	andeq	r2, r0, r6, asr #7
    68a4:	000023c2 	andeq	r2, r0, r2, asr #7
    68a8:	6e656c04 	cdpvs	12, 6, cr6, cr5, cr4, {0}
    68ac:	002d1400 	eoreq	r1, sp, r0, lsl #8
    68b0:	23d50000 	bicscs	r0, r5, #0
    68b4:	23d10000 	bicscs	r0, r1, #0
    68b8:	00000000 	andeq	r0, r0, r0

Disassembly of section .debug_abbrev:

00000000 <.debug_abbrev>:
       0:	02004901 	andeq	r4, r0, #16384	@ 0x4000
       4:	00187e18 	andseq	r7, r8, r8, lsl lr
       8:	00050200 	andeq	r0, r5, r0, lsl #4
       c:	00001349 	andeq	r1, r0, r9, asr #6
      10:	7d014803 	stcvc	8, cr4, [r1, #-12]
      14:	01137f01 	tsteq	r3, r1, lsl #30
      18:	04000013 	streq	r0, [r0], #-19	@ 0xffffffed
      1c:	210b000f 	tstcs	fp, pc
      20:	00134904 	andseq	r4, r3, r4, lsl #18
      24:	00240500 	eoreq	r0, r4, r0, lsl #10
      28:	0b3e0b0b 	bleq	f82c5c <__ROM_SIZE__+0xf42c5c>
      2c:	00000e03 	andeq	r0, r0, r3, lsl #28
      30:	03000d06 	movweq	r0, #3334	@ 0xd06
      34:	3b0b3a0e 	blcc	2ce874 <__ROM_SIZE__+0x28e874>
      38:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
      3c:	000b3813 	andeq	r3, fp, r3, lsl r8
      40:	00160700 	andseq	r0, r6, r0, lsl #14
      44:	0b3a0e03 	bleq	e83858 <__ROM_SIZE__+0xe43858>
      48:	0b390b3b 	bleq	e42d3c <__ROM_SIZE__+0xe02d3c>
      4c:	00001349 	andeq	r1, r0, r9, asr #6
      50:	49010108 	stmdbmi	r1, {r3, r8}
      54:	00130113 	andseq	r0, r3, r3, lsl r1
      58:	00210900 	eoreq	r0, r1, r0, lsl #18
      5c:	0b2f1349 	bleq	bc4d88 <__ROM_SIZE__+0xb84d88>
      60:	2e0a0000 	cdpcs	0, 0, cr0, cr10, cr0, {0}
      64:	03193f01 	tsteq	r9, #1, 30
      68:	3b0b3a0e 	blcc	2ce8a8 <__ROM_SIZE__+0x28e8a8>
      6c:	0621390b 	strteq	r3, [r1], -fp, lsl #18
      70:	193c1927 	ldmdbne	ip!, {r0, r1, r2, r5, r8, fp, ip}
      74:	00001301 	andeq	r1, r0, r1, lsl #6
      78:	3f012e0b 	svccc	0x00012e0b
      7c:	3a0e0319 	bcc	380ce8 <__ROM_SIZE__+0x340ce8>
      80:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
      84:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
      88:	01193c13 	tsteq	r9, r3, lsl ip
      8c:	0c000013 	stceq	0, cr0, [r0], {19}
      90:	017d0148 	cmneq	sp, r8, asr #2
      94:	0000137f 	andeq	r1, r0, pc, ror r3
      98:	4900260d 	stmdbmi	r0, {r0, r2, r3, r9, sl, sp}
      9c:	0e000013 	mcreq	0, 0, r0, cr0, cr3, {0}
      a0:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
      a4:	3b01213a 	blcc	48594 <__ROM_SIZE__+0x8594>
      a8:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
      ac:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
      b0:	00001742 	andeq	r1, r0, r2, asr #14
      b4:	0300340f 	movweq	r3, #1039	@ 0x40f
      b8:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
      bc:	0b390b3b 	bleq	e42db0 <__ROM_SIZE__+0xe02db0>
      c0:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
      c4:	34100000 	ldrcc	r0, [r0], #-0
      c8:	3a0e0300 	bcc	380cd0 <__ROM_SIZE__+0x340cd0>
      cc:	0b3b0621 	bleq	ec1958 <__ROM_SIZE__+0xe81958>
      d0:	49102139 	ldmdbmi	r0, {r0, r3, r4, r5, r8, sp}
      d4:	3c193f13 	ldccc	15, cr3, [r9], {19}
      d8:	11000019 	tstne	r0, r9, lsl r0
      dc:	0111010b 	tsteq	r1, fp, lsl #2
      e0:	13010612 	movwne	r0, #5650	@ 0x1612
      e4:	34120000 	ldrcc	r0, [r2], #-0
      e8:	3a080300 	bcc	200cf0 <__ROM_SIZE__+0x1c0cf0>
      ec:	0b3b0121 	bleq	ec0578 <__ROM_SIZE__+0xe80578>
      f0:	13490b39 	movtne	r0, #39737	@ 0x9b39
      f4:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
      f8:	13000017 	movwne	r0, #23
      fc:	0b0b0113 	bleq	2c0550 <__ROM_SIZE__+0x280550>
     100:	0b3b0b3a 	bleq	ec2df0 <__ROM_SIZE__+0xe82df0>
     104:	01092139 	tsteq	r9, r9, lsr r1
     108:	14000013 	strne	r0, [r0], #-19	@ 0xffffffed
     10c:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
     110:	213a0e03 	teqcs	sl, r3, lsl #28
     114:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
     118:	19270521 	stmdbne	r7!, {r0, r5, r8, sl}
     11c:	01111349 	tsteq	r1, r9, asr #6
     120:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
     124:	1301197a 	movwne	r1, #6522	@ 0x197a
     128:	11150000 	tstne	r5, r0
     12c:	130e2501 	movwne	r2, #58625	@ 0xe501
     130:	1b0e030b 	blne	380d64 <__ROM_SIZE__+0x340d64>
     134:	1201110e 	andne	r1, r1, #-2147483645	@ 0x80000003
     138:	00171006 	andseq	r1, r7, r6
     13c:	00241600 	eoreq	r1, r4, r0, lsl #12
     140:	0b3e0b0b 	bleq	f82d74 <__ROM_SIZE__+0xf42d74>
     144:	00000803 	andeq	r0, r0, r3, lsl #16
     148:	03011317 	movweq	r1, #4887	@ 0x1317
     14c:	3a050b0e 	bcc	142d8c <__ROM_SIZE__+0x102d8c>
     150:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     154:	0013010b 	andseq	r0, r3, fp, lsl #2
     158:	000d1800 	andeq	r1, sp, r0, lsl #16
     15c:	0b3a0803 	bleq	e82170 <__ROM_SIZE__+0xe42170>
     160:	0b390b3b 	bleq	e42e54 <__ROM_SIZE__+0xe02e54>
     164:	0b381349 	bleq	e04e90 <__ROM_SIZE__+0xdc4e90>
     168:	34190000 	ldrcc	r0, [r9], #-0
     16c:	3a080300 	bcc	200d74 <__ROM_SIZE__+0x1c0d74>
     170:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     174:	3f13490b 	svccc	0x0013490b
     178:	00193c19 	andseq	r3, r9, r9, lsl ip
     17c:	00211a00 	eoreq	r1, r1, r0, lsl #20
     180:	161b0000 	ldrne	r0, [fp], -r0
     184:	3a080300 	bcc	200d8c <__ROM_SIZE__+0x1c0d8c>
     188:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     18c:	0013490b 	andseq	r4, r3, fp, lsl #18
     190:	01151c00 	tsteq	r5, r0, lsl #24
     194:	13491927 	movtne	r1, #39207	@ 0x9927
     198:	00001301 	andeq	r1, r0, r1, lsl #6
     19c:	0300341d 	movweq	r3, #1053	@ 0x41d
     1a0:	3b0b3a0e 	blcc	2ce9e0 <__ROM_SIZE__+0x28e9e0>
     1a4:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
     1a8:	02193f13 	andseq	r3, r9, #19, 30	@ 0x4c
     1ac:	1e000018 	mcrne	0, 0, r0, cr0, cr8, {0}
     1b0:	00000018 	andeq	r0, r0, r8, lsl r0
     1b4:	4901011f 	stmdbmi	r1, {r0, r1, r2, r3, r4, r8}
     1b8:	00000013 	andeq	r0, r0, r3, lsl r0
     1bc:	0b002401 	bleq	91c8 <__RAM_SIZE__+0x11c8>
     1c0:	030b3e0b 	movweq	r3, #48651	@ 0xbe0b
     1c4:	0200000e 	andeq	r0, r0, #14
     1c8:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
     1cc:	0e030b13 	vmoveq.32	d3[0], r0
     1d0:	01110e1b 	tsteq	r1, fp, lsl lr
     1d4:	17100612 			@ <UNDEFINED> instruction: 0x17100612
     1d8:	16030000 	strne	r0, [r3], -r0
     1dc:	3a0e0300 	bcc	380de4 <__ROM_SIZE__+0x340de4>
     1e0:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     1e4:	0013490b 	andseq	r4, r3, fp, lsl #18
     1e8:	00240400 	eoreq	r0, r4, r0, lsl #8
     1ec:	0b3e0b0b 	bleq	f82e20 <__ROM_SIZE__+0xf42e20>
     1f0:	00000803 	andeq	r0, r0, r3, lsl #16
     1f4:	03003405 	movweq	r3, #1029	@ 0x405
     1f8:	3b0b3a0e 	blcc	2cea38 <__ROM_SIZE__+0x28ea38>
     1fc:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
     200:	3c193f13 	ldccc	15, cr3, [r9], {19}
     204:	06000019 			@ <UNDEFINED> instruction: 0x06000019
     208:	13490101 	movtne	r0, #37121	@ 0x9101
     20c:	00001301 	andeq	r1, r0, r1, lsl #6
     210:	49002107 	stmdbmi	r0, {r0, r1, r2, r8, sp}
     214:	000b2f13 	andeq	r2, fp, r3, lsl pc
     218:	00340800 	eorseq	r0, r4, r0, lsl #16
     21c:	0b3a0e03 	bleq	e83a30 <__ROM_SIZE__+0xe43a30>
     220:	0b390b3b 	bleq	e42f14 <__ROM_SIZE__+0xe02f14>
     224:	193f1349 	ldmdbne	pc!, {r0, r3, r6, r8, r9, ip}	@ <UNPREDICTABLE>
     228:	00001802 	andeq	r1, r0, r2, lsl #16
     22c:	3f002e09 	svccc	0x00002e09
     230:	3a0e0319 	bcc	380e9c <__ROM_SIZE__+0x340e9c>
     234:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     238:	3c19270b 	ldccc	7, cr2, [r9], {11}
     23c:	0a000019 	beq	2a8 <vector_table+0x2a8>
     240:	193f002e 	ldmdbne	pc!, {r1, r2, r3, r5}	@ <UNPREDICTABLE>
     244:	0b3a0e03 	bleq	e83a58 <__ROM_SIZE__+0xe43a58>
     248:	0b390b3b 	bleq	e42f3c <__ROM_SIZE__+0xe02f3c>
     24c:	01111927 	tsteq	r1, r7, lsr #18
     250:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
     254:	0000197a 	andeq	r1, r0, sl, ror r9
     258:	01110100 	tsteq	r1, r0, lsl #2
     25c:	0b130e25 	bleq	4c3af8 <__ROM_SIZE__+0x483af8>
     260:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
     264:	06120111 			@ <UNDEFINED> instruction: 0x06120111
     268:	00001710 	andeq	r1, r0, r0, lsl r7
     26c:	3f002e02 	svccc	0x00002e02
     270:	3a0e0319 	bcc	380edc <__ROM_SIZE__+0x340edc>
     274:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     278:	1119270b 	tstne	r9, fp, lsl #14
     27c:	40061201 	andmi	r1, r6, r1, lsl #4
     280:	00197a18 	andseq	r7, r9, r8, lsl sl
     284:	002e0300 	eoreq	r0, lr, r0, lsl #6
     288:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
     28c:	0b3b0b3a 	bleq	ec2f7c <__ROM_SIZE__+0xe82f7c>
     290:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
     294:	01111349 	tsteq	r1, r9, asr #6
     298:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
     29c:	0000197a 	andeq	r1, r0, sl, ror r9
     2a0:	0b002404 	bleq	92b8 <__RAM_SIZE__+0x12b8>
     2a4:	030b3e0b 	movweq	r3, #48651	@ 0xbe0b
     2a8:	05000008 	streq	r0, [r0, #-8]
     2ac:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
     2b0:	0b3a0e03 	bleq	e83ac4 <__ROM_SIZE__+0xe43ac4>
     2b4:	0b390b3b 	bleq	e42fa8 <__ROM_SIZE__+0xe02fa8>
     2b8:	01111927 	tsteq	r1, r7, lsr #18
     2bc:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
     2c0:	1301197a 	movwne	r1, #6522	@ 0x197a
     2c4:	05060000 	streq	r0, [r6, #-0]
     2c8:	3a080300 	bcc	200ed0 <__ROM_SIZE__+0x1c0ed0>
     2cc:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     2d0:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
     2d4:	1742b717 	smlaldne	fp, r2, r7, r7
     2d8:	48070000 	stmdami	r7, {}	@ <UNPREDICTABLE>
     2dc:	7f017d01 	svcvc	0x00017d01
     2e0:	08000013 	stmdaeq	r0, {r0, r1, r4}
     2e4:	18020049 	stmdane	r2, {r0, r3, r6}
     2e8:	0000187e 	andeq	r1, r0, lr, ror r8
     2ec:	0b002409 	bleq	9318 <__RAM_SIZE__+0x1318>
     2f0:	030b3e0b 	movweq	r3, #48651	@ 0xbe0b
     2f4:	0000000e 	andeq	r0, r0, lr
     2f8:	25011101 	strcs	r1, [r1, #-257]	@ 0xfffffeff
     2fc:	030b130e 	movweq	r1, #45838	@ 0xb30e
     300:	110e1b0e 	tstne	lr, lr, lsl #22
     304:	10061201 	andne	r1, r6, r1, lsl #4
     308:	02000017 	andeq	r0, r0, #23
     30c:	193f002e 	ldmdbne	pc!, {r1, r2, r3, r5}	@ <UNPREDICTABLE>
     310:	0b3a0e03 	bleq	e83b24 <__ROM_SIZE__+0xe43b24>
     314:	0b390b3b 	bleq	e43008 <__ROM_SIZE__+0xe03008>
     318:	01111927 	tsteq	r1, r7, lsr #18
     31c:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
     320:	0000197a 	andeq	r1, r0, sl, ror r9
     324:	3f002e03 	svccc	0x00002e03
     328:	3a0e0319 	bcc	380f94 <__ROM_SIZE__+0x340f94>
     32c:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     330:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
     334:	12011113 	andne	r1, r1, #-1073741820	@ 0xc0000004
     338:	7a184006 	bvc	610358 <__ROM_SIZE__+0x5d0358>
     33c:	04000019 	streq	r0, [r0], #-25	@ 0xffffffe7
     340:	0b0b0024 	bleq	2c03d8 <__ROM_SIZE__+0x2803d8>
     344:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
     348:	2e050000 	cdpcs	0, 0, cr0, cr5, cr0, {0}
     34c:	03193f01 	tsteq	r9, #1, 30
     350:	3b0b3a0e 	blcc	2ceb90 <__ROM_SIZE__+0x28eb90>
     354:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
     358:	12011119 	andne	r1, r1, #1073741830	@ 0x40000006
     35c:	7a184006 	bvc	61037c <__ROM_SIZE__+0x5d037c>
     360:	00130119 	andseq	r0, r3, r9, lsl r1
     364:	00050600 	andeq	r0, r5, r0, lsl #12
     368:	0b3a0803 	bleq	e8237c <__ROM_SIZE__+0xe4237c>
     36c:	0b390b3b 	bleq	e43060 <__ROM_SIZE__+0xe03060>
     370:	17021349 	strne	r1, [r2, -r9, asr #6]
     374:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
     378:	01480700 	cmpeq	r8, r0, lsl #14
     37c:	137f017d 	cmnne	pc, #1073741855	@ 0x4000001f
     380:	49080000 	stmdbmi	r8, {}	@ <UNPREDICTABLE>
     384:	7e180200 	cdpvc	2, 1, cr0, cr8, cr0, {0}
     388:	09000018 	stmdbeq	r0, {r3, r4}
     38c:	0b0b0024 	bleq	2c0424 <__ROM_SIZE__+0x280424>
     390:	0e030b3e 	vmoveq.16	d3[0], r0
     394:	01000000 	mrseq	r0, (UNDEF: 0)
     398:	0b0b0024 	bleq	2c0430 <__ROM_SIZE__+0x280430>
     39c:	0e030b3e 	vmoveq.16	d3[0], r0
     3a0:	05020000 	streq	r0, [r2, #-0]
     3a4:	00134900 	andseq	r4, r3, r0, lsl #18
     3a8:	00480300 	subeq	r0, r8, r0, lsl #6
     3ac:	137f017d 	cmnne	pc, #1073741855	@ 0x4000001f
     3b0:	2e040000 	cdpcs	0, 0, cr0, cr4, cr0, {0}
     3b4:	03193f01 	tsteq	r9, #1, 30
     3b8:	3b0b3a0e 	blcc	2cebf8 <__ROM_SIZE__+0x28ebf8>
     3bc:	0621390b 	strteq	r3, [r1], -fp, lsl #18
int finish_ecdhpair(int argc, char** argv) {
     3c0:	193c1927 	ldmdbne	ip!, {r0, r1, r2, r5, r8, fp, ip}
    if (argc == 4) {
     3c4:	00001301 	andeq	r1, r0, r1, lsl #6
    else printf("Incorrect number of arguments for PAIRECDH2\n");
     3c8:	0b000f05 	bleq	3fe4 <base_order+0x764>
     3cc:	13490421 	movtne	r0, #37921	@ 0x9421
     3d0:	2e060000 	cdpcs	0, 0, cr0, cr6, cr0, {0}
     3d4:	03193f00 	tsteq	r9, #0, 30
        decode_base64((uint8_t *)argv[3], 64, carpubkey);
     3d8:	3b0b3a0e 	blcc	2cec18 <__ROM_SIZE__+0x28ec18>
     3dc:	21392921 	teqcs	r9, r1, lsr #18
        ecdh_shared_secret(ECDH_privkey, carpubkey, ECDH_shared);
     3e0:	49192705 	ldmdbmi	r9, {r0, r2, r8, r9, sl, sp}
     3e4:	00193c13 	andseq	r3, r9, r3, lsl ip
     3e8:	002e0700 	eoreq	r0, lr, r0, lsl #14
        sha256_init(&shactx);
     3ec:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
     3f0:	213b0b3a 	teqcs	fp, sl, lsr fp
	    sha256_update(&shactx, ECDH_shared, ECC_PUB_KEY_SIZE);
     3f4:	0621392f 	strteq	r3, [r1], -pc, lsr #18
     3f8:	193c1927 	ldmdbne	ip!, {r0, r1, r2, r5, r8, fp, ip}
     3fc:	11080000 	mrsne	r0, (UNDEF: 8)
	    sha256_final(&shactx, ECDH_AESkey);
     400:	130e2501 	movwne	r2, #58625	@ 0xe501
     404:	1b0e030b 	blne	381038 <__ROM_SIZE__+0x341038>
        AES_init_ctx(&ctx, ECDH_AESkey);
     408:	1201110e 	andne	r1, r1, #-2147483645	@ 0x80000003
     40c:	00171006 	andseq	r1, r7, r6
     410:	00240900 	eoreq	r0, r4, r0, lsl #18
     414:	0b3e0b0b 	bleq	f83048 <__ROM_SIZE__+0xf43048>
     418:	00000803 	andeq	r0, r0, r3, lsl #16
     41c:	2701150a 	strcs	r1, [r1, -sl, lsl #10]
     420:	00130119 	andseq	r0, r3, r9, lsl r1
     424:	00150b00 	andseq	r0, r5, r0, lsl #22
int car_mesg(int argc, char** argv) {
     428:	13491927 	movtne	r1, #39207	@ 0x9927
     42c:	2e0c0000 	cdpcs	0, 0, cr0, cr12, cr0, {0}
    printf("Received a message from the car:");
     430:	03193f01 	tsteq	r9, #1, 30
     434:	3b0b3a0e 	blcc	2cec74 <__ROM_SIZE__+0x28ec74>
    for (ctr = 1; ctr < argc; ctr++) {
     438:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
        printf(" %s", argv[ctr]);
     43c:	12011119 	andne	r1, r1, #1073741830	@ 0x40000006
     440:	7a184006 	bvc	610460 <__ROM_SIZE__+0x5d0460>
    for (ctr = 1; ctr < argc; ctr++) {
     444:	00130119 	andseq	r0, r3, r9, lsl r1
     448:	002e0d00 	eoreq	r0, lr, r0, lsl #26
    printf("\n");
     44c:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
    if (argc > 1) {
     450:	0b3b0b3a 	bleq	ec3140 <__ROM_SIZE__+0xe83140>
}
     454:	01110b39 	tsteq	r1, r9, lsr fp
     458:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
        if (strcmp(argv[1], "PING_REPLY") == 0) {
     45c:	0000197a 	andeq	r1, r0, sl, ror r9
     460:	00490100 	subeq	r0, r9, r0, lsl #2
            printf("Got a ping reply.\n");
     464:	187e1802 	ldmdane	lr!, {r1, fp, ip}^
     468:	05020000 	streq	r0, [r2, #-0]
        else if (strcmp(argv[1], "PAIRECDH2") == 0) {
     46c:	00134900 	andseq	r4, r3, r0, lsl #18
     470:	00240300 	eoreq	r0, r4, r0, lsl #6
     474:	0b3e0b0b 	bleq	f830a8 <__ROM_SIZE__+0xf430a8>
            finish_ecdhpair(argc, argv);
     478:	00000e03 	andeq	r0, r0, r3, lsl #28
     47c:	7d014804 	stcvc	8, cr4, [r1, #-16]
        else if (strcmp(argv[1], "AESB64") == 0) {
     480:	01137f01 	tsteq	r3, r1, lsl #30
     484:	05000013 	streq	r0, [r0, #-19]	@ 0xffffffed
     488:	210b000f 	tstcs	fp, pc
            if (argc == 3) { 
     48c:	00134904 	andseq	r4, r3, r4, lsl #18
                printf("Missing AESB64 encoded message\n");
     490:	000d0600 	andeq	r0, sp, r0, lsl #12
     494:	0b3a0e03 	bleq	e83ca8 <__ROM_SIZE__+0xe43ca8>
                len = decode_base64((uint8_t *) argv[2], strlen(argv[2]), decoded);
     498:	0b390b3b 	bleq	e4318c <__ROM_SIZE__+0xe0318c>
     49c:	0b381349 	bleq	e051c8 <__ROM_SIZE__+0xdc51c8>
     4a0:	21070000 	mrscs	r0, (UNDEF: 7)
     4a4:	2f134900 	svccs	0x00134900
     4a8:	0800000b 	stmdaeq	r0, {r0, r1, r3}
                AES_ECB_decrypt(&ctx, decoded);
     4ac:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
     4b0:	0b3a0e03 	bleq	e83cc4 <__ROM_SIZE__+0xe43cc4>
                decoded[len] = '\0';
     4b4:	0b390b3b 	bleq	e431a8 <__ROM_SIZE__+0xe031a8>
     4b8:	13491927 	movtne	r1, #39207	@ 0x9927
     4bc:	1301193c 	movwne	r1, #6460	@ 0x193c
                printf("Decoded/decrypted as %s\n", decoded);
     4c0:	01090000 	mrseq	r0, (UNDEF: 9)
     4c4:	01134901 	tsteq	r3, r1, lsl #18
     4c8:	0a000013 	beq	51c <car_mesg+0xf4>
        else if (strcmp(argv[1], "B64") == 0) {
     4cc:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     4d0:	3b01213a 	blcc	489c0 <__ROM_SIZE__+0x89c0>
            if (argc == 3) { 
     4d4:	0d21390b 			@ <UNDEFINED> instruction: 0x0d21390b
                printf("Missing Base64 encoded message\n");
     4d8:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
     4dc:	160b0000 	strne	r0, [fp], -r0
                printf("Decoding Base64\n");
     4e0:	3a0e0300 	bcc	3810e8 <__ROM_SIZE__+0x3410e8>
     4e4:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
                len = decode_base64((uint8_t *) argv[2], strlen(argv[2]), decoded);
     4e8:	0013490b 	andseq	r4, r3, fp, lsl #18
     4ec:	00260c00 	eoreq	r0, r6, r0, lsl #24
     4f0:	00001349 	andeq	r1, r0, r9, asr #6
     4f4:	3f012e0d 	svccc	0x00012e0d
                decoded[len] = '\0';
     4f8:	3a0e0319 	bcc	381164 <__ROM_SIZE__+0x341164>
     4fc:	0b3b0221 	bleq	ec0d88 <__ROM_SIZE__+0xe80d88>
     500:	27062139 	smladxcs	r6, r9, r1, r2
                printf("Decoded as %s", decoded);
     504:	01193c19 	tsteq	r9, r9, lsl ip
     508:	0e000013 	mcreq	0, 0, r0, cr0, cr3, {0}
     50c:	00000018 	andeq	r0, r0, r8, lsl r0
            printf("Didn't know how to handle %s\n", argv[1]);
     510:	0300050f 	movweq	r0, #1295	@ 0x50f
     514:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
     518:	3907213b 	stmdbcc	r7, {r0, r1, r3, r4, r5, r8, sp}
     51c:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
     520:	1742b717 	smlaldne	fp, r2, r7, r7
     524:	11100000 	tstne	r0, r0
     528:	130e2501 	movwne	r2, #58625	@ 0xe501
     52c:	1b0e030b 	blne	381160 <__ROM_SIZE__+0x341160>
     530:	1201110e 	andne	r1, r1, #-2147483645	@ 0x80000003
     534:	00171006 	andseq	r1, r7, r6
     538:	00241100 	eoreq	r1, r4, r0, lsl #2
     53c:	0b3e0b0b 	bleq	f83170 <__ROM_SIZE__+0xf43170>
     540:	00000803 	andeq	r0, r0, r3, lsl #16
     544:	03011312 	movweq	r1, #4882	@ 0x1312
     548:	3a050b0e 	bcc	143188 <__ROM_SIZE__+0x103188>
     54c:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     550:	0013010b 	andseq	r0, r3, fp, lsl #2
     554:	000d1300 	andeq	r1, sp, r0, lsl #6
void uputc(char c) {
     558:	0b3a0803 	bleq	e8256c <__ROM_SIZE__+0xe4256c>
  while ((UARTFR >> 5) & 1)
     55c:	0b390b3b 	bleq	e43250 <__ROM_SIZE__+0xe03250>
     560:	0b381349 	bleq	e0528c <__ROM_SIZE__+0xdc528c>
  UART_DR = c;
     564:	34140000 	ldrcc	r0, [r4], #-0
  if (c == '\n')
     568:	3a080300 	bcc	201170 <__ROM_SIZE__+0x1c1170>
}
     56c:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    uputc('\r');
     570:	3f13490b 	svccc	0x0013490b
}
     574:	00193c19 	andseq	r3, r9, r9, lsl ip
     578:	00161500 	andseq	r1, r6, r0, lsl #10
  if (!((UARTFR >> 4) & 1)) return UART_DR;
     57c:	0b3a0803 	bleq	e82590 <__ROM_SIZE__+0xe42590>
     580:	0b390b3b 	bleq	e43274 <__ROM_SIZE__+0xe03274>
     584:	00001349 	andeq	r1, r0, r9, asr #6
     588:	27011516 	smladcs	r1, r6, r5, r1
  return -1;
     58c:	01134919 	tsteq	r3, r9, lsl r9
}
     590:	17000013 	smladne	r0, r3, r0, r0
     594:	0b0b0113 	bleq	2c09e8 <__ROM_SIZE__+0x2809e8>
  UARTCTL = 0;
     598:	0b3b0b3a 	bleq	ec3288 <__ROM_SIZE__+0xe83288>
     59c:	13010b39 	movwne	r0, #6969	@ 0x1b39
  UARTIBRD = 8;
     5a0:	34180000 	ldrcc	r0, [r8], #-0
  UARTFBRD = 44;
     5a4:	3a0e0300 	bcc	3811ac <__ROM_SIZE__+0x3411ac>
  UARTCC = 0;
     5a8:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
  UARTLCRH = 0x60;
     5ac:	3f13490b 	svccc	0x0013490b
  UARTCTL = 0x301;
     5b0:	00180219 	andseq	r0, r8, r9, lsl r2
}
     5b4:	012e1900 			@ <UNDEFINED> instruction: 0x012e1900
     5b8:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
void u2putc(char c) {
     5bc:	0b3b0b3a 	bleq	ec32ac <__ROM_SIZE__+0xe832ac>
  while ((UART2FR >> 5) & 1)
     5c0:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
     5c4:	01111349 	tsteq	r1, r9, asr #6
  UART2_DR = c;
     5c8:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
  if (c == '\n')
     5cc:	1301197a 	movwne	r1, #6522	@ 0x197a
}
     5d0:	341a0000 	ldrcc	r0, [sl], #-0
    u2putc('\r');
     5d4:	3a080300 	bcc	2011dc <__ROM_SIZE__+0x1c11dc>
}
     5d8:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     5dc:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
  if (!((UART2FR >> 4) & 1)) return UART2_DR;
     5e0:	1742b717 	smlaldne	fp, r2, r7, r7
     5e4:	481b0000 	ldmdami	fp, {}	@ <UNPREDICTABLE>
     5e8:	7f017d01 	svcvc	0x00017d01
     5ec:	1c000013 	stcne	0, cr0, [r0], {19}
  return -1;
     5f0:	13490101 	movtne	r0, #37121	@ 0x9101
}
     5f4:	01000000 	mrseq	r0, (UNDEF: 0)
     5f8:	18020049 	stmdane	r2, {r0, r3, r6}
  UART2CTL = 0;
     5fc:	0000187e 	andeq	r1, r0, lr, ror r8
     600:	49000502 	stmdbmi	r0, {r1, r8, sl}
  UART2IBRD = 8;
     604:	03000013 	movweq	r0, #19
  UART2FBRD = 44;
     608:	0b0b0024 	bleq	2c06a0 <__ROM_SIZE__+0x2806a0>
  UART2CC = 0;
     60c:	0e030b3e 	vmoveq.16	d3[0], r0
  UART2LCRH = 0x60;
     610:	0f040000 	svceq	0x00040000
  UART2CTL = 0x301;
     614:	04210b00 	strteq	r0, [r1], #-2816	@ 0xfffff500
}
     618:	00001349 	andeq	r1, r0, r9, asr #6
     61c:	03000505 	movweq	r0, #1285	@ 0x505
  RCGCUART |= 3;
     620:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
     624:	0b390b3b 	bleq	e43318 <__ROM_SIZE__+0xe03318>
     628:	17021349 	strne	r1, [r2, -r9, asr #6]
     62c:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
  RCGCGPIO |= 3;
     630:	01480600 	cmpeq	r8, r0, lsl #12
     634:	137f017d 	cmnne	pc, #1073741855	@ 0x4000001f
     638:	00001301 	andeq	r1, r0, r1, lsl #6
  GPIODEN = 0x03;
     63c:	03003407 	movweq	r3, #1031	@ 0x407
     640:	02213a0e 	eoreq	r3, r1, #57344	@ 0xe000
  GPIOAFSEL = 0x03;
     644:	0b390b3b 	bleq	e43338 <__ROM_SIZE__+0xe03338>
  GPIOPCTL |= 0x00000011;
     648:	193f1349 	ldmdbne	pc!, {r0, r3, r6, r8, r9, ip}	@ <UNPREDICTABLE>
     64c:	0000193c 	andeq	r1, r0, ip, lsr r9
     650:	3f012e08 	svccc	0x00012e08
  GPIODEN2 = 0x03;
     654:	3a0e0319 	bcc	3812c0 <__ROM_SIZE__+0x3412c0>
     658:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
  GPIOAFSEL2 = 0x03;
     65c:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
  GPIOPCTL2 |= 0x00000011;
     660:	01193c13 	tsteq	r9, r3, lsl ip
     664:	09000013 	stmdbeq	r0, {r0, r1, r4}
     668:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
}
     66c:	3b02213a 	blcc	88b5c <__ROM_SIZE__+0x48b5c>
     670:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
void platform_init() {
     674:	000b3813 	andeq	r3, fp, r3, lsl r8
    pin_setup();
     678:	00340a00 	eorseq	r0, r4, r0, lsl #20
    uart_init();
     67c:	213a0e03 	teqcs	sl, r3, lsl #28
    uart2_init();
     680:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
    set_read_char(ugetc);
     684:	13490121 	movtne	r0, #37153	@ 0x9121
    set_read_char2(u2getc);
     688:	1802193f 	stmdane	r2, {r0, r1, r2, r3, r4, r5, r8, fp, ip}
     68c:	480b0000 	stmdami	fp, {}	@ <UNPREDICTABLE>
    set_write_char(uputc);
     690:	7f017d01 	svcvc	0x00017d01
    set_write_char2(u2putc);
     694:	0c000013 	stceq	0, cr0, [r0], {19}
     698:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
}
     69c:	0b3b0b3a 	bleq	ec338c <__ROM_SIZE__+0xe8338c>
     6a0:	13490b39 	movtne	r0, #39737	@ 0x9b39
     6a4:	010d0000 	mrseq	r0, (UNDEF: 13)
     6a8:	01134901 	tsteq	r3, r1, lsl #18
int aes_test(int argc, char** argv) {
     6ac:	0e000013 	mcreq	0, 0, r0, cr0, cr3, {0}
    uint8_t text[17] = "0123456789abcdef";
     6b0:	00000018 	andeq	r0, r0, r8, lsl r0
     6b4:	3f012e0f 	svccc	0x00012e0f
     6b8:	3a0e0319 	bcc	381324 <__ROM_SIZE__+0x341324>
     6bc:	0b3b0121 	bleq	ec0b48 <__ROM_SIZE__+0xe80b48>
     6c0:	27052139 	smladxcs	r5, r9, r1, r2
    printf("Plaintext is %s\n", text);
     6c4:	11134919 	tstne	r3, r9, lsl r9
     6c8:	40061201 	andmi	r1, r6, r1, lsl #4
    AES_ECB_encrypt(&ctx, text);
     6cc:	01197a18 	tsteq	r9, r8, lsl sl
     6d0:	10000013 	andne	r0, r0, r3, lsl r0
    len = encode_base64(text, 16, b64text);
     6d4:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
     6d8:	0e030b13 	vmoveq.32	d3[0], r0
     6dc:	01110e1b 	tsteq	r1, fp, lsl lr
    b64text[len] = '\0';
     6e0:	17100612 			@ <UNDEFINED> instruction: 0x17100612
     6e4:	24110000 	ldrcs	r0, [r1], #-0
     6e8:	3e0b0b00 	vmlacc.f64	d0, d11, d0
    printf("Encrypted/encoded is %s\n", b64text);
     6ec:	0008030b 	andeq	r0, r8, fp, lsl #6
     6f0:	00211200 	eoreq	r1, r1, r0, lsl #4
    printf2("FOB_MESG AESB64 %s\n", b64text);
     6f4:	16130000 	ldrne	r0, [r3], -r0
     6f8:	3a080300 	bcc	201300 <__ROM_SIZE__+0x1c1300>
    printf("Test the mesg handler with CAR_MESG AESB64 %s\n", b64text);
     6fc:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     700:	0013490b 	andseq	r4, r3, fp, lsl #18
    len = decode_base64(b64text, len, decoded);
     704:	01151400 	tsteq	r5, r0, lsl #8
     708:	13491927 	movtne	r1, #39207	@ 0x9927
     70c:	00001301 	andeq	r1, r0, r1, lsl #6
    AES_ECB_decrypt(&ctx, decoded);
     710:	49002615 	stmdbmi	r0, {r0, r2, r4, r9, sl, sp}
     714:	16000013 			@ <UNDEFINED> instruction: 0x16000013
    decoded[len] = '\0';
     718:	0b0b0113 	bleq	2c0b6c <__ROM_SIZE__+0x280b6c>
     71c:	0b3b0b3a 	bleq	ec340c <__ROM_SIZE__+0xe8340c>
     720:	13010b39 	movwne	r0, #6969	@ 0x1b39
    printf("After encrypting->encoding->decoding->decrypting we recover %s\n", decoded);
     724:	34170000 	ldrcc	r0, [r7], #-0
     728:	3a0e0300 	bcc	381330 <__ROM_SIZE__+0x341330>
}
     72c:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     730:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
     734:	18000018 	stmdane	r0, {r3, r4}
     738:	13490021 	movtne	r0, #36897	@ 0x9021
     73c:	00000b2f 	andeq	r0, r0, pc, lsr #22
     740:	3f012e19 	svccc	0x00012e19
     744:	3a0e0319 	bcc	3813b0 <__ROM_SIZE__+0x3413b0>
     748:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     74c:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
int pair1(int argc, char** argv) {
     750:	12011113 	andne	r1, r1, #-1073741820	@ 0xc0000004
    printf("Sending a pair request.\n");
     754:	7a184006 	bvc	610774 <__ROM_SIZE__+0x5d0774>
    printf2("FOB_MESG PAIR %d %d\n", fob_ID, pairing_PIN);
     758:	00000019 	andeq	r0, r0, r9, lsl r0
     75c:	02004901 	andeq	r4, r0, #16384	@ 0x4000
     760:	00187e18 	andseq	r7, r8, r8, lsl lr
     764:	00240200 	eoreq	r0, r4, r0, lsl #4
}
     768:	0b3e0b0b 	bleq	f8339c <__ROM_SIZE__+0xf4339c>
     76c:	00000e03 	andeq	r0, r0, r3, lsl #28
     770:	49000503 	stmdbmi	r0, {r0, r1, r8, sl}
     774:	04000013 	streq	r0, [r0], #-19	@ 0xffffffed
     778:	210b000f 	tstcs	fp, pc
int pairchall(int argc, char** argv) {
     77c:	00134904 	andseq	r4, r3, r4, lsl #18
    printf("Sending a pair request with challenge/response.\n");
     780:	01480500 	cmpeq	r8, r0, lsl #10
    printf2("FOB_MESG PAIRCR %d %d\n", fob_ID, pairing_PIN);
     784:	137f017d 	cmnne	pc, #1073741855	@ 0x4000001f
     788:	2e060000 	cdpcs	0, 0, cr0, cr6, cr0, {0}
     78c:	03193f01 	tsteq	r9, #1, 30
     790:	3b0b3a0e 	blcc	2cefd0 <__ROM_SIZE__+0x28efd0>
}
     794:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
     798:	3c134919 			@ <UNDEFINED> instruction: 0x3c134919
     79c:	00130119 	andseq	r0, r3, r9, lsl r1
     7a0:	00050700 	andeq	r0, r5, r0, lsl #14
     7a4:	213a0e03 	teqcs	sl, r3, lsl #28
int pairecdh(int argc, char** argv) {
     7a8:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
    printf("Starting EC Diffie-Hellman key exchange.\n");
     7ac:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
     7b0:	1742b717 	smlaldne	fp, r2, r7, r7
    decode_base64(ECDH_privkey_b64, 32, ECDH_privkey);
     7b4:	16080000 	strne	r0, [r8], -r0
     7b8:	3a0e0300 	bcc	3813c0 <__ROM_SIZE__+0x3413c0>
     7bc:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    ecdh_generate_keys(ECDH_pubkey, ECDH_privkey);
     7c0:	0013490b 	andseq	r4, r3, fp, lsl #18
     7c4:	000d0900 	andeq	r0, sp, r0, lsl #18
    encode_base64(ECDH_pubkey, ECC_PUB_KEY_SIZE, pubkey_b64);
     7c8:	213a0e03 	teqcs	sl, r3, lsl #28
     7cc:	390b3b04 	stmdbcc	fp, {r2, r8, r9, fp, ip, sp}
     7d0:	3813490b 	ldmdacc	r3, {r0, r1, r3, r8, fp, lr}
    pubkey_b64[64] = '\0';
     7d4:	0a00000b 	beq	808 <pairecdh+0x60>
    printf2("FOB_MESG PAIRECDH %d %d %s\n", fob_ID, pairing_PIN, pubkey_b64);
     7d8:	0111010b 	tsteq	r1, fp, lsl #2
     7dc:	13010612 	movwne	r0, #5650	@ 0x1612
     7e0:	480b0000 	stmdami	fp, {}	@ <UNPREDICTABLE>
     7e4:	7f017d01 	svcvc	0x00017d01
}
     7e8:	00130113 	andseq	r0, r3, r3, lsl r1
     7ec:	00340c00 	eorseq	r0, r4, r0, lsl #24
     7f0:	213a0e03 	teqcs	sl, r3, lsl #28
     7f4:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
     7f8:	13490121 	movtne	r0, #37153	@ 0x9121
     7fc:	1802193f 	stmdane	r2, {r0, r1, r2, r3, r4, r5, r8, fp, ip}
     800:	2e0d0000 	cdpcs	0, 0, cr0, cr13, cr0, {0}
     804:	03193f01 	tsteq	r9, #1, 30
     808:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
int encode64(int argc, char** argv) {
     80c:	21390b3b 	teqcs	r9, fp, lsr fp
    if (argc > 1) {
     810:	49192705 	ldmdbmi	r9, {r0, r2, r8, r9, sl, sp}
     814:	12011113 	andne	r1, r1, #-1073741820	@ 0xc0000004
        len = strlen(argv[1]);
     818:	7a184006 	bvc	610838 <__ROM_SIZE__+0x5d0838>
     81c:	00130119 	andseq	r0, r3, r9, lsl r1
        if (len < MAXARRAYLEN) {
     820:	00340e00 	eorseq	r0, r4, r0, lsl #28
            len = encode_base64((uint8_t *) argv[1], len, encoded);
     824:	213a0803 	teqcs	sl, r3, lsl #16
     828:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
            printf("Encoded %s as %s with %d characters\n", argv[1], encoded, len);
     82c:	13490d21 	movtne	r0, #40225	@ 0x9d21
     830:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
     834:	0f000017 	svceq	0x00000017
            printf("String exceeds max length of %d characters", MAXARRAYLEN);
     838:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     83c:	3b01213a 	blcc	48d2c <__ROM_SIZE__+0x8d2c>
     840:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
        printf("Usage is 'encode64 string'\n");
     844:	00180213 	andseq	r0, r8, r3, lsl r2
}
     848:	00481000 	subeq	r1, r8, r0
     84c:	137f017d 	cmnne	pc, #1073741855	@ 0x4000001f
     850:	21110000 	tstcs	r1, r0
     854:	2f134900 	svccs	0x00134900
     858:	1200000b 	andne	r0, r0, #11
int decode64(int argc, char** argv) {
     85c:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
    if (argc > 1) {
     860:	0e030b13 	vmoveq.32	d3[0], r0
     864:	01110e1b 	tsteq	r1, fp, lsl lr
        int len = strlen(argv[1]);
     868:	17100612 			@ <UNDEFINED> instruction: 0x17100612
     86c:	24130000 	ldrcs	r0, [r3], #-0
        if (len < MAXBASE64LEN) {
     870:	3e0b0b00 	vmlacc.f64	d0, d11, d0
                len = decode_base64((uint8_t *) argv[1], len, plaintext);
     874:	0008030b 	andeq	r0, r8, fp, lsl #6
     878:	00161400 	andseq	r1, r6, r0, lsl #8
                plaintext[len] = '\0';
     87c:	0b3a0803 	bleq	e82890 <__ROM_SIZE__+0xe42890>
     880:	0b390b3b 	bleq	e43574 <__ROM_SIZE__+0xe03574>
     884:	00001349 	andeq	r1, r0, r9, asr #6
                printf("Decoded %s as: %s\n", argv[1], plaintext);
     888:	27011515 	smladcs	r1, r5, r5, r1
     88c:	01134919 	tsteq	r3, r9, lsl r9
     890:	16000013 			@ <UNDEFINED> instruction: 0x16000013
            printf("String exceeds max base64 string length of %d characters", MAXBASE64LEN);
     894:	13490026 	movtne	r0, #36902	@ 0x9026
     898:	13170000 	tstne	r7, #0
     89c:	3a0b0b01 	bcc	2c34a8 <__ROM_SIZE__+0x2834a8>
        printf("Usage is 'decode64 string'\n");
     8a0:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
}
     8a4:	0013010b 	andseq	r0, r3, fp, lsl #2
     8a8:	00181800 	andseq	r1, r8, r0, lsl #16
     8ac:	01190000 	tsteq	r9, r0
     8b0:	01134901 	tsteq	r3, r1, lsl #18
     8b4:	1a000013 	bne	908 <ecdh_test+0x50>
int ecdh_test(int argc, char** argv) {
     8b8:	13490101 	movtne	r0, #37121	@ 0x9101
    uint8_t b64privkey2[32] = "wP/uwP/uwP/uwP/uwP/uwP/uwP/uwP/u";
     8bc:	01000000 	mrseq	r0, (UNDEF: 0)
     8c0:	18020049 	stmdane	r2, {r0, r3, r6}
     8c4:	0000187e 	andeq	r1, r0, lr, ror r8
     8c8:	49000502 	stmdbmi	r0, {r1, r8, sl}
     8cc:	03000013 	movweq	r0, #19
    printf("Testing the ecdh key exchange\n");
     8d0:	017d0148 	cmneq	sp, r8, asr #2
     8d4:	1301137f 	movwne	r1, #4991	@ 0x137f
    decode_base64(ECDH_privkey_b64, 32, ECDH_privkey);
     8d8:	24040000 	strcs	r0, [r4], #-0
     8dc:	3e0b0b00 	vmlacc.f64	d0, d11, d0
     8e0:	000e030b 	andeq	r0, lr, fp, lsl #6
    decode_base64(b64privkey2, 32, privkey2);
     8e4:	000f0500 	andeq	r0, pc, r0, lsl #10
     8e8:	4904210b 	stmdbmi	r4, {r0, r1, r3, r8, sp}
    ecdh_generate_keys(ECDH_pubkey, ECDH_privkey);
     8ec:	06000013 			@ <UNDEFINED> instruction: 0x06000013
     8f0:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
     8f4:	0b3b0b3a 	bleq	ec35e4 <__ROM_SIZE__+0xe835e4>
    ecdh_generate_keys(pubkey2, privkey2);
     8f8:	13490b39 	movtne	r0, #39737	@ 0x9b39
     8fc:	00000b38 	andeq	r0, r0, r8, lsr fp
    ecdh_shared_secret(ECDH_privkey, pubkey2, ECDH_shared);
     900:	49010107 	stmdbmi	r1, {r0, r1, r2, r8}
     904:	00130113 	andseq	r0, r3, r3, lsl r1
     908:	00210800 	eoreq	r0, r1, r0, lsl #16
    ecdh_shared_secret(privkey2, ECDH_pubkey, sharedsecret2);
     90c:	0b2f1349 	bleq	bc5638 <__ROM_SIZE__+0xb85638>
     910:	34090000 	strcc	r0, [r9], #-0
    sha256_init(&shactx);
     914:	3a0e0300 	bcc	38151c <__ROM_SIZE__+0x34151c>
     918:	0b3b0121 	bleq	ec0da4 <__ROM_SIZE__+0xe80da4>
	sha256_update(&shactx, ECDH_shared, ECC_PUB_KEY_SIZE);
     91c:	13490b39 	movtne	r0, #39737	@ 0x9b39
     920:	00001802 	andeq	r1, r0, r2, lsl #16
	sha256_final(&shactx, ECDH_AESkey);
     924:	0300160a 	movweq	r1, #1546	@ 0x60a
     928:	3b0b3a0e 	blcc	2cf168 <__ROM_SIZE__+0x28f168>
     92c:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
    len = encode_base64(ECDH_AESkey, AES_KEYLEN, b64test);
     930:	0b000013 	bleq	984 <ecdh_test+0xcc>
     934:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    b64test[len] = '\0';
     938:	3b06213a 	blcc	188e28 <__ROM_SIZE__+0x148e28>
     93c:	1021390b 	eorne	r3, r1, fp, lsl #18
     940:	193f1349 	ldmdbne	pc!, {r0, r3, r6, r8, r9, ip}	@ <UNPREDICTABLE>
     944:	0000193c 	andeq	r1, r0, ip, lsr r9
    printf("First shared key is %s\n", b64test);
     948:	3f012e0c 	svccc	0x00012e0c
     94c:	3a0e0319 	bcc	3815b8 <__ROM_SIZE__+0x3415b8>
    sha256_init(&shactx);
     950:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    sha256_update(&shactx, sharedsecret2, ECC_PUB_KEY_SIZE);
     954:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
     958:	01193c13 	tsteq	r9, r3, lsl ip
     95c:	0d000013 	stceq	0, cr0, [r0, #-76]	@ 0xffffffb4
	sha256_final(&shactx, keytest);
     960:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
     964:	0b3a0e03 	bleq	e84178 <__ROM_SIZE__+0xe44178>
    len = encode_base64(keytest, AES_KEYLEN, b64test);
     968:	21390b3b 	teqcs	r9, fp, lsr fp
     96c:	3c192706 	ldccc	7, cr2, [r9], {6}
    b64test[len] = '\0';
     970:	00130119 	andseq	r0, r3, r9, lsl r1
     974:	00260e00 	eoreq	r0, r6, r0, lsl #28
     978:	00001349 	andeq	r1, r0, r9, asr #6
    printf("Should be same as %s\n", b64test);
     97c:	0b01130f 	bleq	455c0 <__ROM_SIZE__+0x55c0>
     980:	3b0b3a0b 	blcc	2cf1b4 <__ROM_SIZE__+0x28f1b4>
    printf("Switching fob AES key to new value. Try AES tests now.\n");
     984:	0921390b 	stmdbeq	r1!, {r0, r1, r3, r8, fp, ip, sp}
     988:	00001301 	andeq	r1, r0, r1, lsl #6
    AES_init_ctx(&ctx, ECDH_AESkey);
     98c:	03000510 	movweq	r0, #1296	@ 0x510
     990:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
}
     994:	390c213b 	stmdbcc	ip, {r0, r1, r3, r4, r5, r8, sp}
     998:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
     99c:	1742b717 	smlaldne	fp, r2, r7, r7
     9a0:	11110000 	tstne	r1, r0
     9a4:	130e2501 	movwne	r2, #58625	@ 0xe501
     9a8:	1b0e030b 	blne	3815dc <__ROM_SIZE__+0x3415dc>
     9ac:	1201110e 	andne	r1, r1, #-2147483645	@ 0x80000003
     9b0:	00171006 	andseq	r1, r7, r6
     9b4:	00241200 	eoreq	r1, r4, r0, lsl #4
     9b8:	0b3e0b0b 	bleq	f835ec <__ROM_SIZE__+0xf435ec>
     9bc:	00000803 	andeq	r0, r0, r3, lsl #16
     9c0:	03011313 	movweq	r1, #4883	@ 0x1313
int send_ping(int argc, char** argv) {
     9c4:	3a050b0e 	bcc	143604 <__ROM_SIZE__+0x103604>
    printf("Pinging the car.\n");
     9c8:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    printf2("FOB_MESG PING\n");
     9cc:	0013010b 	andseq	r0, r3, fp, lsl #2
     9d0:	000d1400 	andeq	r1, sp, r0, lsl #8
}
     9d4:	0b3a0803 	bleq	e829e8 <__ROM_SIZE__+0xe429e8>
     9d8:	0b390b3b 	bleq	e436cc <__ROM_SIZE__+0xe036cc>
     9dc:	0b381349 	bleq	e05708 <__ROM_SIZE__+0xdc5708>
int sha256_test(int argc, char** argv) {
     9e0:	34150000 	ldrcc	r0, [r5], #-0
    printf("Starting sha256 test\n");
     9e4:	3a080300 	bcc	2015ec <__ROM_SIZE__+0x1c15ec>
     9e8:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    BYTE text1[] = {"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"};
     9ec:	3f13490b 	svccc	0x0013490b
     9f0:	00193c19 	andseq	r3, r9, r9, lsl ip
     9f4:	00211600 	eoreq	r1, r1, r0, lsl #12
     9f8:	16170000 	ldrne	r0, [r7], -r0
     9fc:	3a080300 	bcc	201604 <__ROM_SIZE__+0x1c1604>
     a00:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     a04:	0013490b 	andseq	r4, r3, fp, lsl #18
     a08:	01151800 	tsteq	r5, r0, lsl #16
     a0c:	13491927 	movtne	r1, #39207	@ 0x9927
    BYTE hash1[SHA256_BLOCK_SIZE] = {0x24,0x8d,0x6a,0x61,0xd2,0x06,0x38,0xb8,0xe5,0xc0,0x26,0x93,0x0c,0x3e,0x60,0x39,
     a10:	00001301 	andeq	r1, r0, r1, lsl #6
     a14:	03003419 	movweq	r3, #1049	@ 0x419
     a18:	3b0b3a0e 	blcc	2cf258 <__ROM_SIZE__+0x28f258>
     a1c:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
    sha256_init(&shactx);
     a20:	02193f13 	andseq	r3, r9, #19, 30	@ 0x4c
	sha256_update(&shactx, text1, strlen((char *)text1));
     a24:	1a000018 	bne	a8c <initial_setup+0x8>
     a28:	00000018 	andeq	r0, r0, r8, lsl r0
     a2c:	3f012e1b 	svccc	0x00012e1b
     a30:	3a0e0319 	bcc	38169c <__ROM_SIZE__+0x34169c>
	sha256_final(&shactx, buf);
     a34:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     a38:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
    len = encode_base64(hash1, SHA256_BLOCK_SIZE, b64_hash1);
     a3c:	12011113 	andne	r1, r1, #-1073741820	@ 0xc0000004
     a40:	7a184006 	bvc	610a60 <__ROM_SIZE__+0x5d0a60>
     a44:	00130119 	andseq	r0, r3, r9, lsl r1
    b64_hash1[len] = '\0';
     a48:	00341c00 	eorseq	r1, r4, r0, lsl #24
    len = encode_base64(buf, SHA256_BLOCK_SIZE, b64_buf);
     a4c:	0b3a0803 	bleq	e82a60 <__ROM_SIZE__+0xe42a60>
     a50:	0b390b3b 	bleq	e43744 <__ROM_SIZE__+0xe03744>
     a54:	17021349 	strne	r1, [r2, -r9, asr #6]
    b64_buf[len] = '\0';
     a58:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
    printf("Base64 of SHA-256 test is %s\n", b64_buf);
     a5c:	01481d00 	cmpeq	r8, r0, lsl #26
     a60:	137f017d 	cmnne	pc, #1073741855	@ 0x4000001f
    printf("Should be %s\n", b64_hash1);
     a64:	011e0000 	tsteq	lr, r0
     a68:	00134901 	andseq	r4, r3, r1, lsl #18
}
     a6c:	24010000 	strcs	r0, [r1], #-0
     a70:	3e0b0b00 	vmlacc.f64	d0, d11, d0
     a74:	000e030b 	andeq	r0, lr, fp, lsl #6
     a78:	000f0200 	andeq	r0, pc, r0, lsl #4
     a7c:	4904210b 	stmdbmi	r4, {r0, r1, r3, r8, sp}
     a80:	03000013 	movweq	r0, #19
void __attribute__((optimize("O0"), weak)) initial_setup(void) {
     a84:	13490005 	movtne	r0, #36869	@ 0x9005
     a88:	0d040000 	stceq	0, cr0, [r4, #-0]
  char *src = &_etext, *dst = &_data;
     a8c:	3a0e0300 	bcc	381694 <__ROM_SIZE__+0x341694>
     a90:	0b3b0221 	bleq	ec131c <__ROM_SIZE__+0xe8131c>
  if (dst != src)
     a94:	13490b39 	movtne	r0, #39737	@ 0x9b39
     a98:	00000b38 	andeq	r0, r0, r8, lsr fp
    while (dst < &_edata) *(dst++) = *(src++);
     a9c:	3f012e05 	svccc	0x00012e05
     aa0:	3a0e0319 	bcc	38170c <__ROM_SIZE__+0x34170c>
     aa4:	0b3b0321 	bleq	ec1730 <__ROM_SIZE__+0xe81730>
     aa8:	27052139 	smladxcs	r5, r9, r1, r2
     aac:	3c134919 			@ <UNDEFINED> instruction: 0x3c134919
     ab0:	00130119 	andseq	r0, r3, r9, lsl r1
  for (dst = &_bss; dst < &_ebss; dst++) *dst = 0;
     ab4:	00180600 	andseq	r0, r8, r0, lsl #12
     ab8:	05070000 	streq	r0, [r7, #-0]
     abc:	3a0e0300 	bcc	3816c4 <__ROM_SIZE__+0x3416c4>
     ac0:	213b0121 	teqcs	fp, r1, lsr #2
     ac4:	490b3905 	stmdbmi	fp, {r0, r2, r8, fp, ip, sp}
     ac8:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
     acc:	00001742 	andeq	r1, r0, r2, asr #14
  platform_init();
     ad0:	02004908 	andeq	r4, r0, #8, 18	@ 0x20000
}
     ad4:	00187e18 	andseq	r7, r8, r8, lsl lr
     ad8:	01110900 	tsteq	r1, r0, lsl #18
     adc:	0b130e25 	bleq	4c4378 <__ROM_SIZE__+0x484378>
     ae0:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
     ae4:	06120111 			@ <UNDEFINED> instruction: 0x06120111
     ae8:	00001710 	andeq	r1, r0, r0, lsl r7
     aec:	0b00240a 	bleq	9b1c <__RAM_SIZE__+0x1b1c>
static void delete(void) {
     af0:	030b3e0b 	movweq	r3, #48651	@ 0xbe0b
  __write_char__(BACK_SPACE);
     af4:	0b000008 	bleq	b1c <clear_prompt+0x10>
     af8:	08030016 	stmdaeq	r3, {r1, r2, r4}
  __write_char__(SPACE);
     afc:	0b3b0b3a 	bleq	ec37ec <__ROM_SIZE__+0xe837ec>
  __write_char__(BACK_SPACE);
     b00:	13490b39 	movtne	r0, #39737	@ 0x9b39
     b04:	150c0000 	strne	r0, [ip, #-0]
}
     b08:	49192701 	ldmdbmi	r9, {r0, r8, r9, sl, sp}
static void clear_prompt(int char_count) {
     b0c:	00130113 	andseq	r0, r3, r3, lsl r1
  while (char_count) {
     b10:	00260d00 	eoreq	r0, r6, r0, lsl #26
    delete ();
     b14:	00001349 	andeq	r1, r0, r9, asr #6
  while (char_count) {
     b18:	0b01130e 	bleq	45758 <__ROM_SIZE__+0x5758>
}
     b1c:	3b0b3a0b 	blcc	2cf350 <__ROM_SIZE__+0x28f350>
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
     b20:	010b390b 	tsteq	fp, fp, lsl #18
    auto_load[i].command(0, NULL);
     b24:	0f000013 	svceq	0x00000013
     b28:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
     b2c:	0b3b0b3a 	bleq	ec381c <__ROM_SIZE__+0xe8381c>
     b30:	13490b39 	movtne	r0, #39737	@ 0x9b39
     b34:	34100000 	ldrcc	r0, [r0], #-0
     b38:	3a0e0300 	bcc	381740 <__ROM_SIZE__+0x341740>
     b3c:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
}
     b40:	3f13490b 	svccc	0x0013490b
static int show_history(int argc, char **argv) {
     b44:	00180219 	andseq	r0, r8, r9, lsl r2
  uint32_t end_index = total_num_commands-1;
     b48:	012e1100 			@ <UNDEFINED> instruction: 0x012e1100
  if (total_num_commands > NUM_HISTORY_ENTRIES) {
     b4c:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
     b50:	0b3b0b3a 	bleq	ec3840 <__ROM_SIZE__+0xe83840>
    beg_index = total_num_commands - NUM_HISTORY_ENTRIES;
     b54:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
     b58:	01111349 	tsteq	r1, r9, asr #6
  uint32_t beg_index = 0;
     b5c:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
    printf("%s\n", cmd_history[index % NUM_HISTORY_ENTRIES]);
     b60:	0000197a 	andeq	r1, r0, sl, ror r9
     b64:	7d014812 	stcvc	8, cr4, [r1, #-72]	@ 0xffffffb8
     b68:	01137f01 	tsteq	r3, r1, lsl #30
     b6c:	13000013 	movwne	r0, #19
  for (uint32_t index = beg_index; index <= end_index; ++index) {
     b70:	017d0148 	cmneq	sp, r8, asr #2
}
     b74:	0000137f 	andeq	r1, r0, pc, ror r3
     b78:	00490100 	subeq	r0, r9, r0, lsl #2
     b7c:	187e1802 	ldmdane	lr!, {r1, fp, ip}^
     b80:	05020000 	streq	r0, [r2, #-0]
int cmd_exec_status(int argc, char **argv) {
     b84:	00134900 	andseq	r4, r3, r0, lsl #18
  printf("%d\n", __cmd_exec_status);
     b88:	00240300 	eoreq	r0, r4, r0, lsl #6
     b8c:	0b3e0b0b 	bleq	f837c0 <__ROM_SIZE__+0xf437c0>
     b90:	00000e03 	andeq	r0, r0, r3, lsl #28
}
     b94:	0b000f04 	bleq	47ac <base_order+0xf2c>
     b98:	13490421 	movtne	r0, #37921	@ 0x9421
     b9c:	48050000 	stmdami	r5, {}	@ <UNPREDICTABLE>
static int build_info(int argc, char **argv) {
     ba0:	7f017d01 	svcvc	0x00017d01
  printf("Build: [" SHELL_VERSION ":" USER_REPO_VERSION "] - [" BUILD_USER
     ba4:	00130113 	andseq	r0, r3, r3, lsl r1
}
     ba8:	000d0600 	andeq	r0, sp, r0, lsl #12
     bac:	0b3a0e03 	bleq	e843c0 <__ROM_SIZE__+0xe443c0>
static void execute(int argc, char **argv) {
     bb0:	0b390b3b 	bleq	e438a4 <__ROM_SIZE__+0xe038a4>
     bb4:	0b381349 	bleq	e058e0 <__ROM_SIZE__+0xdc58e0>
  for (int i = 0; table[i].command_name != NULL; i++) {
     bb8:	16070000 	strne	r0, [r7], -r0
     bbc:	3a0e0300 	bcc	3817c4 <__ROM_SIZE__+0x3417c4>
     bc0:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     bc4:	0013490b 	andseq	r4, r3, fp, lsl #18
     bc8:	00210800 	eoreq	r0, r1, r0, lsl #16
    if (strcmp(argv[0], table[i].command_name) == 0) {
     bcc:	0b2f1349 	bleq	bc58f8 <__ROM_SIZE__+0xb858f8>
     bd0:	34090000 	strcc	r0, [r9], #-0
      __cmd_exec_status = table[i].command(argc, &argv[0]);
     bd4:	3a0e0300 	bcc	3817dc <__ROM_SIZE__+0x3417dc>
     bd8:	0b3b0121 	bleq	ec1064 <__ROM_SIZE__+0xe81064>
     bdc:	13490b39 	movtne	r0, #39737	@ 0x9b39
     be0:	00001802 	andeq	r1, r0, r2, lsl #16
     be4:	4901010a 	stmdbmi	r1, {r1, r3, r8}
    printf("\"%s\": command not found. Use \"help\" to list all command.\n",
     be8:	00130113 	andseq	r0, r3, r3, lsl r1
     bec:	012e0b00 			@ <UNDEFINED> instruction: 0x012e0b00
    __cmd_exec_status = -1;
     bf0:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
     bf4:	0b3b0b3a 	bleq	ec38e4 <__ROM_SIZE__+0xe838e4>
     bf8:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
}
     bfc:	193c1349 	ldmdbne	ip!, {r0, r3, r6, r8, r9, ip}
     c00:	00001301 	andeq	r1, r0, r1, lsl #6
     c04:	3f012e0c 	svccc	0x00012e0c
     c08:	3a0e0319 	bcc	381874 <__ROM_SIZE__+0x341874>
int help(int argc, char **argv) {
     c0c:	0b3b0421 	bleq	ec1c98 <__ROM_SIZE__+0xe81c98>
  if (argc > 1 && (strcmp(argv[1], "-l")==0)) {
     c10:	27062139 	smladxcs	r6, r9, r1, r2
     c14:	01193c19 	tsteq	r9, r9, lsl ip
     c18:	0d000013 	stceq	0, cr0, [r0, #-76]	@ 0xffffffb4
     c1c:	13490026 	movtne	r0, #36902	@ 0x9026
    printf("use: help -l for list only.\n\n");
     c20:	130e0000 	movwne	r0, #57344	@ 0xe000
  bool verbose = true;
     c24:	3a0b0b01 	bcc	2c3830 <__ROM_SIZE__+0x283830>
    verbose = false;
     c28:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    printf("\n");
     c2c:	13010921 	movwne	r0, #6433	@ 0x1921
    i++;
     c30:	050f0000 	streq	r0, [pc, #-0]	@ c38 <help+0x2c>
  while (table[i].command_name != NULL) {
     c34:	3a0e0300 	bcc	38183c <__ROM_SIZE__+0x34183c>
     c38:	213b0121 	teqcs	fp, r1, lsr #2
     c3c:	490b3904 	stmdbmi	fp, {r2, r8, fp, ip, sp}
    printf(table[i].command_name);
     c40:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
    if (verbose) {
     c44:	00001742 	andeq	r1, r0, r2, asr #14
      printf("\n\t");
     c48:	25011110 	strcs	r1, [r1, #-272]	@ 0xfffffef0
      printf(table[i].command_help);
     c4c:	030b130e 	movweq	r1, #45838	@ 0xb30e
     c50:	110e1b0e 	tstne	lr, lr, lsl #22
     c54:	10061201 	andne	r1, r6, r1, lsl #4
    verbose = false;
     c58:	11000017 	tstne	r0, r7, lsl r0
}
     c5c:	0b0b0024 	bleq	2c0cf4 <__ROM_SIZE__+0x280cf4>
     c60:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
     c64:	16120000 	ldrne	r0, [r2], -r0
     c68:	3a080300 	bcc	201870 <__ROM_SIZE__+0x1c1870>
     c6c:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     c70:	0013490b 	andseq	r4, r3, fp, lsl #18
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
     c74:	01151300 	tsteq	r5, r0, lsl #6
static void add_command_to_history(const char *cmd_str) {
     c78:	13491927 	movtne	r1, #39207	@ 0x9927
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
     c7c:	00001301 	andeq	r1, r0, r1, lsl #6
     c80:	03003414 	movweq	r3, #1044	@ 0x414
  int index = total_num_commands % NUM_HISTORY_ENTRIES;
     c84:	3b0b3a0e 	blcc	2cf4c4 <__ROM_SIZE__+0x28f4c4>
     c88:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
     c8c:	02193f13 	andseq	r3, r9, #19, 30	@ 0x4c
     c90:	15000018 	strne	r0, [r0, #-24]	@ 0xffffffe8
  memcpy(&cmd_history[index], cmd_str, LINE_BUFF_SIZE);
     c94:	00000018 	andeq	r0, r0, r8, lsl r0
     c98:	3f012e16 	svccc	0x00012e16
     c9c:	3a0e0319 	bcc	381908 <__ROM_SIZE__+0x341908>
     ca0:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
  total_num_commands++;
     ca4:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
  curr_command_ptr = total_num_commands;
     ca8:	12011113 	andne	r1, r1, #-1073741820	@ 0xc0000004
     cac:	7a184006 	bvc	610ccc <__ROM_SIZE__+0x5d0ccc>
     cb0:	00130119 	andseq	r0, r3, r9, lsl r1
     cb4:	00341700 	eorseq	r1, r4, r0, lsl #14
     cb8:	0b3a0803 	bleq	e82ccc <__ROM_SIZE__+0xe42ccc>
static int parse_line(char **argv, char *line_buff, int argument_size) {
     cbc:	0b390b3b 	bleq	e439b0 <__ROM_SIZE__+0xe039b0>
     cc0:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
  int length = strlen(line_buff);
     cc4:	34180000 	ldrcc	r0, [r8], #-0
     cc8:	3a080300 	bcc	2018d0 <__ROM_SIZE__+0x1c18d0>
  int argc = 0;
     ccc:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
         pos++)
     cd0:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
    for (; line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
     cd4:	1742b717 	smlaldne	fp, r2, r7, r7
     cd8:	48190000 	ldmdami	r9, {}	@ <UNPREDICTABLE>
     cdc:	7f017d01 	svcvc	0x00017d01
     ce0:	1a000013 	bne	d34 <prefix_match+0x26>
    if (line_buff[pos] == '\t' || line_buff[pos] == SPACE)
     ce4:	13490101 	movtne	r0, #37121	@ 0x9101
     ce8:	01000000 	mrseq	r0, (UNDEF: 0)
      line_buff[pos] = END_OF_LINE;
     cec:	18020049 	stmdane	r2, {r0, r3, r6}
  while (pos <= length) {
     cf0:	0000187e 	andeq	r1, r0, lr, ror r8
    if (line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
     cf4:	7d014802 	stcvc	8, cr4, [r1, #-8]
     cf8:	01137f01 	tsteq	r3, r1, lsl #30
     cfc:	03000013 	movweq	r0, #19
     d00:	13490005 	movtne	r0, #36869	@ 0x9005
      argv[argc++] = &line_buff[pos];
     d04:	48040000 	stmdami	r4, {}	@ <UNPREDICTABLE>
     d08:	7f017d00 	svcvc	0x00017d00
}
     d0c:	05000013 	streq	r0, [r0, #-19]	@ 0xffffffed
static int prefix_match(char *sub, int len, const char *str) {
     d10:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
     d14:	3b01213a 	blcc	49204 <__ROM_SIZE__+0x9204>
  if (sub == NULL || str == NULL || len <= 0 || len > strlen(str)) {
     d18:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
     d1c:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
     d20:	00001742 	andeq	r1, r0, r2, asr #14
     d24:	7d014806 	stcvc	8, cr4, [r1, #-24]	@ 0xffffffe8
  for (int i = 0; i<len; ++i) {
     d28:	00137f01 	andseq	r7, r3, r1, lsl #30
     d2c:	00240700 	eoreq	r0, r4, r0, lsl #14
    if (sub[i] != str[i]) {
     d30:	0b3e0b0b 	bleq	f83964 <__ROM_SIZE__+0xf43964>
     d34:	00000e03 	andeq	r0, r0, r3, lsl #28
  for (int i = 0; i<len; ++i) {
     d38:	0b000f08 	bleq	4960 <base_order+0x10e0>
}
     d3c:	13490421 	movtne	r0, #37921	@ 0x9421
  return TRUE;
     d40:	34090000 	strcc	r0, [r9], #-0
      return FALSE;
     d44:	3a0e0300 	bcc	38194c <__ROM_SIZE__+0x34194c>
}
     d48:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
static void handle_up_arrow(char *cmd_buff, int *char_count) {
     d4c:	3f13490b 	svccc	0x0013490b
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
     d50:	00193c19 	andseq	r3, r9, r9, lsl ip
     d54:	00340a00 	eorseq	r0, r4, r0, lsl #20
     d58:	213a0e03 	teqcs	sl, r3, lsl #28
     d5c:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
      curr_command_ptr == 0) {
     d60:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
     d64:	1742b717 	smlaldne	fp, r2, r7, r7
    printf("%s", cmd_buff);
     d68:	010b0000 	mrseq	r0, (UNDEF: 11)
     d6c:	01134901 	tsteq	r3, r1, lsl #18
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
     d70:	0c000013 	stceq	0, cr0, [r0], {19}
     d74:	13490021 	movtne	r0, #36897	@ 0x9021
  curr_command_ptr--;
     d78:	00000b2f 	andeq	r0, r0, pc, lsr #22
     d7c:	0300050d 	movweq	r0, #1293	@ 0x50d
     d80:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
     d84:	0b39053b 	bleq	e42278 <__ROM_SIZE__+0xe02278>
     d88:	17021349 	strne	r1, [r2, -r9, asr #6]
     d8c:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
     d90:	00340e00 	eorseq	r0, r4, r0, lsl #28
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
     d94:	213a1347 	teqcs	sl, r7, asr #6
     d98:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
     d9c:	13490921 	movtne	r0, #39201	@ 0x9921
  *char_count = strlen(cmd_buff);
     da0:	00001802 	andeq	r1, r0, r2, lsl #16
     da4:	0300340f 	movweq	r3, #1039	@ 0x40f
  printf("%s", cmd_buff);
     da8:	01213a08 			@ <UNDEFINED> instruction: 0x01213a08
     dac:	0b39053b 	bleq	e422a0 <__ROM_SIZE__+0xe022a0>
     db0:	17021349 	strne	r1, [r2, -r9, asr #6]
     db4:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
     db8:	012e1000 			@ <UNDEFINED> instruction: 0x012e1000
static void handle_down_arrow(char *cmd_buff, int *char_count) {
     dbc:	213a0e03 	teqcs	sl, r3, lsl #28
     dc0:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
     dc4:	19270d21 	stmdbne	r7!, {r0, r5, r8, sl, fp}
     dc8:	06120111 			@ <UNDEFINED> instruction: 0x06120111
  *char_count = 0;
     dcc:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
  if (curr_command_ptr == total_num_commands) return;
     dd0:	00001301 	andeq	r1, r0, r1, lsl #6
     dd4:	3f012e11 	svccc	0x00012e11
     dd8:	3a0e0319 	bcc	381a44 <__ROM_SIZE__+0x341a44>
  curr_command_ptr++;
     ddc:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     de0:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
     de4:	01193c13 	tsteq	r9, r3, lsl ip
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
     de8:	12000013 	andne	r0, r0, #19
     dec:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     df0:	3b01213a 	blcc	492e0 <__ROM_SIZE__+0x92e0>
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
     df4:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
     df8:	02193f13 	andseq	r3, r9, #19, 30	@ 0x4c
     dfc:	13000018 	movwne	r0, #24
     e00:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
  *char_count = strlen(cmd_buff);
     e04:	3b01213a 	blcc	492f4 <__ROM_SIZE__+0x92f4>
     e08:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
  printf("%s", cmd_buff);
     e0c:	00180213 	andseq	r0, r8, r3, lsl r2
     e10:	00341400 	eorseq	r1, r4, r0, lsl #8
}
     e14:	213a0e03 	teqcs	sl, r3, lsl #28
     e18:	39053b01 	stmdbcc	r5, {r0, r8, r9, fp, ip, sp}
void set_read_char(int (*func)(void)) { __read_char__ = func; }
     e1c:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
     e20:	15000018 	strne	r0, [r0, #-24]	@ 0xffffffe8
     e24:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
void set_read_char2(int (*func)(void)) { __read_char2__ = func; }
     e28:	3b01213a 	blcc	49318 <__ROM_SIZE__+0x9318>
     e2c:	39038f21 	stmdbcc	r3, {r0, r5, r8, r9, sl, fp, pc}
     e30:	3f13490b 	svccc	0x0013490b
void set_write_char(void (*func)(char)) { __write_char__ = func; }
     e34:	00193c19 	andseq	r3, r9, r9, lsl ip
     e38:	00161600 	andseq	r1, r6, r0, lsl #12
     e3c:	0b3a0e03 	bleq	e84650 <__ROM_SIZE__+0xe44650>
void set_write_char2(void (*func)(char)) { __write_char2__ = func; }
     e40:	0b390b3b 	bleq	e43b34 <__ROM_SIZE__+0xe03b34>
     e44:	00001349 	andeq	r1, r0, r9, asr #6
     e48:	03000d17 	movweq	r0, #3351	@ 0xd17
}
     e4c:	3b0b3a0e 	blcc	2cf68c <__ROM_SIZE__+0x28f68c>
}
     e50:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
  if (cmd_buff == NULL || char_count <= 0) {
     e54:	000b3813 	andeq	r3, fp, r3, lsl r8
static void handle_tab(char *cmd_buff, int *char_count) {
     e58:	012e1800 			@ <UNDEFINED> instruction: 0x012e1800
     e5c:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
  int last_match = -1;
     e60:	3b01213a 	blcc	49350 <__ROM_SIZE__+0x9350>
  int match_count = 0;
     e64:	05213905 	streq	r3, [r1, #-2309]!	@ 0xfffff6fb
  int i = 0;
     e68:	13491927 	movtne	r1, #39207	@ 0x9927
    i++;
     e6c:	06120111 			@ <UNDEFINED> instruction: 0x06120111
  while (table[i].command_name != NULL) { //loop over all commands
     e70:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
     e74:	00001301 	andeq	r1, r0, r1, lsl #6
     e78:	03003419 	movweq	r3, #1049	@ 0x419
    if (prefix_match(cmd_buff, *char_count, table[i].command_name)) {
     e7c:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
     e80:	0b39053b 	bleq	e42374 <__ROM_SIZE__+0xe02374>
     e84:	17021349 	strne	r1, [r2, -r9, asr #6]
      match_count++;
     e88:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
      printf("\n%s", table[i].command_name);
     e8c:	01481a00 	cmpeq	r8, r0, lsl #20
     e90:	1301017d 	movwne	r0, #4477	@ 0x117d
      last_match = i;
     e94:	341b0000 	ldrcc	r0, [fp], #-0
  if (match_count == 1) {
     e98:	3a080300 	bcc	201aa0 <__ROM_SIZE__+0x1c1aa0>
     e9c:	0b3b0121 	bleq	ec1328 <__ROM_SIZE__+0xe81328>
  if (match_count) {
     ea0:	13490b39 	movtne	r0, #39737	@ 0x9b39
}
     ea4:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
    memcpy(cmd_buff, table[last_match].command_name, LINE_BUFF_SIZE);
     ea8:	1c000017 	stcne	0, cr0, [r0], {23}
     eac:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
     eb0:	3b01213a 	blcc	493a0 <__ROM_SIZE__+0x93a0>
     eb4:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
    *char_count = strlen(cmd_buff);
     eb8:	00180213 	andseq	r0, r8, r3, lsl r2
     ebc:	00261d00 	eoreq	r1, r6, r0, lsl #26
     ec0:	00001349 	andeq	r1, r0, r9, asr #6
    printf("\n");
     ec4:	4900351e 	stmdbmi	r0, {r1, r2, r3, r4, r8, sl, ip, sp}
     ec8:	1f000013 	svcne	0x00000013
    prepend_prompt();
     ecc:	13470034 	movtne	r0, #28724	@ 0x7034
    printf(PROMPT);
     ed0:	3b01213a 	blcc	493c0 <__ROM_SIZE__+0x93c0>
     ed4:	020b390b 	andeq	r3, fp, #180224	@ 0x2c000
    printf("%s", cmd_buff);
     ed8:	20000018 	andcs	r0, r0, r8, lsl r0
     edc:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     ee0:	3b01213a 	blcc	493d0 <__ROM_SIZE__+0x93d0>
     ee4:	01213905 			@ <UNDEFINED> instruction: 0x01213905
     ee8:	193f1349 	ldmdbne	pc!, {r0, r3, r6, r8, r9, ip}	@ <UNPREDICTABLE>
     eec:	00001802 	andeq	r1, r0, r2, lsl #16
     ef0:	11010b21 	tstne	r1, r1, lsr #22
__attribute__((weak)) int active_prompt() { return TRUE; }
     ef4:	00061201 	andeq	r1, r6, r1, lsl #4
static void shell(void) {
     ef8:	01482200 	mrseq	r2, (UNDEF: 104)
  int count = 0;
     efc:	0000017d 	andeq	r0, r0, sp, ror r1
  for (int i = 0; i < LINE_BUFF_SIZE; i++) line_buff[i] = 0;
     f00:	11010b23 	tstne	r1, r3, lsr #22
     f04:	01061201 	tsteq	r6, r1, lsl #4
     f08:	24000013 	strcs	r0, [r0], #-19	@ 0xffffffed
     f0c:	0e03012e 	adfeqsp	f0, f3, #0.5
     f10:	3b01213a 	blcc	49400 <__ROM_SIZE__+0x9400>
  for (int i = 0; i < MAX_ARG_COUNT; i++) argv[i] = NULL;
     f14:	0c21390b 			@ <UNDEFINED> instruction: 0x0c21390b
     f18:	13491927 	movtne	r1, #39207	@ 0x9927
     f1c:	06120111 			@ <UNDEFINED> instruction: 0x06120111
     f20:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
     f24:	00001301 	andeq	r1, r0, r1, lsl #6
  prepend_prompt();
     f28:	03000525 	movweq	r0, #1317	@ 0x525
  printf(PROMPT);
     f2c:	01213a08 			@ <UNDEFINED> instruction: 0x01213a08
  int special_key = 0;
     f30:	01a8213b 			@ <UNDEFINED> instruction: 0x01a8213b
        special_key = 1;
     f34:	13490b39 	movtne	r0, #39737	@ 0x9b39
    if (s == -1) { s = __read_char2__();}
     f38:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
     f3c:	26000017 			@ <UNDEFINED> instruction: 0x26000017
    if (s != -1) {
     f40:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
     f44:	213a0e03 	teqcs	sl, r3, lsl #28
      loop();
     f48:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
        line_buff[count] = END_OF_LINE;
     f4c:	19270621 	stmdbne	r7!, {r0, r5, r9, sl}
     f50:	06120111 			@ <UNDEFINED> instruction: 0x06120111
     f54:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
     f58:	00001301 	andeq	r1, r0, r1, lsl #6
        __write_char__(NEW_LINE);
     f5c:	03003427 	movweq	r3, #1063	@ 0x427
     f60:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
  add_command_to_history(line_buff);
     f64:	21390b3b 	teqcs	r9, fp, lsr fp
  argc = parse_line(argv, line_buff, MAX_ARG_COUNT);
     f68:	00134915 	andseq	r4, r3, r5, lsl r9
     f6c:	00342800 	eorseq	r2, r4, r0, lsl #16
     f70:	213a0803 	teqcs	sl, r3, lsl #16
  if (argc > 0) execute(argc, argv);
     f74:	90213b01 	eorls	r3, r1, r1, lsl #22
}
     f78:	490b3903 	stmdbmi	fp, {r0, r1, r8, fp, ip, sp}
        if (!__echo) {
     f7c:	00180213 	andseq	r0, r8, r3, lsl r2
     f80:	002e2900 	eoreq	r2, lr, r0, lsl #18
        if (count == 0) continue;
     f84:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
        count--;
     f88:	3b01213a 	blcc	49478 <__ROM_SIZE__+0x9478>
        line_buff[count] = END_OF_LINE;
     f8c:	1c21390b 			@ <UNDEFINED> instruction: 0x1c21390b
     f90:	01111927 	tsteq	r1, r7, lsr #18
     f94:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
        delete ();
     f98:	0000197a 	andeq	r1, r0, sl, ror r9
      if (__echo) {
     f9c:	2501112a 	strcs	r1, [r1, #-298]	@ 0xfffffed6
        __write_char__(c);
     fa0:	030b130e 	movweq	r1, #45838	@ 0xb30e
     fa4:	110e1b0e 	tstne	lr, lr, lsl #22
    if (!active_prompt()) {
     fa8:	10061201 	andne	r1, r6, r1, lsl #4
     fac:	2b000017 	blcs	1010 <shell+0x118>
    s = __read_char__();
     fb0:	0b0b0024 	bleq	2c1048 <__ROM_SIZE__+0x281048>
     fb4:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
    if (s == -1) { s = __read_char2__();}
     fb8:	132c0000 			@ <UNDEFINED> instruction: 0x132c0000
     fbc:	0b0e0301 	bleq	381bc8 <__ROM_SIZE__+0x341bc8>
      if (c == CARRIAGE_RETURN || c == NEW_LINE) {
     fc0:	3b0b3a05 	blcc	2cf7dc <__ROM_SIZE__+0x28f7dc>
     fc4:	010b390b 	tsteq	fp, fp, lsl #18
      if (c == DELETE || c == BACK_SPACE) {
     fc8:	2d000013 	stccs	0, cr0, [r0, #-76]	@ 0xffffffb4
     fcc:	0803000d 	stmdaeq	r3, {r0, r2, r3}
      } else if (c == ESCAPE) {
     fd0:	0b3b0b3a 	bleq	ec3cc0 <__ROM_SIZE__+0xe83cc0>
      } else if (c == SQUARE_BRACKET_OPEN && special_key == 1) {
     fd4:	13490b39 	movtne	r0, #39737	@ 0x9b39
      } else if ((c == 'C' || c == 'D') && special_key != 0) {
     fd8:	00000b38 	andeq	r0, r0, r8, lsr fp
     fdc:	0300342e 	movweq	r3, #1070	@ 0x42e
     fe0:	3b0b3a08 	blcc	2cf808 <__ROM_SIZE__+0x28f808>
      } else if ((c == 'A' || c == 'B') && special_key == 2) {
     fe4:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
     fe8:	3c193f13 	ldccc	15, cr3, [r9], {19}
      else if (c == TAB) {
     fec:	2f000019 	svccs	0x00000019
        line_buff[count] = c;
     ff0:	00000021 	andeq	r0, r0, r1, lsr #32
     ff4:	03001630 	movweq	r1, #1584	@ 0x630
     ff8:	3b0b3a08 	blcc	2cf820 <__ROM_SIZE__+0x28f820>
        count++;
     ffc:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
    1000:	31000013 	tstcc	r0, r3, lsl r0
          delete ();
    1004:	19270115 	stmdbne	r7!, {r0, r2, r4, r8}
          delete ();
    1008:	13011349 	movwne	r1, #4937	@ 0x1349
      } else if (c == SQUARE_BRACKET_OPEN && special_key == 1) {
    100c:	13320000 	teqne	r2, #0
        special_key = 2;
    1010:	3a0b0b01 	bcc	2c3c1c <__ROM_SIZE__+0x283c1c>
      } else if ((c == 'C' || c == 'D') && special_key != 0) {
    1014:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
        special_key = 0;
    1018:	0013010b 	andseq	r0, r3, fp, lsl #2
      } else if ((c == 'A' || c == 'B') && special_key == 2) {
    101c:	00153300 	andseq	r3, r5, r0, lsl #6
        if (!__echo) {
    1020:	13491927 	movtne	r1, #39207	@ 0x9927
    1024:	15340000 	ldrne	r0, [r4, #-0]!
          clear_prompt(count + 4);
    1028:	01192701 	tsteq	r9, r1, lsl #14
    102c:	35000013 	strcc	r0, [r0, #-19]	@ 0xffffffed
        if (c == 'A') {
    1030:	0b0b000f 	bleq	2c1074 <__ROM_SIZE__+0x281074>
          handle_down_arrow(line_buff, &count);
    1034:	26360000 	ldrtcs	r0, [r6], -r0
    1038:	37000000 	strcc	r0, [r0, -r0]
        continue;
    103c:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
          clear_prompt(count);
    1040:	0b3a0e03 	bleq	e84854 <__ROM_SIZE__+0xe44854>
    1044:	0b390b3b 	bleq	e43d38 <__ROM_SIZE__+0xe03d38>
          handle_up_arrow(line_buff, &count);
    1048:	193c1927 	ldmdbne	ip!, {r0, r1, r2, r5, r8, fp, ip}
    104c:	00001301 	andeq	r1, r0, r1, lsl #6
        handle_tab(line_buff, &count);
    1050:	3f002e38 	svccc	0x00002e38
    1054:	3a0e0319 	bcc	381cc0 <__ROM_SIZE__+0x341cc0>
        continue;
    1058:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
  if (argc > 0) execute(argc, argv);
    105c:	3c19270b 	ldccc	7, cr2, [r9], {11}
}
    1060:	39000019 	stmdbcc	r0, {r0, r3, r4}
    1064:	00000018 	andeq	r0, r0, r8, lsl r0
    1068:	3f012e3a 	svccc	0x00012e3a
    106c:	3a0e0319 	bcc	381cd8 <__ROM_SIZE__+0x341cd8>
void prompt() {
    1070:	39053b0b 	stmdbcc	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
  initial_setup();
    1074:	1201110b 	andne	r1, r1, #-1073741822	@ 0xc0000002
  exec_auto_cmds();
    1078:	7a184006 	bvc	611098 <__ROM_SIZE__+0x5d1098>
  setup();
    107c:	00130119 	andseq	r0, r3, r9, lsl r1
  decode_base64(AES_key_b64, 44, AES_key);
    1080:	012e3b00 			@ <UNDEFINED> instruction: 0x012e3b00
    1084:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
    1088:	053b0b3a 	ldreq	r0, [fp, #-2874]!	@ 0xfffff4c6
    108c:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
  AES_init_ctx(&ctx, AES_key);
    1090:	06120111 			@ <UNDEFINED> instruction: 0x06120111
    1094:	197c1840 	ldmdbne	ip!, {r6, fp, ip}^
    shell();
    1098:	00001301 	andeq	r1, r0, r1, lsl #6
  while (TRUE) {
    109c:	03012e3c 	movweq	r2, #7740	@ 0x1e3c
    10a0:	3b0b3a0e 	blcc	2cf8e0 <__ROM_SIZE__+0x28f8e0>
    10a4:	270b3905 	strcs	r3, [fp, -r5, lsl #18]
int exec(char *cmd_str) {
    10a8:	11134919 	tstne	r3, r9, lsl r9
    10ac:	40061201 	andmi	r1, r6, r1, lsl #4
  argc = parse_line(argv, cmd_str, MAX_ARG_COUNT);
    10b0:	01197a18 	tsteq	r9, r8, lsl sl
    10b4:	3d000013 	stccc	0, cr0, [r0, #-76]	@ 0xffffffb4
  if (argc > 0) execute(argc, argv);
    10b8:	0e03012e 	adfeqsp	f0, f3, #0.5
  return __cmd_exec_status;
    10bc:	053b0b3a 	ldreq	r0, [fp, #-2874]!	@ 0xfffff4c6
}
    10c0:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
    10c4:	06120111 			@ <UNDEFINED> instruction: 0x06120111
  if (argc > 0) execute(argc, argv);
    10c8:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
    10cc:	00001301 	andeq	r1, r0, r1, lsl #6
    10d0:	03012e3e 	movweq	r2, #7742	@ 0x1e3e
cmd get_function_addr(char *cmd_str) {
    10d4:	3b0b3a0e 	blcc	2cf914 <__ROM_SIZE__+0x28f914>
  for (int i = 0; table[i].command_name != NULL; i++) {
    10d8:	270b3905 	strcs	r3, [fp, -r5, lsl #18]
    10dc:	12011119 	andne	r1, r1, #1073741830	@ 0x40000006
    10e0:	7c184006 	ldcvc	0, cr4, [r8], {6}
    10e4:	00130119 	andseq	r0, r3, r9, lsl r1
    10e8:	010b3f00 	tsteq	fp, r0, lsl #30
    if (strcmp(cmd_str, table[i].command_name) == 0) {
    10ec:	13011755 	movwne	r1, #5973	@ 0x1755
    10f0:	2e400000 	cdpcs	0, 4, cr0, cr0, cr0, {0}
      return table[i].command;
    10f4:	03193f00 	tsteq	r9, #0, 30
    10f8:	3b0b3a0e 	blcc	2cf938 <__ROM_SIZE__+0x28f938>
  return NULL;
    10fc:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
}
    1100:	12011113 	andne	r1, r1, #-1073741820	@ 0xc0000004
  if(v < 26) return v + 'A';
    1104:	7a184006 	bvc	611124 <__ROM_SIZE__+0x5d1124>
  if(v < 52) return v + 71;
    1108:	41000019 	tstmi	r0, r9, lsl r0
  if(v < 62) return v - 4;
    110c:	193f002e 	ldmdbne	pc!, {r1, r2, r3, r5}	@ <UNPREDICTABLE>
  if(v == 62) return '+';
    1110:	0b3a0e03 	bleq	e84924 <__ROM_SIZE__+0xe44924>
  if(v == 63) return '/';
    1114:	0b390b3b 	bleq	e43e08 <__ROM_SIZE__+0xe03e08>
  return 64;
    1118:	06120111 			@ <UNDEFINED> instruction: 0x06120111
  if(v < 26) return v + 'A';
    111c:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
    1120:	2e420000 	cdpcs	0, 4, cr0, cr2, cr0, {0}
  if(v < 52) return v + 71;
    1124:	03193f01 	tsteq	r9, #1, 30
  if(v < 62) return v - 4;
    1128:	3b0b3a0e 	blcc	2cf968 <__ROM_SIZE__+0x28f968>
    112c:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
  if(v == 62) return '+';
    1130:	12011119 	andne	r1, r1, #1073741830	@ 0x40000006
}
    1134:	7a184006 	bvc	611154 <__ROM_SIZE__+0x5d1154>
  if('A' <= c && c <= 'Z') return c - 'A';
    1138:	00000019 	andeq	r0, r0, r9, lsl r0
    113c:	7d004801 	stcvc	8, cr4, [r0, #-4]
  if('a' <= c && c <= 'z') return c - 71;
    1140:	00137f01 	andseq	r7, r3, r1, lsl #30
    1144:	00050200 	andeq	r0, r5, r0, lsl #4
    1148:	213a0e03 	teqcs	sl, r3, lsl #28
  if('0' <= c && c <= '9') return c + 4;
    114c:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
    1150:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
  if(c == '+') return 62;
    1154:	1742b717 	smlaldne	fp, r2, r7, r7
  if(c == '/') return 63;
    1158:	2e030000 	cdpcs	0, 0, cr0, cr3, cr0, {0}
  return 255;
    115c:	03193f01 	tsteq	r9, #1, 30
  if('a' <= c && c <= 'z') return c - 71;
    1160:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
    1164:	0b390b3b 	bleq	e43e58 <__ROM_SIZE__+0xe03e58>
  if('0' <= c && c <= '9') return c + 4;
    1168:	13491927 	movtne	r1, #39207	@ 0x9927
  if(c == '+') return 62;
    116c:	06120111 			@ <UNDEFINED> instruction: 0x06120111
  if(c == '/') return 63;
    1170:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
  return (input_length + 2)/3*4;
    1174:	00001301 	andeq	r1, r0, r1, lsl #6
    1178:	03003404 	movweq	r3, #1028	@ 0x404
    117c:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
}
    1180:	0b390b3b 	bleq	e43e74 <__ROM_SIZE__+0xe03e74>
    1184:	17021349 	strne	r1, [r2, -r9, asr #6]
unsigned int decode_base64_length(unsigned char input[], unsigned int input_length) {
    1188:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
    118c:	00490500 	subeq	r0, r9, r0, lsl #10
  while(base64_to_binary(input[0]) < 64 && (unsigned int) (input - start) < input_length) {
    1190:	187e1802 	ldmdane	lr!, {r1, fp, ip}^
    1194:	0b060000 	bleq	18119c <__ROM_SIZE__+0x14119c>
    1198:	12011101 	andne	r1, r1, #1073741824	@ 0x40000000
    119c:	00130106 	andseq	r0, r3, r6, lsl #2
    11a0:	00340700 	eorseq	r0, r4, r0, lsl #14
  input_length = input - start;
    11a4:	213a0803 	teqcs	sl, r3, lsl #16
  return input_length/4*3 + (input_length % 4 ? input_length % 4 - 1 : 0);
    11a8:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
    11ac:	13491421 	movtne	r1, #37921	@ 0x9421
    11b0:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
}
    11b4:	08000017 	stmdaeq	r0, {r0, r1, r2, r4}
  return input_length/4*3 + (input_length % 4 ? input_length % 4 - 1 : 0);
    11b8:	017d0148 	cmneq	sp, r8, asr #2
unsigned int encode_base64(unsigned char input[], unsigned int input_length, unsigned char output[]) {
    11bc:	1301137f 	movwne	r1, #4991	@ 0x137f
    11c0:	24090000 	strcs	r0, [r9], #-0
    11c4:	3e0b0b00 	vmlacc.f64	d0, d11, d0
  unsigned int full_sets = input_length/3;
    11c8:	000e030b 	andeq	r0, lr, fp, lsl #6
    11cc:	00050a00 	andeq	r0, r5, r0, lsl #20
  for(unsigned int i = 0; i < full_sets; ++i) {
    11d0:	213a0803 	teqcs	sl, r3, lsl #16
    output[0] = binary_to_base64(                         input[0] >> 2);
    11d4:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
    11d8:	13492e21 	movtne	r2, #40481	@ 0x9e21
    output[1] = binary_to_base64((input[0] & 0x03) << 4 | input[1] >> 4);
    11dc:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
    11e0:	0b000017 	bleq	1244 <encode_base64+0x88>
    11e4:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
    11e8:	0e030b13 	vmoveq.32	d3[0], r0
    11ec:	01110e1b 	tsteq	r1, fp, lsl lr
    output[2] = binary_to_base64((input[1] & 0x0F) << 2 | input[2] >> 6);
    11f0:	17100612 			@ <UNDEFINED> instruction: 0x17100612
    11f4:	0f0c0000 	svceq	0x000c0000
    11f8:	490b0b00 	stmdbmi	fp, {r8, r9, fp}
    11fc:	0d000013 	stceq	0, cr0, [r0, #-76]	@ 0xffffffb4
    1200:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
    output[3] = binary_to_base64( input[2] & 0x3F);
    1204:	0b3a0e03 	bleq	e84a18 <__ROM_SIZE__+0xe44a18>
    1208:	0b390b3b 	bleq	e43efc <__ROM_SIZE__+0xe03efc>
    120c:	13491927 	movtne	r1, #39207	@ 0x9927
    input += 3;
    1210:	06120111 			@ <UNDEFINED> instruction: 0x06120111
  for(unsigned int i = 0; i < full_sets; ++i) {
    1214:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
    1218:	01000000 	mrseq	r0, (UNDEF: 0)
  switch(input_length % 3) {
    121c:	08030034 	stmdaeq	r3, {r2, r4, r5}
    1220:	3b01213a 	blcc	49710 <__ROM_SIZE__+0x9710>
    1224:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
    1228:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
    122c:	00001742 	andeq	r1, r0, r2, asr #14
    1230:	0b002402 	bleq	a240 <__RAM_SIZE__+0x2240>
    1234:	030b3e0b 	movweq	r3, #48651	@ 0xbe0b
  return encode_base64_length(input_length);
    1238:	0300000e 	movweq	r0, #14
}
    123c:	18020049 	stmdane	r2, {r0, r3, r6}
      output[0] = '\0';
    1240:	0000187e 	andeq	r1, r0, lr, ror r8
      output[0] = binary_to_base64(                         input[0] >> 2);
    1244:	03001604 	movweq	r1, #1540	@ 0x604
    1248:	3b0b3a0e 	blcc	2cfa88 <__ROM_SIZE__+0x28fa88>
    124c:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
      output[1] = binary_to_base64((input[0] & 0x03) << 4);
    1250:	05000013 	streq	r0, [r0, #-19]	@ 0xffffffed
    1254:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
    1258:	3b03213a 	blcc	c9748 <__ROM_SIZE__+0x89748>
      output[2] = '=';
    125c:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
      output[3] = '=';
    1260:	000b3813 	andeq	r3, fp, r3, lsl r8
      output[4] = '\0';
    1264:	00210600 	eoreq	r0, r1, r0, lsl #12
      output[0] = binary_to_base64(                         input[0] >> 2);
    1268:	0b2f1349 	bleq	bc5f94 <__ROM_SIZE__+0xb85f94>
    126c:	2e070000 	cdpcs	0, 0, cr0, cr7, cr0, {0}
    1270:	03193f01 	tsteq	r9, #1, 30
      output[1] = binary_to_base64((input[0] & 0x03) << 4 | input[1] >> 4);
    1274:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
    1278:	21390b3b 	teqcs	r9, fp, lsr fp
    127c:	11192706 	tstne	r9, r6, lsl #14
    1280:	40061201 	andmi	r1, r6, r1, lsl #4
    1284:	01197a18 	tsteq	r9, r8, lsl sl
      output[2] = binary_to_base64((input[1] & 0x0F) << 2);
    1288:	08000013 	stmdaeq	r0, {r0, r1, r4}
    128c:	08030005 	stmdaeq	r3, {r0, r2}
    1290:	3b01213a 	blcc	49780 <__ROM_SIZE__+0x9780>
      output[3] = '=';
    1294:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
      output[4] = '\0';
    1298:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
      break;
    129c:	00001742 	andeq	r1, r0, r2, asr #14
    12a0:	49002609 	stmdbmi	r0, {r0, r3, r9, sl, sp}
unsigned int decode_base64(unsigned char input[], unsigned int input_length, unsigned char output[]) {
    12a4:	0a000013 	beq	12f8 <decode_base64+0x54>
    12a8:	13490101 	movtne	r0, #37121	@ 0x9101
  unsigned int output_length = decode_base64_length(input, input_length);
    12ac:	00001301 	andeq	r1, r0, r1, lsl #6
    12b0:	4900050b 	stmdbmi	r0, {r0, r1, r3, r8, sl}
  for(unsigned int i = 2; i < output_length; i += 3) {
    12b4:	0c000013 	stceq	0, cr0, [r0], {19}
    output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
    12b8:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
    12bc:	3b01213a 	blcc	497ac <__ROM_SIZE__+0x97ac>
    12c0:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
    12c4:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
    12c8:	00001742 	andeq	r1, r0, r2, asr #14
    output[1] = base64_to_binary(input[1]) << 4 | base64_to_binary(input[2]) >> 2;
    12cc:	0b000f0d 	bleq	4f08 <base_order+0x1688>
    12d0:	13490421 	movtne	r0, #37921	@ 0x9421
    12d4:	340e0000 	strcc	r0, [lr], #-0
    12d8:	3a080300 	bcc	201ee0 <__ROM_SIZE__+0x1c1ee0>
    12dc:	0b3b0121 	bleq	ec1768 <__ROM_SIZE__+0xe81768>
    output[2] = base64_to_binary(input[2]) << 6 | base64_to_binary(input[3]);
    12e0:	13490b39 	movtne	r0, #39737	@ 0x9b39
    12e4:	00001802 	andeq	r1, r0, r2, lsl #16
    12e8:	7d01480f 	stcvc	8, cr4, [r1, #-60]	@ 0xffffffc4
    12ec:	01137f01 	tsteq	r3, r1, lsl #30
    input += 4;
    12f0:	10000013 	andne	r0, r0, r3, lsl r0
  for(unsigned int i = 2; i < output_length; i += 3) {
    12f4:	017d0148 	cmneq	sp, r8, asr #2
    12f8:	0000137f 	andeq	r1, r0, pc, ror r3
  switch(output_length % 3) {
    12fc:	25011111 	strcs	r1, [r1, #-273]	@ 0xfffffeef
    1300:	030b130e 	movweq	r1, #45838	@ 0xb30e
    1304:	110e1b0e 	tstne	lr, lr, lsl #22
    1308:	10061201 	andne	r1, r6, r1, lsl #4
    130c:	12000017 	andne	r0, r0, #23
    1310:	0b0b0024 	bleq	2c13a8 <__ROM_SIZE__+0x2813a8>
    1314:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
    1318:	0f130000 	svceq	0x00130000
      output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
    131c:	000b0b00 	andeq	r0, fp, r0, lsl #22
    1320:	01131400 	tsteq	r3, r0, lsl #8
    1324:	0b3a0b0b 	bleq	e83f58 <__ROM_SIZE__+0xe43f58>
    1328:	0b390b3b 	bleq	e4401c <__ROM_SIZE__+0xe0401c>
    132c:	00001301 	andeq	r1, r0, r1, lsl #6
      output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
    1330:	3f012e15 	svccc	0x00012e15
    1334:	3a0e0319 	bcc	381fa0 <__ROM_SIZE__+0x341fa0>
    1338:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    133c:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
    1340:	01193c13 	tsteq	r9, r3, lsl ip
      output[1] = base64_to_binary(input[1]) << 4 | base64_to_binary(input[2]) >> 2;
    1344:	16000013 			@ <UNDEFINED> instruction: 0x16000013
    1348:	08030005 	stmdaeq	r3, {r0, r2}
    134c:	0b3b0b3a 	bleq	ec403c <__ROM_SIZE__+0xe8403c>
    1350:	13490b39 	movtne	r0, #39737	@ 0x9b39
    1354:	00001802 	andeq	r1, r0, r2, lsl #16
  return output_length;
    1358:	49010117 	stmdbmi	r1, {r0, r1, r2, r4, r8}
    135c:	00000013 	andeq	r0, r0, r3, lsl r0
{
    1360:	02004901 	andeq	r4, r0, #16384	@ 0x4000
    1364:	00187e18 	andseq	r7, r8, r8, lsl lr
	for (i = 0, j = 0; i < 16; ++i, j += 4)
    1368:	00340200 	eorseq	r0, r4, r0, lsl #4
    136c:	213a0e03 	teqcs	sl, r3, lsl #28
		m[i] = (data[j] << 24) | (data[j + 1] << 16) | (data[j + 2] << 8) | (data[j + 3]);
    1370:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
    1374:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
    1378:	1742b717 	smlaldne	fp, r2, r7, r7
    137c:	24030000 	strcs	r0, [r3], #-0
    1380:	3e0b0b00 	vmlacc.f64	d0, d11, d0
    1384:	000e030b 	andeq	r0, lr, fp, lsl #6
    1388:	00160400 	andseq	r0, r6, r0, lsl #8
	for (i = 0, j = 0; i < 16; ++i, j += 4)
    138c:	0b3a0e03 	bleq	e84ba0 <__ROM_SIZE__+0xe44ba0>
    1390:	0b390b3b 	bleq	e44084 <__ROM_SIZE__+0xe04084>
		m[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16];
    1394:	00001349 	andeq	r1, r0, r9, asr #6
    1398:	0b000f05 	bleq	4fb4 <base_order+0x1734>
    139c:	13490421 	movtne	r0, #37921	@ 0x9421
    13a0:	05060000 	streq	r0, [r6, #-0]
    13a4:	3a080300 	bcc	201fac <__ROM_SIZE__+0x1c1fac>
    13a8:	0b3b0121 	bleq	ec1834 <__ROM_SIZE__+0xe81834>
    13ac:	13490b39 	movtne	r0, #39737	@ 0x9b39
    13b0:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
    13b4:	07000017 	smladeq	r0, r7, r0, r0
    13b8:	1755010b 	ldrbne	r0, [r5, -fp, lsl #2]
    13bc:	00001301 	andeq	r1, r0, r1, lsl #6
    13c0:	7d014808 	stcvc	8, cr4, [r1, #-32]	@ 0xffffffe0
    13c4:	00137f01 	andseq	r7, r3, r1, lsl #30
    13c8:	01480900 	cmpeq	r8, r0, lsl #18
    13cc:	0000017d 	andeq	r0, r0, sp, ror r1
    13d0:	0300280a 	movweq	r2, #2058	@ 0x80a
    13d4:	000b1c0e 	andeq	r1, fp, lr, lsl #24
	for ( ; i < 64; ++i)
    13d8:	01010b00 	tsteq	r1, r0, lsl #22
    13dc:	13011349 	movwne	r1, #4937	@ 0x1349
	a = ctx->state[0];
    13e0:	210c0000 	mrscs	r0, (UNDEF: 12)
	b = ctx->state[1];
    13e4:	2f134900 	svccs	0x00134900
	c = ctx->state[2];
    13e8:	0d00000b 	stceq	0, cr0, [r0, #-44]	@ 0xffffffd4
	d = ctx->state[3];
    13ec:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
	e = ctx->state[4];
    13f0:	3b01213a 	blcc	498e0 <__ROM_SIZE__+0x98e0>
	f = ctx->state[5];
    13f4:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
    13f8:	00180213 	andseq	r0, r8, r3, lsl r2
	g = ctx->state[6];
    13fc:	00050e00 	andeq	r0, r5, r0, lsl #28
	h = ctx->state[7];
    1400:	213a0e03 	teqcs	sl, r3, lsl #28
    1404:	32213b01 	eorcc	r3, r1, #1024	@ 0x400
	d = ctx->state[3];
    1408:	13490b39 	movtne	r0, #39737	@ 0x9b39
	b = ctx->state[1];
    140c:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
	for (i = 0; i < 64; ++i) {
    1410:	0f000017 	svceq	0x00000017
    1414:	017d0148 	cmneq	sp, r8, asr #2
    1418:	00001301 	andeq	r1, r0, r1, lsl #6
    141c:	25011110 	strcs	r1, [r1, #-272]	@ 0xfffffef0
		t1 = h + EP1(e) + CH(e,f,g) + k[i] + m[i];
    1420:	030b130e 	movweq	r1, #45838	@ 0xb30e
    1424:	110e1b0e 	tstne	lr, lr, lsl #22
    1428:	10061201 	andne	r1, r6, r1, lsl #4
    142c:	11000017 	tstne	r0, r7, lsl r0
    1430:	0e030113 	mcreq	1, 0, r0, cr3, cr3, {0}
    1434:	0b3a0b0b 	bleq	e84068 <__ROM_SIZE__+0xe44068>
    1438:	13010b3b 	movwne	r0, #6971	@ 0x1b3b
    143c:	0d120000 	ldceq	0, cr0, [r2, #-0]
    1440:	490e0300 	stmdbmi	lr, {r8, r9}
    1444:	340b3813 	strcc	r3, [fp], #-2067	@ 0xfffff7ed
    1448:	13000019 	movwne	r0, #25
		t2 = EP0(a) + MAJ(a,b,c);
    144c:	0b0b000f 	bleq	2c1490 <__ROM_SIZE__+0x281490>
    1450:	24140000 	ldrcs	r0, [r4], #-0
    1454:	3e0b0b00 	vmlacc.f64	d0, d11, d0
    1458:	0008030b 	andeq	r0, r8, fp, lsl #6
    145c:	01151500 	tsteq	r5, r0, lsl #10
    1460:	13011927 	movwne	r1, #6439	@ 0x1927
    1464:	05160000 	ldreq	r0, [r6, #-0]
    1468:	00134900 	andseq	r4, r3, r0, lsl #18
		h = g;
    146c:	00261700 	eoreq	r1, r6, r0, lsl #14
		f = e;
    1470:	00001349 	andeq	r1, r0, r9, asr #6
		e = d + t1;
    1474:	03003418 	movweq	r3, #1048	@ 0x418
		c = b;
    1478:	3b0b3a0e 	blcc	2cfcb8 <__ROM_SIZE__+0x28fcb8>
		a = t1 + t2;
    147c:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
	for (i = 0; i < 64; ++i) {
    1480:	3c193f13 	ldccc	15, cr3, [r9], {19}
	ctx->state[0] += a;
    1484:	19000019 	stmdbne	r0, {r0, r3, r4}
    1488:	0b3e0104 	bleq	f818a0 <__ROM_SIZE__+0xf418a0>
    148c:	13490b0b 	movtne	r0, #39691	@ 0x9b0b
    1490:	0b3b0b3a 	bleq	ec4180 <__ROM_SIZE__+0xe84180>
    1494:	13010b39 	movwne	r0, #6969	@ 0x1b39
	ctx->state[1] += b;
    1498:	2e1a0000 	cdpcs	0, 1, cr0, cr10, cr0, {0}
	ctx->state[2] += c;
    149c:	03193f01 	tsteq	r9, #1, 30
    14a0:	3b0b3a0e 	blcc	2cfce0 <__ROM_SIZE__+0x28fce0>
	ctx->state[3] += d;
    14a4:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
	ctx->state[4] += e;
    14a8:	11134919 	tstne	r3, r9, lsl r9
    14ac:	40061201 	andmi	r1, r6, r1, lsl #4
	ctx->state[5] += f;
    14b0:	01197c18 	tsteq	r9, r8, lsl ip
    14b4:	1b000013 	blne	1508 <sha256_init+0x34>
	ctx->state[6] += g;
    14b8:	00000018 	andeq	r0, r0, r8, lsl r0
    14bc:	7d00481c 	stcvc	8, cr4, [r0, #-112]	@ 0xffffff90
	ctx->state[7] += h;
    14c0:	00137f01 	andseq	r7, r3, r1, lsl #30
    14c4:	012e1d00 			@ <UNDEFINED> instruction: 0x012e1d00
}
    14c8:	0b3a0e03 	bleq	e84cdc <__ROM_SIZE__+0xe44cdc>
    14cc:	0b390b3b 	bleq	e441c0 <__ROM_SIZE__+0xe041c0>
    14d0:	13491927 	movtne	r1, #39207	@ 0x9927
	ctx->datalen = 0;
    14d4:	06120111 			@ <UNDEFINED> instruction: 0x06120111
	ctx->bitlen = 0;
    14d8:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
    14dc:	00001301 	andeq	r1, r0, r1, lsl #6
	ctx->state[0] = 0x6a09e667;
    14e0:	0300341e 	movweq	r3, #1054	@ 0x41e
	ctx->state[1] = 0xbb67ae85;
    14e4:	3b0b3a08 	blcc	2cfd0c <__ROM_SIZE__+0x28fd0c>
	ctx->state[2] = 0x3c6ef372;
    14e8:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
	ctx->state[3] = 0xa54ff53a;
    14ec:	00180213 	andseq	r0, r8, r3, lsl r2
	ctx->state[4] = 0x510e527f;
    14f0:	010b1f00 	tsteq	fp, r0, lsl #30
	ctx->state[5] = 0x9b05688c;
    14f4:	06120111 			@ <UNDEFINED> instruction: 0x06120111
	ctx->state[6] = 0x1f83d9ab;
    14f8:	00001301 	andeq	r1, r0, r1, lsl #6
	ctx->state[7] = 0x5be0cd19;
    14fc:	55010b20 	strpl	r0, [r1, #-2848]	@ 0xfffff4e0
    1500:	21000017 	tstcs	r0, r7, lsl r0
    1504:	08030034 	stmdaeq	r3, {r2, r4, r5}
    1508:	0b3b0b3a 	bleq	ec41f8 <__ROM_SIZE__+0xe841f8>
}
    150c:	13490b39 	movtne	r0, #39737	@ 0x9b39
    1510:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
    1514:	22000017 	andcs	r0, r0, #23
    1518:	0e03012e 	adfeqsp	f0, f3, #0.5
    151c:	0b3b0b3a 	bleq	ec420c <__ROM_SIZE__+0xe8420c>
    1520:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
    1524:	06120111 			@ <UNDEFINED> instruction: 0x06120111
{
    1528:	197c1840 	ldmdbne	ip!, {r6, fp, ip}^
    152c:	01000000 	mrseq	r0, (UNDEF: 0)
	for (i = 0; i < len; ++i) {
    1530:	18020049 	stmdane	r2, {r0, r3, r6}
    1534:	0000187e 	andeq	r1, r0, lr, ror r8
    1538:	03003402 	movweq	r3, #1026	@ 0x402
		ctx->data[ctx->datalen] = data[i];
    153c:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
		ctx->datalen++;
    1540:	0b390b3b 	bleq	e44234 <__ROM_SIZE__+0xe04234>
		if (ctx->datalen == 64) {
    1544:	17021349 	strne	r1, [r2, -r9, asr #6]
			sha256_transform(ctx, ctx->data);
    1548:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
    154c:	00240300 	eoreq	r0, r4, r0, lsl #6
			ctx->bitlen += 512;
    1550:	0b3e0b0b 	bleq	f84184 <__ROM_SIZE__+0xf44184>
    1554:	00000e03 	andeq	r0, r0, r3, lsl #28
    1558:	03001604 	movweq	r1, #1540	@ 0x604
    155c:	3b0b3a0e 	blcc	2cfd9c <__ROM_SIZE__+0x28fd9c>
			ctx->datalen = 0;
    1560:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
    1564:	05000013 	streq	r0, [r0, #-19]	@ 0xffffffed
{
    1568:	210b000f 	tstcs	fp, pc
    156c:	00134904 	andseq	r4, r3, r4, lsl #18
	if (ctx->datalen < 56) {
    1570:	00050600 	andeq	r0, r5, r0, lsl #12
		ctx->data[i++] = 0x80;
    1574:	213a0803 	teqcs	sl, r3, lsl #16
    1578:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
			ctx->data[i++] = 0x00;
    157c:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
    1580:	1742b717 	smlaldne	fp, r2, r7, r7
		while (i < 56)
    1584:	0b070000 	bleq	1c158c <__ROM_SIZE__+0x18158c>
	ctx->bitlen += ctx->datalen * 8;
    1588:	01175501 	tsteq	r7, r1, lsl #10
    158c:	08000013 	stmdaeq	r0, {r0, r1, r4}
    1590:	017d0148 	cmneq	sp, r8, asr #2
    1594:	0000137f 	andeq	r1, r0, pc, ror r3
	ctx->data[63] = ctx->bitlen;
    1598:	7d014809 	stcvc	8, cr4, [r1, #-36]	@ 0xffffffdc
	ctx->data[62] = ctx->bitlen >> 8;
    159c:	0a000001 	beq	15a8 <sha256_final+0x40>
    15a0:	0e030028 	cdpeq	0, 0, cr0, cr3, cr8, {1}
	ctx->data[61] = ctx->bitlen >> 16;
    15a4:	00000b1c 	andeq	r0, r0, ip, lsl fp
	ctx->data[60] = ctx->bitlen >> 24;
    15a8:	4901010b 	stmdbmi	r1, {r0, r1, r3, r8}
    15ac:	00130113 	andseq	r0, r3, r3, lsl r1
	ctx->data[59] = ctx->bitlen >> 32;
    15b0:	00210c00 	eoreq	r0, r1, r0, lsl #24
	ctx->data[58] = ctx->bitlen >> 40;
    15b4:	0b2f1349 	bleq	bc62e0 <__ROM_SIZE__+0xb862e0>
	ctx->data[57] = ctx->bitlen >> 48;
    15b8:	340d0000 	strcc	r0, [sp], #-0
    15bc:	3a0e0300 	bcc	3821c4 <__ROM_SIZE__+0x3421c4>
	ctx->data[56] = ctx->bitlen >> 56;
    15c0:	0b3b0121 	bleq	ec1a4c <__ROM_SIZE__+0xe81a4c>
	sha256_transform(ctx, ctx->data);
    15c4:	13490b39 	movtne	r0, #39737	@ 0x9b39
    15c8:	00001802 	andeq	r1, r0, r2, lsl #16
	for (i = 0; i < 4; ++i) {
    15cc:	0300050e 	movweq	r0, #1294	@ 0x50e
		ctx->data[i++] = 0x80;
    15d0:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
    15d4:	3930213b 	ldmdbcc	r0!, {r0, r1, r3, r4, r5, r8, sp}
			ctx->data[i++] = 0x00;
    15d8:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
    15dc:	1742b717 	smlaldne	fp, r2, r7, r7
		while (i < 64)
    15e0:	480f0000 	stmdami	pc, {}	@ <UNPREDICTABLE>
		sha256_transform(ctx, ctx->data);
    15e4:	01017d01 	tsteq	r1, r1, lsl #26
    15e8:	10000013 	andne	r0, r0, r3, lsl r0
		memset(ctx->data, 0, 56);
    15ec:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
    15f0:	0e030b13 	vmoveq.32	d3[0], r0
    15f4:	01110e1b 	tsteq	r1, fp, lsl lr
		hash[i]      = (ctx->state[0] >> (24 - i * 8)) & 0x000000ff;
    15f8:	17100612 			@ <UNDEFINED> instruction: 0x17100612
    15fc:	13110000 	tstne	r1, #0
    1600:	0b0e0301 	bleq	38220c <__ROM_SIZE__+0x34220c>
		hash[i + 4]  = (ctx->state[1] >> (24 - i * 8)) & 0x000000ff;
    1604:	3b0b3a0b 	blcc	2cfe38 <__ROM_SIZE__+0x28fe38>
    1608:	0013010b 	andseq	r0, r3, fp, lsl #2
		hash[i + 8]  = (ctx->state[2] >> (24 - i * 8)) & 0x000000ff;
    160c:	000d1200 	andeq	r1, sp, r0, lsl #4
    1610:	13490e03 	movtne	r0, #40451	@ 0x9e03
		hash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0x000000ff;
    1614:	19340b38 	ldmdbne	r4!, {r3, r4, r5, r8, r9, fp}
    1618:	0f130000 	svceq	0x00130000
    161c:	000b0b00 	andeq	r0, fp, r0, lsl #22
		hash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0x000000ff;
    1620:	00241400 	eoreq	r1, r4, r0, lsl #8
    1624:	0b3e0b0b 	bleq	f84258 <__ROM_SIZE__+0xf44258>
		hash[i + 20] = (ctx->state[5] >> (24 - i * 8)) & 0x000000ff;
    1628:	00000803 	andeq	r0, r0, r3, lsl #16
    162c:	27011515 	smladcs	r1, r5, r5, r1
    1630:	00130119 	andseq	r0, r3, r9, lsl r1
		hash[i + 24] = (ctx->state[6] >> (24 - i * 8)) & 0x000000ff;
    1634:	00051600 	andeq	r1, r5, r0, lsl #12
    1638:	00001349 	andeq	r1, r0, r9, asr #6
		hash[i + 28] = (ctx->state[7] >> (24 - i * 8)) & 0x000000ff;
    163c:	49002617 	stmdbmi	r0, {r0, r1, r2, r4, r9, sl, sp}
    1640:	18000013 	stmdane	r0, {r0, r1, r4}
    1644:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
	for (i = 0; i < 4; ++i) {
    1648:	0b3b0b3a 	bleq	ec4338 <__ROM_SIZE__+0xe84338>
}
    164c:	13490b39 	movtne	r0, #39737	@ 0x9b39
static void outstr(const char *str) {
    1650:	193c193f 	ldmdbne	ip!, {r0, r1, r2, r3, r4, r5, r8, fp, ip}
  while (*str != '\0') {
    1654:	04190000 	ldreq	r0, [r9], #-0
    __write_char__(*str);
    1658:	0b0b3e01 	bleq	2d0e64 <__ROM_SIZE__+0x290e64>
    str++;
    165c:	3a13490b 	bcc	4d3a90 <__ROM_SIZE__+0x493a90>
  while (*str != '\0') {
    1660:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
}
    1664:	0013010b 	andseq	r0, r3, fp, lsl #2
    1668:	012e1a00 			@ <UNDEFINED> instruction: 0x012e1a00
static bool printf_numbers(const char fmt, va_list *args, int l_count) {
    166c:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
    1670:	0b3b0b3a 	bleq	ec4360 <__ROM_SIZE__+0xe84360>
  switch (fmt) {
    1674:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
    1678:	01111349 	tsteq	r1, r9, asr #6
    167c:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
      if (l_count == 0) {
    1680:	1301197c 	movwne	r1, #6524	@ 0x197c
    1684:	181b0000 	ldmdane	fp, {}	@ <UNPREDICTABLE>
        value = va_arg(*args, unsigned int);
    1688:	1c000000 	stcne	0, cr0, [r0], {-0}
    168c:	017d0048 	cmneq	sp, r8, asr #32
      if (fmt == 'u') {
    1690:	0000137f 	andeq	r1, r0, pc, ror r3
        if (value == 0) {
    1694:	03012e1d 	movweq	r2, #7709	@ 0x1e1d
          __write_char__(hextable[0]);
    1698:	3b0b3a0e 	blcc	2cfed8 <__ROM_SIZE__+0x28fed8>
    169c:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
  return true;
    16a0:	11134919 	tstne	r3, r9, lsl r9
  switch (fmt) {
    16a4:	40061201 	andmi	r1, r6, r1, lsl #4
      outstr("\nprintf-error\n");
    16a8:	01197a18 	tsteq	r9, r8, lsl sl
      return false;
    16ac:	1e000013 	mcrne	0, 0, r0, cr0, cr3, {0}
}
    16b0:	08030034 	stmdaeq	r3, {r2, r4, r5}
      if (l_count == 0) {
    16b4:	0b3b0b3a 	bleq	ec43a4 <__ROM_SIZE__+0xe843a4>
        value = va_arg(*args, int);
    16b8:	13490b39 	movtne	r0, #39737	@ 0x9b39
    16bc:	00001802 	andeq	r1, r0, r2, lsl #16
      if (value < 0) {
    16c0:	11010b1f 	tstne	r1, pc, lsl fp
        num[num_len++] = hextable[value % 10];
    16c4:	01061201 	tsteq	r6, r1, lsl #4
    16c8:	20000013 	andcs	r0, r0, r3, lsl r0
    16cc:	1755010b 	ldrbne	r0, [r5, -fp, lsl #2]
    16d0:	34210000 	strtcc	r0, [r1], #-0
    16d4:	3a080300 	bcc	2022dc <__ROM_SIZE__+0x1c22dc>
    16d8:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    16dc:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
    16e0:	1742b717 	smlaldne	fp, r2, r7, r7
    16e4:	2e220000 	cdpcs	0, 2, cr0, cr2, cr0, {0}
        value = value / 10;
    16e8:	3a0e0301 	bcc	3822f4 <__ROM_SIZE__+0x3422f4>
      } while (value > 0);
    16ec:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    16f0:	1119270b 	tstne	r9, fp, lsl #14
        __write_char__('-');
    16f4:	40061201 	andmi	r1, r6, r1, lsl #4
    16f8:	00197c18 	andseq	r7, r9, r8, lsl ip
        value = -value;
    16fc:	34010000 	strcc	r0, [r1], #-0
        __write_char__(num[--num_len]);
    1700:	3a0e0300 	bcc	382308 <__ROM_SIZE__+0x342308>
    1704:	0b3b0121 	bleq	ec1b90 <__ROM_SIZE__+0xe81b90>
    1708:	13490b39 	movtne	r0, #39737	@ 0x9b39
    170c:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
    1710:	02000017 	andeq	r0, r0, #23
      while (num_len > 0) {
    1714:	18020049 	stmdane	r2, {r0, r3, r6}
  return true;
    1718:	0000187e 	andeq	r1, r0, lr, ror r8
          num[num_len++] = hextable[value % 10];
    171c:	0b002403 	bleq	a730 <__RAM_SIZE__+0x2730>
    1720:	030b3e0b 	movweq	r3, #48651	@ 0xbe0b
    1724:	0400000e 	streq	r0, [r0], #-14
    1728:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
    172c:	3b01213a 	blcc	49c1c <__ROM_SIZE__+0x9c1c>
    1730:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
    1734:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
    1738:	00001742 	andeq	r1, r0, r2, asr #14
          value = value / 10;
    173c:	7d004805 	stcvc	8, cr4, [r0, #-20]	@ 0xffffffec
        } while (value > 0);
    1740:	00137f01 	andseq	r7, r3, r1, lsl #30
        while (num_len > 0) {
    1744:	01480600 	cmpeq	r8, r0, lsl #12
          __write_char__(num[--num_len]);
    1748:	137f017d 	cmnne	pc, #1073741855	@ 0x4000001f
    174c:	05070000 	streq	r0, [r7, #-0]
    1750:	00134900 	andseq	r4, r3, r0, lsl #18
    1754:	00340800 	eorseq	r0, r4, r0, lsl #16
    1758:	213a0e03 	teqcs	sl, r3, lsl #28
    175c:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
  return true;
    1760:	13490121 	movtne	r0, #37153	@ 0x9121
              __write_char__(hextable[val]);
    1764:	1802193f 	stmdane	r2, {r0, r1, r2, r3, r4, r5, r8, fp, ip}
    1768:	48090000 	stmdami	r9, {}	@ <UNPREDICTABLE>
              leading_zero_ignored = true;
    176c:	7f017d01 	svcvc	0x00017d01
          while (start_bit >= 0) {
    1770:	00130113 	andseq	r0, r3, r3, lsl r1
            int val = (value >> start_bit) & 0xF;
    1774:	000f0a00 	andeq	r0, pc, r0, lsl #20
            if (val || leading_zero_ignored) {
    1778:	4904210b 	stmdbmi	r4, {r0, r1, r3, r8, sp}
    177c:	0b000013 	bleq	17d0 <printf+0x24>
    1780:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
          bool leading_zero_ignored = false;
    1784:	0b3b0b3a 	bleq	ec4474 <__ROM_SIZE__+0xe84474>
          int start_bit = LAST_NIBBLE_FIRST_BIT;
    1788:	13490b39 	movtne	r0, #39737	@ 0x9b39
  return true;
    178c:	0d0c0000 	stceq	0, cr0, [ip, #-0]
        return false;
    1790:	3a0e0300 	bcc	382398 <__ROM_SIZE__+0x342398>
        return false;
    1794:	0b3b0321 	bleq	ec2420 <__ROM_SIZE__+0xe82420>
    1798:	13490b39 	movtne	r0, #39737	@ 0x9b39
    179c:	00000b38 	andeq	r0, r0, r8, lsr fp
    17a0:	3f012e0d 	svccc	0x00012e0d
    17a4:	3a0e0319 	bcc	382410 <__ROM_SIZE__+0x342410>
    17a8:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
int printf(const char *fmt, ...) {
    17ac:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
    17b0:	01193c13 	tsteq	r9, r3, lsl ip
    17b4:	0e000013 	mcreq	0, 0, r0, cr0, cr3, {0}
  va_start(args, fmt);
    17b8:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
  while (*fmt) {
    17bc:	213a0e03 	teqcs	sl, r3, lsl #28
        if (*fmt == '%') {
    17c0:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
        __write_char__(*fmt);
    17c4:	19270521 	stmdbne	r7!, {r0, r5, r8, sl}
        fmt++;
    17c8:	01111349 	tsteq	r1, r9, asr #6
  while (*fmt) {
    17cc:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
    switch (state) {
    17d0:	1301197a 	movwne	r1, #6522	@ 0x197a
    17d4:	0a0f0000 	beq	3c17dc <__ROM_SIZE__+0x3817dc>
          fmt++;
    17d8:	3a0e0300 	bcc	3823e0 <__ROM_SIZE__+0x3423e0>
          continue;
    17dc:	0b3b0121 	bleq	ec1c68 <__ROM_SIZE__+0xe81c68>
        while (*fmt && ((*fmt >= '0' && *fmt <= '9') || *fmt == '-')) {
    17e0:	11012139 	tstne	r1, r9, lsr r1
    17e4:	10000001 	andne	r0, r0, r1
    17e8:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
    17ec:	0e030b13 	vmoveq.32	d3[0], r0
    17f0:	01110e1b 	tsteq	r1, fp, lsl lr
        switch (*fmt) {
    17f4:	17100612 			@ <UNDEFINED> instruction: 0x17100612
    17f8:	24110000 	ldrcs	r0, [r1], #-0
    17fc:	3e0b0b00 	vmlacc.f64	d0, d11, d0
    1800:	0008030b 	andeq	r0, r8, fp, lsl #6
            __write_char__(*fmt);
    1804:	00161200 	andseq	r1, r6, r0, lsl #4
    1808:	0b3a0803 	bleq	e8381c <__ROM_SIZE__+0xe4381c>
            state = CHECK_CH;
    180c:	0b390b3b 	bleq	e44500 <__ROM_SIZE__+0xe04500>
            break;
    1810:	00001349 	andeq	r1, r0, r9, asr #6
    1814:	27011513 	smladcs	r1, r3, r5, r1
            outstr(va_arg(args, const char *));
    1818:	01134919 	tsteq	r3, r9, lsl r9
    181c:	14000013 	strne	r0, [r0], #-19	@ 0xffffffed
    1820:	13490026 	movtne	r0, #36902	@ 0x9026
            fmt++;
    1824:	13150000 	tstne	r5, #0
            break;
    1828:	3a0b0b01 	bcc	2c4434 <__ROM_SIZE__+0x284434>
            __write_char__(va_arg(args, int));
    182c:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    1830:	0013010b 	andseq	r0, r3, fp, lsl #2
    1834:	00181600 	andseq	r1, r8, r0, lsl #12
            fmt++;
    1838:	0b170000 	bleq	5c1840 <__ROM_SIZE__+0x581840>
            break;
    183c:	01175501 	tsteq	r7, r1, lsl #10
            if (*fmt == 'l') {
    1840:	18000013 	stmdane	r0, {r0, r1, r4}
    1844:	08030034 	stmdaeq	r3, {r2, r4, r5}
            if (printf_numbers(*fmt, &args, l_count)) {
    1848:	0b3b0b3a 	bleq	ec4538 <__ROM_SIZE__+0xe84538>
    184c:	13490b39 	movtne	r0, #39737	@ 0x9b39
    1850:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
              state = CHECK_CH;
    1854:	19000017 	stmdbne	r0, {r0, r1, r2, r4}
              fmt++;
    1858:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
              l_count++;
    185c:	0b3a0803 	bleq	e83870 <__ROM_SIZE__+0xe43870>
            if (printf_numbers(*fmt, &args, 0)) {
    1860:	0b390b3b 	bleq	e44554 <__ROM_SIZE__+0xe04554>
    1864:	13491927 	movtne	r1, #39207	@ 0x9927
              fmt++;
    1868:	06120111 			@ <UNDEFINED> instruction: 0x06120111
              break;
    186c:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
            return -1;
    1870:	00001301 	andeq	r1, r0, r1, lsl #6
}
    1874:	3f012e1a 	svccc	0x00012e1a
    1878:	3a080319 	bcc	2024e4 <__ROM_SIZE__+0x1c24e4>
            return -1;
    187c:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    1880:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
    1884:	12011113 	andne	r1, r1, #-1073741820	@ 0xc0000004
static void outstr2(const char *str) {
    1888:	7a184006 	bvc	6118a8 <__ROM_SIZE__+0x5d18a8>
  while (*str != '\0') {
    188c:	00000019 	andeq	r0, r0, r9, lsl r0
    __write_char2__(*str);
    1890:	02004901 	andeq	r4, r0, #16384	@ 0x4000
    str++;
    1894:	00187e18 	andseq	r7, r8, r8, lsl lr
  while (*str != '\0') {
    1898:	01480200 	mrseq	r0, (UNDEF: 104)
}
    189c:	137f017d 	cmnne	pc, #1073741855	@ 0x4000001f
    18a0:	00001301 	andeq	r1, r0, r1, lsl #6
static bool printf2_numbers(const char fmt, va_list *args, int l_count) {
    18a4:	03003403 	movweq	r3, #1027	@ 0x403
    18a8:	01213a08 			@ <UNDEFINED> instruction: 0x01213a08
  switch (fmt) {
    18ac:	0b39053b 	bleq	e42da0 <__ROM_SIZE__+0xe02da0>
    18b0:	17021349 	strne	r1, [r2, -r9, asr #6]
    18b4:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
      if (l_count == 0) {
    18b8:	01480400 	cmpeq	r8, r0, lsl #8
    18bc:	137f017d 	cmnne	pc, #1073741855	@ 0x4000001f
        value = va_arg(*args, unsigned int);
    18c0:	05050000 	streq	r0, [r5, #-0]
    18c4:	3a080300 	bcc	2024cc <__ROM_SIZE__+0x1c24cc>
      if (fmt == 'u') {
    18c8:	053b0121 	ldreq	r0, [fp, #-289]!	@ 0xfffffedf
        if (value == 0) {
    18cc:	13490b39 	movtne	r0, #39737	@ 0x9b39
          __write_char2__(hextable2[0]);
    18d0:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
    18d4:	06000017 			@ <UNDEFINED> instruction: 0x06000017
  return true;
    18d8:	0b0b0024 	bleq	2c1970 <__ROM_SIZE__+0x281970>
  switch (fmt) {
    18dc:	0e030b3e 	vmoveq.16	d3[0], r0
      outstr2("\nprintf2-error\n");
    18e0:	05070000 	streq	r0, [r7, #-0]
      return false;
    18e4:	3a0e0300 	bcc	3824ec <__ROM_SIZE__+0x3424ec>
}
    18e8:	053b0121 	ldreq	r0, [fp, #-289]!	@ 0xfffffedf
      if (l_count == 0) {
    18ec:	13490b39 	movtne	r0, #39737	@ 0x9b39
        value = va_arg(*args, int);
    18f0:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
    18f4:	08000017 	stmdaeq	r0, {r0, r1, r2, r4}
      if (value < 0) {
    18f8:	0e03012e 	adfeqsp	f0, f3, #0.5
        num[num_len++] = hextable2[value % 10];
    18fc:	3b01213a 	blcc	49dec <__ROM_SIZE__+0x9dec>
    1900:	0d213905 			@ <UNDEFINED> instruction: 0x0d213905
    1904:	01111927 	tsteq	r1, r7, lsr #18
    1908:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
    190c:	1301197a 	movwne	r1, #6522	@ 0x197a
    1910:	05090000 	streq	r0, [r9, #-0]
    1914:	3a080300 	bcc	20251c <__ROM_SIZE__+0x1c251c>
    1918:	0b3b0121 	bleq	ec1da4 <__ROM_SIZE__+0xe81da4>
    191c:	13490b39 	movtne	r0, #39737	@ 0x9b39
        value = value / 10;
    1920:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
      } while (value > 0);
    1924:	0a000017 	beq	1988 <printf2_numbers+0xe4>
    1928:	13490021 	movtne	r0, #36897	@ 0x9021
        __write_char2__('-');
    192c:	00000b2f 	andeq	r0, r0, pc, lsr #22
    1930:	0300340b 	movweq	r3, #1035	@ 0x40b
        value = -value;
    1934:	01213a08 			@ <UNDEFINED> instruction: 0x01213a08
        __write_char2__(num[--num_len]);
    1938:	0b390b3b 	bleq	e4462c <__ROM_SIZE__+0xe0462c>
    193c:	17021349 	strne	r1, [r2, -r9, asr #6]
    1940:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
    1944:	000f0c00 	andeq	r0, pc, r0, lsl #24
    1948:	4904210b 	stmdbmi	r4, {r0, r1, r3, r8, sp}
      while (num_len > 0) {
    194c:	0d000013 	stceq	0, cr0, [r0, #-76]	@ 0xffffffb4
  return true;
    1950:	13490101 	movtne	r0, #37121	@ 0x9101
          num[num_len++] = hextable2[value % 10];
    1954:	00001301 	andeq	r1, r0, r1, lsl #6
    1958:	3f012e0e 	svccc	0x00012e0e
    195c:	3a0e0319 	bcc	3825c8 <__ROM_SIZE__+0x3425c8>
    1960:	053b0121 	ldreq	r0, [fp, #-289]!	@ 0xfffffedf
    1964:	27062139 	smladxcs	r6, r9, r1, r2
    1968:	12011119 	andne	r1, r1, #1073741830	@ 0x40000006
    196c:	7a184006 	bvc	61198c <__ROM_SIZE__+0x5d198c>
    1970:	00130119 	andseq	r0, r3, r9, lsl r1
          value = value / 10;
    1974:	00050f00 	andeq	r0, r5, r0, lsl #30
        } while (value > 0);
    1978:	213a0e03 	teqcs	sl, r3, lsl #28
        while (num_len > 0) {
    197c:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
          __write_char2__(num[--num_len]);
    1980:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
    1984:	10000018 	andne	r0, r0, r8, lsl r0
    1988:	13490026 	movtne	r0, #36902	@ 0x9026
    198c:	34110000 	ldrcc	r0, [r1], #-0
    1990:	3a0e0300 	bcc	382598 <__ROM_SIZE__+0x342598>
    1994:	0b3b0121 	bleq	ec1e20 <__ROM_SIZE__+0xe81e20>
  return true;
    1998:	13490b39 	movtne	r0, #39737	@ 0x9b39
              __write_char2__(hextable2[val]);
    199c:	00001802 	andeq	r1, r0, r2, lsl #16
    19a0:	03003412 	movweq	r3, #1042	@ 0x412
              leading_zero_ignored = true;
    19a4:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
          while (start_bit >= 0) {
    19a8:	2139053b 	teqcs	r9, fp, lsr r5
            int val = (value >> start_bit) & 0xF;
    19ac:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
            if (val || leading_zero_ignored) {
    19b0:	1742b717 	smlaldne	fp, r2, r7, r7
    19b4:	16130000 	ldrne	r0, [r3], -r0
    19b8:	3a0e0300 	bcc	3825c0 <__ROM_SIZE__+0x3425c0>
          bool leading_zero_ignored = false;
    19bc:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
          int start_bit = LAST_NIBBLE_FIRST_BIT;
    19c0:	0013490b 	andseq	r4, r3, fp, lsl #18
  return true;
    19c4:	00051400 	andeq	r1, r5, r0, lsl #8
        return false;
    19c8:	00001349 	andeq	r1, r0, r9, asr #6
        return false;
    19cc:	03000515 	movweq	r0, #1301	@ 0x515
    19d0:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
    19d4:	0b39053b 	bleq	e42ec8 <__ROM_SIZE__+0xe02ec8>
    19d8:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
    19dc:	2e160000 	cdpcs	0, 1, cr0, cr6, cr0, {0}
    19e0:	3a0e0301 	bcc	3825ec <__ROM_SIZE__+0x3425ec>
int printf2(const char *fmt, ...) {
    19e4:	0b3b0121 	bleq	ec1e70 <__ROM_SIZE__+0xe81e70>
    19e8:	270d2139 	smladxcs	sp, r9, r1, r2
    19ec:	12011119 	andne	r1, r1, #1073741830	@ 0x40000006
  va_start(args, fmt);
    19f0:	7a184006 	bvc	611a10 <__ROM_SIZE__+0x5d1a10>
  while (*fmt) {
    19f4:	00130119 	andseq	r0, r3, r9, lsl r1
        if (*fmt == '%') {
    19f8:	012e1700 			@ <UNDEFINED> instruction: 0x012e1700
        __write_char2__(*fmt);
    19fc:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
        fmt++;
    1a00:	3b01213a 	blcc	49ef0 <__ROM_SIZE__+0x9ef0>
  while (*fmt) {
    1a04:	0621390b 	strteq	r3, [r1], -fp, lsl #18
    switch (state) {
    1a08:	01111927 	tsteq	r1, r7, lsr #18
    1a0c:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
          fmt++;
    1a10:	1301197a 	movwne	r1, #6522	@ 0x197a
          continue;
    1a14:	34180000 	ldrcc	r0, [r8], #-0
        while (*fmt && ((*fmt >= '0' && *fmt <= '9') || *fmt == '-')) {
    1a18:	3a0e0300 	bcc	382620 <__ROM_SIZE__+0x342620>
    1a1c:	053b0121 	ldreq	r0, [fp, #-289]!	@ 0xfffffedf
    1a20:	490b2139 	stmdbmi	fp, {r0, r3, r4, r5, r8, sp}
    1a24:	00180213 	andseq	r0, r8, r3, lsl r2
    1a28:	00051900 	andeq	r1, r5, r0, lsl #18
        switch (*fmt) {
    1a2c:	213a0803 	teqcs	sl, r3, lsl #16
    1a30:	ec213b01 			@ <UNDEFINED> instruction: 0xec213b01
    1a34:	490b3903 	stmdbmi	fp, {r0, r1, r8, fp, ip, sp}
    1a38:	00180213 	andseq	r0, r8, r3, lsl r2
            __write_char2__(*fmt);
    1a3c:	01111a00 	tsteq	r1, r0, lsl #20
    1a40:	0b130e25 	bleq	4c52dc <__ROM_SIZE__+0x4852dc>
            state = CHECK_CH;
    1a44:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
            break;
    1a48:	06120111 			@ <UNDEFINED> instruction: 0x06120111
    1a4c:	00001710 	andeq	r1, r0, r0, lsl r7
            outstr2(va_arg(args, const char *));
    1a50:	0b00241b 	bleq	aac4 <__RAM_SIZE__+0x2ac4>
    1a54:	030b3e0b 	movweq	r3, #48651	@ 0xbe0b
    1a58:	1c000008 	stcne	0, cr0, [r0], {8}
            fmt++;
    1a5c:	0e030113 	mcreq	1, 0, r0, cr3, cr3, {0}
            break;
    1a60:	0b3a050b 	bleq	e82e94 <__ROM_SIZE__+0xe42e94>
            __write_char2__(va_arg(args, int));
    1a64:	0b390b3b 	bleq	e44758 <__ROM_SIZE__+0xe04758>
    1a68:	00001301 	andeq	r1, r0, r1, lsl #6
    1a6c:	03000d1d 	movweq	r0, #3357	@ 0xd1d
            fmt++;
    1a70:	3b0b3a0e 	blcc	2d02b0 <__ROM_SIZE__+0x2902b0>
            break;
    1a74:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
            if (*fmt == 'l') {
    1a78:	000b3813 	andeq	r3, fp, r3, lsl r8
    1a7c:	000d1e00 	andeq	r1, sp, r0, lsl #28
            if (printf2_numbers(*fmt, &args, l_count)) {
    1a80:	0b3a0803 	bleq	e83a94 <__ROM_SIZE__+0xe43a94>
    1a84:	0b390b3b 	bleq	e44778 <__ROM_SIZE__+0xe04778>
    1a88:	0b381349 	bleq	e067b4 <__ROM_SIZE__+0xdc67b4>
              state = CHECK_CH;
    1a8c:	2e1f0000 	cdpcs	0, 1, cr0, cr15, cr0, {0}
              fmt++;
    1a90:	03193f01 	tsteq	r9, #1, 30
              l_count++;
    1a94:	3b0b3a0e 	blcc	2d02d4 <__ROM_SIZE__+0x2902d4>
            if (printf2_numbers(*fmt, &args, 0)) {
    1a98:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
    1a9c:	3c134919 			@ <UNDEFINED> instruction: 0x3c134919
              fmt++;
    1aa0:	00130119 	andseq	r0, r3, r9, lsl r1
              break;
    1aa4:	000f2000 	andeq	r2, pc, r0
            return -1;
    1aa8:	00000b0b 	andeq	r0, r0, fp, lsl #22
}
    1aac:	00002621 	andeq	r2, r0, r1, lsr #12
    1ab0:	012e2200 			@ <UNDEFINED> instruction: 0x012e2200
            return -1;
    1ab4:	0b3a0e03 	bleq	e852c8 <__ROM_SIZE__+0xe452c8>
    1ab8:	0b39053b 	bleq	e42fac <__ROM_SIZE__+0xe02fac>
    1abc:	13491927 	movtne	r1, #39207	@ 0x9927
int r32(int argc, char *argv[]) {
    1ac0:	06120111 			@ <UNDEFINED> instruction: 0x06120111
  if (argc < 2) {
    1ac4:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
  uint32_t addr = atoh(argv[1]);
    1ac8:	00001301 	andeq	r1, r0, r1, lsl #6
    1acc:	11010b23 	tstne	r1, r3, lsr #22
  printf("0x%x: 0x%x\n", addr, data);
    1ad0:	00061201 	andeq	r1, r6, r1, lsl #4
    1ad4:	00342400 	eorseq	r2, r4, r0, lsl #8
}
    1ad8:	0b3a0e03 	bleq	e852ec <__ROM_SIZE__+0xe452ec>
    printf("Usage: %s <address> (in hex)\n", argv[0]);
    1adc:	0b390b3b 	bleq	e447d0 <__ROM_SIZE__+0xe047d0>
    1ae0:	17021349 	strne	r1, [r2, -r9, asr #6]
    return -1;
    1ae4:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
    1ae8:	01012500 	tsteq	r1, r0, lsl #10
    1aec:	00001349 	andeq	r1, r0, r9, asr #6
int w32(int argc, char *argv[]) {
    1af0:	00490100 	subeq	r0, r9, r0, lsl #2
  if (argc < 3) {
    1af4:	187e1802 	ldmdane	lr!, {r1, fp, ip}^
  uint32_t addr = atoh(argv[1]);
    1af8:	48020000 	stmdami	r2, {}	@ <UNPREDICTABLE>
    1afc:	7f017d01 	svcvc	0x00017d01
  uint32_t data = atoh(argv[2]);
    1b00:	00130113 	andseq	r0, r3, r3, lsl r1
    1b04:	00050300 	andeq	r0, r5, r0, lsl #6
  return 0;
    1b08:	213a0803 	teqcs	sl, r3, lsl #16
    printf("Usage: %s <address> (in hex) <value> (in hex)\n", argv[0]);
    1b0c:	39053b01 	stmdbcc	r5, {r0, r8, r9, fp, ip, sp}
    1b10:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
    return -1;
    1b14:	1742b717 	smlaldne	fp, r2, r7, r7
    1b18:	48040000 	stmdami	r4, {}	@ <UNPREDICTABLE>
    1b1c:	7f017d01 	svcvc	0x00017d01
int read_mem(int argc, char *argv[]) {
    1b20:	05000013 	streq	r0, [r0, #-19]	@ 0xffffffed
  if (argc < 3) {
    1b24:	08030034 	stmdaeq	r3, {r2, r4, r5}
  uint32_t addr = atoh(argv[1]);
    1b28:	3b01213a 	blcc	4a018 <__ROM_SIZE__+0xa018>
    1b2c:	490b3905 	stmdbmi	fp, {r0, r2, r8, fp, ip, sp}
  uint32_t length = atoi(argv[2]);
    1b30:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
    1b34:	00001742 	andeq	r1, r0, r2, asr #14
  for (uint32_t i = 0, data = 0; i < length; i++) {
    1b38:	03003406 	movweq	r3, #1030	@ 0x406
    printf("Usage: %s <address> (in hex) <num_words> (in decimal)\n", argv[0]);
    1b3c:	01213a08 			@ <UNDEFINED> instruction: 0x01213a08
    1b40:	0b39053b 	bleq	e43034 <__ROM_SIZE__+0xe03034>
    return -1;
    1b44:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
    1b48:	2e070000 	cdpcs	0, 0, cr0, cr7, cr0, {0}
    printf("0x%x: 0x%x\n", addr, data);
    1b4c:	3a0e0301 	bcc	382758 <__ROM_SIZE__+0x342758>
    1b50:	053b0121 	ldreq	r0, [fp, #-289]!	@ 0xfffffedf
    addr += 4;
    1b54:	270d2139 	smladxcs	sp, r9, r1, r2
  for (uint32_t i = 0, data = 0; i < length; i++) {
    1b58:	12011119 	andne	r1, r1, #1073741830	@ 0x40000006
  return 0;
    1b5c:	7a184006 	bvc	611b7c <__ROM_SIZE__+0x5d1b7c>
}
    1b60:	00130119 	andseq	r0, r3, r9, lsl r1
    1b64:	00240800 	eoreq	r0, r4, r0, lsl #16
{
    1b68:	0b3e0b0b 	bleq	f8479c <__ROM_SIZE__+0xf4479c>
  if (argc < 4) {
    1b6c:	00000e03 	andeq	r0, r0, r3, lsl #28
  uint32_t addr = atoh(argv[1]);
    1b70:	03000509 	movweq	r0, #1289	@ 0x509
    1b74:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
  uint32_t bit_loc = atoi(argv[2]);
    1b78:	0b39053b 	bleq	e4306c <__ROM_SIZE__+0xe0306c>
    1b7c:	17021349 	strne	r1, [r2, -r9, asr #6]
  uint32_t bit_val = atoi(argv[3]);
    1b80:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
    1b84:	00050a00 	andeq	r0, r5, r0, lsl #20
  if (bit_loc > 31) {
    1b88:	213a0803 	teqcs	sl, r3, lsl #16
  if (bit_val != 0 && bit_val != 1) {
    1b8c:	39053b01 	stmdbcc	r5, {r0, r8, r9, fp, ip, sp}
  data = data | (bit_val << bit_loc);
    1b90:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
    1b94:	0b000018 	bleq	1bfc <r32_bit+0x2c>
  data = data & ~(!bit_val << bit_loc);
    1b98:	08030005 	stmdaeq	r3, {r0, r2}
    1b9c:	3b01213a 	blcc	4a08c <__ROM_SIZE__+0xa08c>
    1ba0:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
  return 0;
    1ba4:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
    printf("Error: Invalid bit location argument\n");
    1ba8:	00001742 	andeq	r1, r0, r2, asr #14
    1bac:	0300340c 	movweq	r3, #1036	@ 0x40c
    printf("Error: Invalid bit value argument\n");
    1bb0:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
    1bb4:	21390b3b 	teqcs	r9, fp, lsr fp
  printf("Usage: %s <address_in_hex(32-bits)> <bit_location_in_decimal(0 to 31)> <bit_value(0 or 1)>\n", argv[0]);
    1bb8:	3f134911 	svccc	0x00134911
    1bbc:	00180219 	andseq	r0, r8, r9, lsl r2
  return -1;
    1bc0:	012e0d00 			@ <UNDEFINED> instruction: 0x012e0d00
    1bc4:	213a0e03 	teqcs	sl, r3, lsl #28
    1bc8:	39053b01 	stmdbcc	r5, {r0, r8, r9, fp, ip, sp}
    1bcc:	19270c21 	stmdbne	r7!, {r0, r5, sl, fp}
{
    1bd0:	01111349 	tsteq	r1, r9, asr #6
  if (argc < 3) {
    1bd4:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
  uint32_t addr = atoh(argv[1]);
    1bd8:	1301197a 	movwne	r1, #6522	@ 0x197a
    1bdc:	050e0000 	streq	r0, [lr, #-0]
  uint32_t bit_loc = atoi(argv[2]);
    1be0:	3a080300 	bcc	2027e8 <__ROM_SIZE__+0x1c27e8>
    1be4:	0b3b0121 	bleq	ec2070 <__ROM_SIZE__+0xe82070>
  if (bit_loc > 31) {
    1be8:	13490b39 	movtne	r0, #39737	@ 0x9b39
  uint32_t data = reg32(addr);
    1bec:	00001802 	andeq	r1, r0, r2, lsl #16
  printf("Bit %u @ 0x%08x: %u\n", bit_loc, addr, bit_val);
    1bf0:	0300160f 	movweq	r1, #1551	@ 0x60f
    1bf4:	3b0b3a0e 	blcc	2d0434 <__ROM_SIZE__+0x290434>
    1bf8:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
  return 0;
    1bfc:	10000013 	andne	r0, r0, r3, lsl r0
    printf("Error: Invalid bit location argument\n");
    1c00:	0111010b 	tsteq	r1, fp, lsl #2
    1c04:	13010612 	movwne	r0, #5650	@ 0x1612
  printf("Usage: %s <address_in_hex(32-bits)> <bit_location_in_decimal(0 to 31)\n", argv[0]);
    1c08:	0f110000 	svceq	0x00110000
    1c0c:	04210b00 	strteq	r0, [r1], #-2816	@ 0xfffff500
  return -1;
    1c10:	00001349 	andeq	r1, r0, r9, asr #6
    1c14:	03003412 	movweq	r3, #1042	@ 0x412
    1c18:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
    1c1c:	0b39053b 	bleq	e43110 <__ROM_SIZE__+0xe03110>
{
    1c20:	17021349 	strne	r1, [r2, -r9, asr #6]
  for (i = 0; i < Nk; ++i)
    1c24:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
    RoundKey[(i * 4) + 0] = Key[(i * 4) + 0];
    1c28:	012e1300 			@ <UNDEFINED> instruction: 0x012e1300
    1c2c:	213a0e03 	teqcs	sl, r3, lsl #28
    1c30:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
    RoundKey[(i * 4) + 1] = Key[(i * 4) + 1];
    1c34:	19270d21 	stmdbne	r7!, {r0, r5, r8, sl, fp}
    RoundKey[(i * 4) + 2] = Key[(i * 4) + 2];
    1c38:	06120111 			@ <UNDEFINED> instruction: 0x06120111
    1c3c:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
    RoundKey[(i * 4) + 3] = Key[(i * 4) + 3];
    1c40:	00001301 	andeq	r1, r0, r1, lsl #6
  for (i = 0; i < Nk; ++i)
    1c44:	49002614 	stmdbmi	r0, {r2, r4, r9, sl, sp}
    1c48:	15000013 	strne	r0, [r0, #-19]	@ 0xffffffed
  for (i = Nk; i < Nb * (Nr + 1); ++i)
    1c4c:	08030034 	stmdaeq	r3, {r2, r4, r5}
    if (i % Nk == 4)
    1c50:	3b01213a 	blcc	4a140 <__ROM_SIZE__+0xa140>
    j = i * 4; k=(i - Nk) * 4;
    1c54:	0721390b 	streq	r3, [r1, -fp, lsl #18]!
    RoundKey[j + 0] = RoundKey[k + 0] ^ tempa[0];
    1c58:	17021349 	strne	r1, [r2, -r9, asr #6]
    1c5c:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
    1c60:	012e1600 			@ <UNDEFINED> instruction: 0x012e1600
    1c64:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
    RoundKey[j + 1] = RoundKey[k + 1] ^ tempa[1];
    1c68:	3b01213a 	blcc	4a158 <__ROM_SIZE__+0xa158>
    1c6c:	05213905 	streq	r3, [r1, #-2309]!	@ 0xfffff6fb
    1c70:	13491927 	movtne	r1, #39207	@ 0x9927
    1c74:	06120111 			@ <UNDEFINED> instruction: 0x06120111
    1c78:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
    1c7c:	00001301 	andeq	r1, r0, r1, lsl #6
    RoundKey[j + 2] = RoundKey[k + 2] ^ tempa[2];
    1c80:	03003417 	movweq	r3, #1047	@ 0x417
    1c84:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
    1c88:	04f6213b 	ldrbteq	r2, [r6], #315	@ 0x13b
    1c8c:	13490b39 	movtne	r0, #39737	@ 0x9b39
    RoundKey[j + 3] = RoundKey[k + 3] ^ tempa[3];
    1c90:	00001802 	andeq	r1, r0, r2, lsl #16
    1c94:	55010b18 	strpl	r0, [r1, #-2840]	@ 0xfffff4e8
    1c98:	19000017 	stmdbne	r0, {r0, r1, r2, r4}
  for (i = Nk; i < Nb * (Nr + 1); ++i)
    1c9c:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
    1ca0:	0e030b13 	vmoveq.32	d3[0], r0
      tempa[0]=RoundKey[k + 0];
    1ca4:	01110e1b 	tsteq	r1, fp, lsl lr
    1ca8:	17100612 			@ <UNDEFINED> instruction: 0x17100612
      tempa[1]=RoundKey[k + 1];
    1cac:	241a0000 	ldrcs	r0, [sl], #-0
    1cb0:	3e0b0b00 	vmlacc.f64	d0, d11, d0
    1cb4:	0008030b 	andeq	r0, r8, fp, lsl #6
      tempa[2]=RoundKey[k + 2];
    1cb8:	01011b00 	tsteq	r1, r0, lsl #22
    1cbc:	13011349 	movwne	r1, #4937	@ 0x1349
      tempa[3]=RoundKey[k + 3];
    1cc0:	211c0000 	tstcs	ip, r0
    1cc4:	2f134900 	svccs	0x00134900
    if (i % Nk == 0)
    1cc8:	1d00000b 	stcne	0, cr0, [r0, #-44]	@ 0xffffffd4
        tempa[0] = tempa[1];
    1ccc:	0e03012e 	adfeqsp	f0, f3, #0.5
        tempa[1] = tempa[2];
    1cd0:	0b3b0b3a 	bleq	ec49c0 <__ROM_SIZE__+0xe849c0>
        tempa[2] = tempa[3];
    1cd4:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
        tempa[3] = u8tmp;
    1cd8:	01111349 	tsteq	r1, r9, asr #6
        tempa[0] = getSBoxValue(tempa[0]);
    1cdc:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
    1ce0:	1301197a 	movwne	r1, #6522	@ 0x197a
        tempa[1] = getSBoxValue(tempa[1]);
    1ce4:	341e0000 	ldrcc	r0, [lr], #-0
    1ce8:	3a080300 	bcc	2028f0 <__ROM_SIZE__+0x1c28f0>
        tempa[2] = getSBoxValue(tempa[2]);
    1cec:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    1cf0:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
        tempa[3] = getSBoxValue(tempa[3]);
    1cf4:	1f000018 	svcne	0x00000018
    1cf8:	0e03012e 	adfeqsp	f0, f3, #0.5
      tempa[0] = tempa[0] ^ Rcon[i/Nk];
    1cfc:	0b3b0b3a 	bleq	ec49ec <__ROM_SIZE__+0xe849ec>
    1d00:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
    1d04:	01111349 	tsteq	r1, r9, asr #6
    1d08:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
        tempa[0] = getSBoxValue(tempa[0]);
    1d0c:	0000197a 	andeq	r1, r0, sl, ror r9
    1d10:	00240100 	eoreq	r0, r4, r0, lsl #2
    1d14:	0b3e0b0b 	bleq	f84948 <__ROM_SIZE__+0xf44948>
        tempa[1] = getSBoxValue(tempa[1]);
    1d18:	00000e03 	andeq	r0, r0, r3, lsl #28
    1d1c:	03003402 	movweq	r3, #1026	@ 0x402
        tempa[2] = getSBoxValue(tempa[2]);
    1d20:	01213a08 			@ <UNDEFINED> instruction: 0x01213a08
    1d24:	0b390b3b 	bleq	e44a18 <__ROM_SIZE__+0xe04a18>
    1d28:	17021349 	strne	r1, [r2, -r9, asr #6]
        tempa[3] = getSBoxValue(tempa[3]);
    1d2c:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
    1d30:	00050300 	andeq	r0, r5, r0, lsl #6
    1d34:	213a0803 	teqcs	sl, r3, lsl #16
}
    1d38:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
    1d3c:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
{
    1d40:	1742b717 	smlaldne	fp, r2, r7, r7
  for (i = 0; i < 4; ++i)
    1d44:	0b040000 	bleq	101d4c <__ROM_SIZE__+0xc1d4c>
      (*state)[i][j] ^= RoundKey[(round * Nb * 4) + (i * Nb) + j];
    1d48:	00175501 	andseq	r5, r7, r1, lsl #10
    1d4c:	01110500 	tsteq	r1, r0, lsl #10
    1d50:	0b130e25 	bleq	4c55ec <__ROM_SIZE__+0x4855ec>
    1d54:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
    1d58:	06120111 			@ <UNDEFINED> instruction: 0x06120111
    1d5c:	00001710 	andeq	r1, r0, r0, lsl r7
    1d60:	03001606 	movweq	r1, #1542	@ 0x606
    for (j = 0; j < 4; ++j)
    1d64:	3b0b3a0e 	blcc	2d05a4 <__ROM_SIZE__+0x2905a4>
    1d68:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
  for (i = 0; i < 4; ++i)
    1d6c:	07000013 	smladeq	r0, r3, r0, r0
    1d70:	0b0b0024 	bleq	2c1e08 <__ROM_SIZE__+0x281e08>
    for (j = 0; j < 4; ++j)
    1d74:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
  for (i = 0; i < 4; ++i)
    1d78:	2e080000 	cdpcs	0, 0, cr0, cr8, cr0, {0}
    1d7c:	03193f01 	tsteq	r9, #1, 30
    for (j = 0; j < 4; ++j)
    1d80:	3b0b3a0e 	blcc	2d05c0 <__ROM_SIZE__+0x2905c0>
{
    1d84:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
      (*state)[j][i] = getSBoxValue((*state)[j][i]);
    1d88:	11134919 	tstne	r3, r9, lsl r9
    1d8c:	40061201 	andmi	r1, r6, r1, lsl #4
    1d90:	01197a18 	tsteq	r9, r8, lsl sl
    1d94:	09000013 	stmdbeq	r0, {r0, r1, r4}
    for (j = 0; j < 4; ++j)
    1d98:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    1d9c:	0b3b0b3a 	bleq	ec4a8c <__ROM_SIZE__+0xe84a8c>
  for (i = 0; i < 4; ++i)
    1da0:	13490b39 	movtne	r0, #39737	@ 0x9b39
    1da4:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
    for (j = 0; j < 4; ++j)
    1da8:	0a000017 	beq	1e0c <MixColumns+0xc>
}
    1dac:	0b0b000f 	bleq	2c1df0 <__ROM_SIZE__+0x281df0>
  for (i = 0; i < 4; ++i)
    1db0:	00001349 	andeq	r1, r0, r9, asr #6
    1db4:	4900260b 	stmdbmi	r0, {r0, r1, r3, r9, sl, sp}
    1db8:	0c000013 	stceq	0, cr0, [r0], {19}
  temp           = (*state)[0][1];
    1dbc:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
  (*state)[0][1] = (*state)[1][1];
    1dc0:	0b3a0e03 	bleq	e855d4 <__ROM_SIZE__+0xe455d4>
  (*state)[1][1] = (*state)[2][1];
    1dc4:	0b390b3b 	bleq	e44ab8 <__ROM_SIZE__+0xe04ab8>
  (*state)[2][1] = (*state)[3][1];
    1dc8:	13491927 	movtne	r1, #39207	@ 0x9927
  temp           = (*state)[0][2];
    1dcc:	06120111 			@ <UNDEFINED> instruction: 0x06120111
  (*state)[0][2] = (*state)[2][2];
    1dd0:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
  temp           = (*state)[1][2];
    1dd4:	01000000 	mrseq	r0, (UNDEF: 0)
  (*state)[1][2] = (*state)[3][2];
    1dd8:	0b0b0024 	bleq	2c1e70 <__ROM_SIZE__+0x281e70>
  temp           = (*state)[0][3];
    1ddc:	0e030b3e 	vmoveq.16	d3[0], r0
  (*state)[0][3] = (*state)[3][3];
    1de0:	16020000 	strne	r0, [r2], -r0
  (*state)[3][3] = (*state)[2][3];
    1de4:	3a0e0300 	bcc	3829ec <__ROM_SIZE__+0x3429ec>
  (*state)[2][3] = (*state)[1][3];
    1de8:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
}
    1dec:	0013490b 	andseq	r4, r3, fp, lsl #18
  return ((x<<1) ^ (((x>>7) & 1) * 0x1b));
    1df0:	000d0300 	andeq	r0, sp, r0, lsl #6
    1df4:	213a0e03 	teqcs	sl, r3, lsl #28
    1df8:	390b3b03 	stmdbcc	fp, {r0, r1, r8, r9, fp, ip, sp}
}
    1dfc:	3813490b 	ldmdacc	r3, {r0, r1, r3, r8, fp, lr}
{
    1e00:	0400000b 	streq	r0, [r0], #-11
    1e04:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
  for (i = 0; i < 4; ++i)
    1e08:	3b01213a 	blcc	4a2f8 <__ROM_SIZE__+0xa2f8>
    t   = (*state)[i][0];
    1e0c:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
    Tmp = (*state)[i][0] ^ (*state)[i][1] ^ (*state)[i][2] ^ (*state)[i][3] ;
    1e10:	00180213 	andseq	r0, r8, r3, lsl r2
    1e14:	00050500 	andeq	r0, r5, r0, lsl #10
    1e18:	00001349 	andeq	r1, r0, r9, asr #6
    1e1c:	03000506 	movweq	r0, #1286	@ 0x506
    1e20:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
    1e24:	3917213b 	ldmdbcc	r7, {r0, r1, r3, r4, r5, r8, sp}
    Tm  = (*state)[i][0] ^ (*state)[i][1] ; Tm = xtime(Tm);  (*state)[i][0] ^= Tm ^ Tmp ;
    1e28:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
    1e2c:	1742b717 	smlaldne	fp, r2, r7, r7
    1e30:	28070000 	stmdacs	r7, {}	@ <UNPREDICTABLE>
    Tm  = (*state)[i][1] ^ (*state)[i][2] ; Tm = xtime(Tm);  (*state)[i][1] ^= Tm ^ Tmp ;
    1e34:	1c0e0300 	stcne	3, cr0, [lr], {-0}
    1e38:	0800000b 	stmdaeq	r0, {r0, r1, r3}
    1e3c:	08030028 	stmdaeq	r3, {r3, r5}
    1e40:	00000b1c 	andeq	r0, r0, ip, lsl fp
    1e44:	0b000f09 	bleq	5a70 <base_order+0x21f0>
    Tm  = (*state)[i][2] ^ (*state)[i][3] ; Tm = xtime(Tm);  (*state)[i][2] ^= Tm ^ Tmp ;
    1e48:	13490421 	movtne	r0, #37921	@ 0x9421
    1e4c:	2e0a0000 	cdpcs	0, 0, cr0, cr10, cr0, {0}
    1e50:	03193f01 	tsteq	r9, #1, 30
    1e54:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
    Tm  = (*state)[i][3] ^ t ;              Tm = xtime(Tm);  (*state)[i][3] ^= Tm ^ Tmp ;
    1e58:	21390b3b 	teqcs	r9, fp, lsr fp
    1e5c:	11192706 	tstne	r9, r6, lsl #14
    1e60:	40061201 	andmi	r1, r6, r1, lsl #4
    1e64:	01197a18 	tsteq	r9, r8, lsl sl
    1e68:	0b000013 	bleq	1ebc <InvMixColumns+0x46>
  for (i = 0; i < 4; ++i)
    1e6c:	18020049 	stmdane	r2, {r0, r3, r6}
    1e70:	0000187e 	andeq	r1, r0, lr, ror r8
}
    1e74:	2501110c 	strcs	r1, [r1, #-268]	@ 0xfffffef4
{
    1e78:	030b130e 	movweq	r1, #45838	@ 0xb30e
    1e7c:	110e1b0e 	tstne	lr, lr, lsl #22
  for (i = 0; i < 4; ++i)
    1e80:	10061201 	andne	r1, r6, r1, lsl #4
    a = (*state)[i][0];
    1e84:	0d000017 	stceq	0, cr0, [r0, #-92]	@ 0xffffffa4
    b = (*state)[i][1];
    1e88:	13490035 	movtne	r0, #36917	@ 0x9035
    1e8c:	240e0000 	strcs	r0, [lr], #-0
    c = (*state)[i][2];
    1e90:	3e0b0b00 	vmlacc.f64	d0, d11, d0
    d = (*state)[i][3];
    1e94:	0008030b 	andeq	r0, r8, fp, lsl #6
    (*state)[i][0] = Multiply(a, 0x0e) ^ Multiply(b, 0x0b) ^ Multiply(c, 0x0d) ^ Multiply(d, 0x09);
    1e98:	01040f00 	tsteq	r4, r0, lsl #30
    1e9c:	0b3e0e03 	bleq	f856b0 <__ROM_SIZE__+0xf456b0>
    1ea0:	13490b0b 	movtne	r0, #39691	@ 0x9b0b
    1ea4:	0b3b0b3a 	bleq	ec4b94 <__ROM_SIZE__+0xe84b94>
    1ea8:	13010b39 	movwne	r0, #6969	@ 0x1b39
    1eac:	13100000 	tstne	r0, #0
    1eb0:	0b0e0301 	bleq	382abc <__ROM_SIZE__+0x342abc>
    1eb4:	3b0b3a0b 	blcc	2d06e8 <__ROM_SIZE__+0x2906e8>
    1eb8:	010b390b 	tsteq	fp, fp, lsl #18
    1ebc:	11000013 	tstne	r0, r3, lsl r0
    1ec0:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
    1ec4:	0b3a0e03 	bleq	e856d8 <__ROM_SIZE__+0xe456d8>
    1ec8:	0b390b3b 	bleq	e44bbc <__ROM_SIZE__+0xe04bbc>
    1ecc:	13491927 	movtne	r1, #39207	@ 0x9927
    1ed0:	1301193c 	movwne	r1, #6460	@ 0x193c
    1ed4:	0f120000 	svceq	0x00120000
    1ed8:	000b0b00 	andeq	r0, fp, r0, lsl #22
    1edc:	00051300 	andeq	r1, r5, r0, lsl #6
    1ee0:	0b3a0803 	bleq	e83ef4 <__ROM_SIZE__+0xe43ef4>
    1ee4:	0b390b3b 	bleq	e44bd8 <__ROM_SIZE__+0xe04bd8>
    1ee8:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
    1eec:	2e140000 	cdpcs	0, 1, cr0, cr4, cr0, {0}
    1ef0:	03193f01 	tsteq	r9, #1, 30
    1ef4:	3b0b3a0e 	blcc	2d0734 <__ROM_SIZE__+0x290734>
    1ef8:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
    1efc:	11134919 	tstne	r3, r9, lsl r9
    1f00:	40061201 	andmi	r1, r6, r1, lsl #4
    1f04:	01197a18 	tsteq	r9, r8, lsl sl
    1f08:	15000013 	strne	r0, [r0, #-19]	@ 0xffffffed
    1f0c:	08030034 	stmdaeq	r3, {r2, r4, r5}
    1f10:	0b3b0b3a 	bleq	ec4c00 <__ROM_SIZE__+0xe84c00>
    1f14:	13490b39 	movtne	r0, #39737	@ 0x9b39
    1f18:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
    1f1c:	16000017 			@ <UNDEFINED> instruction: 0x16000017
    1f20:	017d0148 	cmneq	sp, r8, asr #2
    1f24:	0000137f 	andeq	r1, r0, pc, ror r3
    (*state)[i][1] = Multiply(a, 0x09) ^ Multiply(b, 0x0e) ^ Multiply(c, 0x0b) ^ Multiply(d, 0x0d);
    1f28:	00050100 	andeq	r0, r5, r0, lsl #2
    1f2c:	213a0e03 	teqcs	sl, r3, lsl #28
    1f30:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
    1f34:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
    1f38:	1742b717 	smlaldne	fp, r2, r7, r7
    1f3c:	24020000 	strcs	r0, [r2], #-0
    1f40:	3e0b0b00 	vmlacc.f64	d0, d11, d0
    1f44:	000e030b 	andeq	r0, lr, fp, lsl #6
    1f48:	012e0300 			@ <UNDEFINED> instruction: 0x012e0300
    1f4c:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
    1f50:	3b01213a 	blcc	4a440 <__ROM_SIZE__+0xa440>
    1f54:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
    1f58:	11134919 	tstne	r3, r9, lsl r9
    1f5c:	40061201 	andmi	r1, r6, r1, lsl #4
    (*state)[i][2] = Multiply(a, 0x0d) ^ Multiply(b, 0x09) ^ Multiply(c, 0x0e) ^ Multiply(d, 0x0b);
    1f60:	01197a18 	tsteq	r9, r8, lsl sl
    1f64:	04000013 	streq	r0, [r0], #-19	@ 0xffffffed
    1f68:	08030034 	stmdaeq	r3, {r2, r4, r5}
    1f6c:	3b01213a 	blcc	4a45c <__ROM_SIZE__+0xa45c>
    1f70:	0a21390b 	beq	8503a4 <__ROM_SIZE__+0x8103a4>
    1f74:	17021349 	strne	r1, [r2, -r9, asr #6]
    1f78:	001742b7 			@ <UNDEFINED> instruction: 0x001742b7
    1f7c:	00340500 	eorseq	r0, r4, r0, lsl #10
    1f80:	213a0e03 	teqcs	sl, r3, lsl #28
    1f84:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
    1f88:	13490921 	movtne	r0, #39201	@ 0x9921
    1f8c:	42b71702 	adcsmi	r1, r7, #524288	@ 0x80000
    (*state)[i][3] = Multiply(a, 0x0b) ^ Multiply(b, 0x0d) ^ Multiply(c, 0x09) ^ Multiply(d, 0x0e);
    1f90:	06000017 			@ <UNDEFINED> instruction: 0x06000017
    1f94:	210b000f 	tstcs	fp, pc
    1f98:	00134904 	andseq	r4, r3, r4, lsl #18
    1f9c:	00050700 	andeq	r0, r5, r0, lsl #14
    1fa0:	213a0803 	teqcs	sl, r3, lsl #16
    1fa4:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
    1fa8:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
    1fac:	08000018 	stmdaeq	r0, {r3, r4}
    1fb0:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
    1fb4:	3b01213a 	blcc	4a4a4 <__ROM_SIZE__+0xa4a4>
    1fb8:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
    1fbc:	00180213 	andseq	r0, r8, r3, lsl r2
    1fc0:	01110900 	tsteq	r1, r0, lsl #18
  for (i = 0; i < 4; ++i)
    1fc4:	0b130e25 	bleq	4c5860 <__ROM_SIZE__+0x485860>
    1fc8:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
}
    1fcc:	06120111 			@ <UNDEFINED> instruction: 0x06120111
  for (i = 0; i < 4; ++i)
    1fd0:	00001710 	andeq	r1, r0, r0, lsl r7
    1fd4:	0b00240a 	bleq	b004 <__RAM_SIZE__+0x3004>
    for (j = 0; j < 4; ++j)
    1fd8:	030b3e0b 	movweq	r3, #48651	@ 0xbe0b
{
    1fdc:	0b000008 	bleq	2004 <InvSubBytes+0x34>
      (*state)[j][i] = getSBoxInvert((*state)[j][i]);
    1fe0:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
    1fe4:	0b3b0b3a 	bleq	ec4cd4 <__ROM_SIZE__+0xe84cd4>
    1fe8:	13490b39 	movtne	r0, #39737	@ 0x9b39
    1fec:	0f0c0000 	svceq	0x000c0000
    1ff0:	000b0b00 	andeq	r0, fp, r0, lsl #22
    for (j = 0; j < 4; ++j)
    1ff4:	00260d00 	eoreq	r0, r6, r0, lsl #26
    1ff8:	00001349 	andeq	r1, r0, r9, asr #6
  for (i = 0; i < 4; ++i)
    1ffc:	0000260e 	andeq	r2, r0, lr, lsl #12
    2000:	012e0f00 			@ <UNDEFINED> instruction: 0x012e0f00
    for (j = 0; j < 4; ++j)
    2004:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
}
    2008:	0b3b0b3a 	bleq	ec4cf8 <__ROM_SIZE__+0xe84cf8>
  for (i = 0; i < 4; ++i)
    200c:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
    2010:	01111349 	tsteq	r1, r9, asr #6
    2014:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
  temp = (*state)[3][1];
    2018:	0000197a 	andeq	r1, r0, sl, ror r9
  (*state)[3][1] = (*state)[2][1];
    201c:	03000510 	movweq	r0, #1296	@ 0x510
  (*state)[2][1] = (*state)[1][1];
    2020:	3b0b3a08 	blcc	2d0848 <__ROM_SIZE__+0x290848>
  (*state)[1][1] = (*state)[0][1];
    2024:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
  temp = (*state)[0][2];
    2028:	b7170213 			@ <UNDEFINED> instruction: 0xb7170213
  (*state)[0][2] = (*state)[2][2];
    202c:	00001742 	andeq	r1, r0, r2, asr #14
	...

Disassembly of section .debug_loclists:

00000000 <.debug_loclists>:
       0:	000000ca 	andeq	r0, r0, sl, asr #1
       4:	00040005 	andeq	r0, r4, r5
	...
      14:	010a0004 	tsteq	sl, r4
      18:	140a0450 	strne	r0, [sl], #-1104	@ 0xfffffbb0
      1c:	5001a304 	andpl	sl, r1, r4, lsl #6
      20:	1c14049f 	cfldrsne	mvf0, [r4], {159}	@ 0x9f
      24:	1c045001 	stcne	0, cr5, [r4], {1}
      28:	01a30468 			@ <UNDEFINED> instruction: 0x01a30468
      2c:	00009f50 	andeq	r9, r0, r0, asr pc
	...
      38:	0d000400 	cfstrseq	mvf0, [r0, #-0]
      3c:	0d045101 	stfeqs	f5, [r4, #-4]
      40:	01a30414 			@ <UNDEFINED> instruction: 0x01a30414
      44:	14049f51 	strne	r9, [r4], #-3921	@ 0xfffff0af
      48:	0451011a 	ldrbeq	r0, [r1], #-282	@ 0xfffffee6
      4c:	53011f1a 	movwpl	r1, #7962	@ 0x1f1a
      50:	04681f04 	strbteq	r1, [r8], #-3844	@ 0xfffff0fc
      54:	9f5101a3 	svcls	0x005101a3
      58:	00000000 	andeq	r0, r0, r0
      5c:	72680400 	rsbvc	r0, r8, #0, 8
      60:	72045001 	andvc	r5, r4, #1
      64:	55010394 	strpl	r0, [r1, #-916]	@ 0xfffffc6c
      68:	00000000 	andeq	r0, r0, r0
      6c:	75680400 	strbvc	r0, [r8, #-1024]!	@ 0xfffffc00
      70:	75045101 	strvc	r5, [r4, #-257]	@ 0xfffffeff
      74:	56010394 			@ <UNDEFINED> instruction: 0x56010394
      78:	00000100 	andeq	r0, r0, r0, lsl #2
      7c:	00000000 	andeq	r0, r0, r0
      80:	04000000 	streq	r0, [r0], #-0
      84:	31027a76 	tstcc	r2, r6, ror sl
      88:	947a049f 	ldrbtls	r0, [sl], #-1183	@ 0xfffffb61
      8c:	04540101 	ldrbeq	r0, [r4], #-257	@ 0xfffffeff
      90:	01d8019a 			@ <UNDEFINED> instruction: 0x01d8019a
      94:	8a045401 	bhi	1150a0 <__ROM_SIZE__+0xd50a0>
      98:	0102a802 	tsteq	r2, r2, lsl #16
      9c:	02ce0454 	sbceq	r0, lr, #84, 8	@ 0x54000000
      a0:	54010394 	strpl	r0, [r1], #-916	@ 0xfffffc6c
      a4:	00000000 	andeq	r0, r0, r0
      a8:	04000000 	streq	r0, [r0], #-0
      ac:	01ee01ea 	mvneq	r0, sl, ror #3
      b0:	ee045001 	cdp	0, 0, cr5, cr4, cr1, {0}
      b4:	0101fa01 	tsteq	r1, r1, lsl #20	@ <UNPREDICTABLE>
      b8:	01fa0454 	mvnseq	r0, r4, asr r4
      bc:	730401fc 	movwvc	r0, #16892	@ 0x41fc
      c0:	009f7f98 	umullseq	r7, pc, r8, pc	@ <UNPREDICTABLE>
      c4:	b8040000 	stmdalt	r4, {}	@ <UNPREDICTABLE>
      c8:	0102c802 	tsteq	r2, r2, lsl #16
      cc:	002b0050 	eoreq	r0, fp, r0, asr r0
      d0:	00050000 	andeq	r0, r5, r0
      d4:	00000004 	andeq	r0, r0, r4
      d8:	00010000 	andeq	r0, r1, r0
      dc:	00000000 	andeq	r0, r0, r0
      e0:	00040000 	andeq	r0, r4, r0
      e4:	04500114 	ldrbeq	r0, [r0], #-276	@ 0xfffffeec
      e8:	a3041614 	movwge	r1, #17940	@ 0x4614
      ec:	049f5001 	ldreq	r5, [pc], #1	@ f4 <vector_table+0xf4>
      f0:	50011816 	andpl	r1, r1, r6, lsl r8
      f4:	04241804 	strteq	r1, [r4], #-2052	@ 0xfffff7fc
      f8:	9f5001a3 	svcls	0x005001a3
      fc:	00002b00 	andeq	r2, r0, r0, lsl #22
     100:	04000500 	streq	r0, [r0], #-1280	@ 0xfffffb00
     104:	00000000 	andeq	r0, r0, r0
     108:	00000100 	andeq	r0, r0, r0, lsl #2
     10c:	00000000 	andeq	r0, r0, r0
     110:	14000400 	strne	r0, [r0], #-1024	@ 0xfffffc00
     114:	14045001 	strne	r5, [r4], #-1
     118:	01a30416 			@ <UNDEFINED> instruction: 0x01a30416
     11c:	16049f50 			@ <UNDEFINED> instruction: 0x16049f50
     120:	04500118 	ldrbeq	r0, [r0], #-280	@ 0xfffffee8
     124:	a3042418 	movwge	r2, #17432	@ 0x4418
     128:	009f5001 	addseq	r5, pc, r1
     12c:	00000055 	andeq	r0, r0, r5, asr r0
     130:	00040005 	andeq	r0, r4, r5
	...
     13c:	010c0004 	tsteq	ip, r4
     140:	a40c0450 	strge	r0, [ip], #-1104	@ 0xfffffbb0
     144:	01a30401 			@ <UNDEFINED> instruction: 0x01a30401
     148:	00009f50 	andeq	r9, r0, r0, asr pc
     14c:	04000000 	streq	r0, [r0], #-0
     150:	51010c00 	tstpl	r1, r0, lsl #24
     154:	01a40c04 			@ <UNDEFINED> instruction: 0x01a40c04
     158:	5101a304 	tstpl	r1, r4, lsl #6
     15c:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
	...
     168:	01443404 	cmpeq	r4, r4, lsl #8
     16c:	64440450 	strbvs	r0, [r4], #-1104	@ 0xfffffbb0
     170:	64045401 	strvs	r5, [r4], #-1025	@ 0xfffffbff
     174:	04500168 	ldrbeq	r0, [r0], #-360	@ 0xfffffe98
     178:	54017468 	strpl	r7, [r1], #-1128	@ 0xfffffb98
     17c:	047f7404 	ldrbteq	r7, [pc], #-1028	@ 184 <vector_table+0x184>
     180:	9f7fb873 	svcls	0x007fb873
     184:	00007600 	andeq	r7, r0, r0, lsl #12
     188:	04000500 	streq	r0, [r0], #-1280	@ 0xfffffb00
	...
     194:	5e580400 	cdppl	4, 5, cr0, cr8, cr0, {0}
     198:	5e045001 	cdppl	0, 0, cr5, cr4, cr1, {0}
     19c:	a30401bc 	movwge	r0, #16828	@ 0x41bc
     1a0:	009f5001 	addseq	r5, pc, r1
     1a4:	00000000 	andeq	r0, r0, r0
     1a8:	01615804 	cmneq	r1, r4, lsl #16
     1ac:	bc610451 	cfstrdlt	mvd0, [r1], #-324	@ 0xfffffebc
     1b0:	01a30401 			@ <UNDEFINED> instruction: 0x01a30401
     1b4:	00009f51 	andeq	r9, r0, r1, asr pc
     1b8:	04000000 	streq	r0, [r0], #-0
     1bc:	5001302c 	andpl	r3, r1, ip, lsr #32
     1c0:	04583004 	ldrbeq	r3, [r8], #-4
     1c4:	9f5001a3 	svcls	0x005001a3
     1c8:	00000000 	andeq	r0, r0, r0
     1cc:	332c0400 			@ <UNDEFINED> instruction: 0x332c0400
     1d0:	33045101 	movwcc	r5, #16641	@ 0x4101
     1d4:	01a30458 			@ <UNDEFINED> instruction: 0x01a30458
     1d8:	00009f51 	andeq	r9, r0, r1, asr pc
     1dc:	04000000 	streq	r0, [r0], #-0
     1e0:	50010400 	andpl	r0, r1, r0, lsl #8
     1e4:	042c0404 	strteq	r0, [ip], #-1028	@ 0xfffffbfc
     1e8:	9f5001a3 	svcls	0x005001a3
     1ec:	00000000 	andeq	r0, r0, r0
     1f0:	07000400 	streq	r0, [r0, -r0, lsl #8]
     1f4:	07045101 	streq	r5, [r4, -r1, lsl #2]
     1f8:	01a3042c 			@ <UNDEFINED> instruction: 0x01a3042c
     1fc:	e5009f51 	str	r9, [r0, #-3921]	@ 0xfffff0af
     200:	05000000 	streq	r0, [r0, #-0]
     204:	00000400 	andeq	r0, r0, r0, lsl #8
	...
     210:	04000000 	streq	r0, [r0], #-0
     214:	50015c50 	andpl	r5, r1, r0, asr ip
     218:	01925c04 	orrseq	r5, r2, r4, lsl #24
     21c:	5001a304 	andpl	sl, r1, r4, lsl #6
     220:	0192049f 			@ <UNDEFINED> instruction: 0x0192049f
     224:	50010194 	mulpl	r1, r4, r1
     228:	ac019404 	cfstrsge	mvf9, [r1], {4}
     22c:	01a30401 			@ <UNDEFINED> instruction: 0x01a30401
     230:	00009f50 	andeq	r9, r0, r0, asr pc
     234:	00000000 	andeq	r0, r0, r0
     238:	04000000 	streq	r0, [r0], #-0
     23c:	51015f50 	tstpl	r1, r0, asr pc
     240:	01925f04 	orrseq	r5, r2, r4, lsl #30
     244:	92045401 	andls	r5, r4, #16777216	@ 0x1000000
     248:	01019701 	tsteq	r1, r1, lsl #14
     24c:	01970451 	orrseq	r0, r7, r1, asr r4
     250:	a30401ac 	movwge	r0, #16812	@ 0x41ac
     254:	009f5101 	addseq	r5, pc, r1, lsl #2
	...
     260:	62040000 	andvs	r0, r4, #0
     264:	0450016a 	ldrbeq	r0, [r0], #-362	@ 0xfffffe96
     268:	51016d6a 	tstpl	r1, sl, ror #26
     26c:	01766e04 	cmneq	r6, r4, lsl #28
     270:	78760450 	ldmdavc	r6!, {r4, r6, sl}^
     274:	7f987304 	svcvc	0x00987304
     278:	0188049f 			@ <UNDEFINED> instruction: 0x0188049f
     27c:	5001018c 	andpl	r0, r1, ip, lsl #3
	...
     288:	0c000400 	cfstrseq	mvf0, [r0], {-0}
     28c:	0c045001 	stceq	0, cr5, [r4], {1}
     290:	01a30436 			@ <UNDEFINED> instruction: 0x01a30436
     294:	36049f50 			@ <UNDEFINED> instruction: 0x36049f50
     298:	04500138 	ldrbeq	r0, [r0], #-312	@ 0xfffffec8
     29c:	a3045038 	movwge	r5, #16440	@ 0x4038
     2a0:	009f5001 	addseq	r5, pc, r1
	...
     2ac:	010f0004 	tsteq	pc, r4
     2b0:	360f0451 			@ <UNDEFINED> instruction: 0x360f0451
     2b4:	36045401 	strcc	r5, [r4], -r1, lsl #8
     2b8:	0451013b 	ldrbeq	r0, [r1], #-315	@ 0xfffffec5
     2bc:	a304503b 	movwge	r5, #16443	@ 0x403b
     2c0:	009f5101 	addseq	r5, pc, r1, lsl #2
	...
     2cc:	12040000 	andne	r0, r4, #0
     2d0:	0450011a 	ldrbeq	r0, [r0], #-282	@ 0xfffffee6
     2d4:	51011d1a 	tstpl	r1, sl, lsl sp
     2d8:	01262004 			@ <UNDEFINED> instruction: 0x01262004
     2dc:	29260450 	stmdbcs	r6!, {r4, r6, sl}
     2e0:	2c045301 	stccs	3, cr5, [r4], {1}
     2e4:	00500130 	subseq	r0, r0, r0, lsr r1
     2e8:	00000062 	andeq	r0, r0, r2, rrx
     2ec:	00040005 	andeq	r0, r4, r5
	...
     2f8:	010c0004 	tsteq	ip, r4
     2fc:	8c0c0450 	cfstrshi	mvf0, [ip], {80}	@ 0x50
     300:	01a30402 			@ <UNDEFINED> instruction: 0x01a30402
     304:	00009f50 	andeq	r9, r0, r0, asr pc
     308:	04000000 	streq	r0, [r0], #-0
     30c:	51010c00 	tstpl	r1, r0, lsl #24
     310:	028c0c04 	addeq	r0, ip, #4, 24	@ 0x400
     314:	5101a304 	tstpl	r1, r4, lsl #6
     318:	0006009f 	muleq	r6, pc, r0	@ <UNPREDICTABLE>
	...
     324:	01801804 	orreq	r1, r0, r4, lsl #16
     328:	049f3002 	ldreq	r3, [pc], #2	@ 330 <vector_table+0x330>
     32c:	01880180 	orreq	r0, r8, r0, lsl #3
     330:	88045001 	stmdahi	r4, {r0, ip, lr}
     334:	04019501 	streq	r9, [r1], #-1281	@ 0xfffffaff
     338:	9f7dc073 	svcls	0x007dc073
     33c:	c001b804 	andgt	fp, r1, r4, lsl #16
     340:	04500101 	ldrbeq	r0, [r0], #-257	@ 0xfffffeff
     344:	01cb01c0 	biceq	r0, fp, r0, asr #3
     348:	7dc07304 	stclvc	3, cr7, [r0, #16]
     34c:	002c009f 	mlaeq	ip, pc, r0, r0	@ <UNPREDICTABLE>
     350:	00050000 	andeq	r0, r5, r0
     354:	00000004 	andeq	r0, r0, r4
     358:	00000000 	andeq	r0, r0, r0
     35c:	00040000 	andeq	r0, r4, r0
     360:	04500104 	ldrbeq	r0, [r0], #-260	@ 0xfffffefc
     364:	a3041c04 	movwge	r1, #19460	@ 0x4c04
     368:	009f5001 	addseq	r5, pc, r1
     36c:	00000000 	andeq	r0, r0, r0
     370:	01070004 	tsteq	r7, r4
     374:	1c070451 	cfstrsne	mvf0, [r7], {81}	@ 0x51
     378:	5101a304 	tstpl	r1, r4, lsl #6
     37c:	003d009f 	mlaseq	sp, pc, r0, r0	@ <UNPREDICTABLE>
     380:	00050000 	andeq	r0, r5, r0
     384:	00000004 	andeq	r0, r0, r4
     388:	00000000 	andeq	r0, r0, r0
     38c:	00040000 	andeq	r0, r4, r0
     390:	04500106 	ldrbeq	r0, [r0], #-262	@ 0xfffffefa
     394:	0401a406 	streq	sl, [r1], #-1030	@ 0xfffffbfa
     398:	9f5001a3 	svcls	0x005001a3
     39c:	00000000 	andeq	r0, r0, r0
     3a0:	09000400 	stmdbeq	r0, {sl}
     3a4:	09045101 	stmdbeq	r4, {r0, r8, ip, lr}
     3a8:	a30401a4 	movwge	r0, #16804	@ 0x41a4
     3ac:	009f5101 	addseq	r5, pc, r1, lsl #2
     3b0:	00000000 	andeq	r0, r0, r0
     3b4:	01746804 	cmneq	r4, r4, lsl #16
     3b8:	7e780450 	mrcvc	4, 3, r0, cr8, cr0, {2}
     3bc:	38005001 	stmdacc	r0, {r0, ip, lr}
int finish_ecdhpair(int argc, char** argv) {
     3c0:	05000005 	streq	r0, [r0, #-5]
    if (argc == 4) {
     3c4:	00000400 	andeq	r0, r0, r0, lsl #8
    else printf("Incorrect number of arguments for PAIRECDH2\n");
     3c8:	00000000 	andeq	r0, r0, r0
     3cc:	04000000 	streq	r0, [r0], #-0
     3d0:	028a0280 	addeq	r0, sl, #128, 4
     3d4:	8a045001 	bhi	1143e0 <__ROM_SIZE__+0xd43e0>
        decode_base64((uint8_t *)argv[3], 64, carpubkey);
     3d8:	04029c02 	streq	r9, [r2], #-3074	@ 0xfffff3fe
     3dc:	9f5001a3 	svcls	0x005001a3
        ecdh_shared_secret(ECDH_privkey, carpubkey, ECDH_shared);
     3e0:	00000000 	andeq	r0, r0, r0
     3e4:	02800400 	addeq	r0, r0, #0, 8
     3e8:	51010288 	smlabbpl	r1, r8, r2, r0
        sha256_init(&shactx);
     3ec:	9c028804 	stcls	8, cr8, [r2], {4}
     3f0:	01a30402 			@ <UNDEFINED> instruction: 0x01a30402
	    sha256_update(&shactx, ECDH_shared, ECC_PUB_KEY_SIZE);
     3f4:	00009f51 	andeq	r9, r0, r1, asr pc
     3f8:	04000000 	streq	r0, [r0], #-0
     3fc:	03940388 	orrseq	r0, r4, #136, 6	@ 0x20000002
	    sha256_final(&shactx, ECDH_AESkey);
     400:	94045001 	strls	r5, [r4], #-1
     404:	0403f003 	streq	pc, [r3], #-3
        AES_init_ctx(&ctx, ECDH_AESkey);
     408:	9f5001a3 	svcls	0x005001a3
     40c:	00000000 	andeq	r0, r0, r0
     410:	04000000 	streq	r0, [r0], #-0
     414:	03920388 	orrseq	r0, r2, #136, 6	@ 0x20000002
     418:	92045101 	andls	r5, r4, #1073741824	@ 0x40000000
     41c:	01039703 	tsteq	r3, r3, lsl #14
     420:	03970453 	orrseq	r0, r7, #1392508928	@ 0x53000000
     424:	a30403f0 	movwge	r0, #17392	@ 0x43f0
int car_mesg(int argc, char** argv) {
     428:	009f5101 	addseq	r5, pc, r1, lsl #2
     42c:	00000001 	andeq	r0, r0, r1
    printf("Received a message from the car:");
     430:	00000000 	andeq	r0, r0, r0
     434:	a6038a04 	strge	r8, [r3], -r4, lsl #20
    for (ctr = 1; ctr < argc; ctr++) {
     438:	9f300203 	svcls	0x00300203
        printf(" %s", argv[ctr]);
     43c:	d403a604 	strle	sl, [r3], #-1540	@ 0xfffff9fc
     440:	04550103 	ldrbeq	r0, [r5], #-259	@ 0xfffffefd
    for (ctr = 1; ctr < argc; ctr++) {
     444:	03d803d4 	bicseq	r0, r8, #212, 6	@ 0x50000003
     448:	049f3002 	ldreq	r3, [pc], #2	@ 450 <car_mesg+0x28>
    printf("\n");
     44c:	03da03d8 	bicseq	r0, sl, #216, 6	@ 0x60000003
    if (argc > 1) {
     450:	02005501 	andeq	r5, r0, #4194304	@ 0x400000
}
     454:	00000000 	andeq	r0, r0, r0
     458:	04000000 	streq	r0, [r0], #-0
        if (strcmp(argv[1], "PING_REPLY") == 0) {
     45c:	03a2038a 			@ <UNDEFINED> instruction: 0x03a2038a
     460:	049f3102 	ldreq	r3, [pc], #258	@ 468 <car_mesg+0x40>
            printf("Got a ping reply.\n");
     464:	03d403a6 	bicseq	r0, r4, #-1744830462	@ 0x98000002
     468:	d4045601 	strle	r5, [r4], #-1537	@ 0xfffff9ff
        else if (strcmp(argv[1], "PAIRECDH2") == 0) {
     46c:	0203d803 	andeq	sp, r3, #196608	@ 0x30000
     470:	d8049f31 	stmdale	r4, {r0, r4, r5, r8, r9, sl, fp, ip, pc}
     474:	0103da03 	tsteq	r3, r3, lsl #20
            finish_ecdhpair(argc, argv);
     478:	00000056 	andeq	r0, r0, r6, asr r0
     47c:	00000000 	andeq	r0, r0, r0
        else if (strcmp(argv[1], "AESB64") == 0) {
     480:	d80cd004 	stmdale	ip, {r2, ip, lr, pc}
     484:	0450010c 	ldrbeq	r0, [r0], #-268	@ 0xfffffef4
     488:	0cfc0cd8 	ldcleq	12, cr0, [ip], #864	@ 0x360
            if (argc == 3) { 
     48c:	fc045601 	stc2	6, cr5, [r4], {1}
                printf("Missing AESB64 encoded message\n");
     490:	040d800c 	streq	r8, [sp], #-12
     494:	9f5001a3 	svcls	0x005001a3
                len = decode_base64((uint8_t *) argv[2], strlen(argv[2]), decoded);
     498:	00000200 	andeq	r0, r0, r0, lsl #4
     49c:	0cd40400 	cfldrdeq	mvd0, [r4], {0}
     4a0:	30020cd8 	ldrdcc	r0, [r2], -r8
     4a4:	0cd8049f 	cfldrdeq	mvd0, [r8], {159}	@ 0x9f
     4a8:	55010cfc 	strpl	r0, [r1, #-3324]	@ 0xfffff304
                AES_ECB_decrypt(&ctx, decoded);
     4ac:	00000000 	andeq	r0, r0, r0
     4b0:	04000000 	streq	r0, [r0], #-0
                decoded[len] = '\0';
     4b4:	0cae0ca4 	stceq	12, cr0, [lr], #656	@ 0x290
     4b8:	ae045001 	cdpge	0, 0, cr5, cr4, cr1, {0}
     4bc:	010cb10c 	tsteq	ip, ip, lsl #2
                printf("Decoded/decrypted as %s\n", decoded);
     4c0:	0cb10451 	cfldrseq	mvf0, [r1], #324	@ 0x144
     4c4:	a3040cd0 	movwge	r0, #19664	@ 0x4cd0
     4c8:	009f5001 	addseq	r5, pc, r1
        else if (strcmp(argv[1], "B64") == 0) {
     4cc:	00000000 	andeq	r0, r0, r0
     4d0:	b60cb204 	strlt	fp, [ip], -r4, lsl #4
            if (argc == 3) { 
     4d4:	0450010c 	ldrbeq	r0, [r0], #-268	@ 0xfffffef4
                printf("Missing Base64 encoded message\n");
     4d8:	0cc70cc2 	stcleq	12, cr0, [r7], {194}	@ 0xc2
     4dc:	00005001 	andeq	r5, r0, r1
                printf("Decoding Base64\n");
     4e0:	04000000 	streq	r0, [r0], #-0
     4e4:	02a0029c 	adceq	r0, r0, #156, 4	@ 0xc0000009
                len = decode_base64((uint8_t *) argv[2], strlen(argv[2]), decoded);
     4e8:	a0045001 	andge	r5, r4, r1
     4ec:	0402ac02 	streq	sl, [r2], #-3074	@ 0xfffff3fe
     4f0:	9f5001a3 	svcls	0x005001a3
     4f4:	00000000 	andeq	r0, r0, r0
                decoded[len] = '\0';
     4f8:	029c0400 	addseq	r0, ip, #0, 8
     4fc:	510102a3 	smlatbpl	r1, r3, r2, r0
     500:	ac02a304 	stcge	3, cr10, [r2], {4}
                printf("Decoded as %s", decoded);
     504:	01a30402 			@ <UNDEFINED> instruction: 0x01a30402
     508:	02009f51 	andeq	r9, r0, #324	@ 0x144
     50c:	04000000 	streq	r0, [r0], #-0
            printf("Didn't know how to handle %s\n", argv[1]);
     510:	01a0019c 	lsleq	r0, ip	@ <illegal shifter operand>
     514:	049f3002 	ldreq	r3, [pc], #2	@ 51c <car_mesg+0xf4>
     518:	01bc01a0 			@ <UNDEFINED> instruction: 0x01bc01a0
     51c:	00005401 	andeq	r5, r0, r1, lsl #8
     520:	00000000 	andeq	r0, r0, r0
     524:	09b40400 	ldmibeq	r4!, {sl}
     528:	500109bb 			@ <UNDEFINED> instruction: 0x500109bb
     52c:	c509bc04 	strgt	fp, [r9, #-3076]	@ 0xfffff3fc
     530:	04500109 	ldrbeq	r0, [r0], #-265	@ 0xfffffef7
     534:	0aba0ab4 	beq	fee8300c <_STACK_TOP_+0xdee7b010>
     538:	00005001 	andeq	r5, r0, r1
     53c:	04000000 	streq	r0, [r0], #-0
     540:	09f209ee 	ldmibeq	r2!, {r1, r2, r3, r5, r6, r7, r8, fp}^
     544:	d6045001 	strle	r5, [r4], -r1
     548:	010bdb0b 	tsteq	fp, fp, lsl #22
     54c:	00010050 	andeq	r0, r1, r0, asr r0
	...
void uputc(char c) {
     558:	00010100 	andeq	r0, r1, r0, lsl #2
  while ((UARTFR >> 5) & 1)
     55c:	fc040000 	stc2	0, cr0, [r4], {-0}
     560:	0209b008 	andeq	fp, r9, #8
  UART_DR = c;
     564:	b0049f30 	andlt	r9, r4, r0, lsr pc
  if (c == '\n')
     568:	0109b209 	tsteq	r9, r9, lsl #4
}
     56c:	09b40455 	ldmibeq	r4!, {r0, r2, r4, r6, sl}
    uputc('\r');
     570:	550109c6 	strpl	r0, [r1, #-2502]	@ 0xfffff63a
}
     574:	8e09c804 	cdphi	8, 0, cr12, cr9, cr4, {0}
     578:	0455010b 	ldrbeq	r0, [r5], #-267	@ 0xfffffef5
  if (!((UARTFR >> 4) & 1)) return UART_DR;
     57c:	0b960b90 	bleq	fe5833c4 <_STACK_TOP_+0xde57b3c8>
     580:	98045501 	stmdals	r4, {r0, r8, sl, ip, lr}
     584:	010bb60b 	tsteq	fp, fp, lsl #12
     588:	0bb60455 	bleq	fed816e4 <_STACK_TOP_+0xded796e8>
  return -1;
     58c:	30020bba 			@ <UNDEFINED> instruction: 0x30020bba
}
     590:	0bba049f 	bleq	fee81814 <_STACK_TOP_+0xdee79818>
     594:	55010bec 	strpl	r0, [r1, #-3052]	@ 0xfffff414
  UARTCTL = 0;
     598:	00000000 	andeq	r0, r0, r0
     59c:	04000000 	streq	r0, [r0], #-0
  UARTIBRD = 8;
     5a0:	09b409b0 	ldmibeq	r4!, {r4, r5, r7, r8, fp}
  UARTFBRD = 44;
     5a4:	c8045401 	stmdagt	r4, {r0, sl, ip, lr}
  UARTCC = 0;
     5a8:	010aa409 	tsteq	sl, r9, lsl #8
  UARTLCRH = 0x60;
     5ac:	0abc0454 	beq	fef01704 <_STACK_TOP_+0xdeef9708>
  UARTCTL = 0x301;
     5b0:	54010bec 	strpl	r0, [r1], #-3052	@ 0xfffff414
}
     5b4:	00000600 	andeq	r0, r0, r0, lsl #12
     5b8:	08fc0400 	ldmeq	ip!, {sl}^
void u2putc(char c) {
     5bc:	300208fe 	strdcc	r0, [r2], -lr
  while ((UART2FR >> 5) & 1)
     5c0:	08fe049f 	ldmeq	lr!, {r0, r1, r2, r3, r4, r7, sl}^
     5c4:	53010992 	movwpl	r0, #6546	@ 0x1992
  UART2_DR = c;
     5c8:	04000000 	streq	r0, [r0], #-0
  if (c == '\n')
     5cc:	09a50994 	stmibeq	r5!, {r2, r4, r7, r8, fp}
}
     5d0:	00005301 	andeq	r5, r0, r1, lsl #6
    u2putc('\r');
     5d4:	00000000 	andeq	r0, r0, r0
}
     5d8:	02ac0400 	adceq	r0, ip, #0, 8
     5dc:	500102b8 			@ <UNDEFINED> instruction: 0x500102b8
  if (!((UART2FR >> 4) & 1)) return UART2_DR;
     5e0:	fa02b804 	blx	ae5f8 <__ROM_SIZE__+0x6e5f8>
     5e4:	04580102 	ldrbeq	r0, [r8], #-258	@ 0xfffffefe
     5e8:	038802fa 	orreq	r0, r8, #-1610612721	@ 0xa000000f
     5ec:	5001a304 	andpl	sl, r1, r4, lsl #6
  return -1;
     5f0:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
}
     5f4:	00000000 	andeq	r0, r0, r0
     5f8:	b802ac04 	stmdalt	r2, {r2, sl, fp, sp, pc}
  UART2CTL = 0;
     5fc:	04510102 	ldrbeq	r0, [r1], #-258	@ 0xfffffefe
     600:	02fa02b8 	rscseq	r0, sl, #184, 4	@ 0x8000000b
  UART2IBRD = 8;
     604:	fa045601 	blx	115e10 <__ROM_SIZE__+0xd5e10>
  UART2FBRD = 44;
     608:	04038802 	streq	r8, [r3], #-2050	@ 0xfffff7fe
  UART2CC = 0;
     60c:	9f5101a3 	svcls	0x005101a3
  UART2LCRH = 0x60;
     610:	01010100 	mrseq	r0, (UNDEF: 17)
  UART2CTL = 0x301;
     614:	04000000 	streq	r0, [r0], #-0
}
     618:	02e202b4 	rsceq	r0, r2, #180, 4	@ 0x4000000b
     61c:	049f3002 	ldreq	r3, [pc], #2	@ 624 <pin_setup+0x4>
  RCGCUART |= 3;
     620:	02e402e2 	rsceq	r0, r4, #536870926	@ 0x2000000e
     624:	049f3102 	ldreq	r3, [pc], #258	@ 62c <pin_setup+0xc>
     628:	02f602e4 	rscseq	r0, r6, #228, 4	@ 0x4000000e
     62c:	009f3002 	addseq	r3, pc, r2
  RCGCGPIO |= 3;
     630:	00000003 	andeq	r0, r0, r3
     634:	b802b404 	stmdalt	r2, {r2, sl, ip, sp, pc}
     638:	9f300202 	svcls	0x00300202
  GPIODEN = 0x03;
     63c:	fa02b804 	blx	ae654 <__ROM_SIZE__+0x6e654>
     640:	00550102 	subseq	r0, r5, r2, lsl #2
  GPIOAFSEL = 0x03;
     644:	00000000 	andeq	r0, r0, r0
  GPIOPCTL |= 0x00000011;
     648:	c004b804 	andgt	fp, r4, r4, lsl #16
     64c:	04500104 	ldrbeq	r0, [r0], #-260	@ 0xfffffefc
     650:	058a04c0 	streq	r0, [sl, #1216]	@ 0x4c0
  GPIODEN2 = 0x03;
     654:	00005501 	andeq	r5, r0, r1, lsl #10
     658:	04000000 	streq	r0, [r0], #-0
  GPIOAFSEL2 = 0x03;
     65c:	04c304b8 	strbeq	r0, [r3], #1208	@ 0x4b8
  GPIOPCTL2 |= 0x00000011;
     660:	c3045101 	movwgt	r5, #16641	@ 0x4101
     664:	01058a04 	tsteq	r5, r4, lsl #20
     668:	00000054 	andeq	r0, r0, r4, asr r0
}
     66c:	b8040000 	stmdalt	r4, {}	@ <UNPREDICTABLE>
     670:	0104c304 	tsteq	r4, r4, lsl #6
void platform_init() {
     674:	04c30452 	strbeq	r0, [r3], #1106	@ 0x452
    pin_setup();
     678:	a304058a 	movwge	r0, #17802	@ 0x458a
    uart_init();
     67c:	009f5201 	addseq	r5, pc, r1, lsl #4
    uart2_init();
     680:	01000001 	tsteq	r0, r1
    set_read_char(ugetc);
     684:	00000001 	andeq	r0, r0, r1
    set_read_char2(u2getc);
     688:	cc04be04 	stcgt	14, cr11, [r4], {4}
     68c:	9f300204 	svcls	0x00300204
    set_write_char(uputc);
     690:	8004cc04 	andhi	ip, r4, r4, lsl #24
    set_write_char2(u2putc);
     694:	04500105 	ldrbeq	r0, [r0], #-261	@ 0xfffffefb
     698:	05860580 	streq	r0, [r6, #1408]	@ 0x580
}
     69c:	9f017003 	svcls	0x00017003
     6a0:	8a058604 	bhi	161eb8 <__ROM_SIZE__+0x121eb8>
     6a4:	00500105 	subseq	r0, r0, r5, lsl #2
     6a8:	00000002 	andeq	r0, r0, r2
int aes_test(int argc, char** argv) {
     6ac:	cc04be04 	stcgt	14, cr11, [r4], {4}
    uint8_t text[17] = "0123456789abcdef";
     6b0:	9f300204 	svcls	0x00300204
     6b4:	8a04cc04 	bhi	1336cc <__ROM_SIZE__+0xf36cc>
     6b8:	00530105 	subseq	r0, r3, r5, lsl #2
     6bc:	00000000 	andeq	r0, r0, r0
     6c0:	ca04c604 	bgt	131ed8 <__ROM_SIZE__+0xf1ed8>
    printf("Plaintext is %s\n", text);
     6c4:	04500104 	ldrbeq	r0, [r0], #-260	@ 0xfffffefc
     6c8:	058a04ca 	streq	r0, [sl, #1226]	@ 0x4ca
    AES_ECB_encrypt(&ctx, text);
     6cc:	00005c01 	andeq	r5, r0, r1, lsl #24
     6d0:	00000000 	andeq	r0, r0, r0
    len = encode_base64(text, 16, b64text);
     6d4:	07ce0400 	strbeq	r0, [lr, r0, lsl #8]
     6d8:	500107e8 	andpl	r0, r1, r8, ror #15
     6dc:	e007e804 	and	lr, r7, r4, lsl #16
    b64text[len] = '\0';
     6e0:	04580108 	ldrbeq	r0, [r8], #-264	@ 0xfffffef8
     6e4:	08f008e0 	ldmeq	r0!, {r5, r6, r7, fp}^
     6e8:	00005001 	andeq	r5, r0, r1
    printf("Encrypted/encoded is %s\n", b64text);
     6ec:	00000000 	andeq	r0, r0, r0
     6f0:	07ce0400 	strbeq	r0, [lr, r0, lsl #8]
    printf2("FOB_MESG AESB64 %s\n", b64text);
     6f4:	510107e8 	smlattpl	r1, r8, r7, r0
     6f8:	e007e804 	and	lr, r7, r4, lsl #16
    printf("Test the mesg handler with CAR_MESG AESB64 %s\n", b64text);
     6fc:	04560108 	ldrbeq	r0, [r6], #-264	@ 0xfffffef8
     700:	08f008e0 	ldmeq	r0!, {r5, r6, r7, fp}^
    len = decode_base64(b64text, len, decoded);
     704:	00005101 	andeq	r5, r0, r1, lsl #2
     708:	04000000 	streq	r0, [r0], #-0
     70c:	08a007e8 	stmiaeq	r0!, {r3, r5, r6, r7, r8, r9, sl}
    AES_ECB_decrypt(&ctx, decoded);
     710:	a4045501 	strge	r5, [r4], #-1281	@ 0xfffffaff
     714:	0108e008 	tsteq	r8, r8
    decoded[len] = '\0';
     718:	00000055 	andeq	r0, r0, r5, asr r0
     71c:	e8040000 	stmda	r4, {}	@ <UNPREDICTABLE>
     720:	0108a007 	tsteq	r8, r7
    printf("After encrypting->encoding->decoding->decrypting we recover %s\n", decoded);
     724:	08a40459 	stmiaeq	r4!, {r0, r3, r4, r6, sl}
     728:	590108e0 	stmdbpl	r1, {r5, r6, r7, fp}
}
     72c:	01010000 	mrseq	r0, (UNDEF: 1)
     730:	00000000 	andeq	r0, r0, r0
     734:	07e80400 	strbeq	r0, [r8, r0, lsl #8]!
     738:	5a010886 	bpl	42958 <__ROM_SIZE__+0x2958>
     73c:	94088604 	strls	r8, [r8], #-1540	@ 0xfffff9fc
     740:	04550108 	ldrbeq	r0, [r5], #-264	@ 0xfffffef8
     744:	089a0894 	ldmeq	sl, {r2, r4, r7, fp}
     748:	a4045a01 	strge	r5, [r4], #-2561	@ 0xfffff5ff
     74c:	0108a808 	tsteq	r8, r8, lsl #16
int pair1(int argc, char** argv) {
     750:	0000005a 	andeq	r0, r0, sl, asr r0
    printf("Sending a pair request.\n");
     754:	00000000 	andeq	r0, r0, r0
    printf2("FOB_MESG PAIR %d %d\n", fob_ID, pairing_PIN);
     758:	8a040000 	bhi	100760 <__ROM_SIZE__+0xc0760>
     75c:	01059c05 	tsteq	r5, r5, lsl #24
     760:	059c0450 	ldreq	r0, [ip, #1104]	@ 0x450
     764:	560105c2 	strpl	r0, [r1], -r2, asr #11
}
     768:	c405c204 	strgt	ip, [r5], #-516	@ 0xfffffdfc
     76c:	04500105 	ldrbeq	r0, [r0], #-261	@ 0xfffffefb
     770:	05c605c4 	strbeq	r0, [r6, #1476]	@ 0x5c4
     774:	5001a304 	andpl	sl, r1, r4, lsl #6
     778:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
int pairchall(int argc, char** argv) {
     77c:	00000000 	andeq	r0, r0, r0
    printf("Sending a pair request with challenge/response.\n");
     780:	9f058a04 	svcls	0x00058a04
    printf2("FOB_MESG PAIRCR %d %d\n", fob_ID, pairing_PIN);
     784:	04510105 	ldrbeq	r0, [r1], #-261	@ 0xfffffefb
     788:	05c2059f 	strbeq	r0, [r2, #1439]	@ 0x59f
     78c:	c2045501 	andgt	r5, r4, #4194304	@ 0x400000
     790:	0105c605 	tsteq	r5, r5, lsl #12
}
     794:	00000051 	andeq	r0, r0, r1, asr r0
     798:	00000000 	andeq	r0, r0, r0
     79c:	9f058a04 	svcls	0x00058a04
     7a0:	04520105 	ldrbeq	r0, [r2], #-261	@ 0xfffffefb
     7a4:	05c2059f 	strbeq	r0, [r2, #1439]	@ 0x59f
int pairecdh(int argc, char** argv) {
     7a8:	c2045401 	andgt	r5, r4, #16777216	@ 0x1000000
    printf("Starting EC Diffie-Hellman key exchange.\n");
     7ac:	0105c605 	tsteq	r5, r5, lsl #12
     7b0:	00000052 	andeq	r0, r0, r2, asr r0
    decode_base64(ECDH_privkey_b64, 32, ECDH_privkey);
     7b4:	a6040000 	strge	r0, [r4], -r0
     7b8:	0105b605 	tsteq	r5, r5, lsl #12
     7bc:	05ba0453 	ldreq	r0, [sl, #1107]!	@ 0x453
    ecdh_generate_keys(ECDH_pubkey, ECDH_privkey);
     7c0:	530105c2 	movwpl	r0, #5570	@ 0x15c2
     7c4:	00000000 	andeq	r0, r0, r0
    encode_base64(ECDH_pubkey, ECC_PUB_KEY_SIZE, pubkey_b64);
     7c8:	01c00400 	biceq	r0, r0, r0, lsl #8
     7cc:	500101da 	ldrdpl	r0, [r1], -sl
     7d0:	8001da04 	andhi	sp, r1, r4, lsl #20
    pubkey_b64[64] = '\0';
     7d4:	01a30402 			@ <UNDEFINED> instruction: 0x01a30402
    printf2("FOB_MESG PAIRECDH %d %d %s\n", fob_ID, pairing_PIN, pubkey_b64);
     7d8:	00009f50 	andeq	r9, r0, r0, asr pc
     7dc:	04000000 	streq	r0, [r0], #-0
     7e0:	01da01c0 	bicseq	r0, sl, r0, asr #3
     7e4:	da045101 	ble	114bf0 <__ROM_SIZE__+0xd4bf0>
}
     7e8:	04028001 	streq	r8, [r2], #-1
     7ec:	9f5101a3 	svcls	0x005101a3
     7f0:	04000000 	streq	r0, [r0], #-0
     7f4:	01f401c8 	mvnseq	r0, r8, asr #3
     7f8:	01005501 	tsteq	r0, r1, lsl #10
     7fc:	00000000 	andeq	r0, r0, r0
     800:	01c80400 	biceq	r0, r8, r0, lsl #8
     804:	300201d4 	ldrdcc	r0, [r2], -r4
     808:	01d4049f 			@ <UNDEFINED> instruction: 0x01d4049f
int encode64(int argc, char** argv) {
     80c:	540101d6 	strpl	r0, [r1], #-470	@ 0xfffffe2a
    if (argc > 1) {
     810:	da01d604 	ble	76028 <__ROM_SIZE__+0x36028>
     814:	9f300201 	svcls	0x00300201
        len = strlen(argv[1]);
     818:	04000000 	streq	r0, [r0], #-0
     81c:	01f401da 	ldrsbeq	r0, [r4, #26]!
        if (len < MAXARRAYLEN) {
     820:	00005401 	andeq	r5, r0, r1, lsl #8
            len = encode_base64((uint8_t *) argv[1], len, encoded);
     824:	00000000 	andeq	r0, r0, r0
     828:	03f00400 	mvnseq	r0, #0, 8
            printf("Encoded %s as %s with %d characters\n", argv[1], encoded, len);
     82c:	500103fb 	strdpl	r0, [r1], -fp
     830:	ac03fb04 			@ <UNDEFINED> instruction: 0xac03fb04
     834:	04550104 	ldrbeq	r0, [r5], #-260	@ 0xfffffefc
            printf("String exceeds max length of %d characters", MAXARRAYLEN);
     838:	04b804ac 	ldrteq	r0, [r8], #1196	@ 0x4ac
     83c:	00005001 	andeq	r5, r0, r1
     840:	048e0400 	streq	r0, [lr], #1024	@ 0x400
        printf("Usage is 'encode64 string'\n");
     844:	5001049a 	mulpl	r1, sl, r4
}
     848:	00000000 	andeq	r0, r0, r0
     84c:	04000000 	streq	r0, [r0], #-0
     850:	06c506b8 			@ <UNDEFINED> instruction: 0x06c506b8
     854:	c5045001 	strgt	r5, [r4, #-1]
     858:	01079006 	tsteq	r7, r6
int decode64(int argc, char** argv) {
     85c:	07900454 			@ <UNDEFINED> instruction: 0x07900454
    if (argc > 1) {
     860:	a3040798 	movwge	r0, #18328	@ 0x4798
     864:	009f5001 	addseq	r5, pc, r1
        int len = strlen(argv[1]);
     868:	00000000 	andeq	r0, r0, r0
     86c:	b8040000 	stmdalt	r4, {}	@ <UNPREDICTABLE>
        if (len < MAXBASE64LEN) {
     870:	0106c206 	tsteq	r6, r6, lsl #4
                len = decode_base64((uint8_t *) argv[1], len, plaintext);
     874:	06c20451 			@ <UNDEFINED> instruction: 0x06c20451
     878:	55010790 	strpl	r0, [r1, #-1936]	@ 0xfffff870
                plaintext[len] = '\0';
     87c:	98079004 	stmdals	r7, {r2, ip, pc}
     880:	01a30407 			@ <UNDEFINED> instruction: 0x01a30407
     884:	00009f51 	andeq	r9, r0, r1, asr pc
                printf("Decoded %s as: %s\n", argv[1], plaintext);
     888:	06f00400 	ldrbteq	r0, [r0], r0, lsl #8
     88c:	530106fd 	movwpl	r0, #5885	@ 0x16fd
	...
            printf("String exceeds max base64 string length of %d characters", MAXBASE64LEN);
     898:	05c60400 	strbeq	r0, [r6, #1024]	@ 0x400
     89c:	500105e6 	andpl	r0, r1, r6, ror #11
        printf("Usage is 'decode64 string'\n");
     8a0:	ec05e604 	stc	6, cr14, [r5], {4}
}
     8a4:	04540105 	ldrbeq	r0, [r4], #-261	@ 0xfffffefb
     8a8:	05f305ec 	ldrbeq	r0, [r3, #1516]!	@ 0x5ec
     8ac:	f3045001 	vhadd.u8	d5, d4, d1
     8b0:	0106b805 	tsteq	r6, r5, lsl #16
     8b4:	00000054 	andeq	r0, r0, r4, asr r0
int ecdh_test(int argc, char** argv) {
     8b8:	00000000 	andeq	r0, r0, r0
    uint8_t b64privkey2[32] = "wP/uwP/uwP/uwP/uwP/uwP/uwP/uwP/u";
     8bc:	c6040000 	strgt	r0, [r4], -r0
     8c0:	0105e405 	tsteq	r5, r5, lsl #8
     8c4:	05e40451 	strbeq	r0, [r4, #1105]!	@ 0x451
     8c8:	a30405ec 	movwge	r0, #17900	@ 0x45ec
     8cc:	049f5101 	ldreq	r5, [pc], #257	@ 8d4 <ecdh_test+0x1c>
    printf("Testing the ecdh key exchange\n");
     8d0:	05f005ec 	ldrbeq	r0, [r0, #1516]!	@ 0x5ec
     8d4:	f0045101 			@ <UNDEFINED> instruction: 0xf0045101
    decode_base64(ECDH_privkey_b64, 32, ECDH_privkey);
     8d8:	0106b805 	tsteq	r6, r5, lsl #16
     8dc:	00000055 	andeq	r0, r0, r5, asr r0
     8e0:	96068e04 	strls	r8, [r6], -r4, lsl #28
    decode_base64(b64privkey2, 32, privkey2);
     8e4:	00510106 	subseq	r0, r1, r6, lsl #2
     8e8:	00000000 	andeq	r0, r0, r0
    ecdh_generate_keys(ECDH_pubkey, ECDH_privkey);
     8ec:	8e018804 	cdphi	8, 0, cr8, cr1, cr4, {0}
     8f0:	04500101 	ldrbeq	r0, [r0], #-257	@ 0xfffffeff
     8f4:	019a018e 	orrseq	r0, sl, lr, lsl #3
    ecdh_generate_keys(pubkey2, privkey2);
     8f8:	99005401 	stmdbls	r0, {r0, sl, ip, lr}
     8fc:	05000001 	streq	r0, [r0, #-1]
    ecdh_shared_secret(ECDH_privkey, pubkey2, ECDH_shared);
     900:	00000400 	andeq	r0, r0, r0, lsl #8
     904:	00000000 	andeq	r0, r0, r0
     908:	04000000 	streq	r0, [r0], #-0
    ecdh_shared_secret(privkey2, ECDH_pubkey, sharedsecret2);
     90c:	03ab03a0 			@ <UNDEFINED> instruction: 0x03ab03a0
     910:	ab045001 	blge	11491c <__ROM_SIZE__+0xd491c>
    sha256_init(&shactx);
     914:	0104dc03 	tsteq	r4, r3, lsl #24
     918:	00000054 	andeq	r0, r0, r4, asr r0
	sha256_update(&shactx, ECDH_shared, ECC_PUB_KEY_SIZE);
     91c:	a0040000 	andge	r0, r4, r0
     920:	0103ab03 	tsteq	r3, r3, lsl #22
	sha256_final(&shactx, ECDH_AESkey);
     924:	03ab0451 			@ <UNDEFINED> instruction: 0x03ab0451
     928:	a30404dc 	movwge	r0, #17628	@ 0x44dc
     92c:	009f5101 	addseq	r5, pc, r1, lsl #2
    len = encode_base64(ECDH_AESkey, AES_KEYLEN, b64test);
     930:	00000000 	andeq	r0, r0, r0
     934:	ab03a004 	blge	e894c <__ROM_SIZE__+0xa894c>
    b64test[len] = '\0';
     938:	04520103 	ldrbeq	r0, [r2], #-259	@ 0xfffffefd
     93c:	04dc03ab 	ldrbeq	r0, [ip], #939	@ 0x3ab
     940:	00005601 	andeq	r5, r0, r1, lsl #12
     944:	04000000 	streq	r0, [r0], #-0
    printf("First shared key is %s\n", b64test);
     948:	03b203ae 			@ <UNDEFINED> instruction: 0x03b203ae
     94c:	b2045001 	andlt	r5, r4, #1
    sha256_init(&shactx);
     950:	0104dc03 	tsteq	r4, r3, lsl #24
    sha256_update(&shactx, sharedsecret2, ECC_PUB_KEY_SIZE);
     954:	00020058 	andeq	r0, r2, r8, asr r0
     958:	ae040000 	cdpge	0, 0, cr0, cr4, cr0, {0}
     95c:	0203b203 	andeq	fp, r3, #805306368	@ 0x30000000
	sha256_final(&shactx, keytest);
     960:	b2049f32 	andlt	r9, r4, #50, 30	@ 0xc8
     964:	0104dc03 	tsteq	r4, r3, lsl #24
    len = encode_base64(keytest, AES_KEYLEN, b64test);
     968:	00000057 	andeq	r0, r0, r7, asr r0
     96c:	b8040000 	stmdalt	r4, {}	@ <UNPREDICTABLE>
    b64test[len] = '\0';
     970:	0101ce01 	tsteq	r1, r1, lsl #28
     974:	01ce0450 	biceq	r0, lr, r0, asr r4
     978:	540103a0 	strpl	r0, [r1], #-928	@ 0xfffffc60
    printf("Should be same as %s\n", b64test);
     97c:	00000000 	andeq	r0, r0, r0
     980:	01b80400 			@ <UNDEFINED> instruction: 0x01b80400
    printf("Switching fob AES key to new value. Try AES tests now.\n");
     984:	510101ce 	smlabtpl	r1, lr, r1, r0
     988:	a001ce04 	andge	ip, r1, r4, lsl #28
    AES_init_ctx(&ctx, ECDH_AESkey);
     98c:	00580103 	subseq	r0, r8, r3, lsl #2
     990:	00000000 	andeq	r0, r0, r0
}
     994:	ce01b804 	cdpgt	8, 0, cr11, cr1, cr4, {0}
     998:	04520101 	ldrbeq	r0, [r2], #-257	@ 0xfffffeff
     99c:	03a001ce 	moveq	r0, #-2147483597	@ 0x80000033
     9a0:	00005501 	andeq	r5, r0, r1, lsl #10
     9a4:	01ca0400 	biceq	r0, sl, r0, lsl #8
     9a8:	570103a0 	strpl	r0, [r1, -r0, lsr #7]
     9ac:	00000200 	andeq	r0, r0, r0, lsl #4
     9b0:	01ca0400 	biceq	r0, sl, r0, lsl #8
     9b4:	300201ce 	andcc	r0, r2, lr, asr #3
     9b8:	01ce049f 			@ <UNDEFINED> instruction: 0x01ce049f
     9bc:	560103a0 	strpl	r0, [r1], -r0, lsr #7
     9c0:	00000000 	andeq	r0, r0, r0
int send_ping(int argc, char** argv) {
     9c4:	01840400 	orreq	r0, r4, r0, lsl #8
    printf("Pinging the car.\n");
     9c8:	5001018e 	andpl	r0, r1, lr, lsl #3
    printf2("FOB_MESG PING\n");
     9cc:	a2018e04 	andge	r8, r1, #4, 28	@ 0x40
     9d0:	00540101 	subseq	r0, r4, r1, lsl #2
}
     9d4:	00000000 	andeq	r0, r0, r0
     9d8:	84040000 	strhi	r0, [r4], #-0
     9dc:	01018e01 	tsteq	r1, r1, lsl #28
int sha256_test(int argc, char** argv) {
     9e0:	018e0451 	orreq	r0, lr, r1, asr r4
    printf("Starting sha256 test\n");
     9e4:	560101a2 	strpl	r0, [r1], -r2, lsr #3
     9e8:	ac01a204 	sfmge	f2, 1, [r1], {4}
    BYTE text1[] = {"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"};
     9ec:	00540101 	subseq	r0, r4, r1, lsl #2
     9f0:	00000001 	andeq	r0, r0, r1
     9f4:	8e018a04 	vmlahi.f32	s16, s2, s8
     9f8:	04500101 	ldrbeq	r0, [r0], #-257	@ 0xfffffeff
     9fc:	01b8018e 			@ <UNDEFINED> instruction: 0x01b8018e
     a00:	00005501 	andeq	r5, r0, r1, lsl #10
     a04:	00000000 	andeq	r0, r0, r0
     a08:	72700400 	rsbsvc	r0, r0, #0, 8
     a0c:	72045001 	andvc	r5, r4, #1
    BYTE hash1[SHA256_BLOCK_SIZE] = {0x24,0x8d,0x6a,0x61,0xd2,0x06,0x38,0xb8,0xe5,0xc0,0x26,0x93,0x0c,0x3e,0x60,0x39,
     a10:	7e700378 	mrcvc	3, 3, r0, cr0, cr8, {3}
     a14:	8478049f 	ldrbthi	r0, [r8], #-1183	@ 0xfffffb61
     a18:	01a30401 			@ <UNDEFINED> instruction: 0x01a30401
     a1c:	00009f50 	andeq	r9, r0, r0, asr pc
    sha256_init(&shactx);
     a20:	04000000 	streq	r0, [r0], #-0
	sha256_update(&shactx, text1, strlen((char *)text1));
     a24:	50013632 	andpl	r3, r1, r2, lsr r6
     a28:	04703604 	ldrbteq	r3, [r0], #-1540	@ 0xfffff9fc
     a2c:	9f5001a3 	svcls	0x005001a3
	...
    b64_hash1[len] = '\0';
     a48:	16000400 	strne	r0, [r0], -r0, lsl #8
    len = encode_base64(buf, SHA256_BLOCK_SIZE, b64_buf);
     a4c:	16045001 	strne	r5, [r4], -r1
     a50:	01a30418 			@ <UNDEFINED> instruction: 0x01a30418
     a54:	18049f50 	stmdane	r4, {r4, r6, r8, r9, sl, fp, ip, pc}
    b64_buf[len] = '\0';
     a58:	0450011a 	ldrbeq	r0, [r0], #-282	@ 0xfffffee6
    printf("Base64 of SHA-256 test is %s\n", b64_buf);
     a5c:	a3041e1a 	movwge	r1, #19994	@ 0x4e1a
     a60:	049f5001 	ldreq	r5, [pc], #1	@ a68 <sha256_test+0x88>
    printf("Should be %s\n", b64_hash1);
     a64:	5001201e 	andpl	r2, r1, lr, lsl r0
     a68:	04242004 	strteq	r2, [r4], #-4
}
     a6c:	9f5001a3 	svcls	0x005001a3
     a70:	01262404 			@ <UNDEFINED> instruction: 0x01262404
     a74:	2a260450 	bcs	981bbc <__ROM_SIZE__+0x941bbc>
     a78:	5001a304 	andpl	sl, r1, r4, lsl #6
     a7c:	2c2a049f 	cfstrscs	mvf0, [sl], #-636	@ 0xfffffd84
     a80:	2c045001 	stccs	0, cr5, [r4], {1}
void __attribute__((optimize("O0"), weak)) initial_setup(void) {
     a84:	01a3042e 			@ <UNDEFINED> instruction: 0x01a3042e
     a88:	2e049f50 	mcrcs	15, 0, r9, cr4, cr0, {2}
  char *src = &_etext, *dst = &_data;
     a8c:	04500130 	ldrbeq	r0, [r0], #-304	@ 0xfffffed0
     a90:	a3043230 	movwge	r3, #16944	@ 0x4230
  if (dst != src)
     a94:	009f5001 	addseq	r5, pc, r1
     a98:	0000028d 	andeq	r0, r0, sp, lsl #5
    while (dst < &_edata) *(dst++) = *(src++);
     a9c:	00040005 	andeq	r0, r4, r5
	...
     aac:	a6048804 	strge	r8, [r4], -r4, lsl #16
     ab0:	04500104 	ldrbeq	r0, [r0], #-260	@ 0xfffffefc
  for (dst = &_bss; dst < &_ebss; dst++) *dst = 0;
     ab4:	04f004a6 	ldrbteq	r0, [r0], #1190	@ 0x4a6
     ab8:	f0045401 			@ <UNDEFINED> instruction: 0xf0045401
     abc:	01058604 	tsteq	r5, r4, lsl #12
     ac0:	05860450 	streq	r0, [r6, #1104]	@ 0x450
     ac4:	540105ee 	strpl	r0, [r1], #-1518	@ 0xfffffa12
	...
  platform_init();
     ad0:	04880400 	streq	r0, [r8], #1024	@ 0x400
}
     ad4:	51010498 			@ <UNDEFINED> instruction: 0x51010498
     ad8:	f0049804 			@ <UNDEFINED> instruction: 0xf0049804
     adc:	04550104 	ldrbeq	r0, [r5], #-260	@ 0xfffffefc
     ae0:	04f404f0 	ldrbteq	r0, [r4], #1264	@ 0x4f0
     ae4:	f4045101 	vst4.8	{d5,d7,d9,d11}, [r4], r1
     ae8:	0105ee04 	tsteq	r5, r4, lsl #28
     aec:	00000055 	andeq	r0, r0, r5, asr r0
static void delete(void) {
     af0:	00010100 	andeq	r0, r1, r0, lsl #2
  __write_char__(BACK_SPACE);
     af4:	00010000 	andeq	r0, r1, r0
     af8:	01000000 	mrseq	r0, (UNDEF: 0)
  __write_char__(SPACE);
     afc:	00000001 	andeq	r0, r0, r1
  __write_char__(BACK_SPACE);
     b00:	90040000 	andls	r0, r4, r0
     b04:	01049604 	tsteq	r4, r4, lsl #12
}
     b08:	04960452 	ldreq	r0, [r6], #1106	@ 0x452
static void clear_prompt(int char_count) {
     b0c:	5301049c 	movwpl	r0, #5276	@ 0x149c
  while (char_count) {
     b10:	a2049c04 	andge	r9, r4, #4, 24	@ 0x400
    delete ();
     b14:	01730304 	cmneq	r3, r4, lsl #6
  while (char_count) {
     b18:	04a2049f 	strteq	r0, [r2], #1183	@ 0x49f
}
     b1c:	530104a6 	movwpl	r0, #5286	@ 0x14a6
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
     b20:	f004ec04 			@ <UNDEFINED> instruction: 0xf004ec04
    auto_load[i].command(0, NULL);
     b24:	9f300204 	svcls	0x00300204
     b28:	f204f004 	vhadd.s8	d15, d4, d4
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
     b2c:	04520104 	ldrbeq	r0, [r2], #-260	@ 0xfffffefc
     b30:	04f804f2 	ldrbteq	r0, [r8], #1266	@ 0x4f2
     b34:	f8045301 			@ <UNDEFINED> instruction: 0xf8045301
     b38:	0304fe04 	movweq	pc, #19972	@ 0x4e04	@ <UNPREDICTABLE>
     b3c:	049f0173 	ldreq	r0, [pc], #371	@ b44 <show_history>
}
     b40:	058904fe 	streq	r0, [r9, #1278]	@ 0x4fe
static int show_history(int argc, char **argv) {
     b44:	96045301 	strls	r5, [r4], -r1, lsl #6
  uint32_t end_index = total_num_commands-1;
     b48:	0105ee05 	tsteq	r5, r5, lsl #28
  if (total_num_commands > NUM_HISTORY_ENTRIES) {
     b4c:	00000053 	andeq	r0, r0, r3, asr r0
     b50:	c8040000 	stmdagt	r4, {}	@ <UNPREDICTABLE>
    beg_index = total_num_commands - NUM_HISTORY_ENTRIES;
     b54:	0103d403 	tsteq	r3, r3, lsl #8
     b58:	03d40450 	bicseq	r0, r4, #80, 8	@ 0x50000000
  uint32_t beg_index = 0;
     b5c:	54010488 	strpl	r0, [r1], #-1160	@ 0xfffffb78
    printf("%s\n", cmd_history[index % NUM_HISTORY_ENTRIES]);
     b60:	00000000 	andeq	r0, r0, r0
     b64:	03c80400 	biceq	r0, r8, #0, 8
     b68:	510103d4 	ldrdpl	r0, [r1, -r4]
     b6c:	8803d404 	stmdahi	r3, {r2, sl, ip, lr, pc}
  for (uint32_t index = beg_index; index <= end_index; ++index) {
     b70:	00570104 	subseq	r0, r7, r4, lsl #2
}
     b74:	00000000 	andeq	r0, r0, r0
     b78:	d403c804 	strle	ip, [r3], #-2052	@ 0xfffff7fc
     b7c:	04520103 	ldrbeq	r0, [r2], #-259	@ 0xfffffefd
     b80:	048803d4 	streq	r0, [r8], #980	@ 0x3d4
int cmd_exec_status(int argc, char **argv) {
     b84:	02005601 	andeq	r5, r0, #1048576	@ 0x100000
  printf("%d\n", __cmd_exec_status);
     b88:	04000000 	streq	r0, [r0], #-0
     b8c:	03d403d0 	bicseq	r0, r4, #208, 6	@ 0x40000003
     b90:	049f3002 	ldreq	r3, [pc], #2	@ b98 <cmd_exec_status+0x14>
}
     b94:	048803d4 	streq	r0, [r8], #980	@ 0x3d4
     b98:	00005501 	andeq	r5, r0, r1, lsl #10
     b9c:	00000000 	andeq	r0, r0, r0
static int build_info(int argc, char **argv) {
     ba0:	0a000400 	beq	1ba8 <w32_bit+0x40>
  printf("Build: [" SHELL_VERSION ":" USER_REPO_VERSION "] - [" BUILD_USER
     ba4:	0a045001 	beq	114bb0 <__ROM_SIZE__+0xd4bb0>
}
     ba8:	590102ee 	stmdbpl	r1, {r1, r2, r3, r5, r6, r7, r9}
     bac:	f402ee04 			@ <UNDEFINED> instruction: 0xf402ee04
static void execute(int argc, char **argv) {
     bb0:	01a30402 			@ <UNDEFINED> instruction: 0x01a30402
     bb4:	00009f50 	andeq	r9, r0, r0, asr pc
  for (int i = 0; table[i].command_name != NULL; i++) {
     bb8:	04000000 	streq	r0, [r0], #-0
     bbc:	51013400 	tstpl	r1, r0, lsl #8
     bc0:	02f43404 	rscseq	r3, r4, #4, 8	@ 0x4000000
     bc4:	5101a304 	tstpl	r1, r4, lsl #6
     bc8:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
    if (strcmp(argv[0], table[i].command_name) == 0) {
     bcc:	00080800 	andeq	r0, r8, r0, lsl #16
     bd0:	82040000 	andhi	r0, r4, #0
      __cmd_exec_status = table[i].command(argc, &argv[0]);
     bd4:	0101be01 	tsteq	r1, r1, lsl #28
     bd8:	01be045a 			@ <UNDEFINED> instruction: 0x01be045a
     bdc:	5c01028a 	sfmpl	f0, 4, [r1], {138}	@ 0x8a
     be0:	a0028a04 	andge	r8, r2, r4, lsl #20
     be4:	007a0602 	rsbseq	r0, sl, r2, lsl #12
    printf("\"%s\": command not found. Use \"help\" to list all command.\n",
     be8:	9f220071 	svcls	0x00220071
     bec:	f402a004 	vst4.8	{d10-d13}, [r2], r4
    __cmd_exec_status = -1;
     bf0:	005c0102 	subseq	r0, ip, r2, lsl #2
     bf4:	07000000 	streq	r0, [r0, -r0]
     bf8:	00000007 	andeq	r0, r0, r7
}
     bfc:	be018604 	cfmadd32lt	mvax0, mvfx8, mvfx1, mvfx4
     c00:	045b0101 	ldrbeq	r0, [fp], #-257	@ 0xfffffeff
     c04:	028a01be 	addeq	r0, sl, #-2147483601	@ 0x8000002f
     c08:	8a045501 	bhi	116014 <__ROM_SIZE__+0xd6014>
int help(int argc, char **argv) {
     c0c:	0102a002 	tsteq	r2, r2
  if (argc > 1 && (strcmp(argv[1], "-l")==0)) {
     c10:	02a0045c 	adceq	r0, r0, #92, 8	@ 0x5c000000
     c14:	550102b8 	strpl	r0, [r1, #-696]	@ 0xfffffd48
     c18:	00000000 	andeq	r0, r0, r0
     c1c:	00000606 	andeq	r0, r0, r6, lsl #12
    printf("use: help -l for list only.\n\n");
     c20:	018a0400 	orreq	r0, sl, r0, lsl #8
  bool verbose = true;
     c24:	510101be 			@ <UNDEFINED> instruction: 0x510101be
    verbose = false;
     c28:	8a01be04 	bhi	70440 <__ROM_SIZE__+0x30440>
    printf("\n");
     c2c:	04540102 	ldrbeq	r0, [r4], #-258	@ 0xfffffefe
    i++;
     c30:	029c028a 	addseq	r0, ip, #-1610612728	@ 0xa0000008
  while (table[i].command_name != NULL) {
     c34:	9c045501 	cfstr32ls	mvfx5, [r4], {1}
     c38:	0102be02 	tsteq	r2, r2, lsl #28
     c3c:	00000054 	andeq	r0, r0, r4, asr r0
    printf(table[i].command_name);
     c40:	00050500 	andeq	r0, r5, r0, lsl #10
    if (verbose) {
     c44:	8e040000 	cdphi	0, 0, cr0, cr4, cr0, {0}
      printf("\n\t");
     c48:	0101be01 	tsteq	r1, r1, lsl #28
      printf(table[i].command_help);
     c4c:	01be0453 			@ <UNDEFINED> instruction: 0x01be0453
     c50:	5801028a 	stmdapl	r1, {r1, r3, r7, r9}
     c54:	9a028a04 	bls	a346c <__ROM_SIZE__+0x6346c>
    verbose = false;
     c58:	04540102 	ldrbeq	r0, [r4], #-258	@ 0xfffffefe
}
     c5c:	02ee029a 	rsceq	r0, lr, #-1610612727	@ 0xa0000009
     c60:	00005801 	andeq	r5, r0, r1, lsl #16
     c64:	00000404 	andeq	r0, r0, r4, lsl #8
     c68:	01940400 	orrseq	r0, r4, r0, lsl #8
     c6c:	5201028a 	andpl	r0, r1, #-1610612728	@ 0xa0000008
     c70:	96028a04 	strls	r8, [r2], -r4, lsl #20
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
     c74:	00780602 	rsbseq	r0, r8, r2, lsl #12
static void add_command_to_history(const char *cmd_str) {
     c78:	9f22007a 	svcls	0x0022007a
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
     c7c:	cc029604 	stcgt	6, cr9, [r2], {4}
     c80:	00520102 	subseq	r0, r2, r2, lsl #2
  int index = total_num_commands % NUM_HISTORY_ENTRIES;
     c84:	00030300 	andeq	r0, r3, r0, lsl #6
     c88:	9a040000 	bls	100c90 <__ROM_SIZE__+0xc0c90>
     c8c:	01028a01 	tsteq	r2, r1, lsl #20
     c90:	028a0457 	addeq	r0, sl, #1459617792	@ 0x57000000
  memcpy(&cmd_history[index], cmd_str, LINE_BUFF_SIZE);
     c94:	52010296 	andpl	r0, r1, #1610612745	@ 0x60000009
     c98:	d4029604 	strle	r9, [r2], #-1540	@ 0xfffff9fc
     c9c:	00570102 	subseq	r0, r7, r2, lsl #2
     ca0:	00020200 	andeq	r0, r2, r0, lsl #4
  total_num_commands++;
     ca4:	a0040000 	andge	r0, r4, r0
  curr_command_ptr = total_num_commands;
     ca8:	01028a01 	tsteq	r2, r1, lsl #20
     cac:	028a0456 	addeq	r0, sl, #1442840576	@ 0x56000000
     cb0:	57010292 			@ <UNDEFINED> instruction: 0x57010292
     cb4:	dc029204 	sfmle	f1, 1, [r2], {4}
     cb8:	00560102 	subseq	r0, r6, r2, lsl #2
static int parse_line(char **argv, char *line_buff, int argument_size) {
     cbc:	00000000 	andeq	r0, r0, r0
     cc0:	00000001 	andeq	r0, r0, r1
  int length = strlen(line_buff);
     cc4:	b201a604 	andlt	sl, r1, #4, 12	@ 0x400000
     cc8:	04500101 	ldrbeq	r0, [r0], #-257	@ 0xfffffeff
  int argc = 0;
     ccc:	01d001b2 	ldrheq	r0, [r0, #18]
         pos++)
     cd0:	8a045e01 	bhi	1184dc <__ROM_SIZE__+0xd84dc>
    for (; line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
     cd4:	01029002 	tsteq	r2, r2
     cd8:	02900456 	addseq	r0, r0, #1442840576	@ 0x56000000
     cdc:	5e0102f4 	mcrpl	2, 0, r0, cr1, cr4, {7}
     ce0:	00000200 	andeq	r0, r0, r0, lsl #4
    if (line_buff[pos] == '\t' || line_buff[pos] == SPACE)
     ce4:	00000100 	andeq	r0, r0, r0, lsl #2
     ce8:	0e080400 	cfcpyseq	mvf0, mvf8
      line_buff[pos] = END_OF_LINE;
     cec:	049f3002 	ldreq	r3, [pc], #2	@ cf4 <parse_line+0x38>
  while (pos <= length) {
     cf0:	0101920e 	tsteq	r1, lr, lsl #4
    if (line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
     cf4:	01a60452 			@ <UNDEFINED> instruction: 0x01a60452
     cf8:	300201be 			@ <UNDEFINED> instruction: 0x300201be
     cfc:	01be049f 			@ <UNDEFINED> instruction: 0x01be049f
     d00:	500102b2 			@ <UNDEFINED> instruction: 0x500102b2
      argv[argc++] = &line_buff[pos];
     d04:	00000200 	andeq	r0, r0, r0, lsl #4
     d08:	0e080400 	cfcpyseq	mvf0, mvf8
}
     d0c:	049f3002 	ldreq	r3, [pc], #2	@ d14 <prefix_match+0x6>
static int prefix_match(char *sub, int len, const char *str) {
     d10:	5001340e 	andpl	r3, r1, lr, lsl #8
     d14:	04000000 	streq	r0, [r0], #-0
  if (sub == NULL || str == NULL || len <= 0 || len > strlen(str)) {
     d18:	02a001ec 	adceq	r0, r0, #236, 2	@ 0x3b
     d1c:	00005a01 	andeq	r5, r0, r1, lsl #20
     d20:	028a0400 	addeq	r0, sl, #0, 8
     d24:	510102a0 	smlatbpl	r1, r0, r2, r0
  for (int i = 0; i<len; ++i) {
     d28:	00038c00 	andeq	r8, r3, r0, lsl #24
     d2c:	04000500 	streq	r0, [r0], #-1280	@ 0xfffffb00
	...
      return FALSE;
     d44:	02dc0400 	sbcseq	r0, ip, #0, 8
}
     d48:	910202ee 	smlattls	r2, lr, r2, r0
static void handle_up_arrow(char *cmd_buff, int *char_count) {
     d4c:	02ee0470 	rsceq	r0, lr, #112, 8	@ 0x70000000
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
     d50:	540103f0 	strpl	r0, [r1], #-1008	@ 0xfffffc10
     d54:	8403f004 	strhi	pc, [r3], #-4
     d58:	04550104 	ldrbeq	r0, [r5], #-260	@ 0xfffffefc
     d5c:	04880484 	streq	r0, [r8], #1156	@ 0x484
      curr_command_ptr == 0) {
     d60:	88045401 	stmdahi	r4, {r0, sl, ip, lr}
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
     d64:	01048e04 	tsteq	r4, r4, lsl #28
    printf("%s", cmd_buff);
     d68:	048e0455 	streq	r0, [lr], #1109	@ 0x455
     d6c:	5401049e 	strpl	r0, [r1], #-1182	@ 0xfffffb62
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
     d70:	a2049e04 	andge	r9, r4, #4, 28	@ 0x40
     d74:	04550104 	ldrbeq	r0, [r5], #-260	@ 0xfffffefc
  curr_command_ptr--;
     d78:	04b804ac 	ldrteq	r0, [r8], #1196	@ 0x4ac
     d7c:	01005401 	tsteq	r0, r1, lsl #8
     d80:	01010000 	mrseq	r0, (UNDEF: 1)
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
     d84:	01010000 	mrseq	r0, (UNDEF: 1)
     d88:	01010000 	mrseq	r0, (UNDEF: 1)
     d8c:	01010000 	mrseq	r0, (UNDEF: 1)
     d90:	01000000 	mrseq	r0, (UNDEF: 0)
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
     d94:	01010000 	mrseq	r0, (UNDEF: 1)
     d98:	04000000 	streq	r0, [r0], #-0
     d9c:	02ee02e8 	rsceq	r0, lr, #232, 4	@ 0x8000000e
  *char_count = strlen(cmd_buff);
     da0:	049f3002 	ldreq	r3, [pc], #2	@ da8 <handle_up_arrow+0x5e>
     da4:	038802ee 	orreq	r0, r8, #-536870898	@ 0xe000000e
  printf("%s", cmd_buff);
     da8:	88045501 	stmdahi	r4, {r0, r8, sl, ip, lr}
     dac:	02038e03 	andeq	r8, r3, #3, 28	@ 0x30
     db0:	8e049f31 	mcrhi	15, 0, r9, cr4, cr1, {1}
     db4:	0103bc03 	tsteq	r3, r3, lsl #24
     db8:	03bc0455 			@ <UNDEFINED> instruction: 0x03bc0455
static void handle_down_arrow(char *cmd_buff, int *char_count) {
     dbc:	300203c0 	andcc	r0, r2, r0, asr #7
     dc0:	03c0049f 	biceq	r0, r0, #-1627389952	@ 0x9f000000
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
     dc4:	550103d6 	strpl	r0, [r1, #-982]	@ 0xfffffc2a
     dc8:	da03d604 	ble	f65e0 <__ROM_SIZE__+0xb65e0>
  *char_count = 0;
     dcc:	9f300203 	svcls	0x00300203
  if (curr_command_ptr == total_num_commands) return;
     dd0:	ea03da04 	b	f75e8 <__ROM_SIZE__+0xb75e8>
     dd4:	04550103 	ldrbeq	r0, [r5], #-259	@ 0xfffffefd
     dd8:	03ee03ea 	mvneq	r0, #-1476395005	@ 0xa8000003
  curr_command_ptr++;
     ddc:	049f3002 	ldreq	r3, [pc], #2	@ de4 <handle_down_arrow+0x28>
     de0:	03f003ee 	mvnseq	r0, #-1207959549	@ 0xb8000003
     de4:	82045501 	andhi	r5, r4, #4194304	@ 0x400000
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
     de8:	02048804 	andeq	r8, r4, #4, 16	@ 0x40000
     dec:	8e049f30 	mcrhi	15, 0, r9, cr4, cr0, {1}
     df0:	01049804 	tsteq	r4, r4, lsl #16
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
     df4:	04980455 	ldreq	r0, [r8], #1109	@ 0x455
     df8:	3002049e 	mulcc	r2, lr, r4
     dfc:	04ac049f 	strteq	r0, [ip], #1183	@ 0x49f
     e00:	550104b8 	strpl	r0, [r1, #-1208]	@ 0xfffffb48
  *char_count = strlen(cmd_buff);
     e04:	00000100 	andeq	r0, r0, r0, lsl #2
     e08:	01010000 	mrseq	r0, (UNDEF: 1)
  printf("%s", cmd_buff);
     e0c:	03ee0400 	mvneq	r0, #0, 8
     e10:	310203f8 	strdcc	r0, [r2, -r8]
}
     e14:	03f8049f 	mvnseq	r0, #-1627389952	@ 0x9f000000
     e18:	520103ff 	andpl	r0, r1, #-67108861	@ 0xfc000003
void set_read_char(int (*func)(void)) { __read_char__ = func; }
     e1c:	88048804 	stmdahi	r4, {r2, fp, pc}
     e20:	9f310204 	svcls	0x00310204
     e24:	8e048804 	cdphi	8, 0, cr8, cr4, cr4, {0}
void set_read_char2(int (*func)(void)) { __read_char2__ = func; }
     e28:	9f320204 	svcls	0x00320204
	...
void set_write_char2(void (*func)(char)) { __write_char2__ = func; }
     e48:	4c1c0400 	cfldrsmi	mvf0, [ip], {-0}
}
     e4c:	4c045001 	stcmi	0, cr5, [r4], {1}
}
     e50:	01a30452 			@ <UNDEFINED> instruction: 0x01a30452
  if (cmd_buff == NULL || char_count <= 0) {
     e54:	52049f50 	andpl	r9, r4, #80, 30	@ 0x140
static void handle_tab(char *cmd_buff, int *char_count) {
     e58:	04500158 	ldrbeq	r0, [r0], #-344	@ 0xfffffea8
     e5c:	a3046258 	movwge	r6, #16984	@ 0x4258
  int last_match = -1;
     e60:	049f5001 	ldreq	r5, [pc], #1	@ e68 <handle_tab+0x16>
  int match_count = 0;
     e64:	50017262 	andpl	r7, r1, r2, ror #4
  int i = 0;
     e68:	01a27204 			@ <UNDEFINED> instruction: 0x01a27204
    i++;
     e6c:	5001a304 	andpl	sl, r1, r4, lsl #6
  while (table[i].command_name != NULL) { //loop over all commands
     e70:	01a2049f 			@ <UNDEFINED> instruction: 0x01a2049f
     e74:	500101a8 	andpl	r0, r1, r8, lsr #3
     e78:	b401a804 	strlt	sl, [r1], #-2052	@ 0xfffff7fc
    if (prefix_match(cmd_buff, *char_count, table[i].command_name)) {
     e7c:	01a30402 			@ <UNDEFINED> instruction: 0x01a30402
     e80:	b4049f50 	strlt	r9, [r4], #-3920	@ 0xfffff0b0
     e84:	0102ba02 	tsteq	r2, r2, lsl #20
      match_count++;
     e88:	02ba0450 	adcseq	r0, sl, #80, 8	@ 0x50000000
      printf("\n%s", table[i].command_name);
     e8c:	a30402be 	movwge	r0, #17086	@ 0x42be
     e90:	049f5001 	ldreq	r5, [pc], #1	@ e98 <handle_tab+0x46>
      last_match = i;
     e94:	02c002be 	sbceq	r0, r0, #-536870901	@ 0xe000000b
  if (match_count == 1) {
     e98:	c0045001 	andgt	r5, r4, r1
     e9c:	0402c202 	streq	ip, [r2], #-514	@ 0xfffffdfe
  if (match_count) {
     ea0:	9f5001a3 	svcls	0x005001a3
}
     ea4:	c402c204 	strgt	ip, [r2], #-516	@ 0xfffffdfc
    memcpy(cmd_buff, table[last_match].command_name, LINE_BUFF_SIZE);
     ea8:	04500102 	ldrbeq	r0, [r0], #-258	@ 0xfffffefe
     eac:	02dc02c4 	sbcseq	r0, ip, #196, 4	@ 0x4000000c
     eb0:	5001a304 	andpl	sl, r1, r4, lsl #6
     eb4:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
	...
    prepend_prompt();
     ecc:	014d1c04 	cmpeq	sp, r4, lsl #24
    printf(PROMPT);
     ed0:	524d0451 	subpl	r0, sp, #1358954496	@ 0x51000000
     ed4:	5101a304 	tstpl	r1, r4, lsl #6
    printf("%s", cmd_buff);
     ed8:	5b52049f 	blpl	148215c <__ROM_SIZE__+0x144215c>
     edc:	5b045101 	blpl	1152e8 <__ROM_SIZE__+0xd52e8>
     ee0:	01a30462 			@ <UNDEFINED> instruction: 0x01a30462
     ee4:	62049f51 	andvs	r9, r4, #324	@ 0x144
     ee8:	04510172 	ldrbeq	r0, [r1], #-370	@ 0xfffffe8e
     eec:	0401a272 	streq	sl, [r1], #-626	@ 0xfffffd8e
     ef0:	9f5101a3 	svcls	0x005101a3
__attribute__((weak)) int active_prompt() { return TRUE; }
     ef4:	a901a204 	stmdbge	r1, {r2, r9, sp, pc}
static void shell(void) {
     ef8:	04510101 	ldrbeq	r0, [r1], #-257	@ 0xfffffeff
  int count = 0;
     efc:	02b401a9 	adcseq	r0, r4, #1073741866	@ 0x4000002a
  for (int i = 0; i < LINE_BUFF_SIZE; i++) line_buff[i] = 0;
     f00:	5101a304 	tstpl	r1, r4, lsl #6
     f04:	02b4049f 	adcseq	r0, r4, #-1627389952	@ 0x9f000000
     f08:	510102ba 			@ <UNDEFINED> instruction: 0x510102ba
     f0c:	be02ba04 	vmlalt.f32	s22, s4, s8
     f10:	01a30402 			@ <UNDEFINED> instruction: 0x01a30402
  for (int i = 0; i < MAX_ARG_COUNT; i++) argv[i] = NULL;
     f14:	be049f51 	mcrlt	15, 0, r9, cr4, cr1, {2}
     f18:	0102dc02 	tsteq	r2, r2, lsl #24
     f1c:	00000051 	andeq	r0, r0, r1, asr r0
	...
    if (s == -1) { s = __read_char2__();}
     f38:	013a1c04 	teqeq	sl, r4, lsl #24
     f3c:	523a0452 	eorspl	r0, sl, #1375731712	@ 0x52000000
    if (s != -1) {
     f40:	52045401 	andpl	r5, r4, #16777216	@ 0x1000000
     f44:	0452015b 	ldrbeq	r0, [r2], #-347	@ 0xfffffea5
      loop();
     f48:	54015e5b 	strpl	r5, [r1], #-3675	@ 0xfffff1a5
        line_buff[count] = END_OF_LINE;
     f4c:	04625e04 	strbteq	r5, [r2], #-3588	@ 0xfffff1fc
     f50:	9f5201a3 	svcls	0x005201a3
     f54:	016a6204 	cmneq	sl, r4, lsl #4
     f58:	726a0452 	rsbvc	r0, sl, #1375731712	@ 0x52000000
        __write_char__(NEW_LINE);
     f5c:	72045401 	andvc	r5, r4, #16777216	@ 0x1000000
     f60:	a30401a2 	movwge	r0, #16802	@ 0x41a2
  add_command_to_history(line_buff);
     f64:	049f5201 	ldreq	r5, [pc], #513	@ f6c <shell+0x74>
  argc = parse_line(argv, line_buff, MAX_ARG_COUNT);
     f68:	01ae01a2 			@ <UNDEFINED> instruction: 0x01ae01a2
     f6c:	ae045401 	cdpge	4, 0, cr5, cr4, cr1, {0}
     f70:	0402b401 	streq	fp, [r2], #-1025	@ 0xfffffbff
  if (argc > 0) execute(argc, argv);
     f74:	9f5201a3 	svcls	0x005201a3
}
     f78:	b802b404 	stmdalt	r2, {r2, sl, ip, sp, pc}
        if (!__echo) {
     f7c:	04540102 	ldrbeq	r0, [r4], #-258	@ 0xfffffefe
     f80:	02be02b8 	adcseq	r0, lr, #184, 4	@ 0x8000000b
        if (count == 0) continue;
     f84:	5201a304 	andpl	sl, r1, #4, 6	@ 0x10000000
        count--;
     f88:	02be049f 	adcseq	r0, lr, #-1627389952	@ 0x9f000000
        line_buff[count] = END_OF_LINE;
     f8c:	520102dc 	andpl	r0, r1, #220, 4	@ 0xc000000d
     f90:	00000200 	andeq	r0, r0, r0, lsl #4
	...
        __write_char__(c);
     fa0:	04000000 	streq	r0, [r0], #-0
     fa4:	30025e22 	andcc	r5, r2, r2, lsr #28
    if (!active_prompt()) {
     fa8:	7262049f 	rsbvc	r0, r2, #-1627389952	@ 0x9f000000
     fac:	049f3002 	ldreq	r3, [pc], #2	@ fb4 <shell+0xbc>
    s = __read_char__();
     fb0:	01019472 	tsteq	r1, r2, ror r4
     fb4:	01940454 	orrseq	r0, r4, r4, asr r4
    if (s == -1) { s = __read_char2__();}
     fb8:	740301a2 	strvc	r0, [r3], #-418	@ 0xfffffe5e
     fbc:	a2049f7f 	andge	r9, r4, #508	@ 0x1fc
      if (c == CARRIAGE_RETURN || c == NEW_LINE) {
     fc0:	0201ae01 	andeq	sl, r1, #1, 28
     fc4:	ae049f30 	mcrge	15, 0, r9, cr4, cr0, {1}
      if (c == DELETE || c == BACK_SPACE) {
     fc8:	0101e801 	tsteq	r1, r1, lsl #16
     fcc:	01e80454 	mvneq	r0, r4, asr r4
      } else if (c == ESCAPE) {
     fd0:	740301f4 	strvc	r0, [r3], #-500	@ 0xfffffe0c
      } else if (c == SQUARE_BRACKET_OPEN && special_key == 1) {
     fd4:	f4049f7f 			@ <UNDEFINED> instruction: 0xf4049f7f
      } else if ((c == 'C' || c == 'D') && special_key != 0) {
     fd8:	01029201 	tsteq	r2, r1, lsl #4
     fdc:	02920454 	addseq	r0, r2, #84, 8	@ 0x54000000
     fe0:	300202dc 	ldrdcc	r0, [r2], -ip
      } else if ((c == 'A' || c == 'B') && special_key == 2) {
     fe4:	0001009f 	muleq	r1, pc, r0	@ <UNPREDICTABLE>
	...
        line_buff[count] = c;
     ff0:	026e6204 	rsbeq	r6, lr, #4, 4	@ 0x40000000
     ff4:	72049f30 	andvc	r9, r4, #48, 30	@ 0xc0
     ff8:	5501019c 	strpl	r0, [r1, #-412]	@ 0xfffffe64
        count++;
     ffc:	a2019c04 	andge	r9, r1, #4, 24	@ 0x400
    1000:	04510101 	ldrbeq	r0, [r1], #-257	@ 0xfffffeff
          delete ();
    1004:	01ca01ac 	biceq	r0, sl, ip, lsr #3
          delete ();
    1008:	be045501 	cfsh32lt	mvfx5, mvfx4, #1
      } else if (c == SQUARE_BRACKET_OPEN && special_key == 1) {
    100c:	0202c202 	andeq	ip, r2, #536870912	@ 0x20000000
        special_key = 2;
    1010:	01009f30 	tsteq	r0, r0, lsr pc
	...
      } else if ((c == 'A' || c == 'B') && special_key == 2) {
    101c:	3e300400 	cfabsscc	mvf0, mvf0
        if (!__echo) {
    1020:	049f3002 	ldreq	r3, [pc], #2	@ 1028 <shell+0x130>
    1024:	01f001ca 	mvnseq	r0, sl, asr #3
          clear_prompt(count + 4);
    1028:	f0045501 			@ <UNDEFINED> instruction: 0xf0045501
    102c:	0101f401 	tsteq	r1, r1, lsl #8	@ <UNPREDICTABLE>
        if (c == 'A') {
    1030:	01f40451 	mvnseq	r0, r1, asr r4
          handle_down_arrow(line_buff, &count);
    1034:	55010292 	strpl	r0, [r1, #-658]	@ 0xfffffd6e
    1038:	dc02c204 	sfmle	f4, 1, [r2], {4}
        continue;
    103c:	9f300202 	svcls	0x00300202
          clear_prompt(count);
    1040:	00000000 	andeq	r0, r0, r0
    1044:	02920400 	addseq	r0, r2, #0, 8
          handle_up_arrow(line_buff, &count);
    1048:	540102b4 	strpl	r0, [r1], #-692	@ 0xfffffd4c
    104c:	be02ba04 	vmlalt.f32	s22, s4, s8
        handle_tab(line_buff, &count);
    1050:	00540102 	subseq	r0, r4, r2, lsl #2
    1054:	00010100 	andeq	r0, r1, r0, lsl #2
        continue;
    1058:	00000000 	andeq	r0, r0, r0
  if (argc > 0) execute(argc, argv);
    105c:	92029204 	andls	r9, r2, #4, 4	@ 0x40000000
}
    1060:	04520102 	ldrbeq	r0, [r2], #-258	@ 0xfffffefe
    1064:	029e0292 	addseq	r0, lr, #536870921	@ 0x20000009
    1068:	049f3102 	ldreq	r3, [pc], #258	@ 1070 <prompt>
    106c:	02b4029e 	adcseq	r0, r4, #-536870903	@ 0xe0000009
void prompt() {
    1070:	ba045201 	blt	11587c <__ROM_SIZE__+0xd587c>
  initial_setup();
    1074:	0102be02 	tsteq	r2, r2, lsl #28
  exec_auto_cmds();
    1078:	00000052 	andeq	r0, r0, r2, asr r0
  setup();
    107c:	00000000 	andeq	r0, r0, r0
  decode_base64(AES_key_b64, 44, AES_key);
    1080:	92040000 	andls	r0, r4, #0
    1084:	01029b02 	tsteq	r2, r2, lsl #22
    1088:	029b0453 	addseq	r0, fp, #1392508928	@ 0x53000000
    108c:	750802a0 	strvc	r0, [r8, #-672]	@ 0xfffffd60
  AES_init_ctx(&ctx, AES_key);
    1090:	25007400 	strcs	r7, [r0, #-1024]	@ 0xfffffc00
    1094:	049f1a3f 	ldreq	r1, [pc], #2623	@ 109c <prompt+0x2c>
    shell();
    1098:	02ac02a8 	adceq	r0, ip, #168, 4	@ 0x8000000a
  while (TRUE) {
    109c:	3f007305 	svccc	0x00007305
    10a0:	ac049f1a 	stcge	15, cr9, [r4], {26}
    10a4:	0102b402 	tsteq	r2, r2, lsl #8
int exec(char *cmd_str) {
    10a8:	00000053 	andeq	r0, r0, r3, asr r0
    10ac:	00040000 	andeq	r0, r4, r0
  argc = parse_line(argv, cmd_str, MAX_ARG_COUNT);
    10b0:	04500106 	ldrbeq	r0, [r0], #-262	@ 0xfffffefa
    10b4:	54011606 	strpl	r1, [r1], #-1542	@ 0xfffff9fa
  if (argc > 0) execute(argc, argv);
    10b8:	00038c00 	andeq	r8, r3, r0, lsl #24
  return __cmd_exec_status;
    10bc:	04000500 	streq	r0, [r0], #-1280	@ 0xfffffb00
	...
cmd get_function_addr(char *cmd_str) {
    10d4:	02dc0400 	sbcseq	r0, ip, #0, 8
  for (int i = 0; table[i].command_name != NULL; i++) {
    10d8:	910202ee 	smlattls	r2, lr, r2, r0
    10dc:	02ee0470 	rsceq	r0, lr, #112, 8	@ 0x70000000
    10e0:	540103f0 	strpl	r0, [r1], #-1008	@ 0xfffffc10
    10e4:	8403f004 	strhi	pc, [r3], #-4
    10e8:	04550104 	ldrbeq	r0, [r5], #-260	@ 0xfffffefc
    if (strcmp(cmd_str, table[i].command_name) == 0) {
    10ec:	04880484 	streq	r0, [r8], #1156	@ 0x484
    10f0:	88045401 	stmdahi	r4, {r0, sl, ip, lr}
      return table[i].command;
    10f4:	01048e04 	tsteq	r4, r4, lsl #28
    10f8:	048e0455 	streq	r0, [lr], #1109	@ 0x455
  return NULL;
    10fc:	5401049e 	strpl	r0, [r1], #-1182	@ 0xfffffb62
}
    1100:	a2049e04 	andge	r9, r4, #4, 28	@ 0x40
  if(v < 26) return v + 'A';
    1104:	04550104 	ldrbeq	r0, [r5], #-260	@ 0xfffffefc
  if(v < 52) return v + 71;
    1108:	04b804ac 	ldrteq	r0, [r8], #1196	@ 0x4ac
  if(v < 62) return v - 4;
    110c:	01005401 	tsteq	r0, r1, lsl #8
  if(v == 62) return '+';
    1110:	01010000 	mrseq	r0, (UNDEF: 1)
  if(v == 63) return '/';
    1114:	01010000 	mrseq	r0, (UNDEF: 1)
  return 64;
    1118:	01010000 	mrseq	r0, (UNDEF: 1)
  if(v < 26) return v + 'A';
    111c:	01010000 	mrseq	r0, (UNDEF: 1)
    1120:	01000000 	mrseq	r0, (UNDEF: 0)
  if(v < 52) return v + 71;
    1124:	01010000 	mrseq	r0, (UNDEF: 1)
  if(v < 62) return v - 4;
    1128:	04000000 	streq	r0, [r0], #-0
    112c:	02ee02e8 	rsceq	r0, lr, #232, 4	@ 0x8000000e
  if(v == 62) return '+';
    1130:	049f3002 	ldreq	r3, [pc], #2	@ 1138 <base64_to_binary+0x2>
}
    1134:	038802ee 	orreq	r0, r8, #-536870898	@ 0xe000000e
  if('A' <= c && c <= 'Z') return c - 'A';
    1138:	88045501 	stmdahi	r4, {r0, r8, sl, ip, lr}
    113c:	02038e03 	andeq	r8, r3, #3, 28	@ 0x30
  if('a' <= c && c <= 'z') return c - 71;
    1140:	8e049f31 	mcrhi	15, 0, r9, cr4, cr1, {1}
    1144:	0103bc03 	tsteq	r3, r3, lsl #24
    1148:	03bc0455 			@ <UNDEFINED> instruction: 0x03bc0455
  if('0' <= c && c <= '9') return c + 4;
    114c:	300203c0 	andcc	r0, r2, r0, asr #7
    1150:	03c0049f 	biceq	r0, r0, #-1627389952	@ 0x9f000000
  if(c == '+') return 62;
    1154:	550103d6 	strpl	r0, [r1, #-982]	@ 0xfffffc2a
  if(c == '/') return 63;
    1158:	da03d604 	ble	f6970 <__ROM_SIZE__+0xb6970>
  return 255;
    115c:	9f300203 	svcls	0x00300203
  if('a' <= c && c <= 'z') return c - 71;
    1160:	ea03da04 	b	f7978 <__ROM_SIZE__+0xb7978>
    1164:	04550103 	ldrbeq	r0, [r5], #-259	@ 0xfffffefd
  if('0' <= c && c <= '9') return c + 4;
    1168:	03ee03ea 	mvneq	r0, #-1476395005	@ 0xa8000003
  if(c == '+') return 62;
    116c:	049f3002 	ldreq	r3, [pc], #2	@ 1174 <encode_base64_length>
  if(c == '/') return 63;
    1170:	03f003ee 	mvnseq	r0, #-1207959549	@ 0xb8000003
  return (input_length + 2)/3*4;
    1174:	82045501 	andhi	r5, r4, #4194304	@ 0x400000
    1178:	02048804 	andeq	r8, r4, #4, 16	@ 0x40000
    117c:	8e049f30 	mcrhi	15, 0, r9, cr4, cr0, {1}
}
    1180:	01049804 	tsteq	r4, r4, lsl #16
    1184:	04980455 	ldreq	r0, [r8], #1109	@ 0x455
unsigned int decode_base64_length(unsigned char input[], unsigned int input_length) {
    1188:	3002049e 	mulcc	r2, lr, r4
    118c:	04ac049f 	strteq	r0, [ip], #1183	@ 0x49f
  while(base64_to_binary(input[0]) < 64 && (unsigned int) (input - start) < input_length) {
    1190:	550104b8 	strpl	r0, [r1, #-1208]	@ 0xfffffb48
    1194:	00000100 	andeq	r0, r0, r0, lsl #2
    1198:	01010000 	mrseq	r0, (UNDEF: 1)
    119c:	03ee0400 	mvneq	r0, #0, 8
    11a0:	310203f8 	strdcc	r0, [r2, -r8]
  input_length = input - start;
    11a4:	03f8049f 	mvnseq	r0, #-1627389952	@ 0x9f000000
  return input_length/4*3 + (input_length % 4 ? input_length % 4 - 1 : 0);
    11a8:	520103ff 	andpl	r0, r1, #-67108861	@ 0xfc000003
    11ac:	88048804 	stmdahi	r4, {r2, fp, pc}
    11b0:	9f310204 	svcls	0x00310204
}
    11b4:	8e048804 	cdphi	8, 0, cr8, cr4, cr4, {0}
  return input_length/4*3 + (input_length % 4 ? input_length % 4 - 1 : 0);
    11b8:	9f320204 	svcls	0x00320204
	...
    output[0] = binary_to_base64(                         input[0] >> 2);
    11d8:	4c1c0400 	cfldrsmi	mvf0, [ip], {-0}
    output[1] = binary_to_base64((input[0] & 0x03) << 4 | input[1] >> 4);
    11dc:	4c045001 	stcmi	0, cr5, [r4], {1}
    11e0:	01a30452 			@ <UNDEFINED> instruction: 0x01a30452
    11e4:	52049f50 	andpl	r9, r4, #80, 30	@ 0x140
    11e8:	04500158 	ldrbeq	r0, [r0], #-344	@ 0xfffffea8
    11ec:	a3046258 	movwge	r6, #16984	@ 0x4258
    output[2] = binary_to_base64((input[1] & 0x0F) << 2 | input[2] >> 6);
    11f0:	049f5001 	ldreq	r5, [pc], #1	@ 11f8 <encode_base64+0x3c>
    11f4:	50017262 	andpl	r7, r1, r2, ror #4
    11f8:	01a27204 			@ <UNDEFINED> instruction: 0x01a27204
    11fc:	5001a304 	andpl	sl, r1, r4, lsl #6
    1200:	01a2049f 			@ <UNDEFINED> instruction: 0x01a2049f
    output[3] = binary_to_base64( input[2] & 0x3F);
    1204:	500101a8 	andpl	r0, r1, r8, lsr #3
    1208:	b401a804 	strlt	sl, [r1], #-2052	@ 0xfffff7fc
    120c:	01a30402 			@ <UNDEFINED> instruction: 0x01a30402
    input += 3;
    1210:	b4049f50 	strlt	r9, [r4], #-3920	@ 0xfffff0b0
  for(unsigned int i = 0; i < full_sets; ++i) {
    1214:	0102ba02 	tsteq	r2, r2, lsl #20
    1218:	02ba0450 	adcseq	r0, sl, #80, 8	@ 0x50000000
  switch(input_length % 3) {
    121c:	a30402be 	movwge	r0, #17086	@ 0x42be
    1220:	049f5001 	ldreq	r5, [pc], #1	@ 1228 <encode_base64+0x6c>
    1224:	02c002be 	sbceq	r0, r0, #-536870901	@ 0xe000000b
    1228:	c0045001 	andgt	r5, r4, r1
    122c:	0402c202 	streq	ip, [r2], #-514	@ 0xfffffdfe
    1230:	9f5001a3 	svcls	0x005001a3
    1234:	c402c204 	strgt	ip, [r2], #-516	@ 0xfffffdfc
  return encode_base64_length(input_length);
    1238:	04500102 	ldrbeq	r0, [r0], #-258	@ 0xfffffefe
}
    123c:	02dc02c4 	sbcseq	r0, ip, #196, 4	@ 0x4000000c
      output[0] = '\0';
    1240:	5001a304 	andpl	sl, r1, r4, lsl #6
      output[0] = binary_to_base64(                         input[0] >> 2);
    1244:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
	...
      output[2] = '=';
    125c:	014d1c04 	cmpeq	sp, r4, lsl #24
      output[3] = '=';
    1260:	524d0451 	subpl	r0, sp, #1358954496	@ 0x51000000
      output[4] = '\0';
    1264:	5101a304 	tstpl	r1, r4, lsl #6
      output[0] = binary_to_base64(                         input[0] >> 2);
    1268:	5b52049f 	blpl	14824ec <__ROM_SIZE__+0x14424ec>
    126c:	5b045101 	blpl	115678 <__ROM_SIZE__+0xd5678>
    1270:	01a30462 			@ <UNDEFINED> instruction: 0x01a30462
      output[1] = binary_to_base64((input[0] & 0x03) << 4 | input[1] >> 4);
    1274:	62049f51 	andvs	r9, r4, #324	@ 0x144
    1278:	04510172 	ldrbeq	r0, [r1], #-370	@ 0xfffffe8e
    127c:	0401a272 	streq	sl, [r1], #-626	@ 0xfffffd8e
    1280:	9f5101a3 	svcls	0x005101a3
    1284:	a901a204 	stmdbge	r1, {r2, r9, sp, pc}
      output[2] = binary_to_base64((input[1] & 0x0F) << 2);
    1288:	04510101 	ldrbeq	r0, [r1], #-257	@ 0xfffffeff
    128c:	02b401a9 	adcseq	r0, r4, #1073741866	@ 0x4000002a
    1290:	5101a304 	tstpl	r1, r4, lsl #6
      output[3] = '=';
    1294:	02b4049f 	adcseq	r0, r4, #-1627389952	@ 0x9f000000
      output[4] = '\0';
    1298:	510102ba 			@ <UNDEFINED> instruction: 0x510102ba
      break;
    129c:	be02ba04 	vmlalt.f32	s22, s4, s8
    12a0:	01a30402 			@ <UNDEFINED> instruction: 0x01a30402
unsigned int decode_base64(unsigned char input[], unsigned int input_length, unsigned char output[]) {
    12a4:	be049f51 	mcrlt	15, 0, r9, cr4, cr1, {2}
    12a8:	0102dc02 	tsteq	r2, r2, lsl #24
  unsigned int output_length = decode_base64_length(input, input_length);
    12ac:	00000051 	andeq	r0, r0, r1, asr r0
	...
    output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
    12c8:	013a1c04 	teqeq	sl, r4, lsl #24
    output[1] = base64_to_binary(input[1]) << 4 | base64_to_binary(input[2]) >> 2;
    12cc:	523a0452 	eorspl	r0, sl, #1375731712	@ 0x52000000
    12d0:	52045401 	andpl	r5, r4, #16777216	@ 0x1000000
    12d4:	0452015b 	ldrbeq	r0, [r2], #-347	@ 0xfffffea5
    12d8:	54015e5b 	strpl	r5, [r1], #-3675	@ 0xfffff1a5
    12dc:	04625e04 	strbteq	r5, [r2], #-3588	@ 0xfffff1fc
    output[2] = base64_to_binary(input[2]) << 6 | base64_to_binary(input[3]);
    12e0:	9f5201a3 	svcls	0x005201a3
    12e4:	016a6204 	cmneq	sl, r4, lsl #4
    12e8:	726a0452 	rsbvc	r0, sl, #1375731712	@ 0x52000000
    12ec:	72045401 	andvc	r5, r4, #16777216	@ 0x1000000
    input += 4;
    12f0:	a30401a2 	movwge	r0, #16802	@ 0x41a2
  for(unsigned int i = 2; i < output_length; i += 3) {
    12f4:	049f5201 	ldreq	r5, [pc], #513	@ 12fc <decode_base64+0x58>
    12f8:	01ae01a2 			@ <UNDEFINED> instruction: 0x01ae01a2
  switch(output_length % 3) {
    12fc:	ae045401 	cdpge	4, 0, cr5, cr4, cr1, {0}
    1300:	0402b401 	streq	fp, [r2], #-1025	@ 0xfffffbff
    1304:	9f5201a3 	svcls	0x005201a3
    1308:	b802b404 	stmdalt	r2, {r2, sl, ip, sp, pc}
    130c:	04540102 	ldrbeq	r0, [r4], #-258	@ 0xfffffefe
    1310:	02be02b8 	adcseq	r0, lr, #184, 4	@ 0x8000000b
    1314:	5201a304 	andpl	sl, r1, #4, 6	@ 0x10000000
    1318:	02be049f 	adcseq	r0, lr, #-1627389952	@ 0x9f000000
      output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
    131c:	520102dc 	andpl	r0, r1, #220, 4	@ 0xc000000d
    1320:	00000200 	andeq	r0, r0, r0, lsl #4
	...
      output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
    1330:	04000000 	streq	r0, [r0], #-0
    1334:	30025e22 	andcc	r5, r2, r2, lsr #28
    1338:	7262049f 	rsbvc	r0, r2, #-1627389952	@ 0x9f000000
    133c:	049f3002 	ldreq	r3, [pc], #2	@ 1344 <decode_base64+0xa0>
    1340:	01019472 	tsteq	r1, r2, ror r4
      output[1] = base64_to_binary(input[1]) << 4 | base64_to_binary(input[2]) >> 2;
    1344:	01940454 	orrseq	r0, r4, r4, asr r4
    1348:	740301a2 	strvc	r0, [r3], #-418	@ 0xfffffe5e
    134c:	a2049f7f 	andge	r9, r4, #508	@ 0x1fc
    1350:	0201ae01 	andeq	sl, r1, #1, 28
    1354:	ae049f30 	mcrge	15, 0, r9, cr4, cr0, {1}
  return output_length;
    1358:	0101e801 	tsteq	r1, r1, lsl #16
    135c:	01e80454 	mvneq	r0, r4, asr r4
{
    1360:	740301f4 	strvc	r0, [r3], #-500	@ 0xfffffe0c
    1364:	f4049f7f 			@ <UNDEFINED> instruction: 0xf4049f7f
	for (i = 0, j = 0; i < 16; ++i, j += 4)
    1368:	01029201 	tsteq	r2, r1, lsl #4
    136c:	02920454 	addseq	r0, r2, #84, 8	@ 0x54000000
		m[i] = (data[j] << 24) | (data[j + 1] << 16) | (data[j + 2] << 8) | (data[j + 3]);
    1370:	300202dc 	ldrdcc	r0, [r2], -ip
    1374:	0001009f 	muleq	r1, pc, r0	@ <UNPREDICTABLE>
	...
    1380:	026e6204 	rsbeq	r6, lr, #4, 4	@ 0x40000000
    1384:	72049f30 	andvc	r9, r4, #48, 30	@ 0xc0
    1388:	5501019c 	strpl	r0, [r1, #-412]	@ 0xfffffe64
	for (i = 0, j = 0; i < 16; ++i, j += 4)
    138c:	a2019c04 	andge	r9, r1, #4, 24	@ 0x400
    1390:	04510101 	ldrbeq	r0, [r1], #-257	@ 0xfffffeff
		m[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16];
    1394:	01ca01ac 	biceq	r0, sl, ip, lsr #3
    1398:	be045501 	cfsh32lt	mvfx5, mvfx4, #1
    139c:	0202c202 	andeq	ip, r2, #536870912	@ 0x20000000
    13a0:	01009f30 	tsteq	r0, r0, lsr pc
	...
    13ac:	3e300400 	cfabsscc	mvf0, mvf0
    13b0:	049f3002 	ldreq	r3, [pc], #2	@ 13b8 <sha256_transform+0x58>
    13b4:	01f001ca 	mvnseq	r0, sl, asr #3
    13b8:	f0045501 			@ <UNDEFINED> instruction: 0xf0045501
    13bc:	0101f401 	tsteq	r1, r1, lsl #8	@ <UNPREDICTABLE>
    13c0:	01f40451 	mvnseq	r0, r1, asr r4
    13c4:	55010292 	strpl	r0, [r1, #-658]	@ 0xfffffd6e
    13c8:	dc02c204 	sfmle	f4, 1, [r2], {4}
    13cc:	9f300202 	svcls	0x00300202
    13d0:	00000000 	andeq	r0, r0, r0
    13d4:	02920400 	addseq	r0, r2, #0, 8
	for ( ; i < 64; ++i)
    13d8:	540102b4 	strpl	r0, [r1], #-692	@ 0xfffffd4c
    13dc:	be02ba04 	vmlalt.f32	s22, s4, s8
	a = ctx->state[0];
    13e0:	00540102 	subseq	r0, r4, r2, lsl #2
	b = ctx->state[1];
    13e4:	00010100 	andeq	r0, r1, r0, lsl #2
	c = ctx->state[2];
    13e8:	00000000 	andeq	r0, r0, r0
	d = ctx->state[3];
    13ec:	92029204 	andls	r9, r2, #4, 4	@ 0x40000000
	e = ctx->state[4];
    13f0:	04520102 	ldrbeq	r0, [r2], #-258	@ 0xfffffefe
	f = ctx->state[5];
    13f4:	029e0292 	addseq	r0, lr, #536870921	@ 0x20000009
    13f8:	049f3102 	ldreq	r3, [pc], #258	@ 1400 <sha256_transform+0xa0>
	g = ctx->state[6];
    13fc:	02b4029e 	adcseq	r0, r4, #-536870903	@ 0xe0000009
	h = ctx->state[7];
    1400:	ba045201 	blt	115c0c <__ROM_SIZE__+0xd5c0c>
    1404:	0102be02 	tsteq	r2, r2, lsl #28
	d = ctx->state[3];
    1408:	00000052 	andeq	r0, r0, r2, asr r0
	b = ctx->state[1];
    140c:	00000000 	andeq	r0, r0, r0
	for (i = 0; i < 64; ++i) {
    1410:	92040000 	andls	r0, r4, #0
    1414:	01029b02 	tsteq	r2, r2, lsl #22
    1418:	029b0453 	addseq	r0, fp, #1392508928	@ 0x53000000
    141c:	750802a0 	strvc	r0, [r8, #-672]	@ 0xfffffd60
		t1 = h + EP1(e) + CH(e,f,g) + k[i] + m[i];
    1420:	25007400 	strcs	r7, [r0, #-1024]	@ 0xfffffc00
    1424:	049f1a3f 	ldreq	r1, [pc], #2623	@ 142c <sha256_transform+0xcc>
    1428:	02ac02a8 	adceq	r0, ip, #168, 4	@ 0x8000000a
    142c:	3f007305 	svccc	0x00007305
    1430:	ac049f1a 	stcge	15, cr9, [r4], {26}
    1434:	0102b402 	tsteq	r2, r2, lsl #8
    1438:	00000053 	andeq	r0, r0, r3, asr r0
    143c:	00040000 	andeq	r0, r4, r0
    1440:	04500106 	ldrbeq	r0, [r0], #-262	@ 0xfffffefa
    1444:	54011606 	strpl	r1, [r1], #-1542	@ 0xfffff9fa
    1448:	00027e00 	andeq	r7, r2, r0, lsl #28
		t2 = EP0(a) + MAJ(a,b,c);
    144c:	04000500 	streq	r0, [r0], #-1280	@ 0xfffffb00
	...
    1458:	02900400 	addseq	r0, r0, #0, 8
    145c:	5001029a 	mulpl	r1, sl, r2
    1460:	e0029a04 	and	r9, r2, r4, lsl #20
    1464:	01a30402 			@ <UNDEFINED> instruction: 0x01a30402
    1468:	00009f50 	andeq	r9, r0, r0, asr pc
		h = g;
    146c:	04000000 	streq	r0, [r0], #-0
		f = e;
    1470:	029d0290 	addseq	r0, sp, #144, 4
		e = d + t1;
    1474:	9d045101 	stflss	f5, [r4, #-4]
		c = b;
    1478:	0102e002 	tsteq	r2, r2
		a = t1 + t2;
    147c:	00000054 	andeq	r0, r0, r4, asr r0
	for (i = 0; i < 64; ++i) {
    1480:	01000000 	mrseq	r0, (UNDEF: 0)
	ctx->state[0] += a;
    1484:	a202a004 	andge	sl, r2, #4
    1488:	04500102 	ldrbeq	r0, [r0], #-258	@ 0xfffffefe
    148c:	02be02a2 	adcseq	r0, lr, #536870922	@ 0x2000000a
    1490:	c0045501 	andgt	r5, r4, r1, lsl #10
    1494:	0102c602 	tsteq	r2, r2, lsl #12
	ctx->state[1] += b;
    1498:	00000055 	andeq	r0, r0, r5, asr r0
	ctx->state[2] += c;
    149c:	00000000 	andeq	r0, r0, r0
    14a0:	a8040000 	stmdage	r4, {}	@ <UNPREDICTABLE>
	ctx->state[3] += d;
    14a4:	0102b802 	tsteq	r2, r2, lsl #16
	ctx->state[4] += e;
    14a8:	02b80450 	adcseq	r0, r8, #80, 8	@ 0x50000000
    14ac:	510102bb 			@ <UNDEFINED> instruction: 0x510102bb
	ctx->state[5] += f;
    14b0:	c202c004 	andgt	ip, r2, #4
    14b4:	04500102 	ldrbeq	r0, [r0], #-258	@ 0xfffffefe
	ctx->state[6] += g;
    14b8:	02c502c2 	sbceq	r0, r5, #536870924	@ 0x2000000c
    14bc:	00005101 	andeq	r5, r0, r1, lsl #2
	ctx->state[7] += h;
    14c0:	02ae0400 	adceq	r0, lr, #0, 8
    14c4:	530102b0 	movwpl	r0, #4784	@ 0x12b0
}
    14c8:	00000000 	andeq	r0, r0, r0
    14cc:	02b00400 	adcseq	r0, r0, #0, 8
    14d0:	730502b4 	movwvc	r0, #21172	@ 0x52b4
	ctx->datalen = 0;
    14d4:	9f1a3100 	svcls	0x001a3100
	ctx->bitlen = 0;
    14d8:	bb02b404 	bllt	ae4f0 <__ROM_SIZE__+0x6e4f0>
    14dc:	00530102 	subseq	r0, r3, r2, lsl #2
	ctx->state[0] = 0x6a09e667;
    14e0:	00000000 	andeq	r0, r0, r0
	ctx->state[1] = 0xbb67ae85;
    14e4:	b201a804 	andlt	sl, r1, #4, 16	@ 0x40000
	ctx->state[2] = 0x3c6ef372;
    14e8:	04500101 	ldrbeq	r0, [r0], #-257	@ 0xfffffeff
	ctx->state[3] = 0xa54ff53a;
    14ec:	029001b2 	addseq	r0, r0, #-2147483604	@ 0x8000002c
	ctx->state[4] = 0x510e527f;
    14f0:	5001a304 	andpl	sl, r1, r4, lsl #6
	ctx->state[5] = 0x9b05688c;
    14f4:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
	ctx->state[6] = 0x1f83d9ab;
    14f8:	a8040000 	stmdage	r4, {}	@ <UNPREDICTABLE>
	ctx->state[7] = 0x5be0cd19;
    14fc:	0101b501 	tsteq	r1, r1, lsl #10
    1500:	01b50451 			@ <UNDEFINED> instruction: 0x01b50451
    1504:	54010290 	strpl	r0, [r1], #-656	@ 0xfffffd70
    1508:	00000000 	andeq	r0, r0, r0
}
    150c:	04010000 	streq	r0, [r1], #-0
    1510:	01ba01b8 			@ <UNDEFINED> instruction: 0x01ba01b8
    1514:	ba045001 	blt	115520 <__ROM_SIZE__+0xd5520>
    1518:	0101e601 	tsteq	r1, r1, lsl #12
    151c:	01e80456 	mvneq	r0, r6, asr r4
    1520:	560101f6 			@ <UNDEFINED> instruction: 0x560101f6
    1524:	00000000 	andeq	r0, r0, r0
{
    1528:	04010000 	streq	r0, [r1], #-0
    152c:	01c201c0 	biceq	r0, r2, r0, asr #3
	for (i = 0; i < len; ++i) {
    1530:	c2045001 	andgt	r5, r4, #1
    1534:	0101e601 	tsteq	r1, r1, lsl #12
    1538:	01e80455 	mvneq	r0, r5, asr r4
		ctx->data[ctx->datalen] = data[i];
    153c:	550101f6 	strpl	r0, [r1, #-502]	@ 0xfffffe0a
		ctx->datalen++;
    1540:	00000000 	andeq	r0, r0, r0
		if (ctx->datalen == 64) {
    1544:	04000000 	streq	r0, [r0], #-0
			sha256_transform(ctx, ctx->data);
    1548:	01e601c6 	mvneq	r0, r6, asr #3
    154c:	e8045001 	stmda	r4, {r0, ip, lr}
			ctx->bitlen += 512;
    1550:	0101ea01 	tsteq	r1, r1, lsl #20
    1554:	01f00450 	mvnseq	r0, r0, asr r4
    1558:	500101f2 	strdpl	r0, [r1], -r2
    155c:	00000000 	andeq	r0, r0, r0
			ctx->datalen = 0;
    1560:	01d00400 	bicseq	r0, r0, r0, lsl #8
    1564:	520101e2 	andpl	r0, r1, #-2147483592	@ 0x80000038
{
    1568:	e601e204 	str	lr, [r1], -r4, lsl #4
    156c:	00530101 	subseq	r0, r3, r1, lsl #2
	...
		ctx->data[i++] = 0x80;
    1578:	016a6004 	cmneq	sl, r4
			ctx->data[i++] = 0x00;
    157c:	7c6a0450 	cfstrdvc	mvd0, [sl], #-320	@ 0xfffffec0
    1580:	5001a304 	andpl	sl, r1, r4, lsl #6
		while (i < 56)
    1584:	807c049f 			@ <UNDEFINED> instruction: 0x807c049f
	ctx->bitlen += ctx->datalen * 8;
    1588:	04500101 	ldrbeq	r0, [r0], #-257	@ 0xfffffeff
    158c:	01a80180 			@ <UNDEFINED> instruction: 0x01a80180
    1590:	5001a304 	andpl	sl, r1, r4, lsl #6
    1594:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
	...
	ctx->data[62] = ctx->bitlen >> 8;
    15a0:	60040000 	andvs	r0, r4, r0
	ctx->data[61] = ctx->bitlen >> 16;
    15a4:	0451016d 	ldrbeq	r0, [r1], #-365	@ 0xfffffe93
	ctx->data[60] = ctx->bitlen >> 24;
    15a8:	55017a6d 	strpl	r7, [r1, #-2669]	@ 0xfffff593
    15ac:	047c7a04 	ldrbteq	r7, [ip], #-2564	@ 0xfffff5fc
	ctx->data[59] = ctx->bitlen >> 32;
    15b0:	9f5101a3 	svcls	0x005101a3
	ctx->data[58] = ctx->bitlen >> 40;
    15b4:	017e7c04 	cmneq	lr, r4, lsl #24
	ctx->data[57] = ctx->bitlen >> 48;
    15b8:	8a7e0451 	bhi	1f82704 <__ROM_SIZE__+0x1f42704>
    15bc:	04550101 	ldrbeq	r0, [r5], #-257	@ 0xfffffeff
	ctx->data[56] = ctx->bitlen >> 56;
    15c0:	01a8018a 			@ <UNDEFINED> instruction: 0x01a8018a
	sha256_transform(ctx, ctx->data);
    15c4:	5101a304 	tstpl	r1, r4, lsl #6
    15c8:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
	for (i = 0; i < 4; ++i) {
    15cc:	00000000 	andeq	r0, r0, r0
		ctx->data[i++] = 0x80;
    15d0:	01727004 	cmneq	r2, r4
    15d4:	7c720450 	cfldrdvc	mvd0, [r2], #-320	@ 0xfffffec0
			ctx->data[i++] = 0x00;
    15d8:	8a045401 	bhi	1165e4 <__ROM_SIZE__+0xd65e4>
    15dc:	01019e01 	tsteq	r1, r1, lsl #28
		while (i < 64)
    15e0:	00000054 	andeq	r0, r0, r4, asr r0
		sha256_transform(ctx, ctx->data);
    15e4:	78040000 	stmdavc	r4, {}	@ <UNPREDICTABLE>
    15e8:	0450017c 	ldrbeq	r0, [r0], #-380	@ 0xfffffe84
		memset(ctx->data, 0, 56);
    15ec:	019e018a 	orrseq	r0, lr, sl, lsl #3
    15f0:	02005601 	andeq	r5, r0, #1048576	@ 0x100000
    15f4:	04000000 	streq	r0, [r0], #-0
		hash[i]      = (ctx->state[0] >> (24 - i * 8)) & 0x000000ff;
    15f8:	30027c78 	andcc	r7, r2, r8, ror ip
    15fc:	018a049f 			@ <UNDEFINED> instruction: 0x018a049f
    1600:	5501019e 	strpl	r0, [r1, #-414]	@ 0xfffffe62
		hash[i + 4]  = (ctx->state[1] >> (24 - i * 8)) & 0x000000ff;
    1604:	00000200 	andeq	r0, r0, r0, lsl #4
    1608:	7c780400 	cfldrdvc	mvd0, [r8], #-0
		hash[i + 8]  = (ctx->state[2] >> (24 - i * 8)) & 0x000000ff;
    160c:	049f3002 	ldreq	r3, [pc], #2	@ 1614 <sha256_final+0xac>
    1610:	0193018c 	orrseq	r0, r3, ip, lsl #3
		hash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0x000000ff;
    1614:	00005201 	andeq	r5, r0, r1, lsl #4
    1618:	00000000 	andeq	r0, r0, r0
    161c:	04000000 	streq	r0, [r0], #-0
		hash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0x000000ff;
    1620:	50013a30 	andpl	r3, r1, r0, lsr sl
    1624:	044c3a04 	strbeq	r3, [ip], #-2564	@ 0xfffff5fc
		hash[i + 20] = (ctx->state[5] >> (24 - i * 8)) & 0x000000ff;
    1628:	9f5001a3 	svcls	0x005001a3
    162c:	01504c04 	cmpeq	r0, r4, lsl #24
    1630:	60500450 	subsvs	r0, r0, r0, asr r4
		hash[i + 24] = (ctx->state[6] >> (24 - i * 8)) & 0x000000ff;
    1634:	5001a304 	andpl	sl, r1, r4, lsl #6
    1638:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
		hash[i + 28] = (ctx->state[7] >> (24 - i * 8)) & 0x000000ff;
    163c:	00000000 	andeq	r0, r0, r0
    1640:	30040000 	andcc	r0, r4, r0
    1644:	0451013d 	ldrbeq	r0, [r1], #-317	@ 0xfffffec3
	for (i = 0; i < 4; ++i) {
    1648:	54014c3d 	strpl	r4, [r1], #-3133	@ 0xfffff3c3
}
    164c:	014e4c04 	cmpeq	lr, r4, lsl #24
static void outstr(const char *str) {
    1650:	604e0451 	subvs	r0, lr, r1, asr r4
  while (*str != '\0') {
    1654:	00005401 	andeq	r5, r0, r1, lsl #8
    __write_char__(*str);
    1658:	04000000 	streq	r0, [r0], #-0
    str++;
    165c:	50014240 	andpl	r4, r1, r0, asr #4
  while (*str != '\0') {
    1660:	014a4204 	cmpeq	sl, r4, lsl #4
}
    1664:	00000055 	andeq	r0, r0, r5, asr r0
    1668:	014a4604 	cmpeq	sl, r4, lsl #12
static bool printf_numbers(const char fmt, va_list *args, int l_count) {
    166c:	00000050 	andeq	r0, r0, r0, asr r0
    1670:	00000000 	andeq	r0, r0, r0
  switch (fmt) {
    1674:	00040000 	andeq	r0, r4, r0
    1678:	04500108 	ldrbeq	r0, [r0], #-264	@ 0xfffffef8
    167c:	a3041a08 	movwge	r1, #18952	@ 0x4a08
      if (l_count == 0) {
    1680:	049f5001 	ldreq	r5, [pc], #1	@ 1688 <printf_numbers+0x1c>
    1684:	50011e1a 	andpl	r1, r1, sl, lsl lr
        value = va_arg(*args, unsigned int);
    1688:	04301e04 	ldrteq	r1, [r0], #-3588	@ 0xfffff1fc
    168c:	9f5001a3 	svcls	0x005001a3
	...
          __write_char__(hextable[0]);
    1698:	0b000400 	bleq	26a0 <gf2point_on_curve+0x8>
    169c:	0b045101 	bleq	115aa8 <__ROM_SIZE__+0xd5aa8>
  return true;
    16a0:	01a3041a 			@ <UNDEFINED> instruction: 0x01a3041a
  switch (fmt) {
    16a4:	1a049f51 	bne	1293f0 <__ROM_SIZE__+0xe93f0>
      outstr("\nprintf-error\n");
    16a8:	0451011c 	ldrbeq	r0, [r1], #-284	@ 0xfffffee4
      return false;
    16ac:	a304301c 	movwge	r3, #16412	@ 0x401c
}
    16b0:	009f5101 	addseq	r5, pc, r1, lsl #2
      if (l_count == 0) {
    16b4:	00000000 	andeq	r0, r0, r0
        value = va_arg(*args, int);
    16b8:	01120e04 	tsteq	r2, r4, lsl #28
    16bc:	15120450 	ldrne	r0, [r2, #-1104]	@ 0xfffffbb0
      if (value < 0) {
    16c0:	00005101 	andeq	r5, r0, r1, lsl #2
        num[num_len++] = hextable[value % 10];
    16c4:	15100400 	ldrne	r0, [r0, #-1024]	@ 0xfffffc00
    16c8:	12005201 	andne	r5, r0, #268435456	@ 0x10000000
    16cc:	05000006 	streq	r0, [r0, #-6]
    16d0:	00000400 	andeq	r0, r0, r0, lsl #8
    16d4:	00000000 	andeq	r0, r0, r0
    16d8:	04000000 	streq	r0, [r0], #-0
    16dc:	0b980b88 	bleq	fe604504 <_STACK_TOP_+0xde5fc508>
    16e0:	98045001 	stmdals	r4, {r0, ip, lr}
    16e4:	010bfc0b 	tsteq	fp, fp, lsl #24	@ <UNPREDICTABLE>
        value = value / 10;
    16e8:	00000057 	andeq	r0, r0, r7, asr r0
      } while (value > 0);
    16ec:	88040000 	stmdahi	r4, {}	@ <UNPREDICTABLE>
    16f0:	010b980b 	tsteq	fp, fp, lsl #16
        __write_char__('-');
    16f4:	0b980451 	bleq	fe602840 <_STACK_TOP_+0xde5fa844>
    16f8:	55010bfc 	strpl	r0, [r1, #-3068]	@ 0xfffff404
        value = -value;
    16fc:	00000000 	andeq	r0, r0, r0
        __write_char__(num[--num_len]);
    1700:	0b880400 	bleq	fe202708 <_STACK_TOP_+0xde1fa70c>
    1704:	52010b98 	andpl	r0, r1, #152, 22	@ 0x26000
    1708:	fc0b9804 	stc2	8, cr9, [fp], {4}
    170c:	0056010b 	subseq	r0, r6, fp, lsl #2
    1710:	00000004 	andeq	r0, r0, r4
      while (num_len > 0) {
    1714:	980b9204 	stmdals	fp, {r2, r9, ip, pc}
  return true;
    1718:	9f30020b 	svcls	0x0030020b
          num[num_len++] = hextable[value % 10];
    171c:	fc0b9804 	stc2	8, cr9, [fp], {4}
    1720:	0054010b 	subseq	r0, r4, fp, lsl #2
    1724:	00000004 	andeq	r0, r0, r4
    1728:	00000001 	andeq	r0, r0, r1
    172c:	92040000 	andls	r0, r4, #0
    1730:	020b980b 	andeq	r9, fp, #720896	@ 0xb0000
    1734:	98049f40 	stmdals	r4, {r6, r8, r9, sl, fp, ip, pc}
    1738:	010bd30b 	tsteq	fp, fp, lsl #6
          value = value / 10;
    173c:	0bdc0453 	bleq	ff702890 <_STACK_TOP_+0xdf6fa894>
        } while (value > 0);
    1740:	3f020bde 	svccc	0x00020bde
        while (num_len > 0) {
    1744:	0bde049f 	bleq	ff7829c8 <_STACK_TOP_+0xdf77a9cc>
          __write_char__(num[--num_len]);
    1748:	53010bee 	movwpl	r0, #7150	@ 0x1bee
    174c:	fc0bf804 	stc2	8, cr15, [fp], {4}
    1750:	0053010b 	subseq	r0, r3, fp, lsl #2
    1754:	00000000 	andeq	r0, r0, r0
    1758:	d20ac204 	andle	ip, sl, #4, 4	@ 0x40000000
    175c:	0450010a 	ldrbeq	r0, [r0], #-266	@ 0xfffffef6
  return true;
    1760:	0b880ad2 	bleq	fe2042b0 <_STACK_TOP_+0xde1fc2b4>
              __write_char__(hextable[val]);
    1764:	00005701 	andeq	r5, r0, r1, lsl #14
    1768:	04000000 	streq	r0, [r0], #-0
              leading_zero_ignored = true;
    176c:	0ad20ac2 	beq	ff48427c <_STACK_TOP_+0xdf47c280>
          while (start_bit >= 0) {
    1770:	d2045101 	andle	r5, r4, #1073741824	@ 0x40000000
            int val = (value >> start_bit) & 0xF;
    1774:	010b880a 	tsteq	fp, sl, lsl #16
            if (val || leading_zero_ignored) {
    1778:	00000054 	andeq	r0, r0, r4, asr r0
    177c:	c2040000 	andgt	r0, r4, #0
    1780:	010ad20a 	tsteq	sl, sl, lsl #4
          bool leading_zero_ignored = false;
    1784:	0ad20452 	beq	ff4828d4 <_STACK_TOP_+0xdf47a8d8>
          int start_bit = LAST_NIBBLE_FIRST_BIT;
    1788:	58010b88 	stmdapl	r1, {r3, r7, r8, r9, fp}
  return true;
    178c:	00000300 	andeq	r0, r0, r0, lsl #6
        return false;
    1790:	0ace0400 	beq	ff382798 <_STACK_TOP_+0xdf37a79c>
        return false;
    1794:	30020ad2 	ldrdcc	r0, [r2], -r2
    1798:	0ad2049f 	beq	ff482a1c <_STACK_TOP_+0xdf47aa20>
    179c:	55010b88 	strpl	r0, [r1, #-2952]	@ 0xfffff478
    17a0:	00000000 	andeq	r0, r0, r0
    17a4:	0a8a0400 	beq	fe2827ac <_STACK_TOP_+0xde27a7b0>
    17a8:	50010a9e 	mulpl	r1, lr, sl
int printf(const char *fmt, ...) {
    17ac:	c20a9e04 	andgt	r9, sl, #4, 28	@ 0x40
    17b0:	0056010a 	subseq	r0, r6, sl, lsl #2
    17b4:	02000000 	andeq	r0, r0, #0
  va_start(args, fmt);
    17b8:	00000002 	andeq	r0, r0, r2
  while (*fmt) {
    17bc:	9a0a8a04 	bls	2a3fd4 <__ROM_SIZE__+0x263fd4>
        if (*fmt == '%') {
    17c0:	0451010a 	ldrbeq	r0, [r1], #-266	@ 0xfffffef6
        __write_char__(*fmt);
    17c4:	0aac0a9a 	beq	feb04234 <_STACK_TOP_+0xdeafc238>
        fmt++;
    17c8:	ac045401 	cfstrsge	mvf5, [r4], {1}
  while (*fmt) {
    17cc:	030ab20a 	movweq	fp, #41482	@ 0xa20a
    switch (state) {
    17d0:	049f1074 	ldreq	r1, [pc], #116	@ 17d8 <printf+0x2c>
    17d4:	0ac20ab2 	beq	ff0842a4 <_STACK_TOP_+0xdf07c2a8>
          fmt++;
    17d8:	00005401 	andeq	r5, r0, r1, lsl #8
          continue;
    17dc:	04000000 	streq	r0, [r0], #-0
        while (*fmt && ((*fmt >= '0' && *fmt <= '9') || *fmt == '-')) {
    17e0:	0a9e0a8a 	beq	fe784210 <_STACK_TOP_+0xde77c214>
    17e4:	9e045201 	cdpls	2, 0, cr5, cr4, cr1, {0}
    17e8:	010ac20a 	tsteq	sl, sl, lsl #4
    17ec:	00010057 	andeq	r0, r1, r7, asr r0
    17f0:	98040000 	stmdals	r4, {}	@ <UNPREDICTABLE>
        switch (*fmt) {
    17f4:	020a9e0a 	andeq	r9, sl, #10, 28	@ 0xa0
    17f8:	9e049f30 	mcrls	15, 0, r9, cr4, cr0, {1}
    17fc:	010ac20a 	tsteq	sl, sl, lsl #4
    1800:	00000055 	andeq	r0, r0, r5, asr r0
            __write_char__(*fmt);
    1804:	00010000 	andeq	r0, r1, r0
    1808:	98040000 	stmdals	r4, {}	@ <UNPREDICTABLE>
            state = CHECK_CH;
    180c:	010a9e0a 	tsteq	sl, sl, lsl #28
            break;
    1810:	0a9e0458 	beq	fe782978 <_STACK_TOP_+0xde77a97c>
    1814:	51010aa3 	smlatbpl	r1, r3, sl, r0
            outstr(va_arg(args, const char *));
    1818:	b20aac04 	andlt	sl, sl, #4, 24	@ 0x400
    181c:	0454010a 	ldrbeq	r0, [r4], #-266	@ 0xfffffef6
    1820:	0abd0ab2 	beq	fef442f0 <_STACK_TOP_+0xdef3c2f4>
            fmt++;
    1824:	03005101 	movweq	r5, #257	@ 0x101
            break;
    1828:	00000000 	andeq	r0, r0, r0
            __write_char__(va_arg(args, int));
    182c:	09a80400 	stmibeq	r8!, {sl}
    1830:	300209ac 	andcc	r0, r2, ip, lsr #19
    1834:	09ac049f 	stmibeq	ip!, {r0, r1, r2, r3, r4, r7, sl}
            fmt++;
    1838:	530109ba 	movwpl	r0, #6586	@ 0x19ba
            break;
    183c:	c209bc04 	andgt	fp, r9, #4, 24	@ 0x400
            if (*fmt == 'l') {
    1840:	00530109 	subseq	r0, r3, r9, lsl #2
    1844:	00000000 	andeq	r0, r0, r0
            if (printf_numbers(*fmt, &args, l_count)) {
    1848:	fc040000 	stc2	0, cr0, [r4], {-0}
    184c:	010a8409 	tsteq	sl, r9, lsl #8
    1850:	0a840450 	beq	fe102998 <_STACK_TOP_+0xde0fa99c>
              state = CHECK_CH;
    1854:	51010a87 	smlabbpl	r1, r7, sl, r0
              fmt++;
    1858:	8a0a8704 	bhi	2a3470 <__ROM_SIZE__+0x263470>
              l_count++;
    185c:	01a3040a 			@ <UNDEFINED> instruction: 0x01a3040a
            if (printf_numbers(*fmt, &args, 0)) {
    1860:	00009f50 	andeq	r9, r0, r0, asr pc
    1864:	00000000 	andeq	r0, r0, r0
              fmt++;
    1868:	09fc0400 	ldmibeq	ip!, {sl}^
              break;
    186c:	51010a82 	smlabbpl	r1, r2, sl, r0
            return -1;
    1870:	870a8204 	strhi	r8, [sl, -r4, lsl #4]
}
    1874:	0453010a 	ldrbeq	r0, [r3], #-266	@ 0xfffffef6
    1878:	0a8a0a87 	beq	fe28429c <_STACK_TOP_+0xde27c2a0>
            return -1;
    187c:	5101a304 	tstpl	r1, r4, lsl #6
    1880:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
    1884:	00000000 	andeq	r0, r0, r0
static void outstr2(const char *str) {
    1888:	f609ee04 			@ <UNDEFINED> instruction: 0xf609ee04
  while (*str != '\0') {
    188c:	04500109 	ldrbeq	r0, [r0], #-265	@ 0xfffffef7
    __write_char2__(*str);
    1890:	09f909f6 	ldmibeq	r9!, {r1, r2, r4, r5, r6, r7, r8, fp}^
    str++;
    1894:	f9045101 			@ <UNDEFINED> instruction: 0xf9045101
  while (*str != '\0') {
    1898:	0409fc09 	streq	pc, [r9], #-3081	@ 0xfffff3f7
}
    189c:	9f5001a3 	svcls	0x005001a3
    18a0:	00000000 	andeq	r0, r0, r0
static bool printf2_numbers(const char fmt, va_list *args, int l_count) {
    18a4:	04000000 	streq	r0, [r0], #-0
    18a8:	09f409ee 	ldmibeq	r4!, {r1, r2, r3, r5, r6, r7, r8, fp}^
  switch (fmt) {
    18ac:	f4045101 	vst4.8	{d5,d7,d9,d11}, [r4], r1
    18b0:	0109f909 	tsteq	r9, r9, lsl #18	@ <UNPREDICTABLE>
    18b4:	09f90453 	ldmibeq	r9!, {r0, r1, r4, r6, sl}^
      if (l_count == 0) {
    18b8:	a30409fc 	movwge	r0, #18940	@ 0x49fc
    18bc:	009f5101 	addseq	r5, pc, r1, lsl #2
        value = va_arg(*args, unsigned int);
    18c0:	00000000 	andeq	r0, r0, r0
    18c4:	ee040000 	cdp	0, 0, cr0, cr4, cr0, {0}
      if (fmt == 'u') {
    18c8:	0108fa08 	tsteq	r8, r8, lsl #20	@ <UNPREDICTABLE>
        if (value == 0) {
    18cc:	08fa0450 	ldmeq	sl!, {r4, r6, sl}^
          __write_char2__(hextable2[0]);
    18d0:	510108fd 	strdpl	r0, [r1, -sp]
    18d4:	a808fd04 	stmdage	r8, {r2, r8, sl, fp, ip, sp, lr, pc}
  return true;
    18d8:	00550109 	subseq	r0, r5, r9, lsl #2
  switch (fmt) {
    18dc:	00000000 	andeq	r0, r0, r0
      outstr2("\nprintf2-error\n");
    18e0:	ee040000 	cdp	0, 0, cr0, cr4, cr0, {0}
      return false;
    18e4:	0108f808 	tsteq	r8, r8, lsl #16	@ <UNPREDICTABLE>
}
    18e8:	08f80451 	ldmeq	r8!, {r0, r4, r6, sl}^
      if (l_count == 0) {
    18ec:	520108fd 	andpl	r0, r1, #16580608	@ 0xfd0000
        value = va_arg(*args, int);
    18f0:	a808fd04 	stmdage	r8, {r2, r8, sl, fp, ip, sp, lr, pc}
    18f4:	00560109 	subseq	r0, r6, r9, lsl #2
      if (value < 0) {
    18f8:	00010101 	andeq	r0, r1, r1, lsl #2
        num[num_len++] = hextable2[value % 10];
    18fc:	00000000 	andeq	r0, r0, r0
    1900:	fe08f404 	cdp2	4, 0, cr15, cr8, cr4, {0}
    1904:	9f300208 	svcls	0x00300208
    1908:	8208fe04 	andhi	pc, r8, #4, 28	@ 0x40
    190c:	9f3d0209 	svcls	0x003d0209
    1910:	8a098204 	bhi	262128 <__ROM_SIZE__+0x222128>
    1914:	04540109 	ldrbeq	r0, [r4], #-265	@ 0xfffffef7
    1918:	09a8098c 	stmibeq	r8!, {r2, r3, r7, r8, fp}
    191c:	00005401 	andeq	r5, r0, r1, lsl #8
        value = value / 10;
    1920:	00000000 	andeq	r0, r0, r0
      } while (value > 0);
    1924:	08aa0400 	stmiaeq	sl!, {sl}
    1928:	500108b6 			@ <UNDEFINED> instruction: 0x500108b6
        __write_char2__('-');
    192c:	b908b604 	stmdblt	r8, {r2, r9, sl, ip, sp, pc}
    1930:	04510108 	ldrbeq	r0, [r1], #-264	@ 0xfffffef8
        value = -value;
    1934:	08ee08b9 	stmiaeq	lr!, {r0, r3, r4, r5, r7, fp}^
        __write_char2__(num[--num_len]);
    1938:	00005501 	andeq	r5, r0, r1, lsl #10
    193c:	00000000 	andeq	r0, r0, r0
    1940:	08aa0400 	stmiaeq	sl!, {sl}
    1944:	510108b4 			@ <UNDEFINED> instruction: 0x510108b4
    1948:	b908b404 	stmdblt	r8, {r2, sl, ip, sp, pc}
      while (num_len > 0) {
    194c:	04520108 	ldrbeq	r0, [r2], #-264	@ 0xfffffef8
  return true;
    1950:	08ee08b9 	stmiaeq	lr!, {r0, r3, r4, r5, r7, fp}^
          num[num_len++] = hextable2[value % 10];
    1954:	01005601 	tsteq	r0, r1, lsl #12
    1958:	00000101 	andeq	r0, r0, r1, lsl #2
    195c:	04000000 	streq	r0, [r0], #-0
    1960:	08ba08b0 	ldmeq	sl!, {r4, r5, r7, fp}
    1964:	049f3002 	ldreq	r3, [pc], #2	@ 196c <printf2_numbers+0xc8>
    1968:	08be08ba 	ldmeq	lr!, {r1, r3, r4, r5, r7, fp}
    196c:	049f3102 	ldreq	r3, [pc], #258	@ 1974 <printf2_numbers+0xd0>
    1970:	08d008be 	ldmeq	r0, {r1, r2, r3, r4, r5, r7, fp}^
          value = value / 10;
    1974:	d2045401 	andle	r5, r4, #16777216	@ 0x1000000
        } while (value > 0);
    1978:	0108ee08 	tsteq	r8, r8, lsl #28
        while (num_len > 0) {
    197c:	00000054 	andeq	r0, r0, r4, asr r0
          __write_char2__(num[--num_len]);
    1980:	aa07fa04 	bge	200198 <__ROM_SIZE__+0x1c0198>
    1984:	00530108 	subseq	r0, r3, r8, lsl #2
    1988:	00000003 	andeq	r0, r0, r3
    198c:	00000000 	andeq	r0, r0, r0
    1990:	b207b004 	andlt	fp, r7, #4
    1994:	9f300207 	svcls	0x00300207
  return true;
    1998:	dc07b204 	sfmle	f3, 1, [r7], {4}
              __write_char2__(hextable2[val]);
    199c:	04510107 	ldrbeq	r0, [r1], #-263	@ 0xfffffef9
    19a0:	07ec07de 	ubfxeq	r0, lr, #15, #13
              leading_zero_ignored = true;
    19a4:	ee045101 	adfs	f5, f4, f1
          while (start_bit >= 0) {
    19a8:	0107f807 	tsteq	r7, r7, lsl #16	@ <UNPREDICTABLE>
            int val = (value >> start_bit) & 0xF;
    19ac:	00000051 	andeq	r0, r0, r1, asr r0
            if (val || leading_zero_ignored) {
    19b0:	00000000 	andeq	r0, r0, r0
    19b4:	d407b804 	strle	fp, [r7], #-2052	@ 0xfffff7fc
    19b8:	04530107 	ldrbeq	r0, [r3], #-263	@ 0xfffffef9
          bool leading_zero_ignored = false;
    19bc:	07e407d6 	ubfxeq	r0, r6, #15, #5
          int start_bit = LAST_NIBBLE_FIRST_BIT;
    19c0:	e6045301 	str	r5, [r4], -r1, lsl #6
  return true;
    19c4:	0107f007 	tsteq	r7, r7	@ <UNPREDICTABLE>
        return false;
    19c8:	00000053 	andeq	r0, r0, r3, asr r0
        return false;
    19cc:	00000000 	andeq	r0, r0, r0
    19d0:	e204d604 	and	sp, r4, #4, 12	@ 0x400000
    19d4:	04500104 	ldrbeq	r0, [r0], #-260	@ 0xfffffefc
    19d8:	07ac04e2 	streq	r0, [ip, r2, ror #9]!
    19dc:	04007d02 	streq	r7, [r0], #-3330	@ 0xfffff2fe
    19e0:	07b007ac 	ldreq	r0, [r0, ip, lsr #15]!
int printf2(const char *fmt, ...) {
    19e4:	7fb09103 	svcvc	0x00b09103
    19e8:	00000300 	andeq	r0, r0, r0, lsl #6
    19ec:	04de0400 	ldrbeq	r0, [lr], #1024	@ 0x400
  va_start(args, fmt);
    19f0:	300204e2 	andcc	r0, r2, r2, ror #9
  while (*fmt) {
    19f4:	04e2049f 	strbteq	r0, [r2], #1183	@ 0x49f
        if (*fmt == '%') {
    19f8:	540107b0 	strpl	r0, [r1], #-1968	@ 0xfffff850
        __write_char2__(*fmt);
    19fc:	04000000 	streq	r0, [r0], #-0
        fmt++;
    1a00:	07a404e8 	streq	r0, [r4, r8, ror #9]!
  while (*fmt) {
    1a04:	00005b01 	andeq	r5, r0, r1, lsl #22
    switch (state) {
    1a08:	04f00400 	ldrbteq	r0, [r0], #1024	@ 0x400
    1a0c:	5a0107a4 	bpl	438a4 <__ROM_SIZE__+0x38a4>
          fmt++;
    1a10:	04000000 	streq	r0, [r0], #-0
          continue;
    1a14:	07a404f4 			@ <UNDEFINED> instruction: 0x07a404f4
        while (*fmt && ((*fmt >= '0' && *fmt <= '9') || *fmt == '-')) {
    1a18:	00005901 	andeq	r5, r0, r1, lsl #18
    1a1c:	04f80400 	ldrbteq	r0, [r8], #1024	@ 0x400
    1a20:	550106e4 	strpl	r0, [r1, #-1764]	@ 0xfffff91c
    1a24:	00000000 	andeq	r0, r0, r0
    1a28:	03e00400 	mvneq	r0, #0, 8
        switch (*fmt) {
    1a2c:	500103ea 	andpl	r0, r1, sl, ror #7
    1a30:	d603ea04 	strle	lr, [r3], -r4, lsl #20
    1a34:	00590104 	subseq	r0, r9, r4, lsl #2
    1a38:	00000003 	andeq	r0, r0, r3
            __write_char2__(*fmt);
    1a3c:	e6040000 	str	r0, [r4], -r0
    1a40:	0203ea03 	andeq	lr, r3, #12288	@ 0x3000
            state = CHECK_CH;
    1a44:	ea049f30 	b	12970c <__ROM_SIZE__+0xe970c>
            break;
    1a48:	0104cc03 	tsteq	r4, r3, lsl #24
    1a4c:	04ce0455 	strbeq	r0, [lr], #1109	@ 0x455
            outstr2(va_arg(args, const char *));
    1a50:	550104d6 	strpl	r0, [r1, #-1238]	@ 0xfffffb2a
    1a54:	04000000 	streq	r0, [r0], #-0
    1a58:	04c80486 	strbeq	r0, [r8], #1158	@ 0x486
            fmt++;
    1a5c:	01005401 	tsteq	r0, r1, lsl #8
            break;
    1a60:	00000000 	andeq	r0, r0, r0
            __write_char2__(va_arg(args, int));
    1a64:	00000100 	andeq	r0, r0, r0, lsl #2
    1a68:	00000000 	andeq	r0, r0, r0
    1a6c:	00000100 	andeq	r0, r0, r0, lsl #2
            fmt++;
    1a70:	00000000 	andeq	r0, r0, r0
            break;
    1a74:	00000100 	andeq	r0, r0, r0, lsl #2
            if (*fmt == 'l') {
    1a78:	00000000 	andeq	r0, r0, r0
    1a7c:	04860400 	streq	r0, [r6], #1024	@ 0x400
            if (printf2_numbers(*fmt, &args, l_count)) {
    1a80:	50010489 	andpl	r0, r1, r9, lsl #9
    1a84:	8a048904 	bhi	123e9c <__ROM_SIZE__+0xe3e9c>
    1a88:	007b0604 	rsbseq	r0, fp, r4, lsl #12
              state = CHECK_CH;
    1a8c:	9f27007a 	svcls	0x0027007a
              fmt++;
    1a90:	8c048a04 			@ <UNDEFINED> instruction: 0x8c048a04
              l_count++;
    1a94:	04500104 	ldrbeq	r0, [r0], #-260	@ 0xfffffefc
            if (printf2_numbers(*fmt, &args, 0)) {
    1a98:	04980494 	ldreq	r0, [r8], #1172	@ 0x494
    1a9c:	78007b06 	stmdavc	r0, {r1, r2, r8, r9, fp, ip, sp, lr}
              fmt++;
    1aa0:	049f2700 	ldreq	r2, [pc], #1792	@ 1aa8 <printf2+0xc4>
              break;
    1aa4:	049b0498 	ldreq	r0, [fp], #1176	@ 0x498
            return -1;
    1aa8:	9b045001 	blls	115ab4 <__ROM_SIZE__+0xd5ab4>
}
    1aac:	06049c04 	streq	r9, [r4], -r4, lsl #24
    1ab0:	0078007b 	rsbseq	r0, r8, fp, ror r0
            return -1;
    1ab4:	9c049f27 	stcls	15, cr9, [r4], {39}	@ 0x27
    1ab8:	01049e04 	tsteq	r4, r4, lsl #28
    1abc:	04a60450 	strteq	r0, [r6], #1104	@ 0x450
int r32(int argc, char *argv[]) {
    1ac0:	780604aa 	stmdavc	r6, {r1, r3, r5, r7, sl}
  if (argc < 2) {
    1ac4:	27007700 	strcs	r7, [r0, -r0, lsl #14]
  uint32_t addr = atoh(argv[1]);
    1ac8:	04aa049f 	strteq	r0, [sl], #1183	@ 0x49f
    1acc:	500104ad 	andpl	r0, r1, sp, lsr #9
  printf("0x%x: 0x%x\n", addr, data);
    1ad0:	ae04ad04 	cdpge	13, 0, cr10, cr4, cr4, {0}
    1ad4:	00780604 	rsbseq	r0, r8, r4, lsl #12
}
    1ad8:	9f270077 	svcls	0x00270077
    printf("Usage: %s <address> (in hex)\n", argv[0]);
    1adc:	b004ae04 	andlt	sl, r4, r4, lsl #28
    1ae0:	04500104 	ldrbeq	r0, [r0], #-260	@ 0xfffffefc
    return -1;
    1ae4:	04bc04b8 	ldrteq	r0, [ip], #1208	@ 0x4b8
    1ae8:	7a007706 	bvc	1f708 <__RAM_SIZE__+0x17708>
    1aec:	049f2700 	ldreq	r2, [pc], #1792	@ 1af4 <w32+0x4>
int w32(int argc, char *argv[]) {
    1af0:	04bf04bc 	ldrteq	r0, [pc], #1212	@ 1af8 <w32+0x8>
  if (argc < 3) {
    1af4:	bf045001 	svclt	0x00045001
  uint32_t addr = atoh(argv[1]);
    1af8:	0604c004 	streq	ip, [r4], -r4
    1afc:	007a0077 	rsbseq	r0, sl, r7, ror r0
  uint32_t data = atoh(argv[2]);
    1b00:	c0049f27 	andgt	r9, r4, r7, lsr #30
    1b04:	0104ce04 	tsteq	r4, r4, lsl #28
  return 0;
    1b08:	00000050 	andeq	r0, r0, r0, asr r0
    printf("Usage: %s <address> (in hex) <value> (in hex)\n", argv[0]);
    1b0c:	ce03ee04 	cdpgt	14, 0, cr14, cr3, cr4, {0}
    1b10:	005a0104 	subseq	r0, sl, r4, lsl #2
    return -1;
    1b14:	00000000 	andeq	r0, r0, r0
    1b18:	dc03ce04 	stcle	14, cr12, [r3], {4}
    1b1c:	04500103 	ldrbeq	r0, [r0], #-259	@ 0xfffffefd
int read_mem(int argc, char *argv[]) {
    1b20:	03e003dc 	mvneq	r0, #220, 6	@ 0x70000003
  if (argc < 3) {
    1b24:	5001a304 	andpl	sl, r1, r4, lsl #6
  uint32_t addr = atoh(argv[1]);
    1b28:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
    1b2c:	ce039e04 	cdpgt	14, 0, cr9, cr3, cr4, {0}
  uint32_t length = atoi(argv[2]);
    1b30:	00530103 	subseq	r0, r3, r3, lsl #2
    1b34:	00000003 	andeq	r0, r0, r3
  for (uint32_t i = 0, data = 0; i < length; i++) {
    1b38:	00000000 	andeq	r0, r0, r0
    printf("Usage: %s <address> (in hex) <num_words> (in decimal)\n", argv[0]);
    1b3c:	da02d804 	ble	b7b54 <__ROM_SIZE__+0x77b54>
    1b40:	9f300202 	svcls	0x00300202
    return -1;
    1b44:	8202da04 	andhi	sp, r2, #4, 20	@ 0x4000
    1b48:	04520103 	ldrbeq	r0, [r2], #-259	@ 0xfffffefd
    printf("0x%x: 0x%x\n", addr, data);
    1b4c:	03920384 	orrseq	r0, r2, #132, 6	@ 0x10000002
    1b50:	94045201 	strls	r5, [r4], #-513	@ 0xfffffdff
    addr += 4;
    1b54:	01039c03 	tsteq	r3, r3, lsl #24
  for (uint32_t i = 0, data = 0; i < length; i++) {
    1b58:	00000052 	andeq	r0, r0, r2, asr r0
  return 0;
    1b5c:	00000000 	andeq	r0, r0, r0
}
    1b60:	fa02e004 	blx	b9b78 <__ROM_SIZE__+0x79b78>
    1b64:	04530102 	ldrbeq	r0, [r3], #-258	@ 0xfffffefe
{
    1b68:	038a02fc 	orreq	r0, sl, #252, 4	@ 0xc000000f
  if (argc < 4) {
    1b6c:	8c045301 	stchi	3, cr5, [r4], {1}
  uint32_t addr = atoh(argv[1]);
    1b70:	01039603 	tsteq	r3, r3, lsl #12
    1b74:	00020053 	andeq	r0, r2, r3, asr r0
  uint32_t bit_loc = atoi(argv[2]);
    1b78:	00000000 	andeq	r0, r0, r0
    1b7c:	a602a204 	strge	sl, [r2], -r4, lsl #4
  uint32_t bit_val = atoi(argv[3]);
    1b80:	9f300202 	svcls	0x00300202
    1b84:	cc02a604 	stcgt	6, cr10, [r2], {4}
  if (bit_loc > 31) {
    1b88:	04540102 	ldrbeq	r0, [r4], #-258	@ 0xfffffefe
  if (bit_val != 0 && bit_val != 1) {
    1b8c:	02d802ce 	sbcseq	r0, r8, #-536870900	@ 0xe000000c
  data = data | (bit_val << bit_loc);
    1b90:	00005401 	andeq	r5, r0, r1, lsl #8
    1b94:	04000000 	streq	r0, [r0], #-0
  data = data & ~(!bit_val << bit_loc);
    1b98:	02c402a6 	sbceq	r0, r4, #1610612746	@ 0x6000000a
    1b9c:	c6045301 	strgt	r5, [r4], -r1, lsl #6
    1ba0:	0102ce02 	tsteq	r2, r2, lsl #28
  return 0;
    1ba4:	00000053 	andeq	r0, r0, r3, asr r0
    printf("Error: Invalid bit location argument\n");
    1ba8:	00000000 	andeq	r0, r0, r0
    1bac:	e809e204 	stmda	r9, {r2, r9, sp, lr, pc}
    printf("Error: Invalid bit value argument\n");
    1bb0:	04500109 	ldrbeq	r0, [r0], #-265	@ 0xfffffef7
    1bb4:	09eb09e8 	stmibeq	fp!, {r3, r5, r6, r7, r8, fp}^
  printf("Usage: %s <address_in_hex(32-bits)> <bit_location_in_decimal(0 to 31)> <bit_value(0 or 1)>\n", argv[0]);
    1bb8:	7e907004 	cdpvc	0, 9, cr7, cr0, cr4, {0}
    1bbc:	09eb049f 	stmibeq	fp!, {r0, r1, r2, r3, r4, r7, sl}^
  return -1;
    1bc0:	a30409ee 	movwge	r0, #18926	@ 0x49ee
    1bc4:	009f5001 	addseq	r5, pc, r1
    1bc8:	00000000 	andeq	r0, r0, r0
    1bcc:	eb09e204 	bl	27a3e4 <__ROM_SIZE__+0x23a3e4>
{
    1bd0:	04510109 	ldrbeq	r0, [r1], #-265	@ 0xfffffef7
  if (argc < 3) {
    1bd4:	09ee09eb 	stmibeq	lr!, {r0, r1, r3, r5, r6, r7, r8, fp}^
  uint32_t addr = atoh(argv[1]);
    1bd8:	5101a304 	tstpl	r1, r4, lsl #6
    1bdc:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
  uint32_t bit_loc = atoi(argv[2]);
    1be0:	ca040000 	bgt	101be8 <__ROM_SIZE__+0xc1be8>
    1be4:	0109d309 	tsteq	r9, r9, lsl #6
  if (bit_loc > 31) {
    1be8:	09d30450 	ldmibeq	r3, {r4, r6, sl}^
  uint32_t data = reg32(addr);
    1bec:	540109e2 	strpl	r0, [r1], #-2530	@ 0xfffff61e
  printf("Bit %u @ 0x%08x: %u\n", bit_loc, addr, bit_val);
    1bf0:	00000000 	andeq	r0, r0, r0
    1bf4:	09ca0400 	stmibeq	sl, {sl}^
    1bf8:	510109d3 	ldrdpl	r0, [r1, -r3]
  return 0;
    1bfc:	e209d304 	and	sp, r9, #4, 6	@ 0x10000000
    printf("Error: Invalid bit location argument\n");
    1c00:	01a30409 			@ <UNDEFINED> instruction: 0x01a30409
    1c04:	00009f51 	andeq	r9, r0, r1, asr pc
  printf("Usage: %s <address_in_hex(32-bits)> <bit_location_in_decimal(0 to 31)\n", argv[0]);
    1c08:	04000000 	streq	r0, [r0], #-0
    1c0c:	09d309ca 	ldmibeq	r3, {r1, r3, r6, r7, r8, fp}^
  return -1;
    1c10:	d3045201 	movwle	r5, #16897	@ 0x4201
    1c14:	0109e209 	tsteq	r9, r9, lsl #4
    1c18:	00000055 	andeq	r0, r0, r5, asr r0
    1c1c:	c2040000 	andgt	r0, r4, #0
{
    1c20:	0109c709 	tsteq	r9, r9, lsl #14
  for (i = 0; i < Nk; ++i)
    1c24:	09c70450 	stmibeq	r7, {r4, r6, sl}^
    RoundKey[(i * 4) + 0] = Key[(i * 4) + 0];
    1c28:	a30409ca 	movwge	r0, #18890	@ 0x49ca
    1c2c:	009f5001 	addseq	r5, pc, r1
    1c30:	00000000 	andeq	r0, r0, r0
    RoundKey[(i * 4) + 1] = Key[(i * 4) + 1];
    1c34:	c709c204 	strgt	ip, [r9, -r4, lsl #4]
    RoundKey[(i * 4) + 2] = Key[(i * 4) + 2];
    1c38:	04510109 	ldrbeq	r0, [r1], #-265	@ 0xfffffef7
    1c3c:	09ca09c7 	stmibeq	sl, {r0, r1, r2, r6, r7, r8, fp}^
    RoundKey[(i * 4) + 3] = Key[(i * 4) + 3];
    1c40:	5101a304 	tstpl	r1, r4, lsl #6
  for (i = 0; i < Nk; ++i)
    1c44:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
    1c48:	00040000 	andeq	r0, r4, r0
  for (i = Nk; i < Nb * (Nr + 1); ++i)
    1c4c:	0451012e 	ldrbeq	r0, [r1], #-302	@ 0xfffffed2
    if (i % Nk == 4)
    1c50:	0402a02e 	streq	sl, [r2], #-46	@ 0xffffffd2
    j = i * 4; k=(i - Nk) * 4;
    1c54:	9f5101a3 	svcls	0x005101a3
    RoundKey[j + 0] = RoundKey[k + 0] ^ tempa[0];
    1c58:	00000300 	andeq	r0, r0, r0, lsl #6
    1c5c:	04000000 	streq	r0, [r0], #-0
    1c60:	30020804 	andcc	r0, r2, r4, lsl #16
    1c64:	2e08049f 	mcrcs	4, 0, r0, cr8, cr15, {4}
    RoundKey[j + 1] = RoundKey[k + 1] ^ tempa[1];
    1c68:	2e045201 	cdpcs	2, 0, cr5, cr4, cr1, {0}
    1c6c:	530102a0 	movwpl	r0, #4768	@ 0x12a0
    1c70:	00000000 	andeq	r0, r0, r0
    1c74:	78340400 	ldmdavc	r4!, {sl}
    1c78:	78045101 	stmdavc	r4, {r0, r8, ip, lr}
    1c7c:	7d71037e 	ldclvc	3, cr0, [r1, #-504]!	@ 0xfffffe08
    RoundKey[j + 2] = RoundKey[k + 2] ^ tempa[2];
    1c80:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
	...
    1c8c:	05382e04 	ldreq	r2, [r8, #-3588]!	@ 0xfffff1fc
    RoundKey[j + 3] = RoundKey[k + 3] ^ tempa[3];
    1c90:	24327f73 	ldrtcs	r7, [r2], #-3955	@ 0xfffff08d
    1c94:	4c38049f 	cfldrsmi	mvf0, [r8], #-636	@ 0xfffffd84
    1c98:	32007205 	andcc	r7, r0, #1342177280	@ 0x50000000
  for (i = Nk; i < Nb * (Nr + 1); ++i)
    1c9c:	4c049f24 	stcmi	15, cr9, [r4], {36}	@ 0x24
    1ca0:	7873057e 	ldmdavc	r3!, {r1, r2, r3, r4, r5, r6, r8, sl}^
      tempa[0]=RoundKey[k + 0];
    1ca4:	049f2432 	ldreq	r2, [pc], #1074	@ 1cac <KeyExpansion+0x8c>
    1ca8:	01900184 	orrseq	r0, r0, r4, lsl #3
      tempa[1]=RoundKey[k + 1];
    1cac:	32007205 	andcc	r7, r0, #1342177280	@ 0x50000000
    1cb0:	90049f24 	andls	r9, r4, r4, lsr #30
    1cb4:	05029601 	streq	r9, [r2, #-1537]	@ 0xfffff9ff
      tempa[2]=RoundKey[k + 2];
    1cb8:	24327f73 	ldrtcs	r7, [r2], #-3955	@ 0xfffff08d
    1cbc:	0001009f 	muleq	r1, pc, r0	@ <UNPREDICTABLE>
      tempa[3]=RoundKey[k + 3];
    1cc0:	00000000 	andeq	r0, r0, r0
    1cc4:	d601ac04 	strle	sl, [r1], -r4, lsl #24
    if (i % Nk == 0)
    1cc8:	04510101 	ldrbeq	r0, [r1], #-257	@ 0xfffffeff
        tempa[0] = tempa[1];
    1ccc:	01da01d6 	ldrsbeq	r0, [sl, #22]
        tempa[1] = tempa[2];
    1cd0:	046f9102 	strbteq	r9, [pc], #-258	@ 1cd8 <KeyExpansion+0xb8>
        tempa[2] = tempa[3];
    1cd4:	01ea01da 	ldrdeq	r0, [sl, #26]!
        tempa[3] = u8tmp;
    1cd8:	327f7307 	rsbscc	r7, pc, #469762048	@ 0x1c000000
        tempa[0] = getSBoxValue(tempa[0]);
    1cdc:	22007024 	andcs	r7, r0, #36	@ 0x24
    1ce0:	00050300 	andeq	r0, r5, r0, lsl #6
        tempa[1] = getSBoxValue(tempa[1]);
    1ce4:	04000500 	streq	r0, [r0], #-1280	@ 0xfffffb00
	...
        tempa[2] = getSBoxValue(tempa[2]);
    1cf0:	0ab80400 	beq	fee02cf8 <_STACK_TOP_+0xdedfacfc>
        tempa[3] = getSBoxValue(tempa[3]);
    1cf4:	50010ac8 	andpl	r0, r1, r8, asr #21
    1cf8:	800ac804 	andhi	ip, sl, r4, lsl #16
      tempa[0] = tempa[0] ^ Rcon[i/Nk];
    1cfc:	0056010b 	subseq	r0, r6, fp, lsl #2
    1d00:	00000000 	andeq	r0, r0, r0
    1d04:	c60ab804 	strgt	fp, [sl], -r4, lsl #16
    1d08:	0451010a 	ldrbeq	r0, [r1], #-266	@ 0xfffffef6
        tempa[0] = getSBoxValue(tempa[0]);
    1d0c:	0b800ac6 	bleq	fe00482c <_STACK_TOP_+0xddffc830>
    1d10:	00005401 	andeq	r5, r0, r1, lsl #8
    1d14:	04000000 	streq	r0, [r0], #-0
        tempa[1] = getSBoxValue(tempa[1]);
    1d18:	0acb0ab8 	beq	ff2c4800 <_STACK_TOP_+0xdf2bc804>
    1d1c:	cb045201 	blgt	116528 <__ROM_SIZE__+0xd6528>
        tempa[2] = getSBoxValue(tempa[2]);
    1d20:	010b800a 	tsteq	fp, sl
    1d24:	00000055 	andeq	r0, r0, r5, asr r0
    1d28:	fb0ae204 	blx	2ba542 <__ROM_SIZE__+0x27a542>
        tempa[3] = getSBoxValue(tempa[3]);
    1d2c:	0053010a 	subseq	r0, r3, sl, lsl #2
    1d30:	00000000 	andeq	r0, r0, r0
    1d34:	fb09e404 	blx	27ad4e <__ROM_SIZE__+0x23ad4e>
}
    1d38:	04500109 	ldrbeq	r0, [r0], #-265	@ 0xfffffef7
    1d3c:	0ab809fb 	beq	fee04530 <_STACK_TOP_+0xdedfc534>
{
    1d40:	00005601 	andeq	r5, r0, r1, lsl #12
  for (i = 0; i < 4; ++i)
    1d44:	04000000 	streq	r0, [r0], #-0
      (*state)[i][j] ^= RoundKey[(round * Nb * 4) + (i * Nb) + j];
    1d48:	09f809e4 	ldmibeq	r8!, {r2, r5, r6, r7, r8, fp}^
    1d4c:	f8045101 			@ <UNDEFINED> instruction: 0xf8045101
    1d50:	010ab809 	tsteq	sl, r9, lsl #16
    1d54:	00000055 	andeq	r0, r0, r5, asr r0
    1d58:	900a8c04 	andls	r8, sl, r4, lsl #24
    1d5c:	0050010a 	subseq	r0, r0, sl, lsl #2
    1d60:	8e040000 	cdphi	0, 0, cr0, cr4, cr0, {0}
    for (j = 0; j < 4; ++j)
    1d64:	010aaa0a 	tsteq	sl, sl, lsl #20
    1d68:	00000054 	andeq	r0, r0, r4, asr r0
  for (i = 0; i < 4; ++i)
    1d6c:	fc040000 	stc2	0, cr0, [r4], {-0}
    1d70:	01098708 	tsteq	r9, r8, lsl #14
    for (j = 0; j < 4; ++j)
    1d74:	09870450 	stmibeq	r7, {r4, r6, sl}
  for (i = 0; i < 4; ++i)
    1d78:	540109e4 	strpl	r0, [r1], #-2532	@ 0xfffff61c
    1d7c:	00000000 	andeq	r0, r0, r0
    for (j = 0; j < 4; ++j)
    1d80:	08fc0400 	ldmeq	ip!, {sl}^
{
    1d84:	51010987 	smlabbpl	r1, r7, r9, r0
      (*state)[j][i] = getSBoxValue((*state)[j][i]);
    1d88:	e4098704 	str	r8, [r9], #-1796	@ 0xfffff8fc
    1d8c:	00550109 	subseq	r0, r5, r9, lsl #2
    1d90:	00000000 	andeq	r0, r0, r0
    1d94:	b208a604 	andlt	sl, r8, #4, 12	@ 0x400000
    for (j = 0; j < 4; ++j)
    1d98:	04500108 	ldrbeq	r0, [r0], #-264	@ 0xfffffef8
    1d9c:	08fc08b2 	ldmeq	ip!, {r1, r4, r5, r7, fp}^
  for (i = 0; i < 4; ++i)
    1da0:	00005601 	andeq	r5, r0, r1, lsl #12
    1da4:	04000000 	streq	r0, [r0], #-0
    for (j = 0; j < 4; ++j)
    1da8:	08b508a6 	ldmeq	r5!, {r1, r2, r5, r7, fp}
}
    1dac:	b5045101 	strlt	r5, [r4, #-257]	@ 0xfffffeff
  for (i = 0; i < 4; ++i)
    1db0:	0108fc08 	tsteq	r8, r8, lsl #24	@ <UNPREDICTABLE>
    1db4:	00000057 	andeq	r0, r0, r7, asr r0
    1db8:	a6040000 	strge	r0, [r4], -r0
  temp           = (*state)[0][1];
    1dbc:	0108b508 	tsteq	r8, r8, lsl #10
  (*state)[0][1] = (*state)[1][1];
    1dc0:	08b50452 	ldmeq	r5!, {r1, r4, r6, sl}
  (*state)[1][1] = (*state)[2][1];
    1dc4:	550108fc 	strpl	r0, [r1, #-2300]	@ 0xfffff704
  (*state)[2][1] = (*state)[3][1];
    1dc8:	04000000 	streq	r0, [r0], #-0
  temp           = (*state)[0][2];
    1dcc:	08fc08c2 	ldmeq	ip!, {r1, r6, r7, fp}^
  (*state)[0][2] = (*state)[2][2];
    1dd0:	00005401 	andeq	r5, r0, r1, lsl #8
  temp           = (*state)[1][2];
    1dd4:	00000000 	andeq	r0, r0, r0
  (*state)[1][2] = (*state)[3][2];
    1dd8:	08b80400 	ldmeq	r8!, {sl}
  temp           = (*state)[0][3];
    1ddc:	500108bc 			@ <UNDEFINED> instruction: 0x500108bc
  (*state)[0][3] = (*state)[3][3];
    1de0:	c208bc04 	andgt	fp, r8, #4, 24	@ 0x400
  (*state)[3][3] = (*state)[2][3];
    1de4:	04540108 	ldrbeq	r0, [r4], #-264	@ 0xfffffef8
  (*state)[2][3] = (*state)[1][3];
    1de8:	08c408c2 	stmiaeq	r4, {r1, r6, r7, fp}^
}
    1dec:	9f017403 	svcls	0x00017403
  return ((x<<1) ^ (((x>>7) & 1) * 0x1b));
    1df0:	00000000 	andeq	r0, r0, r0
    1df4:	06d20400 	ldrbeq	r0, [r2], r0, lsl #8
    1df8:	500106e2 	andpl	r0, r1, r2, ror #13
}
    1dfc:	a606e204 	strge	lr, [r6], -r4, lsl #4
{
    1e00:	00540108 	subseq	r0, r4, r8, lsl #2
    1e04:	00000000 	andeq	r0, r0, r0
  for (i = 0; i < 4; ++i)
    1e08:	e006d204 	and	sp, r6, r4, lsl #4
    t   = (*state)[i][0];
    1e0c:	04510106 	ldrbeq	r0, [r1], #-262	@ 0xfffffefa
    Tmp = (*state)[i][0] ^ (*state)[i][1] ^ (*state)[i][2] ^ (*state)[i][3] ;
    1e10:	08a606e0 	stmiaeq	r6!, {r5, r6, r7, r9, sl}
    1e14:	00005701 	andeq	r5, r0, r1, lsl #14
    1e18:	04000000 	streq	r0, [r0], #-0
    1e1c:	06e506d2 	usateq	r0, #5, r2, asr #13
    1e20:	e5045201 	str	r5, [r4, #-513]	@ 0xfffffdff
    1e24:	0108a606 	tsteq	r8, r6, lsl #12
    Tm  = (*state)[i][0] ^ (*state)[i][1] ; Tm = xtime(Tm);  (*state)[i][0] ^= Tm ^ Tmp ;
    1e28:	00000055 	andeq	r0, r0, r5, asr r0
    1e2c:	d2040000 	andle	r0, r4, #0
    1e30:	0106e506 	tsteq	r6, r6, lsl #10
    Tm  = (*state)[i][1] ^ (*state)[i][2] ; Tm = xtime(Tm);  (*state)[i][1] ^= Tm ^ Tmp ;
    1e34:	06e50453 	usateq	r0, #5, r3, asr #8
    1e38:	560108a6 	strpl	r0, [r1], -r6, lsr #17
    1e3c:	00000000 	andeq	r0, r0, r0
    1e40:	05e40400 	strbeq	r0, [r4, #1024]!	@ 0x400
    1e44:	500105ef 	andpl	r0, r1, pc, ror #11
    Tm  = (*state)[i][2] ^ (*state)[i][3] ; Tm = xtime(Tm);  (*state)[i][2] ^= Tm ^ Tmp ;
    1e48:	d205ef04 	andle	lr, r5, #4, 30
    1e4c:	00540106 	subseq	r0, r4, r6, lsl #2
    1e50:	00000000 	andeq	r0, r0, r0
    1e54:	ef05e404 	svc	0x0005e404
    Tm  = (*state)[i][3] ^ t ;              Tm = xtime(Tm);  (*state)[i][3] ^= Tm ^ Tmp ;
    1e58:	04510105 	ldrbeq	r0, [r1], #-261	@ 0xfffffefb
    1e5c:	06d205ef 	ldrbeq	r0, [r2], pc, ror #11
    1e60:	00005501 	andeq	r5, r0, r1, lsl #10
    1e64:	04000000 	streq	r0, [r0], #-0
    1e68:	05d505ce 	ldrbeq	r0, [r5, #1486]	@ 0x5ce
  for (i = 0; i < 4; ++i)
    1e6c:	d5045001 	strle	r5, [r4, #-1]
    1e70:	0405e405 	streq	lr, [r5], #-1029	@ 0xfffffbfb
}
    1e74:	9f5001a3 	svcls	0x005001a3
{
    1e78:	00000000 	andeq	r0, r0, r0
    1e7c:	05ce0400 	strbeq	r0, [lr, #1024]	@ 0x400
  for (i = 0; i < 4; ++i)
    1e80:	510105d5 	ldrdpl	r0, [r1, -r5]
    a = (*state)[i][0];
    1e84:	e405d504 	str	sp, [r5], #-1284	@ 0xfffffafc
    b = (*state)[i][1];
    1e88:	00540105 	subseq	r0, r4, r5, lsl #2
    1e8c:	00000000 	andeq	r0, r0, r0
    c = (*state)[i][2];
    1e90:	c505be04 	strgt	fp, [r5, #-3588]	@ 0xfffff1fc
    d = (*state)[i][3];
    1e94:	04500105 	ldrbeq	r0, [r0], #-261	@ 0xfffffefb
    (*state)[i][0] = Multiply(a, 0x0e) ^ Multiply(b, 0x0b) ^ Multiply(c, 0x0d) ^ Multiply(d, 0x09);
    1e98:	05ce05c5 	strbeq	r0, [lr, #1477]	@ 0x5c5
    1e9c:	5001a304 	andpl	sl, r1, r4, lsl #6
    1ea0:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
    1ea4:	be040000 	cdplt	0, 0, cr0, cr4, cr0, {0}
    1ea8:	0105c505 	tsteq	r5, r5, lsl #10
    1eac:	05c50451 	strbeq	r0, [r5, #1105]	@ 0x451
    1eb0:	540105ce 	strpl	r0, [r1], #-1486	@ 0xfffffa32
    1eb4:	00000000 	andeq	r0, r0, r0
    1eb8:	05a80400 	streq	r0, [r8, #1024]!	@ 0x400
    1ebc:	500105b3 			@ <UNDEFINED> instruction: 0x500105b3
    1ec0:	be05b304 	cdplt	3, 0, cr11, cr5, cr4, {0}
    1ec4:	01a30405 			@ <UNDEFINED> instruction: 0x01a30405
    1ec8:	00009f50 	andeq	r9, r0, r0, asr pc
    1ecc:	04000000 	streq	r0, [r0], #-0
    1ed0:	05b005a8 	ldreq	r0, [r0, #1448]!	@ 0x5a8
    1ed4:	b0045101 	andlt	r5, r4, r1, lsl #2
    1ed8:	0105be05 	tsteq	r5, r5, lsl #28
    1edc:	00000054 	andeq	r0, r0, r4, asr r0
    1ee0:	a8040000 	stmdage	r4, {}	@ <UNPREDICTABLE>
    1ee4:	0105b305 	tsteq	r5, r5, lsl #6
    1ee8:	05b30452 	ldreq	r0, [r3, #1106]!	@ 0x452
    1eec:	a30405be 	movwge	r0, #17854	@ 0x45be
    1ef0:	009f5201 	addseq	r5, pc, r1, lsl #4
    1ef4:	00000000 	andeq	r0, r0, r0
    1ef8:	b305a804 	movwlt	sl, #22532	@ 0x5804
    1efc:	04530105 	ldrbeq	r0, [r3], #-261	@ 0xfffffefb
    1f00:	05be05b3 	ldreq	r0, [lr, #1459]!	@ 0x5b3
    1f04:	00005501 	andeq	r5, r0, r1, lsl #10
    1f08:	00000000 	andeq	r0, r0, r0
    1f0c:	04a40400 	strteq	r0, [r4], #1024	@ 0x400
    1f10:	500104ac 	andpl	r0, r1, ip, lsr #9
    1f14:	a204ac04 	andge	sl, r4, #4, 24	@ 0x400
    1f18:	04570105 	ldrbeq	r0, [r7], #-261	@ 0xfffffefb
    1f1c:	05a805a2 	streq	r0, [r8, #1442]!	@ 0x5a2
    1f20:	5001a304 	andpl	sl, r1, r4, lsl #6
    1f24:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
    (*state)[i][1] = Multiply(a, 0x09) ^ Multiply(b, 0x0e) ^ Multiply(c, 0x0b) ^ Multiply(d, 0x0d);
    1f28:	a4040000 	strge	r0, [r4], #-0
    1f2c:	0104af04 	tsteq	r4, r4, lsl #30
    1f30:	04af0451 	strteq	r0, [pc], #1105	@ 1f38 <InvMixColumns+0xc2>
    1f34:	a30405a8 	movwge	r0, #17832	@ 0x45a8
    1f38:	009f5101 	addseq	r5, pc, r1, lsl #2
    1f3c:	00000000 	andeq	r0, r0, r0
    1f40:	c6040000 	strgt	r0, [r4], -r0
    1f44:	0104ee04 	tsteq	r4, r4, lsl #28
    1f48:	05860456 	streq	r0, [r6, #1110]	@ 0x456
    1f4c:	74060588 	strvc	r0, [r6], #-1416	@ 0xfffffa78
    1f50:	1c007000 	stcne	0, cr7, [r0], {-0}
    1f54:	0588049f 	streq	r0, [r8, #1183]	@ 0x49f
    1f58:	5601059e 			@ <UNDEFINED> instruction: 0x5601059e
    1f5c:	00000000 	andeq	r0, r0, r0
    (*state)[i][2] = Multiply(a, 0x0d) ^ Multiply(b, 0x09) ^ Multiply(c, 0x0e) ^ Multiply(d, 0x0b);
    1f60:	04000000 	streq	r0, [r0], #-0
    1f64:	03ba03ae 			@ <UNDEFINED> instruction: 0x03ba03ae
    1f68:	ba045001 	blt	115f74 <__ROM_SIZE__+0xd5f74>
    1f6c:	0104a003 	tsteq	r4, r3
    1f70:	04a00456 	strteq	r0, [r0], #1110	@ 0x456
    1f74:	a30404a4 	movwge	r0, #17572	@ 0x44a4
    1f78:	009f5001 	addseq	r5, pc, r1
	...
    1f84:	ae040000 	cdpge	0, 0, cr0, cr4, cr0, {0}
    1f88:	0103bd03 	tsteq	r3, r3, lsl #26
    1f8c:	03bd0451 			@ <UNDEFINED> instruction: 0x03bd0451
    (*state)[i][3] = Multiply(a, 0x0b) ^ Multiply(b, 0x0d) ^ Multiply(c, 0x09) ^ Multiply(d, 0x0e);
    1f90:	540103d2 	strpl	r0, [r1], #-978	@ 0xfffffc2e
    1f94:	d403d204 	strle	sp, [r3], #-516	@ 0xfffffdfc
    1f98:	01a30403 			@ <UNDEFINED> instruction: 0x01a30403
    1f9c:	d4049f51 	strle	r9, [r4], #-3921	@ 0xfffff0af
    1fa0:	0103dc03 	tsteq	r3, r3, lsl #24
    1fa4:	03dc0454 	bicseq	r0, ip, #84, 8	@ 0x54000000
    1fa8:	a30404a4 	movwge	r0, #17572	@ 0x44a4
    1fac:	009f5101 	addseq	r5, pc, r1, lsl #2
    1fb0:	00000000 	andeq	r0, r0, r0
    1fb4:	ae040000 	cdpge	0, 0, cr0, cr4, cr0, {0}
    1fb8:	0103bd03 	tsteq	r3, r3, lsl #26
    1fbc:	03bd0452 			@ <UNDEFINED> instruction: 0x03bd0452
    1fc0:	550104a0 	strpl	r0, [r1, #-1184]	@ 0xfffffb60
  for (i = 0; i < 4; ++i)
    1fc4:	a404a004 	strge	sl, [r4], #-4
    1fc8:	01a30404 			@ <UNDEFINED> instruction: 0x01a30404
}
    1fcc:	00009f52 	andeq	r9, r0, r2, asr pc
  for (i = 0; i < 4; ++i)
    1fd0:	03dc0400 	bicseq	r0, ip, #0, 8
    1fd4:	540104a0 	strpl	r0, [r1], #-1184	@ 0xfffffb60
    for (j = 0; j < 4; ++j)
    1fd8:	00000300 	andeq	r0, r0, r0, lsl #6
{
    1fdc:	03820400 	orreq	r0, r2, #0, 8
      (*state)[j][i] = getSBoxInvert((*state)[j][i]);
    1fe0:	30020384 	andcc	r0, r2, r4, lsl #7
    1fe4:	0384049f 	orreq	r0, r4, #-1627389952	@ 0x9f000000
    1fe8:	530103a4 	movwpl	r0, #5028	@ 0x13a4
	...
    for (j = 0; j < 4; ++j)
    1ff4:	02e00400 	rsceq	r0, r0, #0, 8
    1ff8:	500102fa 	strdpl	r0, [r1], -sl
  for (i = 0; i < 4; ++i)
    1ffc:	fe02fa04 	vseleq.f32	s30, s4, s8
    2000:	01a30402 			@ <UNDEFINED> instruction: 0x01a30402
    for (j = 0; j < 4; ++j)
    2004:	fe049f50 	mcr2	15, 0, r9, cr4, cr0, {2}
}
    2008:	01038002 	tsteq	r3, r2
  for (i = 0; i < 4; ++i)
    200c:	03800450 	orreq	r0, r0, #80, 8	@ 0x50000000
    2010:	a3040382 	movwge	r0, #17282	@ 0x4382
    2014:	009f5001 	addseq	r5, pc, r1
  temp = (*state)[3][1];
    2018:	e6040000 	str	r0, [r4], -r0
  (*state)[3][1] = (*state)[2][1];
    201c:	0102fe02 	tsteq	r2, r2, lsl #28	@ <UNPREDICTABLE>
  (*state)[2][1] = (*state)[1][1];
    2020:	00020053 	andeq	r0, r2, r3, asr r0
  (*state)[1][1] = (*state)[0][1];
    2024:	d0040000 	andle	r0, r4, r0
  temp = (*state)[0][2];
    2028:	0202d202 	andeq	sp, r2, #536870912	@ 0x20000000
  (*state)[0][2] = (*state)[2][2];
    202c:	d2049f31 	andle	r9, r4, #49, 30	@ 0xc4
  temp = (*state)[1][2];
    2030:	0102e002 	tsteq	r2, r2
  (*state)[1][2] = (*state)[3][2];
    2034:	00000053 	andeq	r0, r0, r3, asr r0
  temp = (*state)[0][3];
    2038:	00000000 	andeq	r0, r0, r0
  (*state)[0][3] = (*state)[1][3];
    203c:	9801d804 	stmdals	r1, {r2, fp, ip, lr, pc}
  (*state)[1][3] = (*state)[2][3];
    2040:	04510102 	ldrbeq	r0, [r1], #-258	@ 0xfffffefe
  (*state)[2][3] = (*state)[3][3];
    2044:	02c80298 	sbceq	r0, r8, #152, 4	@ 0x80000009
}
    2048:	5101a304 	tstpl	r1, r4, lsl #6
{
    204c:	02c8049f 	sbceq	r0, r8, #-1627389952	@ 0x9f000000
  AddRoundKey(0, state, RoundKey);
    2050:	510102cc 	smlabtpl	r1, ip, r2, r0
    2054:	01010000 	mrseq	r0, (UNDEF: 1)
    2058:	04000000 	streq	r0, [r0], #-0
  for (round = 1; ; ++round)
    205c:	029201d8 	addseq	r0, r2, #216, 2	@ 0x36
    MixColumns(state);
    2060:	92045201 	andls	r5, r4, #268435456	@ 0x10000000
    AddRoundKey(round, state, RoundKey);
    2064:	05029602 	streq	r9, [r2, #-1538]	@ 0xfffff9fe
    2068:	1a4f0072 	bne	13c2238 <__ROM_SIZE__+0x1382238>
    206c:	0296049f 	addseq	r0, r6, #-1627389952	@ 0x9f000000
  for (round = 1; ; ++round)
    2070:	520102cc 	andpl	r0, r1, #204, 4	@ 0xc000000c
    SubBytes(state);
    2074:	00000000 	andeq	r0, r0, r0
    ShiftRows(state);
    2078:	01e40400 	mvneq	r0, r0, lsl #8
    207c:	5c0101e8 	stfpls	f0, [r1], {232}	@ 0xe8
    if (round == Nr) {
    2080:	fe01ee04 	cdp2	14, 0, cr14, cr1, cr4, {0}
  AddRoundKey(Nr, state, RoundKey);
    2084:	005c0101 	subseq	r0, ip, r1, lsl #2
    2088:	00000002 	andeq	r0, r0, r2
}
    208c:	e4040000 	str	r0, [r4], #-0
{
    2090:	0201e801 	andeq	lr, r1, #65536	@ 0x10000
  AddRoundKey(Nr, state, RoundKey);
    2094:	ee049f30 	mcr	15, 0, r9, cr4, cr0, {1}
    2098:	01029801 	tsteq	r2, r1, lsl #16
    209c:	02c80453 	sbceq	r0, r8, #1392508928	@ 0x53000000
  for (round = (Nr - 1); ; --round)
    20a0:	530102ca 	movwpl	r0, #4810	@ 0x12ca
    InvMixColumns(state);
    20a4:	00000000 	andeq	r0, r0, r0
  for (round = (Nr - 1); ; --round)
    20a8:	02800400 	addeq	r0, r0, #0, 8
    InvShiftRows(state);
    20ac:	5c010298 	sfmpl	f0, 4, [r1], {152}	@ 0x98
    20b0:	cc02c804 	stcgt	8, cr12, [r2], {4}
    InvSubBytes(state);
    20b4:	005c0102 	subseq	r0, ip, r2, lsl #2
    AddRoundKey(round, state, RoundKey);
    20b8:	9c040000 	stcls	0, cr0, [r4], {-0}
    20bc:	0102c202 	tsteq	r2, r2, lsl #4
    20c0:	00000053 	andeq	r0, r0, r3, asr r0
    if (round == 0) {
    20c4:	00000000 	andeq	r0, r0, r0
  for (i = 0; i < AES_BLOCKLEN; ++i) // The block in AES is always 128bit no matter the key size
    20c8:	ae040000 	cdpge	0, 0, cr0, cr4, cr0, {0}
    buf[i] ^= Iv[i];
    20cc:	0101b201 	tsteq	r1, r1, lsl #4
    20d0:	01b20450 			@ <UNDEFINED> instruction: 0x01b20450
    20d4:	530101b8 	movwpl	r0, #4536	@ 0x11b8
  for (i = 0; i < AES_BLOCKLEN; ++i) // The block in AES is always 128bit no matter the key size
    20d8:	bc01b804 	stclt	8, cr11, [r1], {4}
    20dc:	7c730301 	ldclvc	3, cr0, [r3], #-4
}
    20e0:	01bc049f 			@ <UNDEFINED> instruction: 0x01bc049f
  KeyExpansion(ctx->RoundKey, key);
    20e4:	530101d8 	movwpl	r0, #4568	@ 0x11d8
}
    20e8:	00000200 	andeq	r0, r0, r0, lsl #4
{
    20ec:	01ae0400 			@ <UNDEFINED> instruction: 0x01ae0400
  KeyExpansion(ctx->RoundKey, key);
    20f0:	080301b4 	stmdaeq	r3, {r2, r4, r5, r7, r8}
  memcpy (ctx->Iv, iv, AES_BLOCKLEN);
    20f4:	b4049fc0 	strlt	r9, [r4], #-4032	@ 0xfffff040
    20f8:	0101d801 	tsteq	r1, r1, lsl #16
    20fc:	00000050 	andeq	r0, r0, r0, asr r0
}
    2100:	d201c604 	andle	ip, r1, #4, 12	@ 0x400000
  memcpy (ctx->Iv, iv, AES_BLOCKLEN);
    2104:	00520101 	subseq	r0, r2, r1, lsl #2
    2108:	00000000 	andeq	r0, r0, r0
}
    210c:	aa019404 	bge	67124 <__ROM_SIZE__+0x27124>
{
    2110:	04500101 	ldrbeq	r0, [r0], #-257	@ 0xfffffeff
  Cipher((state_t*)buf, ctx->RoundKey);
    2114:	01ae01aa 			@ <UNDEFINED> instruction: 0x01ae01aa
    2118:	5001a304 	andpl	sl, r1, r4, lsl #6
{
    211c:	0002009f 	muleq	r2, pc, r0	@ <UNPREDICTABLE>
  InvCipher((state_t*)buf, ctx->RoundKey);
    2120:	94040000 	strls	r0, [r4], #-0
    2124:	02019601 	andeq	r9, r1, #1048576	@ 0x100000
}
    2128:	96049f30 			@ <UNDEFINED> instruction: 0x96049f30
{
    212c:	0101ae01 	tsteq	r1, r1, lsl #28
    2130:	00030053 	andeq	r0, r3, r3, asr r0
  uint8_t *Iv = ctx->Iv;
    2134:	82040000 	andhi	r0, r4, #0
    2138:	02018601 	andeq	r8, r1, #1048576	@ 0x100000
  for (i = 0; i < length; i += AES_BLOCKLEN)
    213c:	86049f30 			@ <UNDEFINED> instruction: 0x86049f30
    XorWithIv(buf, Iv);
    2140:	01019401 	tsteq	r1, r1, lsl #8
    Cipher((state_t*)buf, ctx->RoundKey);
    2144:	00000053 	andeq	r0, r0, r3, asr r0
    2148:	00000000 	andeq	r0, r0, r0
  for (i = 0; i < length; i += AES_BLOCKLEN)
    214c:	64040000 	strvs	r0, [r4], #-0
    buf += AES_BLOCKLEN;
    2150:	0450017c 	ldrbeq	r0, [r0], #-380	@ 0xfffffe84
  for (i = 0; i < length; i += AES_BLOCKLEN)
    2154:	a3047e7c 	movwge	r7, #20092	@ 0x4e7c
  memcpy(ctx->Iv, Iv, AES_BLOCKLEN);
    2158:	049f5001 	ldreq	r5, [pc], #1	@ 2160 <AES_CBC_encrypt_buffer+0x36>
    215c:	0101807e 	tsteq	r1, lr, ror r0
}
    2160:	01800450 	orreq	r0, r0, r0, asr r4
{
    2164:	a3040182 	movwge	r0, #16770	@ 0x4182
    2168:	009f5001 	addseq	r5, pc, r1
    216c:	00000003 	andeq	r0, r0, r3
  for (i = 0; i < length; i += AES_BLOCKLEN)
    2170:	02666404 	rsbeq	r6, r6, #4, 8	@ 0x4000000
    memcpy(storeNextIv, buf, AES_BLOCKLEN);
    2174:	66049f30 			@ <UNDEFINED> instruction: 0x66049f30
    2178:	53010182 	movwpl	r0, #4482	@ 0x1182
    InvCipher((state_t*)buf, ctx->RoundKey);
    217c:	00000000 	andeq	r0, r0, r0
    2180:	04000000 	streq	r0, [r0], #-0
    XorWithIv(buf, ctx->Iv);
    2184:	50014c40 	andpl	r4, r1, r0, asr #24
    2188:	014f4c04 	cmpeq	pc, r4, lsl #24
    218c:	644f0451 	strbvs	r0, [pc], #-1105	@ 2194 <AES_CBC_decrypt_buffer+0x32>
    memcpy(ctx->Iv, storeNextIv, AES_BLOCKLEN);
    2190:	00005501 	andeq	r5, r0, r1, lsl #10
    2194:	04000000 	streq	r0, [r0], #-0
    2198:	51014a40 	tstpl	r1, r0, asr #20
  for (i = 0; i < length; i += AES_BLOCKLEN)
    219c:	01644a04 	cmneq	r4, r4, lsl #20
    21a0:	00030054 	andeq	r0, r3, r4, asr r0
}
    21a4:	2c040000 	stccs	0, cr0, [r4], {-0}
{
    21a8:	9f300230 	svcls	0x00300230
    21ac:	01403004 	cmpeq	r0, r4
    21b0:	00000053 	andeq	r0, r0, r3, asr r0
  for (i = 0, bi = AES_BLOCKLEN; i < length; ++i, ++bi)
    21b4:	12040000 	andne	r0, r4, #0
          ctx->Iv[bi] = 0;
    21b8:	0451011e 	ldrbeq	r0, [r1], #-286	@ 0xfffffee2
    21bc:	a3042c1e 	movwge	r2, #19486	@ 0x4c1e
      for (bi = (AES_BLOCKLEN - 1); bi >= 0; --bi)
    21c0:	009f5101 	addseq	r5, pc, r1, lsl #2
      bi = 0;
    21c4:	00000000 	andeq	r0, r0, r0
    buf[i] = (buf[i] ^ buffer[bi]);
    21c8:	01060004 	tsteq	r6, r4
    21cc:	12060450 	andne	r0, r6, #80, 8	@ 0x50000000
    21d0:	5001a304 	andpl	sl, r1, r4, lsl #6
    21d4:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
    21d8:	00040000 	andeq	r0, r4, r0
  for (i = 0, bi = AES_BLOCKLEN; i < length; ++i, ++bi)
    21dc:	0451010a 	ldrbeq	r0, [r1], #-266	@ 0xfffffef6
    21e0:	a304120a 	movwge	r1, #16906	@ 0x420a
    if (bi == AES_BLOCKLEN) /* we need to regen xor compliment in buffer */
    21e4:	009f5101 	addseq	r5, pc, r1, lsl #2
      memcpy(buffer, ctx->Iv, AES_BLOCKLEN);
    21e8:	0000009d 	muleq	r0, sp, r0
    21ec:	00040005 	andeq	r0, r4, r5
	...
      Cipher((state_t*)buffer,ctx->RoundKey);
    21f8:	01241e04 			@ <UNDEFINED> instruction: 0x01241e04
      for (bi = (AES_BLOCKLEN - 1); bi >= 0; --bi)
    21fc:	5c240450 	cfstrspl	mvf0, [r4], #-320	@ 0xfffffec0
    2200:	01005c01 	tsteq	r0, r1, lsl #24
        if (ctx->Iv[bi] == 255)
    2204:	01010000 	mrseq	r0, (UNDEF: 1)
    2208:	04000000 	streq	r0, [r0], #-0
        ctx->Iv[bi] += 1;
    220c:	30022620 	andcc	r2, r2, r0, lsr #12
    2210:	3226049f 	eorcc	r0, r6, #-1627389952	@ 0x9f000000
      bi = 0;
    2214:	32045001 	andcc	r5, r4, #1
}
    2218:	00700536 	rsbseq	r0, r0, r6, lsr r5
  return ((x[idx / 32U] >> (idx & 31U) & 1U));
    221c:	049f2434 	ldreq	r2, [pc], #1076	@ 2224 <bitvec_get_bit+0x8>
    2220:	50015c36 	andpl	r5, r1, r6, lsr ip
    2224:	00000200 	andeq	r0, r0, r0, lsl #4
}
    2228:	00000000 	andeq	r0, r0, r0
    222c:	26200400 	strtcs	r0, [r0], -r0, lsl #8
  x[idx / 32U] &= ~(1U << (idx & 31U));
    2230:	049f3002 	ldreq	r3, [pc], #2	@ 2238 <bitvec_clr_bit+0xa>
    2234:	53013632 	movwpl	r3, #5682	@ 0x1632
    2238:	014c4a04 	cmpeq	ip, r4, lsl #20
    223c:	5a580453 	bpl	1603390 <__ROM_SIZE__+0x15c3390>
    2240:	04005301 	streq	r5, [r0], #-769	@ 0xfffffcff
    2244:	04000000 	streq	r0, [r0], #-0
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2248:	30022620 	andcc	r2, r2, r0, lsr #12
    x[i] = y[i];
    224c:	5c26049f 	cfstrspl	mvf0, [r6], #-636	@ 0xfffffd84
    2250:	00005101 	andeq	r5, r0, r1, lsl #2
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2254:	04000000 	streq	r0, [r0], #-0
    2258:	50010600 	andpl	r0, r1, r0, lsl #12
{
    225c:	011e0604 	tsteq	lr, r4, lsl #12
    2260:	00010051 	andeq	r0, r1, r1, asr r0
  bitvec_copy(tmp, x);
    2264:	00000000 	andeq	r0, r0, r0
    2268:	02080204 	andeq	r0, r8, #4, 4	@ 0x40000000
  bitvec_copy(x, y);
    226c:	08049f30 	stmdaeq	r4, {r4, r5, r8, r9, sl, fp, ip, pc}
    2270:	0450010c 	ldrbeq	r0, [r0], #-268	@ 0xfffffef4
  bitvec_copy(y, tmp);
    2274:	50011e14 	andpl	r1, r1, r4, lsl lr
    2278:	00000300 	andeq	r0, r0, r0, lsl #6
}
    227c:	08020400 	stmdaeq	r2, {sl}
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2280:	049f3002 	ldreq	r3, [pc], #2	@ 2288 <bitvec_equal+0x8>
    2284:	52011e08 	andpl	r1, r1, #8, 28	@ 0x80
    if (x[i] != y[i])
    2288:	00007400 	andeq	r7, r0, r0, lsl #8
    228c:	04000500 	streq	r0, [r0], #-1280	@ 0xfffffb00
	...
  return 1;
    2298:	68580400 	ldmdavs	r8, {sl}^
}
    229c:	6a045001 	bvs	1162a8 <__ROM_SIZE__+0xd62a8>
  for (i = 0; i < BITVEC_NWORDS; ++i)
    22a0:	00500170 	subseq	r0, r0, r0, ror r1
    x[i] = 0;
    22a4:	00000000 	andeq	r0, r0, r0
  for (i = 0; i < BITVEC_NWORDS; ++i)
    22a8:	00040000 	andeq	r0, r4, r0
    22ac:	04500129 	ldrbeq	r0, [r0], #-297	@ 0xfffffed7
  uint32_t i = 0;
    22b0:	a3042c29 	movwge	r2, #19497	@ 0x4c29
  while (i < BITVEC_NWORDS)
    22b4:	049f5001 	ldreq	r5, [pc], #1	@ 22bc <bitvec_is_zero+0xc>
    if (x[i] != 0)
    22b8:	5001402c 	andpl	r4, r1, ip, lsr #32
	...
}
    22c4:	26000400 	strcs	r0, [r0], -r0, lsl #8
    22c8:	26045101 	strcs	r5, [r4], -r1, lsl #2
  x += BITVEC_NWORDS;
    22cc:	04520129 	ldrbeq	r0, [r2], #-297	@ 0xfffffed7
          && (*(--x)) == 0)
    22d0:	a3042c29 	movwge	r2, #19497	@ 0x4c29
    22d4:	049f5101 	ldreq	r5, [pc], #257	@ 22dc <bitvec_degree+0x12>
    22d8:	5101402c 	tstpl	r1, ip, lsr #32
	...
      i -= 1;
    22e4:	24000400 	strcs	r0, [r0], #-1024	@ 0xfffffc00
    while (((*x) & u32mask) == 0)
    22e8:	24045201 	strcs	r5, [r4], #-513	@ 0xfffffdff
}
    22ec:	2c030529 	cfstr32cs	mvfx0, [r3], {41}	@ 0x29
    uint32_t u32mask = ((uint32_t)1 << 31);
    22f0:	04200003 	strteq	r0, [r0], #-3
{
    22f4:	a3042c29 	movwge	r2, #19497	@ 0x4c29
  int nwords = (nbits / 32);
    22f8:	049f5201 	ldreq	r5, [pc], #513	@ 2300 <bitvec_lshift+0xc>
    22fc:	5201402c 	andpl	r4, r1, #44	@ 0x2c
  for (i = 0; i < nwords; ++i)
    2300:	0000dc00 	andeq	sp, r0, r0, lsl #24
  int nwords = (nbits / 32);
    2304:	04000500 	streq	r0, [r0], #-1280	@ 0xfffffb00
	...
  for (i = 0; i < nwords; ++i)
    2310:	5e500400 	cdppl	4, 5, cr0, cr0, cr0, {0}
    2314:	5e045001 	cdppl	0, 0, cr5, cr4, cr1, {0}
  j = 0;
    2318:	01a30460 			@ <UNDEFINED> instruction: 0x01a30460
    x[i] = y[j];
    231c:	04009f50 	streq	r9, [r0], #-3920	@ 0xfffff0b0
    2320:	04000000 	streq	r0, [r0], #-0
    i += 1;
    2324:	30025450 	andcc	r5, r2, r0, asr r4
    j += 1;
    2328:	6054049f 			@ <UNDEFINED> instruction: 0x6054049f
  while (i < BITVEC_NWORDS)
    232c:	03005301 	movweq	r5, #769	@ 0x301
  if (nbits != 0)
    2330:	04000000 	streq	r0, [r0], #-0
}
    2334:	50015e50 	andpl	r5, r1, r0, asr lr
      x[i]  = (x[i] << nbits) | (x[i - 1] >> (32 - nbits));
    2338:	04605e04 	strbteq	r5, [r0], #-3588	@ 0xfffff1fc
    233c:	9f5001a3 	svcls	0x005001a3
    2340:	00000000 	andeq	r0, r0, r0
    2344:	4e3a0400 	cfabssmi	mvf0, mvf10
    2348:	4e045001 	cdpmi	0, 0, cr5, cr4, cr1, {0}
    234c:	01a30450 			@ <UNDEFINED> instruction: 0x01a30450
    2350:	05009f50 	streq	r9, [r0, #-3920]	@ 0xfffff0b0
    2354:	04000000 	streq	r0, [r0], #-0
    for (i = (BITVEC_NWORDS - 1); i > 0; --i)
    2358:	30023e3a 	andcc	r3, r2, sl, lsr lr
    x[0] <<= nbits;
    235c:	503e049f 	mlaspl	lr, pc, r4, r0	@ <UNPREDICTABLE>
    2360:	03005301 	movweq	r5, #769	@ 0x301
    for (i = (BITVEC_NWORDS - 1); i > 0; --i)
    2364:	503a0400 	eorspl	r0, sl, r0, lsl #8
  x[0] = 1;
    2368:	04005101 	streq	r5, [r0], #-257	@ 0xfffffeff
  for (i = 1; i < BITVEC_NWORDS; ++i)
    236c:	04000000 	streq	r0, [r0], #-0
    x[i] = 0;
    2370:	50014e3a 	andpl	r4, r1, sl, lsr lr
  for (i = 1; i < BITVEC_NWORDS; ++i)
    2374:	04504e04 	ldrbeq	r4, [r0], #-3588	@ 0xfffff1fc
    2378:	9f5001a3 	svcls	0x005001a3
  if (x[0] != 1)
    237c:	00000000 	andeq	r0, r0, r0
    2380:	04000000 	streq	r0, [r0], #-0
  for (i = 1; i < BITVEC_NWORDS; ++i)
    2384:	50012a26 	andpl	r2, r1, r6, lsr #20
    if (x[i] != 0)
    2388:	032e2a04 			@ <UNDEFINED> instruction: 0x032e2a04
  for (i = 1; i < BITVEC_NWORDS; ++i)
    238c:	049f0170 	ldreq	r0, [pc], #368	@ 2394 <gf2field_is_one+0x18>
  return (i == BITVEC_NWORDS);
    2390:	5001382e 	andpl	r3, r1, lr, lsr #16
    2394:	00000000 	andeq	r0, r0, r0
    2398:	2a260400 	bcs	9833a0 <__ROM_SIZE__+0x9433a0>
}
    239c:	2a045101 	bcs	1167a8 <__ROM_SIZE__+0xd67a8>
  for (i = 0; i < BITVEC_NWORDS; ++i)
    23a0:	0051013a 	subseq	r0, r1, sl, lsr r1
{
    23a4:	00000000 	andeq	r0, r0, r0
    z[i] = (x[i] ^ y[i]);
    23a8:	01141004 	tsteq	r4, r4
    23ac:	22140450 	andscs	r0, r4, #80, 8	@ 0x50000000
    23b0:	00005001 	andeq	r5, r0, r1
  for (i = 0; i < BITVEC_NWORDS; ++i)
    23b4:	04000000 	streq	r0, [r0], #-0
    23b8:	51011610 	tstpl	r1, r0, lsl r6
}
    23bc:	01261604 			@ <UNDEFINED> instruction: 0x01261604
  x[0] ^= 1;
    23c0:	00000051 	andeq	r0, r0, r1, asr r0
    23c4:	00040000 	andeq	r0, r4, r0
}
    23c8:	04500104 	ldrbeq	r0, [r0], #-260	@ 0xfffffefc
{
    23cc:	52011004 	andpl	r1, r1, #4
    23d0:	00000100 	andeq	r0, r0, r0, lsl #2
  bitvec_copy(tmp, x);
    23d4:	06020400 	streq	r0, [r2], -r0, lsl #8
    23d8:	049f3002 	ldreq	r3, [pc], #2	@ 23e0 <gf2field_mul+0x16>
  if (bitvec_get_bit(y, 0) != 0)
    23dc:	50011006 	andpl	r1, r1, r6
	...

Disassembly of section .debug_aranges:

00000000 <.debug_aranges>:
   0:	0000001c 	andeq	r0, r0, ip, lsl r0
   4:	00000002 	andeq	r0, r0, r2
   8:	00040000 	andeq	r0, r4, r0
   c:	00000000 	andeq	r0, r0, r0
  10:	000003c0 	andeq	r0, r0, r0, asr #7
  14:	00000194 	muleq	r0, r4, r1
	...
  20:	0000001c 	andeq	r0, r0, ip, lsl r0
  24:	06f70002 	ldrbteq	r0, [r7], r2
  28:	00040000 	andeq	r0, r4, r0
  2c:	00000000 	andeq	r0, r0, r0
  30:	00000554 	andeq	r0, r0, r4, asr r5
  34:	00000002 	andeq	r0, r0, r2
	...
  40:	0000001c 	andeq	r0, r0, ip, lsl r0
  44:	07b80002 	ldreq	r0, [r8, r2]!
  48:	00040000 	andeq	r0, r4, r0
  4c:	00000000 	andeq	r0, r0, r0
  50:	00000558 	andeq	r0, r0, r8, asr r5
  54:	00000064 	andeq	r0, r0, r4, rrx
	...
  60:	0000001c 	andeq	r0, r0, ip, lsl r0
  64:	084d0002 	stmdaeq	sp, {r1}^
  68:	00040000 	andeq	r0, r4, r0
  6c:	00000000 	andeq	r0, r0, r0
  70:	000005bc 			@ <UNDEFINED> instruction: 0x000005bc
  74:	00000064 	andeq	r0, r0, r4, rrx
	...
  80:	0000001c 	andeq	r0, r0, ip, lsl r0
  84:	08e20002 	stmiaeq	r2!, {r1}^
  88:	00040000 	andeq	r0, r4, r0
  8c:	00000000 	andeq	r0, r0, r0
  90:	00000620 	andeq	r0, r0, r0, lsr #12
  94:	0000008c 	andeq	r0, r0, ip, lsl #1
	...
  a0:	0000001c 	andeq	r0, r0, ip, lsl r0
  a4:	0a650002 	beq	19400b4 <__ROM_SIZE__+0x19000b4>
  a8:	00040000 	andeq	r0, r4, r0
  ac:	00000000 	andeq	r0, r0, r0
  b0:	000006ac 	andeq	r0, r0, ip, lsr #13
  b4:	000000a4 	andeq	r0, r0, r4, lsr #1
	...
  c0:	0000001c 	andeq	r0, r0, ip, lsl r0
  c4:	0e0e0002 	cdpeq	0, 0, cr0, cr14, cr2, {0}
  c8:	00040000 	andeq	r0, r4, r0
  cc:	00000000 	andeq	r0, r0, r0
  d0:	00000750 	andeq	r0, r0, r0, asr r7
  d4:	000000bc 	strheq	r0, [r0], -ip
	...
  e0:	0000001c 	andeq	r0, r0, ip, lsl r0
  e4:	11c20002 	bicne	r0, r2, r2
  e8:	00040000 	andeq	r0, r4, r0
  ec:	00000000 	andeq	r0, r0, r0
  f0:	0000080c 	andeq	r0, r0, ip, lsl #16
  f4:	000000ac 	andeq	r0, r0, ip, lsr #1
	...
 100:	0000001c 	andeq	r0, r0, ip, lsl r0
 104:	15280002 	strne	r0, [r8, #-2]!
 108:	00040000 	andeq	r0, r4, r0
 10c:	00000000 	andeq	r0, r0, r0
 110:	000008b8 			@ <UNDEFINED> instruction: 0x000008b8
 114:	0000010c 	andeq	r0, r0, ip, lsl #2
	...
 120:	0000001c 	andeq	r0, r0, ip, lsl r0
 124:	1b710002 	blne	1c40134 <__ROM_SIZE__+0x1c00134>
 128:	00040000 	andeq	r0, r4, r0
 12c:	00000000 	andeq	r0, r0, r0
 130:	000009c4 	andeq	r0, r0, r4, asr #19
 134:	0000001c 	andeq	r0, r0, ip, lsl r0
	...
 140:	0000001c 	andeq	r0, r0, ip, lsl r0
 144:	1d000002 	stcne	0, cr0, [r0, #-8]
 148:	00040000 	andeq	r0, r4, r0
 14c:	00000000 	andeq	r0, r0, r0
 150:	000009e0 	andeq	r0, r0, r0, ror #19
 154:	000000a4 	andeq	r0, r0, r4, lsr #1
	...
 160:	0000001c 	andeq	r0, r0, ip, lsl r0
 164:	210a0002 	tstcs	sl, r2
 168:	00040000 	andeq	r0, r4, r0
 16c:	00000000 	andeq	r0, r0, r0
 170:	00000a84 	andeq	r0, r0, r4, lsl #21
 174:	00000680 	andeq	r0, r0, r0, lsl #13
	...
 180:	0000001c 	andeq	r0, r0, ip, lsl r0
 184:	32340002 	eorscc	r0, r4, #2
 188:	00040000 	andeq	r0, r4, r0
 18c:	00000000 	andeq	r0, r0, r0
 190:	00001104 	andeq	r1, r0, r4, lsl #2
 194:	0000025c 	andeq	r0, r0, ip, asr r2
	...
 1a0:	0000001c 	andeq	r0, r0, ip, lsl r0
 1a4:	353d0002 	ldrcc	r0, [sp, #-2]!
 1a8:	00040000 	andeq	r0, r4, r0
 1ac:	00000000 	andeq	r0, r0, r0
 1b0:	00001360 	andeq	r1, r0, r0, ror #6
 1b4:	000002ee 	andeq	r0, r0, lr, ror #5
	...
 1c0:	0000001c 	andeq	r0, r0, ip, lsl r0
 1c4:	38f60002 	ldmcc	r6!, {r1}^
 1c8:	00040000 	andeq	r0, r4, r0
 1cc:	00000000 	andeq	r0, r0, r0
 1d0:	00001650 	andeq	r1, r0, r0, asr r6
 1d4:	00000238 	andeq	r0, r0, r8, lsr r2
	...
 1e0:	0000001c 	andeq	r0, r0, ip, lsl r0
 1e4:	3c250002 	stccc	0, cr0, [r5], #-8
 1e8:	00040000 	andeq	r0, r4, r0
 1ec:	00000000 	andeq	r0, r0, r0
 1f0:	00001888 	andeq	r1, r0, r8, lsl #17
 1f4:	00000238 	andeq	r0, r0, r8, lsr r2
	...
 200:	0000001c 	andeq	r0, r0, ip, lsl r0
 204:	3f540002 	svccc	0x00540002
 208:	00040000 	andeq	r0, r4, r0
 20c:	00000000 	andeq	r0, r0, r0
 210:	00001ac0 	andeq	r1, r0, r0, asr #21
 214:	00000160 	andeq	r0, r0, r0, ror #2
	...
 220:	0000001c 	andeq	r0, r0, ip, lsl r0
 224:	44c00002 	strbmi	r0, [r0], #2
 228:	00040000 	andeq	r0, r4, r0
 22c:	00000000 	andeq	r0, r0, r0
 230:	00001c20 	andeq	r1, r0, r0, lsr #24
 234:	000005fc 	strdeq	r0, [r0], -ip
	...
 240:	0000001c 	andeq	r0, r0, ip, lsl r0
 244:	50f40002 	rscspl	r0, r4, r2
 248:	00040000 	andeq	r0, r4, r0
 24c:	00000000 	andeq	r0, r0, r0
 250:	0000221c 	andeq	r2, r0, ip, lsl r2
 254:	00000580 	andeq	r0, r0, r0, lsl #11
	...
 260:	0000001c 	andeq	r0, r0, ip, lsl r0
 264:	63390002 	teqvs	r9, #2
 268:	00040000 	andeq	r0, r4, r0
 26c:	00000000 	andeq	r0, r0, r0
 270:	0000279c 	muleq	r0, ip, r7
 274:	0000005c 	andeq	r0, r0, ip, asr r0
	...
 280:	0000001c 	andeq	r0, r0, ip, lsl r0
 284:	64840002 	strvs	r0, [r4], #2
 288:	00040000 	andeq	r0, r4, r0
 28c:	00000000 	andeq	r0, r0, r0
 290:	000027f8 	strdeq	r2, [r0], -r8
 294:	000000ac 	andeq	r0, r0, ip, lsr #1
	...
 2a0:	0000001c 	andeq	r0, r0, ip, lsl r0
 2a4:	66ae0002 	strtvs	r0, [lr], r2
 2a8:	00040000 	andeq	r0, r4, r0
 2ac:	00000000 	andeq	r0, r0, r0
 2b0:	000028a4 	andeq	r2, r0, r4, lsr #17
 2b4:	00000060 	andeq	r0, r0, r0, rrx
	...

Disassembly of section .debug_line:

00000000 <.debug_line>:
       0:	00000332 	andeq	r0, r0, r2, lsr r3
       4:	02230003 	eoreq	r0, r3, #3
       8:	01020000 	mrseq	r0, (UNDEF: 2)
       c:	000d0efb 	strdeq	r0, [sp], -fp
      10:	01010101 	tsteq	r1, r1, lsl #2
      14:	01000000 	mrseq	r0, (UNDEF: 0)
      18:	2f010000 	svccs	0x00010000
      1c:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
      20:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
      24:	63652f66 	cmnvs	r5, #408	@ 0x198
      28:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
      2c:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
      30:	662f7265 	strtvs	r7, [pc], -r5, ror #4
      34:	652f626f 	strvs	r6, [pc, #-623]!	@ fffffdcd <_STACK_TOP_+0xdfff7dd1>
      38:	2f667463 	svccs	0x00667463
      3c:	00626f66 	rsbeq	r6, r2, r6, ror #30
      40:	74706f2f 	ldrbtvc	r6, [r0], #-3887	@ 0xfffff0d1
      44:	6363672f 	cmnvs	r3, #12320768	@ 0xbc0000
      48:	6d72612d 	ldfvse	f6, [r2, #-180]!	@ 0xffffff4c
      4c:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
      50:	61652d65 	cmnvs	r5, r5, ror #26
      54:	6c2f6962 			@ <UNDEFINED> instruction: 0x6c2f6962
      58:	672f6269 	strvs	r6, [pc, -r9, ror #4]!
      5c:	612f6363 			@ <UNDEFINED> instruction: 0x612f6363
      60:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
      64:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	@ 0xfffffe44
      68:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
      6c:	2e32312f 	rsfcssp	f3, f2, #10.0
      70:	2f312e32 	svccs	0x00312e32
      74:	6c636e69 	stclvs	14, cr6, [r3], #-420	@ 0xfffffe5c
      78:	00656475 	rsbeq	r6, r5, r5, ror r4
      7c:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ ffffffc8 <_STACK_TOP_+0xdfff7fcc>
      80:	63652f65 	cmnvs	r5, #404	@ 0x194
      84:	652f6674 	strvs	r6, [pc, #-1652]!	@ fffffa18 <_STACK_TOP_+0xdfff7a1c>
      88:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
      8c:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
      90:	2f72656e 	svccs	0x0072656e
      94:	2f626f66 	svccs	0x00626f66
      98:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
      9c:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
      a0:	68732f62 	ldmdavs	r3!, {r1, r5, r6, r8, r9, sl, fp, sp}^
      a4:	36353261 	ldrtcc	r3, [r5], -r1, ror #4
      a8:	6f682f00 	svcvs	0x00682f00
      ac:	652f656d 	strvs	r6, [pc, #-1389]!	@ fffffb47 <_STACK_TOP_+0xdfff7b4b>
      b0:	2f667463 	svccs	0x00667463
      b4:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
      b8:	6172742d 	cmnvs	r2, sp, lsr #8
      bc:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
      c0:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
      c4:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
      c8:	6c2f6c6c 	stcvs	12, cr6, [pc], #-432	@ ffffff20 <_STACK_TOP_+0xdfff7f24>
      cc:	742f6269 	strtvc	r6, [pc], #-617	@ d4 <vector_table+0xd4>
      d0:	2d796e69 	ldclcs	14, cr6, [r9, #-420]!	@ 0xfffffe5c
      d4:	00736561 	rsbseq	r6, r3, r1, ror #10
      d8:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 24 <vector_table+0x24>
      dc:	63652f65 	cmnvs	r5, #404	@ 0x194
      e0:	652f6674 	strvs	r6, [pc, #-1652]!	@ fffffa74 <_STACK_TOP_+0xdfff7a78>
      e4:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
      e8:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
      ec:	2f72656e 	svccs	0x0072656e
      f0:	2f626f66 	svccs	0x00626f66
      f4:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
      f8:	68732f6c 	ldmdavs	r3!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
      fc:	006c6c65 	rsbeq	r6, ip, r5, ror #24
     100:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 4c <vector_table+0x4c>
     104:	63652f65 	cmnvs	r5, #404	@ 0x194
     108:	652f6674 	strvs	r6, [pc, #-1652]!	@ fffffa9c <_STACK_TOP_+0xdfff7aa0>
     10c:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
     110:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
     114:	2f72656e 	svccs	0x0072656e
     118:	2f626f66 	svccs	0x00626f66
     11c:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
     120:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
     124:	69742f62 	ldmdbvs	r4!, {r1, r5, r6, r8, r9, sl, fp, sp}^
     128:	652d796e 	strvs	r7, [sp, #-2414]!	@ 0xfffff692
     12c:	00686463 	rsbeq	r6, r8, r3, ror #8
     130:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 7c <vector_table+0x7c>
     134:	63652f65 	cmnvs	r5, #404	@ 0x194
     138:	652f6674 	strvs	r6, [pc, #-1652]!	@ fffffacc <_STACK_TOP_+0xdfff7ad0>
     13c:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
     140:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
     144:	2f72656e 	svccs	0x0072656e
     148:	2f626f66 	svccs	0x00626f66
     14c:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
     150:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
     154:	61622f62 	cmnvs	r2, r2, ror #30
     158:	34366573 	ldrtcc	r6, [r6], #-1395	@ 0xfffffa8d
     15c:	6f682f00 	svcvs	0x00682f00
     160:	652f656d 	strvs	r6, [pc, #-1389]!	@ fffffbfb <_STACK_TOP_+0xdfff7bff>
     164:	2f667463 	svccs	0x00667463
     168:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
     16c:	6172742d 	cmnvs	r2, sp, lsr #8
     170:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
     174:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
     178:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
     17c:	6c2f6c6c 	stcvs	12, cr6, [pc], #-432	@ ffffffd4 <_STACK_TOP_+0xdfff7fd8>
     180:	732f6269 			@ <UNDEFINED> instruction: 0x732f6269
     184:	6e697274 	mcrvs	2, 3, r7, cr9, cr4, {3}
     188:	682f0067 	stmdavs	pc!, {r0, r1, r2, r5, r6}	@ <UNPREDICTABLE>
     18c:	2f656d6f 	svccs	0x00656d6f
     190:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
     194:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
     198:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
     19c:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
     1a0:	6f662f72 	svcvs	0x00662f72
     1a4:	68732f62 	ldmdavs	r3!, {r1, r5, r6, r8, r9, sl, fp, sp}^
     1a8:	2f6c6c65 	svccs	0x006c6c65
     1ac:	2f62696c 	svccs	0x0062696c
     1b0:	6e697270 	mcrvs	2, 3, r7, cr9, cr0, {3}
     1b4:	00006674 	andeq	r6, r0, r4, ror r6
     1b8:	6773656d 	ldrbvs	r6, [r3, -sp, ror #10]!
     1bc:	0100632e 	tsteq	r0, lr, lsr #6
     1c0:	74730000 	ldrbtvc	r0, [r3], #-0
     1c4:	746e6964 	strbtvc	r6, [lr], #-2404	@ 0xfffff69c
     1c8:	6363672d 	cmnvs	r3, #11796480	@ 0xb40000
     1cc:	0200682e 	andeq	r6, r0, #3014656	@ 0x2e0000
     1d0:	74730000 	ldrbtvc	r0, [r3], #-0
     1d4:	66656464 	strbtvs	r6, [r5], -r4, ror #8
     1d8:	0200682e 	andeq	r6, r0, #3014656	@ 0x2e0000
     1dc:	68730000 	ldmdavs	r3!, {}^	@ <UNPREDICTABLE>
     1e0:	36353261 	ldrtcc	r3, [r5], -r1, ror #4
     1e4:	0300682e 	movweq	r6, #2094	@ 0x82e
     1e8:	65610000 	strbvs	r0, [r1, #-0]!
     1ec:	00682e73 	rsbeq	r2, r8, r3, ror lr
     1f0:	73000004 	movwvc	r0, #4
     1f4:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
     1f8:	0500682e 	streq	r6, [r0, #-2094]	@ 0xfffff7d2
     1fc:	63650000 	cmnvs	r5, #0
     200:	682e6864 	stmdavs	lr!, {r2, r5, r6, fp, sp, lr}
     204:	00000600 	andeq	r0, r0, r0, lsl #12
     208:	65736162 	ldrbvs	r6, [r3, #-354]!	@ 0xfffffe9e
     20c:	682e3436 	stmdavs	lr!, {r1, r2, r4, r5, sl, ip, sp}
     210:	00000700 	andeq	r0, r0, r0, lsl #14
     214:	69727473 	ldmdbvs	r2!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
     218:	682e676e 	stmdavs	lr!, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}
     21c:	00000800 	andeq	r0, r0, r0, lsl #16
     220:	6e697270 	mcrvs	2, 3, r7, cr9, cr0, {3}
     224:	682e6674 	stmdavs	lr!, {r2, r4, r5, r6, r9, sl, sp, lr}
     228:	00000900 	andeq	r0, r0, r0, lsl #18
     22c:	002c0500 	eoreq	r0, ip, r0, lsl #10
     230:	03c00205 	biceq	r0, r0, #1342177280	@ 0x50000000
     234:	3e030000 	cdpcc	0, 0, cr0, cr3, cr0, {0}
     238:	05010601 	streq	r0, [r1, #-1537]	@ 0xfffff9ff
     23c:	05300605 	ldreq	r0, [r0, #-1541]!	@ 0xfffff9fb
     240:	05010608 	streq	r0, [r1, #-1544]	@ 0xfffff9f8
     244:	1003060a 	andne	r0, r3, sl, lsl #12
     248:	0520062e 	streq	r0, [r0, #-1582]!	@ 0xfffff9d2
     24c:	052f0605 	streq	r0, [pc, #-1541]!	@ fffffc4f <_STACK_TOP_+0xdfff7c53>
     250:	3c130601 	ldccc	6, cr0, [r3], {1}
     254:	03060905 	movweq	r0, #26885	@ 0x6905
     258:	0614206f 	ldreq	r2, [r4], -pc, rrx
     25c:	2f06202e 	svccs	0x0006202e
     260:	06051369 	streq	r1, [r5], -r9, ror #6
     264:	0905673d 	stmdbeq	r5, {r0, r2, r3, r4, r5, r8, r9, sl, sp, lr}
     268:	0325055b 			@ <UNDEFINED> instruction: 0x0325055b
     26c:	06f27fb9 			@ <UNDEFINED> instruction: 0x06f27fb9
     270:	06050501 	streq	r0, [r5], -r1, lsl #10
     274:	2006134b 	andcs	r1, r6, fp, asr #6
     278:	0e052f06 	cdpeq	15, 0, cr2, cr5, cr6, {0}
     27c:	05050106 	streq	r0, [r5, #-262]	@ 0xfffffefa
     280:	00090520 	andeq	r0, r9, r0, lsr #10
     284:	06030402 	streq	r0, [r3], -r2, lsl #8
     288:	00220521 	eoreq	r0, r2, r1, lsr #10
     28c:	57030402 	strpl	r0, [r3, -r2, lsl #8]
     290:	02001705 	andeq	r1, r0, #1310720	@ 0x140000
     294:	05200104 	streq	r0, [r0, #-260]!	@ 0xfffffefc
     298:	053f3105 	ldreq	r3, [pc, #-261]!	@ 19b <vector_table+0x19b>
     29c:	05010608 	streq	r0, [r1, #-1544]	@ 0xfffff9f8
     2a0:	27030605 	strcs	r0, [r3, -r5, lsl #12]
     2a4:	0601052e 	streq	r0, [r1], -lr, lsr #10
     2a8:	06090513 			@ <UNDEFINED> instruction: 0x06090513
     2ac:	053c5a03 	ldreq	r5, [ip, #-2563]!	@ 0xfffff5fd
     2b0:	0501060d 	streq	r0, [r1, #-1549]	@ 0xfffff9f3
     2b4:	0d054a0c 	vstreq	s8, [r5, #-48]	@ 0xffffffd0
     2b8:	0e052106 	adfeqs	f2, f5, f6
     2bc:	0612054c 	ldreq	r0, [r2], -ip, asr #10
     2c0:	4a110501 	bmi	4416cc <__ROM_SIZE__+0x4016cc>
     2c4:	21060d05 	tstcs	r6, r5, lsl #26
     2c8:	055a0e05 	ldrbeq	r0, [sl, #-3589]	@ 0xfffff1fb
     2cc:	05010612 	streq	r0, [r1, #-1554]	@ 0xfffff9ee
     2d0:	0d054a11 	vstreq	s8, [r5, #-68]	@ 0xffffffbc
     2d4:	10052106 	andne	r2, r5, r6, lsl #2
     2d8:	11050106 	tstne	r5, r6, lsl #2
     2dc:	2e090306 	cdpcs	3, 0, cr0, cr9, cr6, {0}
     2e0:	134a7803 	movtne	r7, #43011	@ 0xa803
     2e4:	06170513 			@ <UNDEFINED> instruction: 0x06170513
     2e8:	11052001 	tstne	r5, r1
     2ec:	2e069106 	mvfcss	f1, f6
     2f0:	1e052f06 	cdpne	15, 0, cr2, cr5, cr6, {0}
     2f4:	204a0106 	subcs	r0, sl, r6, lsl #2
     2f8:	2f061105 	svccs	0x00061105
     2fc:	055e0e05 	ldrbeq	r0, [lr, #-3589]	@ 0xfffff1fb
     300:	05010612 	streq	r0, [r1, #-1554]	@ 0xfffff9ee
     304:	0d054a11 	vstreq	s8, [r5, #-68]	@ 0xffffffbc
     308:	10052106 	andne	r2, r5, r6, lsl #2
     30c:	11050106 	tstne	r5, r6, lsl #2
     310:	2e090306 	cdpcs	3, 0, cr0, cr9, cr6, {0}
     314:	3d4a7803 	stclcc	8, cr7, [sl, #-12]
     318:	17051313 	smladne	r5, r3, r3, r1
     31c:	05200106 	streq	r0, [r0, #-262]!	@ 0xfffffefa
     320:	05830611 	streq	r0, [r3, #1553]	@ 0x611
     324:	0501061e 	streq	r0, [r1, #-1566]	@ 0xfffff9e2
     328:	06670611 			@ <UNDEFINED> instruction: 0x06670611
     32c:	060d052e 	streq	r0, [sp], -lr, lsr #10
     330:	00230243 	eoreq	r0, r3, r3, asr #4
     334:	00c40101 	sbceq	r0, r4, r1, lsl #2
     338:	00030000 	andeq	r0, r3, r0
     33c:	0000009f 	muleq	r0, pc, r0	@ <UNPREDICTABLE>
     340:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
     344:	0101000d 	tsteq	r1, sp
     348:	00000101 	andeq	r0, r0, r1, lsl #2
     34c:	00000100 	andeq	r0, r0, r0, lsl #2
     350:	6f682f01 	svcvs	0x00682f01
     354:	652f656d 	strvs	r6, [pc, #-1389]!	@ fffffdef <_STACK_TOP_+0xdfff7df3>
     358:	2f667463 	svccs	0x00667463
     35c:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
     360:	6172742d 	cmnvs	r2, sp, lsr #8
     364:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
     368:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
     36c:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
     370:	6f662f66 	svcvs	0x00662f66
     374:	6c702f62 	ldclvs	15, cr2, [r0], #-392	@ 0xfffffe78
     378:	6f667461 	svcvs	0x00667461
     37c:	2f006d72 	svccs	0x00006d72
     380:	2f74706f 	svccs	0x0074706f
     384:	2d636367 	stclcs	3, cr6, [r3, #-412]!	@ 0xfffffe64
     388:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	@ 0xfffffe7c
     38c:	656e6f6e 	strbvs	r6, [lr, #-3950]!	@ 0xfffff092
     390:	6261652d 	rsbvs	r6, r1, #188743680	@ 0xb400000
     394:	696c2f69 	stmdbvs	ip!, {r0, r3, r5, r6, r8, r9, sl, fp, sp}^
     398:	63672f62 	cmnvs	r7, #392	@ 0x188
     39c:	72612f63 	rsbvc	r2, r1, #396	@ 0x18c
     3a0:	6f6e2d6d 	svcvs	0x006e2d6d
     3a4:	652d656e 	strvs	r6, [sp, #-1390]!	@ 0xfffffa92
     3a8:	2f696261 	svccs	0x00696261
     3ac:	322e3231 	eorcc	r3, lr, #268435459	@ 0x10000003
     3b0:	692f312e 	stmdbvs	pc!, {r1, r2, r3, r5, r8, ip, sp}	@ <UNPREDICTABLE>
     3b4:	756c636e 	strbvc	r6, [ip, #-878]!	@ 0xfffffc92
     3b8:	00006564 	andeq	r6, r0, r4, ror #10
     3bc:	74636576 	strbtvc	r6, [r3], #-1398	@ 0xfffffa8a
int finish_ecdhpair(int argc, char** argv) {
     3c0:	745f726f 	ldrbvc	r7, [pc], #-623	@ 3c8 <finish_ecdhpair+0x8>
    if (argc == 4) {
     3c4:	656c6261 	strbvs	r6, [ip, #-609]!	@ 0xfffffd9f
    else printf("Incorrect number of arguments for PAIRECDH2\n");
     3c8:	0100632e 	tsteq	r0, lr, lsr #6
     3cc:	74730000 	ldrbtvc	r0, [r3], #-0
     3d0:	746e6964 	strbtvc	r6, [lr], #-2404	@ 0xfffff69c
     3d4:	6363672d 	cmnvs	r3, #11796480	@ 0xb40000
        decode_base64((uint8_t *)argv[3], 64, carpubkey);
     3d8:	0200682e 	andeq	r6, r0, #3014656	@ 0x2e0000
     3dc:	05000000 	streq	r0, [r0, #-0]
        ecdh_shared_secret(ECDH_privkey, carpubkey, ECDH_shared);
     3e0:	0205001c 	andeq	r0, r5, #28
     3e4:	00000554 	andeq	r0, r0, r4, asr r5
     3e8:	05011603 	streq	r1, [r1, #-1539]	@ 0xfffff9fd
        sha256_init(&shactx);
     3ec:	04020003 	streq	r0, [r2], #-3
     3f0:	09051301 	stmdbeq	r5, {r0, r8, r9, ip}
	    sha256_update(&shactx, ECDH_shared, ECC_PUB_KEY_SIZE);
     3f4:	01040200 	mrseq	r0, R12_usr
     3f8:	00010201 	andeq	r0, r1, r1, lsl #4
     3fc:	00fd0101 	rscseq	r0, sp, r1, lsl #2
	    sha256_final(&shactx, ECDH_AESkey);
     400:	00030000 	andeq	r0, r3, r0
     404:	00000050 	andeq	r0, r0, r0, asr r0
        AES_init_ctx(&ctx, ECDH_AESkey);
     408:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
     40c:	0101000d 	tsteq	r1, sp
     410:	00000101 	andeq	r0, r0, r1, lsl #2
     414:	00000100 	andeq	r0, r0, r0, lsl #2
     418:	6f682f01 	svcvs	0x00682f01
     41c:	652f656d 	strvs	r6, [pc, #-1389]!	@ fffffeb7 <_STACK_TOP_+0xdfff7ebb>
     420:	2f667463 	svccs	0x00667463
     424:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
int car_mesg(int argc, char** argv) {
     428:	6172742d 	cmnvs	r2, sp, lsr #8
     42c:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
    printf("Received a message from the car:");
     430:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
     434:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
    for (ctr = 1; ctr < argc; ctr++) {
     438:	6f662f66 	svcvs	0x00662f66
        printf(" %s", argv[ctr]);
     43c:	6c702f62 	ldclvs	15, cr2, [r0], #-392	@ 0xfffffe78
     440:	6f667461 	svcvs	0x00667461
    for (ctr = 1; ctr < argc; ctr++) {
     444:	752f6d72 	strvc	r6, [pc, #-3442]!	@ fffff6da <_STACK_TOP_+0xdfff76de>
     448:	00747261 	rsbseq	r7, r4, r1, ror #4
    printf("\n");
     44c:	72617500 	rsbvc	r7, r1, #0, 10
    if (argc > 1) {
     450:	00632e74 	rsbeq	r2, r3, r4, ror lr
}
     454:	00000001 	andeq	r0, r0, r1
     458:	05001405 	streq	r1, [r0, #-1029]	@ 0xfffffbfb
        if (strcmp(argv[1], "PING_REPLY") == 0) {
     45c:	00055802 	andeq	r5, r5, r2, lsl #16
     460:	01120300 	tsteq	r2, r0, lsl #6
            printf("Got a ping reply.\n");
     464:	0a050106 	beq	140884 <__ROM_SIZE__+0x100884>
     468:	01040200 	mrseq	r0, R12_usr
        else if (strcmp(argv[1], "PAIRECDH2") == 0) {
     46c:	0b052106 	bleq	14888c <__ROM_SIZE__+0x10888c>
     470:	01040200 	mrseq	r0, R12_usr
     474:	0a050106 	beq	140894 <__ROM_SIZE__+0x100894>
            finish_ecdhpair(argc, argv);
     478:	01040200 	mrseq	r0, R12_usr
     47c:	0603052e 	streq	r0, [r3], -lr, lsr #10
        else if (strcmp(argv[1], "AESB64") == 0) {
     480:	060b053f 			@ <UNDEFINED> instruction: 0x060b053f
     484:	06030501 	streq	r0, [r3], -r1, lsl #10
     488:	0606052f 	streq	r0, [r6], -pc, lsr #10
            if (argc == 3) { 
     48c:	30010501 	andcc	r0, r1, r1, lsl #10
                printf("Missing AESB64 encoded message\n");
     490:	1f060505 	svcne	0x00060505
     494:	01052006 	tsteq	r5, r6
                len = decode_base64((uint8_t *) argv[2], strlen(argv[2]), decoded);
     498:	0611052f 	ldreq	r0, [r1], -pc, lsr #10
     49c:	7c020500 	cfstr32vc	mvfx0, [r2], {-0}
     4a0:	14000005 	strne	r0, [r0], #-5
     4a4:	05130305 	ldreq	r0, [r3, #-773]	@ 0xfffffcfb
     4a8:	0501060a 	streq	r0, [r1, #-1546]	@ 0xfffff9f6
                AES_ECB_decrypt(&ctx, decoded);
     4ac:	1d052e06 	stcne	14, cr2, [r5, #-24]	@ 0xffffffe8
     4b0:	01040200 	mrseq	r0, R12_usr
                decoded[len] = '\0';
     4b4:	24053c06 	strcs	r3, [r5], #-3078	@ 0xfffff3fa
     4b8:	01040200 	mrseq	r0, R12_usr
     4bc:	0a050106 	beq	1408dc <__ROM_SIZE__+0x1008dc>
                printf("Decoded/decrypted as %s\n", decoded);
     4c0:	2f01053e 	svccs	0x0001053e
     4c4:	4c061605 	stcmi	6, cr1, [r6], {5}
     4c8:	05140305 	ldreq	r0, [r4, #-773]	@ 0xfffffcfb
        else if (strcmp(argv[1], "B64") == 0) {
     4cc:	0501060b 	streq	r0, [r1, #-1547]	@ 0xfffff9f5
     4d0:	053f0603 	ldreq	r0, [pc, #-1539]!	@ fffffed5 <_STACK_TOP_+0xdfff7ed9>
            if (argc == 3) { 
     4d4:	0501060c 	streq	r0, [r1, #-1548]	@ 0xfffff9f4
                printf("Missing Base64 encoded message\n");
     4d8:	052f0603 	streq	r0, [pc, #-1539]!	@ fffffedd <_STACK_TOP_+0xdfff7ee1>
     4dc:	0501060c 	streq	r0, [r1, #-1548]	@ 0xfffff9f4
                printf("Decoding Base64\n");
     4e0:	05310603 	ldreq	r0, [r1, #-1539]!	@ 0xfffff9fd
     4e4:	0501060a 	streq	r0, [r1, #-1546]	@ 0xfffff9f6
                len = decode_base64((uint8_t *) argv[2], strlen(argv[2]), decoded);
     4e8:	05310603 	ldreq	r0, [r1, #-1539]!	@ 0xfffff9fd
     4ec:	0501060c 	streq	r0, [r1, #-1548]	@ 0xfffff9f4
     4f0:	05310603 	ldreq	r0, [r1, #-1539]!	@ 0xfffff9fd
     4f4:	0501060b 	streq	r0, [r1, #-1547]	@ 0xfffff9f5
                decoded[len] = '\0';
     4f8:	04023d01 	streq	r3, [r2], #-3329	@ 0xfffff2ff
     4fc:	fe010100 	cdp2	1, 0, cr0, cr1, cr0, {0}
     500:	03000000 	movweq	r0, #0
                printf("Decoded as %s", decoded);
     504:	00005100 	andeq	r5, r0, r0, lsl #2
     508:	fb010200 	blx	40d12 <__ROM_SIZE__+0xd12>
     50c:	01000d0e 	tsteq	r0, lr, lsl #26
            printf("Didn't know how to handle %s\n", argv[1]);
     510:	00010101 	andeq	r0, r1, r1, lsl #2
     514:	00010000 	andeq	r0, r1, r0
     518:	682f0100 	stmdavs	pc!, {r8}	@ <UNPREDICTABLE>
     51c:	2f656d6f 	svccs	0x00656d6f
     520:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
     524:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
     528:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
     52c:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
     530:	6f662f72 	svcvs	0x00662f72
     534:	63652f62 	cmnvs	r5, #392	@ 0x188
     538:	662f6674 			@ <UNDEFINED> instruction: 0x662f6674
     53c:	702f626f 	eorvc	r6, pc, pc, ror #4
     540:	6674616c 	ldrbtvs	r6, [r4], -ip, ror #2
     544:	2f6d726f 	svccs	0x006d726f
     548:	74726175 	ldrbtvc	r6, [r2], #-373	@ 0xfffffe8b
     54c:	61750000 	cmnvs	r5, r0
     550:	2e327472 	mrccs	4, 1, r7, cr2, cr2, {3}
     554:	00010063 	andeq	r0, r1, r3, rrx
void uputc(char c) {
     558:	15050000 	strne	r0, [r5, #-0]
  while ((UARTFR >> 5) & 1)
     55c:	bc020500 	cfstr32lt	mvfx0, [r2], {-0}
     560:	03000005 	movweq	r0, #5
  UART_DR = c;
     564:	01060112 	tsteq	r6, r2, lsl r1
  if (c == '\n')
     568:	02000a05 	andeq	r0, r0, #20480	@ 0x5000
}
     56c:	21060104 	tstcs	r6, r4, lsl #2
    uputc('\r');
     570:	02000b05 	andeq	r0, r0, #5120	@ 0x1400
}
     574:	01060104 	tsteq	r6, r4, lsl #2
     578:	02000a05 	andeq	r0, r0, #20480	@ 0x5000
  if (!((UARTFR >> 4) & 1)) return UART_DR;
     57c:	052e0104 	streq	r0, [lr, #-260]!	@ 0xfffffefc
     580:	053f0603 	ldreq	r0, [pc, #-1539]!	@ ffffff85 <_STACK_TOP_+0xdfff7f89>
     584:	0501060c 	streq	r0, [r1, #-1548]	@ 0xfffff9f4
     588:	052f0603 	streq	r0, [pc, #-1539]!	@ ffffff8d <_STACK_TOP_+0xdfff7f91>
  return -1;
     58c:	05010606 	streq	r0, [r1, #-1542]	@ 0xfffff9fa
}
     590:	05053001 	streq	r3, [r5, #-1]
     594:	20061f06 	andcs	r1, r6, r6, lsl #30
  UARTCTL = 0;
     598:	052f0105 	streq	r0, [pc, #-261]!	@ 49b <car_mesg+0x73>
     59c:	05000612 	streq	r0, [r0, #-1554]	@ 0xfffff9ee
  UARTIBRD = 8;
     5a0:	0005e002 	andeq	lr, r5, r2
  UARTFBRD = 44;
     5a4:	03051400 	movweq	r1, #21504	@ 0x5400
  UARTCC = 0;
     5a8:	060a0513 			@ <UNDEFINED> instruction: 0x060a0513
  UARTLCRH = 0x60;
     5ac:	2e060501 	cfsh32cs	mvfx0, mvfx6, #1
  UARTCTL = 0x301;
     5b0:	02001e05 	andeq	r1, r0, #5, 28	@ 0x50
}
     5b4:	3c060104 	stfccs	f0, [r6], {4}
     5b8:	02002505 	andeq	r2, r0, #20971520	@ 0x1400000
void u2putc(char c) {
     5bc:	01060104 	tsteq	r6, r4, lsl #2
  while ((UART2FR >> 5) & 1)
     5c0:	053e0a05 	ldreq	r0, [lr, #-2565]!	@ 0xfffff5fb
     5c4:	17052f01 	strne	r2, [r5, -r1, lsl #30]
  UART2_DR = c;
     5c8:	03054c06 	movweq	r4, #23558	@ 0x5c06
  if (c == '\n')
     5cc:	060c0514 			@ <UNDEFINED> instruction: 0x060c0514
}
     5d0:	06030501 	streq	r0, [r3], -r1, lsl #10
    u2putc('\r');
     5d4:	060d053f 			@ <UNDEFINED> instruction: 0x060d053f
}
     5d8:	06030501 	streq	r0, [r3], -r1, lsl #10
     5dc:	060d052f 	streq	r0, [sp], -pc, lsr #10
  if (!((UART2FR >> 4) & 1)) return UART2_DR;
     5e0:	06030501 	streq	r0, [r3], -r1, lsl #10
     5e4:	060b0531 			@ <UNDEFINED> instruction: 0x060b0531
     5e8:	06030501 	streq	r0, [r3], -r1, lsl #10
     5ec:	060d0531 			@ <UNDEFINED> instruction: 0x060d0531
  return -1;
     5f0:	06030501 	streq	r0, [r3], -r1, lsl #10
}
     5f4:	060c0531 			@ <UNDEFINED> instruction: 0x060c0531
     5f8:	3d010501 	cfstr32cc	mvfx0, [r1, #-4]
  UART2CTL = 0;
     5fc:	01000402 	tsteq	r0, r2, lsl #8
     600:	00013401 	andeq	r3, r1, r1, lsl #8
  UART2IBRD = 8;
     604:	ca000300 	bgt	120c <encode_base64+0x50>
  UART2FBRD = 44;
     608:	02000000 	andeq	r0, r0, #0
  UART2CC = 0;
     60c:	0d0efb01 	vstreq	d15, [lr, #-4]
  UART2LCRH = 0x60;
     610:	01010100 	mrseq	r0, (UNDEF: 17)
  UART2CTL = 0x301;
     614:	00000001 	andeq	r0, r0, r1
}
     618:	01000001 	tsteq	r0, r1
     61c:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 568 <uputc+0x10>
  RCGCUART |= 3;
     620:	63652f65 	cmnvs	r5, #404	@ 0x194
     624:	652f6674 	strvs	r6, [pc, #-1652]!	@ ffffffb8 <_STACK_TOP_+0xdfff7fbc>
     628:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
     62c:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
  RCGCGPIO |= 3;
     630:	2f72656e 	svccs	0x0072656e
     634:	2f626f66 	svccs	0x00626f66
     638:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
  GPIODEN = 0x03;
     63c:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
     640:	616c702f 	cmnvs	ip, pc, lsr #32
  GPIOAFSEL = 0x03;
     644:	726f6674 	rsbvc	r6, pc, #116, 12	@ 0x7400000
  GPIOPCTL |= 0x00000011;
     648:	682f006d 	stmdavs	pc!, {r0, r2, r3, r5, r6}	@ <UNPREDICTABLE>
     64c:	2f656d6f 	svccs	0x00656d6f
     650:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
  GPIODEN2 = 0x03;
     654:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
     658:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
  GPIOAFSEL2 = 0x03;
     65c:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
  GPIOPCTL2 |= 0x00000011;
     660:	6f662f72 	svcvs	0x00662f72
     664:	63652f62 	cmnvs	r5, #392	@ 0x188
     668:	662f6674 			@ <UNDEFINED> instruction: 0x662f6674
}
     66c:	702f626f 	eorvc	r6, pc, pc, ror #4
     670:	6674616c 	ldrbtvs	r6, [r4], -ip, ror #2
void platform_init() {
     674:	2f6d726f 	svccs	0x006d726f
    pin_setup();
     678:	74726175 	ldrbtvc	r6, [r2], #-373	@ 0xfffffe8b
    uart_init();
     67c:	6f682f00 	svcvs	0x00682f00
    uart2_init();
     680:	652f656d 	strvs	r6, [pc, #-1389]!	@ 11b <vector_table+0x11b>
    set_read_char(ugetc);
     684:	2f667463 	svccs	0x00667463
    set_read_char2(u2getc);
     688:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
     68c:	6172742d 	cmnvs	r2, sp, lsr #8
    set_write_char(uputc);
     690:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
    set_write_char2(u2putc);
     694:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
     698:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
}
     69c:	732f6c6c 			@ <UNDEFINED> instruction: 0x732f6c6c
     6a0:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
     6a4:	6c700000 	ldclvs	0, cr0, [r0], #-0
     6a8:	6f667461 	svcvs	0x00667461
int aes_test(int argc, char** argv) {
     6ac:	632e6d72 			@ <UNDEFINED> instruction: 0x632e6d72
    uint8_t text[17] = "0123456789abcdef";
     6b0:	00000100 	andeq	r0, r0, r0, lsl #2
     6b4:	74726175 	ldrbtvc	r6, [r2], #-373	@ 0xfffffe8b
     6b8:	00682e32 	rsbeq	r2, r8, r2, lsr lr
     6bc:	73000002 	movwvc	r0, #2
     6c0:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
    printf("Plaintext is %s\n", text);
     6c4:	0300682e 	movweq	r6, #2094	@ 0x82e
     6c8:	61750000 	cmnvs	r5, r0
    AES_ECB_encrypt(&ctx, text);
     6cc:	682e7472 	stmdavs	lr!, {r1, r4, r5, r6, sl, ip, sp, lr}
     6d0:	00000200 	andeq	r0, r0, r0, lsl #4
    len = encode_base64(text, 16, b64text);
     6d4:	00120500 	andseq	r0, r2, r0, lsl #10
     6d8:	06200205 	strteq	r0, [r0], -r5, lsl #4
     6dc:	21030000 	mrscs	r0, (UNDEF: 3)
    b64text[len] = '\0';
     6e0:	15030501 	strne	r0, [r3, #-1281]	@ 0xfffffaff
     6e4:	3c060c05 	stccc	12, cr0, [r6], {5}
     6e8:	4c060305 	stcmi	3, cr0, [r6], {5}
    printf("Encrypted/encoded is %s\n", b64text);
     6ec:	2e060c05 	cdpcs	12, 0, cr0, cr6, cr5, {0}
     6f0:	4d060305 	stcmi	3, cr0, [r6, #-20]	@ 0xffffffec
    printf2("FOB_MESG AESB64 %s\n", b64text);
     6f4:	01060b05 	tsteq	r6, r5, lsl #22
     6f8:	59060305 	stmdbpl	r6, {r0, r2, r8, r9}
    printf("Test the mesg handler with CAR_MESG AESB64 %s\n", b64text);
     6fc:	01060d05 	tsteq	r6, r5, lsl #26
     700:	2f060305 	svccs	0x00060305
    len = decode_base64(b64text, len, decoded);
     704:	2e060c05 	cdpcs	12, 0, cr0, cr6, cr5, {0}
     708:	4d060305 	stcmi	3, cr0, [r6, #-20]	@ 0xffffffec
     70c:	01060c05 	tsteq	r6, r5, lsl #24
    AES_ECB_decrypt(&ctx, decoded);
     710:	4b060305 	blmi	18132c <__ROM_SIZE__+0x14132c>
     714:	01060e05 	tsteq	r6, r5, lsl #28
    decoded[len] = '\0';
     718:	2f060305 	svccs	0x00060305
     71c:	2e060d05 	cdpcs	13, 0, cr0, cr6, cr5, {0}
     720:	054b0105 	strbeq	r0, [fp, #-261]	@ 0xfffffefb
    printf("After encrypting->encoding->decoding->decrypting we recover %s\n", decoded);
     724:	05500616 	ldrbeq	r0, [r0, #-1558]	@ 0xfffff9ea
     728:	2f2f2105 	svccs	0x002f2105
}
     72c:	3d3d3d2f 	ldccc	13, cr3, [sp, #-188]!	@ 0xffffff44
     730:	3d060105 	stfccs	f0, [r6, #-20]	@ 0xffffffec
     734:	01000902 	tsteq	r0, r2, lsl #18
     738:	0001c901 	andeq	ip, r1, r1, lsl #18
     73c:	6f000300 	svcvs	0x00000300
     740:	02000001 	andeq	r0, r0, #1
     744:	0d0efb01 	vstreq	d15, [lr, #-4]
     748:	01010100 	mrseq	r0, (UNDEF: 17)
     74c:	00000001 	andeq	r0, r0, r1
int pair1(int argc, char** argv) {
     750:	01000001 	tsteq	r0, r1
    printf("Sending a pair request.\n");
     754:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 6a0 <platform_init+0x2c>
    printf2("FOB_MESG PAIR %d %d\n", fob_ID, pairing_PIN);
     758:	63652f65 	cmnvs	r5, #404	@ 0x194
     75c:	652f6674 	strvs	r6, [pc, #-1652]!	@ f0 <vector_table+0xf0>
     760:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
     764:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
}
     768:	2f72656e 	svccs	0x0072656e
     76c:	2f626f66 	svccs	0x00626f66
     770:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
     774:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
     778:	6f682f00 	svcvs	0x00682f00
int pairchall(int argc, char** argv) {
     77c:	652f656d 	strvs	r6, [pc, #-1389]!	@ 217 <vector_table+0x217>
    printf("Sending a pair request with challenge/response.\n");
     780:	2f667463 	svccs	0x00667463
    printf2("FOB_MESG PAIRCR %d %d\n", fob_ID, pairing_PIN);
     784:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
     788:	6172742d 	cmnvs	r2, sp, lsr #8
     78c:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
     790:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
}
     794:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
     798:	6c2f6c6c 	stcvs	12, cr6, [pc], #-432	@ 5f0 <u2getc+0x10>
     79c:	742f6269 	strtvc	r6, [pc], #-617	@ 7a4 <pairchall+0x28>
     7a0:	2d796e69 	ldclcs	14, cr6, [r9, #-420]!	@ 0xfffffe5c
     7a4:	00736561 	rsbseq	r6, r3, r1, ror #10
int pairecdh(int argc, char** argv) {
     7a8:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 6f4 <aes_test+0x48>
    printf("Starting EC Diffie-Hellman key exchange.\n");
     7ac:	63652f65 	cmnvs	r5, #404	@ 0x194
     7b0:	652f6674 	strvs	r6, [pc, #-1652]!	@ 144 <vector_table+0x144>
    decode_base64(ECDH_privkey_b64, 32, ECDH_privkey);
     7b4:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
     7b8:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
     7bc:	2f72656e 	svccs	0x0072656e
    ecdh_generate_keys(ECDH_pubkey, ECDH_privkey);
     7c0:	2f626f66 	svccs	0x00626f66
     7c4:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
    encode_base64(ECDH_pubkey, ECC_PUB_KEY_SIZE, pubkey_b64);
     7c8:	68732f6c 	ldmdavs	r3!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
     7cc:	006c6c65 	rsbeq	r6, ip, r5, ror #24
     7d0:	74706f2f 	ldrbtvc	r6, [r0], #-3887	@ 0xfffff0d1
    pubkey_b64[64] = '\0';
     7d4:	6363672f 	cmnvs	r3, #12320768	@ 0xbc0000
    printf2("FOB_MESG PAIRECDH %d %d %s\n", fob_ID, pairing_PIN, pubkey_b64);
     7d8:	6d72612d 	ldfvse	f6, [r2, #-180]!	@ 0xffffff4c
     7dc:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
     7e0:	61652d65 	cmnvs	r5, r5, ror #26
     7e4:	6c2f6962 			@ <UNDEFINED> instruction: 0x6c2f6962
}
     7e8:	672f6269 	strvs	r6, [pc, -r9, ror #4]!
     7ec:	612f6363 			@ <UNDEFINED> instruction: 0x612f6363
     7f0:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
     7f4:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	@ 0xfffffe44
     7f8:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
     7fc:	2e32312f 	rsfcssp	f3, f2, #10.0
     800:	2f312e32 	svccs	0x00312e32
     804:	6c636e69 	stclvs	14, cr6, [r3], #-420	@ 0xfffffe5c
     808:	00656475 	rsbeq	r6, r5, r5, ror r4
int encode64(int argc, char** argv) {
     80c:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 758 <pair1+0x8>
    if (argc > 1) {
     810:	63652f65 	cmnvs	r5, #404	@ 0x194
     814:	652f6674 	strvs	r6, [pc, #-1652]!	@ 1a8 <vector_table+0x1a8>
        len = strlen(argv[1]);
     818:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
     81c:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
        if (len < MAXARRAYLEN) {
     820:	2f72656e 	svccs	0x0072656e
            len = encode_base64((uint8_t *) argv[1], len, encoded);
     824:	2f626f66 	svccs	0x00626f66
     828:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
            printf("Encoded %s as %s with %d characters\n", argv[1], encoded, len);
     82c:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
     830:	61622f62 	cmnvs	r2, r2, ror #30
     834:	34366573 	ldrtcc	r6, [r6], #-1395	@ 0xfffffa8d
            printf("String exceeds max length of %d characters", MAXARRAYLEN);
     838:	6f682f00 	svcvs	0x00682f00
     83c:	652f656d 	strvs	r6, [pc, #-1389]!	@ 2d7 <vector_table+0x2d7>
     840:	2f667463 	svccs	0x00667463
        printf("Usage is 'encode64 string'\n");
     844:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
}
     848:	6172742d 	cmnvs	r2, sp, lsr #8
     84c:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
     850:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
     854:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
     858:	6c2f6c6c 	stcvs	12, cr6, [pc], #-432	@ 6b0 <aes_test+0x4>
int decode64(int argc, char** argv) {
     85c:	702f6269 	eorvc	r6, pc, r9, ror #4
    if (argc > 1) {
     860:	746e6972 	strbtvc	r6, [lr], #-2418	@ 0xfffff68e
     864:	61000066 	tstvs	r0, r6, rrx
        int len = strlen(argv[1]);
     868:	745f7365 	ldrbvc	r7, [pc], #-869	@ 870 <decode64+0x14>
     86c:	2e747365 	cdpcs	3, 7, cr7, cr4, cr5, {3}
        if (len < MAXBASE64LEN) {
     870:	00010063 	andeq	r0, r1, r3, rrx
                len = decode_base64((uint8_t *) argv[1], len, plaintext);
     874:	73656100 	cmnvc	r5, #0, 2
     878:	0200682e 	andeq	r6, r0, #3014656	@ 0x2e0000
                plaintext[len] = '\0';
     87c:	68730000 	ldmdavs	r3!, {}^	@ <UNPREDICTABLE>
     880:	2e6c6c65 	cdpcs	12, 6, cr6, cr12, cr5, {3}
     884:	00030068 	andeq	r0, r3, r8, rrx
                printf("Decoded %s as: %s\n", argv[1], plaintext);
     888:	64747300 	ldrbtvs	r7, [r4], #-768	@ 0xfffffd00
     88c:	2d746e69 	ldclcs	14, cr6, [r4, #-420]!	@ 0xfffffe5c
     890:	2e636367 	cdpcs	3, 6, cr6, cr3, cr7, {3}
            printf("String exceeds max base64 string length of %d characters", MAXBASE64LEN);
     894:	00040068 	andeq	r0, r4, r8, rrx
     898:	73616200 	cmnvc	r1, #0, 4
     89c:	2e343665 	cfmsuba32cs	mvax3, mvax3, mvfx4, mvfx5
        printf("Usage is 'decode64 string'\n");
     8a0:	00050068 	andeq	r0, r5, r8, rrx
}
     8a4:	69727000 	ldmdbvs	r2!, {ip, sp, lr}^
     8a8:	2e66746e 	cdpcs	4, 6, cr7, cr6, cr14, {3}
     8ac:	00060068 	andeq	r0, r6, r8, rrx
     8b0:	25050000 	strcs	r0, [r5, #-0]
     8b4:	ac020500 	cfstr32ge	mvfx0, [r2], {-0}
int ecdh_test(int argc, char** argv) {
     8b8:	18000006 	stmdane	r0, {r1, r2}
    uint8_t b64privkey2[32] = "wP/uwP/uwP/uwP/uwP/uwP/uwP/uwP/u";
     8bc:	05050106 	streq	r0, [r5, #-262]	@ 0xfffffefa
     8c0:	0d053006 	stceq	0, cr3, [r5, #-24]	@ 0xffffffe8
     8c4:	054a0106 	strbeq	r0, [sl, #-262]	@ 0xfffffefa
     8c8:	13590605 	cmpne	r9, #5242880	@ 0x500000
     8cc:	135b4b14 	cmpne	fp, #20, 22	@ 0x5000
    printf("Testing the ecdh key exchange\n");
     8d0:	01060b05 	tsteq	r6, r5, lsl #22
     8d4:	67060505 	strvs	r0, [r6, -r5, lsl #10]
    decode_base64(ECDH_privkey_b64, 32, ECDH_privkey);
     8d8:	01061205 	tsteq	r6, r5, lsl #4
     8dc:	67060505 	strvs	r0, [r6, -r5, lsl #10]
     8e0:	2f062e06 	svccs	0x00062e06
    decode_base64(b64privkey2, 32, privkey2);
     8e4:	05134c4b 	ldreq	r4, [r3, #-3147]	@ 0xfffff3b5
     8e8:	0501060b 	streq	r0, [r1, #-1547]	@ 0xfffff9f5
    ecdh_generate_keys(ECDH_pubkey, ECDH_privkey);
     8ec:	06670605 	strbteq	r0, [r7], -r5, lsl #12
     8f0:	052f062e 	streq	r0, [pc, #-1582]!	@ 2ca <vector_table+0x2ca>
     8f4:	4a010612 	bmi	42144 <__ROM_SIZE__+0x2144>
    ecdh_generate_keys(pubkey2, privkey2);
     8f8:	30060505 	andcc	r0, r6, r5, lsl #10
     8fc:	0601054b 	streq	r0, [r1], -fp, asr #10
    ecdh_shared_secret(ECDH_privkey, pubkey2, ECDH_shared);
     900:	00120213 	andseq	r0, r2, r3, lsl r2
     904:	01d10101 	bicseq	r0, r1, r1, lsl #2
     908:	00030000 	andeq	r0, r3, r0
    ecdh_shared_secret(privkey2, ECDH_pubkey, sharedsecret2);
     90c:	0000016d 	andeq	r0, r0, sp, ror #2
     910:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
    sha256_init(&shactx);
     914:	0101000d 	tsteq	r1, sp
     918:	00000101 	andeq	r0, r0, r1, lsl #2
	sha256_update(&shactx, ECDH_shared, ECC_PUB_KEY_SIZE);
     91c:	00000100 	andeq	r0, r0, r0, lsl #2
     920:	6f682f01 	svcvs	0x00682f01
	sha256_final(&shactx, ECDH_AESkey);
     924:	652f656d 	strvs	r6, [pc, #-1389]!	@ 3bf <vector_table+0x3bf>
     928:	2f667463 	svccs	0x00667463
     92c:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    len = encode_base64(ECDH_AESkey, AES_KEYLEN, b64test);
     930:	6172742d 	cmnvs	r2, sp, lsr #8
     934:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
    b64test[len] = '\0';
     938:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
     93c:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
     940:	6f662f66 	svcvs	0x00662f66
     944:	682f0062 	stmdavs	pc!, {r1, r5, r6}	@ <UNPREDICTABLE>
    printf("First shared key is %s\n", b64test);
     948:	2f656d6f 	svccs	0x00656d6f
     94c:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    sha256_init(&shactx);
     950:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
    sha256_update(&shactx, sharedsecret2, ECC_PUB_KEY_SIZE);
     954:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
     958:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
     95c:	6f662f72 	svcvs	0x00662f72
	sha256_final(&shactx, keytest);
     960:	68732f62 	ldmdavs	r3!, {r1, r5, r6, r8, r9, sl, fp, sp}^
     964:	2f6c6c65 	svccs	0x006c6c65
    len = encode_base64(keytest, AES_KEYLEN, b64test);
     968:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
     96c:	6f2f006c 	svcvs	0x002f006c
    b64test[len] = '\0';
     970:	672f7470 			@ <UNDEFINED> instruction: 0x672f7470
     974:	612d6363 			@ <UNDEFINED> instruction: 0x612d6363
     978:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
    printf("Should be same as %s\n", b64test);
     97c:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	@ 0xfffffe44
     980:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
    printf("Switching fob AES key to new value. Try AES tests now.\n");
     984:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
     988:	6363672f 	cmnvs	r3, #12320768	@ 0xbc0000
    AES_init_ctx(&ctx, ECDH_AESkey);
     98c:	6d72612f 	ldfvse	f6, [r2, #-188]!	@ 0xffffff44
     990:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
}
     994:	61652d65 	cmnvs	r5, r5, ror #26
     998:	312f6962 			@ <UNDEFINED> instruction: 0x312f6962
     99c:	2e322e32 	mrccs	14, 1, r2, cr2, cr2, {1}
     9a0:	6e692f31 	mcrvs	15, 3, r2, cr9, cr1, {1}
     9a4:	64756c63 	ldrbtvs	r6, [r5], #-3171	@ 0xfffff39d
     9a8:	682f0065 	stmdavs	pc!, {r0, r2, r5, r6}	@ <UNPREDICTABLE>
     9ac:	2f656d6f 	svccs	0x00656d6f
     9b0:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
     9b4:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
     9b8:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
     9bc:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
     9c0:	6f662f72 	svcvs	0x00662f72
int send_ping(int argc, char** argv) {
     9c4:	68732f62 	ldmdavs	r3!, {r1, r5, r6, r8, r9, sl, fp, sp}^
    printf("Pinging the car.\n");
     9c8:	2f6c6c65 	svccs	0x006c6c65
    printf2("FOB_MESG PING\n");
     9cc:	2f62696c 	svccs	0x0062696c
     9d0:	65736162 	ldrbvs	r6, [r3, #-354]!	@ 0xfffffe9e
}
     9d4:	2f003436 	svccs	0x00003436
     9d8:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
     9dc:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
int sha256_test(int argc, char** argv) {
     9e0:	63652f66 	cmnvs	r5, #408	@ 0x198
    printf("Starting sha256 test\n");
     9e4:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
     9e8:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
    BYTE text1[] = {"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"};
     9ec:	662f7265 	strtvs	r7, [pc], -r5, ror #4
     9f0:	732f626f 			@ <UNDEFINED> instruction: 0x732f626f
     9f4:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
     9f8:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
     9fc:	6e69742f 	cdpvs	4, 6, cr7, cr9, cr15, {1}
     a00:	63652d79 	cmnvs	r5, #7744	@ 0x1e40
     a04:	2f006864 	svccs	0x00006864
     a08:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
     a0c:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
    BYTE hash1[SHA256_BLOCK_SIZE] = {0x24,0x8d,0x6a,0x61,0xd2,0x06,0x38,0xb8,0xe5,0xc0,0x26,0x93,0x0c,0x3e,0x60,0x39,
     a10:	63652f66 	cmnvs	r5, #408	@ 0x198
     a14:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
     a18:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
     a1c:	662f7265 	strtvs	r7, [pc], -r5, ror #4
    sha256_init(&shactx);
     a20:	732f626f 			@ <UNDEFINED> instruction: 0x732f626f
	sha256_update(&shactx, text1, strlen((char *)text1));
     a24:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
     a28:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
     a2c:	6972702f 	ldmdbvs	r2!, {r0, r1, r2, r3, r5, ip, sp, lr}^
     a30:	0066746e 	rsbeq	r7, r6, lr, ror #8
	sha256_final(&shactx, buf);
     a34:	69617000 	stmdbvs	r1!, {ip, sp, lr}^
     a38:	00632e72 	rsbeq	r2, r3, r2, ror lr
    len = encode_base64(hash1, SHA256_BLOCK_SIZE, b64_hash1);
     a3c:	73000001 	movwvc	r0, #1
     a40:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
     a44:	0200682e 	andeq	r6, r0, #3014656	@ 0x2e0000
    b64_hash1[len] = '\0';
     a48:	74730000 	ldrbtvc	r0, [r3], #-0
    len = encode_base64(buf, SHA256_BLOCK_SIZE, b64_buf);
     a4c:	746e6964 	strbtvc	r6, [lr], #-2404	@ 0xfffff69c
     a50:	6363672d 	cmnvs	r3, #11796480	@ 0xb40000
     a54:	0300682e 	movweq	r6, #2094	@ 0x82e
    b64_buf[len] = '\0';
     a58:	61620000 	cmnvs	r2, r0
    printf("Base64 of SHA-256 test is %s\n", b64_buf);
     a5c:	34366573 	ldrtcc	r6, [r6], #-1395	@ 0xfffffa8d
     a60:	0400682e 	streq	r6, [r0], #-2094	@ 0xfffff7d2
    printf("Should be %s\n", b64_hash1);
     a64:	63650000 	cmnvs	r5, #0
     a68:	682e6864 	stmdavs	lr!, {r2, r5, r6, fp, sp, lr}
}
     a6c:	00000500 	andeq	r0, r0, r0, lsl #10
     a70:	6e697270 	mcrvs	2, 3, r7, cr9, cr0, {3}
     a74:	682e6674 	stmdavs	lr!, {r2, r4, r5, r6, r9, sl, sp, lr}
     a78:	00000600 	andeq	r0, r0, r0, lsl #12
     a7c:	00220500 	eoreq	r0, r2, r0, lsl #10
     a80:	07500205 	ldrbeq	r0, [r0, -r5, lsl #4]
void __attribute__((optimize("O0"), weak)) initial_setup(void) {
     a84:	06150000 	ldreq	r0, [r5], -r0
     a88:	06050501 	streq	r0, [r5], -r1, lsl #10
  char *src = &_etext, *dst = &_data;
     a8c:	06200621 	strteq	r0, [r0], -r1, lsr #12
     a90:	0105752f 	tsteq	r5, pc, lsr #10
  if (dst != src)
     a94:	26051306 	strcs	r1, [r5], -r6, lsl #6
     a98:	02050006 	andeq	r0, r5, #6
    while (dst < &_edata) *(dst++) = *(src++);
     a9c:	0000077c 	andeq	r0, r0, ip, ror r7
     aa0:	05010614 	streq	r0, [r1, #-1556]	@ 0xfffff9ec
     aa4:	06220605 	strteq	r0, [r2], -r5, lsl #12
     aa8:	762f0620 	strtvc	r0, [pc], -r0, lsr #12
     aac:	13060105 	movwne	r0, #24837	@ 0x6105
     ab0:	00062505 	andeq	r2, r6, r5, lsl #10
  for (dst = &_bss; dst < &_ebss; dst++) *dst = 0;
     ab4:	07a80205 	streq	r0, [r8, r5, lsl #4]!
     ab8:	06140000 	ldreq	r0, [r4], -r0
     abc:	06050501 	streq	r0, [r5], -r1, lsl #10
     ac0:	20061430 	andcs	r1, r6, r0, lsr r4
     ac4:	59673006 	stmdbpl	r7!, {r1, r2, ip, sp}^
     ac8:	06140559 			@ <UNDEFINED> instruction: 0x06140559
     acc:	06050501 	streq	r0, [r5], -r1, lsl #10
  platform_init();
     ad0:	0105833d 	tsteq	r5, sp, lsr r3
}
     ad4:	12021306 	andne	r1, r2, #402653184	@ 0x18000000
     ad8:	24010100 	strcs	r0, [r1], #-256	@ 0xffffff00
     adc:	03000002 	movweq	r0, #2
     ae0:	00017a00 	andeq	r7, r1, r0, lsl #20
     ae4:	fb010200 	blx	412ee <__ROM_SIZE__+0x12ee>
     ae8:	01000d0e 	tsteq	r0, lr, lsl #26
     aec:	00010101 	andeq	r0, r1, r1, lsl #2
static void delete(void) {
     af0:	00010000 	andeq	r0, r1, r0
  __write_char__(BACK_SPACE);
     af4:	682f0100 	stmdavs	pc!, {r8}	@ <UNPREDICTABLE>
     af8:	2f656d6f 	svccs	0x00656d6f
  __write_char__(SPACE);
     afc:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
  __write_char__(BACK_SPACE);
     b00:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
     b04:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
}
     b08:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
static void clear_prompt(int char_count) {
     b0c:	6f662f72 	svcvs	0x00662f72
  while (char_count) {
     b10:	63652f62 	cmnvs	r5, #392	@ 0x188
    delete ();
     b14:	662f6674 			@ <UNDEFINED> instruction: 0x662f6674
  while (char_count) {
     b18:	2f00626f 	svccs	0x0000626f
}
     b1c:	2f74706f 	svccs	0x0074706f
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
     b20:	2d636367 	stclcs	3, cr6, [r3, #-412]!	@ 0xfffffe64
    auto_load[i].command(0, NULL);
     b24:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	@ 0xfffffe7c
     b28:	656e6f6e 	strbvs	r6, [lr, #-3950]!	@ 0xfffff092
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
     b2c:	6261652d 	rsbvs	r6, r1, #188743680	@ 0xb400000
     b30:	696c2f69 	stmdbvs	ip!, {r0, r3, r5, r6, r8, r9, sl, fp, sp}^
     b34:	63672f62 	cmnvs	r7, #392	@ 0x188
     b38:	72612f63 	rsbvc	r2, r1, #396	@ 0x18c
     b3c:	6f6e2d6d 	svcvs	0x006e2d6d
}
     b40:	652d656e 	strvs	r6, [sp, #-1390]!	@ 0xfffffa92
static int show_history(int argc, char **argv) {
     b44:	2f696261 	svccs	0x00696261
  uint32_t end_index = total_num_commands-1;
     b48:	322e3231 	eorcc	r3, lr, #268435459	@ 0x10000003
  if (total_num_commands > NUM_HISTORY_ENTRIES) {
     b4c:	692f312e 	stmdbvs	pc!, {r1, r2, r3, r5, r8, ip, sp}	@ <UNPREDICTABLE>
     b50:	756c636e 	strbvc	r6, [ip, #-878]!	@ 0xfffffc92
    beg_index = total_num_commands - NUM_HISTORY_ENTRIES;
     b54:	2f006564 	svccs	0x00006564
     b58:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
  uint32_t beg_index = 0;
     b5c:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
    printf("%s\n", cmd_history[index % NUM_HISTORY_ENTRIES]);
     b60:	63652f66 	cmnvs	r5, #408	@ 0x198
     b64:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
     b68:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
     b6c:	662f7265 	strtvs	r7, [pc], -r5, ror #4
  for (uint32_t index = beg_index; index <= end_index; ++index) {
     b70:	732f626f 			@ <UNDEFINED> instruction: 0x732f626f
}
     b74:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
     b78:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
     b7c:	2f006c6c 	svccs	0x00006c6c
     b80:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
int cmd_exec_status(int argc, char **argv) {
     b84:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
  printf("%d\n", __cmd_exec_status);
     b88:	63652f66 	cmnvs	r5, #408	@ 0x198
     b8c:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
     b90:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
}
     b94:	662f7265 	strtvs	r7, [pc], -r5, ror #4
     b98:	732f626f 			@ <UNDEFINED> instruction: 0x732f626f
     b9c:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
static int build_info(int argc, char **argv) {
     ba0:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
  printf("Build: [" SHELL_VERSION ":" USER_REPO_VERSION "] - [" BUILD_USER
     ba4:	7361622f 	cmnvc	r1, #-268435454	@ 0xf0000002
}
     ba8:	00343665 	eorseq	r3, r4, r5, ror #12
     bac:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ af8 <delete+0x8>
static void execute(int argc, char **argv) {
     bb0:	63652f65 	cmnvs	r5, #404	@ 0x194
     bb4:	652f6674 	strvs	r6, [pc, #-1652]!	@ 548 <car_mesg+0x120>
  for (int i = 0; table[i].command_name != NULL; i++) {
     bb8:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
     bbc:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
     bc0:	2f72656e 	svccs	0x0072656e
     bc4:	2f626f66 	svccs	0x00626f66
     bc8:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
    if (strcmp(argv[0], table[i].command_name) == 0) {
     bcc:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
     bd0:	72702f62 	rsbsvc	r2, r0, #392	@ 0x188
      __cmd_exec_status = table[i].command(argc, &argv[0]);
     bd4:	66746e69 	ldrbtvs	r6, [r4], -r9, ror #28
     bd8:	6f682f00 	svcvs	0x00682f00
     bdc:	652f656d 	strvs	r6, [pc, #-1389]!	@ 677 <platform_init+0x3>
     be0:	2f667463 	svccs	0x00667463
     be4:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    printf("\"%s\": command not found. Use \"help\" to list all command.\n",
     be8:	6172742d 	cmnvs	r2, sp, lsr #8
     bec:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
    __cmd_exec_status = -1;
     bf0:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
     bf4:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
     bf8:	6c2f6c6c 	stcvs	12, cr6, [pc], #-432	@ a50 <sha256_test+0x70>
}
     bfc:	732f6269 			@ <UNDEFINED> instruction: 0x732f6269
     c00:	6e697274 	mcrvs	2, 3, r7, cr9, cr4, {3}
     c04:	62000067 	andvs	r0, r0, #103	@ 0x67
     c08:	36657361 	strbtcc	r7, [r5], -r1, ror #6
int help(int argc, char **argv) {
     c0c:	00632e34 	rsbeq	r2, r3, r4, lsr lr
  if (argc > 1 && (strcmp(argv[1], "-l")==0)) {
     c10:	73000001 	movwvc	r0, #1
     c14:	6e696474 	mcrvs	4, 3, r6, cr9, cr4, {3}
     c18:	63672d74 	cmnvs	r7, #116, 26	@ 0x1d00
     c1c:	00682e63 	rsbeq	r2, r8, r3, ror #28
    printf("use: help -l for list only.\n\n");
     c20:	73000002 	movwvc	r0, #2
  bool verbose = true;
     c24:	65646474 	strbvs	r6, [r4, #-1140]!	@ 0xfffffb8c
    verbose = false;
     c28:	00682e66 	rsbeq	r2, r8, r6, ror #28
    printf("\n");
     c2c:	73000002 	movwvc	r0, #2
    i++;
     c30:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
  while (table[i].command_name != NULL) {
     c34:	0300682e 	movweq	r6, #2094	@ 0x82e
     c38:	61620000 	cmnvs	r2, r0
     c3c:	34366573 	ldrtcc	r6, [r6], #-1395	@ 0xfffffa8d
    printf(table[i].command_name);
     c40:	0400682e 	streq	r6, [r0], #-2094	@ 0xfffff7d2
    if (verbose) {
     c44:	72700000 	rsbsvc	r0, r0, #0
      printf("\n\t");
     c48:	66746e69 	ldrbtvs	r6, [r4], -r9, ror #28
      printf(table[i].command_help);
     c4c:	0500682e 	streq	r6, [r0, #-2094]	@ 0xfffff7d2
     c50:	74730000 	ldrbtvc	r0, [r3], #-0
     c54:	676e6972 			@ <UNDEFINED> instruction: 0x676e6972
    verbose = false;
     c58:	0600682e 	streq	r6, [r0], -lr, lsr #16
}
     c5c:	05000000 	streq	r0, [r0, #-0]
     c60:	02050025 	andeq	r0, r5, #37	@ 0x25
     c64:	0000080c 	andeq	r0, r0, ip, lsl #16
     c68:	0501061a 	streq	r0, [r1, #-1562]	@ 0xfffff9e6
     c6c:	05300605 	ldreq	r0, [r0, #-1541]!	@ 0xfffff9fb
     c70:	05010608 	streq	r0, [r1, #-1544]	@ 0xfffff9f8
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
     c74:	133e0609 	teqne	lr, #9437184	@ 0x900000
static void add_command_to_history(const char *cmd_str) {
     c78:	060f0514 			@ <UNDEFINED> instruction: 0x060f0514
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
     c7c:	052e2001 	streq	r2, [lr, #-1]!
     c80:	05210609 	streq	r0, [r1, #-1545]!	@ 0xfffff9f7
  int index = total_num_commands % NUM_HISTORY_ENTRIES;
     c84:	0501060c 	streq	r0, [r1, #-1548]	@ 0xfffff9f4
     c88:	052f060d 	streq	r0, [pc, #-1549]!	@ 683 <platform_init+0xf>
     c8c:	2e010613 	mcrcs	6, 0, r0, cr1, cr3, {0}
     c90:	060d052e 	streq	r0, [sp], -lr, lsr #10
  memcpy(&cmd_history[index], cmd_str, LINE_BUFF_SIZE);
     c94:	2e3c0621 	cfmsuba32cs	mvax1, mvax0, mvfx12, mvfx1
     c98:	2e062306 	cdpcs	3, 0, cr2, cr6, cr6, {0}
     c9c:	0609053c 			@ <UNDEFINED> instruction: 0x0609053c
     ca0:	05200616 	streq	r0, [r0, #-1558]!	@ 0xfffff9ea
  total_num_commands++;
     ca4:	05310605 	ldreq	r0, [r1, #-1541]!	@ 0xfffff9fb
  curr_command_ptr = total_num_commands;
     ca8:	05130601 	ldreq	r0, [r3, #-1537]	@ 0xfffff9ff
     cac:	05000625 	streq	r0, [r0, #-1573]	@ 0xfffff9db
     cb0:	00085c02 	andeq	r5, r8, r2, lsl #24
     cb4:	01061400 	tsteq	r6, r0, lsl #8
     cb8:	30060505 	andcc	r0, r6, r5, lsl #10
static int parse_line(char **argv, char *line_buff, int argument_size) {
     cbc:	01060805 	tsteq	r6, r5, lsl #16
     cc0:	3e060905 	vmlacc.f16	s0, s12, s10	@ <UNPREDICTABLE>
  int length = strlen(line_buff);
     cc4:	01061305 	tsteq	r6, r5, lsl #6
     cc8:	09052e20 	stmdbeq	r5, {r5, r9, sl, fp, sp}
  int argc = 0;
     ccc:	0c052206 	sfmeq	f2, 4, [r5], {6}
         pos++)
     cd0:	11050106 	tstne	r5, r6, lsl #2
    for (; line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
     cd4:	05133006 	ldreq	r3, [r3, #-6]
     cd8:	2e010617 	mcrcs	6, 0, r0, cr1, cr7, {0}
     cdc:	2f061105 	svccs	0x00061105
     ce0:	01062005 	tsteq	r6, r5
    if (line_buff[pos] == '\t' || line_buff[pos] == SPACE)
     ce4:	1105204a 	tstne	r5, sl, asr #32
     ce8:	0d052f06 	stceq	15, cr2, [r5, #-24]	@ 0xffffffe8
      line_buff[pos] = END_OF_LINE;
     cec:	3c2e0669 	stccc	6, cr0, [lr], #-420	@ 0xfffffe5c
  while (pos <= length) {
     cf0:	16060905 	strne	r0, [r6], -r5, lsl #18
    if (line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
     cf4:	05052006 	streq	r2, [r5, #-6]
     cf8:	01053106 	tsteq	r5, r6, lsl #2
     cfc:	0a021306 	beq	8591c <__ROM_SIZE__+0x4591c>
     d00:	5b010100 	blpl	41108 <__ROM_SIZE__+0x1108>
      argv[argc++] = &line_buff[pos];
     d04:	03000002 	movweq	r0, #2
     d08:	0001ef00 	andeq	lr, r1, r0, lsl #30
}
     d0c:	fb010200 	blx	41516 <__ROM_SIZE__+0x1516>
static int prefix_match(char *sub, int len, const char *str) {
     d10:	01000d0e 	tsteq	r0, lr, lsl #26
     d14:	00010101 	andeq	r0, r1, r1, lsl #2
  if (sub == NULL || str == NULL || len <= 0 || len > strlen(str)) {
     d18:	00010000 	andeq	r0, r1, r0
     d1c:	682f0100 	stmdavs	pc!, {r8}	@ <UNPREDICTABLE>
     d20:	2f656d6f 	svccs	0x00656d6f
     d24:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
  for (int i = 0; i<len; ++i) {
     d28:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
     d2c:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
    if (sub[i] != str[i]) {
     d30:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
     d34:	6f662f72 	svcvs	0x00662f72
  for (int i = 0; i<len; ++i) {
     d38:	63652f62 	cmnvs	r5, #392	@ 0x188
}
     d3c:	662f6674 			@ <UNDEFINED> instruction: 0x662f6674
  return TRUE;
     d40:	2f00626f 	svccs	0x0000626f
      return FALSE;
     d44:	2f74706f 	svccs	0x0074706f
}
     d48:	2d636367 	stclcs	3, cr6, [r3, #-412]!	@ 0xfffffe64
static void handle_up_arrow(char *cmd_buff, int *char_count) {
     d4c:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	@ 0xfffffe7c
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
     d50:	656e6f6e 	strbvs	r6, [lr, #-3950]!	@ 0xfffff092
     d54:	6261652d 	rsbvs	r6, r1, #188743680	@ 0xb400000
     d58:	696c2f69 	stmdbvs	ip!, {r0, r3, r5, r6, r8, r9, sl, fp, sp}^
     d5c:	63672f62 	cmnvs	r7, #392	@ 0x188
      curr_command_ptr == 0) {
     d60:	72612f63 	rsbvc	r2, r1, #396	@ 0x18c
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
     d64:	6f6e2d6d 	svcvs	0x006e2d6d
    printf("%s", cmd_buff);
     d68:	652d656e 	strvs	r6, [sp, #-1390]!	@ 0xfffffa92
     d6c:	2f696261 	svccs	0x00696261
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
     d70:	322e3231 	eorcc	r3, lr, #268435459	@ 0x10000003
     d74:	692f312e 	stmdbvs	pc!, {r1, r2, r3, r5, r8, ip, sp}	@ <UNPREDICTABLE>
  curr_command_ptr--;
     d78:	756c636e 	strbvc	r6, [ip, #-878]!	@ 0xfffffc92
     d7c:	2f006564 	svccs	0x00006564
     d80:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
     d84:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
     d88:	63652f66 	cmnvs	r5, #408	@ 0x198
     d8c:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
     d90:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
     d94:	662f7265 	strtvs	r7, [pc], -r5, ror #4
     d98:	732f626f 			@ <UNDEFINED> instruction: 0x732f626f
     d9c:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
  *char_count = strlen(cmd_buff);
     da0:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
     da4:	6168732f 	cmnvs	r8, pc, lsr #6
  printf("%s", cmd_buff);
     da8:	00363532 	eorseq	r3, r6, r2, lsr r5
     dac:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ cf8 <parse_line+0x3c>
     db0:	63652f65 	cmnvs	r5, #404	@ 0x194
     db4:	652f6674 	strvs	r6, [pc, #-1652]!	@ 748 <aes_test+0x9c>
     db8:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
static void handle_down_arrow(char *cmd_buff, int *char_count) {
     dbc:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
     dc0:	2f72656e 	svccs	0x0072656e
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
     dc4:	2f626f66 	svccs	0x00626f66
     dc8:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
  *char_count = 0;
     dcc:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
  if (curr_command_ptr == total_num_commands) return;
     dd0:	69742f62 	ldmdbvs	r4!, {r1, r5, r6, r8, r9, sl, fp, sp}^
     dd4:	612d796e 			@ <UNDEFINED> instruction: 0x612d796e
     dd8:	2f007365 	svccs	0x00007365
  curr_command_ptr++;
     ddc:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
     de0:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
     de4:	63652f66 	cmnvs	r5, #408	@ 0x198
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
     de8:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
     dec:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
     df0:	662f7265 	strtvs	r7, [pc], -r5, ror #4
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
     df4:	732f626f 			@ <UNDEFINED> instruction: 0x732f626f
     df8:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
     dfc:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
     e00:	2f006c6c 	svccs	0x00006c6c
  *char_count = strlen(cmd_buff);
     e04:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
     e08:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
  printf("%s", cmd_buff);
     e0c:	63652f66 	cmnvs	r5, #408	@ 0x198
     e10:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
}
     e14:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
     e18:	662f7265 	strtvs	r7, [pc], -r5, ror #4
void set_read_char(int (*func)(void)) { __read_char__ = func; }
     e1c:	732f626f 			@ <UNDEFINED> instruction: 0x732f626f
     e20:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
     e24:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
void set_read_char2(int (*func)(void)) { __read_char2__ = func; }
     e28:	7361622f 	cmnvc	r1, #-268435454	@ 0xf0000002
     e2c:	00343665 	eorseq	r3, r4, r5, ror #12
     e30:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ d7c <handle_up_arrow+0x32>
void set_write_char(void (*func)(char)) { __write_char__ = func; }
     e34:	63652f65 	cmnvs	r5, #404	@ 0x194
     e38:	652f6674 	strvs	r6, [pc, #-1652]!	@ 7cc <pairecdh+0x24>
     e3c:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
void set_write_char2(void (*func)(char)) { __write_char2__ = func; }
     e40:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
     e44:	2f72656e 	svccs	0x0072656e
     e48:	2f626f66 	svccs	0x00626f66
}
     e4c:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
}
     e50:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
  if (cmd_buff == NULL || char_count <= 0) {
     e54:	69742f62 	ldmdbvs	r4!, {r1, r5, r6, r8, r9, sl, fp, sp}^
static void handle_tab(char *cmd_buff, int *char_count) {
     e58:	652d796e 	strvs	r7, [sp, #-2414]!	@ 0xfffff692
     e5c:	00686463 	rsbeq	r6, r8, r3, ror #8
  int last_match = -1;
     e60:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ dac <handle_up_arrow+0x62>
  int match_count = 0;
     e64:	63652f65 	cmnvs	r5, #404	@ 0x194
  int i = 0;
     e68:	652f6674 	strvs	r6, [pc, #-1652]!	@ 7fc <pairecdh+0x54>
    i++;
     e6c:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
  while (table[i].command_name != NULL) { //loop over all commands
     e70:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
     e74:	2f72656e 	svccs	0x0072656e
     e78:	2f626f66 	svccs	0x00626f66
    if (prefix_match(cmd_buff, *char_count, table[i].command_name)) {
     e7c:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
     e80:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
     e84:	72702f62 	rsbsvc	r2, r0, #392	@ 0x188
      match_count++;
     e88:	66746e69 	ldrbtvs	r6, [r4], -r9, ror #28
      printf("\n%s", table[i].command_name);
     e8c:	63650000 	cmnvs	r5, #0
     e90:	745f6864 	ldrbvc	r6, [pc], #-2148	@ e98 <handle_tab+0x46>
      last_match = i;
     e94:	2e747365 	cdpcs	3, 7, cr7, cr4, cr5, {3}
  if (match_count == 1) {
     e98:	00010063 	andeq	r0, r1, r3, rrx
     e9c:	64747300 	ldrbtvs	r7, [r4], #-768	@ 0xfffffd00
  if (match_count) {
     ea0:	2d746e69 	ldclcs	14, cr6, [r4, #-420]!	@ 0xfffffe5c
}
     ea4:	2e636367 	cdpcs	3, 6, cr6, cr3, cr7, {3}
    memcpy(cmd_buff, table[last_match].command_name, LINE_BUFF_SIZE);
     ea8:	00020068 	andeq	r0, r2, r8, rrx
     eac:	64747300 	ldrbtvs	r7, [r4], #-768	@ 0xfffffd00
     eb0:	2e666564 	cdpcs	5, 6, cr6, cr6, cr4, {3}
     eb4:	00020068 	andeq	r0, r2, r8, rrx
    *char_count = strlen(cmd_buff);
     eb8:	61687300 	cmnvs	r8, r0, lsl #6
     ebc:	2e363532 	mrccs	5, 1, r3, cr6, cr2, {1}
     ec0:	00030068 	andeq	r0, r3, r8, rrx
    printf("\n");
     ec4:	73656100 	cmnvc	r5, #0, 2
     ec8:	0400682e 	streq	r6, [r0], #-2094	@ 0xfffff7d2
    prepend_prompt();
     ecc:	68730000 	ldmdavs	r3!, {}^	@ <UNPREDICTABLE>
    printf(PROMPT);
     ed0:	2e6c6c65 	cdpcs	12, 6, cr6, cr12, cr5, {3}
     ed4:	00050068 	andeq	r0, r5, r8, rrx
    printf("%s", cmd_buff);
     ed8:	73616200 	cmnvc	r1, #0, 4
     edc:	2e343665 	cfmsuba32cs	mvax3, mvax3, mvfx4, mvfx5
     ee0:	00060068 	andeq	r0, r6, r8, rrx
     ee4:	64636500 	strbtvs	r6, [r3], #-1280	@ 0xfffffb00
     ee8:	00682e68 	rsbeq	r2, r8, r8, ror #28
     eec:	70000007 	andvc	r0, r0, r7
     ef0:	746e6972 	strbtvc	r6, [lr], #-2418	@ 0xfffff68e
__attribute__((weak)) int active_prompt() { return TRUE; }
     ef4:	00682e66 	rsbeq	r2, r8, r6, ror #28
static void shell(void) {
     ef8:	00000008 	andeq	r0, r0, r8
  int count = 0;
     efc:	05002605 	streq	r2, [r0, #-1541]	@ 0xfffff9fb
  for (int i = 0; i < LINE_BUFF_SIZE; i++) line_buff[i] = 0;
     f00:	0008b802 	andeq	fp, r8, r2, lsl #16
     f04:	010b0300 	mrseq	r0, (UNDEF: 59)
     f08:	05050106 	streq	r0, [r5, #-262]	@ 0xfffffefa
     f0c:	0d053006 	stceq	0, cr3, [r5, #-24]	@ 0xffffffe8
     f10:	054a0106 	strbeq	r0, [sl, #-262]	@ 0xfffffefa
  for (int i = 0; i < MAX_ARG_COUNT; i++) argv[i] = NULL;
     f14:	13670605 	cmnne	r7, #5242880	@ 0x500000
     f18:	13131313 	tstne	r3, #1275068416	@ 0x4c000000
     f1c:	5a673e14 	bpl	19d0774 <__ROM_SIZE__+0x1990774>
     f20:	5a674c59 	bpl	19d408c <__ROM_SIZE__+0x199408c>
     f24:	3d020513 	cfstr32cc	mvfx0, [r2, #-76]	@ 0xffffffb4
  prepend_prompt();
     f28:	5a050559 	bpl	142494 <__ROM_SIZE__+0x102494>
  printf(PROMPT);
     f2c:	01060b05 	tsteq	r6, r5, lsl #22
  int special_key = 0;
     f30:	59060505 	stmdbpl	r6, {r0, r2, r8, sl}
        special_key = 1;
     f34:	01061205 	tsteq	r6, r5, lsl #4
    if (s == -1) { s = __read_char2__();}
     f38:	0605054a 	streq	r0, [r5], -sl, asr #10
     f3c:	053d4c3e 	ldreq	r4, [sp, #-3134]!	@ 0xfffff3c2
    if (s != -1) {
     f40:	05055902 	streq	r5, [r5, #-2306]	@ 0xfffff6fe
     f44:	060b054c 	streq	r0, [fp], -ip, asr #10
      loop();
     f48:	06050501 	streq	r0, [r5], -r1, lsl #10
        line_buff[count] = END_OF_LINE;
     f4c:	06120559 			@ <UNDEFINED> instruction: 0x06120559
     f50:	05054a01 	streq	r4, [r5, #-2561]	@ 0xfffff5ff
     f54:	3e4c2f06 	cdpcc	15, 4, cr2, cr12, cr6, {0}
     f58:	0601054c 	streq	r0, [r1], -ip, asr #10
        __write_char__(NEW_LINE);
     f5c:	00190213 	andseq	r0, r9, r3, lsl r2
     f60:	00d20101 	sbcseq	r0, r2, r1, lsl #2
  add_command_to_history(line_buff);
     f64:	00030000 	andeq	r0, r3, r0
  argc = parse_line(argv, line_buff, MAX_ARG_COUNT);
     f68:	000000ae 	andeq	r0, r0, lr, lsr #1
     f6c:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
     f70:	0101000d 	tsteq	r1, sp
  if (argc > 0) execute(argc, argv);
     f74:	00000101 	andeq	r0, r0, r1, lsl #2
}
     f78:	00000100 	andeq	r0, r0, r0, lsl #2
        if (!__echo) {
     f7c:	6f682f01 	svcvs	0x00682f01
     f80:	652f656d 	strvs	r6, [pc, #-1389]!	@ a1b <sha256_test+0x3b>
        if (count == 0) continue;
     f84:	2f667463 	svccs	0x00667463
        count--;
     f88:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
        line_buff[count] = END_OF_LINE;
     f8c:	6172742d 	cmnvs	r2, sp, lsr #8
     f90:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
     f94:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
        delete ();
     f98:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
      if (__echo) {
     f9c:	6f662f66 	svcvs	0x00662f66
        __write_char__(c);
     fa0:	682f0062 	stmdavs	pc!, {r1, r5, r6}	@ <UNPREDICTABLE>
     fa4:	2f656d6f 	svccs	0x00656d6f
    if (!active_prompt()) {
     fa8:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
     fac:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
    s = __read_char__();
     fb0:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
     fb4:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
    if (s == -1) { s = __read_char2__();}
     fb8:	6f662f72 	svcvs	0x00662f72
     fbc:	68732f62 	ldmdavs	r3!, {r1, r5, r6, r8, r9, sl, fp, sp}^
      if (c == CARRIAGE_RETURN || c == NEW_LINE) {
     fc0:	2f6c6c65 	svccs	0x006c6c65
     fc4:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
      if (c == DELETE || c == BACK_SPACE) {
     fc8:	682f006c 	stmdavs	pc!, {r2, r3, r5, r6}	@ <UNPREDICTABLE>
     fcc:	2f656d6f 	svccs	0x00656d6f
      } else if (c == ESCAPE) {
     fd0:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
      } else if (c == SQUARE_BRACKET_OPEN && special_key == 1) {
     fd4:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
      } else if ((c == 'C' || c == 'D') && special_key != 0) {
     fd8:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
     fdc:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
     fe0:	6f662f72 	svcvs	0x00662f72
      } else if ((c == 'A' || c == 'B') && special_key == 2) {
     fe4:	68732f62 	ldmdavs	r3!, {r1, r5, r6, r8, r9, sl, fp, sp}^
     fe8:	2f6c6c65 	svccs	0x006c6c65
      else if (c == TAB) {
     fec:	2f62696c 	svccs	0x0062696c
        line_buff[count] = c;
     ff0:	6e697270 	mcrvs	2, 3, r7, cr9, cr0, {3}
     ff4:	00006674 	andeq	r6, r0, r4, ror r6
     ff8:	676e6970 			@ <UNDEFINED> instruction: 0x676e6970
        count++;
     ffc:	0100632e 	tsteq	r0, lr, lsr #6
    1000:	68730000 	ldmdavs	r3!, {}^	@ <UNPREDICTABLE>
          delete ();
    1004:	2e6c6c65 	cdpcs	12, 6, cr6, cr12, cr5, {3}
          delete ();
    1008:	00020068 	andeq	r0, r2, r8, rrx
      } else if (c == SQUARE_BRACKET_OPEN && special_key == 1) {
    100c:	69727000 	ldmdbvs	r2!, {ip, sp, lr}^
        special_key = 2;
    1010:	2e66746e 	cdpcs	4, 6, cr7, cr6, cr14, {3}
      } else if ((c == 'C' || c == 'D') && special_key != 0) {
    1014:	00030068 	andeq	r0, r3, r8, rrx
        special_key = 0;
    1018:	26050000 	strcs	r0, [r5], -r0
      } else if ((c == 'A' || c == 'B') && special_key == 2) {
    101c:	c4020500 	strgt	r0, [r2], #-1280	@ 0xfffffb00
        if (!__echo) {
    1020:	16000009 	strne	r0, [r0], -r9
    1024:	05050106 	streq	r0, [r5, #-262]	@ 0xfffffefa
          clear_prompt(count + 4);
    1028:	20062106 	andcs	r2, r6, r6, lsl #2
    102c:	053d2f06 	ldreq	r2, [sp, #-3846]!	@ 0xfffff0fa
        if (c == 'A') {
    1030:	02130601 	andseq	r0, r3, #1048576	@ 0x100000
          handle_down_arrow(line_buff, &count);
    1034:	01010007 	tsteq	r1, r7
    1038:	0000021e 	andeq	r0, r0, lr, lsl r2
        continue;
    103c:	01b80003 			@ <UNDEFINED> instruction: 0x01b80003
          clear_prompt(count);
    1040:	01020000 	mrseq	r0, (UNDEF: 2)
    1044:	000d0efb 	strdeq	r0, [sp], -fp
          handle_up_arrow(line_buff, &count);
    1048:	01010101 	tsteq	r1, r1, lsl #2
    104c:	01000000 	mrseq	r0, (UNDEF: 0)
        handle_tab(line_buff, &count);
    1050:	2f010000 	svccs	0x00010000
    1054:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
        continue;
    1058:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
  if (argc > 0) execute(argc, argv);
    105c:	63652f66 	cmnvs	r5, #408	@ 0x198
}
    1060:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
    1064:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
    1068:	662f7265 	strtvs	r7, [pc], -r5, ror #4
    106c:	652f626f 	strvs	r6, [pc, #-623]!	@ e05 <handle_down_arrow+0x49>
void prompt() {
    1070:	2f667463 	svccs	0x00667463
  initial_setup();
    1074:	00626f66 	rsbeq	r6, r2, r6, ror #30
  exec_auto_cmds();
    1078:	74706f2f 	ldrbtvc	r6, [r0], #-3887	@ 0xfffff0d1
  setup();
    107c:	6363672f 	cmnvs	r3, #12320768	@ 0xbc0000
  decode_base64(AES_key_b64, 44, AES_key);
    1080:	6d72612d 	ldfvse	f6, [r2, #-180]!	@ 0xffffff4c
    1084:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
    1088:	61652d65 	cmnvs	r5, r5, ror #26
    108c:	6c2f6962 			@ <UNDEFINED> instruction: 0x6c2f6962
  AES_init_ctx(&ctx, AES_key);
    1090:	672f6269 	strvs	r6, [pc, -r9, ror #4]!
    1094:	612f6363 			@ <UNDEFINED> instruction: 0x612f6363
    shell();
    1098:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
  while (TRUE) {
    109c:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	@ 0xfffffe44
    10a0:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
    10a4:	2e32312f 	rsfcssp	f3, f2, #10.0
int exec(char *cmd_str) {
    10a8:	2f312e32 	svccs	0x00312e32
    10ac:	6c636e69 	stclvs	14, cr6, [r3], #-420	@ 0xfffffe5c
  argc = parse_line(argv, cmd_str, MAX_ARG_COUNT);
    10b0:	00656475 	rsbeq	r6, r5, r5, ror r4
    10b4:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 1000 <shell+0x108>
  if (argc > 0) execute(argc, argv);
    10b8:	63652f65 	cmnvs	r5, #404	@ 0x194
  return __cmd_exec_status;
    10bc:	652f6674 	strvs	r6, [pc, #-1652]!	@ a50 <sha256_test+0x70>
}
    10c0:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
    10c4:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
  if (argc > 0) execute(argc, argv);
    10c8:	2f72656e 	svccs	0x0072656e
    10cc:	2f626f66 	svccs	0x00626f66
    10d0:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
cmd get_function_addr(char *cmd_str) {
    10d4:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
  for (int i = 0; table[i].command_name != NULL; i++) {
    10d8:	68732f62 	ldmdavs	r3!, {r1, r5, r6, r8, r9, sl, fp, sp}^
    10dc:	36353261 	ldrtcc	r3, [r5], -r1, ror #4
    10e0:	6f682f00 	svcvs	0x00682f00
    10e4:	652f656d 	strvs	r6, [pc, #-1389]!	@ b7f <show_history+0x3b>
    10e8:	2f667463 	svccs	0x00667463
    if (strcmp(cmd_str, table[i].command_name) == 0) {
    10ec:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    10f0:	6172742d 	cmnvs	r2, sp, lsr #8
      return table[i].command;
    10f4:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
    10f8:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
  return NULL;
    10fc:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
}
    1100:	732f6c6c 			@ <UNDEFINED> instruction: 0x732f6c6c
  if(v < 26) return v + 'A';
    1104:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
  if(v < 52) return v + 71;
    1108:	6f682f00 	svcvs	0x00682f00
  if(v < 62) return v - 4;
    110c:	652f656d 	strvs	r6, [pc, #-1389]!	@ ba7 <build_info+0x7>
  if(v == 62) return '+';
    1110:	2f667463 	svccs	0x00667463
  if(v == 63) return '/';
    1114:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
  return 64;
    1118:	6172742d 	cmnvs	r2, sp, lsr #8
  if(v < 26) return v + 'A';
    111c:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
    1120:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
  if(v < 52) return v + 71;
    1124:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
  if(v < 62) return v - 4;
    1128:	6c2f6c6c 	stcvs	12, cr6, [pc], #-432	@ f80 <shell+0x88>
    112c:	622f6269 	eorvs	r6, pc, #-1879048186	@ 0x90000006
  if(v == 62) return '+';
    1130:	36657361 	strbtcc	r7, [r5], -r1, ror #6
}
    1134:	682f0034 	stmdavs	pc!, {r2, r4, r5}	@ <UNPREDICTABLE>
  if('A' <= c && c <= 'Z') return c - 'A';
    1138:	2f656d6f 	svccs	0x00656d6f
    113c:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
  if('a' <= c && c <= 'z') return c - 71;
    1140:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
    1144:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
    1148:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
  if('0' <= c && c <= '9') return c + 4;
    114c:	6f662f72 	svcvs	0x00662f72
    1150:	68732f62 	ldmdavs	r3!, {r1, r5, r6, r8, r9, sl, fp, sp}^
  if(c == '+') return 62;
    1154:	2f6c6c65 	svccs	0x006c6c65
  if(c == '/') return 63;
    1158:	2f62696c 	svccs	0x0062696c
  return 255;
    115c:	69727473 	ldmdbvs	r2!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
  if('a' <= c && c <= 'z') return c - 71;
    1160:	2f00676e 	svccs	0x0000676e
    1164:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
  if('0' <= c && c <= '9') return c + 4;
    1168:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
  if(c == '+') return 62;
    116c:	63652f66 	cmnvs	r5, #408	@ 0x198
  if(c == '/') return 63;
    1170:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
  return (input_length + 2)/3*4;
    1174:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
    1178:	662f7265 	strtvs	r7, [pc], -r5, ror #4
    117c:	732f626f 			@ <UNDEFINED> instruction: 0x732f626f
}
    1180:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
    1184:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
unsigned int decode_base64_length(unsigned char input[], unsigned int input_length) {
    1188:	6972702f 	ldmdbvs	r2!, {r0, r1, r2, r3, r5, ip, sp, lr}^
    118c:	0066746e 	rsbeq	r7, r6, lr, ror #8
  while(base64_to_binary(input[0]) < 64 && (unsigned int) (input - start) < input_length) {
    1190:	61687300 	cmnvs	r8, r0, lsl #6
    1194:	5f363532 	svcpl	0x00363532
    1198:	74736574 	ldrbtvc	r6, [r3], #-1396	@ 0xfffffa8c
    119c:	0100632e 	tsteq	r0, lr, lsr #6
    11a0:	74730000 	ldrbtvc	r0, [r3], #-0
  input_length = input - start;
    11a4:	746e6964 	strbtvc	r6, [lr], #-2404	@ 0xfffff69c
  return input_length/4*3 + (input_length % 4 ? input_length % 4 - 1 : 0);
    11a8:	6363672d 	cmnvs	r3, #11796480	@ 0xb40000
    11ac:	0200682e 	andeq	r6, r0, #3014656	@ 0x2e0000
    11b0:	74730000 	ldrbtvc	r0, [r3], #-0
}
    11b4:	66656464 	strbtvs	r6, [r5], -r4, ror #8
  return input_length/4*3 + (input_length % 4 ? input_length % 4 - 1 : 0);
    11b8:	0200682e 	andeq	r6, r0, #3014656	@ 0x2e0000
unsigned int encode_base64(unsigned char input[], unsigned int input_length, unsigned char output[]) {
    11bc:	68730000 	ldmdavs	r3!, {}^	@ <UNPREDICTABLE>
    11c0:	36353261 	ldrtcc	r3, [r5], -r1, ror #4
    11c4:	0300682e 	movweq	r6, #2094	@ 0x82e
  unsigned int full_sets = input_length/3;
    11c8:	68730000 	ldmdavs	r3!, {}^	@ <UNPREDICTABLE>
    11cc:	2e6c6c65 	cdpcs	12, 6, cr6, cr12, cr5, {3}
  for(unsigned int i = 0; i < full_sets; ++i) {
    11d0:	00040068 	andeq	r0, r4, r8, rrx
    output[0] = binary_to_base64(                         input[0] >> 2);
    11d4:	73616200 	cmnvc	r1, #0, 4
    11d8:	2e343665 	cfmsuba32cs	mvax3, mvax3, mvfx4, mvfx5
    output[1] = binary_to_base64((input[0] & 0x03) << 4 | input[1] >> 4);
    11dc:	00050068 	andeq	r0, r5, r8, rrx
    11e0:	72747300 	rsbsvc	r7, r4, #0, 6
    11e4:	2e676e69 	cdpcs	14, 6, cr6, cr7, cr9, {3}
    11e8:	00060068 	andeq	r0, r6, r8, rrx
    11ec:	69727000 	ldmdbvs	r2!, {ip, sp, lr}^
    output[2] = binary_to_base64((input[1] & 0x0F) << 2 | input[2] >> 6);
    11f0:	2e66746e 	cdpcs	4, 6, cr7, cr6, cr14, {3}
    11f4:	00070068 	andeq	r0, r7, r8, rrx
    11f8:	28050000 	stmdacs	r5, {}	@ <UNPREDICTABLE>
    11fc:	e0020500 	and	r0, r2, r0, lsl #10
    1200:	15000009 	strne	r0, [r0, #-9]
    output[3] = binary_to_base64( input[2] & 0x3F);
    1204:	05050106 	streq	r0, [r5, #-262]	@ 0xfffffefa
    1208:	20062f06 	andcs	r2, r6, r6, lsl #30
    120c:	05133006 	ldreq	r3, [r3, #-6]
    input += 3;
    1210:	0501060a 	streq	r0, [r1, #-1546]	@ 0xfffff9f6
  for(unsigned int i = 0; i < full_sets; ++i) {
    1214:	21080605 	tstcs	r8, r5, lsl #12
    1218:	01060a05 	tsteq	r6, r5, lsl #20
  switch(input_length % 3) {
    121c:	84060505 	strhi	r0, [r6], #-1285	@ 0xfffffafb
    1220:	14131314 	ldrne	r1, [r3], #-788	@ 0xfffffcec
    1224:	833d0205 	teqhi	sp, #1342177280	@ 0x50000000
    1228:	054c0505 	strbeq	r0, [ip, #-1285]	@ 0xfffffafb
    122c:	0501060b 	streq	r0, [r1, #-1547]	@ 0xfffff9f5
    1230:	05670605 	strbeq	r0, [r7, #-1541]!	@ 0xfffff9fb
    1234:	05010614 	streq	r0, [r1, #-1556]	@ 0xfffff9ec
  return encode_base64_length(input_length);
    1238:	05300605 	ldreq	r0, [r0, #-1541]!	@ 0xfffff9fb
}
    123c:	4a01060b 	bmi	42a70 <__ROM_SIZE__+0x2a70>
      output[0] = '\0';
    1240:	2f060505 	svccs	0x00060505
      output[0] = binary_to_base64(                         input[0] >> 2);
    1244:	01061205 	tsteq	r6, r5, lsl #4
    1248:	22060505 	andcs	r0, r6, #20971520	@ 0x1400000
    124c:	2f062e06 	svccs	0x00062e06
      output[1] = binary_to_base64((input[0] & 0x03) << 4);
    1250:	0601054c 	streq	r0, [r1], -ip, asr #10
    1254:	000d0213 	andeq	r0, sp, r3, lsl r2
    1258:	09e50101 	stmibeq	r5!, {r0, r8}^
      output[2] = '=';
    125c:	00030000 	andeq	r0, r3, r0
      output[3] = '=';
    1260:	0000018c 	andeq	r0, r0, ip, lsl #3
      output[4] = '\0';
    1264:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
      output[0] = binary_to_base64(                         input[0] >> 2);
    1268:	0101000d 	tsteq	r1, sp
    126c:	00000101 	andeq	r0, r0, r1, lsl #2
    1270:	00000100 	andeq	r0, r0, r0, lsl #2
      output[1] = binary_to_base64((input[0] & 0x03) << 4 | input[1] >> 4);
    1274:	6f682f01 	svcvs	0x00682f01
    1278:	652f656d 	strvs	r6, [pc, #-1389]!	@ d13 <prefix_match+0x5>
    127c:	2f667463 	svccs	0x00667463
    1280:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    1284:	6172742d 	cmnvs	r2, sp, lsr #8
      output[2] = binary_to_base64((input[1] & 0x0F) << 2);
    1288:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
    128c:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
    1290:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
      output[3] = '=';
    1294:	732f6c6c 			@ <UNDEFINED> instruction: 0x732f6c6c
      output[4] = '\0';
    1298:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
      break;
    129c:	706f2f00 	rsbvc	r2, pc, r0, lsl #30
    12a0:	63672f74 	cmnvs	r7, #116, 30	@ 0x1d0
unsigned int decode_base64(unsigned char input[], unsigned int input_length, unsigned char output[]) {
    12a4:	72612d63 	rsbvc	r2, r1, #6336	@ 0x18c0
    12a8:	6f6e2d6d 	svcvs	0x006e2d6d
  unsigned int output_length = decode_base64_length(input, input_length);
    12ac:	652d656e 	strvs	r6, [sp, #-1390]!	@ 0xfffffa92
    12b0:	2f696261 	svccs	0x00696261
  for(unsigned int i = 2; i < output_length; i += 3) {
    12b4:	2f62696c 	svccs	0x0062696c
    output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
    12b8:	2f636367 	svccs	0x00636367
    12bc:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	@ 0xfffffe7c
    12c0:	656e6f6e 	strbvs	r6, [lr, #-3950]!	@ 0xfffff092
    12c4:	6261652d 	rsbvs	r6, r1, #188743680	@ 0xb400000
    12c8:	32312f69 	eorscc	r2, r1, #420	@ 0x1a4
    output[1] = base64_to_binary(input[1]) << 4 | base64_to_binary(input[2]) >> 2;
    12cc:	312e322e 			@ <UNDEFINED> instruction: 0x312e322e
    12d0:	636e692f 	cmnvs	lr, #770048	@ 0xbc000
    12d4:	6564756c 	strbvs	r7, [r4, #-1388]!	@ 0xfffffa94
    12d8:	6f682f00 	svcvs	0x00682f00
    12dc:	652f656d 	strvs	r6, [pc, #-1389]!	@ d77 <handle_up_arrow+0x2d>
    output[2] = base64_to_binary(input[2]) << 6 | base64_to_binary(input[3]);
    12e0:	2f667463 	svccs	0x00667463
    12e4:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    12e8:	6172742d 	cmnvs	r2, sp, lsr #8
    12ec:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
    input += 4;
    12f0:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
  for(unsigned int i = 2; i < output_length; i += 3) {
    12f4:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
    12f8:	6c2f6c6c 	stcvs	12, cr6, [pc], #-432	@ 1150 <base64_to_binary+0x1a>
  switch(output_length % 3) {
    12fc:	742f6269 	strtvc	r6, [pc], #-617	@ 1304 <decode_base64+0x60>
    1300:	2d796e69 	ldclcs	14, cr6, [r9, #-420]!	@ 0xfffffe5c
    1304:	00736561 	rsbseq	r6, r3, r1, ror #10
    1308:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 1254 <encode_base64+0x98>
    130c:	63652f65 	cmnvs	r5, #404	@ 0x194
    1310:	652f6674 	strvs	r6, [pc, #-1652]!	@ ca4 <add_command_to_history+0x30>
    1314:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
    1318:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
      output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
    131c:	2f72656e 	svccs	0x0072656e
    1320:	2f626f66 	svccs	0x00626f66
    1324:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
    1328:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
    132c:	74732f62 	ldrbtvc	r2, [r3], #-3938	@ 0xfffff09e
      output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
    1330:	676e6972 			@ <UNDEFINED> instruction: 0x676e6972
    1334:	6f682f00 	svcvs	0x00682f00
    1338:	652f656d 	strvs	r6, [pc, #-1389]!	@ dd3 <handle_down_arrow+0x17>
    133c:	2f667463 	svccs	0x00667463
    1340:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
      output[1] = base64_to_binary(input[1]) << 4 | base64_to_binary(input[2]) >> 2;
    1344:	6172742d 	cmnvs	r2, sp, lsr #8
    1348:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
    134c:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
    1350:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
    1354:	6c2f6c6c 	stcvs	12, cr6, [pc], #-432	@ 11ac <decode_base64_length+0x24>
  return output_length;
    1358:	622f6269 	eorvs	r6, pc, #-1879048186	@ 0x90000006
    135c:	36657361 	strbtcc	r7, [r5], -r1, ror #6
{
    1360:	682f0034 	stmdavs	pc!, {r2, r4, r5}	@ <UNPREDICTABLE>
    1364:	2f656d6f 	svccs	0x00656d6f
	for (i = 0, j = 0; i < 16; ++i, j += 4)
    1368:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    136c:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
		m[i] = (data[j] << 24) | (data[j + 1] << 16) | (data[j + 2] << 8) | (data[j + 3]);
    1370:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
    1374:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
    1378:	6f662f72 	svcvs	0x00662f72
    137c:	68732f62 	ldmdavs	r3!, {r1, r5, r6, r8, r9, sl, fp, sp}^
    1380:	2f6c6c65 	svccs	0x006c6c65
    1384:	2f62696c 	svccs	0x0062696c
    1388:	6e697270 	mcrvs	2, 3, r7, cr9, cr0, {3}
	for (i = 0, j = 0; i < 16; ++i, j += 4)
    138c:	00006674 	andeq	r6, r0, r4, ror r6
    1390:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
		m[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16];
    1394:	00632e6c 	rsbeq	r2, r3, ip, ror #28
    1398:	73000001 	movwvc	r0, #1
    139c:	6e696474 	mcrvs	4, 3, r6, cr9, cr4, {3}
    13a0:	63672d74 	cmnvs	r7, #116, 26	@ 0x1d00
    13a4:	00682e63 	rsbeq	r2, r8, r3, ror #28
    13a8:	73000002 	movwvc	r0, #2
    13ac:	65646474 	strbvs	r6, [r4, #-1140]!	@ 0xfffffb8c
    13b0:	00682e66 	rsbeq	r2, r8, r6, ror #28
    13b4:	73000002 	movwvc	r0, #2
    13b8:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
    13bc:	0100682e 	tsteq	r0, lr, lsr #16
    13c0:	65610000 	strbvs	r0, [r1, #-0]!
    13c4:	00682e73 	rsbeq	r2, r8, r3, ror lr
    13c8:	73000003 	movwvc	r0, #3
    13cc:	6e697274 	mcrvs	2, 3, r7, cr9, cr4, {3}
    13d0:	00682e67 	rsbeq	r2, r8, r7, ror #28
    13d4:	62000004 	andvs	r0, r0, #4
	for ( ; i < 64; ++i)
    13d8:	36657361 	strbtcc	r7, [r5], -r1, ror #6
    13dc:	00682e34 	rsbeq	r2, r8, r4, lsr lr
	a = ctx->state[0];
    13e0:	70000005 	andvc	r0, r0, r5
	b = ctx->state[1];
    13e4:	746e6972 	strbtvc	r6, [lr], #-2418	@ 0xfffff68e
	c = ctx->state[2];
    13e8:	00682e66 	rsbeq	r2, r8, r6, ror #28
	d = ctx->state[3];
    13ec:	00000006 	andeq	r0, r0, r6
	e = ctx->state[4];
    13f0:	05004005 	streq	r4, [r0, #-5]
	f = ctx->state[5];
    13f4:	000a8402 	andeq	r8, sl, r2, lsl #8
    13f8:	03830300 	orreq	r0, r3, #0, 6
	g = ctx->state[6];
    13fc:	03090501 	movweq	r0, #38145	@ 0x9501
	h = ctx->state[7];
    1400:	19053c0c 	stmdbne	r5, {r2, r3, sl, fp, ip, sp}
    1404:	3506052e 	strcc	r0, [r6, #-1326]	@ 0xfffffad2
	d = ctx->state[3];
    1408:	054b0b05 	strbeq	r0, [fp, #-2821]	@ 0xfffff4fb
	b = ctx->state[1];
    140c:	0402002b 	streq	r0, [r2], #-43	@ 0xffffffd5
	for (i = 0; i < 64; ++i) {
    1410:	20052002 	andcs	r2, r5, r2
    1414:	02040200 	andeq	r0, r4, #0, 4
    1418:	0026053c 	eoreq	r0, r6, ip, lsr r5
    141c:	3c020402 	cfstrscc	mvf0, [r2], {2}
		t1 = h + EP1(e) + CH(e,f,g) + k[i] + m[i];
    1420:	02002405 	andeq	r2, r0, #83886080	@ 0x5000000
    1424:	05200204 	streq	r0, [r0, #-516]!	@ 0xfffffdfc
    1428:	04020010 	streq	r0, [r2], #-16
    142c:	0c052001 	stceq	0, cr2, [r5], {1}
    1430:	2e03054d 	cfsh32cs	mvfx0, mvfx3, #45
    1434:	02002f05 	andeq	r2, r0, #5, 30
    1438:	05200304 	streq	r0, [r0, #-772]!	@ 0xfffffcfc
    143c:	04020026 	streq	r0, [r2], #-38	@ 0xffffffda
    1440:	19053c03 	stmdbne	r5, {r0, r1, sl, fp, ip, sp}
    1444:	01040200 	mrseq	r0, R12_usr
    1448:	0303053c 	movweq	r0, #13628	@ 0x353c
		t2 = EP0(a) + MAJ(a,b,c);
    144c:	01054a10 	tsteq	r5, r0, lsl sl
    1450:	031a052f 	tsteq	sl, #197132288	@ 0xbc00000
    1454:	05e47dab 	strbeq	r7, [r4, #3499]!	@ 0xdab
    1458:	3d4b2103 	stfcce	f2, [fp, #-12]
    145c:	3d060105 	stfccs	f0, [r6, #-20]	@ 0xffffffec
    1460:	3e062a05 	vmlacc.f32	s4, s12, s10
    1464:	03050106 	movweq	r0, #20742	@ 0x5106
    1468:	09052f06 	stmdbeq	r5, {r1, r2, r8, r9, sl, fp, sp}
		h = g;
    146c:	05050106 	streq	r0, [r5, #-262]	@ 0xfffffefa
		f = e;
    1470:	052f2106 	streq	r2, [pc, #-262]!	@ 1372 <sha256_transform+0x12>
		e = d + t1;
    1474:	0501060f 	streq	r0, [r1, #-1551]	@ 0xfffff9f1
		c = b;
    1478:	051e060a 	ldreq	r0, [lr, #-1546]	@ 0xfffff9f6
		a = t1 + t2;
    147c:	20320601 	eorscs	r0, r2, r1, lsl #12
	for (i = 0; i < 64; ++i) {
    1480:	00062205 	andeq	r2, r6, r5, lsl #4
	ctx->state[0] += a;
    1484:	0b1e0205 	bleq	781ca0 <__ROM_SIZE__+0x741ca0>
    1488:	95030000 	strls	r0, [r3, #-0]
    148c:	03050102 	movweq	r0, #20738	@ 0x5102
    1490:	01080521 	tsteq	r8, r1, lsr #10
    1494:	01060c05 	tsteq	r6, r5, lsl #24
	ctx->state[1] += b;
    1498:	05200305 	streq	r0, [r0, #-773]!	@ 0xfffffcfb
	ctx->state[2] += c;
    149c:	04020005 	streq	r0, [r2], #-5
    14a0:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
	ctx->state[3] += d;
    14a4:	04020011 	streq	r0, [r2], #-17	@ 0xffffffef
	ctx->state[4] += e;
    14a8:	05010603 	streq	r0, [r1, #-1539]	@ 0xfffff9fd
    14ac:	04020005 	streq	r0, [r2], #-5
	ctx->state[5] += f;
    14b0:	37052003 	strcc	r2, [r5, -r3]
    14b4:	03040200 	movweq	r0, #16896	@ 0x4200
	ctx->state[6] += g;
    14b8:	2d053b06 	vstrcs	d3, [r5, #-24]	@ 0xffffffe8
    14bc:	01040200 	mrseq	r0, R12_usr
	ctx->state[7] += h;
    14c0:	001c0520 	andseq	r0, ip, r0, lsr #10
    14c4:	06010402 	streq	r0, [r1], -r2, lsl #8
}
    14c8:	001f0501 	andseq	r0, pc, r1, lsl #10
    14cc:	58010402 	stmdapl	r1, {r1, sl}
    14d0:	02002d05 	andeq	r2, r0, #320	@ 0x140
	ctx->datalen = 0;
    14d4:	05200104 	streq	r0, [r0, #-260]!	@ 0xfffffefc
	ctx->bitlen = 0;
    14d8:	05203101 	streq	r3, [r0, #-257]!	@ 0xfffffeff
    14dc:	05000630 	streq	r0, [r0, #-1584]	@ 0xfffff9d0
	ctx->state[0] = 0x6a09e667;
    14e0:	000b4402 	andeq	r4, fp, r2, lsl #8
	ctx->state[1] = 0xbb67ae85;
    14e4:	7e990300 	cdpvc	3, 9, cr0, cr9, cr0, {0}
	ctx->state[2] = 0x3c6ef372;
    14e8:	05010601 	streq	r0, [r1, #-1537]	@ 0xfffff9ff
	ctx->state[3] = 0xa54ff53a;
    14ec:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
	ctx->state[4] = 0x510e527f;
    14f0:	0501062a 	streq	r0, [r1, #-1578]	@ 0xfffff9d6
	ctx->state[5] = 0x9b05688c;
    14f4:	133d0603 	teqne	sp, #3145728	@ 0x300000
	ctx->state[6] = 0x1f83d9ab;
    14f8:	01061a05 	tsteq	r6, r5, lsl #20
	ctx->state[7] = 0x5be0cd19;
    14fc:	05200605 	streq	r0, [r0, #-1541]!	@ 0xfffff9fb
    1500:	052f0605 	streq	r0, [pc, #-1541]!	@ f03 <shell+0xb>
    1504:	3c010624 	stccc	6, cr0, [r1], {36}	@ 0x24
    1508:	051e0c05 	ldreq	r0, [lr, #-3077]	@ 0xfffff3fb
}
    150c:	04020005 	streq	r0, [r2], #-5
    1510:	05330603 	ldreq	r0, [r3, #-1539]!	@ 0xfffff9fd
    1514:	04020026 	streq	r0, [r2], #-38	@ 0xffffffda
    1518:	05010603 	streq	r0, [r1, #-1539]	@ 0xfffff9fd
    151c:	04020005 	streq	r0, [r2], #-5
    1520:	38052e03 	stmdacc	r5, {r0, r1, r9, sl, fp, sp}
    1524:	03040200 	movweq	r0, #16896	@ 0x4200
{
    1528:	2a056506 	bcs	15a948 <__ROM_SIZE__+0x11a948>
    152c:	01040200 	mrseq	r0, R12_usr
	for (i = 0; i < len; ++i) {
    1530:	32030520 	andcc	r0, r3, #32, 10	@ 0x8000000
    1534:	13060105 	movwne	r0, #24837	@ 0x6105
    1538:	062c052e 	strteq	r0, [ip], -lr, lsr #10
		ctx->data[ctx->datalen] = data[i];
    153c:	84020500 	strhi	r0, [r2], #-1280	@ 0xfffffb00
		ctx->datalen++;
    1540:	0300000b 	movweq	r0, #11
		if (ctx->datalen == 64) {
    1544:	060102d1 			@ <UNDEFINED> instruction: 0x060102d1
			sha256_transform(ctx, ctx->data);
    1548:	06030501 	streq	r0, [r3], -r1, lsl #10
    154c:	203c0621 	eorscs	r0, ip, r1, lsr #12
			ctx->bitlen += 512;
    1550:	01052f06 	tsteq	r5, r6, lsl #30
    1554:	2e051306 	cdpcs	3, 0, cr1, cr5, cr6, {0}
    1558:	02050006 	andeq	r0, r5, #6
    155c:	00000ba0 	andeq	r0, r0, r0, lsr #23
			ctx->datalen = 0;
    1560:	017f8a03 	cmneq	pc, r3, lsl #20
    1564:	03050106 	movweq	r0, #20742	@ 0x5106
{
    1568:	20062106 	andcs	r2, r6, r6, lsl #2
    156c:	01053006 	tsteq	r5, r6
	if (ctx->datalen < 56) {
    1570:	2c051306 	stccs	3, cr1, [r5], {6}
		ctx->data[i++] = 0x80;
    1574:	02050006 	andeq	r0, r5, #6
    1578:	00000bb0 			@ <UNDEFINED> instruction: 0x00000bb0
			ctx->data[i++] = 0x00;
    157c:	017ef103 	cmneq	lr, r3, lsl #2	@ <UNPREDICTABLE>
    1580:	03050106 	movweq	r0, #20742	@ 0x5106
		while (i < 56)
    1584:	05144b06 	ldreq	r4, [r4, #-2822]	@ 0xfffff4fa
	ctx->bitlen += ctx->datalen * 8;
    1588:	0c050108 	stfeqs	f0, [r5], {8}
    158c:	03050106 	movweq	r0, #20742	@ 0x5106
    1590:	00330520 	eorseq	r0, r3, r0, lsr #10
    1594:	06020402 	streq	r0, [r2], -r2, lsl #8
	ctx->data[63] = ctx->bitlen;
    1598:	00290520 	eoreq	r0, r9, r0, lsr #10
	ctx->data[62] = ctx->bitlen >> 8;
    159c:	20010402 	andcs	r0, r1, r2, lsl #8
    15a0:	02001805 	andeq	r1, r0, #327680	@ 0x50000
	ctx->data[61] = ctx->bitlen >> 16;
    15a4:	01060104 	tsteq	r6, r4, lsl #2
	ctx->data[60] = ctx->bitlen >> 24;
    15a8:	02001b05 	andeq	r1, r0, #5120	@ 0x1400
    15ac:	054a0104 	strbeq	r0, [sl, #-260]	@ 0xfffffefc
	ctx->data[59] = ctx->bitlen >> 32;
    15b0:	04020029 	streq	r0, [r2], #-41	@ 0xffffffd7
	ctx->data[58] = ctx->bitlen >> 40;
    15b4:	05052001 	streq	r2, [r5, #-1]
	ctx->data[57] = ctx->bitlen >> 48;
    15b8:	09052106 	stmdbeq	r5, {r1, r2, r8, sp}
    15bc:	08050106 	stmdaeq	r5, {r1, r2, r8}
	ctx->data[56] = ctx->bitlen >> 56;
    15c0:	0607053c 			@ <UNDEFINED> instruction: 0x0607053c
	sha256_transform(ctx, ctx->data);
    15c4:	0620052f 	strteq	r0, [r0], -pc, lsr #10
    15c8:	2e230501 	cfsh64cs	mvdx0, mvdx3, #1
	for (i = 0; i < 4; ++i) {
    15cc:	05201b05 	streq	r1, [r0, #-2821]!	@ 0xfffff4fb
		ctx->data[i++] = 0x80;
    15d0:	07053c19 	smladeq	r5, r9, ip, r3
    15d4:	06133d06 	ldreq	r3, [r3], -r6, lsl #26
			ctx->data[i++] = 0x00;
    15d8:	06030501 	streq	r0, [r3], -r1, lsl #10
    15dc:	05052016 	streq	r2, [r5, #-22]	@ 0xffffffea
		while (i < 64)
    15e0:	17054c13 	smladne	r5, r3, ip, r4
		sha256_transform(ctx, ctx->data);
    15e4:	01050106 	tsteq	r5, r6, lsl #2
    15e8:	21052e5a 	tstcs	r5, sl, asr lr
		memset(ctx->data, 0, 56);
    15ec:	02050006 	andeq	r0, r5, #6
    15f0:	00000c0c 	andeq	r0, r0, ip, lsl #24
    15f4:	0101d403 	tsteq	r1, r3, lsl #8
		hash[i]      = (ctx->state[0] >> (24 - i * 8)) & 0x000000ff;
    15f8:	03050106 	movweq	r0, #20742	@ 0x5106
    15fc:	14142106 	ldrne	r2, [r4], #-262	@ 0xfffffefa
    1600:	01060605 	tsteq	r6, r5, lsl #12
		hash[i + 4]  = (ctx->state[1] >> (24 - i * 8)) & 0x000000ff;
    1604:	02001405 	andeq	r1, r0, #83886080	@ 0x5000000
    1608:	003c0104 	eorseq	r0, ip, r4, lsl #2
		hash[i + 8]  = (ctx->state[2] >> (24 - i * 8)) & 0x000000ff;
    160c:	20010402 	andcs	r0, r1, r2, lsl #8
    1610:	01040200 	mrseq	r0, R12_usr
		hash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0x000000ff;
    1614:	00100520 	andseq	r0, r0, r0, lsr #10
    1618:	2e010402 	cdpcs	4, 0, cr0, cr1, cr2, {0}
    161c:	23060505 	movwcs	r0, #25861	@ 0x6505
		hash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0x000000ff;
    1620:	37060805 	strcc	r0, [r6, -r5, lsl #16]
    1624:	05230d05 	streq	r0, [r3, #-3333]!	@ 0xfffff2fb
		hash[i + 20] = (ctx->state[5] >> (24 - i * 8)) & 0x000000ff;
    1628:	0d030605 	stceq	6, cr0, [r3, #-20]	@ 0xffffffec
    162c:	06053d2e 	streq	r3, [r5], -lr, lsr #26
    1630:	20050106 	andcs	r0, r5, r6, lsl #2
		hash[i + 24] = (ctx->state[6] >> (24 - i * 8)) & 0x000000ff;
    1634:	20770306 	rsbscs	r0, r7, r6, lsl #6
    1638:	01060f05 	tsteq	r6, r5, lsl #30
		hash[i + 28] = (ctx->state[7] >> (24 - i * 8)) & 0x000000ff;
    163c:	054a1205 	strbeq	r1, [sl, #-517]	@ 0xfffffdfb
    1640:	05052020 	streq	r2, [r5, #-32]	@ 0xffffffe0
    1644:	05302106 	ldreq	r2, [r0, #-262]!	@ 0xfffffefa
	for (i = 0; i < 4; ++i) {
    1648:	05010608 	streq	r0, [r1, #-1544]	@ 0xfffff9f8
}
    164c:	3d2f0607 	stccc	6, cr0, [pc, #-28]!	@ 1638 <sha256_final+0xd0>
static void outstr(const char *str) {
    1650:	01061305 	tsteq	r6, r5, lsl #6
  while (*str != '\0') {
    1654:	052e0705 	streq	r0, [lr, #-1797]!	@ 0xfffff8fb
    __write_char__(*str);
    1658:	4a76030d 	bmi	1d82294 <__ROM_SIZE__+0x1d42294>
    str++;
    165c:	03060305 	movweq	r0, #25349	@ 0x6305
  while (*str != '\0') {
    1660:	01052e11 	tsteq	r5, r1, lsl lr
}
    1664:	05201306 	streq	r1, [r0, #-774]!	@ 0xfffffcfa
    1668:	05000639 	streq	r0, [r0, #-1593]	@ 0xfffff9c7
static bool printf_numbers(const char fmt, va_list *args, int l_count) {
    166c:	000c7402 	andeq	r7, ip, r2, lsl #8
    1670:	7d9a0300 	ldcvc	3, cr0, [sl]
  switch (fmt) {
    1674:	15030501 	strne	r0, [r3, #-1281]	@ 0xfffffaff
    1678:	01060605 	tsteq	r6, r5, lsl #12
    167c:	02003905 	andeq	r3, r0, #81920	@ 0x14000
      if (l_count == 0) {
    1680:	051d0104 	ldreq	r0, [sp, #-260]	@ 0xfffffefc
    1684:	0402001a 	streq	r0, [r2], #-26	@ 0xffffffe6
        value = va_arg(*args, unsigned int);
    1688:	17053101 	strne	r3, [r5, -r1, lsl #2]
    168c:	01040200 	mrseq	r0, R12_usr
      if (fmt == 'u') {
    1690:	2701053c 	smladxcs	r1, ip, r5, r0
        if (value == 0) {
    1694:	1c060305 	stcne	3, cr0, [r6], {5}
          __write_char__(hextable[0]);
    1698:	01062205 	tsteq	r6, r5, lsl #4
    169c:	052e0705 	streq	r0, [lr, #-1797]!	@ 0xfffff8fb
  return true;
    16a0:	05590603 	ldrbeq	r0, [r9, #-1539]	@ 0xfffff9fd
  switch (fmt) {
    16a4:	0501060a 	streq	r0, [r1, #-1546]	@ 0xfffff9f6
      outstr("\nprintf-error\n");
    16a8:	064a2e03 	strbeq	r2, [sl], -r3, lsl #28
      return false;
    16ac:	0615052f 	ldreq	r0, [r5], -pc, lsr #10
}
    16b0:	06030501 	streq	r0, [r3], -r1, lsl #10
      if (l_count == 0) {
    16b4:	0614053d 			@ <UNDEFINED> instruction: 0x0614053d
        value = va_arg(*args, int);
    16b8:	48054a01 	stmdami	r5, {r0, r9, fp, lr}
    16bc:	00c90306 	sbceq	r0, r9, r6, lsl #6
      if (value < 0) {
    16c0:	05010666 	streq	r0, [r1, #-1638]	@ 0xfffff99a
        num[num_len++] = hextable[value % 10];
    16c4:	133d0603 	teqne	sp, #3145728	@ 0x300000
    16c8:	06100513 			@ <UNDEFINED> instruction: 0x06100513
    16cc:	052e2001 	streq	r2, [lr, #-1]!
    16d0:	05220603 	streq	r0, [r2, #-1539]!	@ 0xfffff9fd
    16d4:	1f0f0607 	svcne	0x000f0607
    16d8:	05240905 	streq	r0, [r4, #-2309]!	@ 0xfffff6fb
    16dc:	0527060d 	streq	r0, [r7, #-1549]!	@ 0xfffff9f3
    16e0:	15051e3e 	strne	r1, [r5, #-3646]	@ 0xfffff1c2
    16e4:	3e050106 	adfccs	f0, f5, f6
        value = value / 10;
    16e8:	0023052e 	eoreq	r0, r3, lr, lsr #10
      } while (value > 0);
    16ec:	2e010402 	cdpcs	4, 0, cr0, cr1, cr2, {0}
    16f0:	02003e05 	andeq	r3, r0, #5, 28	@ 0x50
        __write_char__('-');
    16f4:	052e0204 	streq	r0, [lr, #-516]!	@ 0xfffffdfc
    16f8:	05330605 	ldreq	r0, [r3, #-1541]!	@ 0xfffff9fb
        value = -value;
    16fc:	05010608 	streq	r0, [r1, #-1544]	@ 0xfffff9f8
        __write_char__(num[--num_len]);
    1700:	04020020 	streq	r0, [r2], #-32	@ 0xffffffe0
    1704:	07052e01 	streq	r2, [r5, -r1, lsl #28]
    1708:	16052f06 	strne	r2, [r5], -r6, lsl #30
    170c:	05050106 	streq	r0, [r5, #-262]	@ 0xfffffefa
    1710:	08053006 	stmdaeq	r5, {r1, r2, ip, sp}
      while (num_len > 0) {
    1714:	0e050106 	adfeqs	f0, f5, f6
  return true;
    1718:	20730306 	rsbscs	r0, r3, r6, lsl #6
          num[num_len++] = hextable[value % 10];
    171c:	052f0505 	streq	r0, [pc, #-1285]!	@ 121f <encode_base64+0x63>
    1720:	05010612 	streq	r0, [r1, #-1554]	@ 0xfffff9ee
    1724:	20052e08 	andcs	r2, r5, r8, lsl #28
    1728:	01040200 	mrseq	r0, R12_usr
    172c:	003b052e 	eorseq	r0, fp, lr, lsr #10
    1730:	2e020402 	cdpcs	4, 0, cr0, cr2, cr2, {0}
    1734:	30060705 	andcc	r0, r6, r5, lsl #14
    1738:	01061405 	tsteq	r6, r5, lsl #8
          value = value / 10;
    173c:	202e1005 	eorcs	r1, lr, r5
        } while (value > 0);
    1740:	03060305 	movweq	r0, #25349	@ 0x6305
        while (num_len > 0) {
    1744:	0105200d 	tsteq	r5, sp
          __write_char__(num[--num_len]);
    1748:	05201306 	streq	r1, [r0, #-774]!	@ 0xfffffcfa
    174c:	0500063e 	streq	r0, [r0, #-1598]	@ 0xfffff9c2
    1750:	000d0e02 	andeq	r0, sp, r2, lsl #28
    1754:	7fb80300 	svcvc	0x00b80300
    1758:	13030501 	movwne	r0, #13569	@ 0x3501
    175c:	01060605 	tsteq	r6, r5, lsl #12
  return true;
    1760:	02003e05 	andeq	r3, r0, #5, 28	@ 0x50
              __write_char__(hextable[val]);
    1764:	051f0104 	ldreq	r0, [pc, #-260]	@ 1668 <outstr+0x18>
    1768:	04020013 	streq	r0, [r2], #-19	@ 0xffffffed
              leading_zero_ignored = true;
    176c:	22054b01 	andcs	r4, r5, #1024	@ 0x400
          while (start_bit >= 0) {
    1770:	02040200 	andeq	r0, r4, #0, 4
            int val = (value >> start_bit) & 0xF;
    1774:	00370520 	eorseq	r0, r7, r0, lsr #10
            if (val || leading_zero_ignored) {
    1778:	2e030402 	cdpcs	4, 0, cr0, cr3, cr2, {0}
    177c:	03040200 	movweq	r0, #16896	@ 0x4200
    1780:	002e0520 	eoreq	r0, lr, r0, lsr #10
          bool leading_zero_ignored = false;
    1784:	2e030402 	cdpcs	4, 0, cr0, cr3, cr2, {0}
          int start_bit = LAST_NIBBLE_FIRST_BIT;
    1788:	05320c05 	ldreq	r0, [r2, #-3077]!	@ 0xfffff3fb
  return true;
    178c:	04020014 	streq	r0, [r2], #-20	@ 0xffffffec
        return false;
    1790:	05200601 	streq	r0, [r0, #-1537]!	@ 0xfffff9ff
        return false;
    1794:	0c052f05 	stceq	15, cr2, [r5], {5}
    1798:	10050106 	andne	r0, r5, r6, lsl #2
    179c:	20080520 	andcs	r0, r8, r0, lsr #10
    17a0:	02001a05 	andeq	r1, r0, #20480	@ 0x5000
    17a4:	2d060204 	sfmcs	f0, 4, [r6, #-16]
    17a8:	02040200 	andeq	r0, r4, #0, 4
int printf(const char *fmt, ...) {
    17ac:	02002006 	andeq	r2, r0, #6
    17b0:	05200204 	streq	r0, [r0, #-516]!	@ 0xfffffdfc
    17b4:	050f0605 	streq	r0, [pc, #-1541]	@ 11b7 <decode_base64_length+0x2f>
  va_start(args, fmt);
    17b8:	0501060c 	streq	r0, [r1, #-1548]	@ 0xfffff9f4
  while (*fmt) {
    17bc:	200a0301 	andcs	r0, sl, r1, lsl #6
        if (*fmt == '%') {
    17c0:	051f0a05 	ldreq	r0, [pc, #-2565]	@ dc3 <handle_down_arrow+0x7>
        __write_char__(*fmt);
    17c4:	052e2a0e 	streq	r2, [lr, #-2574]!	@ 0xfffff5f2
        fmt++;
    17c8:	050d0605 	streq	r0, [sp, #-1541]	@ 0xfffff9fb
  while (*fmt) {
    17cc:	0501060c 	streq	r0, [r1, #-1548]	@ 0xfffff9f4
    switch (state) {
    17d0:	200a0301 	andcs	r0, sl, r1, lsl #6
    17d4:	03063e05 	movweq	r3, #28165	@ 0x6e05
          fmt++;
    17d8:	06207fb6 			@ <UNDEFINED> instruction: 0x06207fb6
          continue;
    17dc:	06030501 	streq	r0, [r3], -r1, lsl #10
        while (*fmt && ((*fmt >= '0' && *fmt <= '9') || *fmt == '-')) {
    17e0:	062d052f 	strteq	r0, [sp], -pc, lsr #10
    17e4:	3c180501 	cfldr32cc	mvfx0, [r8], {1}
    17e8:	052e0605 	streq	r0, [lr, #-1541]!	@ 0xfffff9fb
    17ec:	04020018 	streq	r0, [r2], #-24	@ 0xffffffe8
    17f0:	43053d01 	movwmi	r3, #23809	@ 0x5d01
        switch (*fmt) {
    17f4:	01040200 	mrseq	r0, R12_usr
    17f8:	0605053b 			@ <UNDEFINED> instruction: 0x0605053b
    17fc:	20200622 	eorcs	r0, r0, r2, lsr #12
    1800:	01052f06 	tsteq	r5, r6, lsl #30
            __write_char__(*fmt);
    1804:	010b0306 	tsteq	fp, r6, lsl #6
    1808:	03060305 	movweq	r0, #25349	@ 0x6305
            state = CHECK_CH;
    180c:	2e062078 	mcrcs	0, 0, r2, cr6, cr8, {3}
            break;
    1810:	13053006 	movwne	r3, #20486	@ 0x5006
    1814:	03050106 	movweq	r0, #20742	@ 0x5106
            outstr(va_arg(args, const char *));
    1818:	21056706 	tstcs	r5, r6, lsl #14
    181c:	07050106 	streq	r0, [r5, -r6, lsl #2]
    1820:	0603052e 	streq	r0, [r3], -lr, lsr #10
            fmt++;
    1824:	06140559 			@ <UNDEFINED> instruction: 0x06140559
            break;
    1828:	20030501 	andcs	r0, r3, r1, lsl #10
            __write_char__(va_arg(args, int));
    182c:	053d063c 	ldreq	r0, [sp, #-1596]!	@ 0xfffff9c4
    1830:	05010611 	streq	r0, [r1, #-1553]	@ 0xfffff9ef
    1834:	03053c0f 	movweq	r3, #23567	@ 0x5c0f
            fmt++;
    1838:	40052206 	andmi	r2, r5, r6, lsl #4
            break;
    183c:	050106a1 	streq	r0, [r1, #-1697]	@ 0xfffff95f
            if (*fmt == 'l') {
    1840:	063d0603 	ldrteq	r0, [sp], -r3, lsl #12
    1844:	052f062e 	streq	r0, [pc, #-1582]!	@ 121e <encode_base64+0x62>
            if (printf_numbers(*fmt, &args, l_count)) {
    1848:	0501060f 	streq	r0, [r1, #-1551]	@ 0xfffff9f1
    184c:	052f0603 	streq	r0, [pc, #-1539]!	@ 1251 <encode_base64+0x95>
    1850:	05010618 	streq	r0, [r1, #-1560]	@ 0xfffff9e8
              state = CHECK_CH;
    1854:	03054a06 	movweq	r4, #23046	@ 0x5a06
              fmt++;
    1858:	13053006 	movwne	r3, #20486	@ 0x5006
              l_count++;
    185c:	03050106 	movweq	r0, #20742	@ 0x5106
            if (printf_numbers(*fmt, &args, 0)) {
    1860:	21056706 	tstcs	r5, r6, lsl #14
    1864:	07050106 	streq	r0, [r5, -r6, lsl #2]
              fmt++;
    1868:	0603052e 	streq	r0, [r3], -lr, lsr #10
              break;
    186c:	06140559 			@ <UNDEFINED> instruction: 0x06140559
            return -1;
    1870:	20030501 	andcs	r0, r3, r1, lsl #10
}
    1874:	11056706 	tstne	r5, r6, lsl #14
    1878:	0f050106 	svceq	0x00050106
            return -1;
    187c:	0603053c 			@ <UNDEFINED> instruction: 0x0603053c
    1880:	06010522 	streq	r0, [r1], -r2, lsr #10
    1884:	2705204b 	strcs	r2, [r5, -fp, asr #32]
static void outstr2(const char *str) {
    1888:	02050006 	andeq	r0, r5, #6
  while (*str != '\0') {
    188c:	00000e1c 	andeq	r0, r0, ip, lsl lr
    __write_char2__(*str);
    1890:	017fba03 	cmneq	pc, r3, lsl #20
    str++;
    1894:	05012905 	streq	r2, [r1, #-2309]	@ 0xfffff6fb
  while (*str != '\0') {
    1898:	05010637 	streq	r0, [r1, #-1591]	@ 0xfffff9c9
}
    189c:	28053c3f 	stmdacs	r5, {r0, r1, r2, r3, r4, r5, sl, fp, ip, sp}
    18a0:	2a053d06 	bcs	150cc0 <__ROM_SIZE__+0x110cc0>
static bool printf2_numbers(const char fmt, va_list *args, int l_count) {
    18a4:	06390501 	ldrteq	r0, [r9], -r1, lsl #10
    18a8:	3c410501 	cfstr64cc	mvdx0, [r1], {1}
  switch (fmt) {
    18ac:	3e062905 	vmlacc.f16	s4, s12, s10	@ <UNPREDICTABLE>
    18b0:	05012b05 	streq	r2, [r1, #-2821]	@ 0xfffff4fb
    18b4:	0501063a 	streq	r0, [r1, #-1594]	@ 0xfffff9c6
      if (l_count == 0) {
    18b8:	2a052e42 	bcs	14d1c8 <__ROM_SIZE__+0x10d1c8>
    18bc:	2c054b06 			@ <UNDEFINED> instruction: 0x2c054b06
        value = va_arg(*args, unsigned int);
    18c0:	063c0501 	ldrteq	r0, [ip], -r1, lsl #10
    18c4:	3c440501 	cfstr64cc	mvdx0, [r4], {1}
      if (fmt == 'u') {
    18c8:	3e062805 	cdpcc	8, 0, cr2, cr6, cr5, {0}
        if (value == 0) {
    18cc:	05140105 	ldreq	r0, [r4, #-261]	@ 0xfffffefb
          __write_char2__(hextable2[0]);
    18d0:	01052227 	tsteq	r5, r7, lsr #4
    18d4:	232d0514 			@ <UNDEFINED> instruction: 0x232d0514
  return true;
    18d8:	05130305 	ldreq	r0, [r3, #-773]	@ 0xfffffcfb
  switch (fmt) {
    18dc:	05130601 	ldreq	r0, [r3, #-1537]	@ 0xfffff9ff
      outstr2("\nprintf2-error\n");
    18e0:	e4030639 	str	r0, [r3], #-1593	@ 0xfffff9c7
      return false;
    18e4:	03052000 	movweq	r2, #20480	@ 0x5000
}
    18e8:	06060513 			@ <UNDEFINED> instruction: 0x06060513
      if (l_count == 0) {
    18ec:	00390501 	eorseq	r0, r9, r1, lsl #10
        value = va_arg(*args, int);
    18f0:	2d010402 	cfstrscs	mvf0, [r1, #-8]
    18f4:	02001805 	andeq	r1, r0, #327680	@ 0x50000
      if (value < 0) {
    18f8:	054b0104 	strbeq	r0, [fp, #-260]	@ 0xfffffefc
        num[num_len++] = hextable2[value % 10];
    18fc:	2d2d2607 	stccs	6, cr2, [sp, #-28]!	@ 0xffffffe4
    1900:	03060505 	movweq	r0, #25861	@ 0x6505
    1904:	06052e0c 	streq	r2, [r5], -ip, lsl #28
    1908:	20050106 	andcs	r0, r5, r6, lsl #2
    190c:	20770306 	rsbscs	r0, r7, r6, lsl #6
    1910:	01060f05 	tsteq	r6, r5, lsl #30
    1914:	054a1205 	strbeq	r1, [sl, #-517]	@ 0xfffffdfb
    1918:	05052020 	streq	r2, [r5, #-32]	@ 0xffffffe0
    191c:	09052306 	stmdbeq	r5, {r1, r2, r8, r9, sp}
        value = value / 10;
    1920:	08050106 	stmdaeq	r5, {r1, r2, r8}
      } while (value > 0);
    1924:	0607054a 	streq	r0, [r7], -sl, asr #10
    1928:	0612052f 	ldreq	r0, [r2], -pc, lsr #10
        __write_char2__('-');
    192c:	06070501 	streq	r0, [r7], -r1, lsl #10
    1930:	1205132f 	andne	r1, r5, #-1140850688	@ 0xbc000000
        value = -value;
    1934:	03055706 	movweq	r5, #22278	@ 0x5706
        __write_char2__(num[--num_len]);
    1938:	06053606 	streq	r3, [r5], -r6, lsl #12
    193c:	03050106 	movweq	r0, #20742	@ 0x5106
    1940:	06054206 	streq	r4, [r5], -r6, lsl #4
    1944:	01050106 	tsteq	r5, r6, lsl #2
    1948:	06050542 	streq	r0, [r5], -r2, asr #10
      while (num_len > 0) {
    194c:	052e7503 	streq	r7, [lr, #-1283]!	@ 0xfffffafd
  return true;
    1950:	0501061b 	streq	r0, [r1, #-1563]	@ 0xfffff9e5
          num[num_len++] = hextable2[value % 10];
    1954:	67062e05 	strvs	r2, [r6, -r5, lsl #28]
    1958:	01061305 	tsteq	r6, r5, lsl #6
    195c:	053c1105 	ldreq	r1, [ip, #-261]!	@ 0xfffffefb
    1960:	59330605 	ldmdbpl	r3!, {r0, r2, r9, sl}
    1964:	66064b2f 	strvs	r4, [r6], -pc, lsr #22
    1968:	03062b05 	movweq	r2, #27397	@ 0x6b05
    196c:	05827f81 	streq	r7, [r2, #3969]	@ 0xf81
    1970:	3a05012d 	bcc	141e2c <__ROM_SIZE__+0x101e2c>
          value = value / 10;
    1974:	19050106 	stmdbne	r5, {r1, r2, r8}
        } while (value > 0);
    1978:	02050006 	andeq	r0, r5, #6
        while (num_len > 0) {
    197c:	00000ef8 	strdeq	r0, [r0], -r8
          __write_char2__(num[--num_len]);
    1980:	0101af03 	tsteq	r1, r3, lsl #30
    1984:	132f0305 			@ <UNDEFINED> instruction: 0x132f0305
    1988:	01060705 	tsteq	r6, r5, lsl #14
    198c:	2f060305 	svccs	0x00060305
    1990:	14131413 	ldrne	r1, [r3], #-1043	@ 0xfffffbed
    1994:	05010805 	streq	r0, [r1, #-2053]	@ 0xfffff7fb
  return true;
    1998:	05010603 	streq	r0, [r1, #-1539]	@ 0xfffff9fd
              __write_char2__(hextable2[val]);
    199c:	0402002c 	streq	r0, [r2], #-44	@ 0xffffffd4
    19a0:	05200603 	streq	r0, [r0, #-1539]!	@ 0xfffff9fd
              leading_zero_ignored = true;
    19a4:	04020039 	streq	r0, [r2], #-57	@ 0xffffffc7
          while (start_bit >= 0) {
    19a8:	05010603 	streq	r0, [r1, #-1539]	@ 0xfffff9fd
            int val = (value >> start_bit) & 0xF;
    19ac:	04020028 	streq	r0, [r2], #-40	@ 0xffffffd8
            if (val || leading_zero_ignored) {
    19b0:	05660603 	strbeq	r0, [r6, #-1539]!	@ 0xfffff9fd
    19b4:	04020015 	streq	r0, [r2], #-21	@ 0xffffffeb
    19b8:	0c052001 	stceq	0, cr2, [r5], {1}
          bool leading_zero_ignored = false;
    19bc:	05203006 	streq	r3, [r0, #-6]!
          int start_bit = LAST_NIBBLE_FIRST_BIT;
    19c0:	0402002b 	streq	r0, [r2], #-43	@ 0xffffffd5
  return true;
    19c4:	05200603 	streq	r0, [r0, #-1539]!	@ 0xfffff9fd
        return false;
    19c8:	04020033 	streq	r0, [r2], #-51	@ 0xffffffcd
        return false;
    19cc:	05010603 	streq	r0, [r1, #-1539]	@ 0xfffff9fd
    19d0:	04020027 	streq	r0, [r2], #-39	@ 0xffffffd9
    19d4:	054a0603 	strbeq	r0, [sl, #-1539]	@ 0xfffff9fd
    19d8:	04020015 	streq	r0, [r2], #-21	@ 0xffffffeb
    19dc:	03052001 	movweq	r2, #20481	@ 0x5001
    19e0:	07052f30 	smladxeq	r5, r0, pc, r2	@ <UNPREDICTABLE>
int printf2(const char *fmt, ...) {
    19e4:	3c750306 	ldclcc	3, cr0, [r5], #-24	@ 0xffffffe8
    19e8:	30031505 	andcc	r1, r3, r5, lsl #10
    19ec:	1405202e 	strne	r2, [r5], #-46	@ 0xffffffd2
  va_start(args, fmt);
    19f0:	01040200 	mrseq	r0, R12_usr
  while (*fmt) {
    19f4:	20660306 	rsbcs	r0, r6, r6, lsl #6
        if (*fmt == '%') {
    19f8:	02001805 	andeq	r1, r0, #327680	@ 0x50000
        __write_char2__(*fmt);
    19fc:	01060104 	tsteq	r6, r4, lsl #2
        fmt++;
    1a00:	02000505 	andeq	r0, r0, #20971520	@ 0x1400000
  while (*fmt) {
    1a04:	4d060104 	stfmis	f0, [r6, #-16]
    switch (state) {
    1a08:	02000805 	andeq	r0, r0, #327680	@ 0x50000
    1a0c:	01060104 	tsteq	r6, r4, lsl #2
          fmt++;
    1a10:	03060705 	movweq	r0, #26373	@ 0x6705
          continue;
    1a14:	063c00c3 	ldrteq	r0, [ip], -r3, asr #1
        while (*fmt && ((*fmt >= '0' && *fmt <= '9') || *fmt == '-')) {
    1a18:	0609052e 	streq	r0, [r9], -lr, lsr #10
    1a1c:	05204103 	streq	r4, [r0, #-259]!	@ 0xfffffefd
    1a20:	05010612 	streq	r0, [r1, #-1554]	@ 0xfffff9ee
    1a24:	0905201a 	stmdbeq	r5, {r1, r3, r4, sp}
    1a28:	054b6706 	strbeq	r6, [fp, #-1798]	@ 0xfffff8fa
        switch (*fmt) {
    1a2c:	00c70303 	sbceq	r0, r7, r3, lsl #6
    1a30:	0a054001 	beq	151a3c <__ROM_SIZE__+0x111a3c>
    1a34:	03050106 	movweq	r0, #20742	@ 0x5106
    1a38:	06055b06 	streq	r5, [r5], -r6, lsl #22
            __write_char2__(*fmt);
    1a3c:	05200106 	streq	r0, [r0, #-262]!	@ 0xfffffefa
    1a40:	09052101 	stmdbeq	r5, {r0, r8, sp}
            state = CHECK_CH;
    1a44:	7fb50306 	svcvc	0x00b50306
            break;
    1a48:	060d052e 	streq	r0, [sp], -lr, lsr #10
    1a4c:	2e0c0501 	cfsh32cs	mvfx0, mvfx12, #1
            outstr2(va_arg(args, const char *));
    1a50:	34060905 	strcc	r0, [r6], #-2309	@ 0xfffff6fb
    1a54:	01061305 	tsteq	r6, r5, lsl #6
    1a58:	05200c05 	streq	r0, [r0, #-3077]!	@ 0xfffff3fb
            fmt++;
    1a5c:	05220609 	streq	r0, [r2, #-1545]!	@ 0xfffff9f7
            break;
    1a60:	0501060e 	streq	r0, [r1, #-1550]	@ 0xfffff9f2
            __write_char2__(va_arg(args, int));
    1a64:	05300609 	ldreq	r0, [r0, #-1545]!	@ 0xfffff9f7
    1a68:	0501061a 	streq	r0, [r1, #-1562]	@ 0xfffff9e6
    1a6c:	05670609 	strbeq	r0, [r7, #-1545]!	@ 0xfffff9f7
            fmt++;
    1a70:	2e2a0307 	cdpcs	3, 2, cr0, cr10, cr7, {0}
            break;
    1a74:	01060b05 	tsteq	r6, r5, lsl #22
            if (*fmt == 'l') {
    1a78:	052e0a05 	streq	r0, [lr, #-2565]!	@ 0xfffff5fb
    1a7c:	05210609 	streq	r0, [r1, #-1545]!	@ 0xfffff9f7
            if (printf2_numbers(*fmt, &args, l_count)) {
    1a80:	7fb40303 	svcvc	0x00b40303
    1a84:	1305054a 	movwne	r0, #21834	@ 0x554a
    1a88:	01060a05 	tsteq	r6, r5, lsl #20
              state = CHECK_CH;
    1a8c:	052e0805 	streq	r0, [lr, #-2053]!	@ 0xfffff7fb
              fmt++;
    1a90:	05330605 	ldreq	r0, [r3, #-1541]!	@ 0xfffff9fb
              l_count++;
    1a94:	05010609 	streq	r0, [r1, #-1545]	@ 0xfffff9f7
            if (printf2_numbers(*fmt, &args, 0)) {
    1a98:	054d0605 	strbeq	r0, [sp, #-1541]	@ 0xfffff9fb
    1a9c:	05010608 	streq	r0, [r1, #-1544]	@ 0xfffff9f8
              fmt++;
    1aa0:	05400607 	strbeq	r0, [r0, #-1543]	@ 0xfffff9f9
              break;
    1aa4:	05010609 	streq	r0, [r1, #-1545]	@ 0xfffff9f7
            return -1;
    1aa8:	05220607 	streq	r0, [r2, #-1543]!	@ 0xfffff9f9
}
    1aac:	0501060a 	streq	r0, [r1, #-1546]	@ 0xfffff9f6
    1ab0:	04020020 	streq	r0, [r2], #-32	@ 0xffffffe0
            return -1;
    1ab4:	07052e01 	streq	r2, [r5, -r1, lsl #28]
    1ab8:	0a053406 	beq	14ead8 <__ROM_SIZE__+0x10ead8>
    1abc:	17050106 	strne	r0, [r5, -r6, lsl #2]
int r32(int argc, char *argv[]) {
    1ac0:	01040200 	mrseq	r0, R12_usr
  if (argc < 2) {
    1ac4:	060e052e 	streq	r0, [lr], -lr, lsr #10
  uint32_t addr = atoh(argv[1]);
    1ac8:	052e0d03 	streq	r0, [lr, #-3331]!	@ 0xfffff2fd
    1acc:	05010611 	streq	r0, [r1, #-1553]	@ 0xfffff9ef
  printf("0x%x: 0x%x\n", addr, data);
    1ad0:	0531060e 	ldreq	r0, [r1, #-1550]!	@ 0xfffff9f2
    1ad4:	05010611 	streq	r0, [r1, #-1553]	@ 0xfffff9ef
}
    1ad8:	0531060e 	ldreq	r0, [r1, #-1550]!	@ 0xfffff9f2
    printf("Usage: %s <address> (in hex)\n", argv[0]);
    1adc:	0501061c 	streq	r0, [r1, #-1564]	@ 0xfffff9e4
    1ae0:	0e053c11 	mcreq	12, 0, r3, cr5, cr1, {0}
    return -1;
    1ae4:	1c053206 	sfmne	f3, 4, [r5], {6}
    1ae8:	11050106 	tstne	r5, r6, lsl #2
    1aec:	060c053c 			@ <UNDEFINED> instruction: 0x060c053c
int w32(int argc, char *argv[]) {
    1af0:	052e1603 	streq	r1, [lr, #-1539]!	@ 0xfffff9fd
  if (argc < 3) {
    1af4:	0501060f 	streq	r0, [r1, #-1551]	@ 0xfffff9f1
  uint32_t addr = atoh(argv[1]);
    1af8:	05340609 	ldreq	r0, [r4, #-1545]!	@ 0xfffff9f7
    1afc:	05010612 	streq	r0, [r1, #-1554]	@ 0xfffff9ee
  uint32_t data = atoh(argv[2]);
    1b00:	0905201a 	stmdbeq	r5, {r1, r3, r4, sp}
    1b04:	0e055906 	vmlaeq.f16	s10, s10, s12	@ <UNPREDICTABLE>
  return 0;
    1b08:	0b050106 	bleq	141f28 <__ROM_SIZE__+0x101f28>
    printf("Usage: %s <address> (in hex) <value> (in hex)\n", argv[0]);
    1b0c:	3c4e0306 	mcrrcc	3, 0, r0, lr, cr6
    1b10:	002b052f 	eoreq	r0, fp, pc, lsr #10
    return -1;
    1b14:	06010402 	streq	r0, [r1], -r2, lsl #8
    1b18:	053c0d03 	ldreq	r0, [ip, #-3331]!	@ 0xfffff2fd
    1b1c:	05202f15 	streq	r2, [r0, #-3861]!	@ 0xfffff0eb
int read_mem(int argc, char *argv[]) {
    1b20:	04020029 	streq	r0, [r2], #-41	@ 0xffffffd7
  if (argc < 3) {
    1b24:	15052201 	strne	r2, [r5, #-513]	@ 0xfffffdff
  uint32_t addr = atoh(argv[1]);
    1b28:	29052030 	stmdbcs	r5, {r4, r5, sp}
    1b2c:	01040200 	mrseq	r0, R12_usr
  uint32_t length = atoi(argv[2]);
    1b30:	06090522 	streq	r0, [r9], -r2, lsr #10
    1b34:	060d052f 	streq	r0, [sp], -pc, lsr #10
  for (uint32_t i = 0, data = 0; i < length; i++) {
    1b38:	2e0c0501 	cfsh32cs	mvfx0, mvfx12, #1
    printf("Usage: %s <address> (in hex) <num_words> (in decimal)\n", argv[0]);
    1b3c:	21060b05 	tstcs	r6, r5, lsl #22
    1b40:	0a030905 	beq	c3f5c <__ROM_SIZE__+0x83f5c>
    return -1;
    1b44:	060c054a 	streq	r0, [ip], -sl, asr #10
    1b48:	060b0501 	streq	r0, [fp], -r1, lsl #10
    printf("0x%x: 0x%x\n", addr, data);
    1b4c:	4d090531 	cfstr32mi	mvfx0, [r9, #-196]	@ 0xffffff3c
    1b50:	06150513 			@ <UNDEFINED> instruction: 0x06150513
    addr += 4;
    1b54:	21090511 	tstcs	r9, r1, lsl r5
  for (uint32_t i = 0, data = 0; i < length; i++) {
    1b58:	03060b05 	movweq	r0, #27397	@ 0x6b05
  return 0;
    1b5c:	09032071 	stmdbeq	r3, {r0, r4, r5, r6, sp}
}
    1b60:	0009054a 	andeq	r0, r9, sl, asr #10
    1b64:	03010402 	movweq	r0, #5122	@ 0x1402
{
    1b68:	0200580a 	andeq	r5, r0, #655360	@ 0xa0000
  if (argc < 4) {
    1b6c:	054b0104 	strbeq	r0, [fp, #-260]	@ 0xfffffefc
  uint32_t addr = atoh(argv[1]);
    1b70:	04020011 	streq	r0, [r2], #-17	@ 0xffffffef
    1b74:	201c0301 	andscs	r0, ip, r1, lsl #6
  uint32_t bit_loc = atoi(argv[2]);
    1b78:	02000105 	andeq	r0, r0, #1073741825	@ 0x40000001
    1b7c:	3d060104 	stfccs	f0, [r6, #-16]
  uint32_t bit_val = atoi(argv[3]);
    1b80:	00060f05 	andeq	r0, r6, r5, lsl #30
    1b84:	10700205 	rsbsne	r0, r0, r5, lsl #4
  if (bit_loc > 31) {
    1b88:	3d030000 	stccc	0, cr0, [r3, #-0]
  if (bit_val != 0 && bit_val != 1) {
    1b8c:	21030501 	tstcs	r3, r1, lsl #10
  data = data | (bit_val << bit_loc);
    1b90:	832f2f2f 			@ <UNDEFINED> instruction: 0x832f2f2f
    1b94:	01040200 	mrseq	r0, R12_usr
  data = data & ~(!bit_val << bit_loc);
    1b98:	0005055a 	andeq	r0, r5, sl, asr r5
    1b9c:	13010402 	movwne	r0, #5122	@ 0x1402
    1ba0:	02000905 	andeq	r0, r0, #81920	@ 0x14000
  return 0;
    1ba4:	052d0104 	streq	r0, [sp, #-260]!	@ 0xfffffefc
    printf("Error: Invalid bit location argument\n");
    1ba8:	02050019 	andeq	r0, r5, #25
    1bac:	000010a8 	andeq	r1, r0, r8, lsr #1
    printf("Error: Invalid bit value argument\n");
    1bb0:	05010617 	streq	r0, [r1, #-1559]	@ 0xfffff9e9
    1bb4:	153d0603 	ldrne	r0, [sp, #-1539]!	@ 0xfffff9fd
  printf("Usage: %s <address_in_hex(32-bits)> <bit_location_in_decimal(0 to 31)> <bit_value(0 or 1)>\n", argv[0]);
    1bb8:	060a0515 			@ <UNDEFINED> instruction: 0x060a0515
    1bbc:	03052e01 	movweq	r2, #24065	@ 0x5e01
  return -1;
    1bc0:	06053106 	streq	r3, [r5], -r6, lsl #2
    1bc4:	05200106 	streq	r0, [r0, #-262]!	@ 0xfffffefa
    1bc8:	05220603 	streq	r0, [r2, #-1539]!	@ 0xfffff9fd
    1bcc:	0501060a 	streq	r0, [r1, #-1546]	@ 0xfffff9f6
{
    1bd0:	11053d01 	tstne	r5, r1, lsl #26
  if (argc < 3) {
    1bd4:	01040200 	mrseq	r0, R12_usr
  uint32_t addr = atoh(argv[1]);
    1bd8:	02003906 	andeq	r3, r0, #98304	@ 0x18000
    1bdc:	3c060104 	stfccs	f0, [r6], {4}
  uint32_t bit_loc = atoi(argv[2]);
    1be0:	00062605 	andeq	r2, r6, r5, lsl #12
    1be4:	10d40205 	sbcsne	r0, r4, r5, lsl #4
  if (bit_loc > 31) {
    1be8:	06170000 	ldreq	r0, [r7], -r0
  uint32_t data = reg32(addr);
    1bec:	06030501 	streq	r0, [r3], -r1, lsl #10
  printf("Bit %u @ 0x%08x: %u\n", bit_loc, addr, bit_val);
    1bf0:	0108052f 	tsteq	r8, pc, lsr #10
    1bf4:	01060c05 	tsteq	r6, r5, lsl #24
    1bf8:	05200305 	streq	r0, [r0, #-773]!	@ 0xfffffcfb
  return 0;
    1bfc:	04020033 	streq	r0, [r2], #-51	@ 0xffffffcd
    printf("Error: Invalid bit location argument\n");
    1c00:	05200602 	streq	r0, [r0, #-1538]!	@ 0xfffff9fe
    1c04:	04020029 	streq	r0, [r2], #-41	@ 0xffffffd7
  printf("Usage: %s <address_in_hex(32-bits)> <bit_location_in_decimal(0 to 31)\n", argv[0]);
    1c08:	18052001 	stmdane	r5, {r0, sp}
    1c0c:	01040200 	mrseq	r0, R12_usr
  return -1;
    1c10:	1b050106 	blne	142030 <__ROM_SIZE__+0x102030>
    1c14:	01040200 	mrseq	r0, R12_usr
    1c18:	0029054a 	eoreq	r0, r9, sl, asr #10
    1c1c:	20010402 	andcs	r0, r1, r2, lsl #8
{
    1c20:	21060505 	tstcs	r6, r5, lsl #10
  for (i = 0; i < Nk; ++i)
    1c24:	01060905 	tsteq	r6, r5, lsl #18
    RoundKey[(i * 4) + 0] = Key[(i * 4) + 0];
    1c28:	053c0805 	ldreq	r0, [ip, #-2053]!	@ 0xfffff7fb
    1c2c:	052f0607 	streq	r0, [pc, #-1543]!	@ 162d <sha256_final+0xc5>
    1c30:	05010613 	streq	r0, [r1, #-1555]	@ 0xfffff9ed
    RoundKey[(i * 4) + 1] = Key[(i * 4) + 1];
    1c34:	052e2e16 	streq	r2, [lr, #-3606]!	@ 0xfffff1ea
    RoundKey[(i * 4) + 2] = Key[(i * 4) + 2];
    1c38:	0105150a 	tsteq	r5, sl, lsl #10
    1c3c:	02022021 	andeq	r2, r2, #33	@ 0x21
    RoundKey[(i * 4) + 3] = Key[(i * 4) + 3];
    1c40:	66010100 	strvs	r0, [r1], -r0, lsl #2
  for (i = 0; i < Nk; ++i)
    1c44:	03000004 	movweq	r0, #4
    1c48:	00004c00 	andeq	r4, r0, r0, lsl #24
  for (i = Nk; i < Nb * (Nr + 1); ++i)
    1c4c:	fb010200 	blx	42456 <__ROM_SIZE__+0x2456>
    if (i % Nk == 4)
    1c50:	01000d0e 	tsteq	r0, lr, lsl #26
    j = i * 4; k=(i - Nk) * 4;
    1c54:	00010101 	andeq	r0, r1, r1, lsl #2
    RoundKey[j + 0] = RoundKey[k + 0] ^ tempa[0];
    1c58:	00010000 	andeq	r0, r1, r0
    1c5c:	682f0100 	stmdavs	pc!, {r8}	@ <UNPREDICTABLE>
    1c60:	2f656d6f 	svccs	0x00656d6f
    1c64:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    RoundKey[j + 1] = RoundKey[k + 1] ^ tempa[1];
    1c68:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
    1c6c:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
    1c70:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
    1c74:	6f662f72 	svcvs	0x00662f72
    1c78:	68732f62 	ldmdavs	r3!, {r1, r5, r6, r8, r9, sl, fp, sp}^
    1c7c:	2f6c6c65 	svccs	0x006c6c65
    RoundKey[j + 2] = RoundKey[k + 2] ^ tempa[2];
    1c80:	2f62696c 	svccs	0x0062696c
    1c84:	65736162 	ldrbvs	r6, [r3, #-354]!	@ 0xfffffe9e
    1c88:	00003436 	andeq	r3, r0, r6, lsr r4
    1c8c:	65736162 	ldrbvs	r6, [r3, #-354]!	@ 0xfffffe9e
    RoundKey[j + 3] = RoundKey[k + 3] ^ tempa[3];
    1c90:	632e3436 			@ <UNDEFINED> instruction: 0x632e3436
    1c94:	00000100 	andeq	r0, r0, r0, lsl #2
    1c98:	00310500 	eorseq	r0, r1, r0, lsl #10
  for (i = Nk; i < Nb * (Nr + 1); ++i)
    1c9c:	11040205 	tstne	r4, r5, lsl #4
    1ca0:	05140000 	ldreq	r0, [r4, #-0]
      tempa[0]=RoundKey[k + 0];
    1ca4:	05051403 	streq	r1, [r5, #-1027]	@ 0xfffffbfd
    1ca8:	03050106 	movweq	r0, #20742	@ 0x5106
      tempa[1]=RoundKey[k + 1];
    1cac:	05053106 	streq	r3, [r5, #-262]	@ 0xfffffefa
    1cb0:	03050106 	movweq	r0, #20742	@ 0x5106
    1cb4:	05053106 	streq	r3, [r5, #-262]	@ 0xfffffefa
      tempa[2]=RoundKey[k + 2];
    1cb8:	03050106 	movweq	r0, #20742	@ 0x5106
    1cbc:	05053106 	streq	r3, [r5, #-262]	@ 0xfffffefa
      tempa[3]=RoundKey[k + 3];
    1cc0:	03050106 	movweq	r0, #20742	@ 0x5106
    1cc4:	05053106 	streq	r3, [r5, #-262]	@ 0xfffffefa
    if (i % Nk == 0)
    1cc8:	0a050106 	beq	1420e8 <__ROM_SIZE__+0x1020e8>
        tempa[0] = tempa[1];
    1ccc:	0e052030 	mcreq	0, 0, r2, cr5, cr0, {1}
        tempa[1] = tempa[2];
    1cd0:	01040200 	mrseq	r0, R12_usr
        tempa[2] = tempa[3];
    1cd4:	20720306 	rsbscs	r0, r2, r6, lsl #6
        tempa[3] = u8tmp;
    1cd8:	02001705 	andeq	r1, r0, #1310720	@ 0x140000
        tempa[0] = getSBoxValue(tempa[0]);
    1cdc:	01060104 	tsteq	r6, r4, lsl #2
    1ce0:	01040200 	mrseq	r0, R12_usr
        tempa[1] = getSBoxValue(tempa[1]);
    1ce4:	000e0520 	andeq	r0, lr, r0, lsr #10
    1ce8:	06010402 	streq	r0, [r1], -r2, lsl #8
        tempa[2] = getSBoxValue(tempa[2]);
    1cec:	00170531 	andseq	r0, r7, r1, lsr r5
    1cf0:	06010402 	streq	r0, [r1], -r2, lsl #8
        tempa[3] = getSBoxValue(tempa[3]);
    1cf4:	04020001 	streq	r0, [r2], #-1
    1cf8:	0e052001 	cdpeq	0, 0, cr2, cr5, cr1, {0}
      tempa[0] = tempa[0] ^ Rcon[i/Nk];
    1cfc:	01040200 	mrseq	r0, R12_usr
    1d00:	17053106 	strne	r3, [r5, -r6, lsl #2]
    1d04:	01040200 	mrseq	r0, R12_usr
    1d08:	02000106 	andeq	r0, r0, #-2147483647	@ 0x80000001
        tempa[0] = getSBoxValue(tempa[0]);
    1d0c:	05200104 	streq	r0, [r0, #-260]!	@ 0xfffffefc
    1d10:	23203116 			@ <UNDEFINED> instruction: 0x23203116
    1d14:	05230105 	streq	r0, [r3, #-261]!	@ 0xfffffefb
        tempa[1] = getSBoxValue(tempa[1]);
    1d18:	06220631 			@ <UNDEFINED> instruction: 0x06220631
    1d1c:	06030501 	streq	r0, [r3], -r1, lsl #10
        tempa[2] = getSBoxValue(tempa[2]);
    1d20:	060f0522 	streq	r0, [pc], -r2, lsr #10
    1d24:	05052001 	streq	r2, [r5, #-1]
    1d28:	06030520 	streq	r0, [r3], -r0, lsr #10
        tempa[3] = getSBoxValue(tempa[3]);
    1d2c:	060f0531 			@ <UNDEFINED> instruction: 0x060f0531
    1d30:	3c050501 	cfstr32cc	mvfx0, [r5], {1}
    1d34:	31060305 	tstcc	r6, r5, lsl #6
}
    1d38:	01060f05 	tsteq	r6, r5, lsl #30
    1d3c:	053c0505 	ldreq	r0, [ip, #-1285]!	@ 0xfffffafb
{
    1d40:	05310603 	ldreq	r0, [r1, #-1539]!	@ 0xfffff9fd
  for (i = 0; i < 4; ++i)
    1d44:	05010605 	streq	r0, [r1, #-1541]	@ 0xfffff9fb
      (*state)[i][j] ^= RoundKey[(round * Nb * 4) + (i * Nb) + j];
    1d48:	05310603 	ldreq	r0, [r1, #-1539]!	@ 0xfffff9fd
    1d4c:	05010605 	streq	r0, [r1, #-1541]	@ 0xfffff9fb
    1d50:	1c05300a 	stcne	0, cr3, [r5], {10}
    1d54:	01040200 	mrseq	r0, R12_usr
    1d58:	2e750306 	cdpcs	3, 7, cr0, cr5, cr6, {0}
    1d5c:	02002505 	andeq	r2, r0, #20971520	@ 0x1400000
    1d60:	01060104 	tsteq	r6, r4, lsl #2
    for (j = 0; j < 4; ++j)
    1d64:	02001c05 	andeq	r1, r0, #1280	@ 0x500
    1d68:	3f060104 	svccc	0x00060104
  for (i = 0; i < 4; ++i)
    1d6c:	02002505 	andeq	r2, r0, #20971520	@ 0x1400000
    1d70:	01060104 	tsteq	r6, r4, lsl #2
    for (j = 0; j < 4; ++j)
    1d74:	313f1705 	teqcc	pc, r5, lsl #14
  for (i = 0; i < 4; ++i)
    1d78:	05230105 	streq	r0, [r3, #-261]!	@ 0xfffffefb
    1d7c:	0522063e 	streq	r0, [r2, #-1598]!	@ 0xfffff9c2
    for (j = 0; j < 4; ++j)
    1d80:	18051303 	stmdane	r5, {r0, r1, r8, r9, ip}
{
    1d84:	1c050106 	stfnes	f0, [r5], {6}
      (*state)[j][i] = getSBoxValue((*state)[j][i]);
    1d88:	01053c20 	tsteq	r5, r0, lsr #24
    1d8c:	06550521 	ldrbeq	r0, [r5], -r1, lsr #10
    1d90:	0501065a 	streq	r0, [r1, #-1626]	@ 0xfffff9a6
    1d94:	143d0603 	ldrtne	r0, [sp], #-1539	@ 0xfffff9fd
    for (j = 0; j < 4; ++j)
    1d98:	01060805 	tsteq	r6, r5, lsl #16
    1d9c:	2f060505 	svccs	0x00060505
  for (i = 0; i < 4; ++i)
    1da0:	051f2905 	ldreq	r2, [pc, #-2309]	@ 14a3 <sha256_transform+0x143>
    1da4:	05010609 	streq	r0, [r1, #-1545]	@ 0xfffff9f7
    for (j = 0; j < 4; ++j)
    1da8:	42053c29 	andmi	r3, r5, #10496	@ 0x2900
}
    1dac:	01040200 	mrseq	r0, R12_usr
  for (i = 0; i < 4; ++i)
    1db0:	0029052e 	eoreq	r0, r9, lr, lsr #10
    1db4:	20010402 	andcs	r0, r1, r2, lsl #8
    1db8:	32060305 	andcc	r0, r6, #335544320	@ 0x14000000
  temp           = (*state)[0][1];
    1dbc:	01061805 	tsteq	r6, r5, lsl #16
  (*state)[0][1] = (*state)[1][1];
    1dc0:	21060305 	tstcs	r6, r5, lsl #6
  (*state)[1][1] = (*state)[2][1];
    1dc4:	01061605 	tsteq	r6, r5, lsl #12
  (*state)[2][1] = (*state)[3][1];
    1dc8:	05201805 	streq	r1, [r0, #-2053]!	@ 0xfffff7fb
  temp           = (*state)[0][2];
    1dcc:	002e2e46 	eoreq	r2, lr, r6, asr #28
  (*state)[0][2] = (*state)[2][2];
    1dd0:	20010402 	andcs	r0, r1, r2, lsl #8
  temp           = (*state)[1][2];
    1dd4:	02000105 	andeq	r0, r0, #1073741825	@ 0x40000001
  (*state)[1][2] = (*state)[3][2];
    1dd8:	05210404 	streq	r0, [r1, #-1028]!	@ 0xfffffbfc
  temp           = (*state)[0][3];
    1ddc:	66052d46 	strvs	r2, [r5], -r6, asr #26
  (*state)[0][3] = (*state)[3][3];
    1de0:	02050006 	andeq	r0, r5, #6
  (*state)[3][3] = (*state)[2][3];
    1de4:	000011bc 			@ <UNDEFINED> instruction: 0x000011bc
  (*state)[2][3] = (*state)[1][3];
    1de8:	05010615 	streq	r0, [r1, #-1557]	@ 0xfffff9eb
}
    1dec:	05590603 	ldrbeq	r0, [r9, #-1539]	@ 0xfffff9fd
  return ((x<<1) ^ (((x>>7) & 1) * 0x1b));
    1df0:	05010610 	streq	r0, [r1, #-1552]	@ 0xfffff9f0
    1df4:	054d0603 	strbeq	r0, [sp, #-1539]	@ 0xfffff9fd
    1df8:	14050107 	strne	r0, [r5], #-263	@ 0xfffffef9
}
    1dfc:	03050106 	movweq	r0, #20742	@ 0x5106
{
    1e00:	00050520 	andeq	r0, r5, r0, lsr #10
    1e04:	06030402 	streq	r0, [r3], -r2, lsl #8
  for (i = 0; i < 4; ++i)
    1e08:	00400521 	subeq	r0, r0, r1, lsr #10
    t   = (*state)[i][0];
    1e0c:	06030402 	streq	r0, [r3], -r2, lsl #8
    Tmp = (*state)[i][0] ^ (*state)[i][1] ^ (*state)[i][2] ^ (*state)[i][3] ;
    1e10:	00110501 	andseq	r0, r1, r1, lsl #10
    1e14:	20030402 	andcs	r0, r3, r2, lsl #8
    1e18:	02000f05 	andeq	r0, r0, #5, 30
    1e1c:	053c0304 	ldreq	r0, [ip, #-772]!	@ 0xfffffcfc
    1e20:	04020005 	streq	r0, [r2], #-5
    1e24:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
    Tm  = (*state)[i][0] ^ (*state)[i][1] ; Tm = xtime(Tm);  (*state)[i][0] ^= Tm ^ Tmp ;
    1e28:	04020028 	streq	r0, [r2], #-40	@ 0xffffffd8
    1e2c:	05010603 	streq	r0, [r1, #-1539]	@ 0xfffff9fd
    1e30:	04020034 	streq	r0, [r2], #-52	@ 0xffffffcc
    Tm  = (*state)[i][1] ^ (*state)[i][2] ; Tm = xtime(Tm);  (*state)[i][1] ^= Tm ^ Tmp ;
    1e34:	40052003 	andmi	r2, r5, r3
    1e38:	03040200 	movweq	r0, #16896	@ 0x4200
    1e3c:	0011053c 	andseq	r0, r1, ip, lsr r5
    1e40:	20030402 	andcs	r0, r3, r2, lsl #8
    1e44:	02000f05 	andeq	r0, r0, #5, 30
    Tm  = (*state)[i][2] ^ (*state)[i][3] ; Tm = xtime(Tm);  (*state)[i][2] ^= Tm ^ Tmp ;
    1e48:	054a0304 	strbeq	r0, [sl, #-772]	@ 0xfffffcfc
    1e4c:	04020005 	streq	r0, [r2], #-5
    1e50:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
    1e54:	04020028 	streq	r0, [r2], #-40	@ 0xffffffd8
    Tm  = (*state)[i][3] ^ t ;              Tm = xtime(Tm);  (*state)[i][3] ^= Tm ^ Tmp ;
    1e58:	05010603 	streq	r0, [r1, #-1539]	@ 0xfffff9fd
    1e5c:	04020034 	streq	r0, [r2], #-52	@ 0xffffffcc
    1e60:	40052003 	andmi	r2, r5, r3
    1e64:	03040200 	movweq	r0, #16896	@ 0x4200
    1e68:	0011053c 	andseq	r0, r1, ip, lsr r5
  for (i = 0; i < 4; ++i)
    1e6c:	20030402 	andcs	r0, r3, r2, lsl #8
    1e70:	02000f05 	andeq	r0, r0, #5, 30
}
    1e74:	054a0304 	strbeq	r0, [sl, #-772]	@ 0xfffffcfc
{
    1e78:	04020005 	streq	r0, [r2], #-5
    1e7c:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
  for (i = 0; i < 4; ++i)
    1e80:	04020028 	streq	r0, [r2], #-40	@ 0xffffffd8
    a = (*state)[i][0];
    1e84:	05010603 	streq	r0, [r1, #-1539]	@ 0xfffff9fd
    b = (*state)[i][1];
    1e88:	04020011 	streq	r0, [r2], #-17	@ 0xffffffef
    1e8c:	0f052003 	svceq	0x00052003
    c = (*state)[i][2];
    1e90:	03040200 	movweq	r0, #16896	@ 0x4200
    d = (*state)[i][3];
    1e94:	0005054a 	andeq	r0, r5, sl, asr #10
    (*state)[i][0] = Multiply(a, 0x0e) ^ Multiply(b, 0x0b) ^ Multiply(c, 0x0d) ^ Multiply(d, 0x09);
    1e98:	06030402 	streq	r0, [r3], -r2, lsl #8
    1e9c:	000b0522 	andeq	r0, fp, r2, lsr #10
    1ea0:	06030402 	streq	r0, [r3], -r2, lsl #8
    1ea4:	00050501 	andeq	r0, r5, r1, lsl #10
    1ea8:	06030402 	streq	r0, [r3], -r2, lsl #8
    1eac:	000c0521 	andeq	r0, ip, r1, lsr #10
    1eb0:	06030402 	streq	r0, [r3], -r2, lsl #8
    1eb4:	002a0501 	eoreq	r0, sl, r1, lsl #10
    1eb8:	06030402 	streq	r0, [r3], -r2, lsl #8
    1ebc:	05207903 	streq	r7, [r0, #-2307]!	@ 0xfffff6fd
    1ec0:	0402001d 	streq	r0, [r2], #-29	@ 0xffffffe3
    1ec4:	02002001 	andeq	r2, r0, #1
    1ec8:	2e060104 	adfcss	f0, f6, f4
    1ecc:	03060305 	movweq	r0, #25349	@ 0x6305
    1ed0:	1705010a 	strne	r0, [r5, -sl, lsl #2]
    1ed4:	03050106 	movweq	r0, #20742	@ 0x5106
    1ed8:	14030690 	strne	r0, [r3], #-1680	@ 0xfffff970
    1edc:	060a0558 			@ <UNDEFINED> instruction: 0x060a0558
    1ee0:	3d010501 	cfstr32cc	mvfx0, [r1, #-4]
    1ee4:	03060705 	movweq	r0, #26373	@ 0x6705
    1ee8:	11052e6d 	tstne	r5, sp, ror #28
    1eec:	07050106 	streq	r0, [r5, -r6, lsl #2]
    1ef0:	05222106 	streq	r2, [r2, #-262]!	@ 0xfffffefa
    1ef4:	05010642 	streq	r0, [r1, #-1602]	@ 0xfffff9be
    1ef8:	11052013 	tstne	r5, r3, lsl r0
    1efc:	0607053c 			@ <UNDEFINED> instruction: 0x0607053c
    1f00:	062a0521 	strteq	r0, [sl], -r1, lsr #10
    1f04:	20360501 	eorscs	r0, r6, r1, lsl #10
    1f08:	05201305 	streq	r1, [r0, #-773]!	@ 0xfffffcfb
    1f0c:	07054a11 	smladeq	r5, r1, sl, r4
    1f10:	11052106 	tstne	r5, r6, lsl #2
    1f14:	07050106 	streq	r0, [r5, -r6, lsl #2]
    1f18:	11052f06 	tstne	r5, r6, lsl #30
    1f1c:	07050106 	streq	r0, [r5, -r6, lsl #2]
    1f20:	11052106 	tstne	r5, r6, lsl #2
    1f24:	07050106 	streq	r0, [r5, -r6, lsl #2]
    (*state)[i][1] = Multiply(a, 0x09) ^ Multiply(b, 0x0e) ^ Multiply(c, 0x0b) ^ Multiply(d, 0x0d);
    1f28:	05222f06 	streq	r2, [r2, #-3846]!	@ 0xfffff0fa
    1f2c:	05010642 	streq	r0, [r1, #-1602]	@ 0xfffff9be
    1f30:	11052013 	tstne	r5, r3, lsl r0
    1f34:	0607053c 			@ <UNDEFINED> instruction: 0x0607053c
    1f38:	062a0521 	strteq	r0, [sl], -r1, lsr #10
    1f3c:	20360501 	eorscs	r0, r6, r1, lsl #10
    1f40:	053c4205 	ldreq	r4, [ip, #-517]!	@ 0xfffffdfb
    1f44:	11052013 	tstne	r5, r3, lsl r0
    1f48:	0607054a 	streq	r0, [r7], -sl, asr #10
    1f4c:	062a0521 	strteq	r0, [sl], -r1, lsr #10
    1f50:	20360501 	eorscs	r0, r6, r1, lsl #10
    1f54:	05201305 	streq	r1, [r0, #-773]!	@ 0xfffffcfb
    1f58:	07054a11 	smladeq	r5, r1, sl, r4
    1f5c:	11052106 	tstne	r5, r6, lsl #2
    (*state)[i][2] = Multiply(a, 0x0d) ^ Multiply(b, 0x09) ^ Multiply(c, 0x0e) ^ Multiply(d, 0x0b);
    1f60:	07050106 	streq	r0, [r5, -r6, lsl #2]
    1f64:	11052f06 	tstne	r5, r6, lsl #30
    1f68:	07050106 	streq	r0, [r5, -r6, lsl #2]
    1f6c:	66052f06 	strvs	r2, [r5], -r6, lsl #30
    1f70:	a4020500 	strge	r0, [r2], #-1280	@ 0xfffffb00
    1f74:	19000012 	stmdbne	r0, {r1, r4}
    1f78:	03050106 	movweq	r0, #20742	@ 0x5106
    1f7c:	20054b06 	andcs	r4, r5, r6, lsl #22
    1f80:	052e0106 	streq	r0, [lr, #-262]!	@ 0xfffffefa
    1f84:	05230603 	streq	r0, [r3, #-1539]!	@ 0xfffff9fd
    1f88:	14050107 	strne	r0, [r5], #-263	@ 0xfffffef9
    1f8c:	03050106 	movweq	r0, #20742	@ 0x5106
    (*state)[i][3] = Multiply(a, 0x0b) ^ Multiply(b, 0x0d) ^ Multiply(c, 0x09) ^ Multiply(d, 0x0e);
    1f90:	00050520 	andeq	r0, r5, r0, lsr #10
    1f94:	06030402 	streq	r0, [r3], -r2, lsl #8
    1f98:	00110521 	andseq	r0, r1, r1, lsr #10
    1f9c:	06030402 	streq	r0, [r3], -r2, lsl #8
    1fa0:	002c0501 	eoreq	r0, ip, r1, lsl #10
    1fa4:	3c030402 	cfstrscc	mvf0, [r3], {2}
    1fa8:	02003305 	andeq	r3, r0, #335544320	@ 0x14000000
    1fac:	05200304 	streq	r0, [r0, #-772]!	@ 0xfffffcfc
    1fb0:	04020031 	streq	r0, [r2], #-49	@ 0xffffffcf
    1fb4:	0f053c03 	svceq	0x00053c03
    1fb8:	03040200 	movweq	r0, #16896	@ 0x4200
    1fbc:	0005052e 	andeq	r0, r5, lr, lsr #10
    1fc0:	06030402 	streq	r0, [r3], -r2, lsl #8
  for (i = 0; i < 4; ++i)
    1fc4:	00110521 	andseq	r0, r1, r1, lsr #10
    1fc8:	06030402 	streq	r0, [r3], -r2, lsl #8
}
    1fcc:	002c0501 	eoreq	r0, ip, r1, lsl #10
  for (i = 0; i < 4; ++i)
    1fd0:	3c030402 	cfstrscc	mvf0, [r3], {2}
    1fd4:	02003305 	andeq	r3, r0, #335544320	@ 0x14000000
    for (j = 0; j < 4; ++j)
    1fd8:	05200304 	streq	r0, [r0, #-772]!	@ 0xfffffcfc
{
    1fdc:	04020031 	streq	r0, [r2], #-49	@ 0xffffffcf
      (*state)[j][i] = getSBoxInvert((*state)[j][i]);
    1fe0:	0f053c03 	svceq	0x00053c03
    1fe4:	03040200 	movweq	r0, #16896	@ 0x4200
    1fe8:	0005052e 	andeq	r0, r5, lr, lsr #10
    1fec:	06030402 	streq	r0, [r3], -r2, lsl #8
    1ff0:	00110521 	andseq	r0, r1, r1, lsr #10
    for (j = 0; j < 4; ++j)
    1ff4:	06030402 	streq	r0, [r3], -r2, lsl #8
    1ff8:	002c0501 	eoreq	r0, ip, r1, lsl #10
  for (i = 0; i < 4; ++i)
    1ffc:	3c030402 	cfstrscc	mvf0, [r3], {2}
    2000:	02003305 	andeq	r3, r0, #335544320	@ 0x14000000
    for (j = 0; j < 4; ++j)
    2004:	05200304 	streq	r0, [r0, #-772]!	@ 0xfffffcfc
}
    2008:	04020031 	streq	r0, [r2], #-49	@ 0xffffffcf
  for (i = 0; i < 4; ++i)
    200c:	0f053c03 	svceq	0x00053c03
    2010:	03040200 	movweq	r0, #16896	@ 0x4200
    2014:	00050520 	andeq	r0, r5, r0, lsr #10
  temp = (*state)[3][1];
    2018:	06030402 	streq	r0, [r3], -r2, lsl #8
  (*state)[3][1] = (*state)[2][1];
    201c:	000b0522 	andeq	r0, fp, r2, lsr #10
  (*state)[2][1] = (*state)[1][1];
    2020:	06030402 	streq	r0, [r3], -r2, lsl #8
  (*state)[1][1] = (*state)[0][1];
    2024:	00050501 	andeq	r0, r5, r1, lsl #10
  temp = (*state)[0][2];
    2028:	06030402 	streq	r0, [r3], -r2, lsl #8
  (*state)[0][2] = (*state)[2][2];
    202c:	000c0521 	andeq	r0, ip, r1, lsr #10
  temp = (*state)[1][2];
    2030:	06030402 	streq	r0, [r3], -r2, lsl #8
  (*state)[1][2] = (*state)[3][2];
    2034:	00300501 	eorseq	r0, r0, r1, lsl #10
  temp = (*state)[0][3];
    2038:	06030402 	streq	r0, [r3], -r2, lsl #8
  (*state)[0][3] = (*state)[1][3];
    203c:	05207a03 	streq	r7, [r0, #-2563]!	@ 0xfffff5fd
  (*state)[1][3] = (*state)[2][3];
    2040:	0402001d 	streq	r0, [r2], #-29	@ 0xffffffe3
  (*state)[2][3] = (*state)[3][3];
    2044:	02002001 	andeq	r2, r0, #1
}
    2048:	2e060104 	adfcss	f0, f6, f4
{
    204c:	03060305 	movweq	r0, #25349	@ 0x6305
  AddRoundKey(0, state, RoundKey);
    2050:	18050109 	stmdane	r5, {r0, r3, r8}
    2054:	03050106 	movweq	r0, #20742	@ 0x5106
    2058:	03010590 	movweq	r0, #5520	@ 0x1590
  for (round = 1; ; ++round)
    205c:	07054a0b 	streq	r4, [r5, -fp, lsl #20]
    MixColumns(state);
    2060:	3c770306 	ldclcc	3, cr0, [r7], #-24	@ 0xffffffe8
    AddRoundKey(round, state, RoundKey);
    2064:	01061305 	tsteq	r6, r5, lsl #6
    2068:	053c2e05 	ldreq	r2, [ip, #-3589]!	@ 0xfffff1fb
    206c:	33052035 	movwcc	r2, #20533	@ 0x5035
  for (round = 1; ; ++round)
    2070:	2e11053c 	mrccs	5, 0, r0, cr1, cr12, {1}
    SubBytes(state);
    2074:	21060705 	tstcs	r6, r5, lsl #14
    ShiftRows(state);
    2078:	06130522 	ldreq	r0, [r3], -r2, lsr #10
    207c:	3c2e0501 	cfstr32cc	mvfx0, [lr], #-4
    if (round == Nr) {
    2080:	05203505 	streq	r3, [r0, #-1285]!	@ 0xfffffafb
  AddRoundKey(Nr, state, RoundKey);
    2084:	11053c33 	tstne	r5, r3, lsr ip
    2088:	0607052e 	streq	r0, [r7], -lr, lsr #10
}
    208c:	06130521 	ldreq	r0, [r3], -r1, lsr #10
{
    2090:	3c2e0501 	cfstr32cc	mvfx0, [lr], #-4
  AddRoundKey(Nr, state, RoundKey);
    2094:	05203505 	streq	r3, [r0, #-1285]!	@ 0xfffffafb
    2098:	11053c33 	tstne	r5, r3, lsr ip
    209c:	0607052e 	streq	r0, [r7], -lr, lsr #10
  for (round = (Nr - 1); ; --round)
    20a0:	15030521 	strne	r0, [r3, #-1313]	@ 0xfffffadf
    InvMixColumns(state);
    20a4:	01060a05 	tsteq	r6, r5, lsl #20
  for (round = (Nr - 1); ; --round)
    20a8:	01000402 	tsteq	r0, r2, lsl #8
    InvShiftRows(state);
    20ac:	0005fc01 	andeq	pc, r5, r1, lsl #24
    20b0:	d9000300 	stmdble	r0, {r8, r9}
    InvSubBytes(state);
    20b4:	02000000 	andeq	r0, r0, #0
    AddRoundKey(round, state, RoundKey);
    20b8:	0d0efb01 	vstreq	d15, [lr, #-4]
    20bc:	01010100 	mrseq	r0, (UNDEF: 17)
    20c0:	00000001 	andeq	r0, r0, r1
    if (round == 0) {
    20c4:	01000001 	tsteq	r0, r1
  for (i = 0; i < AES_BLOCKLEN; ++i) // The block in AES is always 128bit no matter the key size
    20c8:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 2014 <InvSubBytes+0x44>
    buf[i] ^= Iv[i];
    20cc:	63652f65 	cmnvs	r5, #404	@ 0x194
    20d0:	652f6674 	strvs	r6, [pc, #-1652]!	@ 1a64 <printf2+0x80>
    20d4:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
  for (i = 0; i < AES_BLOCKLEN; ++i) // The block in AES is always 128bit no matter the key size
    20d8:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
    20dc:	2f72656e 	svccs	0x0072656e
}
    20e0:	2f626f66 	svccs	0x00626f66
  KeyExpansion(ctx->RoundKey, key);
    20e4:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
}
    20e8:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
{
    20ec:	68732f62 	ldmdavs	r3!, {r1, r5, r6, r8, r9, sl, fp, sp}^
  KeyExpansion(ctx->RoundKey, key);
    20f0:	36353261 	ldrtcc	r3, [r5], -r1, ror #4
  memcpy (ctx->Iv, iv, AES_BLOCKLEN);
    20f4:	706f2f00 	rsbvc	r2, pc, r0, lsl #30
    20f8:	63672f74 	cmnvs	r7, #116, 30	@ 0x1d0
    20fc:	72612d63 	rsbvc	r2, r1, #6336	@ 0x18c0
}
    2100:	6f6e2d6d 	svcvs	0x006e2d6d
  memcpy (ctx->Iv, iv, AES_BLOCKLEN);
    2104:	652d656e 	strvs	r6, [sp, #-1390]!	@ 0xfffffa92
    2108:	2f696261 	svccs	0x00696261
}
    210c:	2f62696c 	svccs	0x0062696c
{
    2110:	2f636367 	svccs	0x00636367
  Cipher((state_t*)buf, ctx->RoundKey);
    2114:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	@ 0xfffffe7c
    2118:	656e6f6e 	strbvs	r6, [lr, #-3950]!	@ 0xfffff092
{
    211c:	6261652d 	rsbvs	r6, r1, #188743680	@ 0xb400000
  InvCipher((state_t*)buf, ctx->RoundKey);
    2120:	32312f69 	eorscc	r2, r1, #420	@ 0x1a4
    2124:	312e322e 			@ <UNDEFINED> instruction: 0x312e322e
}
    2128:	636e692f 	cmnvs	lr, #770048	@ 0xbc000
{
    212c:	6564756c 	strbvs	r7, [r4, #-1388]!	@ 0xfffffa94
    2130:	6f682f00 	svcvs	0x00682f00
  uint8_t *Iv = ctx->Iv;
    2134:	652f656d 	strvs	r6, [pc, #-1389]!	@ 1bcf <w32_bit+0x67>
    2138:	2f667463 	svccs	0x00667463
  for (i = 0; i < length; i += AES_BLOCKLEN)
    213c:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    XorWithIv(buf, Iv);
    2140:	6172742d 	cmnvs	r2, sp, lsr #8
    Cipher((state_t*)buf, ctx->RoundKey);
    2144:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
    2148:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
  for (i = 0; i < length; i += AES_BLOCKLEN)
    214c:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
    buf += AES_BLOCKLEN;
    2150:	6c2f6c6c 	stcvs	12, cr6, [pc], #-432	@ 1fa8 <InvMixColumns+0x132>
  for (i = 0; i < length; i += AES_BLOCKLEN)
    2154:	732f6269 			@ <UNDEFINED> instruction: 0x732f6269
  memcpy(ctx->Iv, Iv, AES_BLOCKLEN);
    2158:	6e697274 	mcrvs	2, 3, r7, cr9, cr4, {3}
    215c:	73000067 	movwvc	r0, #103	@ 0x67
}
    2160:	35326168 	ldrcc	r6, [r2, #-360]!	@ 0xfffffe98
{
    2164:	00632e36 	rsbeq	r2, r3, r6, lsr lr
    2168:	73000001 	movwvc	r0, #1
    216c:	65646474 	strbvs	r6, [r4, #-1140]!	@ 0xfffffb8c
  for (i = 0; i < length; i += AES_BLOCKLEN)
    2170:	00682e66 	rsbeq	r2, r8, r6, ror #28
    memcpy(storeNextIv, buf, AES_BLOCKLEN);
    2174:	73000002 	movwvc	r0, #2
    2178:	35326168 	ldrcc	r6, [r2, #-360]!	@ 0xfffffe98
    InvCipher((state_t*)buf, ctx->RoundKey);
    217c:	00682e36 	rsbeq	r2, r8, r6, lsr lr
    2180:	73000001 	movwvc	r0, #1
    XorWithIv(buf, ctx->Iv);
    2184:	6e697274 	mcrvs	2, 3, r7, cr9, cr4, {3}
    2188:	00682e67 	rsbeq	r2, r8, r7, ror #28
    218c:	00000003 	andeq	r0, r0, r3
    memcpy(ctx->Iv, storeNextIv, AES_BLOCKLEN);
    2190:	05000105 	streq	r0, [r0, #-261]	@ 0xfffffefb
    2194:	00136002 	andseq	r6, r3, r2
    2198:	012c0300 			@ <UNDEFINED> instruction: 0x012c0300
  for (i = 0; i < length; i += AES_BLOCKLEN)
    219c:	02050106 	andeq	r0, r5, #-2147483647	@ 0x80000001
    21a0:	05144b06 	ldreq	r4, [r4, #-2822]	@ 0xfffff4fa
}
    21a4:	05010610 	streq	r0, [r1, #-1552]	@ 0xfffff9f0
{
    21a8:	02052009 	andeq	r2, r5, #9
    21ac:	00030520 	andeq	r0, r3, r0, lsr #10
    21b0:	06030402 	streq	r0, [r3], -r2, lsl #8
  for (i = 0, bi = AES_BLOCKLEN; i < length; ++i, ++bi)
    21b4:	000f0521 	andeq	r0, pc, r1, lsr #10
          ctx->Iv[bi] = 0;
    21b8:	06030402 	streq	r0, [r3], -r2, lsl #8
    21bc:	00210501 	eoreq	r0, r1, r1, lsl #10
      for (bi = (AES_BLOCKLEN - 1); bi >= 0; --bi)
    21c0:	20030402 	andcs	r0, r3, r2, lsl #8
      bi = 0;
    21c4:	02002905 	andeq	r2, r0, #81920	@ 0x14000
    buf[i] = (buf[i] ^ buffer[bi]);
    21c8:	052e0304 	streq	r0, [lr, #-772]!	@ 0xfffffcfc
    21cc:	0402001a 	streq	r0, [r2], #-26	@ 0xffffffe6
    21d0:	37052003 	strcc	r2, [r5, -r3]
    21d4:	03040200 	movweq	r0, #16896	@ 0x4200
    21d8:	0030052e 	eorseq	r0, r0, lr, lsr #10
  for (i = 0, bi = AES_BLOCKLEN; i < length; ++i, ++bi)
    21dc:	20030402 	andcs	r0, r3, r2, lsl #8
    21e0:	02004c05 	andeq	r4, r0, #1280	@ 0x500
    if (bi == AES_BLOCKLEN) /* we need to regen xor compliment in buffer */
    21e4:	052e0304 	streq	r0, [lr, #-772]!	@ 0xfffffcfc
      memcpy(buffer, ctx->Iv, AES_BLOCKLEN);
    21e8:	04020045 	streq	r0, [r2], #-69	@ 0xffffffbb
    21ec:	08052003 	stmdaeq	r5, {r0, r1, sp}
    21f0:	03040200 	movweq	r0, #16896	@ 0x4200
      Cipher((state_t*)buffer,ctx->RoundKey);
    21f4:	00200520 	eoreq	r0, r0, r0, lsr #10
    21f8:	06030402 	streq	r0, [r3], -r2, lsl #8
      for (bi = (AES_BLOCKLEN - 1); bi >= 0; --bi)
    21fc:	001d053b 	andseq	r0, sp, fp, lsr r5
    2200:	06030402 	streq	r0, [r3], -r2, lsl #8
        if (ctx->Iv[bi] == 255)
    2204:	00240501 	eoreq	r0, r4, r1, lsl #10
    2208:	20030402 	andcs	r0, r3, r2, lsl #8
        ctx->Iv[bi] += 1;
    220c:	02001705 	andeq	r1, r0, #1310720	@ 0x140000
    2210:	20060104 	andcs	r0, r6, r4, lsl #2
      bi = 0;
    2214:	02000305 	andeq	r0, r0, #335544320	@ 0x14000000
}
    2218:	053f0204 	ldreq	r0, [pc, #-516]!	@ 201c <InvShiftRows+0x4>
  return ((x[idx / 32U] >> (idx & 31U) & 1U));
    221c:	0402000a 	streq	r0, [r2], #-10
    2220:	05010602 	streq	r0, [r1, #-1538]	@ 0xfffff9fe
    2224:	0402001f 	streq	r0, [r2], #-31	@ 0xffffffe1
}
    2228:	1c059e02 	stcne	14, cr9, [r5], {2}
    222c:	02040200 	andeq	r0, r4, #0, 4
  x[idx / 32U] &= ~(1U << (idx & 31U));
    2230:	00190520 	andseq	r0, r9, r0, lsr #10
    2234:	3c020402 	cfstrscc	mvf0, [r2], {2}
    2238:	02002605 	andeq	r2, r0, #5242880	@ 0x500000
    223c:	05200204 	streq	r0, [r0, #-516]!	@ 0xfffffdfc
    2240:	04020024 	streq	r0, [r2], #-36	@ 0xffffffdc
    2244:	3c059e02 	stccc	14, cr9, [r5], {2}
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2248:	02040200 	andeq	r0, r4, #0, 4
    x[i] = y[i];
    224c:	00390520 	eorseq	r0, r9, r0, lsr #10
    2250:	2e020402 	cdpcs	4, 0, cr0, cr2, cr2, {0}
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2254:	02003605 	andeq	r3, r0, #5242880	@ 0x500000
    2258:	053c0204 	ldreq	r0, [ip, #-516]!	@ 0xfffffdfc
{
    225c:	04020008 	streq	r0, [r2], #-8
    2260:	12052002 	andne	r2, r5, #2
  bitvec_copy(tmp, x);
    2264:	02040200 	andeq	r0, r4, #0, 4
    2268:	0c052d06 	stceq	13, cr2, [r5], {6}
  bitvec_copy(x, y);
    226c:	01040200 	mrseq	r0, R12_usr
    2270:	31020520 	tstcc	r2, r0, lsr #10
  bitvec_copy(y, tmp);
    2274:	01060405 	tsteq	r6, r5, lsl #8
    2278:	2f060205 	svccs	0x00060205
}
    227c:	01060405 	tsteq	r6, r5, lsl #8
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2280:	2f060205 	svccs	0x00060205
    2284:	01060405 	tsteq	r6, r5, lsl #8
    if (x[i] != y[i])
    2288:	2f060205 	svccs	0x00060205
    228c:	01060405 	tsteq	r6, r5, lsl #8
    2290:	2f060205 	svccs	0x00060205
  for (i = 0; i < BITVEC_NWORDS; ++i)
    2294:	01060405 	tsteq	r6, r5, lsl #8
  return 1;
    2298:	0602052e 	streq	r0, [r2], -lr, lsr #10
}
    229c:	06040521 	streq	r0, [r4], -r1, lsr #10
  for (i = 0; i < BITVEC_NWORDS; ++i)
    22a0:	06020501 	streq	r0, [r2], -r1, lsl #10
    x[i] = 0;
    22a4:	0604053d 			@ <UNDEFINED> instruction: 0x0604053d
  for (i = 0; i < BITVEC_NWORDS; ++i)
    22a8:	06020501 	streq	r0, [r2], -r1, lsl #10
    22ac:	0604053d 			@ <UNDEFINED> instruction: 0x0604053d
  uint32_t i = 0;
    22b0:	06020501 	streq	r0, [r2], -r1, lsl #10
  while (i < BITVEC_NWORDS)
    22b4:	0604053e 			@ <UNDEFINED> instruction: 0x0604053e
    if (x[i] != 0)
    22b8:	1f1f1c10 	svcne	0x001f1c10
    i += 1;
    22bc:	0309051f 	movweq	r0, #38175	@ 0x951f
}
    22c0:	05202009 	streq	r2, [r0, #-9]!
    22c4:	03055802 	movweq	r5, #22530	@ 0x5802
    22c8:	03040200 	movweq	r0, #16896	@ 0x4200
  x += BITVEC_NWORDS;
    22cc:	0c052106 	stfeqs	f2, [r5], {6}
          && (*(--x)) == 0)
    22d0:	03040200 	movweq	r0, #16896	@ 0x4200
    22d4:	0a050106 	beq	1426f4 <__ROM_SIZE__+0x1026f4>
    22d8:	03040200 	movweq	r0, #16896	@ 0x4200
    i -= 32;
    22dc:	00150566 	andseq	r0, r5, r6, ror #10
  if (i != 0)
    22e0:	20030402 	andcs	r0, r3, r2, lsl #8
      i -= 1;
    22e4:	03040200 	movweq	r0, #16896	@ 0x4200
    while (((*x) & u32mask) == 0)
    22e8:	0013052e 	andseq	r0, r3, lr, lsr #10
}
    22ec:	4a030402 	bmi	c32fc <__ROM_SIZE__+0x832fc>
    uint32_t u32mask = ((uint32_t)1 << 31);
    22f0:	02002205 	andeq	r2, r0, #1342177280	@ 0x50000000
{
    22f4:	05200304 	streq	r0, [r0, #-772]!	@ 0xfffffcfc
  int nwords = (nbits / 32);
    22f8:	0402001f 	streq	r0, [r2], #-31	@ 0xffffffe1
    22fc:	29053c03 	stmdbcs	r5, {r0, r1, sl, fp, ip, sp}
  for (i = 0; i < nwords; ++i)
    2300:	03040200 	movweq	r0, #16896	@ 0x4200
  int nwords = (nbits / 32);
    2304:	0006052e 	andeq	r0, r6, lr, lsr #10
    2308:	3c030402 	cfstrscc	mvf0, [r3], {2}
    x[i] = 0;
    230c:	02000305 	andeq	r0, r0, #335544320	@ 0x14000000
  for (i = 0; i < nwords; ++i)
    2310:	21060304 	tstcs	r6, r4, lsl #6
    2314:	02000805 	andeq	r0, r0, #327680	@ 0x50000
  j = 0;
    2318:	01060304 	tsteq	r6, r4, lsl #6
    x[i] = y[j];
    231c:	02001105 	andeq	r1, r0, #1073741825	@ 0x40000001
    2320:	05660304 	strbeq	r0, [r6, #-772]!	@ 0xfffffcfc
    i += 1;
    2324:	04020006 	streq	r0, [r2], #-6
    j += 1;
    2328:	03058203 	movweq	r8, #20995	@ 0x5203
  while (i < BITVEC_NWORDS)
    232c:	03040200 	movweq	r0, #16896	@ 0x4200
  if (nbits != 0)
    2330:	02002106 	andeq	r2, r0, #-2147483647	@ 0x80000001
}
    2334:	00130304 	andseq	r0, r3, r4, lsl #6
      x[i]  = (x[i] << nbits) | (x[i - 1] >> (32 - nbits));
    2338:	13030402 	movwne	r0, #13314	@ 0x3402
    233c:	03040200 	movweq	r0, #16896	@ 0x4200
    2340:	04020013 	streq	r0, [r2], #-19	@ 0xffffffed
    2344:	02001303 	andeq	r1, r0, #201326592	@ 0xc000000
    2348:	00130304 	andseq	r0, r3, r4, lsl #6
    234c:	13030402 	movwne	r0, #13314	@ 0x3402
    2350:	03040200 	movweq	r0, #16896	@ 0x4200
    2354:	00160513 	andseq	r0, r6, r3, lsl r5
    for (i = (BITVEC_NWORDS - 1); i > 0; --i)
    2358:	03030402 	movweq	r0, #13314	@ 0x3402
    x[0] <<= nbits;
    235c:	05050176 	streq	r0, [r5, #-374]	@ 0xfffffe8a
    2360:	03040200 	movweq	r0, #16896	@ 0x4200
    for (i = (BITVEC_NWORDS - 1); i > 0; --i)
    2364:	02002306 	andeq	r2, r0, #402653184	@ 0x18000000
  x[0] = 1;
    2368:	00210304 	eoreq	r0, r1, r4, lsl #6
  for (i = 1; i < BITVEC_NWORDS; ++i)
    236c:	21030402 	tstcs	r3, r2, lsl #8
    x[i] = 0;
    2370:	03040200 	movweq	r0, #16896	@ 0x4200
  for (i = 1; i < BITVEC_NWORDS; ++i)
    2374:	04020021 	streq	r0, [r2], #-33	@ 0xffffffdf
    2378:	02002f03 	andeq	r2, r0, #3, 30
  if (x[0] != 1)
    237c:	00210304 	eoreq	r0, r1, r4, lsl #6
    2380:	21030402 	tstcs	r3, r2, lsl #8
  for (i = 1; i < BITVEC_NWORDS; ++i)
    2384:	03040200 	movweq	r0, #16896	@ 0x4200
    if (x[i] != 0)
    2388:	00100521 	andseq	r0, r0, r1, lsr #10
  for (i = 1; i < BITVEC_NWORDS; ++i)
    238c:	06010402 	streq	r0, [r1], -r2, lsl #8
  return (i == BITVEC_NWORDS);
    2390:	062e7603 	strteq	r7, [lr], -r3, lsl #12
    2394:	052e0d03 	streq	r0, [lr, #-3331]!	@ 0xfffff2fd
    2398:	05580602 	ldrbeq	r0, [r8, #-1538]	@ 0xfffff9fe
}
    239c:	2e010610 	mcrcs	6, 0, r0, cr1, cr0, {0}
  for (i = 0; i < BITVEC_NWORDS; ++i)
    23a0:	2f060205 	svccs	0x00060205
{
    23a4:	01061005 	tsteq	r6, r5
    z[i] = (x[i] ^ y[i]);
    23a8:	06020520 	streq	r0, [r2], -r0, lsr #10
    23ac:	0610052f 	ldreq	r0, [r0], -pc, lsr #10
    23b0:	02052001 	andeq	r2, r5, #1
  for (i = 0; i < BITVEC_NWORDS; ++i)
    23b4:	10052f06 	andne	r2, r5, r6, lsl #30
    23b8:	02050106 	andeq	r0, r5, #-2147483647	@ 0x80000001
}
    23bc:	10053d06 	andne	r3, r5, r6, lsl #26
  x[0] ^= 1;
    23c0:	052e0106 	streq	r0, [lr, #-262]!	@ 0xfffffefa
    23c4:	052f0602 	streq	r0, [pc, #-1538]!	@ 1dca <ShiftRows+0xe>
}
    23c8:	2e010610 	mcrcs	6, 0, r0, cr1, cr0, {0}
{
    23cc:	2f060205 	svccs	0x00060205
    23d0:	01061005 	tsteq	r6, r5
  bitvec_copy(tmp, x);
    23d4:	0602052e 	streq	r0, [r2], -lr, lsr #10
    23d8:	0610052f 	ldreq	r0, [r0], -pc, lsr #10
  if (bitvec_get_bit(y, 0) != 0)
    23dc:	4b010501 	blmi	437e8 <__ROM_SIZE__+0x37e8>
    23e0:	0500063c 	streq	r0, [r0, #-1596]	@ 0xfffff9c4
    bitvec_copy(z, x);
    23e4:	0014d402 	andseq	sp, r4, r2, lsl #8
    23e8:	02051500 	andeq	r1, r5, #0, 10
{
    23ec:	060f0513 			@ <UNDEFINED> instruction: 0x060f0513
    bitvec_set_zero(z);
    23f0:	06020501 	streq	r0, [r2], -r1, lsl #10
    23f4:	060e052f 	streq	r0, [lr], -pc, lsr #10
      gf2field_add(tmp, tmp, polynomial);
    23f8:	06020501 	streq	r0, [r2], -r1, lsl #10
    23fc:	0610054b 	ldreq	r0, [r0], -fp, asr #10
    2400:	06020501 	streq	r0, [r2], -r1, lsl #10
  for (i = 1; i < CURVE_DEGREE; ++i)
    2404:	0610052f 	ldreq	r0, [r0], -pc, lsr #10
    2408:	06020501 	streq	r0, [r2], -r1, lsl #10
    bitvec_lshift(tmp, tmp, 1);
    240c:	0610052f 	ldreq	r0, [r0], -pc, lsr #10
    2410:	06020501 	streq	r0, [r2], -r1, lsl #10
    if (bitvec_get_bit(tmp, CURVE_DEGREE))
    2414:	0610052f 	ldreq	r0, [r0], -pc, lsr #10
    2418:	06020501 	streq	r0, [r2], -r1, lsl #10
    241c:	0610052f 	ldreq	r0, [r0], -pc, lsr #10
    if (bitvec_get_bit(y, i))
    2420:	06020501 	streq	r0, [r2], -r1, lsl #10
    2424:	0610052f 	ldreq	r0, [r0], -pc, lsr #10
    2428:	06020501 	streq	r0, [r2], -r1, lsl #10
      gf2field_add(z, z, tmp);
    242c:	0610052f 	ldreq	r0, [r0], -pc, lsr #10
    2430:	06020501 	streq	r0, [r2], -r1, lsl #10
    2434:	0610052f 	ldreq	r0, [r0], -pc, lsr #10
}
    2438:	75010501 	strvc	r0, [r1, #-1281]	@ 0xfffffaff
    243c:	0106e706 	tsteq	r6, r6, lsl #14
{
    2440:	4b060205 	blmi	182c5c <__ROM_SIZE__+0x142c5c>
    2444:	06090514 			@ <UNDEFINED> instruction: 0x06090514
  bitvec_copy(u, x);
    2448:	20020501 	andcs	r0, r2, r1, lsl #10
  bitvec_copy(v, polynomial);
    244c:	02001705 	andeq	r1, r0, #1310720	@ 0x140000
    2450:	20060204 	andcs	r0, r6, r4, lsl #4
  bitvec_set_zero(g);
    2454:	02001005 	andeq	r1, r0, #5
    2458:	05200104 	streq	r0, [r0, #-260]!	@ 0xfffffefc
  gf2field_set_one(z);
    245c:	10052f03 	andne	r2, r5, r3, lsl #30
  while (!gf2field_is_one(u))
    2460:	21050106 	tstcs	r5, r6, lsl #2
    bitvec_lshift(h, v, i);
    2464:	201b0520 	andscs	r0, fp, r0, lsr #10
    2468:	21060305 	tstcs	r6, r5, lsl #6
    gf2field_add(u, u, h);
    246c:	01060f05 	tsteq	r6, r5, lsl #30
    2470:	2f060305 	svccs	0x00060305
    2474:	01060605 	tsteq	r6, r5, lsl #12
    bitvec_lshift(h, g, i);
    2478:	2f060405 	svccs	0x00060405
    247c:	0607054b 	streq	r0, [r7], -fp, asr #10
    gf2field_add(z, z, h);
    2480:	2e100501 	cfmul32cs	mvfx0, mvfx0, mvfx1
    2484:	67060405 	strvs	r0, [r6, -r5, lsl #8]
    2488:	01061105 	tsteq	r6, r5, lsl #2
  while (!gf2field_is_one(u))
    248c:	203f0105 	eorscs	r0, pc, r5, lsl #2
    2490:	02050006 	andeq	r0, r5, #6
    i = (bitvec_degree(u) - bitvec_degree(v));
    2494:	00001568 	andeq	r1, r0, r8, ror #10
    2498:	05010615 	streq	r0, [r1, #-1557]	@ 0xfffff9eb
    249c:	143d0602 	ldrtne	r0, [sp], #-1538	@ 0xfffff9fe
    24a0:	01060405 	tsteq	r6, r5, lsl #8
    if (i < 0)
    24a4:	23060205 	movwcs	r0, #25093	@ 0x6205
      bitvec_swap(u, v);
    24a8:	01060505 	tsteq	r6, r5, lsl #10
    24ac:	2f060305 	svccs	0x00060305
      bitvec_swap(g, z);
    24b0:	01060e05 	tsteq	r6, r5, lsl #28
    24b4:	20201205 	eorcs	r1, r0, r5, lsl #4
      i = -i;
    24b8:	21060305 	tstcs	r6, r5, lsl #6
}
    24bc:	01060905 	tsteq	r6, r5, lsl #18
    24c0:	21060405 	tstcs	r6, r5, lsl #8
{
    24c4:	01061305 	tsteq	r6, r5, lsl #6
    24c8:	052e0f05 	streq	r0, [lr, #-3845]!	@ 0xfffff0fb
  bitvec_copy(x1, x2);
    24cc:	051f060c 	ldreq	r0, [pc, #-1548]	@ 1ec8 <InvMixColumns+0x52>
  bitvec_copy(y1, y2);
    24d0:	2e0c0302 	cdpcs	3, 0, cr0, cr12, cr2, {0}
    24d4:	01060505 	tsteq	r6, r5, lsl #10
}
    24d8:	052e1405 	streq	r1, [lr, #-1029]!	@ 0xfffffbfb
{
    24dc:	0e05201e 	mcreq	0, 0, r2, cr5, cr14, {0}
  bitvec_set_zero(x);
    24e0:	06020520 	streq	r0, [r2], -r0, lsr #10
  bitvec_set_zero(y);
    24e4:	06100559 			@ <UNDEFINED> instruction: 0x06100559
}
    24e8:	06020501 	streq	r0, [r2], -r1, lsl #10
{
    24ec:	061e052f 	ldreq	r0, [lr], -pc, lsr #10
  return (    bitvec_is_zero(x)
    24f0:	20100501 	andscs	r0, r0, r1, lsl #10
           && bitvec_is_zero(y));
    24f4:	2f060205 	svccs	0x00060205
    24f8:	01061e05 	tsteq	r6, r5, lsl #28
    24fc:	05201005 	streq	r1, [r0, #-5]!
{
    2500:	052f0602 	streq	r0, [pc, #-1538]!	@ 1f06 <InvMixColumns+0x90>
    2504:	0501061e 	streq	r0, [r1, #-1566]	@ 0xfffff9e2
  if (bitvec_is_zero(x))
    2508:	02052010 	andeq	r2, r5, #16
    250c:	10052f06 	andne	r2, r5, r6, lsl #30
    bitvec_set_zero(y);
    2510:	02050106 	andeq	r0, r5, #-2147483647	@ 0x80000001
}
    2514:	1e052f06 	cdpne	15, 0, cr2, cr5, cr6, {0}
    gf2field_inv(l, x);
    2518:	10050106 	andne	r0, r5, r6, lsl #2
    251c:	06020520 	streq	r0, [r2], -r0, lsr #10
    gf2field_mul(l, l, y);
    2520:	061e052f 	ldreq	r0, [lr], -pc, lsr #10
    2524:	20100501 	andscs	r0, r0, r1, lsl #10
    2528:	2f060205 	svccs	0x00060205
    gf2field_add(l, l, x);
    252c:	01061e05 	tsteq	r6, r5, lsl #28
    2530:	05201005 	streq	r1, [r0, #-5]!
    gf2field_mul(y, x, x);
    2534:	4e2f0602 	cfmadda32mi	mvax0, mvax0, mvfx15, mvfx2
    2538:	01060905 	tsteq	r6, r5, lsl #18
    253c:	05200205 	streq	r0, [r0, #-517]!	@ 0xfffffdfb
    gf2field_mul(x, l, l);
    2540:	6b030603 	blvs	c3d54 <__ROM_SIZE__+0x83d54>
    2544:	060e0520 	streq	r0, [lr], -r0, lsr #10
    gf2field_inc(l);
    2548:	20120501 	andscs	r0, r2, r1, lsl #10
    254c:	06030520 	streq	r0, [r3], -r0, lsr #10
    gf2field_add(x, x, l);
    2550:	06090521 	streq	r0, [r9], -r1, lsr #10
    2554:	06040501 	streq	r0, [r4], -r1, lsl #10
    gf2field_mul(l, l, x);
    2558:	06130521 	ldreq	r0, [r3], -r1, lsr #10
    255c:	2e0f0501 	cfsh32cs	mvfx0, mvfx15, #1
    2560:	1f060c05 	svcne	0x00060c05
    gf2field_add(y, y, l);
    2564:	06300305 	ldrteq	r0, [r0], -r5, lsl #6
    2568:	002f062e 	eoreq	r0, pc, lr, lsr #12
}
    256c:	03030402 	movweq	r0, #13314	@ 0x3402
{
    2570:	1d056612 	stcne	6, cr6, [r5, #-72]	@ 0xffffffb8
    2574:	03040200 	movweq	r0, #16896	@ 0x4200
    2578:	28050106 	stmdacs	r5, {r1, r2, r8}
  if (!gf2point_is_zero(x2, y2))
    257c:	03040200 	movweq	r0, #16896	@ 0x4200
    2580:	00210520 	eoreq	r0, r1, r0, lsr #10
    if (gf2point_is_zero(x1, y1))
    2584:	3c030402 	cfstrscc	mvf0, [r3], {2}
    2588:	02001005 	andeq	r1, r0, #5
    258c:	05200304 	streq	r0, [r0, #-772]!	@ 0xfffffcfc
      if (bitvec_equal(x1, x2))
    2590:	04020003 	streq	r0, [r2], #-3
    2594:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
        if (bitvec_equal(y1, y2))
    2598:	0402001d 	streq	r0, [r2], #-29	@ 0xffffffe3
    259c:	05010603 	streq	r0, [r1, #-1539]	@ 0xfffff9fd
    25a0:	04020021 	streq	r0, [r2], #-33	@ 0xffffffdf
          gf2point_double(x1, y1);
    25a4:	07052003 	streq	r2, [r5, -r3]
    25a8:	03040200 	movweq	r0, #16896	@ 0x4200
      gf2point_copy(x1, y1, x2, y2);
    25ac:	00100520 	andseq	r0, r0, r0, lsr #10
    25b0:	20030402 	andcs	r0, r3, r2, lsl #8
    25b4:	02000305 	andeq	r0, r0, #335544320	@ 0x14000000
}
    25b8:	21060304 	tstcs	r6, r4, lsl #6
          gf2point_set_zero(x1, y1);
    25bc:	02001d05 	andeq	r1, r0, #320	@ 0x140
    25c0:	01060304 	tsteq	r6, r4, lsl #6
    25c4:	02002105 	andeq	r2, r0, #1073741825	@ 0x40000001
        gf2field_add(a, y1, y2);
    25c8:	05200304 	streq	r0, [r0, #-772]!	@ 0xfffffcfc
    25cc:	04020007 	streq	r0, [r2], #-7
        gf2field_add(b, x1, x2);
    25d0:	10052003 	andne	r2, r5, r3
    25d4:	03040200 	movweq	r0, #16896	@ 0x4200
    25d8:	0003052e 	andeq	r0, r3, lr, lsr #10
        gf2field_inv(c, b);
    25dc:	06030402 	streq	r0, [r3], -r2, lsl #8
    25e0:	001d0521 	andseq	r0, sp, r1, lsr #10
        gf2field_mul(c, c, a);
    25e4:	06030402 	streq	r0, [r3], -r2, lsl #8
    25e8:	00210501 	eoreq	r0, r1, r1, lsl #10
        gf2field_mul(d, c, c);
    25ec:	20030402 	andcs	r0, r3, r2, lsl #8
    25f0:	02000705 	andeq	r0, r0, #1310720	@ 0x140000
    25f4:	05200304 	streq	r0, [r0, #-772]!	@ 0xfffffcfc
        gf2field_add(d, d, c);
    25f8:	04020010 	streq	r0, [r2], #-16
    25fc:	03052e03 	movweq	r2, #24067	@ 0x5e03
        gf2field_add(d, d, b);
    2600:	03040200 	movweq	r0, #16896	@ 0x4200
    2604:	1d052106 	stfnes	f2, [r5, #-24]	@ 0xffffffe8
    2608:	03040200 	movweq	r0, #16896	@ 0x4200
        gf2field_inc(d);
    260c:	21050106 	tstcs	r5, r6, lsl #2
        gf2field_add(x1, x1, d);
    2610:	03040200 	movweq	r0, #16896	@ 0x4200
    2614:	00070520 	andeq	r0, r7, r0, lsr #10
    2618:	20030402 	andcs	r0, r3, r2, lsl #8
        gf2field_mul(a, x1, c);
    261c:	02001005 	andeq	r1, r0, #5
    2620:	052e0304 	streq	r0, [lr, #-772]!	@ 0xfffffcfc
        gf2field_add(a, a, d);
    2624:	04020003 	streq	r0, [r2], #-3
    2628:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
    262c:	0402001d 	streq	r0, [r2], #-29	@ 0xffffffe3
        gf2field_add(y1, y1, a);
    2630:	05010603 	streq	r0, [r1, #-1539]	@ 0xfffff9fd
    2634:	04020021 	streq	r0, [r2], #-33	@ 0xffffffdf
        bitvec_copy(x1, d);
    2638:	07052003 	streq	r2, [r5, -r3]
    263c:	03040200 	movweq	r0, #16896	@ 0x4200
}
    2640:	00100520 	andseq	r0, r0, r0, lsr #10
{
    2644:	2e030402 	cdpcs	4, 0, cr0, cr3, cr2, {0}
    2648:	02000305 	andeq	r0, r0, #335544320	@ 0x14000000
  int nbits = bitvec_degree(exp);
    264c:	21060304 	tstcs	r6, r4, lsl #6
    2650:	02001d05 	andeq	r1, r0, #320	@ 0x140
  gf2point_set_zero(tmpx, tmpy);
    2654:	01060304 	tsteq	r6, r4, lsl #6
    2658:	02002105 	andeq	r2, r0, #1073741825	@ 0x40000001
  for (i = (nbits - 1); i >= 0; --i)
    265c:	05200304 	streq	r0, [r0, #-772]!	@ 0xfffffcfc
    2660:	04020007 	streq	r0, [r2], #-7
    2664:	10052003 	andne	r2, r5, r3
    gf2point_double(tmpx, tmpy);
    2668:	03040200 	movweq	r0, #16896	@ 0x4200
    266c:	0003052e 	andeq	r0, r3, lr, lsr #10
    if (bitvec_get_bit(exp, i))
    2670:	06030402 	streq	r0, [r3], -r2, lsl #8
    2674:	001d0521 	andseq	r0, sp, r1, lsr #10
    2678:	06030402 	streq	r0, [r3], -r2, lsl #8
      gf2point_add(tmpx, tmpy, x, y);
    267c:	00210501 	eoreq	r0, r1, r1, lsl #10
    2680:	20030402 	andcs	r0, r3, r2, lsl #8
    2684:	02000705 	andeq	r0, r0, #1310720	@ 0x140000
  gf2point_copy(x, y, tmpx, tmpy);
    2688:	05200304 	streq	r0, [r0, #-772]!	@ 0xfffffcfc
    268c:	04020010 	streq	r0, [r2], #-16
    2690:	15052e03 	strne	r2, [r5, #-3587]	@ 0xfffff1fd
}
    2694:	03040200 	movweq	r0, #16896	@ 0x4200
{
    2698:	20780306 	rsbscs	r0, r8, r6, lsl #6
    269c:	02001005 	andeq	r1, r0, #5
  if (gf2point_is_zero(x, y))
    26a0:	05200104 	streq	r0, [r0, #-260]!	@ 0xfffffefc
    26a4:	0a030601 	beq	c3eb0 <__ROM_SIZE__+0x83eb0>
}
    26a8:	0100202e 	tsteq	r0, lr, lsr #32
    gf2field_mul(a, x, x);
    26ac:	0003a301 	andeq	sl, r3, r1, lsl #6
    26b0:	a2000300 	andge	r0, r0, #0, 6
    26b4:	02000000 	andeq	r0, r0, #0
    gf2field_mul(b, a, x);
    26b8:	0d0efb01 	vstreq	d15, [lr, #-4]
    26bc:	01010100 	mrseq	r0, (UNDEF: 17)
    gf2field_add(a, a, b);
    26c0:	00000001 	andeq	r0, r0, r1
    26c4:	01000001 	tsteq	r0, r1
    26c8:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 2614 <gf2point_add+0xa6>
    gf2field_add(a, a, coeff_b);
    26cc:	63652f65 	cmnvs	r5, #404	@ 0x194
    26d0:	652f6674 	strvs	r6, [pc, #-1652]!	@ 2064 <Cipher+0x1a>
    gf2field_mul(b, y, y);
    26d4:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
    26d8:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
    26dc:	2f72656e 	svccs	0x0072656e
    gf2field_add(a, a, b);
    26e0:	2f626f66 	svccs	0x00626f66
    26e4:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
    gf2field_mul(b, x, y);
    26e8:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
    26ec:	72702f62 	rsbsvc	r2, r0, #392	@ 0x188
    26f0:	66746e69 	ldrbtvs	r6, [r4], -r9, ror #28
    return bitvec_equal(a, b);
    26f4:	706f2f00 	rsbvc	r2, pc, r0, lsl #30
    26f8:	63672f74 	cmnvs	r7, #116, 30	@ 0x1d0
    26fc:	72612d63 	rsbvc	r2, r1, #6336	@ 0x18c0
{
    2700:	6f6e2d6d 	svcvs	0x006e2d6d
    2704:	652d656e 	strvs	r6, [sp, #-1390]!	@ 0xfffffa92
  gf2point_copy((uint32_t*)public_key, (uint32_t*)(public_key + BITVEC_NBYTES), base_x, base_y);
    2708:	2f696261 	svccs	0x00696261
    270c:	2f62696c 	svccs	0x0062696c
    2710:	2f636367 	svccs	0x00636367
    2714:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	@ 0xfffffe7c
  if (bitvec_degree((uint32_t*)private_key) < (CURVE_DEGREE / 2))
    2718:	656e6f6e 	strbvs	r6, [lr, #-3950]!	@ 0xfffff092
    271c:	6261652d 	rsbvs	r6, r1, #188743680	@ 0xb400000
    2720:	32312f69 	eorscc	r2, r1, #420	@ 0x1a4
    int nbits = bitvec_degree(base_order);
    2724:	312e322e 			@ <UNDEFINED> instruction: 0x312e322e
    for (i = (nbits - 1); i < (BITVEC_NWORDS * 32); ++i)
    2728:	636e692f 	cmnvs	lr, #770048	@ 0xbc000
      bitvec_clr_bit((uint32_t*)private_key, i);
    272c:	6564756c 	strbvs	r7, [r4, #-1388]!	@ 0xfffffa94
    2730:	72700000 	rsbsvc	r0, r0, #0
    for (i = (nbits - 1); i < (BITVEC_NWORDS * 32); ++i)
    2734:	66746e69 	ldrbtvs	r6, [r4], -r9, ror #28
    2738:	0100632e 	tsteq	r0, lr, lsr #6
    gf2point_mul((uint32_t*)public_key, (uint32_t*)(public_key + BITVEC_NBYTES), (uint32_t*)private_key);
    273c:	74730000 	ldrbtvc	r0, [r3], #-0
    2740:	67726164 	ldrbvs	r6, [r2, -r4, ror #2]!
    return 1;
    2744:	0200682e 	andeq	r6, r0, #3014656	@ 0x2e0000
    return 0;
    2748:	623c0000 	eorsvs	r0, ip, #0
    274c:	746c6975 	strbtvc	r6, [ip], #-2421	@ 0xfffff68b
    2750:	3e6e692d 	vmulcc.f16	s13, s28, s27	@ <UNPREDICTABLE>
{
    2754:	00000000 	andeq	r0, r0, r0
    2758:	00250500 	eoreq	r0, r5, r0, lsl #10
  if (    !gf2point_is_zero ((uint32_t*)others_pub, (uint32_t*)(others_pub + BITVEC_NBYTES))
    275c:	16500205 	ldrbne	r0, [r0], -r5, lsl #4
    2760:	2a030000 	bcs	c2768 <__ROM_SIZE__+0x82768>
    2764:	05010601 	streq	r0, [r1, #-1537]	@ 0xfffff9ff
    2768:	052f0603 	streq	r0, [pc, #-1539]!	@ 216d <AES_CBC_decrypt_buffer+0xb>
}
    276c:	05010609 	streq	r0, [r1, #-1545]	@ 0xfffff9f7
       &&  gf2point_on_curve((uint32_t*)others_pub, (uint32_t*)(others_pub + BITVEC_NBYTES)) )
    2770:	3d210605 	stccc	6, cr0, [r1, #-20]!	@ 0xffffffec
    2774:	01060805 	tsteq	r6, r5, lsl #16
    2778:	1e060f05 	cdpne	15, 0, cr0, cr6, cr5, {0}
    for (i = 0; i < (BITVEC_NBYTES * 2); ++i)
    277c:	01060a05 	tsteq	r6, r5, lsl #20
      output[i] = others_pub[i];
    2780:	05200f05 	streq	r0, [r0, #-3845]!	@ 0xfffff0fb
    2784:	05203201 	streq	r3, [r0, #-513]!	@ 0xfffffdff
    for (i = 0; i < (BITVEC_NBYTES * 2); ++i)
    2788:	05000648 	streq	r0, [r0, #-1608]	@ 0xfffff9b8
    gf2point_mul((uint32_t*)output,(uint32_t*)(output + BITVEC_NBYTES), (const uint32_t*)private_key);
    278c:	00166c02 	andseq	r6, r6, r2, lsl #24
    2790:	01061400 	tsteq	r6, r0, lsl #8
    2794:	3d060305 	stccc	3, cr0, [r6, #-20]	@ 0xffffffec
    return 1;
    2798:	07051413 	smladeq	r5, r3, r4, r1
int atoi(const char* str) {
    279c:	14743b03 	ldrbtne	r3, [r4], #-2819	@ 0xfffff4fd
  int res = 0;
    27a0:	01060a05 	tsteq	r6, r5, lsl #20
    res = res * 10 + str[i] - '0';
    27a4:	3d060905 	vstrcc.16	s0, [r6, #-10]	@ <UNPREDICTABLE>
    27a8:	01060f05 	tsteq	r6, r5, lsl #30
    27ac:	0607052e 	streq	r0, [r7], -lr, lsr #10
  for (int i = 0; str[i] != '\0'; ++i) {
    27b0:	052e1103 	streq	r1, [lr, #-259]!	@ 0xfffffefd
    27b4:	0501060a 	streq	r0, [r1, #-1546]	@ 0xfffff9f6
}
    27b8:	0a030609 	beq	c3fe4 <__ROM_SIZE__+0x83fe4>
  for (uint32_t i = 0; str[i] != '\0'; i++) {
    27bc:	060c052e 	streq	r0, [ip], -lr, lsr #10
    27c0:	060b0501 	streq	r0, [fp], -r1, lsl #10
    } else if (str[i] >= 'a' && str[i] <= 'f') {
    27c4:	203c062f 	eorscs	r0, ip, pc, lsr #12
    27c8:	16030a05 	strne	r0, [r3], -r5, lsl #20
      value = str[i] - 'a' + 10;
    27cc:	03052e01 	movweq	r2, #24065	@ 0x5e01
    hex |= value;
    27d0:	017f9003 	cmneq	pc, r3
  for (uint32_t i = 0; str[i] != '\0'; i++) {
    27d4:	03060705 	movweq	r0, #26373	@ 0x6705
    27d8:	062e00ed 	strteq	r0, [lr], -sp, ror #1
    if (str[i] >= '0' && str[i] <= '9') {
    27dc:	052f0620 	streq	r0, [pc, #-1568]!	@ 21c4 <AES_CTR_xcrypt_buffer+0x1c>
    27e0:	0501060e 	streq	r0, [r1, #-1550]	@ 0xfffff9f2
      value = str[i] - '0';
    27e4:	07052301 	streq	r2, [r5, -r1, lsl #6]
    } else if (str[i] >= 'A' && str[i] <= 'F') {
    27e8:	7f9a0306 	svcvc	0x009a0306
    27ec:	0a05142e 	beq	1478ac <__ROM_SIZE__+0x1078ac>
    27f0:	09050106 	stmdbeq	r5, {r1, r2, r8}
      value = str[i] - 'A' + 10;
    27f4:	0f052f06 	svceq	0x00052f06
  selected_mode = mode;
    27f8:	052e0106 	streq	r0, [lr, #-262]!	@ 0xfffffefa
  if (selected_mode == NONE) {
    27fc:	12030607 	andne	r0, r3, #7340032	@ 0x700000
  out_buf_rgn.addr = addr;
    2800:	060a052e 	streq	r0, [sl], -lr, lsr #10
  out_buf_rgn.size = size / 2;
    2804:	00070501 	andeq	r0, r7, r1, lsl #10
  out_buf_rgn.curr_index = 0;
    2808:	06010402 	streq	r0, [r1], -r2, lsl #8
  inp_buf_rgn.addr = addr + size / 2;
    280c:	00090533 	andeq	r0, r9, r3, lsr r5
  inp_buf_rgn.curr_index = 0;
    2810:	13010402 	movwne	r0, #5122	@ 0x1402
  if (!(selected_mode & INP)) {
    2814:	02002905 	andeq	r2, r0, #81920	@ 0x14000
    out_buf_rgn.size = size;
    2818:	01060104 	tsteq	r6, r4, lsl #2
  memset(addr, 0, size);
    281c:	02002205 	andeq	r2, r0, #1342177280	@ 0x50000000
    2820:	05ac0104 	streq	r0, [ip, #260]!	@ 0x104
  } else if (!(selected_mode & OUT)) {
    2824:	04020018 	streq	r0, [r2], #-24	@ 0xffffffe8
    2828:	02002e01 	andeq	r2, r0, #1, 28
    inp_buf_rgn.addr = addr;
    282c:	054a0104 	strbeq	r0, [sl, #-260]	@ 0xfffffefc
    inp_buf_rgn.size = size;
    2830:	04020009 	streq	r0, [r2], #-9
    2834:	052f0601 	streq	r0, [pc, #-1537]!	@ 223b <bitvec_clr_bit+0xd>
  if (!(selected_mode & INP)) {
    2838:	0402000f 	streq	r0, [r2], #-15
    283c:	05200601 	streq	r0, [r0, #-1537]!	@ 0xfffff9ff
    2840:	04020016 	streq	r0, [r2], #-22	@ 0xffffffea
  if (inp_buf_rgn.addr[inp_buf_rgn.curr_index] == 0) {
    2844:	05210601 	streq	r0, [r1, #-1537]!	@ 0xfffff9ff
    2848:	3c790309 	ldclcc	3, cr0, [r9], #-36	@ 0xffffffdc
  int val = inp_buf_rgn.addr[inp_buf_rgn.curr_index];
    284c:	21063c06 	tstcs	r6, r6, lsl #24
  inp_buf_rgn.addr[inp_buf_rgn.curr_index] = 0;
    2850:	01060f05 	tsteq	r6, r5, lsl #30
  inp_buf_rgn.curr_index++;
    2854:	06090520 	streq	r0, [r9], -r0, lsr #10
    2858:	06200903 	strteq	r0, [r0], -r3, lsl #18
  if (inp_buf_rgn.curr_index == inp_buf_rgn.size) {
    285c:	06160520 	ldreq	r0, [r6], -r0, lsr #10
}
    2860:	060a058f 	streq	r0, [sl], -pc, lsl #11
    inp_buf_rgn.curr_index = 0;
    2864:	2e00c603 	cfmadd32cs	mvax0, mvfx12, mvfx0, mvfx3
    return -1;
    2868:	02000905 	andeq	r0, r0, #81920	@ 0x14000
    286c:	03060104 	movweq	r0, #24836	@ 0x6104
    return -1;
    2870:	0b052e60 	bleq	14e1f8 <__ROM_SIZE__+0x10e1f8>
    2874:	01040200 	mrseq	r0, R12_usr
  if (!(selected_mode & OUT) || c == 0) {
    2878:	002b0513 	eoreq	r0, fp, r3, lsl r5
    287c:	06010402 	streq	r0, [r1], -r2, lsl #8
    2880:	00240501 	eoreq	r0, r4, r1, lsl #10
  out_buf_rgn.addr[out_buf_rgn.curr_index] = (uint8_t) c;
    2884:	90010402 	andls	r0, r1, r2, lsl #8
    2888:	02001a05 	andeq	r1, r0, #20480	@ 0x5000
  out_buf_rgn.curr_index++;
    288c:	002e0104 	eoreq	r0, lr, r4, lsl #2
  if (out_buf_rgn.curr_index == out_buf_rgn.size) {
    2890:	4a010402 	bmi	438a0 <__ROM_SIZE__+0x38a0>
    2894:	02000b05 	andeq	r0, r0, #5120	@ 0x1400
    out_buf_rgn.curr_index = 0;
    2898:	2f060104 	svccs	0x00060104
    289c:	02001105 	andeq	r1, r0, #1073741825	@ 0x40000001
    28a0:	20060104 	andcs	r0, r6, r4, lsl #2
size_t strlen(const char *str) {
    28a4:	02001805 	andeq	r1, r0, #327680	@ 0x50000
  while (str[len]) {
    28a8:	21060104 	tstcs	r6, r4, lsl #2
    28ac:	2f0b0530 	svccs	0x000b0530
    28b0:	059e2006 	ldreq	r2, [lr, #6]
  while (*str1 && (*str1 == *str2)) {
    28b4:	011a030a 	tsteq	sl, sl, lsl #6
    str2++;
    28b8:	03060f05 	movweq	r0, #28421	@ 0x6f05
  while (*str1 && (*str1 == *str2)) {
    28bc:	05132e73 	ldreq	r2, [r3, #-3699]	@ 0xfffff18d
    28c0:	05570624 	ldrbeq	r0, [r7, #-1572]	@ 0xfffff9dc
  return *str1 - *str2;
    28c4:	0523060d 	streq	r0, [r3, #-1549]!	@ 0xfffff9f3
}
    28c8:	20010617 	andcs	r0, r1, r7, lsl r6
    *(str1++) = *(str2++);
    28cc:	03061c05 	movweq	r1, #27653	@ 0x6c05
    28d0:	0d05017a 	stfeqs	f0, [r5, #-488]	@ 0xfffffe18
  while (*str2) {
    28d4:	061e052f 	ldreq	r0, [lr], -pc, lsr #10
  *str1 = '\0';
    28d8:	060d0501 	streq	r0, [sp], -r1, lsl #10
}
    28dc:	0610052f 	ldreq	r0, [r0], -pc, lsr #10
  for (i = 0; i < size; i++) {
    28e0:	15052e01 	strne	r2, [r5, #-3585]	@ 0xfffff1ff
    dest_char[i] = src_char[i];
    28e4:	01040200 	mrseq	r0, R12_usr
    28e8:	04020020 	streq	r0, [r2], #-32	@ 0xffffffe0
  for (i = 0; i < size; i++) {
    28ec:	10053c01 	andne	r3, r5, r1, lsl #24
}
    28f0:	1f0f050e 	svcne	0x000f050e
  for (i = 0; i < size; i++) {
    28f4:	0a052020 	beq	14a97c <__ROM_SIZE__+0x10a97c>
    dest_char[i] = val;
    28f8:	05011303 	streq	r1, [r1, #-771]	@ 0xfffffcfd
  for (i = 0; i < size; i++) {
    28fc:	7fac0310 	svcvc	0x00ac0310
}
    2900:	0320202e 			@ <UNDEFINED> instruction: 0x0320202e
    2904:	05200130 	streq	r0, [r0, #-304]!	@ 0xfffffed0
    2908:	05000622 	streq	r0, [r0, #-1570]	@ 0xfffff9de
    290c:	0017ac02 	andseq	sl, r7, r2, lsl #24
    2910:	01270300 			@ <UNDEFINED> instruction: 0x01270300
    2914:	03050106 	movweq	r0, #20742	@ 0x5106
    2918:	14136706 	ldrne	r6, [r3], #-1798	@ 0xfffff8fa
    291c:	06100522 	ldreq	r0, [r0], -r2, lsr #10
    2920:	2509050d 	strcs	r0, [r9, #-1293]	@ 0xfffffaf3
    2924:	0c052306 	stceq	3, cr2, [r5], {6}
    2928:	09050106 	stmdbeq	r5, {r1, r2, r8}
    292c:	053d3306 	ldreq	r3, [sp, #-774]!	@ 0xfffffcfa
    2930:	0501060c 	streq	r0, [r1, #-1548]	@ 0xfffff9f4
    2934:	05210609 	streq	r0, [r1, #-1545]!	@ 0xfffff9f7
    2938:	0176030a 	cmneq	r6, sl, lsl #6
    293c:	053d0505 	ldreq	r0, [sp, #-1285]!	@ 0xfffffafb
    2940:	0402000b 	streq	r0, [r2], #-11
    2944:	02004d01 	andeq	r4, r0, #1, 26	@ 0x40
    2948:	05130104 	ldreq	r0, [r3, #-260]	@ 0xfffffefc
    294c:	0402000e 	streq	r0, [r2], #-14
    2950:	05010601 	streq	r0, [r1, #-1537]	@ 0xfffff9ff
    2954:	0402000b 	streq	r0, [r2], #-11
    2958:	05210601 	streq	r0, [r1, #-1537]!	@ 0xfffff9ff
    295c:	04020011 	streq	r0, [r2], #-17	@ 0xffffffef
    2960:	05100601 	ldreq	r0, [r0, #-1537]	@ 0xfffff9ff
    2964:	0402000b 	streq	r0, [r2], #-11
    2968:	03062201 	movweq	r2, #25089	@ 0x6201
    296c:	0e052009 	cdpeq	0, 0, cr2, cr5, cr9, {0}
    2970:	15050106 	strne	r0, [r5, #-262]	@ 0xfffffefa
    2974:	10051f06 	andne	r1, r5, r6, lsl #30
    2978:	15050106 	strne	r0, [r5, #-262]	@ 0xfffffefa
    297c:	00260520 	eoreq	r0, r6, r0, lsr #10
    2980:	20010402 	andcs	r0, r1, r2, lsl #8
    2984:	02001505 	andeq	r1, r0, #20971520	@ 0x1400000
    2988:	053c0104 	ldreq	r0, [ip, #-260]!	@ 0xfffffefc
    298c:	04020036 	streq	r0, [r2], #-54	@ 0xffffffca
    2990:	09052e02 	stmdbeq	r5, {r1, r9, sl, fp, sp}
    2994:	0d053206 	sfmeq	f3, 4, [r5, #-24]	@ 0xffffffe8
    2998:	10053d92 	mulne	r5, r2, sp
    299c:	0d050106 	stfeqs	f0, [r5, #-24]	@ 0xffffffe8
    29a0:	05132106 	ldreq	r2, [r3, #-262]	@ 0xfffffefa
    29a4:	05110613 	ldreq	r0, [r1, #-1555]	@ 0xfffff9ed
    29a8:	0620210d 	strteq	r2, [r0], -sp, lsl #2
    29ac:	674a0903 	strbvs	r0, [sl, -r3, lsl #18]
    29b0:	01061005 	tsteq	r6, r5
    29b4:	21060d05 	tstcs	r6, r5, lsl #26
    29b8:	06130513 			@ <UNDEFINED> instruction: 0x06130513
    29bc:	210d0511 	tstcs	sp, r1, lsl r5
    29c0:	20770306 	rsbscs	r0, r7, r6, lsl #6
    29c4:	2e061c05 	cdpcs	12, 0, cr1, cr6, cr5, {0}
    29c8:	063c0d05 	ldrteq	r0, [ip], -r5, lsl #26
    29cc:	0610052f 	ldreq	r0, [r0], -pc, lsr #10
    29d0:	060d0501 	streq	r0, [sp], -r1, lsl #10
    29d4:	13051321 	movwne	r1, #21281	@ 0x5321
    29d8:	0d051106 	stfeqs	f1, [r5, #-24]	@ 0xffffffe8
    29dc:	13280621 			@ <UNDEFINED> instruction: 0x13280621
    29e0:	01061005 	tsteq	r6, r5
    29e4:	21060d05 	tstcs	r6, r5, lsl #26
    29e8:	01061105 	tsteq	r6, r5, lsl #2
    29ec:	05201005 	streq	r1, [r0, #-5]!
    29f0:	0d052c11 	stceq	12, cr2, [r5, #-68]	@ 0xffffffbc
    29f4:	11052606 	tstne	r5, r6, lsl #12
    29f8:	10050106 	andne	r0, r5, r6, lsl #2
    29fc:	060f054a 	streq	r0, [pc], -sl, asr #10
    2a00:	12051321 	andne	r1, r5, #-2080374784	@ 0x84000000
    2a04:	0f050106 	svceq	0x00050106
    2a08:	15052106 	strne	r2, [r5, #-262]	@ 0xfffffefa
    2a0c:	0f051006 	svceq	0x00051006
    2a10:	7a030622 	bvc	c42a0 <__ROM_SIZE__+0x842a0>
    2a14:	12051320 	andne	r1, r5, #32, 6	@ 0x80000000
    2a18:	16050106 	strne	r0, [r5], -r6, lsl #2
    2a1c:	0d052e1f 	stceq	14, cr2, [r5, #-124]	@ 0xffffff84
    2a20:	010b0306 	tsteq	fp, r6, lsl #6
    2a24:	01061105 	tsteq	r6, r5, lsl #2
    2a28:	054a1005 	strbeq	r1, [sl, #-5]
    2a2c:	1321060f 			@ <UNDEFINED> instruction: 0x1321060f
    2a30:	01061205 	tsteq	r6, r5, lsl #4
    2a34:	21060f05 	tstcs	r6, r5, lsl #30
    2a38:	10061505 	andne	r1, r6, r5, lsl #10
    2a3c:	05220f05 	streq	r0, [r2, #-3845]!	@ 0xfffff0fb
    2a40:	207a0314 	rsbscs	r0, sl, r4, lsl r3
    2a44:	0301052e 	movweq	r0, #5422	@ 0x152e
    2a48:	14050111 	strne	r0, [r5], #-273	@ 0xfffffeef
    2a4c:	02587703 	subseq	r7, r8, #786432	@ 0xc0000
    2a50:	01010006 	tsteq	r1, r6
    2a54:	000003a4 	andeq	r0, r0, r4, lsr #7
    2a58:	00a30003 	adceq	r0, r3, r3
    2a5c:	01020000 	mrseq	r0, (UNDEF: 2)
    2a60:	000d0efb 	strdeq	r0, [sp], -fp
    2a64:	01010101 	tsteq	r1, r1, lsl #2
    2a68:	01000000 	mrseq	r0, (UNDEF: 0)
    2a6c:	2f010000 	svccs	0x00010000
    2a70:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
    2a74:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
    2a78:	63652f66 	cmnvs	r5, #408	@ 0x198
    2a7c:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
    2a80:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
    2a84:	662f7265 	strtvs	r7, [pc], -r5, ror #4
    2a88:	732f626f 			@ <UNDEFINED> instruction: 0x732f626f
    2a8c:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
    2a90:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
    2a94:	6972702f 	ldmdbvs	r2!, {r0, r1, r2, r3, r5, ip, sp, lr}^
    2a98:	0066746e 	rsbeq	r7, r6, lr, ror #8
    2a9c:	74706f2f 	ldrbtvc	r6, [r0], #-3887	@ 0xfffff0d1
    2aa0:	6363672f 	cmnvs	r3, #12320768	@ 0xbc0000
    2aa4:	6d72612d 	ldfvse	f6, [r2, #-180]!	@ 0xffffff4c
    2aa8:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
    2aac:	61652d65 	cmnvs	r5, r5, ror #26
    2ab0:	6c2f6962 			@ <UNDEFINED> instruction: 0x6c2f6962
    2ab4:	672f6269 	strvs	r6, [pc, -r9, ror #4]!
    2ab8:	612f6363 			@ <UNDEFINED> instruction: 0x612f6363
    2abc:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
    2ac0:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	@ 0xfffffe44
    2ac4:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
    2ac8:	2e32312f 	rsfcssp	f3, f2, #10.0
    2acc:	2f312e32 	svccs	0x00312e32
    2ad0:	6c636e69 	stclvs	14, cr6, [r3], #-420	@ 0xfffffe5c
    2ad4:	00656475 	rsbeq	r6, r5, r5, ror r4
    2ad8:	69727000 	ldmdbvs	r2!, {ip, sp, lr}^
    2adc:	3266746e 	rsbcc	r7, r6, #1845493760	@ 0x6e000000
    2ae0:	0100632e 	tsteq	r0, lr, lsr #6
    2ae4:	74730000 	ldrbtvc	r0, [r3], #-0
    2ae8:	67726164 	ldrbvs	r6, [r2, -r4, ror #2]!
    2aec:	0200682e 	andeq	r6, r0, #3014656	@ 0x2e0000
    2af0:	623c0000 	eorsvs	r0, ip, #0
    2af4:	746c6975 	strbtvc	r6, [ip], #-2421	@ 0xfffff68b
    2af8:	3e6e692d 	vmulcc.f16	s13, s28, s27	@ <UNPREDICTABLE>
    2afc:	00000000 	andeq	r0, r0, r0
    2b00:	00260500 	eoreq	r0, r6, r0, lsl #10
    2b04:	18880205 	stmne	r8, {r0, r2, r9}
    2b08:	28030000 	stmdacs	r3, {}	@ <UNPREDICTABLE>
    2b0c:	05010601 	streq	r0, [r1, #-1537]	@ 0xfffff9ff
    2b10:	052f0603 	streq	r0, [pc, #-1539]!	@ 2515 <gf2point_double+0x15>
    2b14:	05010609 	streq	r0, [r1, #-1545]	@ 0xfffff9f7
    2b18:	3d210605 	stccc	6, cr0, [r1, #-20]!	@ 0xffffffec
    2b1c:	01060805 	tsteq	r6, r5, lsl #16
    2b20:	1e060f05 	cdpne	15, 0, cr0, cr6, cr5, {0}
    2b24:	01060a05 	tsteq	r6, r5, lsl #20
    2b28:	05200f05 	streq	r0, [r0, #-3845]!	@ 0xfffff0fb
    2b2c:	05203201 	streq	r3, [r0, #-513]!	@ 0xfffffdff
    2b30:	05000649 	streq	r0, [r0, #-1609]	@ 0xfffff9b7
    2b34:	0018a402 	andseq	sl, r8, r2, lsl #8
    2b38:	01061400 	tsteq	r6, r0, lsl #8
    2b3c:	3d060305 	stccc	3, cr0, [r6, #-20]	@ 0xffffffec
    2b40:	07051413 	smladeq	r5, r3, r4, r1
    2b44:	14743b03 	ldrbtne	r3, [r4], #-2819	@ 0xfffff4fd
    2b48:	01060a05 	tsteq	r6, r5, lsl #20
    2b4c:	3d060905 	vstrcc.16	s0, [r6, #-10]	@ <UNPREDICTABLE>
    2b50:	01060f05 	tsteq	r6, r5, lsl #30
    2b54:	0607052e 	streq	r0, [r7], -lr, lsr #10
    2b58:	052e1103 	streq	r1, [lr, #-259]!	@ 0xfffffefd
    2b5c:	0501060a 	streq	r0, [r1, #-1546]	@ 0xfffff9f6
    2b60:	0a030609 	beq	c438c <__ROM_SIZE__+0x8438c>
    2b64:	060c052e 	streq	r0, [ip], -lr, lsr #10
    2b68:	060b0501 	streq	r0, [fp], -r1, lsl #10
    2b6c:	203c062f 	eorscs	r0, ip, pc, lsr #12
    2b70:	16030a05 	strne	r0, [r3], -r5, lsl #20
    2b74:	03052e01 	movweq	r2, #24065	@ 0x5e01
    2b78:	017f9003 	cmneq	pc, r3
    2b7c:	03060705 	movweq	r0, #26373	@ 0x6705
    2b80:	062e00ed 	strteq	r0, [lr], -sp, ror #1
    2b84:	052f0620 	streq	r0, [pc, #-1568]!	@ 256c <gf2point_double+0x6c>
    2b88:	0501060e 	streq	r0, [r1, #-1550]	@ 0xfffff9f2
    2b8c:	07052301 	streq	r2, [r5, -r1, lsl #6]
    2b90:	7f9a0306 	svcvc	0x009a0306
    2b94:	0a05142e 	beq	147c54 <__ROM_SIZE__+0x107c54>
    2b98:	09050106 	stmdbeq	r5, {r1, r2, r8}
    2b9c:	0f052f06 	svceq	0x00052f06
    2ba0:	052e0106 	streq	r0, [lr, #-262]!	@ 0xfffffefa
    2ba4:	12030607 	andne	r0, r3, #7340032	@ 0x700000
    2ba8:	060a052e 	streq	r0, [sl], -lr, lsr #10
    2bac:	00070501 	andeq	r0, r7, r1, lsl #10
    2bb0:	06010402 	streq	r0, [r1], -r2, lsl #8
    2bb4:	00090533 	andeq	r0, r9, r3, lsr r5
    2bb8:	13010402 	movwne	r0, #5122	@ 0x1402
    2bbc:	02002a05 	andeq	r2, r0, #20480	@ 0x5000
    2bc0:	01060104 	tsteq	r6, r4, lsl #2
    2bc4:	02002305 	andeq	r2, r0, #335544320	@ 0x14000000
    2bc8:	05ac0104 	streq	r0, [ip, #260]!	@ 0x104
    2bcc:	04020018 	streq	r0, [r2], #-24	@ 0xffffffe8
    2bd0:	02002e01 	andeq	r2, r0, #1, 28
    2bd4:	054a0104 	strbeq	r0, [sl, #-260]	@ 0xfffffefc
    2bd8:	04020009 	streq	r0, [r2], #-9
    2bdc:	052f0601 	streq	r0, [pc, #-1537]!	@ 25e3 <gf2point_add+0x75>
    2be0:	0402000f 	streq	r0, [r2], #-15
    2be4:	05200601 	streq	r0, [r0, #-1537]!	@ 0xfffff9ff
    2be8:	04020016 	streq	r0, [r2], #-22	@ 0xffffffea
    2bec:	05210601 	streq	r0, [r1, #-1537]!	@ 0xfffff9ff
    2bf0:	3c790309 	ldclcc	3, cr0, [r9], #-36	@ 0xffffffdc
    2bf4:	21063c06 	tstcs	r6, r6, lsl #24
    2bf8:	01060f05 	tsteq	r6, r5, lsl #30
    2bfc:	06090520 	streq	r0, [r9], -r0, lsr #10
    2c00:	06200903 	strteq	r0, [r0], -r3, lsl #18
    2c04:	06160520 	ldreq	r0, [r6], -r0, lsr #10
    2c08:	060a058f 	streq	r0, [sl], -pc, lsl #11
    2c0c:	2e00c603 	cfmadd32cs	mvax0, mvfx12, mvfx0, mvfx3
    2c10:	02000905 	andeq	r0, r0, #81920	@ 0x14000
    2c14:	03060104 	movweq	r0, #24836	@ 0x6104
    2c18:	0b052e60 	bleq	14e5a0 <__ROM_SIZE__+0x10e5a0>
    2c1c:	01040200 	mrseq	r0, R12_usr
    2c20:	002c0513 	eoreq	r0, ip, r3, lsl r5
    2c24:	06010402 	streq	r0, [r1], -r2, lsl #8
    2c28:	00250501 	eoreq	r0, r5, r1, lsl #10
    2c2c:	90010402 	andls	r0, r1, r2, lsl #8
    2c30:	02001a05 	andeq	r1, r0, #20480	@ 0x5000
    2c34:	002e0104 	eoreq	r0, lr, r4, lsl #2
    2c38:	4a010402 	bmi	43c48 <__ROM_SIZE__+0x3c48>
    2c3c:	02000b05 	andeq	r0, r0, #5120	@ 0x1400
    2c40:	2f060104 	svccs	0x00060104
    2c44:	02001105 	andeq	r1, r0, #1073741825	@ 0x40000001
    2c48:	20060104 	andcs	r0, r6, r4, lsl #2
    2c4c:	02001805 	andeq	r1, r0, #327680	@ 0x50000
    2c50:	21060104 	tstcs	r6, r4, lsl #2
    2c54:	2f0b0530 	svccs	0x000b0530
    2c58:	059e2006 	ldreq	r2, [lr, #6]
    2c5c:	011a030a 	tsteq	sl, sl, lsl #6
    2c60:	03060f05 	movweq	r0, #28421	@ 0x6f05
    2c64:	05132e73 	ldreq	r2, [r3, #-3699]	@ 0xfffff18d
    2c68:	05570624 	ldrbeq	r0, [r7, #-1572]	@ 0xfffff9dc
    2c6c:	0523060d 	streq	r0, [r3, #-1549]!	@ 0xfffff9f3
    2c70:	20010617 	andcs	r0, r1, r7, lsl r6
    2c74:	03061c05 	movweq	r1, #27653	@ 0x6c05
    2c78:	0d05017a 	stfeqs	f0, [r5, #-488]	@ 0xfffffe18
    2c7c:	061e052f 	ldreq	r0, [lr], -pc, lsr #10
    2c80:	060d0501 	streq	r0, [sp], -r1, lsl #10
    2c84:	0610052f 	ldreq	r0, [r0], -pc, lsr #10
    2c88:	15052e01 	strne	r2, [r5, #-3585]	@ 0xfffff1ff
    2c8c:	01040200 	mrseq	r0, R12_usr
    2c90:	04020020 	streq	r0, [r2], #-32	@ 0xffffffe0
    2c94:	10053c01 	andne	r3, r5, r1, lsl #24
    2c98:	1f0f050e 	svcne	0x000f050e
    2c9c:	0a052020 	beq	14ad24 <__ROM_SIZE__+0x10ad24>
    2ca0:	05011303 	streq	r1, [r1, #-771]	@ 0xfffffcfd
    2ca4:	7fac0310 	svcvc	0x00ac0310
    2ca8:	0320202e 			@ <UNDEFINED> instruction: 0x0320202e
    2cac:	05200130 	streq	r0, [r0, #-304]!	@ 0xfffffed0
    2cb0:	05000623 	streq	r0, [r0, #-1571]	@ 0xfffff9dd
    2cb4:	0019e402 	andseq	lr, r9, r2, lsl #8
    2cb8:	01270300 			@ <UNDEFINED> instruction: 0x01270300
    2cbc:	03050106 	movweq	r0, #20742	@ 0x5106
    2cc0:	14136706 	ldrne	r6, [r3], #-1798	@ 0xfffff8fa
    2cc4:	06110522 	ldreq	r0, [r1], -r2, lsr #10
    2cc8:	2509050d 	strcs	r0, [r9, #-1293]	@ 0xfffffaf3
    2ccc:	0c052306 	stceq	3, cr2, [r5], {6}
    2cd0:	09050106 	stmdbeq	r5, {r1, r2, r8}
    2cd4:	053d3306 	ldreq	r3, [sp, #-774]!	@ 0xfffffcfa
    2cd8:	0501060c 	streq	r0, [r1, #-1548]	@ 0xfffff9f4
    2cdc:	05210609 	streq	r0, [r1, #-1545]!	@ 0xfffff9f7
    2ce0:	0176030a 	cmneq	r6, sl, lsl #6
    2ce4:	053d0505 	ldreq	r0, [sp, #-1285]!	@ 0xfffffafb
    2ce8:	0402000b 	streq	r0, [r2], #-11
    2cec:	02004d01 	andeq	r4, r0, #1, 26	@ 0x40
    2cf0:	05130104 	ldreq	r0, [r3, #-260]	@ 0xfffffefc
    2cf4:	0402000e 	streq	r0, [r2], #-14
    2cf8:	05010601 	streq	r0, [r1, #-1537]	@ 0xfffff9ff
    2cfc:	0402000b 	streq	r0, [r2], #-11
    2d00:	05210601 	streq	r0, [r1, #-1537]!	@ 0xfffff9ff
    2d04:	04020011 	streq	r0, [r2], #-17	@ 0xffffffef
    2d08:	05100601 	ldreq	r0, [r0, #-1537]	@ 0xfffff9ff
    2d0c:	0402000b 	streq	r0, [r2], #-11
    2d10:	03062201 	movweq	r2, #25089	@ 0x6201
    2d14:	0e052009 	cdpeq	0, 0, cr2, cr5, cr9, {0}
    2d18:	15050106 	strne	r0, [r5, #-262]	@ 0xfffffefa
    2d1c:	10051f06 	andne	r1, r5, r6, lsl #30
    2d20:	15050106 	strne	r0, [r5, #-262]	@ 0xfffffefa
    2d24:	00260520 	eoreq	r0, r6, r0, lsr #10
    2d28:	20010402 	andcs	r0, r1, r2, lsl #8
    2d2c:	02001505 	andeq	r1, r0, #20971520	@ 0x1400000
    2d30:	053c0104 	ldreq	r0, [ip, #-260]!	@ 0xfffffefc
    2d34:	04020036 	streq	r0, [r2], #-54	@ 0xffffffca
    2d38:	09052e02 	stmdbeq	r5, {r1, r9, sl, fp, sp}
    2d3c:	0d053206 	sfmeq	f3, 4, [r5, #-24]	@ 0xffffffe8
    2d40:	10053d92 	mulne	r5, r2, sp
    2d44:	0d050106 	stfeqs	f0, [r5, #-24]	@ 0xffffffe8
    2d48:	05132106 	ldreq	r2, [r3, #-262]	@ 0xfffffefa
    2d4c:	05110613 	ldreq	r0, [r1, #-1555]	@ 0xfffff9ed
    2d50:	0620210d 	strteq	r2, [r0], -sp, lsl #2
    2d54:	674a0903 	strbvs	r0, [sl, -r3, lsl #18]
    2d58:	01061005 	tsteq	r6, r5
    2d5c:	21060d05 	tstcs	r6, r5, lsl #26
    2d60:	06130513 			@ <UNDEFINED> instruction: 0x06130513
    2d64:	210d0511 	tstcs	sp, r1, lsl r5
    2d68:	20770306 	rsbscs	r0, r7, r6, lsl #6
    2d6c:	2e061d05 	cdpcs	13, 0, cr1, cr6, cr5, {0}
    2d70:	063c0d05 	ldrteq	r0, [ip], -r5, lsl #26
    2d74:	0610052f 	ldreq	r0, [r0], -pc, lsr #10
    2d78:	060d0501 	streq	r0, [sp], -r1, lsl #10
    2d7c:	13051321 	movwne	r1, #21281	@ 0x5321
    2d80:	0d051106 	stfeqs	f1, [r5, #-24]	@ 0xffffffe8
    2d84:	13280621 			@ <UNDEFINED> instruction: 0x13280621
    2d88:	01061005 	tsteq	r6, r5
    2d8c:	21060d05 	tstcs	r6, r5, lsl #26
    2d90:	01061105 	tsteq	r6, r5, lsl #2
    2d94:	05201005 	streq	r1, [r0, #-5]!
    2d98:	0d052c11 	stceq	12, cr2, [r5, #-68]	@ 0xffffffbc
    2d9c:	11052606 	tstne	r5, r6, lsl #12
    2da0:	10050106 	andne	r0, r5, r6, lsl #2
    2da4:	060f054a 	streq	r0, [pc], -sl, asr #10
    2da8:	12051321 	andne	r1, r5, #-2080374784	@ 0x84000000
    2dac:	0f050106 	svceq	0x00050106
    2db0:	15052106 	strne	r2, [r5, #-262]	@ 0xfffffefa
    2db4:	0f051006 	svceq	0x00051006
    2db8:	7a030622 	bvc	c4648 <__ROM_SIZE__+0x84648>
    2dbc:	12051320 	andne	r1, r5, #32, 6	@ 0x80000000
    2dc0:	16050106 	strne	r0, [r5], -r6, lsl #2
    2dc4:	0d052e1f 	stceq	14, cr2, [r5, #-124]	@ 0xffffff84
    2dc8:	010b0306 	tsteq	fp, r6, lsl #6
    2dcc:	01061105 	tsteq	r6, r5, lsl #2
    2dd0:	054a1005 	strbeq	r1, [sl, #-5]
    2dd4:	1321060f 			@ <UNDEFINED> instruction: 0x1321060f
    2dd8:	01061205 	tsteq	r6, r5, lsl #4
    2ddc:	21060f05 	tstcs	r6, r5, lsl #30
    2de0:	10061505 	andne	r1, r6, r5, lsl #10
    2de4:	05220f05 	streq	r0, [r2, #-3845]!	@ 0xfffff0fb
    2de8:	207a0314 	rsbscs	r0, sl, r4, lsl r3
    2dec:	0301052e 	movweq	r0, #5422	@ 0x152e
    2df0:	14050111 	strne	r0, [r5], #-273	@ 0xfffffeef
    2df4:	02587703 	subseq	r7, r8, #786432	@ 0xc0000
    2df8:	01010006 	tsteq	r1, r6
    2dfc:	0000032f 	andeq	r0, r0, pc, lsr #6
    2e00:	01350003 	teqeq	r5, r3
    2e04:	01020000 	mrseq	r0, (UNDEF: 2)
    2e08:	000d0efb 	strdeq	r0, [sp], -fp
    2e0c:	01010101 	tsteq	r1, r1, lsl #2
    2e10:	01000000 	mrseq	r0, (UNDEF: 0)
    2e14:	2f010000 	svccs	0x00010000
    2e18:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
    2e1c:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
    2e20:	63652f66 	cmnvs	r5, #408	@ 0x198
    2e24:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
    2e28:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
    2e2c:	662f7265 	strtvs	r7, [pc], -r5, ror #4
    2e30:	732f626f 			@ <UNDEFINED> instruction: 0x732f626f
    2e34:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
    2e38:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
    2e3c:	6974752f 	ldmdbvs	r4!, {r0, r1, r2, r3, r5, r8, sl, ip, sp, lr}^
    2e40:	2f00736c 	svccs	0x0000736c
    2e44:	2f74706f 	svccs	0x0074706f
    2e48:	2d636367 	stclcs	3, cr6, [r3, #-412]!	@ 0xfffffe64
    2e4c:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	@ 0xfffffe7c
    2e50:	656e6f6e 	strbvs	r6, [lr, #-3950]!	@ 0xfffff092
    2e54:	6261652d 	rsbvs	r6, r1, #188743680	@ 0xb400000
    2e58:	696c2f69 	stmdbvs	ip!, {r0, r3, r5, r6, r8, r9, sl, fp, sp}^
    2e5c:	63672f62 	cmnvs	r7, #392	@ 0x188
    2e60:	72612f63 	rsbvc	r2, r1, #396	@ 0x18c
    2e64:	6f6e2d6d 	svcvs	0x006e2d6d
    2e68:	652d656e 	strvs	r6, [sp, #-1390]!	@ 0xfffffa92
    2e6c:	2f696261 	svccs	0x00696261
    2e70:	322e3231 	eorcc	r3, lr, #268435459	@ 0x10000003
    2e74:	692f312e 	stmdbvs	pc!, {r1, r2, r3, r5, r8, ip, sp}	@ <UNPREDICTABLE>
    2e78:	756c636e 	strbvc	r6, [ip, #-878]!	@ 0xfffffc92
    2e7c:	2f006564 	svccs	0x00006564
    2e80:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
    2e84:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
    2e88:	63652f66 	cmnvs	r5, #408	@ 0x198
    2e8c:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
    2e90:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
    2e94:	662f7265 	strtvs	r7, [pc], -r5, ror #4
    2e98:	732f626f 			@ <UNDEFINED> instruction: 0x732f626f
    2e9c:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
    2ea0:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
    2ea4:	2f006c6c 	svccs	0x00006c6c
    2ea8:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
    2eac:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
    2eb0:	63652f66 	cmnvs	r5, #408	@ 0x198
    2eb4:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
    2eb8:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
    2ebc:	662f7265 	strtvs	r7, [pc], -r5, ror #4
    2ec0:	732f626f 			@ <UNDEFINED> instruction: 0x732f626f
    2ec4:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
    2ec8:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
    2ecc:	6932612f 	ldmdbvs	r2!, {r0, r1, r2, r3, r5, r8, sp, lr}
    2ed0:	6f682f00 	svcvs	0x00682f00
    2ed4:	652f656d 	strvs	r6, [pc, #-1389]!	@ 296f <_varcar_mesg+0x7>
    2ed8:	2f667463 	svccs	0x00667463
    2edc:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    2ee0:	6172742d 	cmnvs	r2, sp, lsr #8
    2ee4:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
    2ee8:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
    2eec:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
    2ef0:	6c2f6c6c 	stcvs	12, cr6, [pc], #-432	@ 2d48 <cmd_end_+0x2fc>
    2ef4:	702f6269 	eorvc	r6, pc, r9, ror #4
    2ef8:	746e6972 	strbtvc	r6, [lr], #-2418	@ 0xfffff68e
    2efc:	75000066 	strvc	r0, [r0, #-102]	@ 0xffffff9a
    2f00:	736c6974 	cmnvc	ip, #116, 18	@ 0x1d0000
    2f04:	0100632e 	tsteq	r0, lr, lsr #6
    2f08:	74730000 	ldrbtvc	r0, [r3], #-0
    2f0c:	746e6964 	strbtvc	r6, [lr], #-2404	@ 0xfffff69c
    2f10:	6363672d 	cmnvs	r3, #11796480	@ 0xb40000
    2f14:	0200682e 	andeq	r6, r0, #3014656	@ 0x2e0000
    2f18:	68730000 	ldmdavs	r3!, {}^	@ <UNPREDICTABLE>
    2f1c:	2e6c6c65 	cdpcs	12, 6, cr6, cr12, cr5, {3}
    2f20:	00030068 	andeq	r0, r3, r8, rrx
    2f24:	69326100 	ldmdbvs	r2!, {r8, sp, lr}
    2f28:	0400682e 	streq	r6, [r0], #-2094	@ 0xfffff7d2
    2f2c:	72700000 	rsbsvc	r0, r0, #0
    2f30:	66746e69 	ldrbtvs	r6, [r4], -r9, ror #28
    2f34:	0500682e 	streq	r6, [r0, #-2094]	@ 0xfffff7d2
    2f38:	05000000 	streq	r0, [r0, #-0]
    2f3c:	02050021 	andeq	r0, r5, #33	@ 0x21
    2f40:	00001ac0 	andeq	r1, r0, r0, asr #21
    2f44:	06011803 	streq	r1, [r1], -r3, lsl #16
    2f48:	06030501 	streq	r0, [r3], -r1, lsl #10
    2f4c:	06060521 	streq	r0, [r6], -r1, lsr #10
    2f50:	06030501 	streq	r0, [r3], -r1, lsl #10
    2f54:	06130533 			@ <UNDEFINED> instruction: 0x06130533
    2f58:	052e2001 	streq	r2, [lr, #-1]!
    2f5c:	14210603 	strtne	r0, [r1], #-1539	@ 0xfffff9fd
    2f60:	01060805 	tsteq	r6, r5, lsl #16
    2f64:	22060305 	andcs	r0, r6, #335544320	@ 0x14000000
    2f68:	2f062006 	svccs	0x00062006
    2f6c:	01060a05 	tsteq	r6, r5, lsl #20
    2f70:	05210105 	streq	r0, [r1, #-261]!	@ 0xfffffefb
    2f74:	75030605 	strvc	r0, [r3, #-1541]	@ 0xfffff9fb
    2f78:	20200620 	eorcs	r0, r0, r0, lsr #12
    2f7c:	0c052f06 	stceq	15, cr2, [r5], {6}
    2f80:	21050106 	tstcs	r5, r6, lsl #2
    2f84:	740c0306 	strvc	r0, [ip], #-774	@ 0xfffffcfa
    2f88:	03050106 	movweq	r0, #20742	@ 0x5106
    2f8c:	06052f06 	streq	r2, [r5], -r6, lsl #30
    2f90:	03050106 	movweq	r0, #20742	@ 0x5106
    2f94:	13053206 	movwne	r3, #20998	@ 0x5206
    2f98:	2e200106 	sufcss	f0, f0, f6
    2f9c:	21060305 	tstcs	r6, r5, lsl #6
    2fa0:	01061305 	tsteq	r6, r5, lsl #6
    2fa4:	06030520 	streq	r0, [r3], -r0, lsr #10
    2fa8:	060f052f 	streq	r0, [pc], -pc, lsr #10
    2fac:	06030501 	streq	r0, [r3], -r1, lsl #10
    2fb0:	060a0522 	streq	r0, [sl], -r2, lsr #10
    2fb4:	21010501 	tstcs	r1, r1, lsl #10
    2fb8:	03060505 	movweq	r0, #25861	@ 0x6505
    2fbc:	20062078 	andcs	r2, r6, r8, ror r0
    2fc0:	052f0620 	streq	r0, [pc, #-1568]!	@ 29a8 <_vardecode64+0x4>
    2fc4:	0501060c 	streq	r0, [r1, #-1548]	@ 0xfffff9f4
    2fc8:	09030626 	stmdbeq	r3, {r1, r2, r5, r9, sl}
    2fcc:	05010666 	streq	r0, [r1, #-1638]	@ 0xfffff99a
    2fd0:	052f0603 	streq	r0, [pc, #-1539]!	@ 29d5 <_varsha256_test+0x1>
    2fd4:	05010606 	streq	r0, [r1, #-1542]	@ 0xfffff9fa
    2fd8:	05330603 	ldreq	r0, [r3, #-1539]!	@ 0xfffff9fd
    2fdc:	20010613 	andcs	r0, r1, r3, lsl r6
    2fe0:	0603052e 	streq	r0, [r3], -lr, lsr #10
    2fe4:	06150521 	ldreq	r0, [r5], -r1, lsr #10
    2fe8:	03052001 	movweq	r2, #20481	@ 0x5001
    2fec:	08053e06 	stmdaeq	r5, {r1, r2, r9, sl, fp, ip, sp}
    2ff0:	06110501 	ldreq	r0, [r1], -r1, lsl #10
    2ff4:	20030501 	andcs	r0, r3, r1, lsl #10
    2ff8:	06050520 	streq	r0, [r5], -r0, lsr #10
    2ffc:	06017903 	streq	r7, [r1], -r3, lsl #18
    3000:	2f062020 	svccs	0x00062020
    3004:	01060c05 	tsteq	r6, r5, lsl #24
    3008:	02000505 	andeq	r0, r0, #20971520	@ 0x1400000
    300c:	43060304 	movwmi	r0, #25348	@ 0x6304
    3010:	02000a05 	andeq	r0, r0, #20480	@ 0x5000
    3014:	01060304 	tsteq	r6, r4, lsl #6
    3018:	02000505 	andeq	r0, r0, #20971520	@ 0x1400000
    301c:	21060304 	tstcs	r6, r4, lsl #6
    3020:	03040200 	movweq	r0, #16896	@ 0x4200
    3024:	000a054c 	andeq	r0, sl, ip, asr #10
    3028:	06030402 	streq	r0, [r3], -r2, lsl #8
    302c:	002f0501 	eoreq	r0, pc, r1, lsl #10
    3030:	06030402 	streq	r0, [r3], -r2, lsl #8
    3034:	0024051c 	eoreq	r0, r4, ip, lsl r5
    3038:	20010402 	andcs	r0, r1, r2, lsl #8
    303c:	01040200 	mrseq	r0, R12_usr
    3040:	0a052e06 	beq	14e860 <__ROM_SIZE__+0x10e860>
    3044:	21010519 	tstcs	r1, r9, lsl r5
    3048:	01065c06 	tsteq	r6, r6, lsl #24
    304c:	2f060305 	svccs	0x00060305
    3050:	01060605 	tsteq	r6, r5, lsl #12
    3054:	32060305 	andcc	r0, r6, #335544320	@ 0x14000000
    3058:	01061305 	tsteq	r6, r5, lsl #6
    305c:	03052e20 	movweq	r2, #24096	@ 0x5e20
    3060:	16052106 	strne	r2, [r5], -r6, lsl #2
    3064:	05200106 	streq	r0, [r0, #-262]!	@ 0xfffffefa
    3068:	053d0603 	ldreq	r0, [sp, #-1539]!	@ 0xfffff9fd
    306c:	20010616 	andcs	r0, r1, r6, lsl r6
    3070:	30060305 	andcc	r0, r6, r5, lsl #6
    3074:	01060605 	tsteq	r6, r5, lsl #12
    3078:	33060305 	movwcc	r0, #25349	@ 0x6305
    307c:	01060605 	tsteq	r6, r5, lsl #12
    3080:	33060305 	movwcc	r0, #25349	@ 0x6305
    3084:	01060c05 	tsteq	r6, r5, lsl #24
    3088:	21060305 	tstcs	r6, r5, lsl #6
    308c:	01061a05 	tsteq	r6, r5, lsl #20
    3090:	052e0805 	streq	r0, [lr, #-2053]!	@ 0xfffff7fb
    3094:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
    3098:	05010613 	streq	r0, [r1, #-1555]	@ 0xfffff9ed
    309c:	08053c1c 	stmdaeq	r5, {r2, r3, r4, sl, fp, ip, sp}
    30a0:	06030520 	streq	r0, [r3], -r0, lsr #10
    30a4:	060f052f 	streq	r0, [pc], -pc, lsr #10
    30a8:	06030501 	streq	r0, [r3], -r1, lsl #10
    30ac:	060a0522 	streq	r0, [sl], -r2, lsr #10
    30b0:	24010501 	strcs	r0, [r1], #-1281	@ 0xfffffaff
    30b4:	03060505 	movweq	r0, #25861	@ 0x6505
    30b8:	2006206e 	andcs	r2, r6, lr, rrx
    30bc:	06242f06 	strteq	r2, [r4], -r6, lsl #30
    30c0:	052f0620 	streq	r0, [pc, #-1568]!	@ 2aa8 <cmd_end_+0x5c>
    30c4:	010a0303 	tsteq	sl, r3, lsl #6
    30c8:	060a054b 	streq	r0, [sl], -fp, asr #10
    30cc:	06010501 	streq	r0, [r1], -r1, lsl #10
    30d0:	05010694 	streq	r0, [r1, #-1684]	@ 0xfffff96c
    30d4:	052f0603 	streq	r0, [pc, #-1539]!	@ 2ad9 <cmd_end_+0x8d>
    30d8:	05010606 	streq	r0, [r1, #-1542]	@ 0xfffff9fa
    30dc:	05320603 	ldreq	r0, [r2, #-1539]!	@ 0xfffff9fd
    30e0:	20010613 	andcs	r0, r1, r3, lsl r6
    30e4:	0603052e 	streq	r0, [r3], -lr, lsr #10
    30e8:	06160521 	ldreq	r0, [r6], -r1, lsr #10
    30ec:	03052001 	movweq	r2, #20481	@ 0x5001
    30f0:	06053e06 	streq	r3, [r5], -r6, lsl #28
    30f4:	03050106 	movweq	r0, #20742	@ 0x5106
    30f8:	0c053306 	stceq	3, cr3, [r5], {6}
    30fc:	03050106 	movweq	r0, #20742	@ 0x5106
    3100:	1c052106 	stfnes	f2, [r5], {6}
    3104:	03050106 	movweq	r0, #20742	@ 0x5106
    3108:	2e062106 	adfcss	f2, f6, f6
    310c:	052f062e 	streq	r0, [pc, #-1582]!	@ 2ae6 <cmd_end_+0x9a>
    3110:	0501060a 	streq	r0, [r1, #-1546]	@ 0xfffff9f6
    3114:	05052501 	streq	r2, [r5, #-1281]	@ 0xfffffaff
    3118:	20740306 	rsbscs	r0, r4, r6, lsl #6
    311c:	2f062006 	svccs	0x00062006
    3120:	09030305 	stmdbeq	r3, {r0, r2, r8, r9}
    3124:	0a054b01 	beq	155d30 <__ROM_SIZE__+0x115d30>
    3128:	09020106 	stmdbeq	r2, {r1, r2, r8}
    312c:	15010100 	strne	r0, [r1, #-256]	@ 0xffffff00
    3130:	0300000b 	movweq	r0, #11
    3134:	0000e500 	andeq	lr, r0, r0, lsl #10
    3138:	fb010200 	blx	43942 <__ROM_SIZE__+0x3942>
    313c:	01000d0e 	tsteq	r0, lr, lsl #26
    3140:	00010101 	andeq	r0, r1, r1, lsl #2
    3144:	00010000 	andeq	r0, r1, r0
    3148:	682f0100 	stmdavs	pc!, {r8}	@ <UNPREDICTABLE>
    314c:	2f656d6f 	svccs	0x00656d6f
    3150:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    3154:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
    3158:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
    315c:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
    3160:	6f662f72 	svcvs	0x00662f72
    3164:	68732f62 	ldmdavs	r3!, {r1, r5, r6, r8, r9, sl, fp, sp}^
    3168:	2f6c6c65 	svccs	0x006c6c65
    316c:	2f62696c 	svccs	0x0062696c
    3170:	796e6974 	stmdbvc	lr!, {r2, r4, r5, r6, r8, fp, sp, lr}^
    3174:	7365612d 	cmnvc	r5, #1073741835	@ 0x4000000b
    3178:	706f2f00 	rsbvc	r2, pc, r0, lsl #30
    317c:	63672f74 	cmnvs	r7, #116, 30	@ 0x1d0
    3180:	72612d63 	rsbvc	r2, r1, #6336	@ 0x18c0
    3184:	6f6e2d6d 	svcvs	0x006e2d6d
    3188:	652d656e 	strvs	r6, [sp, #-1390]!	@ 0xfffffa92
    318c:	2f696261 	svccs	0x00696261
    3190:	2f62696c 	svccs	0x0062696c
    3194:	2f636367 	svccs	0x00636367
    3198:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	@ 0xfffffe7c
    319c:	656e6f6e 	strbvs	r6, [lr, #-3950]!	@ 0xfffff092
    31a0:	6261652d 	rsbvs	r6, r1, #188743680	@ 0xb400000
    31a4:	32312f69 	eorscc	r2, r1, #420	@ 0x1a4
    31a8:	312e322e 			@ <UNDEFINED> instruction: 0x312e322e
    31ac:	636e692f 	cmnvs	lr, #770048	@ 0xbc000
    31b0:	6564756c 	strbvs	r7, [r4, #-1388]!	@ 0xfffffa94
    31b4:	6f682f00 	svcvs	0x00682f00
    31b8:	652f656d 	strvs	r6, [pc, #-1389]!	@ 2c53 <cmd_end_+0x207>
    31bc:	2f667463 	svccs	0x00667463
    31c0:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    31c4:	6172742d 	cmnvs	r2, sp, lsr #8
    31c8:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
    31cc:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
    31d0:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
    31d4:	6c2f6c6c 	stcvs	12, cr6, [pc], #-432	@ 302c <cmd_end_+0x5e0>
    31d8:	732f6269 			@ <UNDEFINED> instruction: 0x732f6269
    31dc:	6e697274 	mcrvs	2, 3, r7, cr9, cr4, {3}
    31e0:	61000067 	tstvs	r0, r7, rrx
    31e4:	632e7365 			@ <UNDEFINED> instruction: 0x632e7365
    31e8:	00000100 	andeq	r0, r0, r0, lsl #2
    31ec:	64647473 	strbtvs	r7, [r4], #-1139	@ 0xfffffb8d
    31f0:	682e6665 	stmdavs	lr!, {r0, r2, r5, r6, r9, sl, sp, lr}
    31f4:	00000200 	andeq	r0, r0, r0, lsl #4
    31f8:	69647473 	stmdbvs	r4!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
    31fc:	672d746e 	strvs	r7, [sp, -lr, ror #8]!
    3200:	682e6363 	stmdavs	lr!, {r0, r1, r5, r6, r8, r9, sp, lr}
    3204:	00000200 	andeq	r0, r0, r0, lsl #4
    3208:	2e736561 	cdpcs	5, 7, cr6, cr3, cr1, {3}
    320c:	00010068 	andeq	r0, r1, r8, rrx
    3210:	72747300 	rsbsvc	r7, r4, #0, 6
    3214:	2e676e69 	cdpcs	14, 6, cr6, cr7, cr9, {3}
    3218:	00030068 	andeq	r0, r3, r8, rrx
    321c:	01050000 	mrseq	r0, (UNDEF: 5)
    3220:	20020500 	andcs	r0, r2, r0, lsl #10
    3224:	0300001c 	movweq	r0, #28
    3228:	06010192 			@ <UNDEFINED> instruction: 0x06010192
    322c:	06030501 	streq	r0, [r3], -r1, lsl #10
    3230:	0515132f 	ldreq	r1, [r5, #-815]	@ 0xfffffcd1
    3234:	0501060a 	streq	r0, [r1, #-1546]	@ 0xfffff9f6
    3238:	05052003 	streq	r2, [r5, #-3]
    323c:	03040200 	movweq	r0, #16896	@ 0x4200
    3240:	24052206 	strcs	r2, [r5], #-518	@ 0xfffffdfa
    3244:	03040200 	movweq	r0, #16896	@ 0x4200
    3248:	20050106 	andcs	r0, r5, r6, lsl #2
    324c:	03040200 	movweq	r0, #16896	@ 0x4200
    3250:	001b0520 	andseq	r0, fp, r0, lsr #10
    3254:	2e030402 	cdpcs	4, 0, cr0, cr3, cr2, {0}
    3258:	02000505 	andeq	r0, r0, #20971520	@ 0x1400000
    325c:	2f060304 	svccs	0x00060304
    3260:	02002005 	andeq	r2, r0, #5
    3264:	01060304 	tsteq	r6, r4, lsl #6
    3268:	02001b05 	andeq	r1, r0, #5120	@ 0x1400
    326c:	052e0304 	streq	r0, [lr, #-772]!	@ 0xfffffcfc
    3270:	04020005 	streq	r0, [r2], #-5
    3274:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
    3278:	04020020 	streq	r0, [r2], #-32	@ 0xffffffe0
    327c:	05010603 	streq	r0, [r1, #-1539]	@ 0xfffff9fd
    3280:	0402001b 	streq	r0, [r2], #-27	@ 0xffffffe5
    3284:	05052e03 	streq	r2, [r5, #-3587]	@ 0xfffff1fd
    3288:	03040200 	movweq	r0, #16896	@ 0x4200
    328c:	20052106 	andcs	r2, r5, r6, lsl #2
    3290:	03040200 	movweq	r0, #16896	@ 0x4200
    3294:	1b050106 	blne	1436b4 <__ROM_SIZE__+0x1036b4>
    3298:	03040200 	movweq	r0, #16896	@ 0x4200
    329c:	0017052e 	andseq	r0, r7, lr, lsr #10
    32a0:	06030402 	streq	r0, [r3], -r2, lsl #8
    32a4:	0011051b 	andseq	r0, r1, fp, lsl r5
    32a8:	20010402 	andcs	r0, r1, r2, lsl #8
    32ac:	03060a05 	movweq	r0, #27141	@ 0x6a05
    32b0:	05052e09 	streq	r2, [r5, #-3593]	@ 0xfffff1f7
    32b4:	2e270306 	cdpcs	3, 2, cr0, cr7, cr6, {0}
    32b8:	01060805 	tsteq	r6, r5, lsl #16
    32bc:	02000505 	andeq	r0, r0, #20971520	@ 0x1400000
    32c0:	03060204 	movweq	r0, #25092	@ 0x6204
    32c4:	07052e0b 	streq	r2, [r5, -fp, lsl #28]
    32c8:	02040200 	andeq	r0, r4, #0, 4
    32cc:	10050106 	andne	r0, r5, r6, lsl #2
    32d0:	02040200 	andeq	r0, r4, #0, 4
    32d4:	15052006 	strne	r2, [r5, #-6]
    32d8:	02040200 	andeq	r0, r4, #0, 4
    32dc:	05050106 	streq	r0, [r5, #-262]	@ 0xfffffefa
    32e0:	02040200 	andeq	r0, r4, #0, 4
    32e4:	1f052f06 	svcne	0x00052f06
    32e8:	02040200 	andeq	r0, r4, #0, 4
    32ec:	2e050106 	adfcss	f0, f5, f6
    32f0:	02040200 	andeq	r0, r4, #0, 4
    32f4:	0015052e 	andseq	r0, r5, lr, lsr #10
    32f8:	2e020402 	cdpcs	4, 0, cr0, cr2, cr2, {0}
    32fc:	02000505 	andeq	r0, r0, #20971520	@ 0x1400000
    3300:	4b060204 	blmi	183b18 <__ROM_SIZE__+0x143b18>
    3304:	02001f05 	andeq	r1, r0, #5, 30
    3308:	01060204 	tsteq	r6, r4, lsl #4
    330c:	02040200 	andeq	r0, r4, #0, 4
    3310:	002e052e 	eoreq	r0, lr, lr, lsr #10
    3314:	2e020402 	cdpcs	4, 0, cr0, cr2, cr2, {0}
    3318:	02000d05 	andeq	r0, r0, #320	@ 0x140
    331c:	052e0204 	streq	r0, [lr, #-516]!	@ 0xfffffdfc
    3320:	04020015 	streq	r0, [r2], #-21	@ 0xffffffeb
    3324:	05052002 	streq	r2, [r5, #-2]
    3328:	02040200 	andeq	r0, r4, #0, 4
    332c:	1f054b06 	svcne	0x00054b06
    3330:	02040200 	andeq	r0, r4, #0, 4
    3334:	2e050106 	adfcss	f0, f5, f6
    3338:	02040200 	andeq	r0, r4, #0, 4
    333c:	000d052e 	andeq	r0, sp, lr, lsr #10
    3340:	2e020402 	cdpcs	4, 0, cr0, cr2, cr2, {0}
    3344:	02001505 	andeq	r1, r0, #20971520	@ 0x1400000
    3348:	05200204 	streq	r0, [r0, #-516]!	@ 0xfffffdfc
    334c:	04020005 	streq	r0, [r2], #-5
    3350:	054b0602 	strbeq	r0, [fp, #-1538]	@ 0xfffff9fe
    3354:	0402001f 	streq	r0, [r2], #-31	@ 0xffffffe1
    3358:	05010602 	streq	r0, [r1, #-1538]	@ 0xfffff9fe
    335c:	0402002e 	streq	r0, [r2], #-46	@ 0xffffffd2
    3360:	0d052002 	stceq	0, cr2, [r5, #-8]
    3364:	02040200 	andeq	r0, r4, #0, 4
    3368:	0015052e 	andseq	r0, r5, lr, lsr #10
    336c:	20020402 	andcs	r0, r2, r2, lsl #8
    3370:	02002305 	andeq	r2, r0, #335544320	@ 0x14000000
    3374:	03060204 	movweq	r0, #25092	@ 0x6204
    3378:	12052e4a 	andne	r2, r5, #1184	@ 0x4a0
    337c:	01040200 	mrseq	r0, R12_usr
    3380:	31070520 	tstcc	r7, r0, lsr #10
    3384:	01060e05 	tsteq	r6, r5, lsl #28
    3388:	21060705 	tstcs	r6, r5, lsl #14
    338c:	01061805 	tsteq	r6, r5, lsl #16
    3390:	052e0f05 	streq	r0, [lr, #-3845]!	@ 0xfffff0fb
    3394:	052f0607 	streq	r0, [pc, #-1543]!	@ 2d95 <cmd_end_+0x349>
    3398:	2e010618 	mcrcs	6, 0, r0, cr1, cr8, {0}
    339c:	05200f05 	streq	r0, [r0, #-3845]!	@ 0xfffff0fb
    33a0:	052f0607 	streq	r0, [pc, #-1543]!	@ 2da1 <cmd_end_+0x355>
    33a4:	05010618 	streq	r0, [r1, #-1560]	@ 0xfffff9e8
    33a8:	07052e0f 	streq	r2, [r5, -pc, lsl #28]
    33ac:	18052f06 	stmdane	r5, {r1, r2, r8, r9, sl, fp, sp}
    33b0:	0f050106 	svceq	0x00050106
    33b4:	0605052e 	streq	r0, [r5], -lr, lsr #10
    33b8:	06080532 			@ <UNDEFINED> instruction: 0x06080532
    33bc:	06090501 	streq	r0, [r9], -r1, lsl #10
    33c0:	12051343 	andne	r1, r5, #201326593	@ 0xc000001
    33c4:	09050106 	stmdbeq	r5, {r1, r2, r8}
    33c8:	12052f06 	andne	r2, r5, #6, 30
    33cc:	09050106 	stmdbeq	r5, {r1, r2, r8}
    33d0:	12052f06 	andne	r2, r5, #6, 30
    33d4:	09050106 	stmdbeq	r5, {r1, r2, r8}
    33d8:	12052f06 	andne	r2, r5, #6, 30
    33dc:	09050106 	stmdbeq	r5, {r1, r2, r8}
    33e0:	14053606 	strne	r3, [r5], #-1542	@ 0xfffff9fa
    33e4:	12050106 	andne	r0, r5, #-2147483647	@ 0x80000001
    33e8:	0609052e 	streq	r0, [r9], -lr, lsr #10
    33ec:	0614052f 	ldreq	r0, [r4], -pc, lsr #10
    33f0:	2e120501 	cfmul32cs	mvfx0, mvfx2, mvfx1
    33f4:	2f060905 	svccs	0x00060905
    33f8:	01061405 	tsteq	r6, r5, lsl #8
    33fc:	052e1205 	streq	r1, [lr, #-517]!	@ 0xfffffdfb
    3400:	052f0609 	streq	r0, [pc, #-1545]!	@ 2dff <cmd_end_+0x3b3>
    3404:	05010614 	streq	r0, [r1, #-1556]	@ 0xfffff9ec
    3408:	07052012 	smladeq	r5, r2, r0, r2
    340c:	21053106 	tstcs	r5, r6, lsl #2
    3410:	10050106 	andne	r0, r5, r6, lsl #2
    3414:	0609054a 	streq	r0, [r9], -sl, asr #10
    3418:	06140551 			@ <UNDEFINED> instruction: 0x06140551
    341c:	4a120501 	bmi	484828 <__ROM_SIZE__+0x444828>
    3420:	2f060905 	svccs	0x00060905
    3424:	01061405 	tsteq	r6, r5, lsl #8
    3428:	053c1205 	ldreq	r1, [ip, #-517]!	@ 0xfffffdfb
    342c:	052f0609 	streq	r0, [pc, #-1545]!	@ 2e2b <cmd_end_+0x3df>
    3430:	05010614 	streq	r0, [r1, #-1556]	@ 0xfffff9ec
    3434:	09053c12 	stmdbeq	r5, {r1, r4, sl, fp, ip, sp}
    3438:	14052f06 	strne	r2, [r5], #-3846	@ 0xfffff0fa
    343c:	12050106 	andne	r0, r5, #-2147483647	@ 0x80000001
    3440:	0301053c 	movweq	r0, #5436	@ 0x153c
    3444:	00063c0a 	andeq	r3, r6, sl, lsl #24
    3448:	1d400205 	sfmne	f0, 2, [r0, #-20]	@ 0xffffffec
    344c:	15030000 	strne	r0, [r3, #-0]
    3450:	05010601 	streq	r0, [r1, #-1537]	@ 0xfffff9ff
    3454:	13210603 			@ <UNDEFINED> instruction: 0x13210603
    3458:	01060a05 	tsteq	r6, r5, lsl #20
    345c:	05200305 	streq	r0, [r0, #-773]!	@ 0xfffffcfb
    3460:	04020007 	streq	r0, [r2], #-7
    3464:	05240603 	streq	r0, [r4, #-1539]!	@ 0xfffff9fd
    3468:	04020012 	streq	r0, [r2], #-18	@ 0xffffffee
    346c:	05010603 	streq	r0, [r1, #-1539]	@ 0xfffff9fd
    3470:	04020033 	streq	r0, [r2], #-51	@ 0xffffffcd
    3474:	3e054a03 	vmlacc.f32	s8, s10, s6
    3478:	03040200 	movweq	r0, #16896	@ 0x4200
    347c:	0021052e 	eoreq	r0, r1, lr, lsr #10
    3480:	2e030402 	cdpcs	4, 0, cr0, cr3, cr2, {0}
    3484:	02001605 	andeq	r1, r0, #5242880	@ 0x500000
    3488:	052e0304 	streq	r0, [lr, #-772]!	@ 0xfffffcfc
    348c:	04020018 	streq	r0, [r2], #-24	@ 0xffffffe8
    3490:	00480603 	subeq	r0, r8, r3, lsl #12
    3494:	06030402 	streq	r0, [r3], -r2, lsl #8
    3498:	00130520 	andseq	r0, r3, r0, lsr #10
    349c:	06010402 	streq	r0, [r1], -r2, lsl #8
    34a0:	00160520 	andseq	r0, r6, r0, lsr #10
    34a4:	2c020402 	cfstrscs	mvf0, [r2], {2}
    34a8:	02040200 	andeq	r0, r4, #0, 4
    34ac:	11052006 	tstne	r5, r6
    34b0:	01040200 	mrseq	r0, R12_usr
    34b4:	0c052006 	stceq	0, cr2, [r5], {6}
    34b8:	01053006 	tsteq	r5, r6
    34bc:	00062033 	andeq	r2, r6, r3, lsr r0
    34c0:	1d780205 	lfmne	f0, 2, [r8, #-20]!	@ 0xffffffec
    34c4:	05170000 	ldreq	r0, [r7, #-0]
    34c8:	05131303 	ldreq	r1, [r3, #-771]	@ 0xfffffcfd
    34cc:	0501060a 	streq	r0, [r1, #-1546]	@ 0xfffff9f6
    34d0:	05200611 	streq	r0, [r0, #-1553]!	@ 0xfffff9ef
    34d4:	0530060c 	ldreq	r0, [r0, #-1548]!	@ 0xfffff9f4
    34d8:	05200613 	streq	r0, [r0, #-1555]!	@ 0xfffff9ed
    34dc:	052a0601 	streq	r0, [sl, #-1537]!	@ 0xfffff9ff
    34e0:	04020007 	streq	r0, [r2], #-7
    34e4:	05260603 	streq	r0, [r6, #-1539]!	@ 0xfffff9fd
    34e8:	04020018 	streq	r0, [r2], #-24	@ 0xffffffe8
    34ec:	05010603 	streq	r0, [r1, #-1539]	@ 0xfffff9fd
    34f0:	04020016 	streq	r0, [r2], #-22	@ 0xffffffea
    34f4:	18057403 	stmdane	r5, {r0, r1, sl, ip, sp, lr}
    34f8:	03040200 	movweq	r0, #16896	@ 0x4200
    34fc:	02002c06 	andeq	r2, r0, #1536	@ 0x600
    3500:	20060304 	andcs	r0, r6, r4, lsl #6
    3504:	02001305 	andeq	r1, r0, #335544320	@ 0x14000000
    3508:	20060104 	andcs	r0, r6, r4, lsl #2
    350c:	02001605 	andeq	r1, r0, #5242880	@ 0x500000
    3510:	002c0204 	eoreq	r0, ip, r4, lsl #4
    3514:	06020402 	streq	r0, [r2], -r2, lsl #8
    3518:	00110520 	andseq	r0, r1, r0, lsr #10
    351c:	06020402 	streq	r0, [r2], -r2, lsl #8
    3520:	060c0520 	streq	r0, [ip], -r0, lsr #10
    3524:	01052030 	tsteq	r5, r0, lsr r0
    3528:	06160525 	ldreq	r0, [r6], -r5, lsr #10
    352c:	062e7903 	strteq	r7, [lr], -r3, lsl #18
    3530:	05202020 	streq	r2, [r0, #-32]!	@ 0xffffffe0
    3534:	0d030601 	stceq	6, cr0, [r3, #-4]
    3538:	1303053c 	movwne	r0, #13628	@ 0x353c
    353c:	06120515 			@ <UNDEFINED> instruction: 0x06120515
    3540:	06030501 	streq	r0, [r3], -r1, lsl #10
    3544:	061f0521 	ldreq	r0, [pc], -r1, lsr #10
    3548:	20120501 	andscs	r0, r2, r1, lsl #10
    354c:	21060305 	tstcs	r6, r5, lsl #6
    3550:	01061f05 	tsteq	r6, r5, lsl #30
    3554:	05201205 	streq	r1, [r0, #-517]!	@ 0xfffffdfb
    3558:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
    355c:	0501061f 	streq	r0, [r1, #-1567]	@ 0xfffff9e1
    3560:	03052012 	movweq	r2, #20498	@ 0x5012
    3564:	12052106 	andne	r2, r5, #-2147483647	@ 0x80000001
    3568:	03050106 	movweq	r0, #20742	@ 0x5106
    356c:	12052306 	andne	r2, r5, #402653184	@ 0x18000000
    3570:	03050106 	movweq	r0, #20742	@ 0x5106
    3574:	1f052106 	svcne	0x00052106
    3578:	12050106 	andne	r0, r5, #-2147483647	@ 0x80000001
    357c:	06030520 	streq	r0, [r3], -r0, lsr #10
    3580:	06120521 	ldreq	r0, [r2], -r1, lsr #10
    3584:	06030501 	streq	r0, [r3], -r1, lsl #10
    3588:	06120522 	ldreq	r0, [r2], -r2, lsr #10
    358c:	06030501 	streq	r0, [r3], -r1, lsl #10
    3590:	061f0521 	ldreq	r0, [pc], -r1, lsr #10
    3594:	20120501 	andscs	r0, r2, r1, lsl #10
    3598:	21060305 	tstcs	r6, r5, lsl #6
    359c:	01061205 	tsteq	r6, r5, lsl #4
    35a0:	23060305 	movwcs	r0, #25349	@ 0x6305
    35a4:	01061205 	tsteq	r6, r5, lsl #4
    35a8:	21060305 	tstcs	r6, r5, lsl #6
    35ac:	01061f05 	tsteq	r6, r5, lsl #30
    35b0:	05201205 	streq	r1, [r0, #-517]!	@ 0xfffffdfb
    35b4:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
    35b8:	0501061f 	streq	r0, [r1, #-1567]	@ 0xfffff9e1
    35bc:	03052012 	movweq	r2, #20498	@ 0x5012
    35c0:	1f052106 	svcne	0x00052106
    35c4:	12050106 	andne	r0, r5, #-2147483647	@ 0x80000001
    35c8:	06030520 	streq	r0, [r3], -r0, lsr #10
    35cc:	06120521 	ldreq	r0, [r2], -r1, lsr #10
    35d0:	21010501 	tstcs	r1, r1, lsl #10
    35d4:	03052306 	movweq	r2, #21254	@ 0x5306
    35d8:	06120513 			@ <UNDEFINED> instruction: 0x06120513
    35dc:	75010501 	strvc	r0, [r1, #-1281]	@ 0xfffffaff
    35e0:	01063206 	tsteq	r6, r6, lsl #4
    35e4:	3d060305 	stccc	3, cr0, [r6, #-20]	@ 0xffffffec
    35e8:	0a051313 	beq	14823c <__ROM_SIZE__+0x10823c>
    35ec:	03050106 	movweq	r0, #20742	@ 0x5106
    35f0:	00050520 	andeq	r0, r5, r0, lsr #10
    35f4:	06030402 	streq	r0, [r3], -r2, lsl #8
    35f8:	00090522 	andeq	r0, r9, r2, lsr #10
    35fc:	06030402 	streq	r0, [r3], -r2, lsl #8
    3600:	00050501 	andeq	r0, r5, r1, lsl #10
    3604:	06030402 	streq	r0, [r3], -r2, lsl #8
    3608:	0027052f 	eoreq	r0, r7, pc, lsr #10
    360c:	06030402 	streq	r0, [r3], -r2, lsl #8
    3610:	00090501 	andeq	r0, r9, r1, lsl #10
    3614:	4a030402 	bmi	c4624 <__ROM_SIZE__+0x84624>
    3618:	02003805 	andeq	r3, r0, #327680	@ 0x50000
    361c:	052e0304 	streq	r0, [lr, #-772]!	@ 0xfffffcfc
    3620:	04020049 	streq	r0, [r2], #-73	@ 0xffffffb7
    3624:	09052e03 	stmdbeq	r5, {r0, r1, r9, sl, fp, sp}
    3628:	03040200 	movweq	r0, #16896	@ 0x4200
    362c:	00050520 	andeq	r0, r5, r0, lsr #10
    3630:	06030402 	streq	r0, [r3], -r2, lsl #8
    3634:	002d053d 	eoreq	r0, sp, sp, lsr r5
    3638:	01030402 	tsteq	r3, r2, lsl #8
    363c:	02003205 	andeq	r3, r0, #1342177280	@ 0x50000000
    3640:	01060304 	tsteq	r6, r4, lsl #6
    3644:	02003e05 	andeq	r3, r0, #5, 28	@ 0x50
    3648:	2e060304 	cdpcs	3, 0, cr0, cr6, cr4, {0}
    364c:	02004d05 	andeq	r4, r0, #320	@ 0x140
    3650:	01060304 	tsteq	r6, r4, lsl #6
    3654:	03040200 	movweq	r0, #16896	@ 0x4200
    3658:	00050520 	andeq	r0, r5, r0, lsr #10
    365c:	06030402 	streq	r0, [r3], -r2, lsl #8
    3660:	002d054b 	eoreq	r0, sp, fp, asr #10
    3664:	01030402 	tsteq	r3, r2, lsl #8
    3668:	02003205 	andeq	r3, r0, #1342177280	@ 0x50000000
    366c:	01060304 	tsteq	r6, r4, lsl #6
    3670:	03040200 	movweq	r0, #16896	@ 0x4200
    3674:	003e052e 	eorseq	r0, lr, lr, lsr #10
    3678:	06030402 	streq	r0, [r3], -r2, lsl #8
    367c:	004d052e 	subeq	r0, sp, lr, lsr #10
    3680:	06030402 	streq	r0, [r3], -r2, lsl #8
    3684:	04020001 	streq	r0, [r2], #-1
    3688:	05052003 	streq	r2, [r5, #-3]
    368c:	03040200 	movweq	r0, #16896	@ 0x4200
    3690:	2d054b06 	vstrcs	d4, [r5, #-24]	@ 0xffffffe8
    3694:	03040200 	movweq	r0, #16896	@ 0x4200
    3698:	00320501 	eorseq	r0, r2, r1, lsl #10
    369c:	06030402 	streq	r0, [r3], -r2, lsl #8
    36a0:	04020001 	streq	r0, [r2], #-1
    36a4:	3e052e03 	cdpcc	14, 0, cr2, cr5, cr3, {0}
    36a8:	03040200 	movweq	r0, #16896	@ 0x4200
    36ac:	4d052e06 	stcmi	14, cr2, [r5, #-24]	@ 0xffffffe8
    36b0:	03040200 	movweq	r0, #16896	@ 0x4200
    36b4:	02000106 	andeq	r0, r0, #-2147483647	@ 0x80000001
    36b8:	05200304 	streq	r0, [r0, #-772]!	@ 0xfffffcfc
    36bc:	04020005 	streq	r0, [r2], #-5
    36c0:	054b0603 	strbeq	r0, [fp, #-1539]	@ 0xfffff9fd
    36c4:	0402002d 	streq	r0, [r2], #-45	@ 0xffffffd3
    36c8:	32050103 	andcc	r0, r5, #-1073741824	@ 0xc0000000
    36cc:	03040200 	movweq	r0, #16896	@ 0x4200
    36d0:	02000106 	andeq	r0, r0, #-2147483647	@ 0x80000001
    36d4:	052e0304 	streq	r0, [lr, #-772]!	@ 0xfffffcfc
    36d8:	0402003e 	streq	r0, [r2], #-62	@ 0xffffffc2
    36dc:	052e0603 	streq	r0, [lr, #-1539]!	@ 0xfffff9fd
    36e0:	0402004d 	streq	r0, [r2], #-77	@ 0xffffffb3
    36e4:	00010603 	andeq	r0, r1, r3, lsl #12
    36e8:	4a030402 	bmi	c46f8 <__ROM_SIZE__+0x846f8>
    36ec:	02001605 	andeq	r1, r0, #5242880	@ 0x500000
    36f0:	03060304 	movweq	r0, #25348	@ 0x6304
    36f4:	02002079 	andeq	r2, r0, #121	@ 0x79
    36f8:	20060304 	andcs	r0, r6, r4, lsl #6
    36fc:	02001105 	andeq	r1, r0, #1073741825	@ 0x40000001
    3700:	20060104 	andcs	r0, r6, r4, lsl #2
    3704:	03060105 	movweq	r0, #24837	@ 0x6105
    3708:	062e2e09 	strteq	r2, [lr], -r9, lsl #28
    370c:	76020500 	strvc	r0, [r2], -r0, lsl #10
    3710:	0300001e 	movweq	r0, #30
    3714:	01060126 	tsteq	r6, r6, lsr #2
    3718:	4b060305 	blmi	184334 <__ROM_SIZE__+0x144334>
    371c:	0a051313 	beq	148370 <__ROM_SIZE__+0x108370>
    3720:	03050106 	movweq	r0, #20742	@ 0x5106
    3724:	00050520 	andeq	r0, r5, r0, lsr #10
    3728:	06030402 	streq	r0, [r3], -r2, lsl #8
    372c:	00070522 	andeq	r0, r7, r2, lsr #10
    3730:	06030402 	streq	r0, [r3], -r2, lsl #8
    3734:	00050501 	andeq	r0, r5, r1, lsl #10
    3738:	06030402 	streq	r0, [r3], -r2, lsl #8
    373c:	0007053d 	andeq	r0, r7, sp, lsr r5
    3740:	06030402 	streq	r0, [r3], -r2, lsl #8
    3744:	00050501 	andeq	r0, r5, r1, lsl #10
    3748:	06030402 	streq	r0, [r3], -r2, lsl #8
    374c:	0007054b 	andeq	r0, r7, fp, asr #10
    3750:	06030402 	streq	r0, [r3], -r2, lsl #8
    3754:	00050501 	andeq	r0, r5, r1, lsl #10
    3758:	06030402 	streq	r0, [r3], -r2, lsl #8
    375c:	0007052f 	andeq	r0, r7, pc, lsr #10
    3760:	06030402 	streq	r0, [r3], -r2, lsl #8
    3764:	00050501 	andeq	r0, r5, r1, lsl #10
    3768:	06030402 	streq	r0, [r3], -r2, lsl #8
    376c:	00160530 	andseq	r0, r6, r0, lsr r5
    3770:	06030402 	streq	r0, [r3], -r2, lsl #8
    3774:	002a0501 	eoreq	r0, sl, r1, lsl #10
    3778:	9e030402 	cdpls	4, 0, cr0, cr3, cr2, {0}
    377c:	02003e05 	andeq	r3, r0, #5, 28	@ 0x50
    3780:	059e0304 	ldreq	r0, [lr, #772]	@ 0x304
    3784:	04020052 	streq	r0, [r2], #-82	@ 0xffffffae
    3788:	16059e03 	strne	r9, [r5], -r3, lsl #28
    378c:	03040200 	movweq	r0, #16896	@ 0x4200
    3790:	002a0590 	mlaeq	sl, r0, r5, r0
    3794:	90030402 	andls	r0, r3, r2, lsl #8
    3798:	02002805 	andeq	r2, r0, #327680	@ 0x50000
    379c:	05740304 	ldrbeq	r0, [r4, #-772]!	@ 0xfffffcfc
    37a0:	0402003e 	streq	r0, [r2], #-62	@ 0xffffffc2
    37a4:	3c052003 	stccc	0, cr2, [r5], {3}
    37a8:	03040200 	movweq	r0, #16896	@ 0x4200
    37ac:	00520566 	subseq	r0, r2, r6, ror #10
    37b0:	20030402 	andcs	r0, r3, r2, lsl #8
    37b4:	02005005 	andeq	r5, r0, #5
    37b8:	053c0304 	ldreq	r0, [ip, #-772]!	@ 0xfffffcfc
    37bc:	04020014 	streq	r0, [r2], #-20	@ 0xffffffec
    37c0:	05052003 	streq	r2, [r5, #-3]
    37c4:	03040200 	movweq	r0, #16896	@ 0x4200
    37c8:	16054b06 	strne	r4, [r5], -r6, lsl #22
    37cc:	03040200 	movweq	r0, #16896	@ 0x4200
    37d0:	2a050106 	bcs	143bf0 <__ROM_SIZE__+0x103bf0>
    37d4:	03040200 	movweq	r0, #16896	@ 0x4200
    37d8:	0028053c 	eoreq	r0, r8, ip, lsr r5
    37dc:	82030402 	andhi	r0, r3, #33554432	@ 0x2000000
    37e0:	02003e05 	andeq	r3, r0, #5, 28	@ 0x50
    37e4:	05200304 	streq	r0, [r0, #-772]!	@ 0xfffffcfc
    37e8:	0402003c 	streq	r0, [r2], #-60	@ 0xffffffc4
    37ec:	52057403 	andpl	r7, r5, #50331648	@ 0x3000000
    37f0:	03040200 	movweq	r0, #16896	@ 0x4200
    37f4:	00500520 	subseq	r0, r0, r0, lsr #10
    37f8:	58030402 	stmdapl	r3, {r1, sl}
    37fc:	02001405 	andeq	r1, r0, #83886080	@ 0x5000000
    3800:	05200304 	streq	r0, [r0, #-772]!	@ 0xfffffcfc
    3804:	04020005 	streq	r0, [r2], #-5
    3808:	052f0603 	streq	r0, [pc, #-1539]!	@ 320d <cmd_end_+0x7c1>
    380c:	04020016 	streq	r0, [r2], #-22	@ 0xffffffea
    3810:	05010603 	streq	r0, [r1, #-1539]	@ 0xfffff9fd
    3814:	0402002a 	streq	r0, [r2], #-42	@ 0xffffffd6
    3818:	28056603 	stmdacs	r5, {r0, r1, r9, sl, sp, lr}
    381c:	03040200 	movweq	r0, #16896	@ 0x4200
    3820:	003e053c 	eorseq	r0, lr, ip, lsr r5
    3824:	20030402 	andcs	r0, r3, r2, lsl #8
    3828:	02003c05 	andeq	r3, r0, #1280	@ 0x500
    382c:	05660304 	strbeq	r0, [r6, #-772]!	@ 0xfffffcfc
    3830:	04020052 	streq	r0, [r2], #-82	@ 0xffffffae
    3834:	02002003 	andeq	r2, r0, #3
    3838:	052e0304 	streq	r0, [lr, #-772]!	@ 0xfffffcfc
    383c:	04020050 	streq	r0, [r2], #-80	@ 0xffffffb0
    3840:	14053c03 	strne	r3, [r5], #-3075	@ 0xfffff3fd
    3844:	03040200 	movweq	r0, #16896	@ 0x4200
    3848:	00050520 	andeq	r0, r5, r0, lsr #10
    384c:	06030402 	streq	r0, [r3], -r2, lsl #8
    3850:	0016052f 	andseq	r0, r6, pc, lsr #10
    3854:	06030402 	streq	r0, [r3], -r2, lsl #8
    3858:	002a0501 	eoreq	r0, sl, r1, lsl #10
    385c:	58030402 	stmdapl	r3, {r1, sl}
    3860:	02002805 	andeq	r2, r0, #327680	@ 0x50000
    3864:	05660304 	strbeq	r0, [r6, #-772]!	@ 0xfffffcfc
    3868:	0402003e 	streq	r0, [r2], #-62	@ 0xffffffc2
    386c:	3c052003 	stccc	0, cr2, [r5], {3}
    3870:	03040200 	movweq	r0, #16896	@ 0x4200
    3874:	0052053c 	subseq	r0, r2, ip, lsr r5
    3878:	20030402 	andcs	r0, r3, r2, lsl #8
    387c:	02005005 	andeq	r5, r0, #5
    3880:	05660304 	strbeq	r0, [r6, #-772]!	@ 0xfffffcfc
    3884:	04020014 	streq	r0, [r2], #-20	@ 0xffffffec
    3888:	16052003 	strne	r2, [r5], -r3
    388c:	03040200 	movweq	r0, #16896	@ 0x4200
    3890:	2e760306 	cdpcs	3, 7, cr0, cr6, cr6, {0}
    3894:	02001105 	andeq	r1, r0, #1073741825	@ 0x40000001
    3898:	05200104 	streq	r0, [r0, #-260]!	@ 0xfffffefc
    389c:	0c030601 	stceq	6, cr0, [r3], {1}
    38a0:	062e203c 			@ <UNDEFINED> instruction: 0x062e203c
    38a4:	d0020500 	andle	r0, r2, r0, lsl #10
    38a8:	1800001f 	stmdane	r0, {r0, r1, r2, r3, r4}
    38ac:	13130305 	tstne	r3, #335544320	@ 0x14000000
    38b0:	01060a05 	tsteq	r6, r5, lsl #20
    38b4:	20061105 	andcs	r1, r6, r5, lsl #2
    38b8:	30060c05 	andcc	r0, r6, r5, lsl #24
    38bc:	20061305 	andcs	r1, r6, r5, lsl #6
    38c0:	2a060105 	bcs	183cdc <__ROM_SIZE__+0x143cdc>
    38c4:	02000705 	andeq	r0, r0, #1310720	@ 0x140000
    38c8:	26060304 	strcs	r0, [r6], -r4, lsl #6
    38cc:	02001805 	andeq	r1, r0, #327680	@ 0x50000
    38d0:	01060304 	tsteq	r6, r4, lsl #6
    38d4:	02001605 	andeq	r1, r0, #5242880	@ 0x500000
    38d8:	05820304 	streq	r0, [r2, #772]	@ 0x304
    38dc:	04020018 	streq	r0, [r2], #-24	@ 0xffffffe8
    38e0:	002c0603 	eoreq	r0, ip, r3, lsl #12
    38e4:	06030402 	streq	r0, [r3], -r2, lsl #8
    38e8:	00130520 	andseq	r0, r3, r0, lsr #10
    38ec:	06010402 	streq	r0, [r1], -r2, lsl #8
    38f0:	00160520 	andseq	r0, r6, r0, lsr #10
    38f4:	2c020402 	cfstrscs	mvf0, [r2], {2}
    38f8:	02040200 	andeq	r0, r4, #0, 4
    38fc:	11052006 	tstne	r5, r6
    3900:	02040200 	andeq	r0, r4, #0, 4
    3904:	0c052006 	stceq	0, cr2, [r5], {6}
    3908:	05203006 	streq	r3, [r0, #-6]!
    390c:	16052501 	strne	r2, [r5], -r1, lsl #10
    3910:	2e790306 	cdpcs	3, 7, cr0, cr9, cr6, {0}
    3914:	20202006 	eorcs	r2, r0, r6
    3918:	03060105 	movweq	r0, #24837	@ 0x6105
    391c:	03054a0a 	movweq	r4, #23050	@ 0x5a0a
    3920:	08051513 	stmdaeq	r5, {r0, r1, r4, r8, sl, ip}
    3924:	03050106 	movweq	r0, #20742	@ 0x5106
    3928:	1f052106 	svcne	0x00052106
    392c:	12050106 	andne	r0, r5, #-2147483647	@ 0x80000001
    3930:	06030520 	streq	r0, [r3], -r0, lsr #10
    3934:	061f0521 	ldreq	r0, [pc], -r1, lsr #10
    3938:	20120501 	andscs	r0, r2, r1, lsl #10
    393c:	21060305 	tstcs	r6, r5, lsl #6
    3940:	01061f05 	tsteq	r6, r5, lsl #30
    3944:	05201205 	streq	r1, [r0, #-517]!	@ 0xfffffdfb
    3948:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
    394c:	05010612 	streq	r0, [r1, #-1554]	@ 0xfffff9ee
    3950:	05230603 	streq	r0, [r3, #-1539]!	@ 0xfffff9fd
    3954:	05010608 	streq	r0, [r1, #-1544]	@ 0xfffff9f8
    3958:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
    395c:	0501061f 	streq	r0, [r1, #-1567]	@ 0xfffff9e1
    3960:	03052012 	movweq	r2, #20498	@ 0x5012
    3964:	12052106 	andne	r2, r5, #-2147483647	@ 0x80000001
    3968:	03050106 	movweq	r0, #20742	@ 0x5106
    396c:	08052206 	stmdaeq	r5, {r1, r2, r9, sp}
    3970:	03050106 	movweq	r0, #20742	@ 0x5106
    3974:	1f052106 	svcne	0x00052106
    3978:	12050106 	andne	r0, r5, #-2147483647	@ 0x80000001
    397c:	06030520 	streq	r0, [r3], -r0, lsr #10
    3980:	06120521 	ldreq	r0, [r2], -r1, lsr #10
    3984:	06030501 	streq	r0, [r3], -r1, lsl #10
    3988:	06080523 	streq	r0, [r8], -r3, lsr #10
    398c:	06030501 	streq	r0, [r3], -r1, lsl #10
    3990:	061f0521 	ldreq	r0, [pc], -r1, lsr #10
    3994:	20120501 	andscs	r0, r2, r1, lsl #10
    3998:	21060305 	tstcs	r6, r5, lsl #6
    399c:	01061f05 	tsteq	r6, r5, lsl #30
    39a0:	05201205 	streq	r1, [r0, #-517]!	@ 0xfffffdfb
    39a4:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
    39a8:	0501061f 	streq	r0, [r1, #-1567]	@ 0xfffff9e1
    39ac:	03052012 	movweq	r2, #20498	@ 0x5012
    39b0:	12052106 	andne	r2, r5, #-2147483647	@ 0x80000001
    39b4:	01050106 	tsteq	r5, r6, lsl #2
    39b8:	06250621 	strteq	r0, [r5], -r1, lsr #12
    39bc:	06030501 	streq	r0, [r3], -r1, lsl #10
    39c0:	2e06153d 	mcrcs	5, 0, r1, cr6, cr13, {1}
    39c4:	05340620 	ldreq	r0, [r4, #-1568]!	@ 0xfffff9e0
    39c8:	0501060e 	streq	r0, [r1, #-1550]	@ 0xfffff9f2
    39cc:	3d350605 	ldccc	6, cr0, [r5, #-20]!	@ 0xffffffec
    39d0:	78031505 	stmdavc	r3, {r0, r2, r8, sl, ip}
    39d4:	05200658 	streq	r0, [r0, #-1624]!	@ 0xfffff9a8
    39d8:	05200603 	streq	r0, [r0, #-1539]!	@ 0xfffff9fd
    39dc:	3d3d1405 	cfldrscc	mvf1, [sp, #-20]!	@ 0xffffffec
    39e0:	01060805 	tsteq	r6, r5, lsl #16
    39e4:	35060305 	strcc	r0, [r6, #-773]	@ 0xfffffcfb
    39e8:	59060105 	stmdbpl	r6, {r0, r2, r8}
    39ec:	05000620 	streq	r0, [r0, #-1568]	@ 0xfffff9e0
    39f0:	00208e02 	eoreq	r8, r0, r2, lsl #28
    39f4:	01061600 	tsteq	r6, r0, lsl #12
    39f8:	3d060305 	stccc	3, cr0, [r6, #-20]	@ 0xffffffec
    39fc:	202e0615 	eorcs	r0, lr, r5, lsl r6
    3a00:	0e053406 	cdpeq	4, 0, cr3, cr5, cr6, {0}
    3a04:	05050106 	streq	r0, [r5, #-262]	@ 0xfffffefa
    3a08:	1c053606 	stcne	6, cr3, [r5], {6}
    3a0c:	063c7803 	ldrteq	r7, [ip], -r3, lsl #16
    3a10:	06030520 	streq	r0, [r3], -r0, lsr #10
    3a14:	14050520 	strne	r0, [r5], #-1312	@ 0xfffffae0
    3a18:	05593d3d 	ldrbeq	r3, [r9, #-3389]	@ 0xfffff2c3
    3a1c:	05010608 	streq	r0, [r1, #-1544]	@ 0xfffff9f8
    3a20:	06203401 	strteq	r3, [r0], -r1, lsl #8
    3a24:	c8020500 	stmdagt	r2, {r8, sl}
    3a28:	03000020 	movweq	r0, #32
    3a2c:	03050120 	movweq	r0, #20768	@ 0x5120
    3a30:	0a051313 	beq	148684 <__ROM_SIZE__+0x108684>
    3a34:	03050106 	movweq	r0, #20742	@ 0x5106
    3a38:	00050520 	andeq	r0, r5, r0, lsr #10
    3a3c:	06030402 	streq	r0, [r3], -r2, lsl #8
    3a40:	00080522 	andeq	r0, r8, r2, lsr #10
    3a44:	06030402 	streq	r0, [r3], -r2, lsl #8
    3a48:	00110501 	andseq	r0, r1, r1, lsl #10
    3a4c:	20030402 	andcs	r0, r3, r2, lsl #8
    3a50:	02000c05 	andeq	r0, r0, #1280	@ 0x500
    3a54:	052e0304 	streq	r0, [lr, #-772]!	@ 0xfffffcfc
    3a58:	04020021 	streq	r0, [r2], #-33	@ 0xffffffdf
    3a5c:	003a0603 	eorseq	r0, sl, r3, lsl #12
    3a60:	06030402 	streq	r0, [r3], -r2, lsl #8
    3a64:	00110520 	andseq	r0, r1, r0, lsr #10
    3a68:	06010402 	streq	r0, [r1], -r2, lsl #8
    3a6c:	06010520 	streq	r0, [r1], -r0, lsr #10
    3a70:	e9030632 	stmdb	r3, {r1, r4, r5, r9, sl}
    3a74:	0106207d 	tsteq	r6, sp, ror r0
    3a78:	21060305 	tstcs	r6, r5, lsl #6
    3a7c:	2f060105 	svccs	0x00060105
    3a80:	01062306 	tsteq	r6, r6, lsl #6
    3a84:	3d060305 	stccc	3, cr0, [r6, #-20]	@ 0xffffffec
    3a88:	0601052f 	streq	r0, [r1], -pc, lsr #10
    3a8c:	00062067 	andeq	r2, r6, r7, rrx
    3a90:	21020205 	tstcs	r2, r5, lsl #4
    3a94:	06140000 	ldreq	r0, [r4], -r0
    3a98:	06030501 	streq	r0, [r3], -r1, lsl #10
    3a9c:	052e0621 	streq	r0, [lr, #-1569]!	@ 0xfffff9df
    3aa0:	03062f01 	movweq	r2, #28417	@ 0x6f01
    3aa4:	062001ef 	strteq	r0, [r0], -pc, ror #3
    3aa8:	06030501 	streq	r0, [r3], -r1, lsl #10
    3aac:	20200630 	eorcs	r0, r0, r0, lsr r6
    3ab0:	062f0105 	strteq	r0, [pc], -r5, lsl #2
    3ab4:	05010623 	streq	r0, [r1, #-1571]	@ 0xfffff9dd
    3ab8:	06300603 	ldrteq	r0, [r0], -r3, lsl #12
    3abc:	01052020 	tsteq	r5, r0, lsr #32
    3ac0:	1603062f 	strne	r0, [r3], -pc, lsr #12
    3ac4:	05010620 	streq	r0, [r1, #-1568]	@ 0xfffff9e0
    3ac8:	13590603 	cmpne	r9, #3145728	@ 0x300000
    3acc:	01060c05 	tsteq	r6, r5, lsl #24
    3ad0:	2f060305 	svccs	0x00060305
    3ad4:	11060c05 	tstne	r6, r5, lsl #24
    3ad8:	05210a05 	streq	r0, [r1, #-2565]!	@ 0xfffff5fb
    3adc:	05052003 	streq	r2, [r5, #-3]
    3ae0:	03040200 	movweq	r0, #16896	@ 0x4200
    3ae4:	02002206 	andeq	r2, r0, #1610612736	@ 0x60000000
    3ae8:	003d0304 	eorseq	r0, sp, r4, lsl #6
    3aec:	4b030402 	blmi	c4afc <__ROM_SIZE__+0x84afc>
    3af0:	03040200 	movweq	r0, #16896	@ 0x4200
    3af4:	001d0513 	andseq	r0, sp, r3, lsl r5
    3af8:	0d030402 	cfstrseq	mvf0, [r3, #-8]
    3afc:	02000805 	andeq	r0, r0, #327680	@ 0x50000
    3b00:	24060304 	strcs	r0, [r6], #-772	@ 0xfffffcfc
    3b04:	02000905 	andeq	r0, r0, #81920	@ 0x14000
    3b08:	05210304 	streq	r0, [r1, #-772]!	@ 0xfffffcfc
    3b0c:	04020011 	streq	r0, [r2], #-17	@ 0xffffffef
    3b10:	051b0601 	ldreq	r0, [fp, #-1537]	@ 0xfffff9ff
    3b14:	01053603 	tsteq	r5, r3, lsl #12
    3b18:	062e4b06 	strteq	r4, [lr], -r6, lsl #22
    3b1c:	62020500 	andvs	r0, r2, #0, 10
    3b20:	15000021 	strne	r0, [r0, #-33]	@ 0xffffffdf
    3b24:	03050106 	movweq	r0, #20742	@ 0x5106
    3b28:	13136706 	tstne	r3, #1572864	@ 0x180000
    3b2c:	01060a05 	tsteq	r6, r5, lsl #20
    3b30:	05200305 	streq	r0, [r0, #-773]!	@ 0xfffffcfb
    3b34:	04020005 	streq	r0, [r2], #-5
    3b38:	00220603 	eoreq	r0, r2, r3, lsl #12
    3b3c:	59030402 	stmdbpl	r3, {r1, sl}
    3b40:	03040200 	movweq	r0, #16896	@ 0x4200
    3b44:	0017054b 	andseq	r0, r7, fp, asr #10
    3b48:	06030402 	streq	r0, [r3], -r2, lsl #8
    3b4c:	00050501 	andeq	r0, r5, r1, lsl #10
    3b50:	2e030402 	cdpcs	4, 0, cr0, cr3, cr2, {0}
    3b54:	03040200 	movweq	r0, #16896	@ 0x4200
    3b58:	02004b06 	andeq	r4, r0, #6144	@ 0x1800
    3b5c:	05590304 	ldrbeq	r0, [r9, #-772]	@ 0xfffffcfc
    3b60:	04020009 	streq	r0, [r2], #-9
    3b64:	05010603 	streq	r0, [r1, #-1539]	@ 0xfffff9fd
    3b68:	0402001d 	streq	r0, [r2], #-29	@ 0xffffffe3
    3b6c:	7a030603 	bvc	c5380 <__ROM_SIZE__+0x85380>
    3b70:	00110520 	andseq	r0, r1, r0, lsr #10
    3b74:	20010402 	andcs	r0, r1, r2, lsl #8
    3b78:	03060105 	movweq	r0, #24837	@ 0x6105
    3b7c:	063c2e09 	ldrteq	r2, [ip], -r9, lsl #28
    3b80:	a8020500 	stmdage	r2, {r8, sl}
    3b84:	03000021 	movweq	r0, #33	@ 0x21
    3b88:	0106010a 	tsteq	r6, sl, lsl #2
    3b8c:	59060305 	stmdbpl	r6, {r0, r2, r8, r9}
    3b90:	05131314 	ldreq	r1, [r3, #-788]	@ 0xfffffcec
    3b94:	05010612 	streq	r0, [r1, #-1554]	@ 0xfffff9ee
    3b98:	0305200a 	movweq	r2, #20490	@ 0x500a
    3b9c:	000b0520 	andeq	r0, fp, r0, lsr #10
    3ba0:	06010402 	streq	r0, [r1], -r2, lsl #8
    3ba4:	05200e03 	streq	r0, [r0, #-3587]!	@ 0xfffff1fd
    3ba8:	04020017 	streq	r0, [r2], #-23	@ 0xffffffe9
    3bac:	05010601 	streq	r0, [r1, #-1537]	@ 0xfffff9ff
    3bb0:	0402000b 	streq	r0, [r2], #-11
    3bb4:	054b0601 	strbeq	r0, [fp, #-1537]	@ 0xfffff9ff
    3bb8:	0402002e 	streq	r0, [r2], #-46	@ 0xffffffd2
    3bbc:	017a0301 	cmneq	sl, r1, lsl #6
    3bc0:	01040200 	mrseq	r0, R12_usr
    3bc4:	0a052006 	beq	14bbe4 <__ROM_SIZE__+0x10bbe4>
    3bc8:	05200b03 	streq	r0, [r0, #-2819]!	@ 0xfffff4fd
    3bcc:	04020005 	streq	r0, [r2], #-5
    3bd0:	05230602 	streq	r0, [r3, #-1538]!	@ 0xfffff9fe
    3bd4:	04020012 	streq	r0, [r2], #-18	@ 0xffffffee
    3bd8:	05010602 	streq	r0, [r1, #-1538]	@ 0xfffff9fe
    3bdc:	0402001e 	streq	r0, [r2], #-30	@ 0xffffffe2
    3be0:	0c052e02 	stceq	14, cr2, [r5], {2}
    3be4:	02040200 	andeq	r0, r4, #0, 4
    3be8:	00310558 	eorseq	r0, r1, r8, asr r5
    3bec:	06020402 	streq	r0, [r2], -r2, lsl #8
    3bf0:	054a6903 	strbeq	r6, [sl, #-2307]	@ 0xfffff6fd
    3bf4:	0402002e 	streq	r0, [r2], #-46	@ 0xffffffd2
    3bf8:	05010602 	streq	r0, [r1, #-1538]	@ 0xfffff9fe
    3bfc:	04020033 	streq	r0, [r2], #-51	@ 0xffffffcd
    3c00:	24052002 	strcs	r2, [r5], #-2
    3c04:	01040200 	mrseq	r0, R12_usr
    3c08:	05052006 	streq	r2, [r5, #-6]
    3c0c:	06080530 			@ <UNDEFINED> instruction: 0x06080530
    3c10:	06070501 	streq	r0, [r7], -r1, lsl #10
    3c14:	054d6731 	strbeq	r6, [sp, #-1841]	@ 0xfffff8cf
    3c18:	0501060f 	streq	r0, [r1, #-1551]	@ 0xfffff9f1
    3c1c:	04020028 	streq	r0, [r2], #-40	@ 0xffffffd8
    3c20:	05200601 	streq	r0, [r0, #-1537]!	@ 0xfffff9ff
    3c24:	14053109 	strne	r3, [r5], #-265	@ 0xfffffef7
    3c28:	0c050106 	stfeqs	f0, [r5], {6}
    3c2c:	0609053c 			@ <UNDEFINED> instruction: 0x0609053c
    3c30:	06150533 			@ <UNDEFINED> instruction: 0x06150533
    3c34:	09052001 	stmdbeq	r5, {r0, sp}
    3c38:	0a053d06 	beq	153058 <__ROM_SIZE__+0x113058>
    3c3c:	09051406 	stmdbeq	r5, {r1, r2, sl, ip}
    3c40:	2701051e 	smladcs	r1, lr, r5, r0
    3c44:	0101002e 	tsteq	r1, lr, lsr #32
    3c48:	000006a2 	andeq	r0, r0, r2, lsr #13
    3c4c:	00990003 	addseq	r0, r9, r3
    3c50:	01020000 	mrseq	r0, (UNDEF: 2)
    3c54:	000d0efb 	strdeq	r0, [sp], -fp
    3c58:	01010101 	tsteq	r1, r1, lsl #2
    3c5c:	01000000 	mrseq	r0, (UNDEF: 0)
    3c60:	2f010000 	svccs	0x00010000
    3c64:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
    3c68:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
    3c6c:	63652f66 	cmnvs	r5, #408	@ 0x198
    3c70:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
    3c74:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
    3c78:	662f7265 	strtvs	r7, [pc], -r5, ror #4
    3c7c:	732f626f 			@ <UNDEFINED> instruction: 0x732f626f
    3c80:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
    3c84:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
    3c88:	6e69742f 	cdpvs	4, 6, cr7, cr9, cr15, {1}
    3c8c:	63652d79 	cmnvs	r5, #7744	@ 0x1e40
    3c90:	2f006864 	svccs	0x00006864
    3c94:	2f74706f 	svccs	0x0074706f
    3c98:	2d636367 	stclcs	3, cr6, [r3, #-412]!	@ 0xfffffe64
    3c9c:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	@ 0xfffffe7c
    3ca0:	656e6f6e 	strbvs	r6, [lr, #-3950]!	@ 0xfffff092
    3ca4:	6261652d 	rsbvs	r6, r1, #188743680	@ 0xb400000
    3ca8:	696c2f69 	stmdbvs	ip!, {r0, r3, r5, r6, r8, r9, sl, fp, sp}^
    3cac:	63672f62 	cmnvs	r7, #392	@ 0x188
    3cb0:	72612f63 	rsbvc	r2, r1, #396	@ 0x18c
    3cb4:	6f6e2d6d 	svcvs	0x006e2d6d
    3cb8:	652d656e 	strvs	r6, [sp, #-1390]!	@ 0xfffffa92
    3cbc:	2f696261 	svccs	0x00696261
    3cc0:	322e3231 	eorcc	r3, lr, #268435459	@ 0x10000003
    3cc4:	692f312e 	stmdbvs	pc!, {r1, r2, r3, r5, r8, ip, sp}	@ <UNPREDICTABLE>
    3cc8:	756c636e 	strbvc	r6, [ip, #-878]!	@ 0xfffffc92
    3ccc:	00006564 	andeq	r6, r0, r4, ror #10
    3cd0:	68646365 	stmdavs	r4!, {r0, r2, r5, r6, r8, r9, sp, lr}^
    3cd4:	0100632e 	tsteq	r0, lr, lsr #6
    3cd8:	74730000 	ldrbtvc	r0, [r3], #-0
    3cdc:	746e6964 	strbtvc	r6, [lr], #-2404	@ 0xfffff69c
    3ce0:	6363672d 	cmnvs	r3, #11796480	@ 0xb40000
    3ce4:	0200682e 	andeq	r6, r0, #3014656	@ 0x2e0000
    3ce8:	05000000 	streq	r0, [r0, #-0]
    3cec:	02050001 	andeq	r0, r5, #1
    3cf0:	0000221c 	andeq	r2, r0, ip, lsl r2
    3cf4:	0101c603 	tsteq	r1, r3, lsl #12
    3cf8:	05130305 	ldreq	r0, [r3, #-773]	@ 0xfffffcfb
    3cfc:	05010612 	streq	r0, [r1, #-1554]	@ 0xfffff9ee
    3d00:	2105200d 	tstcs	r5, sp
    3d04:	2e19052e 	cfmul64cs	mvdx0, mvdx9, mvdx14
    3d08:	06210105 	strteq	r0, [r1], -r5, lsl #2
    3d0c:	1303053f 	movwne	r0, #13631	@ 0x353f
    3d10:	01060905 	tsteq	r6, r5, lsl #18
    3d14:	052e0405 	streq	r0, [lr, #-1029]!	@ 0xfffffbfb
    3d18:	18052e20 	stmdane	r5, {r5, r9, sl, fp, sp}
    3d1c:	2e10052e 	cfmul64cs	mvdx0, mvdx0, mvdx14
    3d20:	064b0105 	strbeq	r0, [fp], -r5, lsl #2
    3d24:	13030523 	movwne	r0, #13603	@ 0x3523
    3d28:	060a0513 			@ <UNDEFINED> instruction: 0x060a0513
    3d2c:	20030501 	andcs	r0, r3, r1, lsl #10
    3d30:	02000505 	andeq	r0, r0, #20971520	@ 0x1400000
    3d34:	22060304 	andcs	r0, r6, #4, 6	@ 0x10000000
    3d38:	02000d05 	andeq	r0, r0, #320	@ 0x140
    3d3c:	01060304 	tsteq	r6, r4, lsl #6
    3d40:	02000a05 	andeq	r0, r0, #20480	@ 0x5000
    3d44:	052e0304 	streq	r0, [lr, #-772]!	@ 0xfffffcfc
    3d48:	04020022 	streq	r0, [r2], #-34	@ 0xffffffde
    3d4c:	052c0603 	streq	r0, [ip, #-1539]!	@ 0xfffff9fd
    3d50:	04020011 	streq	r0, [r2], #-17	@ 0xffffffef
    3d54:	01052001 	tsteq	r5, r1
    3d58:	23063206 	movwcs	r3, #25094	@ 0x6206
    3d5c:	03050106 	movweq	r0, #20742	@ 0x5106
    3d60:	06134b06 	ldreq	r4, [r3], -r6, lsl #22
    3d64:	2f062020 	svccs	0x00062020
    3d68:	0601054b 	streq	r0, [r1], -fp, asr #10
    3d6c:	00062e4b 	andeq	r2, r6, fp, asr #28
    3d70:	22800205 	addcs	r0, r0, #1342177280	@ 0x50000000
    3d74:	05170000 	ldreq	r0, [r7, #-0]
    3d78:	05131303 	ldreq	r1, [r3, #-771]	@ 0xfffffcfd
    3d7c:	0501060a 	streq	r0, [r1, #-1546]	@ 0xfffff9f6
    3d80:	04020011 	streq	r0, [r2], #-17	@ 0xffffffef
    3d84:	05200601 	streq	r0, [r0, #-1537]!	@ 0xfffff9ff
    3d88:	12053005 	andne	r3, r5, #5
    3d8c:	08050106 	stmdaeq	r5, {r1, r2, r8}
    3d90:	0022052e 	eoreq	r0, r2, lr, lsr #10
    3d94:	06020402 	streq	r0, [r2], -r2, lsl #8
    3d98:	04020048 	streq	r0, [r2], #-72	@ 0xffffffb8
    3d9c:	05200602 	streq	r0, [r0, #-1538]!	@ 0xfffff9fe
    3da0:	0520270a 	streq	r2, [r0, #-1802]!	@ 0xfffff8f6
    3da4:	01051d0e 	tsteq	r5, lr, lsl #26
    3da8:	10030624 	andne	r0, r3, r4, lsr #12
    3dac:	13030520 	movwne	r0, #13600	@ 0x3520
    3db0:	060a0513 			@ <UNDEFINED> instruction: 0x060a0513
    3db4:	20030501 	andcs	r0, r3, r1, lsl #10
    3db8:	02000505 	andeq	r0, r0, #20971520	@ 0x1400000
    3dbc:	22060304 	andcs	r0, r6, #4, 6	@ 0x10000000
    3dc0:	02000a05 	andeq	r0, r0, #20480	@ 0x5000
    3dc4:	01060304 	tsteq	r6, r4, lsl #6
    3dc8:	02002205 	andeq	r2, r0, #1342177280	@ 0x50000000
    3dcc:	3a060304 	bcc	1849e4 <__ROM_SIZE__+0x1449e4>
    3dd0:	02001105 	andeq	r1, r0, #1073741825	@ 0x40000001
    3dd4:	05200104 	streq	r0, [r0, #-260]!	@ 0xfffffefc
    3dd8:	06320601 	ldrteq	r0, [r2], -r1, lsl #12
    3ddc:	13030525 	movwne	r0, #13605	@ 0x3525
    3de0:	060c0513 			@ <UNDEFINED> instruction: 0x060c0513
    3de4:	05210611 	streq	r0, [r1, #-1553]!	@ 0xfffff9ef
    3de8:	0a053005 	beq	14fe04 <__ROM_SIZE__+0x10fe04>
    3dec:	08050106 	stmdaeq	r5, {r1, r2, r8}
    3df0:	0605052e 	streq	r0, [r5], -lr, lsr #10
    3df4:	06070524 	streq	r0, [r7], -r4, lsr #10
    3df8:	03052001 	movweq	r2, #20481	@ 0x5001
    3dfc:	01052206 	tsteq	r5, r6, lsl #4
    3e00:	063c1306 	ldrteq	r1, [ip], -r6, lsl #6
    3e04:	ca020500 	bgt	8520c <__ROM_SIZE__+0x4520c>
    3e08:	03000022 	movweq	r0, #34	@ 0x22
    3e0c:	03050111 	movweq	r0, #20753	@ 0x5111
    3e10:	05051513 	streq	r1, [r5, #-1299]	@ 0xfffffaed
    3e14:	03050106 	movweq	r0, #20742	@ 0x5106
    3e18:	07053106 	streq	r3, [r5, -r6, lsl #2]
    3e1c:	017a0306 	cmneq	sl, r6, lsl #6
    3e20:	27060b05 	strcs	r0, [r6, -r5, lsl #22]
    3e24:	02000f05 	andeq	r0, r0, #5, 30
    3e28:	2e060104 	adfcss	f0, f6, f4
    3e2c:	02000b05 	andeq	r0, r0, #5120	@ 0x1400
    3e30:	052e0104 	streq	r0, [lr, #-260]!	@ 0xfffffefc
    3e34:	05220605 	streq	r0, [r2, #-1541]!	@ 0xfffff9fb
    3e38:	20010607 	andcs	r0, r1, r7, lsl #12
    3e3c:	23060305 	movwcs	r0, #25349	@ 0x6305
    3e40:	01060605 	tsteq	r6, r5, lsl #12
    3e44:	06070520 	streq	r0, [r7], -r0, lsr #10
    3e48:	060f0525 	streq	r0, [pc], -r5, lsr #10
    3e4c:	06070501 	streq	r0, [r7], -r1, lsl #10
    3e50:	06090521 	streq	r0, [r9], -r1, lsr #10
    3e54:	061d0501 	ldreq	r0, [sp], -r1, lsl #10
    3e58:	060e051d 			@ <UNDEFINED> instruction: 0x060e051d
    3e5c:	201d0501 	andscs	r0, sp, r1, lsl #10
    3e60:	1901052e 	stmdbne	r1, {r1, r2, r3, r5, r8, sl}
    3e64:	78030e05 	stmdavc	r3, {r0, r2, r9, sl, fp}
    3e68:	06010520 	streq	r0, [r1], -r0, lsr #10
    3e6c:	063c0c03 	ldrteq	r0, [ip], -r3, lsl #24
    3e70:	06030501 	streq	r0, [r3], -r1, lsl #10
    3e74:	06070521 	streq	r0, [r7], -r1, lsr #10
    3e78:	03053c01 	movweq	r3, #23553	@ 0x5c01
    3e7c:	05133106 	ldreq	r3, [r3, #-262]	@ 0xfffffefa
    3e80:	0501060a 	streq	r0, [r1, #-1546]	@ 0xfffff9f6
    3e84:	07052003 	streq	r2, [r5, -r3]
    3e88:	0005051c 	andeq	r0, r5, ip, lsl r5
    3e8c:	06030402 	streq	r0, [r3], -r2, lsl #8
    3e90:	000a0543 	andeq	r0, sl, r3, asr #10
    3e94:	06030402 	streq	r0, [r3], -r2, lsl #8
    3e98:	001b0501 	andseq	r0, fp, r1, lsl #10
    3e9c:	06030402 	streq	r0, [r3], -r2, lsl #8
    3ea0:	00110539 	andseq	r0, r1, r9, lsr r5
    3ea4:	20010402 	andcs	r0, r1, r2, lsl #8
    3ea8:	33060505 	movwcc	r0, #25861	@ 0x6505
    3eac:	0524062e 	streq	r0, [r4, #-1582]!	@ 0xfffff9d2
    3eb0:	0501060a 	streq	r0, [r1, #-1546]	@ 0xfffff9f6
    3eb4:	054b0605 	strbeq	r0, [fp, #-1541]	@ 0xfffff9fb
    3eb8:	05010607 	streq	r0, [r1, #-1543]	@ 0xfffff9f9
    3ebc:	05210605 	streq	r0, [r1, #-1541]!	@ 0xfffff9fb
    3ec0:	05010607 	streq	r0, [r1, #-1543]	@ 0xfffff9f9
    3ec4:	052a060c 	streq	r0, [sl, #-1548]!	@ 0xfffff9f4
    3ec8:	05133603 	ldreq	r3, [r3, #-1539]	@ 0xfffff9fd
    3ecc:	2e010606 	cfmadd32cs	mvax0, mvfx0, mvfx1, mvfx6
    3ed0:	0a030105 	beq	c42ec <__ROM_SIZE__+0x842ec>
    3ed4:	00070520 	andeq	r0, r7, r0, lsr #10
    3ed8:	06030402 	streq	r0, [r3], -r2, lsl #8
    3edc:	0011052a 	andseq	r0, r1, sl, lsr #10
    3ee0:	06030402 	streq	r0, [r3], -r2, lsl #8
    3ee4:	00150501 	andseq	r0, r5, r1, lsl #10
    3ee8:	2e030402 	cdpcs	4, 0, cr0, cr3, cr2, {0}
    3eec:	02002305 	andeq	r2, r0, #335544320	@ 0x14000000
    3ef0:	05200304 	streq	r0, [r0, #-772]!	@ 0xfffffcfc
    3ef4:	04020032 	streq	r0, [r2], #-50	@ 0xffffffce
    3ef8:	2b055803 	blcs	159f0c <__ROM_SIZE__+0x119f0c>
    3efc:	03040200 	movweq	r0, #16896	@ 0x4200
    3f00:	001f052e 	andseq	r0, pc, lr, lsr #10
    3f04:	2e030402 	cdpcs	4, 0, cr0, cr3, cr2, {0}
    3f08:	02000d05 	andeq	r0, r0, #320	@ 0x140
    3f0c:	05200304 	streq	r0, [r0, #-772]!	@ 0xfffffcfc
    3f10:	0402002a 	streq	r0, [r2], #-42	@ 0xffffffd6
    3f14:	052c0603 	streq	r0, [ip, #-1539]!	@ 0xfffff9fd
    3f18:	04020025 	streq	r0, [r2], #-37	@ 0xffffffdb
    3f1c:	05052001 	streq	r2, [r5, #-1]
    3f20:	06060532 			@ <UNDEFINED> instruction: 0x06060532
    3f24:	200a0501 	andcs	r0, sl, r1, lsl #10
    3f28:	05300105 	ldreq	r0, [r0, #-261]!	@ 0xfffffefb
    3f2c:	207a030c 	rsbscs	r0, sl, ip, lsl #6
    3f30:	06010520 	streq	r0, [r1], -r0, lsr #10
    3f34:	68020500 	stmdavs	r2, {r8, sl}
    3f38:	03000023 	movweq	r0, #35	@ 0x23
    3f3c:	03050111 	movweq	r0, #20753	@ 0x5111
    3f40:	06080514 			@ <UNDEFINED> instruction: 0x06080514
    3f44:	06030501 	streq	r0, [r3], -r1, lsl #10
    3f48:	01061330 	tsteq	r6, r0, lsr r3
    3f4c:	02000505 	andeq	r0, r0, #20971520	@ 0x1400000
    3f50:	22060304 	andcs	r0, r6, #4, 6	@ 0x10000000
    3f54:	02000a05 	andeq	r0, r0, #20480	@ 0x5000
    3f58:	01060304 	tsteq	r6, r4, lsl #6
    3f5c:	02002205 	andeq	r2, r0, #1342177280	@ 0x50000000
    3f60:	3a060304 	bcc	184b78 <__ROM_SIZE__+0x144b78>
    3f64:	02001105 	andeq	r1, r0, #1073741825	@ 0x40000001
    3f68:	05200104 	streq	r0, [r0, #-260]!	@ 0xfffffefc
    3f6c:	06320601 	ldrteq	r0, [r2], -r1, lsl #12
    3f70:	14030525 	strne	r0, [r3], #-1317	@ 0xfffffadb
    3f74:	01060805 	tsteq	r6, r5, lsl #16
    3f78:	05200605 	streq	r0, [r0, #-1541]!	@ 0xfffff9fb
    3f7c:	04020011 	streq	r0, [r2], #-17	@ 0xffffffef
    3f80:	05340601 	ldreq	r0, [r4, #-1537]!	@ 0xfffff9ff
    3f84:	0a053005 	beq	14ffa0 <__ROM_SIZE__+0x10ffa0>
    3f88:	08050106 	stmdaeq	r5, {r1, r2, r8}
    3f8c:	0022052e 	eoreq	r0, r2, lr, lsr #10
    3f90:	06020402 	streq	r0, [r2], -r2, lsl #8
    3f94:	0402001e 	streq	r0, [r2], #-30	@ 0xffffffe2
    3f98:	05200602 	streq	r0, [r0, #-1538]!	@ 0xfffff9fe
    3f9c:	05270603 	streq	r0, [r7, #-1539]!	@ 0xfffff9fd
    3fa0:	3c01060d 	stccc	6, cr0, [r1], {13}
    3fa4:	75030c05 	strvc	r0, [r3, #-3077]	@ 0xfffff3fb
    3fa8:	0301052e 	movweq	r0, #5422	@ 0x152e
    3fac:	0306200c 	movweq	r2, #24588	@ 0x600c
    3fb0:	03052018 	movweq	r2, #20504	@ 0x5018
    3fb4:	0a051313 	beq	148c08 <__ROM_SIZE__+0x108c08>
    3fb8:	11050106 	tstne	r5, r6, lsl #2
    3fbc:	01052006 	tsteq	r5, r6
    3fc0:	05052c06 	streq	r2, [r5, #-3078]	@ 0xfffff3fa
    3fc4:	03040200 	movweq	r0, #16896	@ 0x4200
    3fc8:	15052406 	strne	r2, [r5, #-1030]	@ 0xfffffbfa
    3fcc:	03040200 	movweq	r0, #16896	@ 0x4200
    3fd0:	12050106 	andne	r0, r5, #-2147483647	@ 0x80000001
    3fd4:	03040200 	movweq	r0, #16896	@ 0x4200
    3fd8:	000a052e 	andeq	r0, sl, lr, lsr #10
    3fdc:	3c030402 	cfstrscc	mvf0, [r3], {2}
    3fe0:	02002205 	andeq	r2, r0, #1342177280	@ 0x50000000
    3fe4:	2c060304 	stccs	3, cr0, [r6], {4}
    3fe8:	02001105 	andeq	r1, r0, #1073741825	@ 0x40000001
    3fec:	05200304 	streq	r0, [r0, #-772]!	@ 0xfffffcfc
    3ff0:	2e320601 	cfmsuba32cs	mvax0, mvax0, mvfx2, mvfx1
    3ff4:	03052406 	movweq	r2, #21510	@ 0x5406
    3ff8:	06040513 			@ <UNDEFINED> instruction: 0x06040513
    3ffc:	20080501 	andcs	r0, r8, r1, lsl #10
    4000:	063d0105 	ldrteq	r0, [sp], -r5, lsl #2
    4004:	05010625 	streq	r0, [r1, #-1573]	@ 0xfffff9db
    4008:	13590603 	cmpne	r9, #3145728	@ 0x300000
    400c:	06200618 			@ <UNDEFINED> instruction: 0x06200618
    4010:	06070531 			@ <UNDEFINED> instruction: 0x06070531
    4014:	4a060501 	bmi	185420 <__ROM_SIZE__+0x145420>
    4018:	22060505 	andcs	r0, r6, #20971520	@ 0x1400000
    401c:	02000105 	andeq	r0, r0, #1073741825	@ 0x40000001
    4020:	03060104 	movweq	r0, #24836	@ 0x6104
    4024:	02004a73 	andeq	r4, r0, #471040	@ 0x73000
    4028:	05200104 	streq	r0, [r0, #-260]!	@ 0xfffffefc
    402c:	11030605 	tstne	r3, r5, lsl #12
    4030:	03070520 	movweq	r0, #29984	@ 0x7520
    4034:	21054a0c 	tstcs	r5, ip, lsl #20
    4038:	02040200 	andeq	r0, r4, #0, 4
    403c:	05667803 	strbeq	r7, [r6, #-2051]!	@ 0xfffff7fd
    4040:	04020011 	streq	r0, [r2], #-17	@ 0xffffffef
    4044:	05052001 	streq	r2, [r5, #-1]
    4048:	09055b31 	stmdbeq	r5, {r0, r4, r5, r8, r9, fp, ip, lr}
    404c:	08050106 	stmdaeq	r5, {r1, r2, r8}
    4050:	0605054a 	streq	r0, [r5], -sl, asr #10
    4054:	052e0c03 	streq	r0, [lr, #-3075]!	@ 0xfffff3fd
    4058:	05010609 	streq	r0, [r1, #-1545]	@ 0xfffff9f7
    405c:	07054a08 	streq	r4, [r5, -r8, lsl #20]
    4060:	01053006 	tsteq	r5, r6
    4064:	66090306 	strvs	r0, [r9], -r6, lsl #6
    4068:	0500062e 	streq	r0, [r0, #-1582]	@ 0xfffff9d2
    406c:	00244002 	eoreq	r4, r4, r2
    4070:	01061600 	tsteq	r6, r0, lsl #12
    4074:	3d060305 	stccc	3, cr0, [r6, #-20]	@ 0xffffffec
    4078:	20061413 	andcs	r1, r6, r3, lsl r4
    407c:	3d4b2f06 	stclcc	15, cr2, [fp, #-24]	@ 0xffffffe8
    4080:	0609053e 			@ <UNDEFINED> instruction: 0x0609053e
    4084:	06050501 	streq	r0, [r5], -r1, lsl #10
    4088:	59201103 	stmdbpl	r0!, {r0, r1, r8, ip}
    408c:	0a055959 	beq	15a5f8 <__ROM_SIZE__+0x11a5f8>
    4090:	05586c03 	ldrbeq	r6, [r8, #-3075]	@ 0xfffff3fd
    4094:	0501060b 	streq	r0, [r1, #-1547]	@ 0xfffff9f5
    4098:	05053c0a 	streq	r3, [r5, #-3082]	@ 0xfffff3f6
    409c:	0a052206 	beq	14c8bc <__ROM_SIZE__+0x10c8bc>
    40a0:	1d050106 	stfnes	f0, [r5, #-24]	@ 0xffffffe8
    40a4:	0605054a 	streq	r0, [r5], -sl, asr #10
    40a8:	0608054c 	streq	r0, [r8], -ip, asr #10
    40ac:	07052001 	streq	r2, [r5, -r1]
    40b0:	4b4b2206 	blmi	12cc8d0 <__ROM_SIZE__+0x128c8d0>
    40b4:	01060905 	tsteq	r6, r5, lsl #18
    40b8:	03010520 	movweq	r0, #5408	@ 0x1520
    40bc:	062e200e 	strteq	r2, [lr], -lr
    40c0:	c4020500 	strgt	r0, [r2], #-1280	@ 0xfffffb00
    40c4:	03000024 	movweq	r0, #36	@ 0x24
    40c8:	0106010f 	tsteq	r6, pc, lsl #2
    40cc:	3d060305 	stccc	3, cr0, [r6, #-20]	@ 0xffffffec
    40d0:	2f062006 	svccs	0x00062006
    40d4:	4b060105 	blmi	1844f0 <__ROM_SIZE__+0x1444f0>
    40d8:	05000620 	streq	r0, [r0, #-1568]	@ 0xfffff9e0
    40dc:	0024da02 	eoreq	sp, r4, r2, lsl #20
    40e0:	01061500 	tsteq	r6, r0, lsl #10
    40e4:	2f060305 	svccs	0x00060305
    40e8:	0601052f 	streq	r0, [r1], -pc, lsr #10
    40ec:	0006203d 	andeq	r2, r6, sp, lsr r0
    40f0:	24ea0205 	strbtcs	r0, [sl], #517	@ 0x205
    40f4:	06150000 	ldreq	r0, [r5], -r0
    40f8:	06030501 	streq	r0, [r3], -r1, lsl #10
    40fc:	060f052f 	streq	r0, [pc], -pc, lsr #10
    4100:	2f0c0501 	svccs	0x000c0501
    4104:	02000f05 	andeq	r0, r0, #5, 30
    4108:	05200104 	streq	r0, [r0, #-260]!	@ 0xfffffefc
    410c:	0402000c 	streq	r0, [r2], #-12
    4110:	05203c01 	streq	r3, [r0, #-3073]!	@ 0xfffff3ff
    4114:	06202101 	strteq	r2, [r0], -r1, lsl #2
    4118:	00020500 	andeq	r0, r2, r0, lsl #10
    411c:	16000025 	strne	r0, [r0], -r5, lsr #32
    4120:	03050106 	movweq	r0, #20742	@ 0x5106
    4124:	07054c06 	streq	r4, [r5, -r6, lsl #24]
    4128:	06050106 	streq	r0, [r5], -r6, lsl #2
    412c:	0605052e 	streq	r0, [r5], -lr, lsr #10
    4130:	06010522 	streq	r0, [r1], -r2, lsr #10
    4134:	053c1203 	ldreq	r1, [ip, #-515]!	@ 0xfffffdfd
    4138:	72030605 	andvc	r0, r3, #5242880	@ 0x500000
    413c:	594b142e 	stmdbpl	fp, {r1, r2, r3, r5, sl, ip}^
    4140:	3e5a5959 			@ <UNDEFINED> instruction: 0x3e5a5959
    4144:	01055959 	tsteq	r5, r9, asr r9
    4148:	00065a06 	andeq	r5, r6, r6, lsl #20
    414c:	256e0205 	strbcs	r0, [lr, #-517]!	@ 0xfffffdfb
    4150:	06170000 	ldreq	r0, [r7], -r0
    4154:	06030501 	streq	r0, [r3], -r1, lsl #10
    4158:	06080567 	streq	r0, [r8], -r7, ror #10
    415c:	05202001 	streq	r2, [r0, #-1]!
    4160:	05052e06 	streq	r2, [r5, #-3590]	@ 0xfffff1fa
    4164:	09052206 	stmdbeq	r5, {r1, r2, r9, sp}
    4168:	08050106 	stmdaeq	r5, {r1, r2, r8}
    416c:	0607054a 	streq	r0, [r7], -sl, asr #10
    4170:	060b0526 	streq	r0, [fp], -r6, lsr #10
    4174:	4a0a0501 	bmi	285580 <__ROM_SIZE__+0x245580>
    4178:	22060905 	andcs	r0, r6, #81920	@ 0x14000
    417c:	01060d05 	tsteq	r6, r5, lsl #26
    4180:	054a0c05 	strbeq	r0, [sl, #-3077]	@ 0xfffff3fb
    4184:	0522060b 	streq	r0, [r2, #-1547]!	@ 0xfffff9f5
    4188:	58780307 	ldmdapl	r8!, {r0, r1, r2, r8, r9}^
    418c:	03060105 	movweq	r0, #24837	@ 0x6105
    4190:	0b056626 	bleq	15da30 <__ROM_SIZE__+0x11da30>
    4194:	2e660306 	cdpcs	3, 6, cr0, cr6, cr6, {0}
    4198:	145e0905 	ldrbne	r0, [lr], #-2309	@ 0xfffff6fb
    419c:	594b5959 	stmdbpl	fp, {r0, r3, r4, r6, r8, fp, ip, lr}^
    41a0:	3e5a5959 			@ <UNDEFINED> instruction: 0x3e5a5959
    41a4:	59595959 	ldmdbpl	r9, {r0, r3, r4, r6, r8, fp, ip, lr}^
    41a8:	4e060105 	adfmis	f0, f6, f5
    41ac:	02050006 	andeq	r0, r5, #6
    41b0:	00002642 	andeq	r2, r0, r2, asr #12
    41b4:	05010619 	streq	r0, [r1, #-1561]	@ 0xfffff9e7
    41b8:	13590603 	cmpne	r9, #3145728	@ 0x300000
    41bc:	060f0513 			@ <UNDEFINED> instruction: 0x060f0513
    41c0:	052e2001 	streq	r2, [lr, #-1]!
    41c4:	06220603 	strteq	r0, [r2], -r3, lsl #12
    41c8:	0530062e 	ldreq	r0, [r0, #-1582]!	@ 0xfffff9d2
    41cc:	0501060a 	streq	r0, [r1, #-1546]	@ 0xfffff9f6
    41d0:	21052003 	tstcs	r5, r3
    41d4:	02040200 	andeq	r0, r4, #0, 4
    41d8:	1b052006 	blne	14c1f8 <__ROM_SIZE__+0x10c1f8>
    41dc:	01040200 	mrseq	r0, R12_usr
    41e0:	30050520 	andcc	r0, r5, r0, lsr #10
    41e4:	0609054b 	streq	r0, [r9], -fp, asr #10
    41e8:	4a080501 	bmi	2055f4 <__ROM_SIZE__+0x1c55f4>
    41ec:	30060705 	andcc	r0, r6, r5, lsl #14
    41f0:	05770305 	ldrbeq	r0, [r7, #-773]!	@ 0xfffffcfb
    41f4:	2e670601 	cdpcs	6, 6, cr0, cr7, cr1, {0}
    41f8:	02050006 	andeq	r0, r5, #6
    41fc:	00002698 	muleq	r0, r8, r6
    4200:	06012403 	streq	r2, [r1], -r3, lsl #8
    4204:	06030501 	streq	r0, [r3], -r1, lsl #10
    4208:	0705144b 	streq	r1, [r5, -fp, asr #8]
    420c:	06050106 	streq	r0, [r5], -r6, lsl #2
    4210:	220c052e 	andcs	r0, ip, #192937984	@ 0xb800000
    4214:	12030105 	andne	r0, r3, #1073741825	@ 0x40000001
    4218:	06050520 	streq	r0, [r5], -r0, lsr #10
    421c:	5c2e7203 	sfmpl	f7, 4, [lr], #-12
    4220:	59595a59 	ldmdbpl	r9, {r0, r3, r4, r6, r9, fp, ip, lr}^
    4224:	0c055a59 			@ <UNDEFINED> instruction: 0x0c055a59
    4228:	01050106 	tsteq	r5, r6, lsl #2
    422c:	740f0306 	strvc	r0, [pc], #-774	@ 4234 <base_order+0x9b4>
    4230:	03050106 	movweq	r0, #20742	@ 0x5106
    4234:	3f053e06 	svccc	0x00053e06
    4238:	03050106 	movweq	r0, #20742	@ 0x5106
    423c:	3106582e 	tstcc	r6, lr, lsr #16
    4240:	01060705 	tsteq	r6, r5, lsl #14
    4244:	053c0605 	ldreq	r0, [ip, #-1541]!	@ 0xfffff9fb
    4248:	05350605 	ldreq	r0, [r5, #-1541]!	@ 0xfffff9fb
    424c:	05010611 	streq	r0, [r1, #-1553]	@ 0xfffff9ef
    4250:	143d0605 	ldrtne	r0, [sp], #-1541	@ 0xfffff9fb
    4254:	01060c05 	tsteq	r6, r5, lsl #24
    4258:	05200505 	streq	r0, [r0, #-1285]!	@ 0xfffffafb
    425c:	04020007 	streq	r0, [r2], #-7
    4260:	05220603 	streq	r0, [r2, #-1539]!	@ 0xfffff9fd
    4264:	04020035 	streq	r0, [r2], #-53	@ 0xffffffcb
    4268:	1d054803 	stcne	8, cr4, [r5, #-12]
    426c:	01040200 	mrseq	r0, R12_usr
    4270:	34050520 	strcc	r0, [r5], #-1312	@ 0xfffffae0
    4274:	060c055a 			@ <UNDEFINED> instruction: 0x060c055a
    4278:	01052001 	tsteq	r5, r1
    427c:	030c0514 	movweq	r0, #50452	@ 0xc514
    4280:	0105206e 	tsteq	r5, lr, rrx
    4284:	02050006 	andeq	r0, r5, #6
    4288:	00002754 	andeq	r2, r0, r4, asr r7
    428c:	06011703 	streq	r1, [r1], -r3, lsl #14
    4290:	06030501 	streq	r0, [r3], -r1, lsl #10
    4294:	064c054c 	strbeq	r0, [ip], -ip, asr #10
    4298:	2e0c0501 	cfsh32cs	mvfx0, mvfx12, #1
    429c:	06052020 	streq	r2, [r5], -r0, lsr #32
    42a0:	0605052e 	streq	r0, [r5], -lr, lsr #10
    42a4:	05201b03 	streq	r1, [r0, #-2819]!	@ 0xfffff4fd
    42a8:	0501060c 	streq	r0, [r1, #-1548]	@ 0xfffff9f4
    42ac:	0c052201 	sfmeq	f2, 4, [r5], {1}
    42b0:	05206403 	streq	r6, [r0, #-1027]!	@ 0xfffffbfd
    42b4:	0c054a08 			@ <UNDEFINED> instruction: 0x0c054a08
    42b8:	00070532 	andeq	r0, r7, r2, lsr r5
    42bc:	06030402 	streq	r0, [r3], -r2, lsl #8
    42c0:	001d0530 	andseq	r0, sp, r0, lsr r5
    42c4:	06030402 	streq	r0, [r3], -r2, lsl #8
    42c8:	00110501 	andseq	r0, r1, r1, lsl #10
    42cc:	2e030402 	cdpcs	4, 0, cr0, cr3, cr2, {0}
    42d0:	02002a05 	andeq	r2, r0, #20480	@ 0x5000
    42d4:	2c060304 	stccs	3, cr0, [r6], {4}
    42d8:	02001305 	andeq	r1, r0, #335544320	@ 0x14000000
    42dc:	05200104 	streq	r0, [r0, #-260]!	@ 0xfffffefc
    42e0:	0c033405 	cfstrseq	mvf3, [r3], {5}
    42e4:	060c0566 	streq	r0, [ip], -r6, ror #10
    42e8:	00020201 	andeq	r0, r2, r1, lsl #4
    42ec:	01890101 	orreq	r0, r9, r1, lsl #2
    42f0:	00030000 	andeq	r0, r3, r0
    42f4:	00000092 	muleq	r0, r2, r0
    42f8:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
    42fc:	0101000d 	tsteq	r1, sp
    4300:	00000101 	andeq	r0, r0, r1, lsl #2
    4304:	00000100 	andeq	r0, r0, r0, lsl #2
    4308:	6f682f01 	svcvs	0x00682f01
    430c:	652f656d 	strvs	r6, [pc, #-1389]!	@ 3da7 <base_order+0x527>
    4310:	2f667463 	svccs	0x00667463
    4314:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    4318:	6172742d 	cmnvs	r2, sp, lsr #8
    431c:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
    4320:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
    4324:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
    4328:	6c2f6c6c 	stcvs	12, cr6, [pc], #-432	@ 4180 <base_order+0x900>
    432c:	612f6269 			@ <UNDEFINED> instruction: 0x612f6269
    4330:	2f006932 	svccs	0x00006932
    4334:	2f74706f 	svccs	0x0074706f
    4338:	2d636367 	stclcs	3, cr6, [r3, #-412]!	@ 0xfffffe64
    433c:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	@ 0xfffffe7c
    4340:	656e6f6e 	strbvs	r6, [lr, #-3950]!	@ 0xfffff092
    4344:	6261652d 	rsbvs	r6, r1, #188743680	@ 0xb400000
    4348:	696c2f69 	stmdbvs	ip!, {r0, r3, r5, r6, r8, r9, sl, fp, sp}^
    434c:	63672f62 	cmnvs	r7, #392	@ 0x188
    4350:	72612f63 	rsbvc	r2, r1, #396	@ 0x18c
    4354:	6f6e2d6d 	svcvs	0x006e2d6d
    4358:	652d656e 	strvs	r6, [sp, #-1390]!	@ 0xfffffa92
    435c:	2f696261 	svccs	0x00696261
    4360:	322e3231 	eorcc	r3, lr, #268435459	@ 0x10000003
    4364:	692f312e 	stmdbvs	pc!, {r1, r2, r3, r5, r8, ip, sp}	@ <UNPREDICTABLE>
    4368:	756c636e 	strbvc	r6, [ip, #-878]!	@ 0xfffffc92
    436c:	00006564 	andeq	r6, r0, r4, ror #10
    4370:	2e693261 	cdpcs	2, 6, cr3, cr9, cr1, {3}
    4374:	00010063 	andeq	r0, r1, r3, rrx
    4378:	64747300 	ldrbtvs	r7, [r4], #-768	@ 0xfffffd00
    437c:	2d746e69 	ldclcs	14, cr6, [r4, #-420]!	@ 0xfffffe5c
    4380:	2e636367 	cdpcs	3, 6, cr6, cr3, cr7, {3}
    4384:	00020068 	andeq	r0, r2, r8, rrx
    4388:	1b050000 	blne	144390 <__ROM_SIZE__+0x104390>
    438c:	9c020500 	cfstr32ls	mvfx0, [r2], {-0}
    4390:	03000027 	movweq	r0, #39	@ 0x27
    4394:	01060112 	tsteq	r6, r2, lsl r1
    4398:	21060305 	tstcs	r6, r5, lsl #6
    439c:	01080513 	tsteq	r8, r3, lsl r5
    43a0:	01060c05 	tsteq	r6, r5, lsl #24
    43a4:	051f0705 	ldreq	r0, [pc, #-1797]	@ 3ca7 <base_order+0x427>
    43a8:	05052103 	streq	r2, [r5, #-259]	@ 0xfffffefd
    43ac:	03040200 	movweq	r0, #16896	@ 0x4200
    43b0:	0f052106 	svceq	0x00052106
    43b4:	03040200 	movweq	r0, #16896	@ 0x4200
    43b8:	14050106 	strne	r0, [r5], #-262	@ 0xfffffefa
    43bc:	03040200 	movweq	r0, #16896	@ 0x4200
    43c0:	0009052e 	andeq	r0, r9, lr, lsr #10
    43c4:	2e030402 	cdpcs	4, 0, cr0, cr3, cr2, {0}
    43c8:	02002305 	andeq	r2, r0, #335544320	@ 0x14000000
    43cc:	2d060304 	stccs	3, cr0, [r6, #-16]
    43d0:	02001a05 	andeq	r1, r0, #20480	@ 0x5000
    43d4:	05200104 	streq	r0, [r0, #-260]!	@ 0xfffffefc
    43d8:	04020016 	streq	r0, [r2], #-22	@ 0xffffffea
    43dc:	05010601 	streq	r0, [r1, #-1537]	@ 0xfffff9ff
    43e0:	0402001a 	streq	r0, [r2], #-26	@ 0xffffffe6
    43e4:	03052001 	movweq	r2, #20481	@ 0x5001
    43e8:	01053106 	tsteq	r5, r6, lsl #2
    43ec:	20051306 	andcs	r1, r5, r6, lsl #6
    43f0:	01062206 	tsteq	r6, r6, lsl #4
    43f4:	21060305 	tstcs	r6, r5, lsl #6
    43f8:	08051413 	stmdaeq	r5, {r0, r1, r4, sl, ip}
    43fc:	06110501 	ldreq	r0, [r1], -r1, lsl #10
    4400:	1d0c0501 	cfstr32ne	mvfx0, [ip, #-4]
    4404:	05230305 	streq	r0, [r3, #-773]!	@ 0xfffffcfb
    4408:	0523060c 	streq	r0, [r3, #-1548]!	@ 0xfffff9f4
    440c:	0501061e 	streq	r0, [r1, #-1566]	@ 0xfffff9e2
    4410:	07053c0f 	streq	r3, [r5, -pc, lsl #24]
    4414:	1c052f06 	stcne	15, cr2, [r5], {6}
    4418:	05050106 	streq	r0, [r5, #-262]	@ 0xfffffefa
    441c:	05132806 	ldreq	r2, [r3, #-2054]	@ 0xfffff7fa
    4420:	05010609 	streq	r0, [r1, #-1545]	@ 0xfffff9f7
    4424:	04020029 	streq	r0, [r2], #-41	@ 0xffffffd7
    4428:	73030602 	movwvc	r0, #13826	@ 0x3602
    442c:	001f052e 	andseq	r0, pc, lr, lsr #10
    4430:	20010402 	andcs	r0, r1, r2, lsl #8
    4434:	02001b05 	andeq	r1, r0, #5120	@ 0x1400
    4438:	01060104 	tsteq	r6, r4, lsl #2
    443c:	02001f05 	andeq	r1, r0, #5, 30
    4440:	052e0104 	streq	r0, [lr, #-260]!	@ 0xfffffefc
    4444:	05210605 	streq	r0, [r1, #-1541]!	@ 0xfffff9fb
    4448:	05010617 	streq	r0, [r1, #-1559]	@ 0xfffff9e9
    444c:	07053c08 	streq	r3, [r5, -r8, lsl #24]
    4450:	16052f06 	strne	r2, [r5], -r6, lsl #30
    4454:	05200106 	streq	r0, [r0, #-262]!	@ 0xfffffefa
    4458:	0523060c 	streq	r0, [r3, #-1548]!	@ 0xfffff9f4
    445c:	0501061e 	streq	r0, [r1, #-1566]	@ 0xfffff9e2
    4460:	07053c0f 	streq	r3, [r5, -pc, lsl #24]
    4464:	1c052f06 	stcne	15, cr2, [r5], {6}
    4468:	20200106 	eorcs	r0, r0, r6, lsl #2
    446c:	03060305 	movweq	r0, #25349	@ 0x6305
    4470:	0105010a 	tsteq	r5, sl, lsl #2
    4474:	01021306 	tsteq	r2, r6, lsl #6
    4478:	13010100 	movwne	r0, #4352	@ 0x1100
    447c:	03000002 	movweq	r0, #2
    4480:	0000e900 	andeq	lr, r0, r0, lsl #18
    4484:	fb010200 	blx	44c8e <__ROM_SIZE__+0x4c8e>
    4488:	01000d0e 	tsteq	r0, lr, lsl #26
    448c:	00010101 	andeq	r0, r1, r1, lsl #2
    4490:	00010000 	andeq	r0, r1, r0
    4494:	682f0100 	stmdavs	pc!, {r8}	@ <UNPREDICTABLE>
    4498:	2f656d6f 	svccs	0x00656d6f
    449c:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    44a0:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
    44a4:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
    44a8:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
    44ac:	6f662f72 	svcvs	0x00662f72
    44b0:	68732f62 	ldmdavs	r3!, {r1, r5, r6, r8, r9, sl, fp, sp}^
    44b4:	2f6c6c65 	svccs	0x006c6c65
    44b8:	2f62696c 	svccs	0x0062696c
    44bc:	6c6d656d 	cfstr64vs	mvdx6, [sp], #-436	@ 0xfffffe4c
    44c0:	2f00676f 	svccs	0x0000676f
    44c4:	2f74706f 	svccs	0x0074706f
    44c8:	2d636367 	stclcs	3, cr6, [r3, #-412]!	@ 0xfffffe64
    44cc:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	@ 0xfffffe7c
    44d0:	656e6f6e 	strbvs	r6, [lr, #-3950]!	@ 0xfffff092
    44d4:	6261652d 	rsbvs	r6, r1, #188743680	@ 0xb400000
    44d8:	696c2f69 	stmdbvs	ip!, {r0, r3, r5, r6, r8, r9, sl, fp, sp}^
    44dc:	63672f62 	cmnvs	r7, #392	@ 0x188
    44e0:	72612f63 	rsbvc	r2, r1, #396	@ 0x18c
    44e4:	6f6e2d6d 	svcvs	0x006e2d6d
    44e8:	652d656e 	strvs	r6, [sp, #-1390]!	@ 0xfffffa92
    44ec:	2f696261 	svccs	0x00696261
    44f0:	322e3231 	eorcc	r3, lr, #268435459	@ 0x10000003
    44f4:	692f312e 	stmdbvs	pc!, {r1, r2, r3, r5, r8, ip, sp}	@ <UNPREDICTABLE>
    44f8:	756c636e 	strbvc	r6, [ip, #-878]!	@ 0xfffffc92
    44fc:	2f006564 	svccs	0x00006564
    4500:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
    4504:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
    4508:	63652f66 	cmnvs	r5, #408	@ 0x198
    450c:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
    4510:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
    4514:	662f7265 	strtvs	r7, [pc], -r5, ror #4
    4518:	732f626f 			@ <UNDEFINED> instruction: 0x732f626f
    451c:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
    4520:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
    4524:	7274732f 	rsbsvc	r7, r4, #-1140850688	@ 0xbc000000
    4528:	00676e69 	rsbeq	r6, r7, r9, ror #28
    452c:	6d656d00 	stclvs	13, cr6, [r5, #-0]
    4530:	2e676f6c 	cdpcs	15, 6, cr6, cr7, cr12, {3}
    4534:	00010063 	andeq	r0, r1, r3, rrx
    4538:	64747300 	ldrbtvs	r7, [r4], #-768	@ 0xfffffd00
    453c:	2d746e69 	ldclcs	14, cr6, [r4, #-420]!	@ 0xfffffe5c
    4540:	2e636367 	cdpcs	3, 6, cr6, cr3, cr7, {3}
    4544:	00020068 	andeq	r0, r2, r8, rrx
    4548:	6d656d00 	stclvs	13, cr6, [r5, #-0]
    454c:	2e676f6c 	cdpcs	15, 6, cr6, cr7, cr12, {3}
    4550:	00010068 	andeq	r0, r1, r8, rrx
    4554:	64747300 	ldrbtvs	r7, [r4], #-768	@ 0xfffffd00
    4558:	2e666564 	cdpcs	5, 6, cr6, cr6, cr4, {3}
    455c:	00020068 	andeq	r0, r2, r8, rrx
    4560:	72747300 	rsbsvc	r7, r4, #0, 6
    4564:	2e676e69 	cdpcs	14, 6, cr6, cr7, cr9, {3}
    4568:	00030068 	andeq	r0, r3, r8, rrx
    456c:	3d050000 	stccc	0, cr0, [r5, #-0]
    4570:	f8020500 			@ <UNDEFINED> instruction: 0xf8020500
    4574:	03000027 	movweq	r0, #39	@ 0x27
    4578:	03050116 	movweq	r0, #20758	@ 0x5116
    457c:	06110513 			@ <UNDEFINED> instruction: 0x06110513
    4580:	06030501 	streq	r0, [r3], -r1, lsl #10
    4584:	06060530 			@ <UNDEFINED> instruction: 0x06060530
    4588:	1d3d0501 	cfldr32ne	mvfx0, [sp, #-4]!
    458c:	27060305 	strcs	r0, [r6, -r5, lsl #6]
    4590:	01061405 	tsteq	r6, r5, lsl #8
    4594:	21060305 	tstcs	r6, r5, lsl #6
    4598:	01061b05 	tsteq	r6, r5, lsl #22
    459c:	05201405 	streq	r1, [r0, #-1029]!	@ 0xfffffbfb
    45a0:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
    45a4:	0501061a 	streq	r0, [r1, #-1562]	@ 0xfffff9e6
    45a8:	05300603 	ldreq	r0, [r0, #-1539]!	@ 0xfffff9fd
    45ac:	0501061b 	streq	r0, [r1, #-1563]	@ 0xfffff9e5
    45b0:	03052014 	movweq	r2, #20500	@ 0x5014
    45b4:	14052106 	strne	r2, [r5], #-262	@ 0xfffffefa
    45b8:	03050106 	movweq	r0, #20742	@ 0x5106
    45bc:	1a052106 	bne	14c9dc <__ROM_SIZE__+0x10c9dc>
    45c0:	03050106 	movweq	r0, #20742	@ 0x5106
    45c4:	06052206 	streq	r2, [r5], -r6, lsl #4
    45c8:	05050106 	streq	r0, [r5, #-262]	@ 0xfffffefa
    45cc:	16053f06 	strne	r3, [r5], -r6, lsl #30
    45d0:	03050106 	movweq	r0, #20742	@ 0x5106
    45d4:	20062806 	andcs	r2, r6, r6, lsl #16
    45d8:	2f010520 	svccs	0x00010520
    45dc:	03060a05 	movweq	r0, #27141	@ 0x6a05
    45e0:	0d052078 	stceq	0, cr2, [r5, #-480]	@ 0xfffffe20
    45e4:	05050106 	streq	r0, [r5, #-262]	@ 0xfffffefa
    45e8:	16053f06 	strne	r3, [r5], -r6, lsl #30
    45ec:	05050106 	streq	r0, [r5, #-262]	@ 0xfffffefa
    45f0:	16052f06 	strne	r2, [r5], -r6, lsl #30
    45f4:	052e0106 	streq	r0, [lr, #-262]!	@ 0xfffffefa
    45f8:	05420613 	strbeq	r0, [r2, #-1555]	@ 0xfffff9ed
    45fc:	17051303 	strne	r1, [r5, -r3, lsl #6]
    4600:	06050106 	streq	r0, [r5], -r6, lsl #2
    4604:	0603052e 	streq	r0, [r3], -lr, lsr #10
    4608:	06120540 	ldreq	r0, [r2], -r0, asr #10
    460c:	2e230501 	cfsh64cs	mvdx0, mvdx3, #1
    4610:	05201705 	streq	r1, [r0, #-1797]!	@ 0xfffff8fb
    4614:	03052006 	movweq	r2, #20486	@ 0x5006
    4618:	1d052406 	cfstrsne	mvf2, [r5, #-24]	@ 0xffffffe8
    461c:	03050106 	movweq	r0, #20742	@ 0x5106
    4620:	2c052f06 	stccs	15, cr2, [r5], {6}
    4624:	03050106 	movweq	r0, #20742	@ 0x5106
    4628:	19052f06 	stmdbne	r5, {r1, r2, r8, r9, sl, fp, sp}
    462c:	03050106 	movweq	r0, #20742	@ 0x5106
    4630:	2c053e06 	stccs	14, cr3, [r5], {6}
    4634:	06050106 	streq	r0, [r5], -r6, lsl #2
    4638:	33010520 	movwcc	r0, #5408	@ 0x1520
    463c:	1c060505 	cfstr32ne	mvfx0, [r6], {5}
    4640:	01061c05 	tsteq	r6, r5, lsl #24
    4644:	74030c05 	strvc	r0, [r3], #-3077	@ 0xfffff3fb
    4648:	1a05403c 	bne	154740 <__ROM_SIZE__+0x114740>
    464c:	580e0306 	stmdapl	lr, {r1, r2, r8, r9}
    4650:	05130305 	ldreq	r0, [r3, #-773]	@ 0xfffffcfb
    4654:	05010617 	streq	r0, [r1, #-1559]	@ 0xfffff9e9
    4658:	1e052e06 	cdpne	14, 0, cr2, cr5, cr6, {0}
    465c:	01040200 	mrseq	r0, R12_usr
    4660:	0603053c 			@ <UNDEFINED> instruction: 0x0603053c
    4664:	060e0524 	streq	r0, [lr], -r4, lsr #10
    4668:	2e1f0501 	cfmul32cs	mvfx0, mvfx15, mvfx1
    466c:	05202c05 	streq	r2, [r0, #-3077]!	@ 0xfffff3fb
    4670:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
    4674:	05010619 	streq	r0, [r1, #-1561]	@ 0xfffff9e7
    4678:	05300603 	ldreq	r0, [r0, #-1539]!	@ 0xfffff9fd
    467c:	0501062c 	streq	r0, [r1, #-1580]	@ 0xfffff9d4
    4680:	01052006 	tsteq	r5, r6
    4684:	06050531 			@ <UNDEFINED> instruction: 0x06050531
    4688:	061c051e 			@ <UNDEFINED> instruction: 0x061c051e
    468c:	00060201 	andeq	r0, r6, r1, lsl #4
    4690:	01b30101 			@ <UNDEFINED> instruction: 0x01b30101
    4694:	00030000 	andeq	r0, r3, r0
    4698:	00000094 	muleq	r0, r4, r0
    469c:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
    46a0:	0101000d 	tsteq	r1, sp
    46a4:	00000101 	andeq	r0, r0, r1, lsl #2
    46a8:	00000100 	andeq	r0, r0, r0, lsl #2
    46ac:	6f682f01 	svcvs	0x00682f01
    46b0:	652f656d 	strvs	r6, [pc, #-1389]!	@ 414b <base_order+0x8cb>
    46b4:	2f667463 	svccs	0x00667463
    46b8:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    46bc:	6172742d 	cmnvs	r2, sp, lsr #8
    46c0:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
    46c4:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
    46c8:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
    46cc:	6c2f6c6c 	stcvs	12, cr6, [pc], #-432	@ 4524 <base_order+0xca4>
    46d0:	732f6269 			@ <UNDEFINED> instruction: 0x732f6269
    46d4:	6e697274 	mcrvs	2, 3, r7, cr9, cr4, {3}
    46d8:	6f2f0067 	svcvs	0x002f0067
    46dc:	672f7470 			@ <UNDEFINED> instruction: 0x672f7470
    46e0:	612d6363 			@ <UNDEFINED> instruction: 0x612d6363
    46e4:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
    46e8:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	@ 0xfffffe44
    46ec:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
    46f0:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
    46f4:	6363672f 	cmnvs	r3, #12320768	@ 0xbc0000
    46f8:	6d72612f 	ldfvse	f6, [r2, #-188]!	@ 0xffffff44
    46fc:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
    4700:	61652d65 	cmnvs	r5, r5, ror #26
    4704:	312f6962 			@ <UNDEFINED> instruction: 0x312f6962
    4708:	2e322e32 	mrccs	14, 1, r2, cr2, cr2, {1}
    470c:	6e692f31 	mcrvs	15, 3, r2, cr9, cr1, {1}
    4710:	64756c63 	ldrbtvs	r6, [r5], #-3171	@ 0xfffff39d
    4714:	73000065 	movwvc	r0, #101	@ 0x65
    4718:	6e697274 	mcrvs	2, 3, r7, cr9, cr4, {3}
    471c:	00632e67 	rsbeq	r2, r3, r7, ror #28
    4720:	73000001 	movwvc	r0, #1
    4724:	65646474 	strbvs	r6, [r4, #-1140]!	@ 0xfffffb8c
    4728:	00682e66 	rsbeq	r2, r8, r6, ror #28
    472c:	00000002 	andeq	r0, r0, r2
    4730:	05002005 	streq	r2, [r0, #-5]
    4734:	0028a402 	eoreq	sl, r8, r2, lsl #8
    4738:	01120300 	tsteq	r2, r0, lsl #6
    473c:	03050106 	movweq	r0, #20742	@ 0x5106
    4740:	05132106 	ldreq	r2, [r3, #-262]	@ 0xfffffefa
    4744:	0511060a 	ldreq	r0, [r1, #-1546]	@ 0xfffff9f6
    4748:	05052109 	streq	r2, [r5, #-265]	@ 0xfffffef7
    474c:	08052106 	stmdaeq	r5, {r1, r2, r8, sp}
    4750:	0a050106 	beq	144b70 <__ROM_SIZE__+0x104b70>
    4754:	0d051f06 	stceq	15, cr1, [r5, #-24]	@ 0xffffffe8
    4758:	0a050106 	beq	144b78 <__ROM_SIZE__+0x104b78>
    475c:	06030520 	streq	r0, [r3], -r0, lsr #10
    4760:	06010531 			@ <UNDEFINED> instruction: 0x06010531
    4764:	06300513 			@ <UNDEFINED> instruction: 0x06300513
    4768:	13030522 	movwne	r0, #13602	@ 0x3522
    476c:	01060905 	tsteq	r6, r5, lsl #18
    4770:	21060505 	tstcs	r6, r5, lsl #10
    4774:	01060905 	tsteq	r6, r5, lsl #18
    4778:	21060505 	tstcs	r6, r5, lsl #10
    477c:	01060905 	tsteq	r6, r5, lsl #18
    4780:	1e061005 	cdpne	0, 0, cr1, cr6, cr5, {0}
    4784:	01060a05 	tsteq	r6, r5, lsl #20
    4788:	05201005 	streq	r1, [r0, #-5]!
    478c:	0402001d 	streq	r0, [r2], #-29	@ 0xffffffe3
    4790:	10052001 	andne	r2, r5, r1
    4794:	01040200 	mrseq	r0, R12_usr
    4798:	06030520 	streq	r0, [r3], -r0, lsr #10
    479c:	06120532 			@ <UNDEFINED> instruction: 0x06120532
    47a0:	21010501 	tstcs	r1, r1, lsl #10
    47a4:	30062c05 	andcc	r2, r6, r5, lsl #24
    47a8:	05130305 	ldreq	r0, [r3, #-773]	@ 0xfffffcfb
    47ac:	05010609 	streq	r0, [r1, #-1545]	@ 0xfffff9f7
    47b0:	05210605 	streq	r0, [r1, #-1541]!	@ 0xfffff9fb
    47b4:	05010617 	streq	r0, [r1, #-1559]	@ 0xfffff9e9
    47b8:	0a05200f 	beq	14c7fc <__ROM_SIZE__+0x10c7fc>
    47bc:	03052d06 	movweq	r2, #23814	@ 0x5d06
    47c0:	0609053f 			@ <UNDEFINED> instruction: 0x0609053f
    47c4:	06030501 	streq	r0, [r3], -r1, lsl #10
    47c8:	06010521 	streq	r0, [r1], -r1, lsr #10
    47cc:	38052013 	stmdacc	r5, {r0, r1, r4, sp}
    47d0:	03052206 	movweq	r2, #20998	@ 0x5206
    47d4:	13131313 	tstne	r3, #1275068416	@ 0x4c000000
    47d8:	01060a05 	tsteq	r6, r5, lsl #20
    47dc:	05200305 	streq	r0, [r0, #-773]!	@ 0xfffffcfb
    47e0:	04020005 	streq	r0, [r2], #-5
    47e4:	05210603 	streq	r0, [r1, #-1539]!	@ 0xfffff9fd
    47e8:	0402001c 	streq	r0, [r2], #-28	@ 0xffffffe4
    47ec:	05010603 	streq	r0, [r1, #-1539]	@ 0xfffff9fd
    47f0:	04020012 	streq	r0, [r2], #-18	@ 0xffffffee
    47f4:	1a052e03 	bne	150008 <__ROM_SIZE__+0x110008>
    47f8:	03040200 	movweq	r0, #16896	@ 0x4200
    47fc:	11052d06 	tstne	r5, r6, lsl #26
    4800:	01040200 	mrseq	r0, R12_usr
    4804:	31030520 	tstcc	r3, r0, lsr #10
    4808:	13060105 	movwne	r0, #24837	@ 0x6105
    480c:	06300520 	ldrteq	r0, [r0], -r0, lsr #10
    4810:	13030522 	movwne	r0, #13602	@ 0x3522
    4814:	0a051313 	beq	149468 <__ROM_SIZE__+0x109468>
    4818:	03050106 	movweq	r0, #20742	@ 0x5106
    481c:	00050520 	andeq	r0, r5, r0, lsr #10
    4820:	06030402 	streq	r0, [r3], -r2, lsl #8
    4824:	00120521 	andseq	r0, r2, r1, lsr #10
    4828:	06030402 	streq	r0, [r3], -r2, lsl #8
    482c:	001a0501 	andseq	r0, sl, r1, lsl #10
    4830:	06030402 	streq	r0, [r3], -r2, lsl #8
    4834:	0011051f 	andseq	r0, r1, pc, lsl r5
    4838:	20010402 	andcs	r0, r1, r2, lsl #8
    483c:	05320305 	ldreq	r0, [r2, #-773]!	@ 0xfffffcfb
    4840:	20130601 	andscs	r0, r3, r1, lsl #12
    4844:	01000102 	tsteq	r0, r2, lsl #2
    4848:	Address 0x4848 is out of bounds.


Disassembly of section .debug_str:

00000000 <.debug_str>:
       0:	6d6d6f63 	stclvs	15, cr6, [sp, #-396]!	@ 0xfffffe74
       4:	5f646e61 	svcpl	0x00646e61
       8:	706c6568 	rsbvc	r6, ip, r8, ror #10
       c:	7a697300 	bvc	1a5cc14 <__ROM_SIZE__+0x1a1cc14>
      10:	00745f65 	rsbseq	r5, r4, r5, ror #30
      14:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ ffffff60 <_STACK_TOP_+0xdfff7f64>
      18:	63652f65 	cmnvs	r5, #404	@ 0x194
      1c:	652f6674 	strvs	r6, [pc, #-1652]!	@ fffff9b0 <_STACK_TOP_+0xdfff79b4>
      20:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
      24:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
      28:	2f72656e 	svccs	0x0072656e
      2c:	2f626f66 	svccs	0x00626f66
      30:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
      34:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
      38:	44434500 	strbmi	r4, [r3], #-1280	@ 0xfffffb00
      3c:	72705f48 	rsbsvc	r5, r0, #72, 30	@ 0x120
      40:	656b7669 	strbvs	r7, [fp, #-1641]!	@ 0xfffff997
      44:	4e470079 	mcrmi	0, 2, r0, cr7, cr9, {3}
      48:	31432055 	qdaddcc	r2, r5, r3
      4c:	32312037 	eorscc	r2, r1, #55	@ 0x37
      50:	312e322e 			@ <UNDEFINED> instruction: 0x312e322e
      54:	32303220 	eorscc	r3, r0, #32, 4
      58:	31323033 	teqcc	r2, r3, lsr r0
      5c:	6d2d2034 	stcvs	0, cr2, [sp, #-208]!	@ 0xffffff30
      60:	3d757063 	ldclcc	0, cr7, [r5, #-396]!	@ 0xfffffe74
      64:	74726f63 	ldrbtvc	r6, [r2], #-3939	@ 0xfffff09d
      68:	6d2d7865 	stcvs	8, cr7, [sp, #-404]!	@ 0xfffffe6c
      6c:	6d2d2034 	stcvs	0, cr2, [sp, #-208]!	@ 0xffffff30
      70:	6d756874 	ldclvs	8, cr6, [r5, #-464]!	@ 0xfffffe30
      74:	6d2d2062 	stcvs	0, cr2, [sp, #-392]!	@ 0xfffffe78
      78:	656e7574 	strbvs	r7, [lr, #-1396]!	@ 0xfffffa8c
      7c:	726f633d 	rsbvc	r6, pc, #-201326592	@ 0xf4000000
      80:	2d786574 	cfldr64cs	mvdx6, [r8, #-464]!	@ 0xfffffe30
      84:	2d20346d 	cfstrscs	mvf3, [r0, #-436]!	@ 0xfffffe4c
      88:	6f6c666d 	svcvs	0x006c666d
      8c:	612d7461 			@ <UNDEFINED> instruction: 0x612d7461
      90:	733d6962 	teqvc	sp, #1605632	@ 0x188000
      94:	2074666f 	rsbscs	r6, r4, pc, ror #12
      98:	72616d2d 	rsbvc	r6, r1, #2880	@ 0xb40
      9c:	613d6863 	teqvs	sp, r3, ror #16
      a0:	37766d72 			@ <UNDEFINED> instruction: 0x37766d72
      a4:	206d2d65 	rsbcs	r2, sp, r5, ror #26
      a8:	6467672d 	strbtvs	r6, [r7], #-1837	@ 0xfffff8d3
      ac:	4f2d2062 	svcmi	0x002d2062
      b0:	662d2067 	strtvs	r2, [sp], -r7, rrx
      b4:	65657266 	strbvs	r7, [r5, #-614]!	@ 0xfffffd9a
      b8:	6e617473 	mcrvs	4, 3, r7, cr1, cr3, {3}
      bc:	676e6964 	strbvs	r6, [lr, -r4, ror #18]!
      c0:	74616400 	strbtvc	r6, [r1], #-1024	@ 0xfffffc00
      c4:	6e656c61 	cdpvs	12, 6, cr6, cr5, cr1, {3}
      c8:	524f5700 	subpl	r5, pc, #0, 14
      cc:	43450044 	movtmi	r0, #20548	@ 0x5044
      d0:	415f4844 	cmpmi	pc, r4, asr #16
      d4:	656b5345 	strbvs	r5, [fp, #-837]!	@ 0xfffffcbb
      d8:	6f630079 	svcvs	0x00630079
      dc:	6e616d6d 	cdpvs	13, 6, cr6, cr1, cr13, {3}
      e0:	59420064 	stmdbpl	r2, {r2, r5, r6}^
      e4:	64004554 	strvs	r4, [r0], #-1364	@ 0xfffffaac
      e8:	646f6365 	strbtvs	r6, [pc], #-869	@ f0 <vector_table+0xf0>
      ec:	61625f65 	cmnvs	r2, r5, ror #30
      f0:	34366573 	ldrtcc	r6, [r6], #-1395	@ 0xfffffa8d
      f4:	53454100 	movtpl	r4, #20736	@ 0x5100
      f8:	4243455f 	submi	r4, r3, #398458880	@ 0x17c00000
      fc:	6365645f 	cmnvs	r5, #1593835520	@ 0x5f000000
     100:	74707972 	ldrbtvc	r7, [r0], #-2418	@ 0xfffff68e
     104:	61687300 	cmnvs	r8, r0, lsl #6
     108:	5f363532 	svcpl	0x00363532
     10c:	616e6966 	cmnvs	lr, r6, ror #18
     110:	765f006c 	ldrbvc	r0, [pc], -ip, rrx
     114:	61637261 	cmnvs	r3, r1, ror #4
     118:	656d5f72 	strbvs	r5, [sp, #-3954]!	@ 0xfffff08e
     11c:	73006773 	movwvc	r6, #1907	@ 0x773
     120:	35326168 	ldrcc	r6, [r2, #-360]!	@ 0xfffffe98
     124:	6e695f36 	mcrvs	15, 3, r5, cr9, cr6, {1}
     128:	75007469 	strvc	r7, [r0, #-1129]	@ 0xfffffb97
     12c:	6769736e 	strbvs	r7, [r9, -lr, ror #6]!
     130:	2064656e 	rsbcs	r6, r4, lr, ror #10
     134:	72616863 	rsbvc	r6, r1, #6488064	@ 0x630000
     138:	6f687300 	svcvs	0x00687300
     13c:	75207472 	strvc	r7, [r0, #-1138]!	@ 0xfffffb8e
     140:	6769736e 	strbvs	r7, [r9, -lr, ror #6]!
     144:	2064656e 	rsbcs	r6, r4, lr, ror #10
     148:	00746e69 	rsbseq	r6, r4, r9, ror #28
     14c:	32616873 	rsbcc	r6, r1, #7536640	@ 0x730000
     150:	755f3635 	ldrbvc	r3, [pc, #-1589]	@ fffffb23 <_STACK_TOP_+0xdfff7b27>
     154:	74616470 	strbtvc	r6, [r1], #-1136	@ 0xfffffb90
     158:	72610065 	rsbvc	r0, r1, #101	@ 0x65
     15c:	62007667 	andvs	r7, r0, #108003328	@ 0x6700000
     160:	656c7469 	strbvs	r7, [ip, #-1129]!	@ 0xfffffb97
     164:	4853006e 	ldmdami	r3, {r1, r2, r3, r5, r6}^
     168:	36353241 	ldrtcc	r3, [r5], -r1, asr #4
     16c:	5854435f 	ldmdapl	r4, {r0, r1, r2, r3, r4, r6, r8, r9, lr}^
     170:	6e6f6c00 	cdpvs	12, 6, cr6, cr15, cr0, {0}
     174:	6f6c2067 	svcvs	0x006c2067
     178:	7520676e 	strvc	r6, [r0, #-1902]!	@ 0xfffff892
     17c:	6769736e 	strbvs	r7, [r9, -lr, ror #6]!
     180:	2064656e 	rsbcs	r6, r4, lr, ror #10
     184:	00746e69 	rsbseq	r6, r4, r9, ror #28
     188:	746e6975 	strbtvc	r6, [lr], #-2421	@ 0xfffff68b
     18c:	00745f38 	rsbseq	r5, r4, r8, lsr pc
     190:	696e6966 	stmdbvs	lr!, {r1, r2, r5, r6, r8, fp, sp, lr}^
     194:	655f6873 	ldrbvs	r6, [pc, #-2163]	@ fffff929 <_STACK_TOP_+0xdfff792d>
     198:	70686463 	rsbvc	r6, r8, r3, ror #8
     19c:	00726961 	rsbseq	r6, r2, r1, ror #18
     1a0:	5f534541 	svcpl	0x00534541
     1a4:	00787463 	rsbseq	r7, r8, r3, ror #8
     1a8:	5f534541 	svcpl	0x00534541
     1ac:	74696e69 	strbtvc	r6, [r9], #-3689	@ 0xfffff197
     1b0:	7874635f 	ldmdavc	r4!, {r0, r1, r2, r3, r4, r6, r8, r9, sp, lr}^
     1b4:	72747300 	rsbsvc	r7, r4, #0, 6
     1b8:	00706d63 	rsbseq	r6, r0, r3, ror #26
     1bc:	5f646d63 	svcpl	0x00646d63
     1c0:	6f6c0074 	svcvs	0x006c0074
     1c4:	6c20676e 	stcvs	7, cr6, [r0], #-440	@ 0xfffffe48
     1c8:	20676e6f 	rsbcs	r6, r7, pc, ror #28
     1cc:	00746e69 	rsbseq	r6, r4, r9, ror #28
     1d0:	48444345 	stmdami	r4, {r0, r2, r6, r8, r9, lr}^
     1d4:	6168735f 	cmnvs	r8, pc, asr r3
     1d8:	00646572 	rsbeq	r6, r4, r2, ror r5
     1dc:	6e697270 	mcrvs	2, 3, r7, cr9, cr0, {3}
     1e0:	73006674 	movwvc	r6, #1652	@ 0x674
     1e4:	74726f68 	ldrbtvc	r6, [r2], #-3944	@ 0xfffff098
     1e8:	746e6920 	strbtvc	r6, [lr], #-2336	@ 0xfffff6e0
     1ec:	67726100 	ldrbvs	r6, [r2, -r0, lsl #2]!
     1f0:	68730063 	ldmdavs	r3!, {r0, r1, r5, r6}^
     1f4:	78746361 	ldmdavc	r4!, {r0, r5, r6, r8, r9, sp, lr}^
     1f8:	6f682f00 	svcvs	0x00682f00
     1fc:	652f656d 	strvs	r6, [pc, #-1389]!	@ fffffc97 <_STACK_TOP_+0xdfff7c9b>
     200:	2f667463 	svccs	0x00667463
     204:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
     208:	6172742d 	cmnvs	r2, sp, lsr #8
     20c:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
     210:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
     214:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
     218:	6f662f66 	svcvs	0x00662f66
     21c:	656d2f62 	strbvs	r2, [sp, #-3938]!	@ 0xfffff09e
     220:	632e6773 			@ <UNDEFINED> instruction: 0x632e6773
     224:	6e6f6c00 	cdpvs	12, 6, cr6, cr15, cr0, {0}
     228:	6f642067 	svcvs	0x00642067
     22c:	656c6275 	strbvs	r6, [ip, #-629]!	@ 0xfffffd8b
     230:	64636500 	strbtvs	r6, [r3], #-1280	@ 0xfffffb00
     234:	68735f68 	ldmdavs	r3!, {r3, r5, r6, r8, r9, sl, fp, ip, lr}^
     238:	64657261 	strbtvs	r7, [r5], #-609	@ 0xfffffd9f
     23c:	6365735f 	cmnvs	r5, #2080374785	@ 0x7c000001
     240:	00746572 	rsbseq	r6, r4, r2, ror r5
     244:	70726163 	rsbsvc	r6, r2, r3, ror #2
     248:	656b6275 	strbvs	r6, [fp, #-629]!	@ 0xfffffd8b
     24c:	74730079 	ldrbtvc	r0, [r3], #-121	@ 0xffffff87
     250:	6e656c72 	mcrvs	12, 3, r6, cr5, cr2, {3}
     254:	63656400 	cmnvs	r5, #0, 8
     258:	6465646f 	strbtvs	r6, [r5], #-1135	@ 0xfffffb91
     25c:	6d6f6300 	stclvs	3, cr6, [pc, #-0]	@ 264 <vector_table+0x264>
     260:	646e616d 	strbtvs	r6, [lr], #-365	@ 0xfffffe93
     264:	6d616e5f 	stclvs	14, cr6, [r1, #-380]!	@ 0xfffffe84
     268:	69750065 	ldmdbvs	r5!, {r0, r2, r5, r6}^
     26c:	3233746e 	eorscc	r7, r3, #1845493760	@ 0x6e000000
     270:	7200745f 	andvc	r7, r0, #1593835520	@ 0x5f000000
     274:	74657365 	strbtvc	r7, [r5], #-869	@ 0xfffffc9b
     278:	6e61685f 	mcrvs	8, 3, r6, cr1, cr15, {2}
     27c:	72656c64 	rsbvc	r6, r5, #100, 24	@ 0x6400
     280:	66656400 	strbtvs	r6, [r5], -r0, lsl #8
     284:	746c7561 	strbtvc	r7, [ip], #-1377	@ 0xfffffa9f
     288:	6e61685f 	mcrvs	8, 3, r6, cr1, cr15, {2}
     28c:	72656c64 	rsbvc	r6, r5, #100, 24	@ 0x6400
     290:	54535f00 	ldrbpl	r5, [r3], #-3840	@ 0xfffff100
     294:	5f4b4341 	svcpl	0x004b4341
     298:	5f504f54 	svcpl	0x00504f54
     29c:	6f682f00 	svcvs	0x00682f00
     2a0:	652f656d 	strvs	r6, [pc, #-1389]!	@ fffffd3b <_STACK_TOP_+0xdfff7d3f>
     2a4:	2f667463 	svccs	0x00667463
     2a8:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
     2ac:	6172742d 	cmnvs	r2, sp, lsr #8
     2b0:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
     2b4:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
     2b8:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
     2bc:	6f662f66 	svcvs	0x00662f66
     2c0:	6c702f62 	ldclvs	15, cr2, [r0], #-392	@ 0xfffffe78
     2c4:	6f667461 	svcvs	0x00667461
     2c8:	762f6d72 			@ <UNDEFINED> instruction: 0x762f6d72
     2cc:	6f746365 	svcvs	0x00746365
     2d0:	61745f72 	cmnvs	r4, r2, ror pc
     2d4:	2e656c62 	cdpcs	12, 6, cr6, cr5, cr2, {3}
     2d8:	65760063 	ldrbvs	r0, [r6, #-99]!	@ 0xffffff9d
     2dc:	726f7463 	rsbvc	r7, pc, #1660944384	@ 0x63000000
     2e0:	6261745f 	rsbvs	r7, r1, #1593835520	@ 0x5f000000
     2e4:	7500656c 	strvc	r6, [r0, #-1388]	@ 0xfffffa94
     2e8:	5f747261 	svcpl	0x00747261
     2ec:	74696e69 	strbtvc	r6, [r9], #-3689	@ 0xfffff197
     2f0:	65677500 	strbvs	r7, [r7, #-1280]!	@ 0xfffffb00
     2f4:	2f006374 	svccs	0x00006374
     2f8:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
     2fc:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
     300:	63652f66 	cmnvs	r5, #408	@ 0x198
     304:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
     308:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
     30c:	662f7265 	strtvs	r7, [pc], -r5, ror #4
     310:	652f626f 	strvs	r6, [pc, #-623]!	@ a9 <vector_table+0xa9>
     314:	2f667463 	svccs	0x00667463
     318:	2f626f66 	svccs	0x00626f66
     31c:	74616c70 	strbtvc	r6, [r1], #-3184	@ 0xfffff390
     320:	6d726f66 	ldclvs	15, cr6, [r2, #-408]!	@ 0xfffffe68
     324:	7261752f 	rsbvc	r7, r1, #197132288	@ 0xbc00000
     328:	61752f74 	cmnvs	r5, r4, ror pc
     32c:	632e7472 			@ <UNDEFINED> instruction: 0x632e7472
     330:	75707500 	ldrbvc	r7, [r0, #-1280]!	@ 0xfffffb00
     334:	75006374 	strvc	r6, [r0, #-884]	@ 0xfffffc8c
     338:	74757032 	ldrbtvc	r7, [r5], #-50	@ 0xffffffce
     33c:	682f0063 	stmdavs	pc!, {r0, r1, r5, r6}	@ <UNPREDICTABLE>
     340:	2f656d6f 	svccs	0x00656d6f
     344:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
     348:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
     34c:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
     350:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
     354:	6f662f72 	svcvs	0x00662f72
     358:	63652f62 	cmnvs	r5, #392	@ 0x188
     35c:	662f6674 			@ <UNDEFINED> instruction: 0x662f6674
     360:	702f626f 	eorvc	r6, pc, pc, ror #4
     364:	6674616c 	ldrbtvs	r6, [r4], -ip, ror #2
     368:	2f6d726f 	svccs	0x006d726f
     36c:	74726175 	ldrbtvc	r6, [r2], #-373	@ 0xfffffe8b
     370:	7261752f 	rsbvc	r7, r1, #197132288	@ 0xbc00000
     374:	632e3274 			@ <UNDEFINED> instruction: 0x632e3274
     378:	67327500 	ldrvs	r7, [r2, -r0, lsl #10]!
     37c:	00637465 	rsbeq	r7, r3, r5, ror #8
     380:	74726175 	ldrbtvc	r6, [r2], #-373	@ 0xfffffe8b
     384:	6e695f32 	mcrvs	15, 3, r5, cr9, cr2, {1}
     388:	70007469 	andvc	r7, r0, r9, ror #8
     38c:	735f6e69 	cmpvc	pc, #1680	@ 0x690
     390:	70757465 	rsbsvc	r7, r5, r5, ror #8
     394:	74657300 	strbtvc	r7, [r5], #-768	@ 0xfffffd00
     398:	6165725f 	cmnvs	r5, pc, asr r2
     39c:	68635f64 	stmdavs	r3!, {r2, r5, r6, r8, r9, sl, fp, ip, lr}^
     3a0:	00327261 	eorseq	r7, r2, r1, ror #4
     3a4:	5f746573 	svcpl	0x00746573
     3a8:	74697277 	strbtvc	r7, [r9], #-631	@ 0xfffffd89
     3ac:	68635f65 	stmdavs	r3!, {r0, r2, r5, r6, r8, r9, sl, fp, ip, lr}^
     3b0:	73007261 	movwvc	r7, #609	@ 0x261
     3b4:	775f7465 	ldrbvc	r7, [pc, -r5, ror #8]
     3b8:	65746972 	ldrbvs	r6, [r4, #-2418]!	@ 0xfffff68e
     3bc:	6168635f 	cmnvs	r8, pc, asr r3
int finish_ecdhpair(int argc, char** argv) {
     3c0:	73003272 	movwvc	r3, #626	@ 0x272
    if (argc == 4) {
     3c4:	725f7465 	subsvc	r7, pc, #1694498816	@ 0x65000000
    else printf("Incorrect number of arguments for PAIRECDH2\n");
     3c8:	5f646165 	svcpl	0x00646165
     3cc:	72616863 	rsbvc	r6, r1, #6488064	@ 0x630000
     3d0:	6f682f00 	svcvs	0x00682f00
     3d4:	652f656d 	strvs	r6, [pc, #-1389]!	@ fffffe6f <_STACK_TOP_+0xdfff7e73>
        decode_base64((uint8_t *)argv[3], 64, carpubkey);
     3d8:	2f667463 	svccs	0x00667463
     3dc:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
        ecdh_shared_secret(ECDH_privkey, carpubkey, ECDH_shared);
     3e0:	6172742d 	cmnvs	r2, sp, lsr #8
     3e4:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
     3e8:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
        sha256_init(&shactx);
     3ec:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
     3f0:	6f662f66 	svcvs	0x00662f66
	    sha256_update(&shactx, ECDH_shared, ECC_PUB_KEY_SIZE);
     3f4:	6c702f62 	ldclvs	15, cr2, [r0], #-392	@ 0xfffffe78
     3f8:	6f667461 	svcvs	0x00667461
     3fc:	702f6d72 	eorvc	r6, pc, r2, ror sp	@ <UNPREDICTABLE>
	    sha256_final(&shactx, ECDH_AESkey);
     400:	6674616c 	ldrbtvs	r6, [r4], -ip, ror #2
     404:	2e6d726f 	cdpcs	2, 6, cr7, cr13, cr15, {3}
        AES_init_ctx(&ctx, ECDH_AESkey);
     408:	6c700063 	ldclvs	0, cr0, [r0], #-396	@ 0xfffffe74
     40c:	6f667461 	svcvs	0x00667461
     410:	695f6d72 	ldmdbvs	pc, {r1, r4, r5, r6, r8, sl, fp, sp, lr}^	@ <UNPREDICTABLE>
     414:	0074696e 	rsbseq	r6, r4, lr, ror #18
     418:	5f534541 	svcpl	0x00534541
     41c:	5f424345 	svcpl	0x00424345
     420:	72636e65 	rsbvc	r6, r3, #1616	@ 0x650
     424:	00747079 	rsbseq	r7, r4, r9, ror r0
int car_mesg(int argc, char** argv) {
     428:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 374 <vector_table+0x374>
     42c:	63652f65 	cmnvs	r5, #404	@ 0x194
    printf("Received a message from the car:");
     430:	652f6674 	strvs	r6, [pc, #-1652]!	@ fffffdc4 <_STACK_TOP_+0xdfff7dc8>
     434:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
    for (ctr = 1; ctr < argc; ctr++) {
     438:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
        printf(" %s", argv[ctr]);
     43c:	2f72656e 	svccs	0x0072656e
     440:	2f626f66 	svccs	0x00626f66
    for (ctr = 1; ctr < argc; ctr++) {
     444:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
     448:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
    printf("\n");
     44c:	7365612f 	cmnvc	r5, #-1073741813	@ 0xc000000b
    if (argc > 1) {
     450:	7365745f 	cmnvc	r5, #1593835520	@ 0x5f000000
}
     454:	00632e74 	rsbeq	r2, r3, r4, ror lr
     458:	6e697270 	mcrvs	2, 3, r7, cr9, cr0, {3}
        if (strcmp(argv[1], "PING_REPLY") == 0) {
     45c:	00326674 	eorseq	r6, r2, r4, ror r6
     460:	74343662 	ldrtvc	r3, [r4], #-1634	@ 0xfffff99e
            printf("Got a ping reply.\n");
     464:	00747865 	rsbseq	r7, r4, r5, ror #16
     468:	6f636e65 	svcvs	0x00636e65
        else if (strcmp(argv[1], "PAIRECDH2") == 0) {
     46c:	625f6564 	subsvs	r6, pc, #100, 10	@ 0x19000000
     470:	36657361 	strbtcc	r7, [r5], -r1, ror #6
     474:	765f0034 			@ <UNDEFINED> instruction: 0x765f0034
            finish_ecdhpair(argc, argv);
     478:	65617261 	strbvs	r7, [r1, #-609]!	@ 0xfffffd9f
     47c:	65745f73 	ldrbvs	r5, [r4, #-3955]!	@ 0xfffff08d
        else if (strcmp(argv[1], "AESB64") == 0) {
     480:	66007473 			@ <UNDEFINED> instruction: 0x66007473
     484:	495f626f 	ldmdbmi	pc, {r0, r1, r2, r3, r5, r6, r9, sp, lr}^	@ <UNPREDICTABLE>
     488:	63650044 	cmnvs	r5, #68	@ 0x44
            if (argc == 3) { 
     48c:	675f6864 	ldrbvs	r6, [pc, -r4, ror #16]
                printf("Missing AESB64 encoded message\n");
     490:	72656e65 	rsbvc	r6, r5, #1616	@ 0x650
     494:	5f657461 	svcpl	0x00657461
                len = decode_base64((uint8_t *) argv[2], strlen(argv[2]), decoded);
     498:	7379656b 	cmnvc	r9, #448790528	@ 0x1ac00000
     49c:	61765f00 	cmnvs	r6, r0, lsl #30
     4a0:	69617072 	stmdbvs	r1!, {r1, r4, r5, r6, ip, sp, lr}^
     4a4:	64636572 	strbtvs	r6, [r3], #-1394	@ 0xfffffa8e
     4a8:	765f0068 	ldrbvc	r0, [pc], -r8, rrx
                AES_ECB_decrypt(&ctx, decoded);
     4ac:	61707261 	cmnvs	r0, r1, ror #4
     4b0:	68637269 	stmdavs	r3!, {r0, r3, r5, r6, r9, ip, sp, lr}^
                decoded[len] = '\0';
     4b4:	006c6c61 	rsbeq	r6, ip, r1, ror #24
     4b8:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 404 <finish_ecdhpair+0x44>
     4bc:	63652f65 	cmnvs	r5, #404	@ 0x194
                printf("Decoded/decrypted as %s\n", decoded);
     4c0:	652f6674 	strvs	r6, [pc, #-1652]!	@ fffffe54 <_STACK_TOP_+0xdfff7e58>
     4c4:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
     4c8:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
        else if (strcmp(argv[1], "B64") == 0) {
     4cc:	2f72656e 	svccs	0x0072656e
     4d0:	2f626f66 	svccs	0x00626f66
            if (argc == 3) { 
     4d4:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
                printf("Missing Base64 encoded message\n");
     4d8:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
     4dc:	6961702f 	stmdbvs	r1!, {r0, r1, r2, r3, r5, ip, sp, lr}^
                printf("Decoding Base64\n");
     4e0:	00632e72 	rsbeq	r2, r3, r2, ror lr
     4e4:	6b627570 	blvs	189daac <__ROM_SIZE__+0x185daac>
                len = decode_base64((uint8_t *) argv[2], strlen(argv[2]), decoded);
     4e8:	625f7965 	subsvs	r7, pc, #1654784	@ 0x194000
     4ec:	70003436 	andvc	r3, r0, r6, lsr r4
     4f0:	69726961 	ldmdbvs	r2!, {r0, r5, r6, r8, fp, sp, lr}^
     4f4:	505f676e 	subspl	r6, pc, lr, ror #14
                decoded[len] = '\0';
     4f8:	45004e49 	strmi	r4, [r0, #-3657]	@ 0xfffff1b7
     4fc:	5f484443 	svcpl	0x00484443
     500:	76697270 			@ <UNDEFINED> instruction: 0x76697270
                printf("Decoded as %s", decoded);
     504:	5f79656b 	svcpl	0x0079656b
     508:	00343662 	eorseq	r3, r4, r2, ror #12
     50c:	7261765f 	rsbvc	r7, r1, #99614720	@ 0x5f00000
            printf("Didn't know how to handle %s\n", argv[1]);
     510:	72696170 	rsbvc	r6, r9, #112, 2
     514:	43450031 	movtmi	r0, #20529	@ 0x5031
     518:	705f4844 	subsvc	r4, pc, r4, asr #16
     51c:	656b6275 	strbvs	r6, [fp, #-629]!	@ 0xfffffd8b
     520:	765f0079 			@ <UNDEFINED> instruction: 0x765f0079
     524:	65647261 	strbvs	r7, [r4, #-609]!	@ 0xfffffd9f
     528:	65646f63 	strbvs	r6, [r4, #-3939]!	@ 0xfffff09d
     52c:	70003436 	andvc	r3, r0, r6, lsr r4
     530:	6e69616c 	powvsez	f6, f1, #4.0
     534:	74786574 	ldrbtvc	r6, [r8], #-1396	@ 0xfffffa8c
     538:	636e6500 	cmnvs	lr, #0, 10
     53c:	6465646f 	strbtvs	r6, [r5], #-1135	@ 0xfffffb91
     540:	6f682f00 	svcvs	0x00682f00
     544:	652f656d 	strvs	r6, [pc, #-1389]!	@ ffffffdf <_STACK_TOP_+0xdfff7fe3>
     548:	2f667463 	svccs	0x00667463
     54c:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
     550:	6172742d 	cmnvs	r2, sp, lsr #8
     554:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
void uputc(char c) {
     558:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
  while ((UARTFR >> 5) & 1)
     55c:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
     560:	6f662f66 	svcvs	0x00662f66
  UART_DR = c;
     564:	61622f62 	cmnvs	r2, r2, ror #30
  if (c == '\n')
     568:	34366573 	ldrtcc	r6, [r6], #-1395	@ 0xfffffa8d
}
     56c:	5f00632e 	svcpl	0x0000632e
    uputc('\r');
     570:	65726176 	ldrbvs	r6, [r2, #-374]!	@ 0xfffffe8a
}
     574:	646f636e 	strbtvs	r6, [pc], #-878	@ 57c <ugetc>
     578:	00343665 	eorseq	r3, r4, r5, ror #12
  if (!((UARTFR >> 4) & 1)) return UART_DR;
     57c:	74343662 	ldrtvc	r3, [r4], #-1634	@ 0xfffff99e
     580:	00747365 	rsbseq	r7, r4, r5, ror #6
     584:	6b627570 	blvs	189db4c <__ROM_SIZE__+0x185db4c>
     588:	00327965 	eorseq	r7, r2, r5, ror #18
  return -1;
     58c:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ 4d8 <car_mesg+0xb0>
}
     590:	63652f65 	cmnvs	r5, #404	@ 0x194
     594:	652f6674 	strvs	r6, [pc, #-1652]!	@ ffffff28 <_STACK_TOP_+0xdfff7f2c>
  UARTCTL = 0;
     598:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
     59c:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
  UARTIBRD = 8;
     5a0:	2f72656e 	svccs	0x0072656e
  UARTFBRD = 44;
     5a4:	2f626f66 	svccs	0x00626f66
  UARTCC = 0;
     5a8:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
  UARTLCRH = 0x60;
     5ac:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
  UARTCTL = 0x301;
     5b0:	6463652f 	strbtvs	r6, [r3], #-1327	@ 0xfffffad1
}
     5b4:	65745f68 	ldrbvs	r5, [r4, #-3944]!	@ 0xfffff098
     5b8:	632e7473 			@ <UNDEFINED> instruction: 0x632e7473
void u2putc(char c) {
     5bc:	61687300 	cmnvs	r8, r0, lsl #6
  while ((UART2FR >> 5) & 1)
     5c0:	73646572 	cmnvc	r4, #478150656	@ 0x1c800000
     5c4:	65726365 	ldrbvs	r6, [r2, #-869]!	@ 0xfffffc9b
  UART2_DR = c;
     5c8:	62003274 	andvs	r3, r0, #116, 4	@ 0x40000007
  if (c == '\n')
     5cc:	72703436 	rsbsvc	r3, r0, #905969664	@ 0x36000000
}
     5d0:	656b7669 	strbvs	r7, [fp, #-1641]!	@ 0xfffff997
    u2putc('\r');
     5d4:	6b003279 	blvs	cfc0 <__RAM_SIZE__+0x4fc0>
}
     5d8:	65747965 	ldrbvs	r7, [r4, #-2405]!	@ 0xfffff69b
     5dc:	5f007473 	svcpl	0x00007473
  if (!((UART2FR >> 4) & 1)) return UART2_DR;
     5e0:	65726176 	ldrbvs	r6, [r2, #-374]!	@ 0xfffffe8a
     5e4:	5f686463 	svcpl	0x00686463
     5e8:	74736574 	ldrbtvc	r6, [r3], #-1396	@ 0xfffffa8c
     5ec:	61765f00 	cmnvs	r6, r0, lsl #30
  return -1;
     5f0:	6e657372 	mcrvs	3, 3, r7, cr5, cr2, {3}
}
     5f4:	69705f64 	ldmdbvs	r0!, {r2, r5, r6, r8, r9, sl, fp, ip, lr}^
     5f8:	2f00676e 	svccs	0x0000676e
  UART2CTL = 0;
     5fc:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
     600:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
  UART2IBRD = 8;
     604:	63652f66 	cmnvs	r5, #408	@ 0x198
  UART2FBRD = 44;
     608:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
  UART2CC = 0;
     60c:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
  UART2LCRH = 0x60;
     610:	662f7265 	strtvs	r7, [pc], -r5, ror #4
  UART2CTL = 0x301;
     614:	652f626f 	strvs	r6, [pc, #-623]!	@ 3ad <vector_table+0x3ad>
}
     618:	2f667463 	svccs	0x00667463
     61c:	2f626f66 	svccs	0x00626f66
  RCGCUART |= 3;
     620:	676e6970 			@ <UNDEFINED> instruction: 0x676e6970
     624:	2f00632e 	svccs	0x0000632e
     628:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
     62c:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
  RCGCGPIO |= 3;
     630:	63652f66 	cmnvs	r5, #408	@ 0x198
     634:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
     638:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
  GPIODEN = 0x03;
     63c:	662f7265 	strtvs	r7, [pc], -r5, ror #4
     640:	652f626f 	strvs	r6, [pc, #-623]!	@ 3d9 <finish_ecdhpair+0x19>
  GPIOAFSEL = 0x03;
     644:	2f667463 	svccs	0x00667463
  GPIOPCTL |= 0x00000011;
     648:	2f626f66 	svccs	0x00626f66
     64c:	32616873 	rsbcc	r6, r1, #7536640	@ 0x730000
     650:	745f3635 	ldrbvc	r3, [pc], #-1589	@ 658 <pin_setup+0x38>
  GPIODEN2 = 0x03;
     654:	2e747365 	cdpcs	3, 7, cr7, cr4, cr5, {3}
     658:	36620063 	strbtcc	r0, [r2], -r3, rrx
  GPIOAFSEL2 = 0x03;
     65c:	75625f34 	strbvc	r5, [r2, #-3892]!	@ 0xfffff0cc
  GPIOPCTL2 |= 0x00000011;
     660:	36620066 	strbtcc	r0, [r2], -r6, rrx
     664:	61685f34 	cmnvs	r8, r4, lsr pc
     668:	00316873 	eorseq	r6, r1, r3, ror r8
}
     66c:	74786574 	ldrbtvc	r6, [r8], #-1396	@ 0xfffffa8c
     670:	765f0031 			@ <UNDEFINED> instruction: 0x765f0031
void platform_init() {
     674:	68737261 	ldmdavs	r3!, {r0, r5, r6, r9, ip, sp, lr}^
    pin_setup();
     678:	36353261 	ldrtcc	r3, [r5], -r1, ror #4
    uart_init();
     67c:	7365745f 	cmnvc	r5, #1593835520	@ 0x5f000000
    uart2_init();
     680:	61700074 	cmnvs	r0, r4, ror r0
    set_read_char(ugetc);
     684:	5f657372 	svcpl	0x00657372
    set_read_char2(u2getc);
     688:	656e696c 	strbvs	r6, [lr, #-2412]!	@ 0xfffff694
     68c:	61686300 	cmnvs	r8, r0, lsl #6
    set_write_char(uputc);
     690:	6f635f72 	svcvs	0x00635f72
    set_write_char2(u2putc);
     694:	00746e75 	rsbseq	r6, r4, r5, ror lr
     698:	72775f5f 	rsbsvc	r5, r7, #380	@ 0x17c
}
     69c:	5f657469 	svcpl	0x00657469
     6a0:	72616863 	rsbvc	r6, r1, #6488064	@ 0x630000
     6a4:	005f5f32 	subseq	r5, pc, r2, lsr pc	@ <UNPREDICTABLE>
     6a8:	6164655f 	cmnvs	r4, pc, asr r5
int aes_test(int argc, char** argv) {
     6ac:	5f006174 	svcpl	0x00006174
    uint8_t text[17] = "0123456789abcdef";
     6b0:	73726176 	cmnvc	r2, #-2147483619	@ 0x8000001d
     6b4:	5f776f68 	svcpl	0x00776f68
     6b8:	74736968 	ldrbtvc	r6, [r3], #-2408	@ 0xfffff698
     6bc:	0079726f 	rsbseq	r7, r9, pc, ror #4
     6c0:	69746361 	ldmdbvs	r4!, {r0, r5, r6, r8, r9, sp, lr}^
    printf("Plaintext is %s\n", text);
     6c4:	705f6576 	subsvc	r6, pc, r6, ror r5	@ <UNPREDICTABLE>
     6c8:	706d6f72 	rsbvc	r6, sp, r2, ror pc
    AES_ECB_encrypt(&ctx, text);
     6cc:	45410074 	strbmi	r0, [r1, #-116]	@ 0xffffff8c
     6d0:	656b5f53 	strbvs	r5, [fp, #-3923]!	@ 0xfffff0ad
    len = encode_base64(text, 16, b64text);
     6d4:	65760079 	ldrbvs	r0, [r6, #-121]!	@ 0xffffff87
     6d8:	736f6272 	cmnvc	pc, #536870919	@ 0x20000007
     6dc:	765f0065 	ldrbvc	r0, [pc], -r5, rrx
    b64text[len] = '\0';
     6e0:	6d637261 	sfmvs	f7, 2, [r3, #-388]!	@ 0xfffffe7c
     6e4:	78655f64 	stmdavc	r5!, {r2, r5, r6, r8, r9, sl, fp, ip, lr}^
     6e8:	735f6365 	cmpvc	pc, #-1811939327	@ 0x94000001
    printf("Encrypted/encoded is %s\n", b64text);
     6ec:	75746174 	ldrbvc	r6, [r4, #-372]!	@ 0xfffffe8c
     6f0:	5f5f0073 	svcpl	0x005f0073
    printf2("FOB_MESG AESB64 %s\n", b64text);
     6f4:	64616572 	strbtvs	r6, [r1], #-1394	@ 0xfffffa8e
     6f8:	6168635f 	cmnvs	r8, pc, asr r3
    printf("Test the mesg handler with CAR_MESG AESB64 %s\n", b64text);
     6fc:	005f5f72 	subseq	r5, pc, r2, ror pc	@ <UNPREDICTABLE>
     700:	74696e69 	strbtvc	r6, [r9], #-3689	@ 0xfffff197
    len = decode_base64(b64text, len, decoded);
     704:	5f6c6169 	svcpl	0x006c6169
     708:	75746573 	ldrbvc	r6, [r4, #-1395]!	@ 0xfffffa8d
     70c:	656d0070 	strbvs	r0, [sp, #-112]!	@ 0xffffff90
    AES_ECB_decrypt(&ctx, decoded);
     710:	7970636d 	ldmdbvc	r0!, {r0, r2, r3, r5, r6, r8, r9, sp, lr}^
     714:	61765f00 	cmnvs	r6, r0, lsl #30
    decoded[len] = '\0';
     718:	6c656872 	stclvs	8, cr6, [r5], #-456	@ 0xfffffe38
     71c:	61680070 	smcvs	32768	@ 0x8000
     720:	656c646e 	strbvs	r6, [ip, #-1134]!	@ 0xfffffb92
    printf("After encrypting->encoding->decoding->decrypting we recover %s\n", decoded);
     724:	6261745f 	rsbvs	r7, r1, #1593835520	@ 0x5f000000
     728:	656c6300 	strbvs	r6, [ip, #-768]!	@ 0xfffffd00
}
     72c:	705f7261 	subsvc	r7, pc, r1, ror #4
     730:	706d6f72 	rsbvc	r6, sp, r2, ror pc
     734:	6d630074 	stclvs	0, cr0, [r3, #-464]!	@ 0xfffffe30
     738:	69685f64 	stmdbvs	r8!, {r2, r5, r6, r8, r9, sl, fp, ip, lr}^
     73c:	726f7473 	rsbvc	r7, pc, #1929379840	@ 0x73000000
     740:	6d630079 	stclvs	0, cr0, [r3, #-484]!	@ 0xfffffe1c
     744:	74735f64 	ldrbtvc	r5, [r3], #-3940	@ 0xfffff09c
     748:	61680072 	smcvs	32770	@ 0x8002
     74c:	656c646e 	strbvs	r6, [ip, #-1134]!	@ 0xfffffb92
int pair1(int argc, char** argv) {
     750:	5f70755f 	svcpl	0x0070755f
    printf("Sending a pair request.\n");
     754:	6f727261 	svcvs	0x00727261
    printf2("FOB_MESG PAIR %d %d\n", fob_ID, pairing_PIN);
     758:	78650077 	stmdavc	r5!, {r0, r1, r2, r4, r5, r6}^
     75c:	66006365 	strvs	r6, [r0], -r5, ror #6
     760:	00636e75 	rsbeq	r6, r3, r5, ror lr
     764:	7362655f 	cmnvc	r2, #398458880	@ 0x17c00000
}
     768:	656d0073 	strbvs	r0, [sp, #-115]!	@ 0xffffff8d
     76c:	7465736d 	strbtvc	r7, [r5], #-877	@ 0xfffffc93
     770:	435f5f00 	cmpmi	pc, #0, 30
     774:	545f444d 	ldrbpl	r4, [pc], #-1101	@ 77c <pairchall>
     778:	454c4241 	strbmi	r4, [ip, #-577]	@ 0xfffffdbf
int pairchall(int argc, char** argv) {
     77c:	4154535f 	cmpmi	r4, pc, asr r3
    printf("Sending a pair request with challenge/response.\n");
     780:	5f5f5452 	svcpl	0x005f5452
    printf2("FOB_MESG PAIRCR %d %d\n", fob_ID, pairing_PIN);
     784:	6e696c00 	cdpvs	12, 6, cr6, cr9, cr0, {0}
     788:	75625f65 	strbvc	r5, [r2, #-3941]!	@ 0xfffff09b
     78c:	5f006666 	svcpl	0x00006666
     790:	61746164 	cmnvs	r4, r4, ror #2
}
     794:	65687300 	strbvs	r7, [r8, #-768]!	@ 0xfffffd00
     798:	41006c6c 	tstmi	r0, ip, ror #24
     79c:	6b5f5345 	blvs	17d54b8 <__ROM_SIZE__+0x17954b8>
     7a0:	625f7965 	subsvs	r7, pc, #1654784	@ 0x194000
     7a4:	61003436 	tstvs	r0, r6, lsr r4
int pairecdh(int argc, char** argv) {
     7a8:	635f6464 	cmpvs	pc, #100, 8	@ 0x64000000
    printf("Starting EC Diffie-Hellman key exchange.\n");
     7ac:	616d6d6f 	cmnvs	sp, pc, ror #26
     7b0:	745f646e 	ldrbvc	r6, [pc], #-1134	@ 7b8 <pairecdh+0x10>
    decode_base64(ECDH_privkey_b64, 32, ECDH_privkey);
     7b4:	69685f6f 	stmdbvs	r8!, {r0, r1, r2, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
     7b8:	726f7473 	rsbvc	r7, pc, #1929379840	@ 0x73000000
     7bc:	616d0079 	smcvs	53257	@ 0xd009
    ecdh_generate_keys(ECDH_pubkey, ECDH_privkey);
     7c0:	5f686374 	svcpl	0x00686374
     7c4:	6e756f66 	cdpvs	15, 7, cr6, cr5, cr6, {3}
    encode_base64(ECDH_pubkey, ECC_PUB_KEY_SIZE, pubkey_b64);
     7c8:	6d630064 	stclvs	0, cr0, [r3, #-400]!	@ 0xfffffe70
     7cc:	6e655f64 	cdpvs	15, 6, cr5, cr5, cr4, {3}
     7d0:	74005f64 	strvc	r5, [r0], #-3940	@ 0xfffff09c
    pubkey_b64[64] = '\0';
     7d4:	6c61746f 	cfstrdvs	mvd7, [r1], #-444	@ 0xfffffe44
    printf2("FOB_MESG PAIRECDH %d %d %s\n", fob_ID, pairing_PIN, pubkey_b64);
     7d8:	6d756e5f 	ldclvs	14, cr6, [r5, #-380]!	@ 0xfffffe84
     7dc:	6d6f635f 	stclvs	3, cr6, [pc, #-380]!	@ 668 <pin_setup+0x48>
     7e0:	646e616d 	strbtvs	r6, [lr], #-365	@ 0xfffffe93
     7e4:	5f5f0073 	svcpl	0x005f0073
}
     7e8:	4f545541 	svcmi	0x00545541
     7ec:	4241545f 	submi	r5, r1, #1593835520	@ 0x5f000000
     7f0:	535f454c 	cmppl	pc, #76, 10	@ 0x13000000
     7f4:	54524154 	ldrbpl	r4, [r2], #-340	@ 0xfffffeac
     7f8:	6c005f5f 	stcvs	15, cr5, [r0], {95}	@ 0x5f
     7fc:	00706f6f 	rsbseq	r6, r0, pc, ror #30
     800:	63657073 	cmnvs	r5, #115	@ 0x73
     804:	5f6c6169 	svcpl	0x006c6169
     808:	0079656b 	rsbseq	r6, r9, fp, ror #10
int encode64(int argc, char** argv) {
     80c:	5f646d63 	svcpl	0x00646d63
    if (argc > 1) {
     810:	66667562 	strbtvs	r7, [r6], -r2, ror #10
     814:	61765f00 	cmnvs	r6, r0, lsl #30
        len = strlen(argv[1]);
     818:	69756272 	ldmdbvs	r5!, {r1, r4, r5, r6, r9, sp, lr}^
     81c:	695f646c 	ldmdbvs	pc, {r2, r3, r5, r6, sl, sp, lr}^	@ <UNPREDICTABLE>
        if (len < MAXARRAYLEN) {
     820:	006f666e 	rsbeq	r6, pc, lr, ror #12
            len = encode_base64((uint8_t *) argv[1], len, encoded);
     824:	66657270 			@ <UNDEFINED> instruction: 0x66657270
     828:	6d5f7869 	ldclvs	8, cr7, [pc, #-420]	@ 68c <platform_init+0x18>
            printf("Encoded %s as %s with %d characters\n", argv[1], encoded, len);
     82c:	68637461 	stmdavs	r3!, {r0, r5, r6, sl, ip, sp, lr}^
     830:	6f425f00 	svcvs	0x00425f00
     834:	6c006c6f 	stcvs	12, cr6, [r0], {111}	@ 0x6f
            printf("String exceeds max length of %d characters", MAXARRAYLEN);
     838:	5f747361 	svcpl	0x00747361
     83c:	6374616d 	cmnvs	r4, #1073741851	@ 0x4000001b
     840:	72700068 	rsbsvc	r0, r0, #104	@ 0x68
        printf("Usage is 'encode64 string'\n");
     844:	6e657065 	cdpvs	0, 6, cr7, cr5, cr5, {3}
}
     848:	72705f64 	rsbsvc	r5, r0, #100, 30	@ 0x190
     84c:	74706d6f 	ldrbtvc	r6, [r0], #-3439	@ 0xfffff291
     850:	6c656400 	cfstrdvs	mvd6, [r5], #-0
     854:	00657465 	rsbeq	r7, r5, r5, ror #8
     858:	72775f5f 	rsbsvc	r5, r7, #380	@ 0x17c
int decode64(int argc, char** argv) {
     85c:	5f657469 	svcpl	0x00657469
    if (argc > 1) {
     860:	72616863 	rsbvc	r6, r1, #6488064	@ 0x630000
     864:	68005f5f 	stmdavs	r0, {r0, r1, r2, r3, r4, r6, r8, r9, sl, fp, ip, lr}
        int len = strlen(argv[1]);
     868:	6c646e61 	stclvs	14, cr6, [r4], #-388	@ 0xfffffe7c
     86c:	6f645f65 	svcvs	0x00645f65
        if (len < MAXBASE64LEN) {
     870:	615f6e77 	cmpvs	pc, r7, ror lr	@ <UNPREDICTABLE>
                len = decode_base64((uint8_t *) argv[1], len, plaintext);
     874:	776f7272 			@ <UNDEFINED> instruction: 0x776f7272
     878:	74656700 	strbtvc	r6, [r5], #-1792	@ 0xfffff900
                plaintext[len] = '\0';
     87c:	6e75665f 	mrcvs	6, 3, r6, cr5, cr15, {2}
     880:	6f697463 	svcvs	0x00697463
     884:	64615f6e 	strbtvs	r5, [r1], #-3950	@ 0xfffff092
                printf("Decoded %s as: %s\n", argv[1], plaintext);
     888:	5f007264 	svcpl	0x00007264
     88c:	646d635f 	strbtvs	r6, [sp], #-863	@ 0xfffffca1
     890:	6578655f 	ldrbvs	r6, [r8, #-1375]!	@ 0xfffffaa1
            printf("String exceeds max base64 string length of %d characters", MAXBASE64LEN);
     894:	74735f63 	ldrbtvc	r5, [r3], #-3939	@ 0xfffff09d
     898:	73757461 	cmnvc	r5, #1627389952	@ 0x61000000
     89c:	74616d00 	strbtvc	r6, [r1], #-3328	@ 0xfffff300
        printf("Usage is 'decode64 string'\n");
     8a0:	635f6863 	cmpvs	pc, #6488064	@ 0x630000
}
     8a4:	746e756f 	strbtvc	r7, [lr], #-1391	@ 0xfffffa91
     8a8:	65786500 	ldrbvs	r6, [r8, #-1280]!	@ 0xfffffb00
     8ac:	75615f63 	strbvc	r5, [r1, #-3939]!	@ 0xfffff09d
     8b0:	635f6f74 	cmpvs	pc, #116, 30	@ 0x1d0
     8b4:	0073646d 	rsbseq	r6, r3, sp, ror #8
int ecdh_test(int argc, char** argv) {
     8b8:	72727563 	rsbsvc	r7, r2, #415236096	@ 0x18c00000
    uint8_t b64privkey2[32] = "wP/uwP/uwP/uwP/uwP/uwP/uwP/uwP/u";
     8bc:	6d6f635f 	stclvs	3, cr6, [pc, #-380]!	@ 748 <aes_test+0x9c>
     8c0:	646e616d 	strbtvs	r6, [lr], #-365	@ 0xfffffe93
     8c4:	7274705f 	rsbsvc	r7, r4, #95	@ 0x5f
     8c8:	646e6500 	strbtvs	r6, [lr], #-1280	@ 0xfffffb00
     8cc:	646e695f 	strbtvs	r6, [lr], #-2399	@ 0xfffff6a1
    printf("Testing the ecdh key exchange\n");
     8d0:	2f007865 	svccs	0x00007865
     8d4:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
    decode_base64(ECDH_privkey_b64, 32, ECDH_privkey);
     8d8:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
     8dc:	63652f66 	cmnvs	r5, #408	@ 0x198
     8e0:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
    decode_base64(b64privkey2, 32, privkey2);
     8e4:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
     8e8:	662f7265 	strtvs	r7, [pc], -r5, ror #4
    ecdh_generate_keys(ECDH_pubkey, ECDH_privkey);
     8ec:	732f626f 			@ <UNDEFINED> instruction: 0x732f626f
     8f0:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
     8f4:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
    ecdh_generate_keys(pubkey2, privkey2);
     8f8:	732f6c6c 			@ <UNDEFINED> instruction: 0x732f6c6c
     8fc:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
    ecdh_shared_secret(ECDH_privkey, pubkey2, ECDH_shared);
     900:	6500632e 	strvs	r6, [r0, #-814]	@ 0xfffffcd2
     904:	75636578 	strbvc	r6, [r3, #-1400]!	@ 0xfffffa88
     908:	61006574 	tstvs	r0, r4, ror r5
    ecdh_shared_secret(privkey2, ECDH_pubkey, sharedsecret2);
     90c:	6d756772 	ldclvs	7, cr6, [r5, #-456]!	@ 0xfffffe38
     910:	5f746e65 	svcpl	0x00746e65
    sha256_init(&shactx);
     914:	657a6973 	ldrbvs	r6, [sl, #-2419]!	@ 0xfffff68d
     918:	655f5f00 	ldrbvs	r5, [pc, #-3840]	@ fffffa20 <_STACK_TOP_+0xdfff7a24>
	sha256_update(&shactx, ECDH_shared, ECC_PUB_KEY_SIZE);
     91c:	006f6863 	rsbeq	r6, pc, r3, ror #16
     920:	5f676562 	svcpl	0x00676562
	sha256_final(&shactx, ECDH_AESkey);
     924:	65646e69 	strbvs	r6, [r4, #-3689]!	@ 0xfffff197
     928:	75610078 	strbvc	r0, [r1, #-120]!	@ 0xffffff88
     92c:	6c5f6f74 	mrrcvs	15, 7, r6, pc, cr4	@ <UNPREDICTABLE>
    len = encode_base64(ECDH_AESkey, AES_KEYLEN, b64test);
     930:	0064616f 	rsbeq	r6, r4, pc, ror #2
     934:	65725f5f 	ldrbvs	r5, [r2, #-3935]!	@ 0xfffff0a1
    b64test[len] = '\0';
     938:	635f6461 	cmpvs	pc, #1627389952	@ 0x61000000
     93c:	32726168 	rsbscc	r6, r2, #104, 2
     940:	5f005f5f 	svcpl	0x00005f5f
     944:	78657465 	stmdavc	r5!, {r0, r2, r5, r6, sl, ip, sp, lr}^
    printf("First shared key is %s\n", b64test);
     948:	625f0074 	subsvs	r0, pc, #116	@ 0x74
     94c:	66007373 			@ <UNDEFINED> instruction: 0x66007373
    sha256_init(&shactx);
     950:	5f6c6c75 	svcpl	0x006c6c75
    sha256_update(&shactx, sharedsecret2, ECC_PUB_KEY_SIZE);
     954:	73746573 	cmnvc	r4, #482344960	@ 0x1cc00000
     958:	74756f00 	ldrbtvc	r6, [r5], #-3840	@ 0xfffff100
     95c:	00747570 	rsbseq	r7, r4, r0, ror r5
	sha256_final(&shactx, keytest);
     960:	65736162 	ldrbvs	r6, [r3, #-354]!	@ 0xfffffe9e
     964:	745f3436 	ldrbvc	r3, [pc], #-1078	@ 96c <ecdh_test+0xb4>
    len = encode_base64(keytest, AES_KEYLEN, b64test);
     968:	69625f6f 	stmdbvs	r2!, {r0, r1, r2, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
     96c:	7972616e 	ldmdbvc	r2!, {r1, r2, r3, r5, r6, r8, sp, lr}^
    b64test[len] = '\0';
     970:	706e6900 	rsbvc	r6, lr, r0, lsl #18
     974:	6c5f7475 	cfldrdvs	mvd7, [pc], {117}	@ 0x75
     978:	74676e65 	strbtvc	r6, [r7], #-3685	@ 0xfffff19b
    printf("Should be same as %s\n", b64test);
     97c:	682f0068 	stmdavs	pc!, {r3, r5, r6}	@ <UNPREDICTABLE>
     980:	2f656d6f 	svccs	0x00656d6f
    printf("Switching fob AES key to new value. Try AES tests now.\n");
     984:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
     988:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
    AES_init_ctx(&ctx, ECDH_AESkey);
     98c:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
     990:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
}
     994:	6f662f72 	svcvs	0x00662f72
     998:	68732f62 	ldmdavs	r3!, {r1, r5, r6, r8, r9, sl, fp, sp}^
     99c:	2f6c6c65 	svccs	0x006c6c65
     9a0:	2f62696c 	svccs	0x0062696c
     9a4:	65736162 	ldrbvs	r6, [r3, #-354]!	@ 0xfffffe9e
     9a8:	622f3436 	eorvs	r3, pc, #905969664	@ 0x36000000
     9ac:	36657361 	strbtcc	r7, [r5], -r1, ror #6
     9b0:	00632e34 	rsbeq	r2, r3, r4, lsr lr
     9b4:	6f636e65 	svcvs	0x00636e65
     9b8:	625f6564 	subsvs	r6, pc, #100, 10	@ 0x19000000
     9bc:	36657361 	strbtcc	r7, [r5], -r1, ror #6
     9c0:	656c5f34 	strbvs	r5, [ip, #-3892]!	@ 0xfffff0cc
int send_ping(int argc, char** argv) {
     9c4:	6874676e 	ldmdavs	r4!, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}^
    printf("Pinging the car.\n");
     9c8:	74756f00 	ldrbtvc	r6, [r5], #-3840	@ 0xfffff100
    printf2("FOB_MESG PING\n");
     9cc:	5f747570 	svcpl	0x00747570
     9d0:	676e656c 	strbvs	r6, [lr, -ip, ror #10]!
}
     9d4:	62006874 	andvs	r6, r0, #116, 16	@ 0x740000
     9d8:	72616e69 	rsbvc	r6, r1, #1680	@ 0x690
     9dc:	6f745f79 	svcvs	0x00745f79
int sha256_test(int argc, char** argv) {
     9e0:	7361625f 	cmnvc	r1, #-268435451	@ 0xf0000005
    printf("Starting sha256 test\n");
     9e4:	00343665 	eorseq	r3, r4, r5, ror #12
     9e8:	75706e69 	ldrbvc	r6, [r0, #-3689]!	@ 0xfffff197
    BYTE text1[] = {"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"};
     9ec:	74730074 	ldrbtvc	r0, [r3], #-116	@ 0xffffff8c
     9f0:	00747261 	rsbseq	r7, r4, r1, ror #4
     9f4:	6f636564 	svcvs	0x00636564
     9f8:	625f6564 	subsvs	r6, pc, #100, 10	@ 0x19000000
     9fc:	36657361 	strbtcc	r7, [r5], -r1, ror #6
     a00:	656c5f34 	strbvs	r5, [ip, #-3892]!	@ 0xfffff0cc
     a04:	6874676e 	ldmdavs	r4!, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}^
     a08:	6f682f00 	svcvs	0x00682f00
     a0c:	652f656d 	strvs	r6, [pc, #-1389]!	@ 4a7 <car_mesg+0x7f>
    BYTE hash1[SHA256_BLOCK_SIZE] = {0x24,0x8d,0x6a,0x61,0xd2,0x06,0x38,0xb8,0xe5,0xc0,0x26,0x93,0x0c,0x3e,0x60,0x39,
     a10:	2f667463 	svccs	0x00667463
     a14:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
     a18:	6172742d 	cmnvs	r2, sp, lsr #8
     a1c:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
    sha256_init(&shactx);
     a20:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
	sha256_update(&shactx, text1, strlen((char *)text1));
     a24:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
     a28:	6c2f6c6c 	stcvs	12, cr6, [pc], #-432	@ 880 <decode64+0x24>
     a2c:	732f6269 			@ <UNDEFINED> instruction: 0x732f6269
     a30:	35326168 	ldrcc	r6, [r2, #-360]!	@ 0xfffffe98
	sha256_final(&shactx, buf);
     a34:	68732f36 	ldmdavs	r3!, {r1, r2, r4, r5, r8, r9, sl, fp, sp}^
     a38:	36353261 	ldrtcc	r3, [r5], -r1, ror #4
    len = encode_base64(hash1, SHA256_BLOCK_SIZE, b64_hash1);
     a3c:	6800632e 	stmdavs	r0, {r1, r2, r3, r5, r8, r9, sp, lr}
     a40:	00687361 	rsbeq	r7, r8, r1, ror #6
     a44:	32616873 	rsbcc	r6, r1, #7536640	@ 0x730000
    b64_hash1[len] = '\0';
     a48:	745f3635 	ldrbvc	r3, [pc], #-1589	@ a50 <sha256_test+0x70>
    len = encode_base64(buf, SHA256_BLOCK_SIZE, b64_buf);
     a4c:	736e6172 	cmnvc	lr, #-2147483620	@ 0x8000001c
     a50:	6d726f66 	ldclvs	15, cr6, [r2, #-408]!	@ 0xfffffe68
     a54:	74756f00 	ldrbtvc	r6, [r5], #-3840	@ 0xfffff100
    b64_buf[len] = '\0';
     a58:	00727473 	rsbseq	r7, r2, r3, ror r4
    printf("Base64 of SHA-256 test is %s\n", b64_buf);
     a5c:	6461656c 	strbtvs	r6, [r1], #-1388	@ 0xfffffa94
     a60:	5f676e69 	svcpl	0x00676e69
    printf("Should be %s\n", b64_hash1);
     a64:	6f72657a 	svcvs	0x0072657a
     a68:	6e67695f 			@ <UNDEFINED> instruction: 0x6e67695f
}
     a6c:	6465726f 	strbtvs	r7, [r5], #-623	@ 0xfffffd91
     a70:	52415000 	subpl	r5, r1, #0
     a74:	465f4553 			@ <UNDEFINED> instruction: 0x465f4553
     a78:	535f544d 	cmppl	pc, #1291845632	@ 0x4d000000
     a7c:	68005254 	stmdavs	r0, {r2, r4, r6, r9, ip, lr}
     a80:	61747865 	cmnvs	r4, r5, ror #16
void __attribute__((optimize("O0"), weak)) initial_setup(void) {
     a84:	00656c62 	rsbeq	r6, r5, r2, ror #24
     a88:	5f6d756e 	svcpl	0x006d756e
  char *src = &_etext, *dst = &_data;
     a8c:	006e656c 	rsbeq	r6, lr, ip, ror #10
     a90:	6f635f6c 	svcvs	0x00635f6c
  if (dst != src)
     a94:	00746e75 	rsbseq	r6, r4, r5, ror lr
     a98:	61765f5f 	cmnvs	r6, pc, asr pc
    while (dst < &_edata) *(dst++) = *(src++);
     a9c:	73696c5f 	cmnvc	r9, #24320	@ 0x5f00
     aa0:	682f0074 	stmdavs	pc!, {r2, r4, r5, r6}	@ <UNPREDICTABLE>
     aa4:	2f656d6f 	svccs	0x00656d6f
     aa8:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
     aac:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
     ab0:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
  for (dst = &_bss; dst < &_ebss; dst++) *dst = 0;
     ab4:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
     ab8:	6f662f72 	svcvs	0x00662f72
     abc:	68732f62 	ldmdavs	r3!, {r1, r5, r6, r8, r9, sl, fp, sp}^
     ac0:	2f6c6c65 	svccs	0x006c6c65
     ac4:	2f62696c 	svccs	0x0062696c
     ac8:	6e697270 	mcrvs	2, 3, r7, cr9, cr0, {3}
     acc:	702f6674 	eorvc	r6, pc, r4, ror r6	@ <UNPREDICTABLE>
  platform_init();
     ad0:	746e6972 	strbtvc	r6, [lr], #-2418	@ 0xfffff68e
}
     ad4:	00632e66 	rsbeq	r2, r3, r6, ror #28
     ad8:	6e697270 	mcrvs	2, 3, r7, cr9, cr0, {3}
     adc:	735f6674 	cmpvc	pc, #116, 12	@ 0x7400000
     ae0:	65746174 	ldrbvs	r6, [r4, #-372]!	@ 0xfffffe8c
     ae4:	61747300 	cmnvs	r4, r0, lsl #6
     ae8:	625f7472 	subsvs	r7, pc, #1912602624	@ 0x72000000
     aec:	5f007469 	svcpl	0x00007469
static void delete(void) {
     af0:	756e675f 	strbvc	r6, [lr, #-1887]!	@ 0xfffff8a1
  __write_char__(BACK_SPACE);
     af4:	61765f63 	cmnvs	r6, r3, ror #30
     af8:	73696c5f 	cmnvc	r9, #24320	@ 0x5f00
  __write_char__(SPACE);
     afc:	61760074 	cmnvs	r6, r4, ror r0
  __write_char__(BACK_SPACE);
     b00:	0065756c 	rsbeq	r7, r5, ip, ror #10
     b04:	6e697270 	mcrvs	2, 3, r7, cr9, cr0, {3}
}
     b08:	6e5f6674 	mrcvs	6, 2, r6, cr15, cr4, {3}
static void clear_prompt(int char_count) {
     b0c:	65626d75 	strbvs	r6, [r2, #-3445]!	@ 0xfffff28b
  while (char_count) {
     b10:	43007372 	movwmi	r7, #882	@ 0x372
    delete ();
     b14:	4b434548 	blmi	10d203c <__ROM_SIZE__+0x109203c>
  while (char_count) {
     b18:	0048435f 	subeq	r4, r8, pc, asr r3
}
     b1c:	73677261 	cmnvc	r7, #268435462	@ 0x10000006
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
     b20:	615f5f00 	cmpvs	pc, r0, lsl #30
    auto_load[i].command(0, NULL);
     b24:	72700070 	rsbsvc	r0, r0, #112	@ 0x70
     b28:	66746e69 	ldrbtvs	r6, [r4], -r9, ror #28
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
     b2c:	74735f32 	ldrbtvc	r5, [r3], #-3890	@ 0xfffff0ce
     b30:	00657461 	rsbeq	r7, r5, r1, ror #8
     b34:	7374756f 	cmnvc	r4, #465567744	@ 0x1bc00000
     b38:	00327274 	eorseq	r7, r2, r4, ror r2
     b3c:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	@ a88 <initial_setup+0x4>
}
     b40:	63652f65 	cmnvs	r5, #404	@ 0x194
static int show_history(int argc, char **argv) {
     b44:	652f6674 	strvs	r6, [pc, #-1652]!	@ 4d8 <car_mesg+0xb0>
  uint32_t end_index = total_num_commands-1;
     b48:	2d667463 	cfstrdcs	mvd7, [r6, #-396]!	@ 0xfffffe74
  if (total_num_commands > NUM_HISTORY_ENTRIES) {
     b4c:	69617274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, sp, lr}^
     b50:	2f72656e 	svccs	0x0072656e
    beg_index = total_num_commands - NUM_HISTORY_ENTRIES;
     b54:	2f626f66 	svccs	0x00626f66
     b58:	6c656873 	stclvs	8, cr6, [r5], #-460	@ 0xfffffe34
  uint32_t beg_index = 0;
     b5c:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
    printf("%s\n", cmd_history[index % NUM_HISTORY_ENTRIES]);
     b60:	72702f62 	rsbsvc	r2, r0, #392	@ 0x188
     b64:	66746e69 	ldrbtvs	r6, [r4], -r9, ror #28
     b68:	6972702f 	ldmdbvs	r2!, {r0, r1, r2, r3, r5, ip, sp, lr}^
     b6c:	3266746e 	rsbcc	r7, r6, #1845493760	@ 0x6e000000
  for (uint32_t index = beg_index; index <= end_index; ++index) {
     b70:	7000632e 	andvc	r6, r0, lr, lsr #6
}
     b74:	746e6972 	strbtvc	r6, [lr], #-2418	@ 0xfffff68e
     b78:	6e5f3266 	cdpvs	2, 5, cr3, cr15, cr6, {3}
     b7c:	65626d75 	strbvs	r6, [r2, #-3445]!	@ 0xfffff28b
     b80:	68007372 	stmdavs	r0, {r1, r4, r5, r6, r8, r9, ip, sp, lr}
int cmd_exec_status(int argc, char **argv) {
     b84:	61747865 	cmnvs	r4, r5, ror #16
  printf("%d\n", __cmd_exec_status);
     b88:	32656c62 	rsbcc	r6, r5, #25088	@ 0x6200
     b8c:	61765f00 	cmnvs	r6, r0, lsl #30
     b90:	32337772 	eorscc	r7, r3, #29884416	@ 0x1c80000
}
     b94:	7469625f 	strbtvc	r6, [r9], #-607	@ 0xfffffda1
     b98:	61737500 	cmnvs	r3, r0, lsl #10
     b9c:	75006567 	strvc	r6, [r0, #-1383]	@ 0xfffffa99
static int build_info(int argc, char **argv) {
     ba0:	70746e69 	rsbsvc	r6, r4, r9, ror #28
  printf("Build: [" SHELL_VERSION ":" USER_REPO_VERSION "] - [" BUILD_USER
     ba4:	745f7274 	ldrbvc	r7, [pc], #-628	@ bac <build_info+0xc>
}
     ba8:	74696200 	strbtvc	r6, [r9], #-512	@ 0xfffffe00
     bac:	636f6c5f 	cmnvs	pc, #24320	@ 0x5f00
static void execute(int argc, char **argv) {
     bb0:	61765f00 	cmnvs	r6, r0, lsl #30
     bb4:	32337272 	eorscc	r7, r3, #536870919	@ 0x20000007
  for (int i = 0; table[i].command_name != NULL; i++) {
     bb8:	7469625f 	strbtvc	r6, [r9], #-607	@ 0xfffffda1
     bbc:	6f682f00 	svcvs	0x00682f00
     bc0:	652f656d 	strvs	r6, [pc, #-1389]!	@ 65b <pin_setup+0x3b>
     bc4:	2f667463 	svccs	0x00667463
     bc8:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
    if (strcmp(argv[0], table[i].command_name) == 0) {
     bcc:	6172742d 	cmnvs	r2, sp, lsr #8
     bd0:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
      __cmd_exec_status = table[i].command(argc, &argv[0]);
     bd4:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
     bd8:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
     bdc:	6c2f6c6c 	stcvs	12, cr6, [pc], #-432	@ a34 <sha256_test+0x54>
     be0:	752f6269 	strvc	r6, [pc, #-617]!	@ 97f <ecdh_test+0xc7>
     be4:	736c6974 	cmnvc	ip, #116, 18	@ 0x1d0000
    printf("\"%s\": command not found. Use \"help\" to list all command.\n",
     be8:	6974752f 	ldmdbvs	r4!, {r0, r1, r2, r3, r5, r8, sl, ip, sp, lr}^
     bec:	632e736c 			@ <UNDEFINED> instruction: 0x632e736c
    __cmd_exec_status = -1;
     bf0:	61765f00 	cmnvs	r6, r0, lsl #30
     bf4:	32337272 	eorscc	r7, r3, #536870919	@ 0x20000007
     bf8:	6f746100 	svcvs	0x00746100
}
     bfc:	74610069 	strbtvc	r0, [r1], #-105	@ 0xffffff97
     c00:	5f00686f 	svcpl	0x0000686f
     c04:	72726176 	rsbsvc	r6, r2, #-2147483619	@ 0x8000001d
     c08:	5f646165 	svcpl	0x00646165
int help(int argc, char **argv) {
     c0c:	006d656d 	rsbeq	r6, sp, sp, ror #10
  if (argc > 1 && (strcmp(argv[1], "-l")==0)) {
     c10:	5f746962 	svcpl	0x00746962
     c14:	006c6176 	rsbeq	r6, ip, r6, ror r1
     c18:	7261765f 	rsbvc	r7, r1, #99614720	@ 0x5f00000
     c1c:	00323377 	eorseq	r3, r2, r7, ror r3
    printf("use: help -l for list only.\n\n");
     c20:	5f534541 	svcpl	0x00534541
  bool verbose = true;
     c24:	74696e69 	strbtvc	r6, [r9], #-3689	@ 0xfffff197
    verbose = false;
     c28:	7874635f 	ldmdavc	r4!, {r0, r1, r2, r3, r4, r6, r8, r9, sp, lr}^
    printf("\n");
     c2c:	0076695f 	rsbseq	r6, r6, pc, asr r9
    i++;
     c30:	706d6574 	rsbvc	r6, sp, r4, ror r5
  while (table[i].command_name != NULL) {
     c34:	65740061 	ldrbvs	r0, [r4, #-97]!	@ 0xffffff9f
     c38:	7300706d 	movwvc	r7, #109	@ 0x6d
     c3c:	65726f74 	ldrbvs	r6, [r2, #-3956]!	@ 0xfffff08c
    printf(table[i].command_name);
     c40:	7478654e 	ldrbtvc	r6, [r8], #-1358	@ 0xfffffab2
    if (verbose) {
     c44:	72007649 	andvc	r7, r0, #76546048	@ 0x4900000
      printf("\n\t");
     c48:	786f6273 	stmdavc	pc!, {r0, r1, r4, r5, r6, r9, sp, lr}^	@ <UNPREDICTABLE>
      printf(table[i].command_help);
     c4c:	53454100 	movtpl	r4, #20736	@ 0x5100
     c50:	4342435f 	movtmi	r4, #9055	@ 0x235f
     c54:	636e655f 	cmnvs	lr, #398458880	@ 0x17c00000
    verbose = false;
     c58:	74707972 	ldrbtvc	r7, [r0], #-2418	@ 0xfffff68e
}
     c5c:	6675625f 			@ <UNDEFINED> instruction: 0x6675625f
     c60:	00726566 	rsbseq	r6, r2, r6, ror #10
     c64:	43766e49 	cmnmi	r6, #1168	@ 0x490
     c68:	65687069 	strbvs	r7, [r8, #-105]!	@ 0xffffff97
     c6c:	38750072 	ldmdacc	r5!, {r1, r4, r5, r6}^
     c70:	00706d74 	rsbseq	r6, r0, r4, ror sp
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
     c74:	74617473 	strbtvc	r7, [r1], #-1139	@ 0xfffffb8d
static void add_command_to_history(const char *cmd_str) {
     c78:	00745f65 	rsbseq	r5, r4, r5, ror #30
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
     c7c:	5f534541 	svcpl	0x00534541
     c80:	5f434243 	svcpl	0x00434243
  int index = total_num_commands % NUM_HISTORY_ENTRIES;
     c84:	72636564 	rsbvc	r6, r3, #100, 10	@ 0x19000000
     c88:	5f747079 	svcpl	0x00747079
     c8c:	66667562 	strbtvs	r7, [r6], -r2, ror #10
     c90:	41007265 	tstmi	r0, r5, ror #4
  memcpy(&cmd_history[index], cmd_str, LINE_BUFF_SIZE);
     c94:	6f526464 	svcvs	0x00526464
     c98:	4b646e75 	blmi	191c674 <__ROM_SIZE__+0x18dc674>
     c9c:	49007965 	stmdbmi	r0, {r0, r2, r5, r6, r8, fp, ip, sp, lr}
     ca0:	694d766e 	stmdbvs	sp, {r1, r2, r3, r5, r6, r9, sl, ip, sp, lr}^
  total_num_commands++;
     ca4:	6c6f4378 	stclvs	3, cr4, [pc], #-480	@ acc <initial_setup+0x48>
  curr_command_ptr = total_num_commands;
     ca8:	736e6d75 	cmnvc	lr, #7488	@ 0x1d40
     cac:	6f682f00 	svcvs	0x00682f00
     cb0:	652f656d 	strvs	r6, [pc, #-1389]!	@ 74b <aes_test+0x9f>
     cb4:	2f667463 	svccs	0x00667463
     cb8:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
static int parse_line(char **argv, char *line_buff, int argument_size) {
     cbc:	6172742d 	cmnvs	r2, sp, lsr #8
     cc0:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
  int length = strlen(line_buff);
     cc4:	626f662f 	rsbvs	r6, pc, #49283072	@ 0x2f00000
     cc8:	6568732f 	strbvs	r7, [r8, #-815]!	@ 0xfffffcd1
  int argc = 0;
     ccc:	6c2f6c6c 	stcvs	12, cr6, [pc], #-432	@ b24 <exec_auto_cmds+0x6>
         pos++)
     cd0:	742f6269 	strtvc	r6, [pc], #-617	@ cd8 <parse_line+0x1c>
    for (; line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
     cd4:	2d796e69 	ldclcs	14, cr6, [r9, #-420]!	@ 0xfffffe5c
     cd8:	2f736561 	svccs	0x00736561
     cdc:	2e736561 	cdpcs	5, 7, cr6, cr3, cr1, {3}
     ce0:	45410063 	strbmi	r0, [r1, #-99]	@ 0xffffff9d
    if (line_buff[pos] == '\t' || line_buff[pos] == SPACE)
     ce4:	54435f53 	strbpl	r5, [r3], #-3923	@ 0xfffff0ad
     ce8:	63785f52 	cmnvs	r8, #328	@ 0x148
      line_buff[pos] = END_OF_LINE;
     cec:	74707972 	ldrbtvc	r7, [r0], #-2418	@ 0xfffff68e
  while (pos <= length) {
     cf0:	6675625f 			@ <UNDEFINED> instruction: 0x6675625f
    if (line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
     cf4:	00726566 	rsbseq	r6, r2, r6, ror #10
     cf8:	6e756f72 	mrcvs	15, 3, r6, cr5, cr2, {3}
     cfc:	63520064 	cmpvs	r2, #100	@ 0x64
     d00:	41006e6f 	tstmi	r0, pc, ror #28
      argv[argc++] = &line_buff[pos];
     d04:	635f5345 	cmpvs	pc, #335544321	@ 0x14000001
     d08:	735f7874 	cmpvc	pc, #116, 16	@ 0x740000
}
     d0c:	695f7465 	ldmdbvs	pc, {r0, r2, r5, r6, sl, ip, sp, lr}^	@ <UNPREDICTABLE>
static int prefix_match(char *sub, int len, const char *str) {
     d10:	6e490076 	mcrvs	0, 2, r0, cr9, cr6, {3}
     d14:	69685376 	stmdbvs	r8!, {r1, r2, r4, r5, r6, r8, r9, ip, lr}^
  if (sub == NULL || str == NULL || len <= 0 || len > strlen(str)) {
     d18:	6f527466 	svcvs	0x00527466
     d1c:	78007377 	stmdavc	r0, {r0, r1, r2, r4, r5, r6, r8, r9, ip, sp, lr}
     d20:	656d6974 	strbvs	r6, [sp, #-2420]!	@ 0xfffff68c
     d24:	79654b00 	stmdbvc	r5!, {r8, r9, fp, lr}^
  for (int i = 0; i<len; ++i) {
     d28:	61707845 	cmnvs	r0, r5, asr #16
     d2c:	6f69736e 	svcvs	0x0069736e
    if (sub[i] != str[i]) {
     d30:	6e49006e 	cdpvs	0, 4, cr0, cr9, cr14, {3}
     d34:	62755376 	rsbsvs	r5, r5, #-671088639	@ 0xd8000001
  for (int i = 0; i<len; ++i) {
     d38:	65747942 	ldrbvs	r7, [r4, #-2370]!	@ 0xfffff6be
}
     d3c:	6f580073 	svcvs	0x00580073
  return TRUE;
     d40:	74695772 	strbtvc	r5, [r9], #-1906	@ 0xfffff88e
      return FALSE;
     d44:	00764968 	rsbseq	r4, r6, r8, ror #18
}
     d48:	78706d74 	ldmdavc	r0!, {r2, r4, r5, r6, r8, sl, fp, sp, lr}^
static void handle_up_arrow(char *cmd_buff, int *char_count) {
     d4c:	706d7400 	rsbvc	r7, sp, r0, lsl #8
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
     d50:	66670079 			@ <UNDEFINED> instruction: 0x66670079
     d54:	696f7032 	stmdbvs	pc!, {r1, r4, r5, ip, sp, lr}^	@ <UNPREDICTABLE>
     d58:	735f746e 	cmpvc	pc, #1845493760	@ 0x6e000000
     d5c:	7a5f7465 	bvc	17ddef8 <__ROM_SIZE__+0x179def8>
      curr_command_ptr == 0) {
     d60:	006f7265 	rsbeq	r7, pc, r5, ror #4
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
     d64:	796c6f70 	stmdbvc	ip!, {r4, r5, r6, r8, r9, sl, fp, sp, lr}^
    printf("%s", cmd_buff);
     d68:	696d6f6e 	stmdbvs	sp!, {r1, r2, r3, r5, r6, r8, r9, sl, fp, sp, lr}^
     d6c:	6e006c61 	cdpvs	12, 0, cr6, cr0, cr1, {3}
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
     d70:	64726f77 	ldrbtvs	r6, [r2], #-3959	@ 0xfffff089
     d74:	66670073 			@ <UNDEFINED> instruction: 0x66670073
  curr_command_ptr--;
     d78:	656c6532 	strbvs	r6, [ip, #-1330]!	@ 0xffffface
     d7c:	00745f6d 	rsbseq	r5, r4, sp, ror #30
     d80:	76746962 	ldrbtvc	r6, [r4], -r2, ror #18
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
     d84:	655f6365 	ldrbvs	r6, [pc, #-869]	@ a27 <sha256_test+0x47>
     d88:	6c617571 	cfstr64vs	mvdx7, [r1], #-452	@ 0xfffffe3c
     d8c:	32666700 	rsbcc	r6, r6, #0, 14
     d90:	6e696f70 	mcrvs	15, 3, r6, cr9, cr0, {3}
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
     d94:	6f645f74 	svcvs	0x00645f74
     d98:	656c6275 	strbvs	r6, [ip, #-629]!	@ 0xfffffd8b
     d9c:	32666700 	rsbcc	r6, r6, #0, 14
  *char_count = strlen(cmd_buff);
     da0:	6c656966 			@ <UNDEFINED> instruction: 0x6c656966
     da4:	6e695f64 	cdpvs	15, 6, cr5, cr9, cr4, {3}
  printf("%s", cmd_buff);
     da8:	61620063 	cmnvs	r2, r3, rrx
     dac:	6f5f6573 	svcvs	0x005f6573
     db0:	72656472 	rsbvc	r6, r5, #1912602624	@ 0x72000000
     db4:	74696200 	strbtvc	r6, [r9], #-512	@ 0xfffffe00
     db8:	5f636576 	svcpl	0x00636576
static void handle_down_arrow(char *cmd_buff, int *char_count) {
     dbc:	79706f63 	ldmdbvc	r0!, {r0, r1, r5, r6, r8, r9, sl, fp, sp, lr}^
     dc0:	74696200 	strbtvc	r6, [r9], #-512	@ 0xfffffe00
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
     dc4:	5f636576 	svcpl	0x00636576
     dc8:	7a5f7369 	bvc	17ddb74 <__ROM_SIZE__+0x179db74>
  *char_count = 0;
     dcc:	006f7265 	rsbeq	r7, pc, r5, ror #4
  if (curr_command_ptr == total_num_commands) return;
     dd0:	66326667 	ldrtvs	r6, [r2], -r7, ror #12
     dd4:	646c6569 	strbtvs	r6, [ip], #-1385	@ 0xfffffa97
     dd8:	766e695f 			@ <UNDEFINED> instruction: 0x766e695f
  curr_command_ptr++;
     ddc:	32666700 	rsbcc	r6, r6, #0, 14
     de0:	6e696f70 	mcrvs	15, 3, r6, cr9, cr0, {3}
     de4:	6e6f5f74 	mcrvs	15, 3, r5, cr15, cr4, {3}
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
     de8:	7275635f 	rsbsvc	r6, r5, #2080374785	@ 0x7c000001
     dec:	6e006576 	cfrshl64vs	mvdx0, mvdx6, r6
     df0:	73746962 	cmnvc	r4, #1605632	@ 0x188000
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
     df4:	74696200 	strbtvc	r6, [r9], #-512	@ 0xfffffe00
     df8:	5f636576 	svcpl	0x00636576
     dfc:	5f746567 	svcpl	0x00746567
     e00:	00746962 	rsbseq	r6, r4, r2, ror #18
  *char_count = strlen(cmd_buff);
     e04:	76746962 	ldrbtvc	r6, [r4], -r2, ror #18
     e08:	6c5f6365 	mrrcvs	3, 6, r6, pc, cr5	@ <UNPREDICTABLE>
  printf("%s", cmd_buff);
     e0c:	66696873 			@ <UNDEFINED> instruction: 0x66696873
     e10:	746f0074 	strbtvc	r0, [pc], #-116	@ e18 <handle_down_arrow+0x5c>
}
     e14:	73726568 	cmnvc	r2, #104, 10	@ 0x1a000000
     e18:	6275705f 	rsbsvs	r7, r5, #95	@ 0x5f
void set_read_char(int (*func)(void)) { __read_char__ = func; }
     e1c:	74696200 	strbtvc	r6, [r9], #-512	@ 0xfffffe00
     e20:	5f636576 	svcpl	0x00636576
     e24:	72676564 	rsbvc	r6, r7, #100, 10	@ 0x19000000
void set_read_char2(int (*func)(void)) { __read_char2__ = func; }
     e28:	70006565 	andvc	r6, r0, r5, ror #10
     e2c:	696c6275 	stmdbvs	ip!, {r0, r2, r4, r5, r6, r9, sp, lr}^
     e30:	656b5f63 	strbvs	r5, [fp, #-3939]!	@ 0xfffff09d
void set_write_char(void (*func)(char)) { __write_char__ = func; }
     e34:	682f0079 	stmdavs	pc!, {r0, r3, r4, r5, r6}	@ <UNPREDICTABLE>
     e38:	2f656d6f 	svccs	0x00656d6f
     e3c:	66746365 	ldrbtvs	r6, [r4], -r5, ror #6
void set_write_char2(void (*func)(char)) { __write_char2__ = func; }
     e40:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
     e44:	72742d66 	rsbsvc	r2, r4, #6528	@ 0x1980
     e48:	656e6961 	strbvs	r6, [lr, #-2401]!	@ 0xfffff69f
}
     e4c:	6f662f72 	svcvs	0x00662f72
}
     e50:	68732f62 	ldmdavs	r3!, {r1, r5, r6, r8, r9, sl, fp, sp}^
  if (cmd_buff == NULL || char_count <= 0) {
     e54:	2f6c6c65 	svccs	0x006c6c65
static void handle_tab(char *cmd_buff, int *char_count) {
     e58:	2f62696c 	svccs	0x0062696c
     e5c:	796e6974 	stmdbvc	lr!, {r2, r4, r5, r6, r8, fp, sp, lr}^
  int last_match = -1;
     e60:	6463652d 	strbtvs	r6, [r3], #-1325	@ 0xfffffad3
  int match_count = 0;
     e64:	63652f68 	cmnvs	r5, #104, 30	@ 0x1a0
  int i = 0;
     e68:	632e6864 			@ <UNDEFINED> instruction: 0x632e6864
    i++;
     e6c:	69727000 	ldmdbvs	r2!, {ip, sp, lr}^
  while (table[i].command_name != NULL) { //loop over all commands
     e70:	65746176 	ldrbvs	r6, [r4, #-374]!	@ 0xfffffe8a
     e74:	79656b5f 	stmdbvc	r5!, {r0, r1, r2, r3, r4, r6, r8, r9, fp, sp, lr}^
     e78:	32666700 	rsbcc	r6, r6, #0, 14
    if (prefix_match(cmd_buff, *char_count, table[i].command_name)) {
     e7c:	6c656966 			@ <UNDEFINED> instruction: 0x6c656966
     e80:	73695f64 	cmnvc	r9, #100, 30	@ 0x190
     e84:	656e6f5f 	strbvs	r6, [lr, #-3935]!	@ 0xfffff0a1
      match_count++;
     e88:	32666700 	rsbcc	r6, r6, #0, 14
      printf("\n%s", table[i].command_name);
     e8c:	6c656966 			@ <UNDEFINED> instruction: 0x6c656966
     e90:	64615f64 	strbtvs	r5, [r1], #-3940	@ 0xfffff09c
      last_match = i;
     e94:	66670064 	strbtvs	r0, [r7], -r4, rrx
  if (match_count == 1) {
     e98:	696f7032 	stmdbvs	pc!, {r1, r4, r5, ip, sp, lr}^	@ <UNPREDICTABLE>
     e9c:	695f746e 	ldmdbvs	pc, {r1, r2, r3, r5, r6, sl, ip, sp, lr}^	@ <UNPREDICTABLE>
  if (match_count) {
     ea0:	657a5f73 	ldrbvs	r5, [sl, #-3955]!	@ 0xfffff08d
}
     ea4:	62006f72 	andvs	r6, r0, #456	@ 0x1c8
    memcpy(cmd_buff, table[last_match].command_name, LINE_BUFF_SIZE);
     ea8:	65767469 	ldrbvs	r7, [r6, #-1129]!	@ 0xfffffb97
     eac:	77735f63 	ldrbvc	r5, [r3, -r3, ror #30]!
     eb0:	62007061 	andvs	r7, r0, #97	@ 0x61
     eb4:	65767469 	ldrbvs	r7, [r6, #-1129]!	@ 0xfffffb97
    *char_count = strlen(cmd_buff);
     eb8:	00745f63 	rsbseq	r5, r4, r3, ror #30
     ebc:	76746962 	ldrbtvc	r6, [r4], -r2, ror #18
     ec0:	735f6365 	cmpvc	pc, #-1811939327	@ 0x94000001
    printf("\n");
     ec4:	7a5f7465 	bvc	17de060 <__ROM_SIZE__+0x179e060>
     ec8:	006f7265 	rsbeq	r7, pc, r5, ror #4
    prepend_prompt();
     ecc:	66326667 	ldrtvs	r6, [r2], -r7, ror #12
    printf(PROMPT);
     ed0:	646c6569 	strbtvs	r6, [ip], #-1385	@ 0xfffffa97
     ed4:	6c756d5f 	ldclvs	13, cr6, [r5], #-380	@ 0xfffffe84
    printf("%s", cmd_buff);
     ed8:	32666700 	rsbcc	r6, r6, #0, 14
     edc:	6e696f70 	mcrvs	15, 3, r6, cr9, cr0, {3}
     ee0:	64615f74 	strbtvs	r5, [r1], #-3956	@ 0xfffff08c
     ee4:	61620064 	cmnvs	r2, r4, rrx
     ee8:	785f6573 	ldmdavc	pc, {r0, r1, r4, r5, r6, r8, sl, sp, lr}^	@ <UNPREDICTABLE>
     eec:	73616200 	cmnvc	r1, #0, 4
     ef0:	00795f65 	rsbseq	r5, r9, r5, ror #30
__attribute__((weak)) int active_prompt() { return TRUE; }
     ef4:	66326667 	ldrtvs	r6, [r2], -r7, ror #12
static void shell(void) {
     ef8:	646c6569 	strbtvs	r6, [ip], #-1385	@ 0xfffffa97
  int count = 0;
     efc:	7465735f 	strbtvc	r7, [r5], #-863	@ 0xfffffca1
  for (int i = 0; i < LINE_BUFF_SIZE; i++) line_buff[i] = 0;
     f00:	656e6f5f 	strbvs	r6, [lr, #-3935]!	@ 0xfffff0a1
     f04:	32666700 	rsbcc	r6, r6, #0, 14
     f08:	6e696f70 	mcrvs	15, 3, r6, cr9, cr0, {3}
     f0c:	6f635f74 	svcvs	0x00635f74
     f10:	63007970 	movwvs	r7, #2416	@ 0x970
  for (int i = 0; i < MAX_ARG_COUNT; i++) argv[i] = NULL;
     f14:	6666656f 	strbtvs	r6, [r6], -pc, ror #10
     f18:	6700625f 	smlsdvs	r0, pc, r2, r6	@ <UNPREDICTABLE>
     f1c:	6f703266 	svcvs	0x00703266
     f20:	5f746e69 	svcpl	0x00746e69
     f24:	006c756d 	rsbeq	r7, ip, sp, ror #10
  prepend_prompt();
     f28:	6d323375 	ldcvs	3, cr3, [r2, #-468]!	@ 0xfffffe2c
  printf(PROMPT);
     f2c:	006b7361 	rsbeq	r7, fp, r1, ror #6
  int special_key = 0;
     f30:	76746962 	ldrbtvc	r6, [r4], -r2, ror #18
        special_key = 1;
     f34:	635f6365 	cmpvs	pc, #-1811939327	@ 0x94000001
    if (s == -1) { s = __read_char2__();}
     f38:	625f726c 	subsvs	r7, pc, #108, 4	@ 0xc0000006
     f3c:	2f007469 	svccs	0x00007469
    if (s != -1) {
     f40:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
     f44:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
      loop();
     f48:	63652f66 	cmnvs	r5, #408	@ 0x198
        line_buff[count] = END_OF_LINE;
     f4c:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
     f50:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
     f54:	662f7265 	strtvs	r7, [pc], -r5, ror #4
     f58:	732f626f 			@ <UNDEFINED> instruction: 0x732f626f
        __write_char__(NEW_LINE);
     f5c:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
     f60:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
  add_command_to_history(line_buff);
     f64:	6932612f 	ldmdbvs	r2!, {r0, r1, r2, r3, r5, r8, sp, lr}
  argc = parse_line(argv, line_buff, MAX_ARG_COUNT);
     f68:	6932612f 	ldmdbvs	r2!, {r0, r1, r2, r3, r5, r8, sp, lr}
     f6c:	7200632e 	andvc	r6, r0, #-1207959552	@ 0xb8000000
     f70:	695f6e67 	ldmdbvs	pc, {r0, r1, r2, r5, r6, r9, sl, fp, sp, lr}^	@ <UNPREDICTABLE>
  if (argc > 0) execute(argc, argv);
     f74:	5f6f666e 	svcpl	0x006f666e
}
     f78:	67720074 			@ <UNDEFINED> instruction: 0x67720074
        if (!__echo) {
     f7c:	6e695f6e 	cdpvs	15, 6, cr5, cr9, cr14, {3}
     f80:	6f006f66 	svcvs	0x00006f66
        if (count == 0) continue;
     f84:	625f7475 	subsvs	r7, pc, #1962934272	@ 0x75000000
        count--;
     f88:	725f6675 	subsvc	r6, pc, #122683392	@ 0x7500000
        line_buff[count] = END_OF_LINE;
     f8c:	2f006e67 	svccs	0x00006e67
     f90:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
     f94:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
        delete ();
     f98:	63652f66 	cmnvs	r5, #408	@ 0x198
      if (__echo) {
     f9c:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
        __write_char__(c);
     fa0:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
     fa4:	662f7265 	strtvs	r7, [pc], -r5, ror #4
    if (!active_prompt()) {
     fa8:	732f626f 			@ <UNDEFINED> instruction: 0x732f626f
     fac:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
    s = __read_char__();
     fb0:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
     fb4:	6d656d2f 	stclvs	13, cr6, [r5, #-188]!	@ 0xffffff44
    if (s == -1) { s = __read_char2__();}
     fb8:	2f676f6c 	svccs	0x00676f6c
     fbc:	6c6d656d 	cfstr64vs	mvdx6, [sp], #-436	@ 0xfffffe4c
      if (c == CARRIAGE_RETURN || c == NEW_LINE) {
     fc0:	632e676f 			@ <UNDEFINED> instruction: 0x632e676f
     fc4:	6c657300 	stclvs	3, cr7, [r5], #-0
      if (c == DELETE || c == BACK_SPACE) {
     fc8:	65746365 	ldrbvs	r6, [r4, #-869]!	@ 0xfffffc9b
     fcc:	6f6d5f64 	svcvs	0x006d5f64
      } else if (c == ESCAPE) {
     fd0:	6d006564 	cfstr32vs	mvfx6, [r0, #-400]	@ 0xfffffe70
      } else if (c == SQUARE_BRACKET_OPEN && special_key == 1) {
     fd4:	6f6c6d65 	svcvs	0x006c6d65
      } else if ((c == 'C' || c == 'D') && special_key != 0) {
     fd8:	75705f67 	ldrbvc	r5, [r0, #-3943]!	@ 0xfffff099
     fdc:	63006374 	movwvs	r6, #884	@ 0x374
     fe0:	5f727275 	svcpl	0x00727275
      } else if ((c == 'A' || c == 'B') && special_key == 2) {
     fe4:	65646e69 	strbvs	r6, [r4, #-3689]!	@ 0xfffff197
     fe8:	6e690078 	mcrvs	0, 3, r0, cr9, cr8, {3}
      else if (c == TAB) {
     fec:	75625f70 	strbvc	r5, [r2, #-3952]!	@ 0xfffff090
        line_buff[count] = c;
     ff0:	67725f66 	ldrbvs	r5, [r2, -r6, ror #30]!
     ff4:	4f4e006e 	svcmi	0x004e006e
     ff8:	6d00454e 	cfstr32vs	mvfx4, [r0, #-312]	@ 0xfffffec8
        count++;
     ffc:	6f6c6d65 	svcvs	0x006c6d65
    1000:	6e695f67 	cdpvs	15, 6, cr5, cr9, cr7, {3}
          delete ();
    1004:	6d007469 	cfstrsvs	mvf7, [r0, #-420]	@ 0xfffffe5c
          delete ();
    1008:	6f6c6d65 	svcvs	0x006c6d65
      } else if (c == SQUARE_BRACKET_OPEN && special_key == 1) {
    100c:	65675f67 	strbvs	r5, [r7, #-3943]!	@ 0xfffff099
        special_key = 2;
    1010:	49006374 	stmdbmi	r0, {r2, r4, r5, r6, r8, r9, sp, lr}
      } else if ((c == 'C' || c == 'D') && special_key != 0) {
    1014:	4f5f504e 	svcmi	0x005f504e
        special_key = 0;
    1018:	6d005455 	cfstrsvs	mvf5, [r0, #-340]	@ 0xfffffeac
      } else if ((c == 'A' || c == 'B') && special_key == 2) {
    101c:	5f65646f 	svcpl	0x0065646f
        if (!__echo) {
    1020:	65640074 	strbvs	r0, [r4, #-116]!	@ 0xffffff8c
    1024:	73007473 	movwvc	r7, #1139	@ 0x473
          clear_prompt(count + 4);
    1028:	70637274 	rsbvc	r7, r3, r4, ror r2
    102c:	74730079 	ldrbtvc	r0, [r3], #-121	@ 0xffffff87
        if (c == 'A') {
    1030:	2f003172 	svccs	0x00003172
          handle_down_arrow(line_buff, &count);
    1034:	656d6f68 	strbvs	r6, [sp, #-3944]!	@ 0xfffff098
    1038:	7463652f 	strbtvc	r6, [r3], #-1327	@ 0xfffffad1
        continue;
    103c:	63652f66 	cmnvs	r5, #408	@ 0x198
          clear_prompt(count);
    1040:	742d6674 	strtvc	r6, [sp], #-1652	@ 0xfffff98c
    1044:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
          handle_up_arrow(line_buff, &count);
    1048:	662f7265 	strtvs	r7, [pc], -r5, ror #4
    104c:	732f626f 			@ <UNDEFINED> instruction: 0x732f626f
        handle_tab(line_buff, &count);
    1050:	6c6c6568 	cfstr64vs	mvdx6, [ip], #-416	@ 0xfffffe60
    1054:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
        continue;
    1058:	7274732f 	rsbsvc	r7, r4, #-1140850688	@ 0xbc000000
  if (argc > 0) execute(argc, argv);
    105c:	2f676e69 	svccs	0x00676e69
}
    1060:	69727473 	ldmdbvs	r2!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
    1064:	632e676e 			@ <UNDEFINED> instruction: 0x632e676e
    1068:	73656400 	cmnvc	r5, #0, 8
    106c:	68635f74 	stmdavs	r3!, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
void prompt() {
    1070:	73007261 	movwvc	r7, #609	@ 0x261
  initial_setup();
    1074:	635f6372 	cmpvs	pc, #-939524095	@ 0xc8000001
  exec_auto_cmds();
    1078:	00726168 	rsbseq	r6, r2, r8, ror #2

Disassembly of section .comment:

00000000 <.comment>:
   0:	3a434347 	bcc	10d0d24 <__ROM_SIZE__+0x1090d24>
   4:	72412820 	subvc	r2, r1, #32, 16	@ 0x200000
   8:	4e47206d 	cdpmi	0, 4, cr2, cr7, cr13, {3}
   c:	6f542055 	svcvs	0x00542055
  10:	68636c6f 	stmdavs	r3!, {r0, r1, r2, r3, r5, r6, sl, fp, sp, lr}^
  14:	206e6961 	rsbcs	r6, lr, r1, ror #18
  18:	322e3231 	eorcc	r3, lr, #268435459	@ 0x10000003
  1c:	41504d2e 	cmpmi	r0, lr, lsr #26
  20:	49544243 	ldmdbmi	r4, {r0, r1, r6, r9, lr}^
  24:	6c65522d 	sfmvs	f5, 2, [r5], #-180	@ 0xffffff4c
  28:	42282031 	eormi	r2, r8, #49	@ 0x31
  2c:	646c6975 	strbtvs	r6, [ip], #-2421	@ 0xfffff68b
  30:	6d726120 	ldfvse	f6, [r2, #-128]!	@ 0xffffff80
  34:	2d32312d 	ldfcss	f3, [r2, #-180]!	@ 0xffffff4c
  38:	6361706d 	cmnvs	r1, #109	@ 0x6d
  3c:	2e697462 	cdpcs	4, 6, cr7, cr9, cr2, {3}
  40:	29293433 	stmdbcs	r9!, {r0, r1, r4, r5, sl, ip, sp}
  44:	2e323120 	rsfcssp	f3, f2, f0
  48:	20312e32 	eorscs	r2, r1, r2, lsr lr
  4c:	33323032 	teqcc	r2, #50	@ 0x32
  50:	34313230 	ldrtcc	r3, [r1], #-560	@ 0xfffffdd0
	...

Disassembly of section .ARM.attributes:

00000000 <.ARM.attributes>:
   0:	00002b41 	andeq	r2, r0, r1, asr #22
   4:	61656100 	cmnvs	r5, r0, lsl #2
   8:	01006962 	tsteq	r0, r2, ror #18
   c:	00000021 	andeq	r0, r0, r1, lsr #32
  10:	2d453705 	stclcs	7, cr3, [r5, #-20]	@ 0xffffffec
  14:	0d06004d 	stceq	0, cr0, [r6, #-308]	@ 0xfffffecc
  18:	02094d07 	andeq	r4, r9, #448	@ 0x1c0
  1c:	01140412 	tsteq	r4, r2, lsl r4
  20:	03170115 	tsteq	r7, #1073741829	@ 0x40000005
  24:	011a0118 	tsteq	sl, r8, lsl r1
  28:	0122011e 			@ <UNDEFINED> instruction: 0x0122011e

Disassembly of section .debug_frame:

00000000 <.debug_frame>:
   0:	0000000c 	andeq	r0, r0, ip
   4:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
   8:	7c020001 	stcvc	0, cr0, [r2], {1}
   c:	000d0c0e 	andeq	r0, sp, lr, lsl #24
  10:	00000020 	andeq	r0, r0, r0, lsr #32
  14:	00000000 	andeq	r0, r0, r0
  18:	000003c0 	andeq	r0, r0, r0, asr #7
  1c:	00000068 	andeq	r0, r0, r8, rrx
  20:	84080e41 	strhi	r0, [r8], #-3649	@ 0xfffff1bf
  24:	41018e02 	tstmi	r1, r2, lsl #28
  28:	4701a80e 	strmi	sl, [r1, -lr, lsl #16]
  2c:	41080e0a 	tstmi	r8, sl, lsl #28
  30:	0000000b 	andeq	r0, r0, fp
  34:	00000020 	andeq	r0, r0, r0, lsr #32
  38:	00000000 	andeq	r0, r0, r0
  3c:	00000428 	andeq	r0, r0, r8, lsr #8
  40:	0000012c 	andeq	r0, r0, ip, lsr #2
  44:	84100e41 	ldrhi	r0, [r0], #-3649	@ 0xfffff1bf
  48:	86038504 	strhi	r8, [r3], -r4, lsl #10
  4c:	41018e02 	tstmi	r1, r2, lsl #28
  50:	0a56780e 	beq	159e090 <__ROM_SIZE__+0x155e090>
  54:	0b41100e 	bleq	1044094 <__ROM_SIZE__+0x1004094>
  58:	0000000c 	andeq	r0, r0, ip
  5c:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
  60:	7c020001 	stcvc	0, cr0, [r2], {1}
  64:	000d0c0e 	andeq	r0, sp, lr, lsl #24
  68:	0000000c 	andeq	r0, r0, ip
  6c:	00000058 	andeq	r0, r0, r8, asr r0
  70:	00000554 	andeq	r0, r0, r4, asr r5
  74:	00000002 	andeq	r0, r0, r2
  78:	0000000c 	andeq	r0, r0, ip
  7c:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
  80:	7c020001 	stcvc	0, cr0, [r2], {1}
  84:	000d0c0e 	andeq	r0, sp, lr, lsl #24
  88:	00000014 	andeq	r0, r0, r4, lsl r0
  8c:	00000078 	andeq	r0, r0, r8, ror r0
  90:	00000558 	andeq	r0, r0, r8, asr r5
  94:	00000024 	andeq	r0, r0, r4, lsr #32
  98:	83080e41 	movwhi	r0, #36417	@ 0x8e41
  9c:	00018e02 	andeq	r8, r1, r2, lsl #28
  a0:	0000000c 	andeq	r0, r0, ip
  a4:	00000078 	andeq	r0, r0, r8, ror r0
  a8:	0000057c 	andeq	r0, r0, ip, ror r5
  ac:	0000001c 	andeq	r0, r0, ip, lsl r0
  b0:	0000000c 	andeq	r0, r0, ip
  b4:	00000078 	andeq	r0, r0, r8, ror r0
  b8:	00000598 	muleq	r0, r8, r5
  bc:	00000024 	andeq	r0, r0, r4, lsr #32
  c0:	0000000c 	andeq	r0, r0, ip
  c4:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
  c8:	7c020001 	stcvc	0, cr0, [r2], {1}
  cc:	000d0c0e 	andeq	r0, sp, lr, lsl #24
  d0:	00000014 	andeq	r0, r0, r4, lsl r0
  d4:	000000c0 	andeq	r0, r0, r0, asr #1
  d8:	000005bc 			@ <UNDEFINED> instruction: 0x000005bc
  dc:	00000024 	andeq	r0, r0, r4, lsr #32
  e0:	83080e41 	movwhi	r0, #36417	@ 0x8e41
  e4:	00018e02 	andeq	r8, r1, r2, lsl #28
  e8:	0000000c 	andeq	r0, r0, ip
  ec:	000000c0 	andeq	r0, r0, r0, asr #1
  f0:	000005e0 	andeq	r0, r0, r0, ror #11
  f4:	0000001c 	andeq	r0, r0, ip, lsl r0
  f8:	0000000c 	andeq	r0, r0, ip
  fc:	000000c0 	andeq	r0, r0, r0, asr #1
 100:	000005fc 	strdeq	r0, [r0], -ip
 104:	00000024 	andeq	r0, r0, r4, lsr #32
 108:	0000000c 	andeq	r0, r0, ip
 10c:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 110:	7c020001 	stcvc	0, cr0, [r2], {1}
 114:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 118:	0000000c 	andeq	r0, r0, ip
 11c:	00000108 	andeq	r0, r0, r8, lsl #2
 120:	00000620 	andeq	r0, r0, r0, lsr #12
 124:	00000054 	andeq	r0, r0, r4, asr r0
 128:	00000014 	andeq	r0, r0, r4, lsl r0
 12c:	00000108 	andeq	r0, r0, r8, lsl #2
 130:	00000674 	andeq	r0, r0, r4, ror r6
 134:	00000038 	andeq	r0, r0, r8, lsr r0
 138:	83080e41 	movwhi	r0, #36417	@ 0x8e41
 13c:	00018e02 	andeq	r8, r1, r2, lsl #28
 140:	0000000c 	andeq	r0, r0, ip
 144:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 148:	7c020001 	stcvc	0, cr0, [r2], {1}
 14c:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 150:	00000020 	andeq	r0, r0, r0, lsr #32
 154:	00000140 	andeq	r0, r0, r0, asr #2
 158:	000006ac 	andeq	r0, r0, ip, lsr #13
 15c:	000000a4 	andeq	r0, r0, r4, lsr #1
 160:	84100e41 	ldrhi	r0, [r0], #-3649	@ 0xfffff1bf
 164:	86038504 	strhi	r8, [r3], -r4, lsl #10
 168:	41018e02 	tstmi	r1, r2, lsl #28
 16c:	4002580e 	andmi	r5, r2, lr, lsl #16
 170:	0000100e 	andeq	r1, r0, lr
 174:	0000000c 	andeq	r0, r0, ip
 178:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 17c:	7c020001 	stcvc	0, cr0, [r2], {1}
 180:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 184:	00000014 	andeq	r0, r0, r4, lsl r0
 188:	00000174 	andeq	r0, r0, r4, ror r1
 18c:	00000750 	andeq	r0, r0, r0, asr r7
 190:	0000002c 	andeq	r0, r0, ip, lsr #32
 194:	83080e41 	movwhi	r0, #36417	@ 0x8e41
 198:	00018e02 	andeq	r8, r1, r2, lsl #28
 19c:	00000014 	andeq	r0, r0, r4, lsl r0
 1a0:	00000174 	andeq	r0, r0, r4, ror r1
 1a4:	0000077c 	andeq	r0, r0, ip, ror r7
 1a8:	0000002c 	andeq	r0, r0, ip, lsr #32
 1ac:	83080e41 	movwhi	r0, #36417	@ 0x8e41
 1b0:	00018e02 	andeq	r8, r1, r2, lsl #28
 1b4:	0000001c 	andeq	r0, r0, ip, lsl r0
 1b8:	00000174 	andeq	r0, r0, r4, ror r1
 1bc:	000007a8 	andeq	r0, r0, r8, lsr #15
 1c0:	00000064 	andeq	r0, r0, r4, rrx
 1c4:	840c0e41 	strhi	r0, [ip], #-3649	@ 0xfffff1bf
 1c8:	8e028503 	cfsh32hi	mvfx8, mvfx2, #3
 1cc:	580e4101 	stmdapl	lr, {r0, r8, lr}
 1d0:	000c0e60 	andeq	r0, ip, r0, ror #28
 1d4:	0000000c 	andeq	r0, r0, ip
 1d8:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 1dc:	7c020001 	stcvc	0, cr0, [r2], {1}
 1e0:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 1e4:	0000001c 	andeq	r0, r0, ip, lsl r0
 1e8:	000001d4 	ldrdeq	r0, [r0], -r4
 1ec:	0000080c 	andeq	r0, r0, ip, lsl #16
 1f0:	00000050 	andeq	r0, r0, r0, asr r0
 1f4:	84080e41 	strhi	r0, [r8], #-3649	@ 0xfffff1bf
 1f8:	41018e02 	tstmi	r1, r2, lsl #28
 1fc:	5e01880e 	cdppl	8, 0, cr8, cr1, cr14, {0}
 200:	0000080e 	andeq	r0, r0, lr, lsl #16
 204:	0000001c 	andeq	r0, r0, ip, lsl r0
 208:	000001d4 	ldrdeq	r0, [r0], -r4
 20c:	0000085c 	andeq	r0, r0, ip, asr r8
 210:	0000005c 	andeq	r0, r0, ip, asr r0
 214:	84080e41 	strhi	r0, [r8], #-3649	@ 0xfffff1bf
 218:	41018e02 	tstmi	r1, r2, lsl #28
 21c:	0e64700e 	cdpeq	0, 6, cr7, cr4, cr14, {0}
 220:	00000008 	andeq	r0, r0, r8
 224:	0000000c 	andeq	r0, r0, ip
 228:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 22c:	7c020001 	stcvc	0, cr0, [r2], {1}
 230:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 234:	00000020 	andeq	r0, r0, r0, lsr #32
 238:	00000224 	andeq	r0, r0, r4, lsr #4
 23c:	000008b8 			@ <UNDEFINED> instruction: 0x000008b8
 240:	0000010c 	andeq	r0, r0, ip, lsl #2
 244:	84100e41 	ldrhi	r0, [r0], #-3649	@ 0xfffff1bf
 248:	86038504 	strhi	r8, [r3], -r4, lsl #10
 24c:	41018e02 	tstmi	r1, r2, lsl #28
 250:	0202d00e 	andeq	sp, r2, #14
 254:	00100e6d 	andseq	r0, r0, sp, ror #28
 258:	0000000c 	andeq	r0, r0, ip
 25c:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 260:	7c020001 	stcvc	0, cr0, [r2], {1}
 264:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 268:	00000014 	andeq	r0, r0, r4, lsl r0
 26c:	00000258 	andeq	r0, r0, r8, asr r2
 270:	000009c4 	andeq	r0, r0, r4, asr #19
 274:	0000001c 	andeq	r0, r0, ip, lsl r0
 278:	83080e41 	movwhi	r0, #36417	@ 0x8e41
 27c:	00018e02 	andeq	r8, r1, r2, lsl #28
 280:	0000000c 	andeq	r0, r0, ip
 284:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 288:	7c020001 	stcvc	0, cr0, [r2], {1}
 28c:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 290:	00000020 	andeq	r0, r0, r0, lsr #32
 294:	00000280 	andeq	r0, r0, r0, lsl #5
 298:	000009e0 	andeq	r0, r0, r0, ror #19
 29c:	000000a4 	andeq	r0, r0, r4, lsr #1
 2a0:	84100e41 	ldrhi	r0, [r0], #-3649	@ 0xfffff1bf
 2a4:	86038504 	strhi	r8, [r3], -r4, lsl #10
 2a8:	41018e02 	tstmi	r1, r2, lsl #28
 2ac:	0202e00e 	andeq	lr, r2, #14
 2b0:	00100e45 	andseq	r0, r0, r5, asr #28
 2b4:	0000000c 	andeq	r0, r0, ip
 2b8:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 2bc:	7c020001 	stcvc	0, cr0, [r2], {1}
 2c0:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 2c4:	00000020 	andeq	r0, r0, r0, lsr #32
 2c8:	000002b4 			@ <UNDEFINED> instruction: 0x000002b4
 2cc:	00000a84 	andeq	r0, r0, r4, lsl #21
 2d0:	0000006c 	andeq	r0, r0, ip, rrx
 2d4:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 2d8:	41018e02 	tstmi	r1, r2, lsl #28
 2dc:	0d41100e 	stcleq	0, cr1, [r1, #-56]	@ 0xffffffc8
 2e0:	080e6607 	stmdaeq	lr, {r0, r1, r2, r9, sl, sp, lr}
 2e4:	000d0d41 	andeq	r0, sp, r1, asr #26
 2e8:	00000014 	andeq	r0, r0, r4, lsl r0
 2ec:	000002b4 			@ <UNDEFINED> instruction: 0x000002b4
 2f0:	00000af0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
 2f4:	0000001c 	andeq	r0, r0, ip, lsl r0
 2f8:	84080e41 	strhi	r0, [r8], #-3649	@ 0xfffff1bf
 2fc:	00018e02 	andeq	r8, r1, r2, lsl #28
 300:	00000014 	andeq	r0, r0, r4, lsl r0
 304:	000002b4 			@ <UNDEFINED> instruction: 0x000002b4
 308:	00000b0c 	andeq	r0, r0, ip, lsl #22
 30c:	00000012 	andeq	r0, r0, r2, lsl r0
 310:	84080e41 	strhi	r0, [r8], #-3649	@ 0xfffff1bf
 314:	00018e02 	andeq	r8, r1, r2, lsl #28
 318:	00000014 	andeq	r0, r0, r4, lsl r0
 31c:	000002b4 			@ <UNDEFINED> instruction: 0x000002b4
 320:	00000b1e 	andeq	r0, r0, lr, lsl fp
 324:	00000026 	andeq	r0, r0, r6, lsr #32
 328:	84080e41 	strhi	r0, [r8], #-3649	@ 0xfffff1bf
 32c:	00018e02 	andeq	r8, r1, r2, lsl #28
 330:	00000018 	andeq	r0, r0, r8, lsl r0
 334:	000002b4 			@ <UNDEFINED> instruction: 0x000002b4
 338:	00000b44 	andeq	r0, r0, r4, asr #22
 33c:	00000040 	andeq	r0, r0, r0, asr #32
 340:	83100e41 	tsthi	r0, #1040	@ 0x410
 344:	85038404 	strhi	r8, [r3, #-1028]	@ 0xfffffbfc
 348:	00018e02 	andeq	r8, r1, r2, lsl #28
 34c:	00000014 	andeq	r0, r0, r4, lsl r0
 350:	000002b4 			@ <UNDEFINED> instruction: 0x000002b4
 354:	00000b84 	andeq	r0, r0, r4, lsl #23
 358:	0000001c 	andeq	r0, r0, ip, lsl r0
 35c:	83080e41 	movwhi	r0, #36417	@ 0x8e41
 360:	00018e02 	andeq	r8, r1, r2, lsl #28
 364:	00000014 	andeq	r0, r0, r4, lsl r0
 368:	000002b4 			@ <UNDEFINED> instruction: 0x000002b4
 36c:	00000ba0 	andeq	r0, r0, r0, lsr #23
 370:	00000010 	andeq	r0, r0, r0, lsl r0
 374:	83080e41 	movwhi	r0, #36417	@ 0x8e41
 378:	00018e02 	andeq	r8, r1, r2, lsl #28
 37c:	0000001c 	andeq	r0, r0, ip, lsl r0
 380:	000002b4 			@ <UNDEFINED> instruction: 0x000002b4
 384:	00000bb0 			@ <UNDEFINED> instruction: 0x00000bb0
 388:	0000005c 	andeq	r0, r0, ip, asr r0
 38c:	83180e42 	tsthi	r8, #1056	@ 0x420
 390:	85058406 	strhi	r8, [r5, #-1030]	@ 0xfffffbfa
 394:	88038604 	stmdahi	r3, {r2, r9, sl, pc}
 398:	00018e02 	andeq	r8, r1, r2, lsl #28
 39c:	00000018 	andeq	r0, r0, r8, lsl r0
 3a0:	000002b4 			@ <UNDEFINED> instruction: 0x000002b4
 3a4:	00000c0c 	andeq	r0, r0, ip, lsl #24
 3a8:	00000068 	andeq	r0, r0, r8, rrx
 3ac:	84100e41 	ldrhi	r0, [r0], #-3649	@ 0xfffff1bf
 3b0:	86038504 	strhi	r8, [r3], -r4, lsl #10
 3b4:	00018e02 	andeq	r8, r1, r2, lsl #28
 3b8:	00000020 	andeq	r0, r0, r0, lsr #32
 3bc:	000002b4 			@ <UNDEFINED> instruction: 0x000002b4
int finish_ecdhpair(int argc, char** argv) {
 3c0:	00000c74 	andeq	r0, r0, r4, ror ip
    if (argc == 4) {
 3c4:	00000048 	andeq	r0, r0, r8, asr #32
    else printf("Incorrect number of arguments for PAIRECDH2\n");
 3c8:	83100e42 	tsthi	r0, #1056	@ 0x420
 3cc:	85038404 	strhi	r8, [r3, #-1028]	@ 0xfffffbfc
 3d0:	5c018e02 	stcpl	14, cr8, [r1], {2}
 3d4:	c4c3000e 	strbgt	r0, [r3], #14
        decode_base64((uint8_t *)argv[3], 64, carpubkey);
 3d8:	0000cec5 	andeq	ip, r0, r5, asr #29
 3dc:	00000018 	andeq	r0, r0, r8, lsl r0
        ecdh_shared_secret(ECDH_privkey, carpubkey, ECDH_shared);
 3e0:	000002b4 			@ <UNDEFINED> instruction: 0x000002b4
 3e4:	00000cbc 			@ <UNDEFINED> instruction: 0x00000cbc
 3e8:	00000052 	andeq	r0, r0, r2, asr r0
        sha256_init(&shactx);
 3ec:	83100e41 	tsthi	r0, #1040	@ 0x410
 3f0:	85038404 	strhi	r8, [r3, #-1028]	@ 0xfffffbfc
	    sha256_update(&shactx, ECDH_shared, ECC_PUB_KEY_SIZE);
 3f4:	00018e02 	andeq	r8, r1, r2, lsl #28
 3f8:	00000020 	andeq	r0, r0, r0, lsr #32
 3fc:	000002b4 			@ <UNDEFINED> instruction: 0x000002b4
	    sha256_final(&shactx, ECDH_AESkey);
 400:	00000d0e 	andeq	r0, r0, lr, lsl #26
 404:	0000003c 	andeq	r0, r0, ip, lsr r0
        AES_init_ctx(&ctx, ECDH_AESkey);
 408:	84100e42 	ldrhi	r0, [r0], #-3650	@ 0xfffff1be
 40c:	86038504 	strhi	r8, [r3], -r4, lsl #10
 410:	5a018e02 	bpl	63c20 <__ROM_SIZE__+0x23c20>
 414:	c5c4000e 	strbgt	r0, [r4, #14]
 418:	0000cec6 	andeq	ip, r0, r6, asr #29
 41c:	00000018 	andeq	r0, r0, r8, lsl r0
 420:	000002b4 			@ <UNDEFINED> instruction: 0x000002b4
 424:	00000d4a 	andeq	r0, r0, sl, asr #26
int car_mesg(int argc, char** argv) {
 428:	00000072 	andeq	r0, r0, r2, ror r0
 42c:	83100e41 	tsthi	r0, #1040	@ 0x410
    printf("Received a message from the car:");
 430:	85038404 	strhi	r8, [r3, #-1028]	@ 0xfffffbfc
 434:	00018e02 	andeq	r8, r1, r2, lsl #28
    for (ctr = 1; ctr < argc; ctr++) {
 438:	00000018 	andeq	r0, r0, r8, lsl r0
        printf(" %s", argv[ctr]);
 43c:	000002b4 			@ <UNDEFINED> instruction: 0x000002b4
 440:	00000dbc 			@ <UNDEFINED> instruction: 0x00000dbc
    for (ctr = 1; ctr < argc; ctr++) {
 444:	00000060 	andeq	r0, r0, r0, rrx
 448:	83100e41 	tsthi	r0, #1040	@ 0x410
    printf("\n");
 44c:	85038404 	strhi	r8, [r3, #-1028]	@ 0xfffffbfc
    if (argc > 1) {
 450:	00018e02 	andeq	r8, r1, r2, lsl #28
}
 454:	0000000c 	andeq	r0, r0, ip
 458:	000002b4 			@ <UNDEFINED> instruction: 0x000002b4
        if (strcmp(argv[1], "PING_REPLY") == 0) {
 45c:	00000e1c 	andeq	r0, r0, ip, lsl lr
 460:	0000000c 	andeq	r0, r0, ip
            printf("Got a ping reply.\n");
 464:	0000000c 	andeq	r0, r0, ip
 468:	000002b4 			@ <UNDEFINED> instruction: 0x000002b4
        else if (strcmp(argv[1], "PAIRECDH2") == 0) {
 46c:	00000e28 	andeq	r0, r0, r8, lsr #28
 470:	0000000c 	andeq	r0, r0, ip
 474:	0000000c 	andeq	r0, r0, ip
            finish_ecdhpair(argc, argv);
 478:	000002b4 			@ <UNDEFINED> instruction: 0x000002b4
 47c:	00000e34 	andeq	r0, r0, r4, lsr lr
        else if (strcmp(argv[1], "AESB64") == 0) {
 480:	0000000c 	andeq	r0, r0, ip
 484:	0000000c 	andeq	r0, r0, ip
 488:	000002b4 			@ <UNDEFINED> instruction: 0x000002b4
            if (argc == 3) { 
 48c:	00000e40 	andeq	r0, r0, r0, asr #28
                printf("Missing AESB64 encoded message\n");
 490:	0000000c 	andeq	r0, r0, ip
 494:	0000000c 	andeq	r0, r0, ip
                len = decode_base64((uint8_t *) argv[2], strlen(argv[2]), decoded);
 498:	000002b4 			@ <UNDEFINED> instruction: 0x000002b4
 49c:	00000e4c 	andeq	r0, r0, ip, asr #28
 4a0:	00000002 	andeq	r0, r0, r2
 4a4:	0000000c 	andeq	r0, r0, ip
 4a8:	000002b4 			@ <UNDEFINED> instruction: 0x000002b4
                AES_ECB_decrypt(&ctx, decoded);
 4ac:	00000e4e 	andeq	r0, r0, lr, asr #28
 4b0:	00000002 	andeq	r0, r0, r2
                decoded[len] = '\0';
 4b4:	0000000c 	andeq	r0, r0, ip
 4b8:	000002b4 			@ <UNDEFINED> instruction: 0x000002b4
 4bc:	00000e50 	andeq	r0, r0, r0, asr lr
                printf("Decoded/decrypted as %s\n", decoded);
 4c0:	00000002 	andeq	r0, r0, r2
 4c4:	0000002c 	andeq	r0, r0, ip, lsr #32
 4c8:	000002b4 			@ <UNDEFINED> instruction: 0x000002b4
        else if (strcmp(argv[1], "B64") == 0) {
 4cc:	00000e52 	andeq	r0, r0, r2, asr lr
 4d0:	000000a2 	andeq	r0, r0, r2, lsr #1
            if (argc == 3) { 
 4d4:	83200e44 			@ <UNDEFINED> instruction: 0x83200e44
                printf("Missing Base64 encoded message\n");
 4d8:	85078408 	strhi	r8, [r7, #-1032]	@ 0xfffffbf8
 4dc:	88058606 	stmdahi	r5, {r1, r2, r9, sl, pc}
                printf("Decoding Base64\n");
 4e0:	8a038904 	bhi	e28f8 <__ROM_SIZE__+0xa28f8>
 4e4:	02018e02 	andeq	r8, r1, #2, 28
                len = decode_base64((uint8_t *) argv[2], strlen(argv[2]), decoded);
 4e8:	c3000e45 	movwgt	r0, #3653	@ 0xe45
 4ec:	c8c6c5c4 	stmiagt	r6, {r2, r6, r7, r8, sl, lr, pc}^
 4f0:	00cecac9 	sbceq	ip, lr, r9, asr #21
 4f4:	0000000c 	andeq	r0, r0, ip
                decoded[len] = '\0';
 4f8:	000002b4 			@ <UNDEFINED> instruction: 0x000002b4
 4fc:	00000ef4 	strdeq	r0, [r0], -r4
 500:	00000004 	andeq	r0, r0, r4
                printf("Decoded as %s", decoded);
 504:	00000020 	andeq	r0, r0, r0, lsr #32
 508:	000002b4 			@ <UNDEFINED> instruction: 0x000002b4
 50c:	00000ef8 	strdeq	r0, [r0], -r8
            printf("Didn't know how to handle %s\n", argv[1]);
 510:	00000178 	andeq	r0, r0, r8, ror r1
 514:	840c0e41 	strhi	r0, [ip], #-3649	@ 0xfffff1bf
 518:	8e028503 	cfsh32hi	mvfx8, mvfx2, #3
 51c:	980e4101 	stmdals	lr, {r0, r8, lr}
 520:	0e0a7e03 	cdpeq	14, 0, cr7, cr10, cr3, {0}
 524:	000b410c 	andeq	r4, fp, ip, lsl #2
 528:	00000014 	andeq	r0, r0, r4, lsl r0
 52c:	000002b4 			@ <UNDEFINED> instruction: 0x000002b4
 530:	00001070 	andeq	r1, r0, r0, ror r0
 534:	00000038 	andeq	r0, r0, r8, lsr r0
 538:	83080e41 	movwhi	r0, #36417	@ 0x8e41
 53c:	00018e02 	andeq	r8, r1, r2, lsl #28
 540:	0000001c 	andeq	r0, r0, ip, lsl r0
 544:	000002b4 			@ <UNDEFINED> instruction: 0x000002b4
 548:	000010a8 	andeq	r1, r0, r8, lsr #1
 54c:	0000002c 	andeq	r0, r0, ip, lsr #32
 550:	8e040e41 	cdphi	14, 0, cr0, cr4, cr1, {2}
 554:	880e4101 	stmdahi	lr, {r0, r8, lr}
void uputc(char c) {
 558:	0e0a4b02 	vmlaeq.f64	d4, d10, d2
  while ((UARTFR >> 5) & 1)
 55c:	000b4204 	andeq	r4, fp, r4, lsl #4
 560:	00000018 	andeq	r0, r0, r8, lsl r0
  UART_DR = c;
 564:	000002b4 			@ <UNDEFINED> instruction: 0x000002b4
  if (c == '\n')
 568:	000010d4 	ldrdeq	r1, [r0], -r4
}
 56c:	00000030 	andeq	r0, r0, r0, lsr r0
    uputc('\r');
 570:	84100e41 	ldrhi	r0, [r0], #-3649	@ 0xfffff1bf
}
 574:	86038504 	strhi	r8, [r3], -r4, lsl #10
 578:	00018e02 	andeq	r8, r1, r2, lsl #28
  if (!((UARTFR >> 4) & 1)) return UART_DR;
 57c:	0000000c 	andeq	r0, r0, ip
 580:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 584:	7c020001 	stcvc	0, cr0, [r2], {1}
 588:	000d0c0e 	andeq	r0, sp, lr, lsl #24
  return -1;
 58c:	0000000c 	andeq	r0, r0, ip
}
 590:	0000057c 	andeq	r0, r0, ip, ror r5
 594:	00001104 	andeq	r1, r0, r4, lsl #2
  UARTCTL = 0;
 598:	00000032 	andeq	r0, r0, r2, lsr r0
 59c:	0000000c 	andeq	r0, r0, ip
  UARTIBRD = 8;
 5a0:	0000057c 	andeq	r0, r0, ip, ror r5
  UARTFBRD = 44;
 5a4:	00001136 	andeq	r1, r0, r6, lsr r1
  UARTCC = 0;
 5a8:	0000003e 	andeq	r0, r0, lr, lsr r0
  UARTLCRH = 0x60;
 5ac:	0000000c 	andeq	r0, r0, ip
  UARTCTL = 0x301;
 5b0:	0000057c 	andeq	r0, r0, ip, ror r5
}
 5b4:	00001174 	andeq	r1, r0, r4, ror r1
 5b8:	00000014 	andeq	r0, r0, r4, lsl r0
void u2putc(char c) {
 5bc:	00000018 	andeq	r0, r0, r8, lsl r0
  while ((UART2FR >> 5) & 1)
 5c0:	0000057c 	andeq	r0, r0, ip, ror r5
 5c4:	00001188 	andeq	r1, r0, r8, lsl #3
  UART2_DR = c;
 5c8:	00000034 	andeq	r0, r0, r4, lsr r0
  if (c == '\n')
 5cc:	84100e41 	ldrhi	r0, [r0], #-3649	@ 0xfffff1bf
}
 5d0:	86038504 	strhi	r8, [r3], -r4, lsl #10
    u2putc('\r');
 5d4:	00018e02 	andeq	r8, r1, r2, lsl #28
}
 5d8:	0000001c 	andeq	r0, r0, ip, lsl r0
 5dc:	0000057c 	andeq	r0, r0, ip, ror r5
  if (!((UART2FR >> 4) & 1)) return UART2_DR;
 5e0:	000011bc 			@ <UNDEFINED> instruction: 0x000011bc
 5e4:	000000e8 	andeq	r0, r0, r8, ror #1
 5e8:	84180e42 	ldrhi	r0, [r8], #-3650	@ 0xfffff1be
 5ec:	86058506 	strhi	r8, [r5], -r6, lsl #10
  return -1;
 5f0:	88038704 	stmdahi	r3, {r2, r8, r9, sl, pc}
}
 5f4:	00018e02 	andeq	r8, r1, r2, lsl #28
 5f8:	0000001c 	andeq	r0, r0, ip, lsl r0
  UART2CTL = 0;
 5fc:	0000057c 	andeq	r0, r0, ip, ror r5
 600:	000012a4 	andeq	r1, r0, r4, lsr #5
  UART2IBRD = 8;
 604:	000000bc 	strheq	r0, [r0], -ip
  UART2FBRD = 44;
 608:	84180e42 	ldrhi	r0, [r8], #-3650	@ 0xfffff1be
  UART2CC = 0;
 60c:	86058506 	strhi	r8, [r5], -r6, lsl #10
  UART2LCRH = 0x60;
 610:	88038704 	stmdahi	r3, {r2, r8, r9, sl, pc}
  UART2CTL = 0x301;
 614:	00018e02 	andeq	r8, r1, r2, lsl #28
}
 618:	0000000c 	andeq	r0, r0, ip
 61c:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
  RCGCUART |= 3;
 620:	7c020001 	stcvc	0, cr0, [r2], {1}
 624:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 628:	0000002c 	andeq	r0, r0, ip, lsr #32
 62c:	00000618 	andeq	r0, r0, r8, lsl r6
  RCGCGPIO |= 3;
 630:	00001360 	andeq	r1, r0, r0, ror #6
 634:	00000174 	andeq	r0, r0, r4, ror r1
 638:	84240e42 	strthi	r0, [r4], #-3650	@ 0xfffff1be
  GPIODEN = 0x03;
 63c:	86088509 	strhi	r8, [r8], -r9, lsl #10
 640:	88068707 	stmdahi	r6, {r0, r1, r2, r8, r9, sl, pc}
  GPIOAFSEL = 0x03;
 644:	8a048905 	bhi	122a60 <__ROM_SIZE__+0xe2a60>
  GPIOPCTL |= 0x00000011;
 648:	8e028b03 	vmlahi.f64	d8, d2, d3
 64c:	c80e4101 	stmdagt	lr, {r0, r8, lr}
 650:	0eb20202 	cdpeq	2, 11, cr0, cr2, cr2, {0}
  GPIODEN2 = 0x03;
 654:	00000024 	andeq	r0, r0, r4, lsr #32
 658:	0000000c 	andeq	r0, r0, ip
  GPIOAFSEL2 = 0x03;
 65c:	00000618 	andeq	r0, r0, r8, lsl r6
  GPIOPCTL2 |= 0x00000011;
 660:	000014d4 	ldrdeq	r1, [r0], -r4
 664:	00000054 	andeq	r0, r0, r4, asr r0
 668:	0000001c 	andeq	r0, r0, ip, lsl r0
}
 66c:	00000618 	andeq	r0, r0, r8, lsl r6
 670:	00001528 	andeq	r1, r0, r8, lsr #10
void platform_init() {
 674:	00000040 	andeq	r0, r0, r0, asr #32
    pin_setup();
 678:	83180e41 	tsthi	r8, #1040	@ 0x410
    uart_init();
 67c:	85058406 	strhi	r8, [r5, #-1030]	@ 0xfffffbfa
    uart2_init();
 680:	87038604 	strhi	r8, [r3, -r4, lsl #12]
    set_read_char(ugetc);
 684:	00018e02 	andeq	r8, r1, r2, lsl #28
    set_read_char2(u2getc);
 688:	00000018 	andeq	r0, r0, r8, lsl r0
 68c:	00000618 	andeq	r0, r0, r8, lsl r6
    set_write_char(uputc);
 690:	00001568 	andeq	r1, r0, r8, ror #10
    set_write_char2(u2putc);
 694:	000000e6 	andeq	r0, r0, r6, ror #1
 698:	83100e41 	tsthi	r0, #1040	@ 0x410
}
 69c:	85038404 	strhi	r8, [r3, #-1028]	@ 0xfffffbfc
 6a0:	00018e02 	andeq	r8, r1, r2, lsl #28
 6a4:	0000000c 	andeq	r0, r0, ip
 6a8:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
int aes_test(int argc, char** argv) {
 6ac:	7c020001 	stcvc	0, cr0, [r2], {1}
    uint8_t text[17] = "0123456789abcdef";
 6b0:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 6b4:	00000014 	andeq	r0, r0, r4, lsl r0
 6b8:	000006a4 	andeq	r0, r0, r4, lsr #13
 6bc:	00001650 	andeq	r1, r0, r0, asr r6
 6c0:	0000001c 	andeq	r0, r0, ip, lsl r0
    printf("Plaintext is %s\n", text);
 6c4:	84080e41 	strhi	r0, [r8], #-3649	@ 0xfffff1bf
 6c8:	00018e02 	andeq	r8, r1, r2, lsl #28
    AES_ECB_encrypt(&ctx, text);
 6cc:	00000020 	andeq	r0, r0, r0, lsr #32
 6d0:	000006a4 	andeq	r0, r0, r4, lsr #13
    len = encode_base64(text, 16, b64text);
 6d4:	0000166c 	andeq	r1, r0, ip, ror #12
 6d8:	00000140 	andeq	r0, r0, r0, asr #2
 6dc:	840c0e41 	strhi	r0, [ip], #-3649	@ 0xfffff1bf
    b64text[len] = '\0';
 6e0:	8e028503 	cfsh32hi	mvfx8, mvfx2, #3
 6e4:	200e4101 	andcs	r4, lr, r1, lsl #2
 6e8:	0c0e0a60 			@ <UNDEFINED> instruction: 0x0c0e0a60
    printf("Encrypted/encoded is %s\n", b64text);
 6ec:	00000b41 	andeq	r0, r0, r1, asr #22
 6f0:	00000038 	andeq	r0, r0, r8, lsr r0
    printf2("FOB_MESG AESB64 %s\n", b64text);
 6f4:	000006a4 	andeq	r0, r0, r4, lsr #13
 6f8:	000017ac 	andeq	r1, r0, ip, lsr #15
    printf("Test the mesg handler with CAR_MESG AESB64 %s\n", b64text);
 6fc:	000000dc 	ldrdeq	r0, [r0], -ip
 700:	80100e41 	andshi	r0, r0, r1, asr #28
    len = decode_base64(b64text, len, decoded);
 704:	82038104 	andhi	r8, r3, #4, 2
 708:	41018302 	tstmi	r1, r2, lsl #6
 70c:	07841c0e 	streq	r1, [r4, lr, lsl #24]
    AES_ECB_decrypt(&ctx, decoded);
 710:	058e0685 	streq	r0, [lr, #1669]	@ 0x685
 714:	02280e41 	eoreq	r0, r8, #1040	@ 0x410
    decoded[len] = '\0';
 718:	1c0e0a61 			@ <UNDEFINED> instruction: 0x1c0e0a61
 71c:	c4c5ce42 	strbgt	ip, [r5], #3650	@ 0xe42
 720:	c341100e 	movtgt	r1, #4110	@ 0x100e
    printf("After encrypting->encoding->decoding->decrypting we recover %s\n", decoded);
 724:	0ec0c1c2 	acseqdm	f4, f2
 728:	000b4100 	andeq	r4, fp, r0, lsl #2
}
 72c:	0000000c 	andeq	r0, r0, ip
 730:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 734:	7c020001 	stcvc	0, cr0, [r2], {1}
 738:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 73c:	00000014 	andeq	r0, r0, r4, lsl r0
 740:	0000072c 	andeq	r0, r0, ip, lsr #14
 744:	00001888 	andeq	r1, r0, r8, lsl #17
 748:	0000001c 	andeq	r0, r0, ip, lsl r0
 74c:	84080e41 	strhi	r0, [r8], #-3649	@ 0xfffff1bf
int pair1(int argc, char** argv) {
 750:	00018e02 	andeq	r8, r1, r2, lsl #28
    printf("Sending a pair request.\n");
 754:	00000020 	andeq	r0, r0, r0, lsr #32
    printf2("FOB_MESG PAIR %d %d\n", fob_ID, pairing_PIN);
 758:	0000072c 	andeq	r0, r0, ip, lsr #14
 75c:	000018a4 	andeq	r1, r0, r4, lsr #17
 760:	00000140 	andeq	r0, r0, r0, asr #2
 764:	840c0e41 	strhi	r0, [ip], #-3649	@ 0xfffff1bf
}
 768:	8e028503 	cfsh32hi	mvfx8, mvfx2, #3
 76c:	200e4101 	andcs	r4, lr, r1, lsl #2
 770:	0c0e0a60 			@ <UNDEFINED> instruction: 0x0c0e0a60
 774:	00000b41 	andeq	r0, r0, r1, asr #22
 778:	00000038 	andeq	r0, r0, r8, lsr r0
int pairchall(int argc, char** argv) {
 77c:	0000072c 	andeq	r0, r0, ip, lsr #14
    printf("Sending a pair request with challenge/response.\n");
 780:	000019e4 	andeq	r1, r0, r4, ror #19
    printf2("FOB_MESG PAIRCR %d %d\n", fob_ID, pairing_PIN);
 784:	000000dc 	ldrdeq	r0, [r0], -ip
 788:	80100e41 	andshi	r0, r0, r1, asr #28
 78c:	82038104 	andhi	r8, r3, #4, 2
 790:	41018302 	tstmi	r1, r2, lsl #6
}
 794:	07841c0e 	streq	r1, [r4, lr, lsl #24]
 798:	058e0685 	streq	r0, [lr, #1669]	@ 0x685
 79c:	02280e41 	eoreq	r0, r8, #1040	@ 0x410
 7a0:	1c0e0a61 			@ <UNDEFINED> instruction: 0x1c0e0a61
 7a4:	c4c5ce42 	strbgt	ip, [r5], #3650	@ 0xe42
int pairecdh(int argc, char** argv) {
 7a8:	c341100e 	movtgt	r1, #4110	@ 0x100e
    printf("Starting EC Diffie-Hellman key exchange.\n");
 7ac:	0ec0c1c2 	acseqdm	f4, f2
 7b0:	000b4100 	andeq	r4, fp, r0, lsl #2
    decode_base64(ECDH_privkey_b64, 32, ECDH_privkey);
 7b4:	0000000c 	andeq	r0, r0, ip
 7b8:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 7bc:	7c020001 	stcvc	0, cr0, [r2], {1}
    ecdh_generate_keys(ECDH_pubkey, ECDH_privkey);
 7c0:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 7c4:	00000014 	andeq	r0, r0, r4, lsl r0
    encode_base64(ECDH_pubkey, ECC_PUB_KEY_SIZE, pubkey_b64);
 7c8:	000007b4 			@ <UNDEFINED> instruction: 0x000007b4
 7cc:	00001ac0 	andeq	r1, r0, r0, asr #21
 7d0:	00000030 	andeq	r0, r0, r0, lsr r0
    pubkey_b64[64] = '\0';
 7d4:	83080e41 	movwhi	r0, #36417	@ 0x8e41
    printf2("FOB_MESG PAIRECDH %d %d %s\n", fob_ID, pairing_PIN, pubkey_b64);
 7d8:	00018e02 	andeq	r8, r1, r2, lsl #28
 7dc:	00000018 	andeq	r0, r0, r8, lsl r0
 7e0:	000007b4 			@ <UNDEFINED> instruction: 0x000007b4
 7e4:	00001af0 	strdeq	r1, [r0], -r0
}
 7e8:	00000030 	andeq	r0, r0, r0, lsr r0
 7ec:	83100e41 	tsthi	r0, #1040	@ 0x410
 7f0:	85038404 	strhi	r8, [r3, #-1028]	@ 0xfffffbfc
 7f4:	00018e02 	andeq	r8, r1, r2, lsl #28
 7f8:	00000018 	andeq	r0, r0, r8, lsl r0
 7fc:	000007b4 			@ <UNDEFINED> instruction: 0x000007b4
 800:	00001b20 	andeq	r1, r0, r0, lsr #22
 804:	00000048 	andeq	r0, r0, r8, asr #32
 808:	84100e41 	ldrhi	r0, [r0], #-3649	@ 0xfffff1bf
int encode64(int argc, char** argv) {
 80c:	86038504 	strhi	r8, [r3], -r4, lsl #10
    if (argc > 1) {
 810:	00018e02 	andeq	r8, r1, r2, lsl #28
 814:	00000018 	andeq	r0, r0, r8, lsl r0
        len = strlen(argv[1]);
 818:	000007b4 			@ <UNDEFINED> instruction: 0x000007b4
 81c:	00001b68 	andeq	r1, r0, r8, ror #22
        if (len < MAXARRAYLEN) {
 820:	00000068 	andeq	r0, r0, r8, rrx
            len = encode_base64((uint8_t *) argv[1], len, encoded);
 824:	84100e41 	ldrhi	r0, [r0], #-3649	@ 0xfffff1bf
 828:	86038504 	strhi	r8, [r3], -r4, lsl #10
            printf("Encoded %s as %s with %d characters\n", argv[1], encoded, len);
 82c:	00018e02 	andeq	r8, r1, r2, lsl #28
 830:	00000018 	andeq	r0, r0, r8, lsl r0
 834:	000007b4 			@ <UNDEFINED> instruction: 0x000007b4
            printf("String exceeds max length of %d characters", MAXARRAYLEN);
 838:	00001bd0 	ldrdeq	r1, [r0], -r0
 83c:	00000050 	andeq	r0, r0, r0, asr r0
 840:	83100e41 	tsthi	r0, #1040	@ 0x410
        printf("Usage is 'encode64 string'\n");
 844:	85038404 	strhi	r8, [r3, #-1028]	@ 0xfffffbfc
}
 848:	00018e02 	andeq	r8, r1, r2, lsl #28
 84c:	0000000c 	andeq	r0, r0, ip
 850:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 854:	7c020001 	stcvc	0, cr0, [r2], {1}
 858:	000d0c0e 	andeq	r0, sp, lr, lsl #24
int decode64(int argc, char** argv) {
 85c:	0000001c 	andeq	r0, r0, ip, lsl r0
    if (argc > 1) {
 860:	0000084c 	andeq	r0, r0, ip, asr #16
 864:	00001c20 	andeq	r1, r0, r0, lsr #24
        int len = strlen(argv[1]);
 868:	00000120 	andeq	r0, r0, r0, lsr #2
 86c:	840c0e41 	strhi	r0, [ip], #-3649	@ 0xfffff1bf
        if (len < MAXBASE64LEN) {
 870:	8e028503 	cfsh32hi	mvfx8, mvfx2, #3
                len = decode_base64((uint8_t *) argv[1], len, plaintext);
 874:	180e4101 	stmdane	lr, {r0, r8, lr}
 878:	0c0e8a02 			@ <UNDEFINED> instruction: 0x0c0e8a02
                plaintext[len] = '\0';
 87c:	00000018 	andeq	r0, r0, r8, lsl r0
 880:	0000084c 	andeq	r0, r0, ip, asr #16
 884:	00001d40 	andeq	r1, r0, r0, asr #26
                printf("Decoded %s as: %s\n", argv[1], plaintext);
 888:	00000038 	andeq	r0, r0, r8, lsr r0
 88c:	840c0e41 	strhi	r0, [ip], #-3649	@ 0xfffff1bf
 890:	8e028503 	cfsh32hi	mvfx8, mvfx2, #3
            printf("String exceeds max base64 string length of %d characters", MAXBASE64LEN);
 894:	00000001 	andeq	r0, r0, r1
 898:	00000018 	andeq	r0, r0, r8, lsl r0
 89c:	0000084c 	andeq	r0, r0, ip, asr #16
        printf("Usage is 'decode64 string'\n");
 8a0:	00001d78 	andeq	r1, r0, r8, ror sp
}
 8a4:	00000044 	andeq	r0, r0, r4, asr #32
 8a8:	84040e47 	strhi	r0, [r4], #-3655	@ 0xfffff1b9
 8ac:	0ec45401 	cdpeq	4, 12, cr5, cr4, cr1, {0}
 8b0:	00000000 	andeq	r0, r0, r0
 8b4:	0000000c 	andeq	r0, r0, ip
int ecdh_test(int argc, char** argv) {
 8b8:	0000084c 	andeq	r0, r0, ip, asr #16
    uint8_t b64privkey2[32] = "wP/uwP/uwP/uwP/uwP/uwP/uwP/uwP/u";
 8bc:	00001dbc 			@ <UNDEFINED> instruction: 0x00001dbc
 8c0:	00000032 	andeq	r0, r0, r2, lsr r0
 8c4:	0000000c 	andeq	r0, r0, ip
 8c8:	0000084c 	andeq	r0, r0, ip, asr #16
 8cc:	00001dee 	andeq	r1, r0, lr, ror #27
    printf("Testing the ecdh key exchange\n");
 8d0:	00000012 	andeq	r0, r0, r2, lsl r0
 8d4:	00000024 	andeq	r0, r0, r4, lsr #32
    decode_base64(ECDH_privkey_b64, 32, ECDH_privkey);
 8d8:	0000084c 	andeq	r0, r0, ip, asr #16
 8dc:	00001e00 	andeq	r1, r0, r0, lsl #28
 8e0:	00000076 	andeq	r0, r0, r6, ror r0
    decode_base64(b64privkey2, 32, privkey2);
 8e4:	83280e42 			@ <UNDEFINED> instruction: 0x83280e42
 8e8:	8509840a 	strhi	r8, [r9, #-1034]	@ 0xfffffbf6
    ecdh_generate_keys(ECDH_pubkey, ECDH_privkey);
 8ec:	87078608 	strhi	r8, [r7, -r8, lsl #12]
 8f0:	89058806 	stmdbhi	r5, {r1, r2, fp, pc}
 8f4:	8b038a04 	blhi	e310c <__ROM_SIZE__+0xa310c>
    ecdh_generate_keys(pubkey2, privkey2);
 8f8:	00018e02 	andeq	r8, r1, r2, lsl #28
 8fc:	00000028 	andeq	r0, r0, r8, lsr #32
    ecdh_shared_secret(ECDH_privkey, pubkey2, ECDH_shared);
 900:	0000084c 	andeq	r0, r0, ip, asr #16
 904:	00001e76 	andeq	r1, r0, r6, ror lr
 908:	0000015a 	andeq	r0, r0, sl, asr r1
    ecdh_shared_secret(privkey2, ECDH_pubkey, sharedsecret2);
 90c:	84240e42 	strthi	r0, [r4], #-3650	@ 0xfffff1be
 910:	86088509 	strhi	r8, [r8], -r9, lsl #10
    sha256_init(&shactx);
 914:	88068707 	stmdahi	r6, {r0, r1, r2, r8, r9, sl, pc}
 918:	8a048905 	bhi	122d34 <__ROM_SIZE__+0xe2d34>
	sha256_update(&shactx, ECDH_shared, ECC_PUB_KEY_SIZE);
 91c:	8e028b03 	vmlahi.f64	d8, d2, d3
 920:	500e4101 	andpl	r4, lr, r1, lsl #2
	sha256_final(&shactx, ECDH_AESkey);
 924:	240ea802 	strcs	sl, [lr], #-2050	@ 0xfffff7fe
 928:	00000018 	andeq	r0, r0, r8, lsl r0
 92c:	0000084c 	andeq	r0, r0, ip, asr #16
    len = encode_base64(ECDH_AESkey, AES_KEYLEN, b64test);
 930:	00001fd0 	ldrdeq	r1, [r0], -r0
 934:	00000048 	andeq	r0, r0, r8, asr #32
    b64test[len] = '\0';
 938:	8e040e47 	cdphi	14, 0, cr0, cr4, cr7, {2}
 93c:	000e5601 	andeq	r5, lr, r1, lsl #12
 940:	000000ce 	andeq	r0, r0, lr, asr #1
 944:	0000000c 	andeq	r0, r0, ip
    printf("First shared key is %s\n", b64test);
 948:	0000084c 	andeq	r0, r0, ip, asr #16
 94c:	00002018 	andeq	r2, r0, r8, lsl r0
    sha256_init(&shactx);
 950:	00000032 	andeq	r0, r0, r2, lsr r0
    sha256_update(&shactx, sharedsecret2, ECC_PUB_KEY_SIZE);
 954:	00000018 	andeq	r0, r0, r8, lsl r0
 958:	0000084c 	andeq	r0, r0, ip, asr #16
 95c:	0000204a 	andeq	r2, r0, sl, asr #32
	sha256_final(&shactx, keytest);
 960:	00000044 	andeq	r0, r0, r4, asr #32
 964:	84100e41 	ldrhi	r0, [r0], #-3649	@ 0xfffff1bf
    len = encode_base64(keytest, AES_KEYLEN, b64test);
 968:	86038504 	strhi	r8, [r3], -r4, lsl #10
 96c:	00018e02 	andeq	r8, r1, r2, lsl #28
    b64test[len] = '\0';
 970:	00000018 	andeq	r0, r0, r8, lsl r0
 974:	0000084c 	andeq	r0, r0, ip, asr #16
 978:	0000208e 	andeq	r2, r0, lr, lsl #1
    printf("Should be same as %s\n", b64test);
 97c:	0000003a 	andeq	r0, r0, sl, lsr r0
 980:	84100e41 	ldrhi	r0, [r0], #-3649	@ 0xfffff1bf
    printf("Switching fob AES key to new value. Try AES tests now.\n");
 984:	86038504 	strhi	r8, [r3], -r4, lsl #10
 988:	00018e02 	andeq	r8, r1, r2, lsl #28
    AES_init_ctx(&ctx, ECDH_AESkey);
 98c:	0000000c 	andeq	r0, r0, ip
 990:	0000084c 	andeq	r0, r0, ip, asr #16
}
 994:	000020c8 	andeq	r2, r0, r8, asr #1
 998:	0000001a 	andeq	r0, r0, sl, lsl r0
 99c:	00000014 	andeq	r0, r0, r4, lsl r0
 9a0:	0000084c 	andeq	r0, r0, ip, asr #16
 9a4:	000020e2 	andeq	r2, r0, r2, ror #1
 9a8:	00000008 	andeq	r0, r0, r8
 9ac:	83080e41 	movwhi	r0, #36417	@ 0x8e41
 9b0:	00018e02 	andeq	r8, r1, r2, lsl #28
 9b4:	00000018 	andeq	r0, r0, r8, lsl r0
 9b8:	0000084c 	andeq	r0, r0, ip, asr #16
 9bc:	000020ea 	andeq	r2, r0, sl, ror #1
 9c0:	00000018 	andeq	r0, r0, r8, lsl r0
int send_ping(int argc, char** argv) {
 9c4:	83100e41 	tsthi	r0, #1040	@ 0x410
    printf("Pinging the car.\n");
 9c8:	85038404 	strhi	r8, [r3, #-1028]	@ 0xfffffbfc
    printf2("FOB_MESG PING\n");
 9cc:	00018e02 	andeq	r8, r1, r2, lsl #28
 9d0:	00000014 	andeq	r0, r0, r4, lsl r0
}
 9d4:	0000084c 	andeq	r0, r0, ip, asr #16
 9d8:	00002102 	andeq	r2, r0, r2, lsl #2
 9dc:	0000000c 	andeq	r0, r0, ip
int sha256_test(int argc, char** argv) {
 9e0:	83080e41 	movwhi	r0, #36417	@ 0x8e41
    printf("Starting sha256 test\n");
 9e4:	00018e02 	andeq	r8, r1, r2, lsl #28
 9e8:	00000014 	andeq	r0, r0, r4, lsl r0
    BYTE text1[] = {"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"};
 9ec:	0000084c 	andeq	r0, r0, ip, asr #16
 9f0:	0000210e 	andeq	r2, r0, lr, lsl #2
 9f4:	0000000e 	andeq	r0, r0, lr
 9f8:	83080e41 	movwhi	r0, #36417	@ 0x8e41
 9fc:	00018e02 	andeq	r8, r1, r2, lsl #28
 a00:	00000014 	andeq	r0, r0, r4, lsl r0
 a04:	0000084c 	andeq	r0, r0, ip, asr #16
 a08:	0000211c 	andeq	r2, r0, ip, lsl r1
 a0c:	0000000e 	andeq	r0, r0, lr
    BYTE hash1[SHA256_BLOCK_SIZE] = {0x24,0x8d,0x6a,0x61,0xd2,0x06,0x38,0xb8,0xe5,0xc0,0x26,0x93,0x0c,0x3e,0x60,0x39,
 a10:	83080e41 	movwhi	r0, #36417	@ 0x8e41
 a14:	00018e02 	andeq	r8, r1, r2, lsl #28
 a18:	0000001c 	andeq	r0, r0, ip, lsl r0
 a1c:	0000084c 	andeq	r0, r0, ip, asr #16
    sha256_init(&shactx);
 a20:	0000212a 	andeq	r2, r0, sl, lsr #2
	sha256_update(&shactx, text1, strlen((char *)text1));
 a24:	00000038 	andeq	r0, r0, r8, lsr r0
 a28:	84180e42 	ldrhi	r0, [r8], #-3650	@ 0xfffff1be
 a2c:	86058506 	strhi	r8, [r5], -r6, lsl #10
 a30:	88038704 	stmdahi	r3, {r2, r8, r9, sl, pc}
	sha256_final(&shactx, buf);
 a34:	00018e02 	andeq	r8, r1, r2, lsl #28
 a38:	00000024 	andeq	r0, r0, r4, lsr #32
    len = encode_base64(hash1, SHA256_BLOCK_SIZE, b64_hash1);
 a3c:	0000084c 	andeq	r0, r0, ip, asr #16
 a40:	00002162 	andeq	r2, r0, r2, ror #2
 a44:	00000046 	andeq	r0, r0, r6, asr #32
    b64_hash1[len] = '\0';
 a48:	84180e42 	ldrhi	r0, [r8], #-3650	@ 0xfffff1be
    len = encode_base64(buf, SHA256_BLOCK_SIZE, b64_buf);
 a4c:	86058506 	strhi	r8, [r5], -r6, lsl #10
 a50:	88038704 	stmdahi	r3, {r2, r8, r9, sl, pc}
 a54:	41018e02 	tstmi	r1, r2, lsl #28
    b64_buf[len] = '\0';
 a58:	0e5e280e 	cdpeq	8, 5, cr2, cr14, cr14, {0}
    printf("Base64 of SHA-256 test is %s\n", b64_buf);
 a5c:	00000018 	andeq	r0, r0, r8, lsl r0
 a60:	00000020 	andeq	r0, r0, r0, lsr #32
    printf("Should be %s\n", b64_hash1);
 a64:	0000084c 	andeq	r0, r0, ip, asr #16
 a68:	000021a8 	andeq	r2, r0, r8, lsr #3
}
 a6c:	00000074 	andeq	r0, r0, r4, ror r0
 a70:	84140e41 	ldrhi	r0, [r4], #-3649	@ 0xfffff1bf
 a74:	86048505 	strhi	r8, [r4], -r5, lsl #10
 a78:	8e028703 	cdphi	7, 0, cr8, cr2, cr3, {0}
 a7c:	280e4101 	stmdacs	lr, {r0, r8, lr}
 a80:	00140e77 	andseq	r0, r4, r7, ror lr
void __attribute__((optimize("O0"), weak)) initial_setup(void) {
 a84:	0000000c 	andeq	r0, r0, ip
 a88:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
  char *src = &_etext, *dst = &_data;
 a8c:	7c020001 	stcvc	0, cr0, [r2], {1}
 a90:	000d0c0e 	andeq	r0, sp, lr, lsl #24
  if (dst != src)
 a94:	0000000c 	andeq	r0, r0, ip
 a98:	00000a84 	andeq	r0, r0, r4, lsl #21
    while (dst < &_edata) *(dst++) = *(src++);
 a9c:	0000221c 	andeq	r2, r0, ip, lsl r2
 aa0:	00000012 	andeq	r0, r0, r2, lsl r0
 aa4:	0000000c 	andeq	r0, r0, ip
 aa8:	00000a84 	andeq	r0, r0, r4, lsl #21
 aac:	0000222e 	andeq	r2, r0, lr, lsr #4
 ab0:	0000001a 	andeq	r0, r0, sl, lsl r0
  for (dst = &_bss; dst < &_ebss; dst++) *dst = 0;
 ab4:	0000000c 	andeq	r0, r0, ip
 ab8:	00000a84 	andeq	r0, r0, r4, lsl #21
 abc:	00002248 	andeq	r2, r0, r8, asr #4
 ac0:	00000014 	andeq	r0, r0, r4, lsl r0
 ac4:	0000001c 	andeq	r0, r0, ip, lsl r0
 ac8:	00000a84 	andeq	r0, r0, r4, lsl #21
 acc:	0000225c 	andeq	r2, r0, ip, asr r2
  platform_init();
 ad0:	00000024 	andeq	r0, r0, r4, lsr #32
}
 ad4:	840c0e41 	strhi	r0, [ip], #-3649	@ 0xfffff1bf
 ad8:	8e028503 	cfsh32hi	mvfx8, mvfx2, #3
 adc:	280e4101 	stmdacs	lr, {r0, r8, lr}
 ae0:	000c0e4f 	andeq	r0, ip, pc, asr #28
 ae4:	0000000c 	andeq	r0, r0, ip
 ae8:	00000a84 	andeq	r0, r0, r4, lsl #21
 aec:	00002280 	andeq	r2, r0, r0, lsl #5
static void delete(void) {
 af0:	0000001e 	andeq	r0, r0, lr, lsl r0
  __write_char__(BACK_SPACE);
 af4:	0000000c 	andeq	r0, r0, ip
 af8:	00000a84 	andeq	r0, r0, r4, lsl #21
  __write_char__(SPACE);
 afc:	0000229e 	muleq	r0, lr, r2
  __write_char__(BACK_SPACE);
 b00:	00000012 	andeq	r0, r0, r2, lsl r0
 b04:	0000000c 	andeq	r0, r0, ip
}
 b08:	00000a84 	andeq	r0, r0, r4, lsl #21
static void clear_prompt(int char_count) {
 b0c:	000022b0 			@ <UNDEFINED> instruction: 0x000022b0
  while (char_count) {
 b10:	0000001a 	andeq	r0, r0, sl, lsl r0
    delete ();
 b14:	0000000c 	andeq	r0, r0, ip
  while (char_count) {
 b18:	00000a84 	andeq	r0, r0, r4, lsl #21
}
 b1c:	000022ca 	andeq	r2, r0, sl, asr #5
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
 b20:	0000002a 	andeq	r0, r0, sl, lsr #32
    auto_load[i].command(0, NULL);
 b24:	00000018 	andeq	r0, r0, r8, lsl r0
 b28:	00000a84 	andeq	r0, r0, r4, lsl #21
  for (int i = 0; auto_load[i].command_name != NULL; i++) {
 b2c:	000022f4 	strdeq	r2, [r0], -r4
 b30:	00000074 	andeq	r0, r0, r4, ror r0
 b34:	84040e41 	strhi	r0, [r4], #-3649	@ 0xfffff1bf
 b38:	c40a6001 	strgt	r6, [sl], #-1
 b3c:	0b41000e 	bleq	1040b7c <__ROM_SIZE__+0x1000b7c>
}
 b40:	0000000c 	andeq	r0, r0, ip
static int show_history(int argc, char **argv) {
 b44:	00000a84 	andeq	r0, r0, r4, lsl #21
  uint32_t end_index = total_num_commands-1;
 b48:	00002368 	andeq	r2, r0, r8, ror #6
  if (total_num_commands > NUM_HISTORY_ENTRIES) {
 b4c:	00000014 	andeq	r0, r0, r4, lsl r0
 b50:	0000000c 	andeq	r0, r0, ip
    beg_index = total_num_commands - NUM_HISTORY_ENTRIES;
 b54:	00000a84 	andeq	r0, r0, r4, lsl #21
 b58:	0000237c 	andeq	r2, r0, ip, ror r3
  uint32_t beg_index = 0;
 b5c:	00000022 	andeq	r0, r0, r2, lsr #32
    printf("%s\n", cmd_history[index % NUM_HISTORY_ENTRIES]);
 b60:	00000018 	andeq	r0, r0, r8, lsl r0
 b64:	00000a84 	andeq	r0, r0, r4, lsl #21
 b68:	0000239e 	muleq	r0, lr, r3
 b6c:	00000022 	andeq	r0, r0, r2, lsr #32
  for (uint32_t index = beg_index; index <= end_index; ++index) {
 b70:	84080e44 	strhi	r0, [r8], #-3652	@ 0xfffff1bc
}
 b74:	4b018502 	blmi	61f84 <__ROM_SIZE__+0x21f84>
 b78:	000ec4c5 	andeq	ip, lr, r5, asr #9
 b7c:	0000000c 	andeq	r0, r0, ip
 b80:	00000a84 	andeq	r0, r0, r4, lsl #21
int cmd_exec_status(int argc, char **argv) {
 b84:	000023c0 	andeq	r2, r0, r0, asr #7
  printf("%d\n", __cmd_exec_status);
 b88:	0000000a 	andeq	r0, r0, sl
 b8c:	00000020 	andeq	r0, r0, r0, lsr #32
 b90:	00000a84 	andeq	r0, r0, r4, lsl #21
}
 b94:	000023ca 	andeq	r2, r0, sl, asr #7
 b98:	00000076 	andeq	r0, r0, r6, ror r0
 b9c:	84100e41 	ldrhi	r0, [r0], #-3649	@ 0xfffff1bf
static int build_info(int argc, char **argv) {
 ba0:	86038504 	strhi	r8, [r3], -r4, lsl #10
  printf("Build: [" SHELL_VERSION ":" USER_REPO_VERSION "] - [" BUILD_USER
 ba4:	41018e02 	tstmi	r1, r2, lsl #28
}
 ba8:	0e76280e 	cdpeq	8, 7, cr2, cr6, cr14, {0}
 bac:	00000010 	andeq	r0, r0, r0, lsl r0
static void execute(int argc, char **argv) {
 bb0:	00000020 	andeq	r0, r0, r0, lsr #32
 bb4:	00000a84 	andeq	r0, r0, r4, lsl #21
  for (int i = 0; table[i].command_name != NULL; i++) {
 bb8:	00002440 	andeq	r2, r0, r0, asr #8
 bbc:	00000084 	andeq	r0, r0, r4, lsl #1
 bc0:	84140e41 	ldrhi	r0, [r4], #-3649	@ 0xfffff1bf
 bc4:	86048505 	strhi	r8, [r4], -r5, lsl #10
 bc8:	8e028703 	cdphi	7, 0, cr8, cr2, cr3, {0}
    if (strcmp(argv[0], table[i].command_name) == 0) {
 bcc:	780e4101 	stmdavc	lr, {r0, r8, lr}
 bd0:	00140e7c 	andseq	r0, r4, ip, ror lr
      __cmd_exec_status = table[i].command(argc, &argv[0]);
 bd4:	00000018 	andeq	r0, r0, r8, lsl r0
 bd8:	00000a84 	andeq	r0, r0, r4, lsl #21
 bdc:	000024c4 	andeq	r2, r0, r4, asr #9
 be0:	00000016 	andeq	r0, r0, r6, lsl r0
 be4:	83100e41 	tsthi	r0, #1040	@ 0x410
    printf("\"%s\": command not found. Use \"help\" to list all command.\n",
 be8:	85038404 	strhi	r8, [r3, #-1028]	@ 0xfffffbfc
 bec:	00018e02 	andeq	r8, r1, r2, lsl #28
    __cmd_exec_status = -1;
 bf0:	00000014 	andeq	r0, r0, r4, lsl r0
 bf4:	00000a84 	andeq	r0, r0, r4, lsl #21
 bf8:	000024da 	ldrdeq	r2, [r0], -sl
}
 bfc:	00000010 	andeq	r0, r0, r0, lsl r0
 c00:	84080e41 	strhi	r0, [r8], #-3649	@ 0xfffff1bf
 c04:	00018e02 	andeq	r8, r1, r2, lsl #28
 c08:	00000014 	andeq	r0, r0, r4, lsl r0
int help(int argc, char **argv) {
 c0c:	00000a84 	andeq	r0, r0, r4, lsl #21
  if (argc > 1 && (strcmp(argv[1], "-l")==0)) {
 c10:	000024ea 	andeq	r2, r0, sl, ror #9
 c14:	00000016 	andeq	r0, r0, r6, lsl r0
 c18:	84080e41 	strhi	r0, [r8], #-3649	@ 0xfffff1bf
 c1c:	00018e02 	andeq	r8, r1, r2, lsl #28
    printf("use: help -l for list only.\n\n");
 c20:	00000020 	andeq	r0, r0, r0, lsr #32
  bool verbose = true;
 c24:	00000a84 	andeq	r0, r0, r4, lsl #21
    verbose = false;
 c28:	00002500 	andeq	r2, r0, r0, lsl #10
    printf("\n");
 c2c:	0000006e 	andeq	r0, r0, lr, rrx
    i++;
 c30:	840c0e41 	strhi	r0, [ip], #-3649	@ 0xfffff1bf
  while (table[i].command_name != NULL) {
 c34:	8e028503 	cfsh32hi	mvfx8, mvfx2, #3
 c38:	280e4101 	stmdacs	lr, {r0, r8, lr}
 c3c:	0c0e0a49 			@ <UNDEFINED> instruction: 0x0c0e0a49
    printf(table[i].command_name);
 c40:	00000b41 	andeq	r0, r0, r1, asr #22
    if (verbose) {
 c44:	00000024 	andeq	r0, r0, r4, lsr #32
      printf("\n\t");
 c48:	00000a84 	andeq	r0, r0, r4, lsl #21
      printf(table[i].command_help);
 c4c:	0000256e 	andeq	r2, r0, lr, ror #10
 c50:	000000d4 	ldrdeq	r0, [r0], -r4
 c54:	84140e41 	ldrhi	r0, [r4], #-3649	@ 0xfffff1bf
    verbose = false;
 c58:	86048505 	strhi	r8, [r4], -r5, lsl #10
}
 c5c:	8e028703 	cdphi	7, 0, cr8, cr2, cr3, {0}
 c60:	780e4101 	stmdavc	lr, {r0, r8, lr}
 c64:	140e0a64 	strne	r0, [lr], #-2660	@ 0xfffff59c
 c68:	00000b41 	andeq	r0, r0, r1, asr #22
 c6c:	00000020 	andeq	r0, r0, r0, lsr #32
 c70:	00000a84 	andeq	r0, r0, r4, lsl #21
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
 c74:	00002642 	andeq	r2, r0, r2, asr #12
static void add_command_to_history(const char *cmd_str) {
 c78:	00000056 	andeq	r0, r0, r6, asr r0
  if (cmd_str == NULL || strcmp(cmd_str, "") == 0) {
 c7c:	84140e41 	ldrhi	r0, [r4], #-3649	@ 0xfffff1bf
 c80:	86048505 	strhi	r8, [r4], -r5, lsl #10
  int index = total_num_commands % NUM_HISTORY_ENTRIES;
 c84:	8e028703 	cdphi	7, 0, cr8, cr2, cr3, {0}
 c88:	480e4101 	stmdami	lr, {r0, r8, lr}
 c8c:	00140e68 	andseq	r0, r4, r8, ror #28
 c90:	00000020 	andeq	r0, r0, r0, lsr #32
  memcpy(&cmd_history[index], cmd_str, LINE_BUFF_SIZE);
 c94:	00000a84 	andeq	r0, r0, r4, lsl #21
 c98:	00002698 	muleq	r0, r8, r6
 c9c:	00000068 	andeq	r0, r0, r8, rrx
 ca0:	840c0e41 	strhi	r0, [ip], #-3649	@ 0xfffff1bf
  total_num_commands++;
 ca4:	8e028503 	cfsh32hi	mvfx8, mvfx2, #3
  curr_command_ptr = total_num_commands;
 ca8:	400e4101 	andmi	r4, lr, r1, lsl #2
 cac:	0c0e0a47 			@ <UNDEFINED> instruction: 0x0c0e0a47
 cb0:	00000b41 	andeq	r0, r0, r1, asr #22
 cb4:	0000001c 	andeq	r0, r0, ip, lsl r0
 cb8:	00000a84 	andeq	r0, r0, r4, lsl #21
static int parse_line(char **argv, char *line_buff, int argument_size) {
 cbc:	00002700 	andeq	r2, r0, r0, lsl #14
 cc0:	00000054 	andeq	r0, r0, r4, asr r0
  int length = strlen(line_buff);
 cc4:	83180e41 	tsthi	r8, #1040	@ 0x410
 cc8:	85058406 	strhi	r8, [r5, #-1030]	@ 0xfffffbfa
  int argc = 0;
 ccc:	87038604 	strhi	r8, [r3, -r4, lsl #12]
         pos++)
 cd0:	00018e02 	andeq	r8, r1, r2, lsl #28
    for (; line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
 cd4:	0000001c 	andeq	r0, r0, ip, lsl r0
 cd8:	00000a84 	andeq	r0, r0, r4, lsl #21
 cdc:	00002754 	andeq	r2, r0, r4, asr r7
 ce0:	00000048 	andeq	r0, r0, r8, asr #32
    if (line_buff[pos] == '\t' || line_buff[pos] == SPACE)
 ce4:	83180e41 	tsthi	r8, #1040	@ 0x410
 ce8:	85058406 	strhi	r8, [r5, #-1030]	@ 0xfffffbfa
      line_buff[pos] = END_OF_LINE;
 cec:	87038604 	strhi	r8, [r3, -r4, lsl #12]
  while (pos <= length) {
 cf0:	00018e02 	andeq	r8, r1, r2, lsl #28
    if (line_buff[pos] != '\t' && line_buff[pos] != SPACE &&
 cf4:	0000000c 	andeq	r0, r0, ip
 cf8:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 cfc:	7c020001 	stcvc	0, cr0, [r2], {1}
 d00:	000d0c0e 	andeq	r0, sp, lr, lsl #24
      argv[argc++] = &line_buff[pos];
 d04:	0000000c 	andeq	r0, r0, ip
 d08:	00000cf4 	strdeq	r0, [r0], -r4
}
 d0c:	0000279c 	muleq	r0, ip, r7
static int prefix_match(char *sub, int len, const char *str) {
 d10:	0000001e 	andeq	r0, r0, lr, lsl r0
 d14:	0000000c 	andeq	r0, r0, ip
  if (sub == NULL || str == NULL || len <= 0 || len > strlen(str)) {
 d18:	00000cf4 	strdeq	r0, [r0], -r4
 d1c:	000027ba 			@ <UNDEFINED> instruction: 0x000027ba
 d20:	0000003e 	andeq	r0, r0, lr, lsr r0
 d24:	0000000c 	andeq	r0, r0, ip
  for (int i = 0; i<len; ++i) {
 d28:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 d2c:	7c020001 	stcvc	0, cr0, [r2], {1}
    if (sub[i] != str[i]) {
 d30:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 d34:	00000020 	andeq	r0, r0, r0, lsr #32
  for (int i = 0; i<len; ++i) {
 d38:	00000d24 	andeq	r0, r0, r4, lsr #26
}
 d3c:	000027f8 	strdeq	r2, [r0], -r8
  return TRUE;
 d40:	00000040 	andeq	r0, r0, r0, asr #32
      return FALSE;
 d44:	84100e44 	ldrhi	r0, [r0], #-3652	@ 0xfffff1bc
}
 d48:	86038504 	strhi	r8, [r3], -r4, lsl #10
static void handle_up_arrow(char *cmd_buff, int *char_count) {
 d4c:	59018e02 	stmdbpl	r1, {r1, r9, sl, fp, pc}
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
 d50:	c5c4000e 	strbgt	r0, [r4, #14]
 d54:	0000cec6 	andeq	ip, r0, r6, asr #29
 d58:	0000000c 	andeq	r0, r0, ip
 d5c:	00000d24 	andeq	r0, r0, r4, lsr #26
      curr_command_ptr == 0) {
 d60:	00002838 	andeq	r2, r0, r8, lsr r8
  if (curr_command_ptr < total_num_commands - NUM_HISTORY_ENTRIES ||
 d64:	00000040 	andeq	r0, r0, r0, asr #32
    printf("%s", cmd_buff);
 d68:	0000000c 	andeq	r0, r0, ip
 d6c:	00000d24 	andeq	r0, r0, r4, lsr #26
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
 d70:	00002878 	andeq	r2, r0, r8, ror r8
 d74:	0000002c 	andeq	r0, r0, ip, lsr #32
  curr_command_ptr--;
 d78:	0000000c 	andeq	r0, r0, ip
 d7c:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 d80:	7c020001 	stcvc	0, cr0, [r2], {1}
  int index = (curr_command_ptr % NUM_HISTORY_ENTRIES);
 d84:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 d88:	0000000c 	andeq	r0, r0, ip
 d8c:	00000d78 	andeq	r0, r0, r8, ror sp
 d90:	000028a4 	andeq	r2, r0, r4, lsr #17
  memcpy(cmd_buff, &cmd_history[index], LINE_BUFF_SIZE);
 d94:	00000010 	andeq	r0, r0, r0, lsl r0
 d98:	0000000c 	andeq	r0, r0, ip
 d9c:	00000d78 	andeq	r0, r0, r8, ror sp
  *char_count = strlen(cmd_buff);
 da0:	000028b4 			@ <UNDEFINED> instruction: 0x000028b4
 da4:	00000016 	andeq	r0, r0, r6, lsl r0
  printf("%s", cmd_buff);
 da8:	0000000c 	andeq	r0, r0, ip
 dac:	00000d78 	andeq	r0, r0, r8, ror sp
 db0:	000028ca 	andeq	r2, r0, sl, asr #17
 db4:	00000014 	andeq	r0, r0, r4, lsl r0
 db8:	0000000c 	andeq	r0, r0, ip
static void handle_down_arrow(char *cmd_buff, int *char_count) {
 dbc:	00000d78 	andeq	r0, r0, r8, ror sp
 dc0:	000028de 	ldrdeq	r2, [r0], -lr
  memset(cmd_buff, 0, LINE_BUFF_SIZE);
 dc4:	00000016 	andeq	r0, r0, r6, lsl r0
 dc8:	0000000c 	andeq	r0, r0, ip
  *char_count = 0;
 dcc:	00000d78 	andeq	r0, r0, r8, ror sp
  if (curr_command_ptr == total_num_commands) return;
 dd0:	000028f4 	strdeq	r2, [r0], -r4
 dd4:	00000010 	andeq	r0, r0, r0, lsl r0

Disassembly of section .debug_rnglists:

00000000 <.debug_rnglists>:
   0:	00000013 	andeq	r0, r0, r3, lsl r0
   4:	00040005 	andeq	r0, r4, r5
   8:	00000000 	andeq	r0, r0, r0
   c:	b605a404 	strlt	sl, [r5], -r4, lsl #8
  10:	05bc0405 	ldreq	r0, [ip, #1029]!	@ 0x405
  14:	3e0005c2 	cfsh32cc	mvfx0, mvfx0, #-30
  18:	05000000 	streq	r0, [r0, #-0]
  1c:	00000400 	andeq	r0, r0, r0, lsl #8
  20:	04000000 	streq	r0, [r0], #-0
  24:	50044e30 	andpl	r4, r4, r0, lsr lr
  28:	01ca0452 	biceq	r0, sl, r2, asr r4
  2c:	9204028e 	andls	r0, r4, #-536870904	@ 0xe0000008
  30:	0402ba02 	streq	fp, [r2], #-2562	@ 0xfffff5fe
  34:	02dc02c2 	sbcseq	r0, ip, #536870924	@ 0x2000000c
  38:	02920400 	addseq	r0, r2, #0, 8
  3c:	a40402a0 	strge	r0, [r4], #-672	@ 0xfffffd60
  40:	0002b402 	andeq	fp, r2, r2, lsl #8
  44:	01c66204 	biceq	r6, r6, r4, lsl #4
  48:	c202be04 	andgt	fp, r2, #4, 28	@ 0x40
  4c:	ee040002 	cdp	0, 0, cr0, cr4, cr2, {0}
  50:	04048e03 	streq	r8, [r4], #-3587	@ 0xfffff1fd
  54:	04a2049e 	strteq	r0, [r2], #1182	@ 0x49e
  58:	00003e00 	andeq	r3, r0, r0, lsl #28
  5c:	04000500 	streq	r0, [r0], #-1280	@ 0xfffffb00
  60:	00000000 	andeq	r0, r0, r0
  64:	4e300400 	cfabssmi	mvf0, mvf0
  68:	04525004 	ldrbeq	r5, [r2], #-4
  6c:	028e01ca 	addeq	r0, lr, #-2147483598	@ 0x80000032
  70:	ba029204 	blt	a4888 <__ROM_SIZE__+0x64888>
  74:	02c20402 	sbceq	r0, r2, #33554432	@ 0x2000000
  78:	040002dc 	streq	r0, [r0], #-732	@ 0xfffffd24
  7c:	02a00292 	adceq	r0, r0, #536870921	@ 0x20000009
  80:	b402a404 	strlt	sl, [r2], #-1028	@ 0xfffffbfc
  84:	62040002 	andvs	r0, r4, #2
  88:	be0401c6 	adfltdm	f0, f4, f6
  8c:	0002c202 	andeq	ip, r2, r2, lsl #4
  90:	8e03ee04 	cdphi	14, 0, cr14, cr3, cr4, {0}
  94:	049e0404 	ldreq	r0, [lr], #1028	@ 0x404
  98:	110004a2 	smlatbne	r0, r2, r4, r0
  9c:	05000000 	streq	r0, [r0, #-0]
  a0:	00000400 	andeq	r0, r0, r0, lsl #8
  a4:	04000000 	streq	r0, [r0], #-0
  a8:	8a047c78 	bhi	11f290 <__ROM_SIZE__+0xdf290>
  ac:	00019c01 	andeq	r9, r1, r1, lsl #24
  b0:	0000001e 	andeq	r0, r0, lr, lsl r0
  b4:	00040005 	andeq	r0, r4, r5
  b8:	00000000 	andeq	r0, r0, r0
  bc:	d001c404 	andle	ip, r1, r4, lsl #8
  c0:	01d20401 	bicseq	r0, r2, r1, lsl #8
  c4:	040001d8 	streq	r0, [r0], #-472	@ 0xfffffe28
  c8:	02c6029c 	sbceq	r0, r6, #156, 4	@ 0xc0000009
  cc:	cc02c804 	stcgt	8, cr12, [r2], {4}
  d0:	00160002 	andseq	r0, r6, r2
  d4:	00050000 	andeq	r0, r5, r0
  d8:	00000004 	andeq	r0, r0, r4
  dc:	02040000 	andeq	r0, r4, #0
  e0:	1c060404 	cfstrsne	mvf0, [r6], {4}
  e4:	22200400 	eorcs	r0, r0, #0, 8
  e8:	005a2404 	subseq	r2, sl, r4, lsl #8
